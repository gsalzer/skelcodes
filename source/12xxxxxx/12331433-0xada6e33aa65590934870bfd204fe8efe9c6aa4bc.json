{"status":"1","message":"OK","result":[{"SourceCode":"// File @aragon/os/contracts/common/UnstructuredStorage.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\nlibrary UnstructuredStorage {\r\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function setStorageBool(bytes32 position, bool data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n\r\n    function setStorageAddress(bytes32 position, address data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n\r\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n\r\n    function setStorageUint256(bytes32 position, uint256 data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/acl/IACL.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ninterface IACL {\r\n    function initialize(address permissionsCreator) external;\r\n\r\n    // TODO: this should be external\r\n    // See https://github.com/ethereum/solidity/issues/4832\r\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/common/IVaultRecoverable.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ninterface IVaultRecoverable {\r\n    event RecoverToVault(address indexed vault, address indexed token, uint256 amount);\r\n\r\n    function transferToVault(address token) external;\r\n\r\n    function allowRecoverability(address token) external view returns (bool);\r\n    function getRecoveryVault() external view returns (address);\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/kernel/IKernel.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ninterface IKernelEvents {\r\n    event SetApp(bytes32 indexed namespace, bytes32 indexed appId, address app);\r\n}\r\n\r\n\r\n// This should be an interface, but interfaces can't inherit yet :(\r\ncontract IKernel is IKernelEvents, IVaultRecoverable {\r\n    function acl() public view returns (IACL);\r\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\r\n\r\n    function setApp(bytes32 namespace, bytes32 appId, address app) public;\r\n    function getApp(bytes32 namespace, bytes32 appId) public view returns (address);\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/apps/AppStorage.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract AppStorage {\r\n    using UnstructuredStorage for bytes32;\r\n\r\n    /* Hardcoded constants to save gas\r\n    bytes32 internal constant KERNEL_POSITION = keccak256(\"aragonOS.appStorage.kernel\");\r\n    bytes32 internal constant APP_ID_POSITION = keccak256(\"aragonOS.appStorage.appId\");\r\n    */\r\n    bytes32 internal constant KERNEL_POSITION = 0x4172f0f7d2289153072b0a6ca36959e0cbe2efc3afe50fc81636caa96338137b;\r\n    bytes32 internal constant APP_ID_POSITION = 0xd625496217aa6a3453eecb9c3489dc5a53e6c67b444329ea2b2cbc9ff547639b;\r\n\r\n    function kernel() public view returns (IKernel) {\r\n        return IKernel(KERNEL_POSITION.getStorageAddress());\r\n    }\r\n\r\n    function appId() public view returns (bytes32) {\r\n        return APP_ID_POSITION.getStorageBytes32();\r\n    }\r\n\r\n    function setKernel(IKernel _kernel) internal {\r\n        KERNEL_POSITION.setStorageAddress(address(_kernel));\r\n    }\r\n\r\n    function setAppId(bytes32 _appId) internal {\r\n        APP_ID_POSITION.setStorageBytes32(_appId);\r\n    }\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/acl/ACLSyntaxSugar.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract ACLSyntaxSugar {\r\n    function arr() internal pure returns (uint256[]) {\r\n        return new uint256[](0);\r\n    }\r\n\r\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a));\r\n    }\r\n\r\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a), uint256(_b));\r\n    }\r\n\r\n    function arr(address _a) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a));\r\n    }\r\n\r\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a), uint256(_b));\r\n    }\r\n\r\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a), _b, _c);\r\n    }\r\n\r\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a), _b, _c, _d);\r\n    }\r\n\r\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a), uint256(_b));\r\n    }\r\n\r\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\r\n    }\r\n\r\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a), uint256(_b), uint256(_c));\r\n    }\r\n\r\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\r\n        return arr(uint256(_a), uint256(_b), uint256(_c));\r\n    }\r\n\r\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\r\n        r = new uint256[](1);\r\n        r[0] = _a;\r\n    }\r\n\r\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\r\n        r = new uint256[](2);\r\n        r[0] = _a;\r\n        r[1] = _b;\r\n    }\r\n\r\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\r\n        r = new uint256[](3);\r\n        r[0] = _a;\r\n        r[1] = _b;\r\n        r[2] = _c;\r\n    }\r\n\r\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\r\n        r = new uint256[](4);\r\n        r[0] = _a;\r\n        r[1] = _b;\r\n        r[2] = _c;\r\n        r[3] = _d;\r\n    }\r\n\r\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\r\n        r = new uint256[](5);\r\n        r[0] = _a;\r\n        r[1] = _b;\r\n        r[2] = _c;\r\n        r[3] = _d;\r\n        r[4] = _e;\r\n    }\r\n}\r\n\r\n\r\ncontract ACLHelpers {\r\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\r\n        return uint8(_x >> (8 * 30));\r\n    }\r\n\r\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\r\n        return uint8(_x >> (8 * 31));\r\n    }\r\n\r\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\r\n        a = uint32(_x);\r\n        b = uint32(_x >> (8 * 4));\r\n        c = uint32(_x >> (8 * 8));\r\n    }\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/common/Uint256Helpers.sol@v4.4.0\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\nlibrary Uint256Helpers {\r\n    uint256 private constant MAX_UINT64 = uint64(-1);\r\n\r\n    string private constant ERROR_NUMBER_TOO_BIG = \"UINT64_NUMBER_TOO_BIG\";\r\n\r\n    function toUint64(uint256 a) internal pure returns (uint64) {\r\n        require(a <= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\r\n        return uint64(a);\r\n    }\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/common/TimeHelpers.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract TimeHelpers {\r\n    using Uint256Helpers for uint256;\r\n\r\n    /**\r\n    * @dev Returns the current block number.\r\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\r\n    *      tests.\r\n    */\r\n    function getBlockNumber() internal view returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current block number, converted to uint64.\r\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\r\n    *      tests.\r\n    */\r\n    function getBlockNumber64() internal view returns (uint64) {\r\n        return getBlockNumber().toUint64();\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current timestamp.\r\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\r\n    *      tests.\r\n    */\r\n    function getTimestamp() internal view returns (uint256) {\r\n        return block.timestamp; // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current timestamp, converted to uint64.\r\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\r\n    *      tests.\r\n    */\r\n    function getTimestamp64() internal view returns (uint64) {\r\n        return getTimestamp().toUint64();\r\n    }\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/common/Initializable.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract Initializable is TimeHelpers {\r\n    using UnstructuredStorage for bytes32;\r\n\r\n    // keccak256(\"aragonOS.initializable.initializationBlock\")\r\n    bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;\r\n\r\n    string private constant ERROR_ALREADY_INITIALIZED = \"INIT_ALREADY_INITIALIZED\";\r\n    string private constant ERROR_NOT_INITIALIZED = \"INIT_NOT_INITIALIZED\";\r\n\r\n    modifier onlyInit {\r\n        require(getInitializationBlock() == 0, ERROR_ALREADY_INITIALIZED);\r\n        _;\r\n    }\r\n\r\n    modifier isInitialized {\r\n        require(hasInitialized(), ERROR_NOT_INITIALIZED);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @return Block number in which the contract was initialized\r\n    */\r\n    function getInitializationBlock() public view returns (uint256) {\r\n        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\r\n    }\r\n\r\n    /**\r\n    * @return Whether the contract has been initialized by the time of the current block\r\n    */\r\n    function hasInitialized() public view returns (bool) {\r\n        uint256 initializationBlock = getInitializationBlock();\r\n        return initializationBlock != 0 && getBlockNumber() >= initializationBlock;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to be called by top level contract after initialization has finished.\r\n    */\r\n    function initialized() internal onlyInit {\r\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\r\n    }\r\n\r\n    /**\r\n    * @dev Function to be called by top level contract after initialization to enable the contract\r\n    *      at a future block number rather than immediately.\r\n    */\r\n    function initializedAt(uint256 _blockNumber) internal onlyInit {\r\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\r\n    }\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/common/Petrifiable.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract Petrifiable is Initializable {\r\n    // Use block UINT256_MAX (which should be never) as the initializable date\r\n    uint256 internal constant PETRIFIED_BLOCK = uint256(-1);\r\n\r\n    function isPetrified() public view returns (bool) {\r\n        return getInitializationBlock() == PETRIFIED_BLOCK;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to be called by top level contract to prevent being initialized.\r\n    *      Useful for freezing base contracts when they're used behind proxies.\r\n    */\r\n    function petrify() internal onlyInit {\r\n        initializedAt(PETRIFIED_BLOCK);\r\n    }\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/common/Autopetrified.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract Autopetrified is Petrifiable {\r\n    constructor() public {\r\n        // Immediately petrify base (non-proxy) instances of inherited contracts on deploy.\r\n        // This renders them uninitializable (and unusable without a proxy).\r\n        petrify();\r\n    }\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/common/ConversionHelpers.sol@v4.4.0\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\nlibrary ConversionHelpers {\r\n    string private constant ERROR_IMPROPER_LENGTH = \"CONVERSION_IMPROPER_LENGTH\";\r\n\r\n    function dangerouslyCastUintArrayToBytes(uint256[] memory _input) internal pure returns (bytes memory output) {\r\n        // Force cast the uint256[] into a bytes array, by overwriting its length\r\n        // Note that the bytes array doesn't need to be initialized as we immediately overwrite it\r\n        // with the input and a new length. The input becomes invalid from this point forward.\r\n        uint256 byteLength = _input.length * 32;\r\n        assembly {\r\n            output := _input\r\n            mstore(output, byteLength)\r\n        }\r\n    }\r\n\r\n    function dangerouslyCastBytesToUintArray(bytes memory _input) internal pure returns (uint256[] memory output) {\r\n        // Force cast the bytes array into a uint256[], by overwriting its length\r\n        // Note that the uint256[] doesn't need to be initialized as we immediately overwrite it\r\n        // with the input and a new length. The input becomes invalid from this point forward.\r\n        uint256 intsLength = _input.length / 32;\r\n        require(_input.length == intsLength * 32, ERROR_IMPROPER_LENGTH);\r\n\r\n        assembly {\r\n            output := _input\r\n            mstore(output, intsLength)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/common/ReentrancyGuard.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract ReentrancyGuard {\r\n    using UnstructuredStorage for bytes32;\r\n\r\n    /* Hardcoded constants to save gas\r\n    bytes32 internal constant REENTRANCY_MUTEX_POSITION = keccak256(\"aragonOS.reentrancyGuard.mutex\");\r\n    */\r\n    bytes32 private constant REENTRANCY_MUTEX_POSITION = 0xe855346402235fdd185c890e68d2c4ecad599b88587635ee285bce2fda58dacb;\r\n\r\n    string private constant ERROR_REENTRANT = \"REENTRANCY_REENTRANT_CALL\";\r\n\r\n    modifier nonReentrant() {\r\n        // Ensure mutex is unlocked\r\n        require(!REENTRANCY_MUTEX_POSITION.getStorageBool(), ERROR_REENTRANT);\r\n\r\n        // Lock mutex before function call\r\n        REENTRANCY_MUTEX_POSITION.setStorageBool(true);\r\n\r\n        // Perform function call\r\n        _;\r\n\r\n        // Unlock mutex after function call\r\n        REENTRANCY_MUTEX_POSITION.setStorageBool(false);\r\n    }\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/lib/token/ERC20.sol@v4.4.0\r\n\r\n// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a9f910d34f0ab33a1ae5e714f69f9596a02b4d91/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address _who) public view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        public view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value)\r\n        public returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public returns (bool);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/common/EtherTokenConstant.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n// aragonOS and aragon-apps rely on address(0) to denote native ETH, in\r\n// contracts where both tokens and ETH are accepted\r\ncontract EtherTokenConstant {\r\n    address internal constant ETH = address(0);\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/common/IsContract.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract IsContract {\r\n    /*\r\n    * NOTE: this should NEVER be used for authentication\r\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\r\n    *\r\n    * This is only intended to be used as a sanity check that an address is actually a contract,\r\n    * RATHER THAN an address not being a contract.\r\n    */\r\n    function isContract(address _target) internal view returns (bool) {\r\n        if (_target == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 size;\r\n        assembly { size := extcodesize(_target) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/common/SafeERC20.sol@v4.4.0\r\n\r\n// Inspired by AdEx (https://github.com/AdExNetwork/adex-protocol-eth/blob/b9df617829661a7518ee10f4cb6c4108659dd6d5/contracts/libs/SafeERC20.sol)\r\n// and 0x (https://github.com/0xProject/0x-monorepo/blob/737d1dc54d72872e24abce5a1dbe1b66d35fa21a/contracts/protocol/contracts/protocol/AssetProxy/ERC20Proxy.sol#L143)\r\n\r\npragma solidity ^0.4.24;\r\n\r\nlibrary SafeERC20 {\r\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\r\n    // https://github.com/ethereum/solidity/issues/3544\r\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\r\n\r\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = \"SAFE_ERC_20_BALANCE_REVERTED\";\r\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = \"SAFE_ERC_20_ALLOWANCE_REVERTED\";\r\n\r\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\r\n        private\r\n        returns (bool)\r\n    {\r\n        bool ret;\r\n        assembly {\r\n            let ptr := mload(0x40)    // free memory pointer\r\n\r\n            let success := call(\r\n                gas,                  // forward all gas\r\n                _addr,                // address\r\n                0,                    // no value\r\n                add(_calldata, 0x20), // calldata start\r\n                mload(_calldata),     // calldata length\r\n                ptr,                  // write output over free memory\r\n                0x20                  // uint256 return\r\n            )\r\n\r\n            if gt(success, 0) {\r\n                // Check number of bytes returned from last function call\r\n                switch returndatasize\r\n\r\n                // No bytes returned: assume success\r\n                case 0 {\r\n                    ret := 1\r\n                }\r\n\r\n                // 32 bytes returned: check if non-zero\r\n                case 0x20 {\r\n                    // Only return success if returned data was true\r\n                    // Already have output in ptr\r\n                    ret := eq(mload(ptr), 1)\r\n                }\r\n\r\n                // Not sure what was returned: don't mark as success\r\n                default { }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    function staticInvoke(address _addr, bytes memory _calldata)\r\n        private\r\n        view\r\n        returns (bool, uint256)\r\n    {\r\n        bool success;\r\n        uint256 ret;\r\n        assembly {\r\n            let ptr := mload(0x40)    // free memory pointer\r\n\r\n            success := staticcall(\r\n                gas,                  // forward all gas\r\n                _addr,                // address\r\n                add(_calldata, 0x20), // calldata start\r\n                mload(_calldata),     // calldata length\r\n                ptr,                  // write output over free memory\r\n                0x20                  // uint256 return\r\n            )\r\n\r\n            if gt(success, 0) {\r\n                ret := mload(ptr)\r\n            }\r\n        }\r\n        return (success, ret);\r\n    }\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\r\n        bytes memory transferCallData = abi.encodeWithSelector(\r\n            TRANSFER_SELECTOR,\r\n            _to,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(_token, transferCallData);\r\n    }\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\r\n        bytes memory transferFromCallData = abi.encodeWithSelector(\r\n            _token.transferFrom.selector,\r\n            _from,\r\n            _to,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(_token, transferFromCallData);\r\n    }\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\r\n        bytes memory approveCallData = abi.encodeWithSelector(\r\n            _token.approve.selector,\r\n            _spender,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(_token, approveCallData);\r\n    }\r\n\r\n    /**\r\n    * @dev Static call into ERC20.balanceOf().\r\n    * Reverts if the call fails for some reason (should never fail).\r\n    */\r\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\r\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\r\n            _token.balanceOf.selector,\r\n            _owner\r\n        );\r\n\r\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\r\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\r\n\r\n        return tokenBalance;\r\n    }\r\n\r\n    /**\r\n    * @dev Static call into ERC20.allowance().\r\n    * Reverts if the call fails for some reason (should never fail).\r\n    */\r\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\r\n        bytes memory allowanceCallData = abi.encodeWithSelector(\r\n            _token.allowance.selector,\r\n            _owner,\r\n            _spender\r\n        );\r\n\r\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\r\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\r\n\r\n        return allowance;\r\n    }\r\n\r\n    /**\r\n    * @dev Static call into ERC20.totalSupply().\r\n    * Reverts if the call fails for some reason (should never fail).\r\n    */\r\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\r\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\r\n\r\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\r\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\r\n\r\n        return totalSupply;\r\n    }\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/common/VaultRecoverable.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\ncontract VaultRecoverable is IVaultRecoverable, EtherTokenConstant, IsContract {\r\n    using SafeERC20 for ERC20;\r\n\r\n    string private constant ERROR_DISALLOWED = \"RECOVER_DISALLOWED\";\r\n    string private constant ERROR_VAULT_NOT_CONTRACT = \"RECOVER_VAULT_NOT_CONTRACT\";\r\n    string private constant ERROR_TOKEN_TRANSFER_FAILED = \"RECOVER_TOKEN_TRANSFER_FAILED\";\r\n\r\n    /**\r\n     * @notice Send funds to recovery Vault. This contract should never receive funds,\r\n     *         but in case it does, this function allows one to recover them.\r\n     * @param _token Token balance to be sent to recovery vault.\r\n     */\r\n    function transferToVault(address _token) external {\r\n        require(allowRecoverability(_token), ERROR_DISALLOWED);\r\n        address vault = getRecoveryVault();\r\n        require(isContract(vault), ERROR_VAULT_NOT_CONTRACT);\r\n\r\n        uint256 balance;\r\n        if (_token == ETH) {\r\n            balance = address(this).balance;\r\n            vault.transfer(balance);\r\n        } else {\r\n            ERC20 token = ERC20(_token);\r\n            balance = token.staticBalanceOf(this);\r\n            require(token.safeTransfer(vault, balance), ERROR_TOKEN_TRANSFER_FAILED);\r\n        }\r\n\r\n        emit RecoverToVault(vault, _token, balance);\r\n    }\r\n\r\n    /**\r\n    * @dev By default deriving from AragonApp makes it recoverable\r\n    * @param token Token address that would be recovered\r\n    * @return bool whether the app allows the recovery\r\n    */\r\n    function allowRecoverability(address token) public view returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    // Cast non-implemented interface to be public so we can use it internally\r\n    function getRecoveryVault() public view returns (address);\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/evmscript/IEVMScriptExecutor.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ninterface IEVMScriptExecutor {\r\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\r\n    function executorType() external pure returns (bytes32);\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/evmscript/IEVMScriptRegistry.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract EVMScriptRegistryConstants {\r\n    /* Hardcoded constants to save gas\r\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = apmNamehash(\"evmreg\");\r\n    */\r\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = 0xddbcfd564f642ab5627cf68b9b7d374fb4f8a36e941a75d89c87998cef03bd61;\r\n}\r\n\r\n\r\ninterface IEVMScriptRegistry {\r\n    function addScriptExecutor(IEVMScriptExecutor executor) external returns (uint id);\r\n    function disableScriptExecutor(uint256 executorId) external;\r\n\r\n    // TODO: this should be external\r\n    // See https://github.com/ethereum/solidity/issues/4832\r\n    function getScriptExecutor(bytes script) public view returns (IEVMScriptExecutor);\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/kernel/KernelConstants.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract KernelAppIds {\r\n    /* Hardcoded constants to save gas\r\n    bytes32 internal constant KERNEL_CORE_APP_ID = apmNamehash(\"kernel\");\r\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = apmNamehash(\"acl\");\r\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = apmNamehash(\"vault\");\r\n    */\r\n    bytes32 internal constant KERNEL_CORE_APP_ID = 0x3b4bf6bf3ad5000ecf0f989d5befde585c6860fea3e574a4fab4c49d1c177d9c;\r\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = 0xe3262375f45a6e2026b7e7b18c2b807434f2508fe1a2a3dfb493c7df8f4aad6a;\r\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = 0x7e852e0fcfce6551c13800f1e7476f982525c2b5277ba14b24339c68416336d1;\r\n}\r\n\r\n\r\ncontract KernelNamespaceConstants {\r\n    /* Hardcoded constants to save gas\r\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = keccak256(\"core\");\r\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = keccak256(\"base\");\r\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = keccak256(\"app\");\r\n    */\r\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = 0xc681a85306374a5ab27f0bbc385296a54bcd314a1948b6cf61c4ea1bc44bb9f8;\r\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = 0xf1f3eb40f5bc1ad1344716ced8b8a0431d840b5783aea1fd01786bc26f35ac0f;\r\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb;\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/evmscript/EVMScriptRunner.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\ncontract EVMScriptRunner is AppStorage, Initializable, EVMScriptRegistryConstants, KernelNamespaceConstants {\r\n    string private constant ERROR_EXECUTOR_UNAVAILABLE = \"EVMRUN_EXECUTOR_UNAVAILABLE\";\r\n    string private constant ERROR_PROTECTED_STATE_MODIFIED = \"EVMRUN_PROTECTED_STATE_MODIFIED\";\r\n\r\n    /* This is manually crafted in assembly\r\n    string private constant ERROR_EXECUTOR_INVALID_RETURN = \"EVMRUN_EXECUTOR_INVALID_RETURN\";\r\n    */\r\n\r\n    event ScriptResult(address indexed executor, bytes script, bytes input, bytes returnData);\r\n\r\n    function getEVMScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\r\n        return IEVMScriptExecutor(getEVMScriptRegistry().getScriptExecutor(_script));\r\n    }\r\n\r\n    function getEVMScriptRegistry() public view returns (IEVMScriptRegistry) {\r\n        address registryAddr = kernel().getApp(KERNEL_APP_ADDR_NAMESPACE, EVMSCRIPT_REGISTRY_APP_ID);\r\n        return IEVMScriptRegistry(registryAddr);\r\n    }\r\n\r\n    function runScript(bytes _script, bytes _input, address[] _blacklist)\r\n        internal\r\n        isInitialized\r\n        protectState\r\n        returns (bytes)\r\n    {\r\n        IEVMScriptExecutor executor = getEVMScriptExecutor(_script);\r\n        require(address(executor) != address(0), ERROR_EXECUTOR_UNAVAILABLE);\r\n\r\n        bytes4 sig = executor.execScript.selector;\r\n        bytes memory data = abi.encodeWithSelector(sig, _script, _input, _blacklist);\r\n\r\n        bytes memory output;\r\n        assembly {\r\n            let success := delegatecall(\r\n                gas,                // forward all gas\r\n                executor,           // address\r\n                add(data, 0x20),    // calldata start\r\n                mload(data),        // calldata length\r\n                0,                  // don't write output (we'll handle this ourselves)\r\n                0                   // don't write output\r\n            )\r\n\r\n            output := mload(0x40) // free mem ptr get\r\n\r\n            switch success\r\n            case 0 {\r\n                // If the call errored, forward its full error data\r\n                returndatacopy(output, 0, returndatasize)\r\n                revert(output, returndatasize)\r\n            }\r\n            default {\r\n                switch gt(returndatasize, 0x3f)\r\n                case 0 {\r\n                    // Need at least 0x40 bytes returned for properly ABI-encoded bytes values,\r\n                    // revert with \"EVMRUN_EXECUTOR_INVALID_RETURN\"\r\n                    // See remix: doing a `revert(\"EVMRUN_EXECUTOR_INVALID_RETURN\")` always results in\r\n                    // this memory layout\r\n                    mstore(output, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\r\n                    mstore(add(output, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\r\n                    mstore(add(output, 0x24), 0x000000000000000000000000000000000000000000000000000000000000001e) // reason length\r\n                    mstore(add(output, 0x44), 0x45564d52554e5f4558454355544f525f494e56414c49445f52455455524e0000) // reason\r\n\r\n                    revert(output, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\r\n                }\r\n                default {\r\n                    // Copy result\r\n                    //\r\n                    // Needs to perform an ABI decode for the expected `bytes` return type of\r\n                    // `executor.execScript()` as solidity will automatically ABI encode the returned bytes as:\r\n                    //    [ position of the first dynamic length return value = 0x20 (32 bytes) ]\r\n                    //    [ output length (32 bytes) ]\r\n                    //    [ output content (N bytes) ]\r\n                    //\r\n                    // Perform the ABI decode by ignoring the first 32 bytes of the return data\r\n                    let copysize := sub(returndatasize, 0x20)\r\n                    returndatacopy(output, 0x20, copysize)\r\n\r\n                    mstore(0x40, add(output, copysize)) // free mem ptr set\r\n                }\r\n            }\r\n        }\r\n\r\n        emit ScriptResult(address(executor), _script, _input, output);\r\n\r\n        return output;\r\n    }\r\n\r\n    modifier protectState {\r\n        address preKernel = address(kernel());\r\n        bytes32 preAppId = appId();\r\n        _; // exec\r\n        require(address(kernel()) == preKernel, ERROR_PROTECTED_STATE_MODIFIED);\r\n        require(appId() == preAppId, ERROR_PROTECTED_STATE_MODIFIED);\r\n    }\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/apps/AragonApp.sol@v4.4.0\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Contracts inheriting from AragonApp are, by default, immediately petrified upon deployment so\r\n// that they can never be initialized.\r\n// Unless overriden, this behaviour enforces those contracts to be usable only behind an AppProxy.\r\n// ReentrancyGuard, EVMScriptRunner, and ACLSyntaxSugar are not directly used by this contract, but\r\n// are included so that they are automatically usable by subclassing contracts\r\ncontract AragonApp is AppStorage, Autopetrified, VaultRecoverable, ReentrancyGuard, EVMScriptRunner, ACLSyntaxSugar {\r\n    string private constant ERROR_AUTH_FAILED = \"APP_AUTH_FAILED\";\r\n\r\n    modifier auth(bytes32 _role) {\r\n        require(canPerform(msg.sender, _role, new uint256[](0)), ERROR_AUTH_FAILED);\r\n        _;\r\n    }\r\n\r\n    modifier authP(bytes32 _role, uint256[] _params) {\r\n        require(canPerform(msg.sender, _role, _params), ERROR_AUTH_FAILED);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Check whether an action can be performed by a sender for a particular role on this app\r\n    * @param _sender Sender of the call\r\n    * @param _role Role on this app\r\n    * @param _params Permission params for the role\r\n    * @return Boolean indicating whether the sender has the permissions to perform the action.\r\n    *         Always returns false if the app hasn't been initialized yet.\r\n    */\r\n    function canPerform(address _sender, bytes32 _role, uint256[] _params) public view returns (bool) {\r\n        if (!hasInitialized()) {\r\n            return false;\r\n        }\r\n\r\n        IKernel linkedKernel = kernel();\r\n        if (address(linkedKernel) == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        return linkedKernel.hasPermission(\r\n            _sender,\r\n            address(this),\r\n            _role,\r\n            ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Get the recovery vault for the app\r\n    * @return Recovery vault address for the app\r\n    */\r\n    function getRecoveryVault() public view returns (address) {\r\n        // Funds recovery via a vault is only available when used with a kernel\r\n        return kernel().getRecoveryVault(); // if kernel is not set, it will revert\r\n    }\r\n}\r\n\r\n\r\n// File @aragon/os/contracts/lib/math/SafeMath.sol@v4.4.0\r\n\r\n// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d51e38758e1d985661534534d5c61e27bece5042/contracts/math/SafeMath.sol\r\n// Adapted to use pragma ^0.4.24 and satisfy our linter rules\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    string private constant ERROR_ADD_OVERFLOW = \"MATH_ADD_OVERFLOW\";\r\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH_SUB_UNDERFLOW\";\r\n    string private constant ERROR_MUL_OVERFLOW = \"MATH_MUL_OVERFLOW\";\r\n    string private constant ERROR_DIV_ZERO = \"MATH_DIV_ZERO\";\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a, ERROR_ADD_OVERFLOW);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, ERROR_DIV_ZERO);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/0.4.24/interfaces/IBeaconReportReceiver.sol\r\n\r\n// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n  * @title Interface defining a callback that the quorum will call on every quorum reached\r\n  */\r\ninterface IBeaconReportReceiver {\r\n    /**\r\n      * @notice Callback to be called by the oracle contract upon the quorum is reached\r\n      * @param _postTotalPooledEther total pooled ether on Lido right after the quorum value was reported\r\n      * @param _preTotalPooledEther total pooled ether on Lido right before the quorum value was reported\r\n      * @param _timeElapsed time elapsed in seconds between the last and the previous quorum\r\n      */\r\n    function processLidoOracleReport(uint256 _postTotalPooledEther,\r\n                                     uint256 _preTotalPooledEther,\r\n                                     uint256 _timeElapsed) external;\r\n}\r\n\r\n\r\n// File contracts/0.4.24/interfaces/ILido.sol\r\n\r\n// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n  * @title Liquid staking pool\r\n  *\r\n  * For the high-level description of the pool operation please refer to the paper.\r\n  * Pool manages withdrawal keys and fees. It receives ether submitted by users on the ETH 1 side\r\n  * and stakes it via the deposit_contract.sol contract. It doesn't hold ether on it's balance,\r\n  * only a small portion (buffer) of it.\r\n  * It also mints new tokens for rewards generated at the ETH 2.0 side.\r\n  */\r\ninterface ILido {\r\n    /**\r\n     * @dev From ISTETH interface, because \"Interfaces cannot inherit\".\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n    function getTotalShares() external view returns (uint256);\r\n\r\n    /**\r\n      * @notice Stop pool routine operations\r\n      */\r\n    function stop() external;\r\n\r\n    /**\r\n      * @notice Resume pool routine operations\r\n      */\r\n    function resume() external;\r\n\r\n    event Stopped();\r\n    event Resumed();\r\n\r\n\r\n    /**\r\n      * @notice Set fee rate to `_feeBasisPoints` basis points. The fees are accrued when oracles report staking results\r\n      * @param _feeBasisPoints Fee rate, in basis points\r\n      */\r\n    function setFee(uint16 _feeBasisPoints) external;\r\n\r\n    /**\r\n      * @notice Set fee distribution: `_treasuryFeeBasisPoints` basis points go to the treasury, `_insuranceFeeBasisPoints` basis points go to the insurance fund, `_operatorsFeeBasisPoints` basis points go to node operators. The sum has to be 10 000.\r\n      */\r\n    function setFeeDistribution(\r\n        uint16 _treasuryFeeBasisPoints,\r\n        uint16 _insuranceFeeBasisPoints,\r\n        uint16 _operatorsFeeBasisPoints)\r\n        external;\r\n\r\n    /**\r\n      * @notice Returns staking rewards fee rate\r\n      */\r\n    function getFee() external view returns (uint16 feeBasisPoints);\r\n\r\n    /**\r\n      * @notice Returns fee distribution proportion\r\n      */\r\n    function getFeeDistribution() external view returns (uint16 treasuryFeeBasisPoints, uint16 insuranceFeeBasisPoints,\r\n                                                         uint16 operatorsFeeBasisPoints);\r\n\r\n    event FeeSet(uint16 feeBasisPoints);\r\n\r\n    event FeeDistributionSet(uint16 treasuryFeeBasisPoints, uint16 insuranceFeeBasisPoints, uint16 operatorsFeeBasisPoints);\r\n\r\n\r\n    /**\r\n      * @notice Set credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched to `_withdrawalCredentials`\r\n      * @dev Note that setWithdrawalCredentials discards all unused signing keys as the signatures are invalidated.\r\n      * @param _withdrawalCredentials hash of withdrawal multisignature key as accepted by\r\n      *        the deposit_contract.deposit function\r\n      */\r\n    function setWithdrawalCredentials(bytes32 _withdrawalCredentials) external;\r\n\r\n    /**\r\n      * @notice Returns current credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched\r\n      */\r\n    function getWithdrawalCredentials() external view returns (bytes);\r\n\r\n\r\n    event WithdrawalCredentialsSet(bytes32 withdrawalCredentials);\r\n\r\n\r\n    /**\r\n      * @notice Ether on the ETH 2.0 side reported by the oracle\r\n      * @param _epoch Epoch id\r\n      * @param _eth2balance Balance in wei on the ETH 2.0 side\r\n      */\r\n    function pushBeacon(uint256 _epoch, uint256 _eth2balance) external;\r\n\r\n\r\n    // User functions\r\n\r\n    /**\r\n      * @notice Adds eth to the pool\r\n      * @return StETH Amount of StETH generated\r\n      */\r\n    function submit(address _referral) external payable returns (uint256 StETH);\r\n\r\n    // Records a deposit made by a user\r\n    event Submitted(address indexed sender, uint256 amount, address referral);\r\n\r\n    // The `_amount` of ether was sent to the deposit_contract.deposit function.\r\n    event Unbuffered(uint256 amount);\r\n\r\n    /**\r\n      * @notice Issues withdrawal request. Large withdrawals will be processed only after the phase 2 launch.\r\n      * @param _amount Amount of StETH to burn\r\n      * @param _pubkeyHash Receiving address\r\n      */\r\n    function withdraw(uint256 _amount, bytes32 _pubkeyHash) external;\r\n\r\n    // Requested withdrawal of `etherAmount` to `pubkeyHash` on the ETH 2.0 side, `tokenAmount` burned by `sender`,\r\n    // `sentFromBuffer` was sent on the current Ethereum side.\r\n    event Withdrawal(address indexed sender, uint256 tokenAmount, uint256 sentFromBuffer,\r\n                     bytes32 indexed pubkeyHash, uint256 etherAmount);\r\n\r\n\r\n    // Info functions\r\n\r\n    /**\r\n      * @notice Gets the amount of Ether controlled by the system\r\n      */\r\n    function getTotalPooledEther() external view returns (uint256);\r\n\r\n    /**\r\n      * @notice Gets the amount of Ether temporary buffered on this contract balance\r\n      */\r\n    function getBufferedEther() external view returns (uint256);\r\n\r\n    /**\r\n      * @notice Returns the key values related to Beacon-side\r\n      * @return depositedValidators - number of deposited validators\r\n      * @return beaconValidators - number of Lido's validators visible in the Beacon state, reported by oracles\r\n      * @return beaconBalance - total amount of Beacon-side Ether (sum of all the balances of Lido validators)\r\n      */\r\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance);\r\n}\r\n\r\n\r\n// File contracts/0.4.24/interfaces/ILidoOracle.sol\r\n\r\n// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity 0.4.24;\r\n\r\n/**\r\n * @title ETH 2.0 -> ETH oracle\r\n *\r\n * The goal of the oracle is to inform other parts of the system about balances controlled by the\r\n * DAO on the ETH 2.0 side. The balances can go up because of reward accumulation and can go down\r\n * because of slashing.\r\n */\r\ninterface ILidoOracle {\r\n    event AllowedBeaconBalanceAnnualRelativeIncreaseSet(uint256 value);\r\n    event AllowedBeaconBalanceRelativeDecreaseSet(uint256 value);\r\n    event BeaconReportReceiverSet(address callback);\r\n    event MemberAdded(address member);\r\n    event MemberRemoved(address member);\r\n    event QuorumChanged(uint256 quorum);\r\n    event ExpectedEpochIdUpdated(uint256 epochId);\r\n    event BeaconSpecSet(\r\n        uint64 epochsPerFrame,\r\n        uint64 slotsPerEpoch,\r\n        uint64 secondsPerSlot,\r\n        uint64 genesisTime\r\n    );\r\n    event BeaconReported(\r\n        uint256 epochId,\r\n        uint128 beaconBalance,\r\n        uint128 beaconValidators,\r\n        address caller\r\n    );\r\n    event Completed(\r\n        uint256 epochId,\r\n        uint128 beaconBalance,\r\n        uint128 beaconValidators\r\n    );\r\n    event PostTotalShares(\r\n         uint256 postTotalPooledEther,\r\n         uint256 preTotalPooledEther,\r\n         uint256 timeElapsed,\r\n         uint256 totalShares);\r\n    event ContractVersionSet(uint256 version);\r\n\r\n    /**\r\n     * @notice Return the Lido contract address\r\n     */\r\n    function getLido() public view returns (ILido);\r\n\r\n    /**\r\n     * @notice Return the number of exactly the same reports needed to finalize the epoch\r\n     */\r\n    function getQuorum() public view returns (uint256);\r\n\r\n    /**\r\n     * @notice Return the upper bound of the reported balance possible increase in APR\r\n     */\r\n    function getAllowedBeaconBalanceAnnualRelativeIncrease() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Return the lower bound of the reported balance possible decrease\r\n     */\r\n    function getAllowedBeaconBalanceRelativeDecrease() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Set the upper bound of the reported balance possible increase in APR to `_value`\r\n     */\r\n    function setAllowedBeaconBalanceAnnualRelativeIncrease(uint256 _value) external;\r\n\r\n    /**\r\n     * @notice Set the lower bound of the reported balance possible decrease to `_value`\r\n     */\r\n    function setAllowedBeaconBalanceRelativeDecrease(uint256 _value) external;\r\n\r\n    /**\r\n     * @notice Return the receiver contract address to be called when the report is pushed to Lido\r\n     */\r\n    function getBeaconReportReceiver() external view returns (address);\r\n\r\n    /**\r\n     * @notice Set the receiver contract address to be called when the report is pushed to Lido\r\n     */\r\n    function setBeaconReportReceiver(address _addr) external;\r\n\r\n    /**\r\n     * @notice Return the current reporting bitmap, representing oracles who have already pushed\r\n     * their version of report during the expected epoch\r\n     */\r\n    function getCurrentOraclesReportStatus() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Return the current reporting array size\r\n     */\r\n    function getCurrentReportVariantsSize() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Return the current reporting array element with the given index\r\n     */\r\n    function getCurrentReportVariant(uint256 _index)\r\n        external\r\n        view\r\n        returns (\r\n            uint64 beaconBalance,\r\n            uint32 beaconValidators,\r\n            uint16 count\r\n        );\r\n\r\n    /**\r\n     * @notice Return epoch that can be reported by oracles\r\n     */\r\n    function getExpectedEpochId() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Return the current oracle member committee list\r\n     */\r\n    function getOracleMembers() external view returns (address[]);\r\n\r\n    /**\r\n     * @notice Return the initialized version of this contract starting from 0\r\n     */\r\n    function getVersion() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Return beacon specification data\r\n     */\r\n    function getBeaconSpec()\r\n        external\r\n        view\r\n        returns (\r\n            uint64 epochsPerFrame,\r\n            uint64 slotsPerEpoch,\r\n            uint64 secondsPerSlot,\r\n            uint64 genesisTime\r\n        );\r\n\r\n    /**\r\n     * Updates beacon specification data\r\n     */\r\n    function setBeaconSpec(\r\n        uint64 _epochsPerFrame,\r\n        uint64 _slotsPerEpoch,\r\n        uint64 _secondsPerSlot,\r\n        uint64 _genesisTime\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Returns the epoch calculated from current timestamp\r\n     */\r\n    function getCurrentEpochId() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Return currently reportable epoch (the first epoch of the current frame) as well as\r\n     * its start and end times in seconds\r\n     */\r\n    function getCurrentFrame()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 frameEpochId,\r\n            uint256 frameStartTime,\r\n            uint256 frameEndTime\r\n        );\r\n\r\n    /**\r\n     * @notice Return last completed epoch\r\n     */\r\n    function getLastCompletedEpochId() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Report beacon balance and its change during the last frame\r\n     */\r\n    function getLastCompletedReportDelta()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 postTotalPooledEther,\r\n            uint256 preTotalPooledEther,\r\n            uint256 timeElapsed\r\n        );\r\n\r\n    /**\r\n     * @notice Initialize the contract v2 data, with sanity check bounds\r\n     * (`_allowedBeaconBalanceAnnualRelativeIncrease`, `_allowedBeaconBalanceRelativeDecrease`)\r\n     * @dev Original initialize function removed from v2 because it is invoked only once\r\n     */\r\n    function initialize_v2(\r\n        uint256 _allowedBeaconBalanceAnnualRelativeIncrease,\r\n        uint256 _allowedBeaconBalanceRelativeDecrease\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * @notice Add `_member` to the oracle member committee list\r\n     */\r\n    function addOracleMember(address _member) external;\r\n\r\n    /**\r\n     * @notice Remove '_member` from the oracle member committee list\r\n     */\r\n    function removeOracleMember(address _member) external;\r\n\r\n    /**\r\n     * @notice Set the number of exactly the same reports needed to finalize the epoch to `_quorum`\r\n     */\r\n    function setQuorum(uint256 _quorum) external;\r\n\r\n    /**\r\n     * @notice Accept oracle committee member reports from the ETH 2.0 side\r\n     * @param _epochId Beacon chain epoch\r\n     * @param _beaconBalance Balance in gwei on the ETH 2.0 side (9-digit denomination)\r\n     * @param _beaconValidators Number of validators visible in this epoch\r\n     */\r\n    function reportBeacon(uint256 _epochId, uint64 _beaconBalance, uint32 _beaconValidators) external;\r\n}\r\n\r\n\r\n// File contracts/0.4.24/oracle/ReportUtils.sol\r\n\r\n// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity 0.4.24;\r\n\r\n/**\r\n * Utility functions for effectively storing reports within a single storage slot\r\n *\r\n * +00 | uint16 | count            | 0..256  | number of reports received exactly like this\r\n * +16 | uint32 | beaconValidators | 0..1e9  | number of Lido's validators in beacon chain\r\n * +48 | uint64 | beaconBalance    | 0..1e18 | total amout of their balance\r\n *\r\n * Note that the 'count' is the leftmost field here. Thus it is possible to apply addition\r\n * operations to it when it is encoded, provided that you watch for the overflow.\r\n */\r\nlibrary ReportUtils {\r\n    uint256 constant internal COUNT_OUTMASK = 0xFFFFFFFFFFFFFFFFFFFFFFFF0000;\r\n\r\n    function encode(uint64 beaconBalance, uint32 beaconValidators) internal pure returns (uint256) {\r\n        return uint256(beaconBalance) << 48 | uint256(beaconValidators) << 16;\r\n    }\r\n\r\n    function decode(uint256 value) internal pure returns (uint64 beaconBalance, uint32 beaconValidators) {\r\n        beaconBalance = uint64(value >> 48);\r\n        beaconValidators = uint32(value >> 16);\r\n    }\r\n\r\n    function decodeWithCount(uint256 value)\r\n        internal pure\r\n        returns (\r\n            uint64 beaconBalance,\r\n            uint32 beaconValidators,\r\n            uint16 count\r\n        ) {\r\n        beaconBalance = uint64(value >> 48);\r\n        beaconValidators = uint32(value >> 16);\r\n        count = uint16(value);\r\n    }\r\n\r\n    /// @notice Check if the given reports are different, not considering the counter of the first\r\n    function isDifferent(uint256 value, uint256 that) internal pure returns(bool) {\r\n        return (value & COUNT_OUTMASK) != that;\r\n    }\r\n\r\n    function getCount(uint256 value) internal pure returns(uint16) {\r\n        return uint16(value);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/0.4.24/oracle/LidoOracle.sol\r\n\r\n// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\n\r\n/* See contracts/COMPILERS.md */\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Implementation of an ETH 2.0 -> ETH oracle\r\n *\r\n * The goal of the oracle is to inform other parts of the system about balances controlled by the\r\n * DAO on the ETH 2.0 side. The balances can go up because of reward accumulation and can go down\r\n * because of slashing.\r\n *\r\n * The timeline is divided into consecutive frames. Every oracle member may push its report once\r\n * per frame. When the equal reports reach the configurable 'quorum' value, this frame is\r\n * considered finalized and the resulting report is pushed to Lido.\r\n *\r\n * Not all frames may come to a quorum. Oracles may report only to the first epoch of the frame and\r\n * only if no quorum is reached for this epoch yet.\r\n */\r\ncontract LidoOracle is ILidoOracle, AragonApp {\r\n    using SafeMath for uint256;\r\n    using ReportUtils for uint256;\r\n\r\n    struct BeaconSpec {\r\n        uint64 epochsPerFrame;\r\n        uint64 slotsPerEpoch;\r\n        uint64 secondsPerSlot;\r\n        uint64 genesisTime;\r\n    }\r\n\r\n    /// ACL\r\n    bytes32 constant public MANAGE_MEMBERS =\r\n        0xbf6336045918ae0015f4cdb3441a2fdbfaa4bcde6558c8692aac7f56c69fb067; // keccak256(\"MANAGE_MEMBERS\")\r\n    bytes32 constant public MANAGE_QUORUM =\r\n        0xa5ffa9f45fa52c446078e834e1914561bd9c2ab1e833572d62af775da092ccbc; // keccak256(\"MANAGE_QUORUM\")\r\n    bytes32 constant public SET_BEACON_SPEC =\r\n        0x16a273d48baf8111397316e6d961e6836913acb23b181e6c5fb35ec0bd2648fc; // keccak256(\"SET_BEACON_SPEC\")\r\n    bytes32 constant public SET_REPORT_BOUNDARIES =\r\n        0x44adaee26c92733e57241cb0b26ffaa2d182ed7120ba3ecd7e0dce3635c01dc1; // keccak256(\"SET_REPORT_BOUNDARIES\")\r\n    bytes32 constant public SET_BEACON_REPORT_RECEIVER =\r\n        0xe22a455f1bfbaf705ac3e891a64e156da92cb0b42cfc389158e6e82bd57f37be; // keccak256(\"SET_BEACON_REPORT_RECEIVER\")\r\n\r\n    /// Maximum number of oracle committee members\r\n    uint256 public constant MAX_MEMBERS = 256;\r\n\r\n    /// Eth1 denomination is 18 digits, while Eth2 has 9 digits. Because we work with Eth2\r\n    /// balances and to support old interfaces expecting eth1 format, we multiply by this\r\n    /// coefficient.\r\n    uint128 internal constant DENOMINATION_OFFSET = 1e9;\r\n\r\n    uint256 internal constant MEMBER_NOT_FOUND = uint256(-1);\r\n\r\n    /// Number of exactly the same reports needed to finalize the epoch\r\n    bytes32 internal constant QUORUM_POSITION =\r\n        0xd43b42c1ba05a1ab3c178623a49b2cdb55f000ec70b9ccdba5740b3339a7589e; // keccak256(\"lido.LidoOracle.quorum\")\r\n\r\n    /// Address of the Lido contract\r\n    bytes32 internal constant LIDO_POSITION =\r\n        0xf6978a4f7e200f6d3a24d82d44c48bddabce399a3b8ec42a480ea8a2d5fe6ec5; // keccak256(\"lido.LidoOracle.lido\")\r\n\r\n    /// Storage for the actual beacon chain specification\r\n    bytes32 internal constant BEACON_SPEC_POSITION =\r\n        0x805e82d53a51be3dfde7cfed901f1f96f5dad18e874708b082adb8841e8ca909; // keccak256(\"lido.LidoOracle.beaconSpec\")\r\n\r\n    /// Version of the initialized contract data, v1 is 0\r\n    bytes32 internal constant CONTRACT_VERSION_POSITION =\r\n        0x75be19a3f314d89bd1f84d30a6c84e2f1cd7afc7b6ca21876564c265113bb7e4; // keccak256(\"lido.LidoOracle.contractVersion\")\r\n\r\n    /// Epoch that we currently collect reports\r\n    bytes32 internal constant EXPECTED_EPOCH_ID_POSITION =\r\n        0x65f1a0ee358a8a4000a59c2815dc768eb87d24146ca1ac5555cb6eb871aee915; // keccak256(\"lido.LidoOracle.expectedEpochId\")\r\n\r\n    /// The bitmask of the oracle members that pushed their reports\r\n    bytes32 internal constant REPORTS_BITMASK_POSITION =\r\n        0xea6fa022365e4737a3bb52facb00ddc693a656fb51ffb2b4bd24fb85bdc888be; // keccak256(\"lido.LidoOracle.reportsBitMask\")\r\n\r\n    /// Historic data about 2 last completed reports and their times\r\n    bytes32 internal constant POST_COMPLETED_TOTAL_POOLED_ETHER_POSITION =\r\n        0xaa8433b13d2b111d4f84f6f374bc7acbe20794944308876aa250fa9a73dc7f53; // keccak256(\"lido.LidoOracle.postCompletedTotalPooledEther\")\r\n    bytes32 internal constant PRE_COMPLETED_TOTAL_POOLED_ETHER_POSITION =\r\n        0x1043177539af09a67d747435df3ff1155a64cd93a347daaac9132a591442d43e; // keccak256(\"lido.LidoOracle.preCompletedTotalPooledEther\")\r\n    bytes32 internal constant LAST_COMPLETED_EPOCH_ID_POSITION =\r\n        0xdad15c0beecd15610092d84427258e369d2582df22869138b4c5265f049f574c; // keccak256(\"lido.LidoOracle.lastCompletedEpochId\")\r\n    bytes32 internal constant TIME_ELAPSED_POSITION =\r\n        0x8fe323f4ecd3bf0497252a90142003855cc5125cee76a5b5ba5d508c7ec28c3a; // keccak256(\"lido.LidoOracle.timeElapsed\")\r\n\r\n    /// Receiver address to be called when the report is pushed to Lido\r\n    bytes32 internal constant BEACON_REPORT_RECEIVER_POSITION =\r\n        0xb59039ed37776bc23c5d272e10b525a957a1dfad97f5006c84394b6b512c1564; // keccak256(\"lido.LidoOracle.beaconReportReceiver\")\r\n\r\n    /// Upper bound of the reported balance possible increase in APR, controlled by the governance\r\n    bytes32 internal constant ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION =\r\n        0x613075ab597bed8ce2e18342385ce127d3e5298bc7a84e3db68dc64abd4811ac; // keccak256(\"lido.LidoOracle.allowedBeaconBalanceAnnualRelativeIncrease\")\r\n\r\n    /// Lower bound of the reported balance possible decrease, controlled by the governance\r\n    ///\r\n    /// @notice When slashing happens, the balance may decrease at a much faster pace. Slashing are\r\n    /// one-time events that decrease the balance a fair amount - a few percent at a time in a\r\n    /// realistic scenario. Thus, instead of sanity check for an APR, we check if the plain relative\r\n    /// decrease is within bounds.  Note that it's not annual value, its just one-jump value.\r\n    bytes32 internal constant ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION =\r\n        0x92ba7776ed6c5d13cf023555a94e70b823a4aebd56ed522a77345ff5cd8a9109; // keccak256(\"lido.LidoOracle.allowedBeaconBalanceDecrease\")\r\n\r\n    /// This variable is from v1: the last reported epoch, used only in the initializer\r\n    bytes32 internal constant V1_LAST_REPORTED_EPOCH_ID_POSITION =\r\n        0xfe0250ed0c5d8af6526c6d133fccb8e5a55dd6b1aa6696ed0c327f8e517b5a94; // keccak256(\"lido.LidoOracle.lastReportedEpochId\")\r\n\r\n    /// Contract structured storage\r\n    address[] private members;                /// slot 0: oracle committee members\r\n    uint256[] private currentReportVariants;  /// slot 1: reporting storage\r\n\r\n\r\n    /**\r\n     * @notice Return the Lido contract address\r\n     */\r\n    function getLido() public view returns (ILido) {\r\n        return ILido(LIDO_POSITION.getStorageAddress());\r\n    }\r\n\r\n    /**\r\n     * @notice Return the number of exactly the same reports needed to finalize the epoch\r\n     */\r\n    function getQuorum() public view returns (uint256) {\r\n        return QUORUM_POSITION.getStorageUint256();\r\n    }\r\n\r\n    /**\r\n     * @notice Return the upper bound of the reported balance possible increase in APR\r\n     */\r\n    function getAllowedBeaconBalanceAnnualRelativeIncrease() external view returns (uint256) {\r\n        return ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION.getStorageUint256();\r\n    }\r\n\r\n    /**\r\n     * @notice Return the lower bound of the reported balance possible decrease\r\n     */\r\n    function getAllowedBeaconBalanceRelativeDecrease() external view returns (uint256) {\r\n        return ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION.getStorageUint256();\r\n    }\r\n\r\n    /**\r\n     * @notice Set the upper bound of the reported balance possible increase in APR to `_value`\r\n     */\r\n    function setAllowedBeaconBalanceAnnualRelativeIncrease(uint256 _value) external auth(SET_REPORT_BOUNDARIES) {\r\n        ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION.setStorageUint256(_value);\r\n        emit AllowedBeaconBalanceAnnualRelativeIncreaseSet(_value);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the lower bound of the reported balance possible decrease to `_value`\r\n     */\r\n    function setAllowedBeaconBalanceRelativeDecrease(uint256 _value) external auth(SET_REPORT_BOUNDARIES) {\r\n        ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION.setStorageUint256(_value);\r\n        emit AllowedBeaconBalanceRelativeDecreaseSet(_value);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the receiver contract address to be called when the report is pushed to Lido\r\n     */\r\n    function getBeaconReportReceiver() external view returns (address) {\r\n        return address(BEACON_REPORT_RECEIVER_POSITION.getStorageUint256());\r\n    }\r\n\r\n    /**\r\n     * @notice Set the receiver contract address to `_addr` to be called when the report is pushed\r\n     * @dev Specify 0 to disable this functionality\r\n     */\r\n    function setBeaconReportReceiver(address _addr) external auth(SET_BEACON_REPORT_RECEIVER) {\r\n        BEACON_REPORT_RECEIVER_POSITION.setStorageUint256(uint256(_addr));\r\n        emit BeaconReportReceiverSet(_addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the current reporting bitmap, representing oracles who have already pushed\r\n     * their version of report during the expected epoch\r\n     * @dev Every oracle bit corresponds to the index of the oracle in the current members list\r\n     */\r\n    function getCurrentOraclesReportStatus() external view returns (uint256) {\r\n        return REPORTS_BITMASK_POSITION.getStorageUint256();\r\n    }\r\n\r\n    /**\r\n     * @notice Return the current reporting variants array size\r\n     */\r\n    function getCurrentReportVariantsSize() external view returns (uint256) {\r\n        return currentReportVariants.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the current reporting array element with index `_index`\r\n     */\r\n    function getCurrentReportVariant(uint256 _index)\r\n        external\r\n        view\r\n        returns (\r\n            uint64 beaconBalance,\r\n            uint32 beaconValidators,\r\n            uint16 count\r\n        )\r\n    {\r\n        return currentReportVariants[_index].decodeWithCount();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns epoch that can be reported by oracles\r\n     */\r\n    function getExpectedEpochId() external view returns (uint256) {\r\n        return EXPECTED_EPOCH_ID_POSITION.getStorageUint256();\r\n    }\r\n\r\n    /**\r\n     * @notice Return the current oracle member committee list\r\n     */\r\n    function getOracleMembers() external view returns (address[]) {\r\n        return members;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the initialized version of this contract starting from 0\r\n     */\r\n    function getVersion() external view returns (uint256) {\r\n        return CONTRACT_VERSION_POSITION.getStorageUint256();\r\n    }\r\n\r\n    /**\r\n     * @notice Return beacon specification data\r\n     */\r\n    function getBeaconSpec()\r\n        external\r\n        view\r\n        returns (\r\n            uint64 epochsPerFrame,\r\n            uint64 slotsPerEpoch,\r\n            uint64 secondsPerSlot,\r\n            uint64 genesisTime\r\n        )\r\n    {\r\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\r\n        return (\r\n            beaconSpec.epochsPerFrame,\r\n            beaconSpec.slotsPerEpoch,\r\n            beaconSpec.secondsPerSlot,\r\n            beaconSpec.genesisTime\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Update beacon specification data\r\n     */\r\n    function setBeaconSpec(\r\n        uint64 _epochsPerFrame,\r\n        uint64 _slotsPerEpoch,\r\n        uint64 _secondsPerSlot,\r\n        uint64 _genesisTime\r\n    )\r\n        external\r\n        auth(SET_BEACON_SPEC)\r\n    {\r\n        _setBeaconSpec(\r\n            _epochsPerFrame,\r\n            _slotsPerEpoch,\r\n            _secondsPerSlot,\r\n            _genesisTime\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Return the epoch calculated from current timestamp\r\n     */\r\n    function getCurrentEpochId() external view returns (uint256) {\r\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\r\n        return _getCurrentEpochId(beaconSpec);\r\n    }\r\n\r\n    /**\r\n     * @notice Return currently reportable epoch (the first epoch of the current frame) as well as\r\n     * its start and end times in seconds\r\n     */\r\n    function getCurrentFrame()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 frameEpochId,\r\n            uint256 frameStartTime,\r\n            uint256 frameEndTime\r\n        )\r\n    {\r\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\r\n        uint64 genesisTime = beaconSpec.genesisTime;\r\n        uint64 secondsPerEpoch = beaconSpec.secondsPerSlot * beaconSpec.slotsPerEpoch;\r\n\r\n        frameEpochId = _getFrameFirstEpochId(_getCurrentEpochId(beaconSpec), beaconSpec);\r\n        frameStartTime = frameEpochId * secondsPerEpoch + genesisTime;\r\n        frameEndTime = (frameEpochId + beaconSpec.epochsPerFrame) * secondsPerEpoch + genesisTime - 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Return last completed epoch\r\n     */\r\n    function getLastCompletedEpochId() external view returns (uint256) {\r\n        return LAST_COMPLETED_EPOCH_ID_POSITION.getStorageUint256();\r\n    }\r\n\r\n    /**\r\n     * @notice Report beacon balance and its change during the last frame\r\n     */\r\n    function getLastCompletedReportDelta()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 postTotalPooledEther,\r\n            uint256 preTotalPooledEther,\r\n            uint256 timeElapsed\r\n        )\r\n    {\r\n        postTotalPooledEther = POST_COMPLETED_TOTAL_POOLED_ETHER_POSITION.getStorageUint256();\r\n        preTotalPooledEther = PRE_COMPLETED_TOTAL_POOLED_ETHER_POSITION.getStorageUint256();\r\n        timeElapsed = TIME_ELAPSED_POSITION.getStorageUint256();\r\n    }\r\n\r\n    /**\r\n     * @notice Initialize the contract v2 data, with sanity check bounds\r\n     * (`_allowedBeaconBalanceAnnualRelativeIncrease`, `_allowedBeaconBalanceRelativeDecrease`)\r\n     * @dev Original initialize function removed from v2 because it is invoked only once\r\n     */\r\n    function initialize_v2(\r\n        uint256 _allowedBeaconBalanceAnnualRelativeIncrease,\r\n        uint256 _allowedBeaconBalanceRelativeDecrease\r\n    )\r\n        external\r\n    {\r\n        require(CONTRACT_VERSION_POSITION.getStorageUint256() == 0, \"ALREADY_INITIALIZED\");\r\n        CONTRACT_VERSION_POSITION.setStorageUint256(1);\r\n        emit ContractVersionSet(1);\r\n\r\n        ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION\r\n            .setStorageUint256(_allowedBeaconBalanceAnnualRelativeIncrease);\r\n        emit AllowedBeaconBalanceAnnualRelativeIncreaseSet(_allowedBeaconBalanceAnnualRelativeIncrease);\r\n\r\n        ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION\r\n            .setStorageUint256(_allowedBeaconBalanceRelativeDecrease);\r\n        emit AllowedBeaconBalanceRelativeDecreaseSet(_allowedBeaconBalanceRelativeDecrease);\r\n\r\n        // set last completed epoch as V1's contract last reported epoch, in the vast majority of\r\n        // cases this is true, in others the error is within a frame\r\n        uint256 lastReportedEpoch = V1_LAST_REPORTED_EPOCH_ID_POSITION.getStorageUint256();\r\n        LAST_COMPLETED_EPOCH_ID_POSITION.setStorageUint256(lastReportedEpoch);\r\n\r\n        // set expected epoch to the first epoch for the next frame\r\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\r\n        uint256 expectedEpoch = _getFrameFirstEpochId(lastReportedEpoch, beaconSpec) + beaconSpec.epochsPerFrame;\r\n        EXPECTED_EPOCH_ID_POSITION.setStorageUint256(expectedEpoch);\r\n        emit ExpectedEpochIdUpdated(expectedEpoch);\r\n    }\r\n\r\n    /**\r\n     * @notice Add `_member` to the oracle member committee list\r\n     */\r\n    function addOracleMember(address _member) external auth(MANAGE_MEMBERS) {\r\n        require(address(0) != _member, \"BAD_ARGUMENT\");\r\n        require(MEMBER_NOT_FOUND == _getMemberId(_member), \"MEMBER_EXISTS\");\r\n\r\n        members.push(_member);\r\n        require(members.length < MAX_MEMBERS, \"TOO_MANY_MEMBERS\");\r\n        emit MemberAdded(_member);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove '_member` from the oracle member committee list\r\n     */\r\n    function removeOracleMember(address _member) external auth(MANAGE_MEMBERS) {\r\n        uint256 index = _getMemberId(_member);\r\n        require(index != MEMBER_NOT_FOUND, \"MEMBER_NOT_FOUND\");\r\n        uint256 last = members.length - 1;\r\n        if (index != last) members[index] = members[last];\r\n        members.length--;\r\n        emit MemberRemoved(_member);\r\n\r\n        // delete the data for the last epoch, let remained oracles report it again\r\n        REPORTS_BITMASK_POSITION.setStorageUint256(0);\r\n        delete currentReportVariants;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the number of exactly the same reports needed to finalize the epoch to `_quorum`\r\n     */\r\n    function setQuorum(uint256 _quorum) external auth(MANAGE_QUORUM) {\r\n        require(0 != _quorum, \"QUORUM_WONT_BE_MADE\");\r\n        uint256 oldQuorum = QUORUM_POSITION.getStorageUint256();\r\n        QUORUM_POSITION.setStorageUint256(_quorum);\r\n        emit QuorumChanged(_quorum);\r\n\r\n        // If the quorum value lowered, check existing reports whether it is time to push\r\n        if (oldQuorum > _quorum) {\r\n            (bool isQuorum, uint256 report) = _getQuorumReport(_quorum);\r\n            if (isQuorum) {\r\n                (uint64 beaconBalance, uint32 beaconValidators) = report.decode();\r\n                _push(\r\n                     EXPECTED_EPOCH_ID_POSITION.getStorageUint256(),\r\n                     DENOMINATION_OFFSET * uint128(beaconBalance),\r\n                     beaconValidators,\r\n                     _getBeaconSpec()\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accept oracle committee member reports from the ETH 2.0 side\r\n     * @param _epochId Beacon chain epoch\r\n     * @param _beaconBalance Balance in gwei on the ETH 2.0 side (9-digit denomination)\r\n     * @param _beaconValidators Number of validators visible in this epoch\r\n     */\r\n    function reportBeacon(uint256 _epochId, uint64 _beaconBalance, uint32 _beaconValidators) external {\r\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\r\n        uint256 expectedEpoch = EXPECTED_EPOCH_ID_POSITION.getStorageUint256();\r\n        require(_epochId >= expectedEpoch, \"EPOCH_IS_TOO_OLD\");\r\n\r\n        // if expected epoch has advanced, check that this is the first epoch of the current frame\r\n        // and clear the last unsuccessful reporting\r\n        if (_epochId > expectedEpoch) {\r\n            require(_epochId == _getFrameFirstEpochId(_getCurrentEpochId(beaconSpec), beaconSpec), \"UNEXPECTED_EPOCH\");\r\n            _clearReportingAndAdvanceTo(_epochId);\r\n        }\r\n\r\n        uint128 beaconBalanceEth1 = DENOMINATION_OFFSET * uint128(_beaconBalance);\r\n        emit BeaconReported(_epochId, beaconBalanceEth1, _beaconValidators, msg.sender);\r\n\r\n        // make sure the oracle is from members list and has not yet voted\r\n        uint256 index = _getMemberId(msg.sender);\r\n        require(index != MEMBER_NOT_FOUND, \"MEMBER_NOT_FOUND\");\r\n        uint256 bitMask = REPORTS_BITMASK_POSITION.getStorageUint256();\r\n        uint256 mask = 1 << index;\r\n        require(bitMask & mask == 0, \"ALREADY_SUBMITTED\");\r\n        REPORTS_BITMASK_POSITION.setStorageUint256(bitMask | mask);\r\n\r\n        // push this report to the matching kind\r\n        uint256 report = ReportUtils.encode(_beaconBalance, _beaconValidators);\r\n        uint256 quorum = getQuorum();\r\n        uint256 i = 0;\r\n\r\n        // iterate on all report variants we already have, limited by the oracle members maximum\r\n        while (i < currentReportVariants.length && currentReportVariants[i].isDifferent(report)) ++i;\r\n        if (i < currentReportVariants.length) {\r\n            if (currentReportVariants[i].getCount() + 1 >= quorum) {\r\n                _push(_epochId, beaconBalanceEth1, _beaconValidators, beaconSpec);\r\n            } else {\r\n                ++currentReportVariants[i]; // increment report counter, see ReportUtils for details\r\n            }\r\n        } else {\r\n            if (quorum == 1) {\r\n                _push(_epochId, beaconBalanceEth1, _beaconValidators, beaconSpec);\r\n            } else {\r\n                currentReportVariants.push(report + 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Return beacon specification data\r\n     */\r\n    function _getBeaconSpec()\r\n        internal\r\n        view\r\n        returns (BeaconSpec memory beaconSpec)\r\n    {\r\n        uint256 data = BEACON_SPEC_POSITION.getStorageUint256();\r\n        beaconSpec.epochsPerFrame = uint64(data >> 192);\r\n        beaconSpec.slotsPerEpoch = uint64(data >> 128);\r\n        beaconSpec.secondsPerSlot = uint64(data >> 64);\r\n        beaconSpec.genesisTime = uint64(data);\r\n        return beaconSpec;\r\n    }\r\n\r\n    /**\r\n     * @notice Return whether the `_quorum` is reached and the final report\r\n     */\r\n    function _getQuorumReport(uint256 _quorum) internal view returns (bool isQuorum, uint256 report) {\r\n        // check most frequent cases first: all reports are the same or no reports yet\r\n        if (currentReportVariants.length == 1) {\r\n            return (currentReportVariants[0].getCount() >= _quorum, currentReportVariants[0]);\r\n        } else if (currentReportVariants.length == 0) {\r\n            return (false, 0);\r\n        }\r\n\r\n        // if more than 2 kind of reports exist, choose the most frequent\r\n        uint256 maxind = 0;\r\n        uint256 repeat = 0;\r\n        uint16 maxval = 0;\r\n        uint16 cur = 0;\r\n        for (uint256 i = 0; i < currentReportVariants.length; ++i) {\r\n            cur = currentReportVariants[i].getCount();\r\n            if (cur >= maxval) {\r\n                if (cur == maxval) {\r\n                    ++repeat;\r\n                } else {\r\n                    maxind = i;\r\n                    maxval = cur;\r\n                    repeat = 0;\r\n                }\r\n            }\r\n        }\r\n        return (maxval >= _quorum && repeat == 0, currentReportVariants[maxind]);\r\n    }\r\n\r\n    /**\r\n     * @notice Set beacon specification data\r\n     */\r\n    function _setBeaconSpec(\r\n        uint64 _epochsPerFrame,\r\n        uint64 _slotsPerEpoch,\r\n        uint64 _secondsPerSlot,\r\n        uint64 _genesisTime\r\n    )\r\n        internal\r\n    {\r\n        require(_epochsPerFrame > 0, \"BAD_EPOCHS_PER_FRAME\");\r\n        require(_slotsPerEpoch > 0, \"BAD_SLOTS_PER_EPOCH\");\r\n        require(_secondsPerSlot > 0, \"BAD_SECONDS_PER_SLOT\");\r\n        require(_genesisTime > 0, \"BAD_GENESIS_TIME\");\r\n\r\n        uint256 data = (\r\n            uint256(_epochsPerFrame) << 192 |\r\n            uint256(_slotsPerEpoch) << 128 |\r\n            uint256(_secondsPerSlot) << 64 |\r\n            uint256(_genesisTime)\r\n        );\r\n        BEACON_SPEC_POSITION.setStorageUint256(data);\r\n        emit BeaconSpecSet(\r\n            _epochsPerFrame,\r\n            _slotsPerEpoch,\r\n            _secondsPerSlot,\r\n            _genesisTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Push the given report to Lido and performs accompanying accounting\r\n     * @param _epochId Beacon chain epoch, proven to be >= expected epoch and <= current epoch\r\n     * @param _beaconBalanceEth1 Validators balance in eth1 (18-digit denomination)\r\n     * @param _beaconSpec current beacon specification data\r\n     */\r\n    function _push(\r\n        uint256 _epochId,\r\n        uint128 _beaconBalanceEth1,\r\n        uint128 _beaconValidators,\r\n        BeaconSpec memory _beaconSpec\r\n    )\r\n        internal\r\n    {\r\n        emit Completed(_epochId, _beaconBalanceEth1, _beaconValidators);\r\n\r\n        // now this frame is completed, so the expected epoch should be advanced to the first epoch\r\n        // of the next frame\r\n        _clearReportingAndAdvanceTo(_epochId + _beaconSpec.epochsPerFrame);\r\n\r\n        // report to the Lido and collect stats\r\n        ILido lido = getLido();\r\n        uint256 prevTotalPooledEther = lido.totalSupply();\r\n        lido.pushBeacon(_beaconValidators, _beaconBalanceEth1);\r\n        uint256 postTotalPooledEther = lido.totalSupply();\r\n\r\n        PRE_COMPLETED_TOTAL_POOLED_ETHER_POSITION.setStorageUint256(prevTotalPooledEther);\r\n        POST_COMPLETED_TOTAL_POOLED_ETHER_POSITION.setStorageUint256(postTotalPooledEther);\r\n        uint256 timeElapsed = (_epochId - LAST_COMPLETED_EPOCH_ID_POSITION.getStorageUint256()) *\r\n            _beaconSpec.slotsPerEpoch * _beaconSpec.secondsPerSlot;\r\n        TIME_ELAPSED_POSITION.setStorageUint256(timeElapsed);\r\n        LAST_COMPLETED_EPOCH_ID_POSITION.setStorageUint256(_epochId);\r\n\r\n        // rollback on boundaries violation\r\n        _reportSanityChecks(postTotalPooledEther, prevTotalPooledEther, timeElapsed);\r\n\r\n        // emit detailed statistics and call the quorum delegate with this data\r\n        emit PostTotalShares(postTotalPooledEther, prevTotalPooledEther, timeElapsed, lido.getTotalShares());\r\n        IBeaconReportReceiver receiver = IBeaconReportReceiver(BEACON_REPORT_RECEIVER_POSITION.getStorageUint256());\r\n        if (address(receiver) != address(0)) {\r\n            receiver.processLidoOracleReport(postTotalPooledEther, prevTotalPooledEther, timeElapsed);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Remove the current reporting progress and advances to accept the later epoch `_epochId`\r\n     */\r\n    function _clearReportingAndAdvanceTo(uint256 _epochId) internal {\r\n        REPORTS_BITMASK_POSITION.setStorageUint256(0);\r\n        EXPECTED_EPOCH_ID_POSITION.setStorageUint256(_epochId);\r\n        delete currentReportVariants;\r\n        emit ExpectedEpochIdUpdated(_epochId);\r\n    }\r\n\r\n    /**\r\n     * @notice Performs logical consistency check of the Lido changes as the result of reports push\r\n     * @dev To make oracles less dangerous, we limit rewards report by 10% _annual_ increase and 5%\r\n     * _instant_ decrease in stake, with both values configurable by the governance in case of\r\n     * extremely unusual circumstances.\r\n     **/\r\n    function _reportSanityChecks(\r\n        uint256 _postTotalPooledEther,\r\n        uint256 _preTotalPooledEther,\r\n        uint256 _timeElapsed)\r\n        internal\r\n        view\r\n    {\r\n        if (_postTotalPooledEther >= _preTotalPooledEther) {\r\n            // increase                 = _postTotalPooledEther - _preTotalPooledEther,\r\n            // relativeIncrease         = increase / _preTotalPooledEther,\r\n            // annualRelativeIncrease   = relativeIncrease / (timeElapsed / 365 days),\r\n            // annualRelativeIncreaseBp = annualRelativeIncrease * 10000, in basis points 0.01% (1e-4)\r\n            uint256 allowedAnnualRelativeIncreaseBp =\r\n                ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION.getStorageUint256();\r\n            // check that annualRelativeIncreaseBp <= allowedAnnualRelativeIncreaseBp\r\n            require(uint256(10000 * 365 days).mul(_postTotalPooledEther - _preTotalPooledEther) <=\r\n                    allowedAnnualRelativeIncreaseBp.mul(_preTotalPooledEther).mul(_timeElapsed),\r\n                    \"ALLOWED_BEACON_BALANCE_INCREASE\");\r\n        } else {\r\n            // decrease           = _preTotalPooledEther - _postTotalPooledEther\r\n            // relativeDecrease   = decrease / _preTotalPooledEther\r\n            // relativeDecreaseBp = relativeDecrease * 10000, in basis points 0.01% (1e-4)\r\n            uint256 allowedRelativeDecreaseBp =\r\n                ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION.getStorageUint256();\r\n            // check that relativeDecreaseBp <= allowedRelativeDecreaseBp\r\n            require(uint256(10000).mul(_preTotalPooledEther - _postTotalPooledEther) <=\r\n                    allowedRelativeDecreaseBp.mul(_preTotalPooledEther),\r\n                    \"ALLOWED_BEACON_BALANCE_DECREASE\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Return `_member` index in the members list or MEMBER_NOT_FOUND\r\n     */\r\n    function _getMemberId(address _member) internal view returns (uint256) {\r\n        uint256 length = members.length;\r\n        for (uint256 i = 0; i < length; ++i) {\r\n            if (members[i] == _member) {\r\n                return i;\r\n            }\r\n        }\r\n        return MEMBER_NOT_FOUND;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the epoch calculated from current timestamp\r\n     */\r\n    function _getCurrentEpochId(BeaconSpec memory _beaconSpec) internal view returns (uint256) {\r\n        return (_getTime() - _beaconSpec.genesisTime) / (_beaconSpec.slotsPerEpoch * _beaconSpec.secondsPerSlot);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the first epoch of the frame that `_epochId` belongs to\r\n     */\r\n    function _getFrameFirstEpochId(uint256 _epochId, BeaconSpec memory _beaconSpec) internal view returns (uint256) {\r\n        return _epochId / _beaconSpec.epochsPerFrame * _beaconSpec.epochsPerFrame;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the current timestamp\r\n     */\r\n    function _getTime() internal view returns (uint256) {\r\n        return block.timestamp; // solhint-disable-line not-rely-on-time\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentOraclesReportStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setAllowedBeaconBalanceAnnualRelativeIncrease\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_script\",\"type\":\"bytes\"}],\"name\":\"getEVMScriptExecutor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MANAGE_QUORUM\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_epochId\",\"type\":\"uint256\"},{\"name\":\"_beaconBalance\",\"type\":\"uint64\"},{\"name\":\"_beaconValidators\",\"type\":\"uint32\"}],\"name\":\"reportBeacon\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRecoveryVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllowedBeaconBalanceAnnualRelativeIncrease\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllowedBeaconBalanceRelativeDecrease\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExpectedEpochId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastCompletedReportDelta\",\"outputs\":[{\"name\":\"postTotalPooledEther\",\"type\":\"uint256\"},{\"name\":\"preTotalPooledEther\",\"type\":\"uint256\"},{\"name\":\"timeElapsed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLido\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_BEACON_REPORT_RECEIVER\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MANAGE_MEMBERS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentFrame\",\"outputs\":[{\"name\":\"frameEpochId\",\"type\":\"uint256\"},{\"name\":\"frameStartTime\",\"type\":\"uint256\"},{\"name\":\"frameEndTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"allowRecoverability\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getCurrentReportVariant\",\"outputs\":[{\"name\":\"beaconBalance\",\"type\":\"uint64\"},{\"name\":\"beaconValidators\",\"type\":\"uint32\"},{\"name\":\"count\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"appId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastCompletedEpochId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitializationBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allowedBeaconBalanceAnnualRelativeIncrease\",\"type\":\"uint256\"},{\"name\":\"_allowedBeaconBalanceRelativeDecrease\",\"type\":\"uint256\"}],\"name\":\"initialize_v2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setBeaconReportReceiver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"transferToVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_BEACON_SPEC\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"bytes32\"},{\"name\":\"_params\",\"type\":\"uint256[]\"}],\"name\":\"canPerform\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentEpochId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEVMScriptRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"addOracleMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBeaconReportReceiver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_REPORT_BOUNDARIES\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_quorum\",\"type\":\"uint256\"}],\"name\":\"setQuorum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kernel\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOracleMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPetrified\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setAllowedBeaconBalanceRelativeDecrease\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBeaconSpec\",\"outputs\":[{\"name\":\"epochsPerFrame\",\"type\":\"uint64\"},{\"name\":\"slotsPerEpoch\",\"type\":\"uint64\"},{\"name\":\"secondsPerSlot\",\"type\":\"uint64\"},{\"name\":\"genesisTime\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_epochsPerFrame\",\"type\":\"uint64\"},{\"name\":\"_slotsPerEpoch\",\"type\":\"uint64\"},{\"name\":\"_secondsPerSlot\",\"type\":\"uint64\"},{\"name\":\"_genesisTime\",\"type\":\"uint64\"}],\"name\":\"setBeaconSpec\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_MEMBERS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentReportVariantsSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"removeOracleMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"script\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"input\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"ScriptResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RecoverToVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AllowedBeaconBalanceAnnualRelativeIncreaseSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AllowedBeaconBalanceRelativeDecreaseSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"callback\",\"type\":\"address\"}],\"name\":\"BeaconReportReceiverSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"quorum\",\"type\":\"uint256\"}],\"name\":\"QuorumChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"epochId\",\"type\":\"uint256\"}],\"name\":\"ExpectedEpochIdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"epochsPerFrame\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"slotsPerEpoch\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"secondsPerSlot\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"genesisTime\",\"type\":\"uint64\"}],\"name\":\"BeaconSpecSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"epochId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"beaconBalance\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"beaconValidators\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"BeaconReported\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"epochId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"beaconBalance\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"beaconValidators\",\"type\":\"uint128\"}],\"name\":\"Completed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"postTotalPooledEther\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"preTotalPooledEther\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeElapsed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalShares\",\"type\":\"uint256\"}],\"name\":\"PostTotalShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"ContractVersionSet\",\"type\":\"event\"}]","ContractName":"LidoOracle","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"constantinople","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://b2463ee7fe02bec7d61ce2a715980bdb2401164ca8bf7c5f6a0cf54bf6a525a2"}]}