{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/access/AccessControlled.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"../interfaces/AccessControlledInterface.sol\\\";\\nimport \\\"../vendor/AccessControllerInterface.sol\\\";\\nimport \\\"../vendor/ConfirmedOwner.sol\\\";\\n\\ncontract AccessControlled is AccessControlledInterface, ConfirmedOwner(msg.sender) {\\n  AccessControllerInterface internal s_accessController;\\n\\n  function setAccessController(\\n    AccessControllerInterface _accessController\\n  )\\n    public\\n    override\\n    onlyOwner()\\n  {\\n    require(address(_accessController) != address(s_accessController), \\\"Access controller is already set\\\");\\n    s_accessController = _accessController;\\n    emit AccessControllerSet(address(_accessController), msg.sender);\\n  }\\n\\n  function getAccessController()\\n    public\\n    view\\n    override\\n    returns (\\n      AccessControllerInterface\\n    )\\n  {\\n    return s_accessController;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/AccessControlledInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"../vendor/AccessControllerInterface.sol\\\";\\n\\ninterface AccessControlledInterface {\\n  event AccessControllerSet(\\n    address indexed accessController,\\n    address indexed sender\\n  );\\n\\n  function setAccessController(\\n    AccessControllerInterface _accessController\\n  )\\n    external;\\n\\n  function getAccessController()\\n    external\\n    view\\n    returns (\\n      AccessControllerInterface\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/AccessControllerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.6.0 <0.8.0;\\n\\ninterface AccessControllerInterface {\\n  function hasAccess(address user, bytes calldata data) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n\\n  constructor(\\n    address newOwner\\n  )\\n    ConfirmedOwnerWithProposal(\\n      newOwner,\\n      address(0)\\n    )\\n  {\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"../interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(\\n    address indexed from,\\n    address indexed to\\n  );\\n  event OwnershipTransferred(\\n    address indexed from,\\n    address indexed to\\n  );\\n\\n  constructor(\\n    address owner,\\n    address pendingOwner\\n  ) {\\n    require(owner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = owner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(\\n    address to\\n  )\\n    public\\n    override\\n    onlyOwner()\\n  {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership()\\n    external\\n    override\\n  {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner()\\n    public\\n    view\\n    override\\n    returns (\\n      address\\n    )\\n  {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(\\n    address to\\n  )\\n    private\\n  {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership()\\n    internal\\n  {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface OwnableInterface {\\n  function owner()\\n    external\\n    returns (\\n      address\\n    );\\n\\n  function transferOwnership(\\n    address recipient\\n  )\\n    external;\\n\\n  function acceptOwnership()\\n    external;\\n}\\n\"\r\n    },\r\n    \"contracts/FeedRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\npragma abicoder v2; // solhint-disable compiler-version\\n\\nimport \\\"@chainlink/contracts/src/v0.7/interfaces/AggregatorV2V3Interface.sol\\\";\\nimport \\\"./access/AccessControlled.sol\\\";\\nimport \\\"./interfaces/FeedRegistryInterface.sol\\\";\\n\\n/**\\n  * @notice An on-chain registry of assets to aggregators.\\n  * @notice This contract provides a consistent address for consumers but delegates where it reads from to the owner, who is\\n  * trusted to update it. This registry contract works for multiple feeds, not just a single aggregator.\\n  * @notice Only access enabled addresses are allowed to access getters for answers and round data\\n  */\\ncontract FeedRegistry is FeedRegistryInterface, AccessControlled {\\n  uint256 constant private PHASE_OFFSET = 64;\\n  uint256 constant private PHASE_SIZE = 16;\\n  uint256 constant private MAX_ID = 2**(PHASE_OFFSET+PHASE_SIZE) - 1;\\n\\n  mapping(address => bool) private s_isAggregatorEnabled;\\n  mapping(address => mapping(address => AggregatorV2V3Interface)) private s_proposedAggregators;\\n  mapping(address => mapping(address => uint16)) private s_currentPhaseId;\\n  mapping(address => mapping(address => mapping(uint16 => AggregatorV2V3Interface))) private s_phaseAggregators;\\n  mapping(address => mapping(address => mapping(uint16 => Phase))) private s_phases;\\n\\n  /*\\n   * @notice Versioning\\n   */\\n  function typeAndVersion()\\n    external\\n    override\\n    pure\\n    virtual\\n    returns (\\n      string memory\\n    )\\n  {\\n    return \\\"FeedRegistry 1.0.0-alpha\\\";\\n  }\\n\\n  /**\\n   * @notice represents the number of decimals the aggregator responses represent.\\n   */\\n  function decimals(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    override\\n    returns (\\n      uint8\\n    )\\n  {\\n    AggregatorV2V3Interface aggregator = _getFeed(asset, denomination);\\n    return aggregator.decimals();\\n  }\\n\\n  /**\\n   * @notice returns the description of the aggregator the proxy points to.\\n   */\\n  function description(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    override\\n    returns (\\n      string memory\\n    )\\n  {\\n    AggregatorV2V3Interface aggregator = _getFeed(asset, denomination);\\n    return aggregator.description();\\n  }\\n\\n  /**\\n   * @notice the version number representing the type of aggregator the proxy\\n   * points to.\\n   */\\n  function version(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    override\\n    returns (\\n      uint256\\n    )\\n  {\\n    AggregatorV2V3Interface aggregator = _getFeed(asset, denomination);\\n    return aggregator.version();\\n  }\\n\\n  /**\\n   * @notice get data about the latest round. Consumers are encouraged to check\\n   * that they're receiving fresh data by inspecting the updatedAt and\\n   * answeredInRound return values.\\n   * Note that different underlying implementations of AggregatorV3Interface\\n   * have slightly different semantics for some of the return values. Consumers\\n   * should determine what implementations they expect to receive\\n   * data from and validate that they can properly handle return data from all\\n   * of them.\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @return roundId is the round ID from the aggregator for which the data was\\n   * retrieved combined with a phase to ensure that round IDs get larger as\\n   * time moves forward.\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @dev Note that answer and updatedAt may change between queries.\\n   */\\n  function latestRoundData(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    override\\n    checkPairAccess()\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    uint16 currentPhaseId = s_currentPhaseId[asset][denomination];\\n    AggregatorV2V3Interface currentPhaseAggregator = _getFeed(asset, denomination);\\n    (\\n      roundId,\\n      answer,\\n      startedAt,\\n      updatedAt,\\n      answeredInRound\\n    ) = currentPhaseAggregator.latestRoundData();\\n    return _addPhaseIds(roundId, answer, startedAt, updatedAt, answeredInRound, currentPhaseId);\\n  }\\n\\n  /**\\n   * @notice get data about a round. Consumers are encouraged to check\\n   * that they're receiving fresh data by inspecting the updatedAt and\\n   * answeredInRound return values.\\n   * Note that different underlying implementations of AggregatorV3Interface\\n   * have slightly different semantics for some of the return values. Consumers\\n   * should determine what implementations they expect to receive\\n   * data from and validate that they can properly handle return data from all\\n   * of them.\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @param _roundId the proxy round id number to retrieve the round data for\\n   * @return roundId is the round ID from the aggregator for which the data was\\n   * retrieved combined with a phase to ensure that round IDs get larger as\\n   * time moves forward.\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @dev Note that answer and updatedAt may change between queries.\\n   */\\n  function getRoundData(\\n    address asset,\\n    address denomination,\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    override\\n    checkPairAccess()\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    (uint16 phaseId, uint64 aggregatorRoundId) = _parseIds(_roundId);\\n    AggregatorV2V3Interface aggregator = _getPhaseFeed(asset, denomination, phaseId);\\n    (\\n      roundId,\\n      answer,\\n      startedAt,\\n      updatedAt,\\n      answeredInRound\\n    ) = aggregator.getRoundData(aggregatorRoundId);\\n    return _addPhaseIds(roundId, answer, startedAt, updatedAt, answeredInRound, phaseId);\\n  }\\n\\n\\n  /**\\n   * @notice Reads the current answer for an asset / denomination pair's aggregator.\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @notice We advise to use latestRoundData() instead because it returns more in-depth information.\\n   * @dev This does not error if no answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended latestRoundData\\n   * instead which includes better verification information.\\n   */\\n  function latestAnswer(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    override\\n    checkPairAccess()\\n    returns (\\n      int256 answer\\n    )\\n  {\\n    AggregatorV2V3Interface aggregator = _getFeed(asset, denomination);\\n    return aggregator.latestAnswer();\\n  }\\n\\n  /**\\n   * @notice get the latest completed timestamp where the answer was updated.\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   *\\n   * @notice We advise to use latestRoundData() instead because it returns more in-depth information.\\n   * @dev This does not error if no answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended latestRoundData\\n   * instead which includes better verification information.\\n   */\\n  function latestTimestamp(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    override\\n    checkPairAccess()\\n    returns (\\n      uint256 timestamp\\n    )\\n  {\\n    AggregatorV2V3Interface aggregator = _getFeed(asset, denomination);\\n    return aggregator.latestTimestamp();\\n  }\\n\\n  /**\\n   * @notice get the latest completed round where the answer was updated\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @dev overridden function to add the checkAccess() modifier\\n   *\\n   * @notice We advise to use latestRoundData() instead because it returns more in-depth information.\\n   * @dev Use latestRoundData instead. This does not error if no\\n   * answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended latestRoundData\\n   * instead which includes better verification information.\\n   */\\n  function latestRound(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    override\\n    checkPairAccess()\\n    returns (\\n      uint256 roundId\\n    )\\n  {\\n    uint16 currentPhaseId = s_currentPhaseId[asset][denomination];\\n    AggregatorV2V3Interface currentPhaseAggregator = _getFeed(asset, denomination);\\n    return _addPhase(currentPhaseId, uint64(currentPhaseAggregator.latestRound()));\\n  }\\n\\n  /**\\n   * @notice get past rounds answers\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @param roundId the proxy round id number to retrieve the answer for\\n   * @dev overridden function to add the checkAccess() modifier\\n   *\\n   * @notice We advise to use getRoundData() instead because it returns more in-depth information.\\n   * @dev This does not error if no answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended getRoundData\\n   * instead which includes better verification information.\\n   */\\n  function getAnswer(\\n    address asset,\\n    address denomination,\\n    uint256 roundId\\n  )\\n    external\\n    view\\n    override\\n    checkPairAccess()\\n    returns (\\n      int256 answer\\n    )\\n  {\\n    if (roundId > MAX_ID) return 0;\\n    (uint16 phaseId, uint64 aggregatorRoundId) = _parseIds(roundId);\\n    AggregatorV2V3Interface aggregator = _getPhaseFeed(asset, denomination, phaseId);\\n    if (address(aggregator) == address(0)) return 0;\\n    return aggregator.getAnswer(aggregatorRoundId);\\n  }\\n\\n  /**\\n   * @notice get block timestamp when an answer was last updated\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @param roundId the proxy round id number to retrieve the updated timestamp for\\n   * @dev overridden function to add the checkAccess() modifier\\n   *\\n   * @notice We advise to use getRoundData() instead because it returns more in-depth information.\\n   * @dev This does not error if no answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended getRoundData\\n   * instead which includes better verification information.\\n   */\\n  function getTimestamp(\\n    address asset,\\n    address denomination,\\n    uint256 roundId\\n  )\\n    external\\n    view\\n    override\\n    checkPairAccess()\\n    returns (\\n      uint256 timestamp\\n    )\\n  {\\n    if (roundId > MAX_ID) return 0;\\n    (uint16 phaseId, uint64 aggregatorRoundId) = _parseIds(roundId);\\n    AggregatorV2V3Interface aggregator = _getPhaseFeed(asset, denomination, phaseId);\\n    if (address(aggregator) == address(0)) return 0;\\n    return aggregator.getTimestamp(aggregatorRoundId);\\n  }\\n\\n\\n  /**\\n   * @notice Retrieve the aggregator of an asset / denomination pair in the current phase\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @return aggregator\\n   */\\n  function getFeed(\\n    address asset,\\n    address denomination\\n  )\\n    public\\n    view\\n    override\\n    returns (\\n      AggregatorV2V3Interface aggregator\\n    )\\n  {\\n    aggregator = _getFeed(asset, denomination);\\n    require(address(aggregator) != address(0), \\\"Feed not found\\\");\\n  }\\n\\n  /**\\n   * @notice retrieve the aggregator of an asset / denomination pair at a specific phase\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @param phaseId phase ID\\n   * @return aggregator\\n   */\\n  function getPhaseFeed(\\n    address asset,\\n    address denomination,\\n    uint16 phaseId\\n  )\\n    public\\n    view\\n    override\\n    returns (\\n      AggregatorV2V3Interface aggregator\\n    )\\n  {\\n    aggregator = _getPhaseFeed(asset, denomination, phaseId);\\n    require(address(aggregator) != address(0), \\\"Feed not found for phase\\\");\\n  }\\n\\n  /**\\n   * @notice returns true if a aggregator is enabled for any pair\\n   * @param aggregator aggregator address\\n   */\\n  function isFeedEnabled(\\n    address aggregator\\n  )\\n    public\\n    view\\n    override\\n    returns (\\n      bool\\n    )\\n  {\\n    return s_isAggregatorEnabled[aggregator];\\n  }\\n\\n  /**\\n   * @notice returns a phase by id. A Phase contains the starting and ending aggregator round ids.\\n   * endingAggregatorRoundId will be 0 if the phase is the current phase\\n   * @dev reverts if the phase does not exist\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @param phaseId phase id\\n   * @return phase\\n   */\\n  function getPhase(\\n    address asset,\\n    address denomination,\\n    uint16 phaseId\\n  )\\n    public\\n    view\\n    override\\n    returns (\\n      Phase memory phase\\n    )\\n  {\\n    phase = _getPhase(asset, denomination, phaseId);\\n    require(_phaseExists(phase), \\\"Phase does not exist\\\");\\n  }\\n\\n  /**\\n   * @notice retrieve the aggregator of an asset / denomination pair at a specific round id\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @param roundId the proxy round id\\n   */\\n  function getRoundFeed(\\n    address asset,\\n    address denomination,\\n    uint80 roundId\\n  )\\n    public\\n    view\\n    override\\n    returns (\\n      AggregatorV2V3Interface aggregator\\n    )\\n  {\\n    uint16 phaseId = _getPhaseIdByRoundId(asset, denomination, roundId);\\n    aggregator = _getPhaseFeed(asset, denomination, phaseId);\\n    require(address(aggregator) != address(0), \\\"Feed not found for round\\\");\\n  }\\n\\n  /**\\n   * @notice returns the range of proxy round ids of a phase\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @param phaseId phase id\\n   * @return startingRoundId\\n   * @return endingRoundId\\n   */\\n  function getPhaseRange(\\n    address asset,\\n    address denomination,\\n    uint16 phaseId\\n  )\\n    public\\n    view\\n    override\\n    returns (\\n      uint80 startingRoundId,\\n      uint80 endingRoundId\\n    )\\n  {\\n    Phase memory phase = _getPhase(asset, denomination, phaseId);\\n    require(_phaseExists(phase), \\\"Phase does not exist\\\");\\n\\n    uint16 currentPhaseId = s_currentPhaseId[asset][denomination];\\n    if (phaseId == currentPhaseId) return _getLatestRoundRange(asset, denomination, currentPhaseId);\\n    return _getPhaseRange(asset, denomination, phaseId);\\n  }\\n\\n  /**\\n   * @notice return the previous round id of a given round\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @param roundId the round id number to retrieve the updated timestamp for\\n   * @dev Note that this is not the aggregator round id, but the proxy round id\\n   * To get full ranges of round ids of different phases, use getPhaseRange()\\n   * @return previousRoundId\\n   */\\n  function getPreviousRoundId(\\n    address asset,\\n    address denomination,\\n    uint80 roundId\\n  ) external\\n    view\\n    override\\n    returns (\\n      uint80 previousRoundId\\n    )\\n  {\\n    uint16 phaseId = _getPhaseIdByRoundId(asset, denomination, roundId);\\n    return _getPreviousRoundId(asset, denomination, phaseId, roundId);\\n  }\\n\\n  /**\\n   * @notice return the next round id of a given round\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @param roundId the round id number to retrieve the updated timestamp for\\n   * @dev Note that this is not the aggregator round id, but the proxy round id\\n   * To get full ranges of round ids of different phases, use getPhaseRange()\\n   * @return nextRoundId\\n   */\\n  function getNextRoundId(\\n    address asset,\\n    address denomination,\\n    uint80 roundId\\n  ) external\\n    view\\n    override\\n    returns (\\n      uint80 nextRoundId\\n    )\\n  {\\n    uint16 phaseId = _getPhaseIdByRoundId(asset, denomination, roundId);\\n    return _getNextRoundId(asset, denomination, phaseId, roundId);\\n  }\\n\\n  /**\\n   * @notice Allows the owner to propose a new address for the aggregator\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @param aggregator The new aggregator contract address\\n   */\\n  function proposeFeed(\\n    address asset,\\n    address denomination,\\n    address aggregator\\n  )\\n    external\\n    override\\n    onlyOwner()\\n  {\\n    AggregatorV2V3Interface currentPhaseAggregator = _getFeed(asset, denomination);\\n    require(aggregator != address(currentPhaseAggregator), \\\"Cannot propose current aggregator\\\");\\n    address proposedAggregator = address(_getProposedFeed(asset, denomination));\\n    if (proposedAggregator != aggregator) {\\n      s_proposedAggregators[asset][denomination] = AggregatorV2V3Interface(aggregator);\\n      emit FeedProposed(asset, denomination, aggregator, address(currentPhaseAggregator), msg.sender);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows the owner to confirm and change the address\\n   * to the proposed aggregator\\n   * @dev Reverts if the given address doesn't match what was previously\\n   * proposed\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @param aggregator The new aggregator contract address\\n   */\\n  function confirmFeed(\\n    address asset,\\n    address denomination,\\n    address aggregator\\n  )\\n    external\\n    override\\n    onlyOwner()\\n  {\\n    (uint16 nextPhaseId, address previousAggregator) = _setFeed(asset, denomination, aggregator);\\n    s_isAggregatorEnabled[aggregator] = true;\\n    s_isAggregatorEnabled[previousAggregator] = false;\\n    emit FeedConfirmed(asset, denomination, aggregator, previousAggregator, nextPhaseId, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Returns the proposed aggregator for an asset / denomination pair\\n   * returns a zero address if there is no proposed aggregator for the pair\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @return proposedAggregator\\n  */\\n  function getProposedFeed(\\n    address asset,\\n    address denomination\\n  )\\n    public\\n    view\\n    override\\n    returns (\\n      AggregatorV2V3Interface proposedAggregator\\n    )\\n  {\\n    return _getProposedFeed(asset, denomination);\\n  }\\n\\n  /**\\n   * @notice Used if an aggregator contract has been proposed.\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @param roundId the round ID to retrieve the round data for\\n   * @return id is the round ID for which data was retrieved\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed.\\n  */\\n  function proposedGetRoundData(\\n    address asset,\\n    address denomination,\\n    uint80 roundId\\n  )\\n    external\\n    view\\n    virtual\\n    override\\n    hasProposal(asset, denomination)\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    return s_proposedAggregators[asset][denomination].getRoundData(roundId);\\n  }\\n\\n  /**\\n   * @notice Used if an aggregator contract has been proposed.\\n   * @param asset asset address\\n   * @param denomination denomination address\\n   * @return id is the round ID for which data was retrieved\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed.\\n  */\\n  function proposedLatestRoundData(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    virtual\\n    override\\n    hasProposal(asset, denomination)\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    return s_proposedAggregators[asset][denomination].latestRoundData();\\n  }\\n\\n  function getCurrentPhaseId(\\n    address asset,\\n    address denomination\\n  )\\n    public\\n    view\\n    override\\n    returns (\\n      uint16 currentPhaseId\\n    )\\n  {\\n    return s_currentPhaseId[asset][denomination];\\n  }\\n\\n  function _addPhase(\\n    uint16 phase,\\n    uint64 originalId\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint80\\n    )\\n  {\\n    return uint80(uint256(phase) << PHASE_OFFSET | originalId);\\n  }\\n\\n  function _parseIds(\\n    uint256 roundId\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint16,\\n      uint64\\n    )\\n  {\\n    uint16 phaseId = uint16(roundId >> PHASE_OFFSET);\\n    uint64 aggregatorRoundId = uint64(roundId);\\n\\n    return (phaseId, aggregatorRoundId);\\n  }\\n\\n  function _addPhaseIds(\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound,\\n      uint16 phaseId\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint80,\\n      int256,\\n      uint256,\\n      uint256,\\n      uint80\\n    )\\n  {\\n    return (\\n      _addPhase(phaseId, uint64(roundId)),\\n      answer,\\n      startedAt,\\n      updatedAt,\\n      _addPhase(phaseId, uint64(answeredInRound))\\n    );\\n  }\\n\\n  function _getPhase(\\n    address asset,\\n    address denomination,\\n    uint16 phaseId\\n  )\\n    internal\\n    view\\n    returns (\\n      Phase memory phase\\n    )\\n  {\\n    return s_phases[asset][denomination][phaseId];\\n  }\\n\\n  function _phaseExists(\\n    Phase memory phase\\n  )\\n    internal\\n    pure\\n    returns (\\n      bool\\n    )\\n  {\\n    return phase.phaseId > 0;\\n  }\\n\\n  function _getProposedFeed(\\n    address asset,\\n    address denomination\\n  )\\n    internal\\n    view\\n    returns (\\n      AggregatorV2V3Interface proposedAggregator\\n    )\\n  {\\n    return s_proposedAggregators[asset][denomination];\\n  }\\n\\n  function _getPhaseFeed(\\n    address asset,\\n    address denomination,\\n    uint16 phaseId\\n  )\\n    internal\\n    view\\n    returns (\\n      AggregatorV2V3Interface aggregator\\n    )\\n  {\\n    return s_phaseAggregators[asset][denomination][phaseId];\\n  }\\n\\n  function _getFeed(\\n    address asset,\\n    address denomination\\n  )\\n    internal\\n    view\\n    returns (\\n      AggregatorV2V3Interface aggregator\\n    )\\n  {\\n    uint16 currentPhaseId = s_currentPhaseId[asset][denomination];\\n    return _getPhaseFeed(asset, denomination, currentPhaseId);\\n  }\\n\\n  function _setFeed(\\n    address asset,\\n    address denomination,\\n    address newAggregator\\n  )\\n    internal\\n    returns (\\n      uint16 nextPhaseId,\\n      address previousAggregator\\n    )\\n  {\\n    require(newAggregator == address(s_proposedAggregators[asset][denomination]), \\\"Invalid proposed aggregator\\\");\\n    delete s_proposedAggregators[asset][denomination];\\n\\n    AggregatorV2V3Interface currentAggregator = _getFeed(asset, denomination);\\n    uint80 previousAggregatorEndingRoundId = _getLatestAggregatorRoundId(currentAggregator);\\n    uint16 currentPhaseId = s_currentPhaseId[asset][denomination];\\n    s_phases[asset][denomination][currentPhaseId].endingAggregatorRoundId = previousAggregatorEndingRoundId;\\n\\n    nextPhaseId = currentPhaseId + 1;\\n    s_currentPhaseId[asset][denomination] = nextPhaseId;\\n    s_phaseAggregators[asset][denomination][nextPhaseId] = AggregatorV2V3Interface(newAggregator);\\n    uint80 startingRoundId = _getLatestAggregatorRoundId(AggregatorV2V3Interface(newAggregator));\\n    s_phases[asset][denomination][nextPhaseId] = Phase(nextPhaseId, startingRoundId, 0);\\n\\n    return (nextPhaseId, address(currentAggregator));\\n  }\\n\\n  function _getPreviousRoundId(\\n    address asset,\\n    address denomination,\\n    uint16 phaseId,\\n    uint80 roundId\\n  )\\n    internal\\n    view\\n    returns (\\n      uint80\\n    )\\n  {\\n    for (uint16 pid = phaseId; pid > 0; pid--) {\\n      AggregatorV2V3Interface phaseAggregator = _getPhaseFeed(asset, denomination, pid);\\n      (uint80 startingRoundId, uint80 endingRoundId) = _getPhaseRange(asset, denomination, pid);\\n      if (address(phaseAggregator) == address(0)) continue;\\n      if (roundId <= startingRoundId) continue;\\n      if (roundId > startingRoundId && roundId <= endingRoundId) return roundId - 1;\\n      if (roundId > endingRoundId) return endingRoundId;\\n    }\\n    return 0; // Round not found\\n  }\\n\\n  function _getNextRoundId(\\n    address asset,\\n    address denomination,\\n    uint16 phaseId,\\n    uint80 roundId\\n  )\\n    internal\\n    view\\n    returns (\\n      uint80\\n    )\\n  {\\n    uint16 currentPhaseId = s_currentPhaseId[asset][denomination];\\n    for (uint16 pid = phaseId; pid <= currentPhaseId; pid++) {\\n      AggregatorV2V3Interface phaseAggregator = _getPhaseFeed(asset, denomination, pid);\\n      (uint80 startingRoundId, uint80 endingRoundId) =\\n        (pid == currentPhaseId) ? _getLatestRoundRange(asset, denomination, pid) : _getPhaseRange(asset, denomination, pid);\\n      if (address(phaseAggregator) == address(0)) continue;\\n      if (roundId >= endingRoundId) continue;\\n      if (roundId >= startingRoundId && roundId < endingRoundId) return roundId + 1;\\n      if (roundId < startingRoundId) return startingRoundId;\\n    }\\n    return 0; // Round not found\\n  }\\n\\n  function _getPhaseRange(\\n    address asset,\\n    address denomination,\\n    uint16 phaseId\\n  )\\n    internal\\n    view\\n    returns (\\n      uint80 startingRoundId,\\n      uint80 endingRoundId\\n    )\\n  {\\n    Phase memory phase = _getPhase(asset, denomination, phaseId);\\n    return (\\n      _getStartingRoundId(phaseId, phase),\\n      _getEndingRoundId(phaseId, phase)\\n    );\\n  }\\n\\n  function _getLatestRoundRange(\\n    address asset,\\n    address denomination,\\n    uint16 currentPhaseId\\n  )\\n    internal\\n    view\\n    returns (\\n      uint80 startingRoundId,\\n      uint80 endingRoundId\\n    )\\n  {\\n    Phase memory phase = s_phases[asset][denomination][currentPhaseId];\\n    return (\\n      _getStartingRoundId(currentPhaseId, phase),\\n      _getLatestRoundId(asset, denomination, currentPhaseId)\\n    );\\n  }\\n\\n  function _getStartingRoundId(\\n    uint16 phaseId,\\n    Phase memory phase\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint80 startingRoundId\\n    )\\n  {\\n    return _addPhase(phaseId, uint64(phase.startingAggregatorRoundId));\\n  }\\n\\n  function _getEndingRoundId(\\n    uint16 phaseId,\\n    Phase memory phase\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint80 startingRoundId\\n    )\\n  {\\n    return _addPhase(phaseId, uint64(phase.endingAggregatorRoundId));\\n  }\\n\\n  function _getLatestRoundId(\\n    address asset,\\n    address denomination,\\n    uint16 currentPhaseId\\n  )\\n    internal\\n    view\\n    returns (\\n      uint80 startingRoundId\\n    )\\n  {\\n    AggregatorV2V3Interface currentPhaseAggregator = _getFeed(asset, denomination);\\n    uint80 latestAggregatorRoundId = _getLatestAggregatorRoundId(currentPhaseAggregator);\\n    return _addPhase(currentPhaseId, uint64(latestAggregatorRoundId));\\n  }\\n\\n  function _getLatestAggregatorRoundId(\\n    AggregatorV2V3Interface aggregator\\n  )\\n    internal\\n    view\\n    returns (\\n      uint80 roundId\\n    )\\n  {\\n    if (address(aggregator) == address(0)) return uint80(0);\\n    return uint80(aggregator.latestRound());\\n  }\\n\\n  function _getPhaseIdByRoundId(\\n    address asset,\\n    address denomination,\\n    uint80 roundId\\n  )\\n    internal\\n    view\\n    returns (\\n      uint16 phaseId\\n    )\\n  {\\n    // Handle case where the round is in current phase\\n    uint16 currentPhaseId = s_currentPhaseId[asset][denomination];\\n    (uint80 startingCurrentRoundId, uint80 endingCurrentRoundId) = _getLatestRoundRange(asset, denomination, currentPhaseId);\\n    if (roundId >= startingCurrentRoundId && roundId <= endingCurrentRoundId) return currentPhaseId;\\n\\n    // Handle case where the round is in past phases\\n    for (uint16 pid = currentPhaseId - 1; pid > 0; pid--) {\\n      AggregatorV2V3Interface phaseAggregator = s_phaseAggregators[asset][denomination][pid];\\n      if (address(phaseAggregator) == address(0)) continue;\\n      (uint80 startingRoundId, uint80 endingRoundId) = _getPhaseRange(asset, denomination, pid);\\n      if (roundId >= startingRoundId && roundId <= endingRoundId) return pid;\\n      if (roundId > endingRoundId) break;\\n    }\\n    return 0;\\n  }\\n\\n  /**\\n   * @dev reverts if the caller does not have access granted by the accessController contract\\n   * to the asset / denomination pair or is the contract itself.\\n   */\\n  modifier checkPairAccess() {\\n    require(address(s_accessController) == address(0) || s_accessController.hasAccess(msg.sender, msg.data), \\\"No access\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev reverts if no proposed aggregator was set\\n   */\\n  modifier hasProposal(\\n    address asset,\\n    address denomination\\n  ) {\\n    require(address(s_proposedAggregators[asset][denomination]) != address(0), \\\"No proposed aggregator present\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\\n{\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/FeedRegistryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\npragma abicoder v2; // solhint-disable compiler-version\\n\\nimport \\\"@chainlink/contracts/src/v0.7/interfaces/AggregatorV2V3Interface.sol\\\";\\nimport \\\"./AccessControlledInterface.sol\\\";\\nimport \\\"./TypeAndVersionInterface.sol\\\";\\n\\ninterface FeedRegistryInterface is AccessControlledInterface, TypeAndVersionInterface {\\n  struct Phase {\\n    uint16 phaseId;\\n    uint80 startingAggregatorRoundId; // The latest round id of `aggregator` at phase start\\n    uint80 endingAggregatorRoundId; // The latest round of the at phase end\\n  }\\n\\n  event FeedProposed(\\n    address indexed asset,\\n    address indexed denomination,\\n    address indexed proposedAggregator,\\n    address currentAggregator,\\n    address sender\\n  );\\n  event FeedConfirmed(\\n    address indexed asset,\\n    address indexed denomination,\\n    address indexed latestAggregator,\\n    address previousAggregator,\\n    uint16 nextPhaseId,\\n    address sender\\n  );\\n\\n  // V3 AggregatorV3Interface\\n\\n  function decimals(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    returns (\\n      uint8\\n    );\\n\\n  function description(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    returns (\\n      string memory\\n    );\\n\\n  function version(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  function latestRoundData(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function getRoundData(\\n    address asset,\\n    address denomination,\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  // V2 AggregatorInterface\\n\\n  function latestAnswer(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    returns (\\n      int256 answer\\n    );\\n\\n  function latestTimestamp(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 timestamp\\n    );\\n\\n  function latestRound(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 roundId\\n    );\\n\\n  function getAnswer(\\n    address asset,\\n    address denomination,\\n    uint256 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      int256 answer\\n    );\\n\\n  function getTimestamp(\\n    address asset,\\n    address denomination,\\n    uint256 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 timestamp\\n    );\\n\\n  // Registry getters\\n\\n  function getFeed(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    returns (\\n      AggregatorV2V3Interface aggregator\\n    );\\n\\n  function getPhaseFeed(\\n    address asset,\\n    address denomination,\\n    uint16 phaseId\\n  )\\n    external\\n    view\\n    returns (\\n      AggregatorV2V3Interface aggregator\\n    );\\n\\n  function isFeedEnabled(\\n    address aggregator\\n  )\\n    external\\n    view\\n    returns (\\n      bool\\n    );\\n\\n  function getPhase(\\n    address asset,\\n    address denomination,\\n    uint16 phaseId\\n  )\\n    external\\n    view\\n    returns (\\n      Phase memory phase\\n    );\\n\\n  // Round helpers\\n\\n  function getRoundFeed(\\n    address asset,\\n    address denomination,\\n    uint80 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      AggregatorV2V3Interface aggregator\\n    );\\n\\n  function getPhaseRange(\\n    address asset,\\n    address denomination,\\n    uint16 phaseId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 startingRoundId,\\n      uint80 endingRoundId\\n    );\\n\\n  function getPreviousRoundId(\\n    address asset,\\n    address denomination,\\n    uint80 roundId\\n  ) external\\n    view\\n    returns (\\n      uint80 previousRoundId\\n    );\\n\\n  function getNextRoundId(\\n    address asset,\\n    address denomination,\\n    uint80 roundId\\n  ) external\\n    view\\n    returns (\\n      uint80 nextRoundId\\n    );\\n\\n  // Feed management\\n\\n  function proposeFeed(\\n    address asset,\\n    address denomination,\\n    address aggregator\\n  ) external;\\n\\n  function confirmFeed(\\n    address asset,\\n    address denomination,\\n    address aggregator\\n  ) external;\\n\\n  // Proposed aggregator\\n\\n  function getProposedFeed(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    returns (\\n      AggregatorV2V3Interface proposedAggregator\\n    );\\n\\n  function proposedGetRoundData(\\n    address asset,\\n    address denomination,\\n    uint80 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function proposedLatestRoundData(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  // Phases\\n  function getCurrentPhaseId(\\n    address asset,\\n    address denomination\\n  )\\n    external\\n    view\\n    returns (\\n      uint16 currentPhaseId\\n    );\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer()\\n    external\\n    view\\n    returns (\\n      int256\\n    );\\n  \\n  function latestTimestamp()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  function latestRound()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  function getAnswer(\\n    uint256 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      int256\\n    );\\n\\n  function getTimestamp(\\n    uint256 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  event AnswerUpdated(\\n    int256 indexed current,\\n    uint256 indexed roundId,\\n    uint256 updatedAt\\n  );\\n\\n  event NewRound(\\n    uint256 indexed roundId,\\n    address indexed startedBy,\\n    uint256 startedAt\\n  );\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8\\n    );\\n\\n  function description()\\n    external\\n    view\\n    returns (\\n      string memory\\n    );\\n\\n  function version()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/TypeAndVersionInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface TypeAndVersionInterface{\\n  function typeAndVersion()\\n    external\\n    pure\\n    returns (\\n      string memory\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/test/MockConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"../interfaces/FeedRegistryInterface.sol\\\";\\n\\ncontract MockConsumer {\\n  FeedRegistryInterface private s_FeedRegistry;\\n\\n  constructor(\\n    FeedRegistryInterface FeedRegistry\\n  ) {\\n    s_FeedRegistry = FeedRegistry;\\n  }\\n\\n  function getFeedRegistry()\\n    public\\n    view\\n    returns (\\n      FeedRegistryInterface\\n    )\\n  {\\n    return s_FeedRegistry;\\n  }\\n\\n  function read(\\n    address asset,\\n    address denomination\\n  )\\n    public\\n    view\\n    returns (\\n      int256\\n    )\\n  {\\n    return s_FeedRegistry.latestAnswer(asset, denomination);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/access/WriteAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"../vendor/AccessControllerInterface.sol\\\";\\nimport \\\"../vendor/ConfirmedOwner.sol\\\";\\n\\n/**\\n * @title WriteAccessController\\n * @notice Has two access lists: a global list and a data-specific list.\\n * @dev does not make any special permissions for EOAs, see\\n * ReadAccessController for that.\\n */\\ncontract WriteAccessController is AccessControllerInterface, ConfirmedOwner(msg.sender) {\\n  bool private s_checkEnabled = true;\\n  mapping(address => bool) internal s_globalAccessList;\\n  mapping(address => mapping(bytes => bool)) internal s_localAccessList;\\n\\n  event AccessAdded(address user, bytes data, address sender);\\n  event AccessRemoved(address user, bytes data, address sender);\\n  event CheckAccessEnabled();\\n  event CheckAccessDisabled();\\n\\n  function checkEnabled()\\n    public\\n    view\\n    returns (\\n      bool\\n    )\\n  {\\n    return s_checkEnabled;\\n  }\\n\\n  /**\\n   * @notice Returns the access of an address\\n   * @param user The address to query\\n   * @param data The calldata to query\\n   */\\n  function hasAccess(\\n    address user,\\n    bytes memory data\\n  )\\n    public\\n    view\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    return !s_checkEnabled || s_globalAccessList[user] || s_localAccessList[user][data];\\n  }\\n\\n/**\\n   * @notice Adds an address to the global access list\\n   * @param user The address to add\\n   */\\n  function addGlobalAccess(\\n    address user\\n  )\\n    external\\n    onlyOwner()\\n  {\\n    _addGlobalAccess(user);\\n  }\\n\\n  /**\\n   * @notice Adds an address+data to the local access list\\n   * @param user The address to add\\n   * @param data The calldata to add\\n   */\\n  function addLocalAccess(\\n    address user,\\n    bytes memory data\\n  )\\n    external\\n    onlyOwner()\\n  {\\n    _addLocalAccess(user, data);\\n  }\\n\\n  /**\\n   * @notice Removes an address from the global access list\\n   * @param user The address to remove\\n   */\\n  function removeGlobalAccess(\\n    address user\\n  )\\n    external\\n    onlyOwner()\\n  {\\n    _removeGlobalAccess(user);\\n  }\\n\\n  /**\\n   * @notice Removes an address+data from the local access list\\n   * @param user The address to remove\\n   * @param data The calldata to remove\\n   */\\n  function removeLocalAccess(\\n    address user,\\n    bytes memory data\\n  )\\n    external\\n    onlyOwner()\\n  {\\n    _removeLocalAccess(user, data);\\n  }\\n\\n  /**\\n   * @notice makes the access check enforced\\n   */\\n  function enableAccessCheck()\\n    external\\n    onlyOwner()\\n  {\\n    _enableAccessCheck();\\n  }\\n\\n  /**\\n   * @notice makes the access check unenforced\\n   */\\n  function disableAccessCheck()\\n    external\\n    onlyOwner()\\n  {\\n    _disableAccessCheck();\\n  }\\n\\n  /**\\n   * @dev reverts if the caller does not have access\\n   */\\n  modifier checkAccess() {\\n    if (s_checkEnabled) {\\n      require(hasAccess(msg.sender, msg.data), \\\"No access\\\");\\n    }\\n    _;\\n  }\\n\\n  function _enableAccessCheck() internal {\\n    if (!s_checkEnabled) {\\n      s_checkEnabled = true;\\n      emit CheckAccessEnabled();\\n    }\\n  }\\n\\n  function _disableAccessCheck() internal {\\n    if (s_checkEnabled) {\\n      s_checkEnabled = false;\\n      emit CheckAccessDisabled();\\n    }\\n  }\\n\\n  function _addGlobalAccess(address user) internal {\\n    if (!s_globalAccessList[user]) {\\n      s_globalAccessList[user] = true;\\n      emit AccessAdded(user, \\\"\\\", msg.sender);\\n    }\\n  }\\n\\n  function _removeGlobalAccess(address user) internal {\\n    if (s_globalAccessList[user]) {\\n      s_globalAccessList[user] = false;\\n      emit AccessRemoved(user, \\\"\\\", msg.sender);\\n    }\\n  }\\n\\n  function _addLocalAccess(address user, bytes memory data) internal {\\n    if (!s_localAccessList[user][data]) {\\n      s_localAccessList[user][data] = true;\\n      emit AccessAdded(user, data, msg.sender);\\n    }\\n  }\\n\\n  function _removeLocalAccess(address user, bytes memory data) internal {\\n    if (s_localAccessList[user][data]) {\\n      s_localAccessList[user][data] = false;\\n      emit AccessRemoved(user, data, msg.sender);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/access/ReadAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./WriteAccessController.sol\\\";\\nimport \\\"../utils/EOAContext.sol\\\";\\n\\n/**\\n * @title ReadAccessController\\n * @notice Gives access to:\\n * - any externally owned account (note that offchain actors can always read\\n * any contract storage regardless of onchain access control measures, so this\\n * does not weaken the access control while improving usability)\\n * - accounts explicitly added to an access list\\n * @dev ReadAccessController is not suitable for access controlling writes\\n * since it grants any externally owned account access! See\\n * WriteAccessController for that.\\n */\\ncontract ReadAccessController is WriteAccessController, EOAContext {\\n  /**\\n   * @notice Returns the access of an address\\n   * @param account The address to query\\n   * @param data The calldata to query\\n   */\\n  function hasAccess(\\n    address account,\\n    bytes memory data\\n  )\\n    public\\n    view\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    return super.hasAccess(account, data) || _isEOA(account);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/EOAContext.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\n/*\\n * @dev Provides information about the current execution context, specifically on if an account is an EOA on that chain.\\n * Different chains have different account abstractions, so this contract helps to switch behaviour between chains.\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract EOAContext {\\n  function _isEOA(address account) internal view virtual returns (bool) {\\n      return account == tx.origin; // solhint-disable-line avoid-tx-origin\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/access/PairReadAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./WriteAccessController.sol\\\";\\nimport \\\"../utils/EOAContext.sol\\\";\\n\\n/**\\n * @title PairReadAccessController\\n * @notice Extends WriteAccessController. Decodes the (asset, denomination) pair values of msg.data.\\n * @notice Gives access to:\\n * - any externally owned account (note that offchain actors can always read\\n * any contract storage regardless of onchain access control measures, so this\\n * does not weaken the access control while improving usability)\\n * - accounts explicitly added to an access list\\n * @dev PairReadAccessController is not suitable for access controlling writes\\n * since it grants any externally owned account access! See\\n * WriteAccessController for that.\\n */\\ncontract PairReadAccessController is WriteAccessController, EOAContext {\\n  /**\\n   * @notice Returns the access of an address to an asset/denomination pair\\n   * @param account The address to query\\n   * @param data The calldata to query\\n   */\\n  function hasAccess(\\n    address account,\\n    bytes calldata data\\n  )\\n    public\\n    view\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    (\\n      address asset,\\n      address denomination\\n    ) = abi.decode(data[4:], (address, address));\\n    bytes memory pairData = abi.encode(asset, denomination); // Check access to pair (TKN / ETH)\\n    return super.hasAccess(account, pairData) || _isEOA(account);\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/AggregatorProxyInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./AggregatorV2V3Interface.sol\\\";\\n\\ninterface AggregatorProxyInterface is AggregatorV2V3Interface {\\n  \\n\\tfunction phaseAggregators(\\n    uint16 phaseId\\n  )\\n    external\\n    view\\n    returns (\\n      address\\n    );\\n\\n\\tfunction phaseId()\\n    external\\n    view\\n    returns (\\n      uint16\\n    );\\n\\n\\tfunction proposedAggregator()\\n    external\\n    view\\n    returns (\\n      address\\n    );\\n\\n\\tfunction proposedGetRoundData(\\n    uint80 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n\\tfunction proposedLatestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n\\tfunction aggregator()\\n    external\\n    view\\n    returns (\\n      address\\n    );\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/dev/AggregatorProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ConfirmedOwner.sol\\\";\\nimport \\\"../interfaces/AggregatorProxyInterface.sol\\\";\\n\\n/**\\n * @title A trusted proxy for updating where current answers are read from\\n * @notice This contract provides a consistent address for the\\n * CurrentAnwerInterface but delegates where it reads from to the owner, who is\\n * trusted to update it.\\n */\\ncontract AggregatorProxy is AggregatorProxyInterface, ConfirmedOwner {\\n\\n  struct Phase {\\n    uint16 id;\\n    AggregatorProxyInterface aggregator;\\n  }\\n  AggregatorProxyInterface private s_proposedAggregator;\\n  mapping(uint16 => AggregatorProxyInterface) private s_phaseAggregators;\\n  Phase private s_currentPhase;\\n  \\n  uint256 constant private PHASE_OFFSET = 64;\\n  uint256 constant private PHASE_SIZE = 16;\\n  uint256 constant private MAX_ID = 2**(PHASE_OFFSET+PHASE_SIZE) - 1;\\n\\n  event AggregatorProposed(\\n    address indexed current,\\n    address indexed proposed\\n  );\\n  event AggregatorConfirmed(\\n    address indexed previous,\\n    address indexed latest\\n  );\\n\\n  constructor(\\n    address aggregatorAddress\\n  )\\n    ConfirmedOwner(msg.sender)\\n  {\\n    setAggregator(aggregatorAddress);\\n  }\\n\\n  /**\\n   * @notice Reads the current answer from aggregator delegated to.\\n   *\\n   * @dev #[deprecated] Use latestRoundData instead. This does not error if no\\n   * answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended latestRoundData\\n   * instead which includes better verification information.\\n   */\\n  function latestAnswer()\\n    public\\n    view\\n    virtual\\n    override\\n    returns (\\n      int256 answer\\n    )\\n  {\\n    return s_currentPhase.aggregator.latestAnswer();\\n  }\\n\\n  /**\\n   * @notice Reads the last updated height from aggregator delegated to.\\n   *\\n   * @dev #[deprecated] Use latestRoundData instead. This does not error if no\\n   * answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended latestRoundData\\n   * instead which includes better verification information.\\n   */\\n  function latestTimestamp()\\n    public\\n    view\\n    virtual\\n    override\\n    returns (\\n      uint256 updatedAt\\n    )\\n  {\\n    return s_currentPhase.aggregator.latestTimestamp();\\n  }\\n\\n  /**\\n   * @notice get past rounds answers\\n   * @param roundId the answer number to retrieve the answer for\\n   *\\n   * @dev #[deprecated] Use getRoundData instead. This does not error if no\\n   * answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended getRoundData\\n   * instead which includes better verification information.\\n   */\\n  function getAnswer(\\n    uint256 roundId\\n  )\\n    public\\n    view\\n    virtual\\n    override\\n    returns (\\n      int256 answer\\n    )\\n  {\\n    if (roundId > MAX_ID) return 0;\\n\\n    (uint16 phaseId, uint64 aggregatorRoundId) = parseIds(roundId);\\n    AggregatorProxyInterface aggregator = s_phaseAggregators[phaseId];\\n    if (address(aggregator) == address(0)) return 0;\\n\\n    return aggregator.getAnswer(aggregatorRoundId);\\n  }\\n\\n  /**\\n   * @notice get block timestamp when an answer was last updated\\n   * @param roundId the answer number to retrieve the updated timestamp for\\n   *\\n   * @dev #[deprecated] Use getRoundData instead. This does not error if no\\n   * answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended getRoundData\\n   * instead which includes better verification information.\\n   */\\n  function getTimestamp(\\n    uint256 roundId\\n  )\\n    public\\n    view\\n    virtual\\n    override\\n    returns (\\n      uint256 updatedAt\\n    )\\n  {\\n    if (roundId > MAX_ID) return 0;\\n\\n    (uint16 phaseId, uint64 aggregatorRoundId) = parseIds(roundId);\\n    AggregatorProxyInterface aggregator = s_phaseAggregators[phaseId];\\n    if (address(aggregator) == address(0)) return 0;\\n\\n    return aggregator.getTimestamp(aggregatorRoundId);\\n  }\\n\\n  /**\\n   * @notice get the latest completed round where the answer was updated. This\\n   * ID includes the proxy's phase, to make sure round IDs increase even when\\n   * switching to a newly deployed aggregator.\\n   *\\n   * @dev #[deprecated] Use latestRoundData instead. This does not error if no\\n   * answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended latestRoundData\\n   * instead which includes better verification information.\\n   */\\n  function latestRound()\\n    public\\n    view\\n    virtual\\n    override\\n    returns (\\n      uint256 roundId\\n    )\\n  {\\n    Phase memory phase = s_currentPhase; // cache storage reads\\n    return addPhase(phase.id, uint64(phase.aggregator.latestRound()));\\n  }\\n\\n  /**\\n   * @notice get data about a round. Consumers are encouraged to check\\n   * that they're receiving fresh data by inspecting the updatedAt and\\n   * answeredInRound return values.\\n   * Note that different underlying implementations of AggregatorV3Interface\\n   * have slightly different semantics for some of the return values. Consumers\\n   * should determine what implementations they expect to receive\\n   * data from and validate that they can properly handle return data from all\\n   * of them.\\n   * @param roundId the requested round ID as presented through the proxy, this\\n   * is made up of the aggregator's round ID with the phase ID encoded in the\\n   * two highest order bytes\\n   * @return id is the round ID from the aggregator for which the data was\\n   * retrieved combined with an phase to ensure that round IDs get larger as\\n   * time moves forward.\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @dev Note that answer and updatedAt may change between queries.\\n   */\\n  function getRoundData(\\n    uint80 roundId\\n  )\\n    public\\n    view\\n    virtual\\n    override\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    (uint16 phaseId, uint64 aggregatorRoundId) = parseIds(roundId);\\n\\n    (\\n      id,\\n      answer,\\n      startedAt,\\n      updatedAt,\\n      answeredInRound\\n    ) = s_phaseAggregators[phaseId].getRoundData(aggregatorRoundId);\\n\\n    return addPhaseIds(id, answer, startedAt, updatedAt, answeredInRound, phaseId);\\n  }\\n\\n  /**\\n   * @notice get data about the latest round. Consumers are encouraged to check\\n   * that they're receiving fresh data by inspecting the updatedAt and\\n   * answeredInRound return values.\\n   * Note that different underlying implementations of AggregatorV3Interface\\n   * have slightly different semantics for some of the return values. Consumers\\n   * should determine what implementations they expect to receive\\n   * data from and validate that they can properly handle return data from all\\n   * of them.\\n   * @return id is the round ID from the aggregator for which the data was\\n   * retrieved combined with an phase to ensure that round IDs get larger as\\n   * time moves forward.\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @dev Note that answer and updatedAt may change between queries.\\n   */\\n  function latestRoundData()\\n    public\\n    view\\n    virtual\\n    override\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    Phase memory current = s_currentPhase; // cache storage reads\\n\\n    (\\n      id,\\n      answer,\\n      startedAt,\\n      updatedAt,\\n      answeredInRound\\n    ) = current.aggregator.latestRoundData();\\n\\n    return addPhaseIds(id, answer, startedAt, updatedAt, answeredInRound, current.id);\\n  }\\n\\n  /**\\n   * @notice Used if an aggregator contract has been proposed.\\n   * @param roundId the round ID to retrieve the round data for\\n   * @return id is the round ID for which data was retrieved\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed.\\n  */\\n  function proposedGetRoundData(\\n    uint80 roundId\\n  )\\n    external\\n    view\\n    virtual\\n    override\\n    hasProposal()\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    return s_proposedAggregator.getRoundData(roundId);\\n  }\\n\\n  /**\\n   * @notice Used if an aggregator contract has been proposed.\\n   * @return id is the round ID for which data was retrieved\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed.\\n  */\\n  function proposedLatestRoundData()\\n    external\\n    view\\n    virtual\\n    override\\n    hasProposal()\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    return s_proposedAggregator.latestRoundData();\\n  }\\n\\n  /**\\n   * @notice returns the current phase's aggregator address.\\n   */\\n  function aggregator()\\n    external\\n    view\\n    override\\n    returns (\\n      address\\n    )\\n  {\\n    return address(s_currentPhase.aggregator);\\n  }\\n\\n  /**\\n   * @notice returns the current phase's ID.\\n   */\\n  function phaseId()\\n    external\\n    view\\n    override\\n    returns (\\n      uint16\\n    )\\n  {\\n    return s_currentPhase.id;\\n  }\\n\\n  /**\\n   * @notice represents the number of decimals the aggregator responses represent.\\n   */\\n  function decimals()\\n    external\\n    view\\n    override\\n    returns (\\n      uint8\\n    )\\n  {\\n    return s_currentPhase.aggregator.decimals();\\n  }\\n\\n  /**\\n   * @notice the version number representing the type of aggregator the proxy\\n   * points to.\\n   */\\n  function version()\\n    external\\n    view\\n    override\\n    returns (\\n      uint256\\n    )\\n  {\\n    return s_currentPhase.aggregator.version();\\n  }\\n\\n  /**\\n   * @notice returns the description of the aggregator the proxy points to.\\n   */\\n  function description()\\n    external\\n    view\\n    override\\n    returns (\\n      string memory\\n    )\\n  {\\n    return s_currentPhase.aggregator.description();\\n  }\\n\\n  /**\\n   * @notice returns the current proposed aggregator\\n   */\\n  function proposedAggregator()\\n    external\\n    view\\n    override\\n    returns (\\n      address\\n    )\\n  {\\n    return address(s_proposedAggregator);\\n  }\\n\\n  /**\\n   * @notice return a phase aggregator using the phaseId\\n   *\\n   * @param phaseId uint16\\n   */\\n  function phaseAggregators(\\n    uint16 phaseId\\n  )\\n    external\\n    view\\n    override\\n    returns (\\n      address\\n    )\\n  {\\n    return address(s_phaseAggregators[phaseId]);\\n  }\\n\\n  /**\\n   * @notice Allows the owner to propose a new address for the aggregator\\n   * @param aggregatorAddress The new address for the aggregator contract\\n   */\\n  function proposeAggregator(\\n    address aggregatorAddress\\n  )\\n    external\\n    onlyOwner()\\n  {\\n    s_proposedAggregator = AggregatorProxyInterface(aggregatorAddress);\\n    emit AggregatorProposed(address(s_currentPhase.aggregator), aggregatorAddress);\\n  }\\n\\n  /**\\n   * @notice Allows the owner to confirm and change the address\\n   * to the proposed aggregator\\n   * @dev Reverts if the given address doesn't match what was previously\\n   * proposed\\n   * @param aggregatorAddress The new address for the aggregator contract\\n   */\\n  function confirmAggregator(\\n    address aggregatorAddress\\n  )\\n    external\\n    onlyOwner()\\n  {\\n    require(aggregatorAddress == address(s_proposedAggregator), \\\"Invalid proposed aggregator\\\");\\n    address previousAggregator = address(s_currentPhase.aggregator);\\n    delete s_proposedAggregator;\\n    setAggregator(aggregatorAddress);\\n    emit AggregatorConfirmed(previousAggregator, aggregatorAddress);\\n  }\\n\\n\\n  /*\\n   * Internal\\n   */\\n\\n  function setAggregator(\\n    address aggregatorAddress\\n  )\\n    internal\\n  {\\n    uint16 id = s_currentPhase.id + 1;\\n    s_currentPhase = Phase(id, AggregatorProxyInterface(aggregatorAddress));\\n    s_phaseAggregators[id] = AggregatorProxyInterface(aggregatorAddress);\\n  }\\n\\n  function addPhase(\\n    uint16 phase,\\n    uint64 originalId\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint80\\n    )\\n  {\\n    return uint80(uint256(phase) << PHASE_OFFSET | originalId);\\n  }\\n\\n  function parseIds(\\n    uint256 roundId\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint16,\\n      uint64\\n    )\\n  {\\n    uint16 phaseId = uint16(roundId >> PHASE_OFFSET);\\n    uint64 aggregatorRoundId = uint64(roundId);\\n\\n    return (phaseId, aggregatorRoundId);\\n  }\\n\\n  function addPhaseIds(\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound,\\n      uint16 phaseId\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint80,\\n      int256,\\n      uint256,\\n      uint256,\\n      uint80\\n    )\\n  {\\n    return (\\n      addPhase(phaseId, uint64(roundId)),\\n      answer,\\n      startedAt,\\n      updatedAt,\\n      addPhase(phaseId, uint64(answeredInRound))\\n    );\\n  }\\n\\n  /*\\n   * Modifiers\\n   */\\n\\n  modifier hasProposal() {\\n    require(address(s_proposedAggregator) != address(0), \\\"No proposed aggregator present\\\");\\n    _;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/dev/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner {\\n\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(\\n    address indexed from,\\n    address indexed to\\n  );\\n  event OwnershipTransferred(\\n    address indexed from,\\n    address indexed to\\n  );\\n\\n  constructor(address newOwner) {\\n    s_owner = newOwner;\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(\\n    address to\\n  )\\n    external\\n    onlyOwner()\\n  {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership()\\n    external\\n  {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner()\\n    public\\n    view\\n    returns (\\n      address\\n    )\\n  {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n    _;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/test/MockAggregatorProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@chainlink/contracts/src/v0.7/dev/AggregatorProxy.sol\\\";\\n\\ncontract MockAggregatorProxy is AggregatorProxy {\\n    constructor(\\n        address aggregatorAddress\\n    ) AggregatorProxy(aggregatorAddress) {} // solhint-disable-line\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"accessController\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"AccessControllerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"latestAggregator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAggregator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"nextPhaseId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"FeedConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposedAggregator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currentAggregator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"FeedProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"confirmFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"}],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAccessController\",\"outputs\":[{\"internalType\":\"contract AccessControllerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"}],\"name\":\"getCurrentPhaseId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"currentPhaseId\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"}],\"name\":\"getFeed\",\"outputs\":[{\"internalType\":\"contract AggregatorV2V3Interface\",\"name\":\"aggregator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"}],\"name\":\"getNextRoundId\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"nextRoundId\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"phaseId\",\"type\":\"uint16\"}],\"name\":\"getPhase\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"phaseId\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"startingAggregatorRoundId\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"endingAggregatorRoundId\",\"type\":\"uint80\"}],\"internalType\":\"struct FeedRegistryInterface.Phase\",\"name\":\"phase\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"phaseId\",\"type\":\"uint16\"}],\"name\":\"getPhaseFeed\",\"outputs\":[{\"internalType\":\"contract AggregatorV2V3Interface\",\"name\":\"aggregator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"phaseId\",\"type\":\"uint16\"}],\"name\":\"getPhaseRange\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"startingRoundId\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"endingRoundId\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"}],\"name\":\"getPreviousRoundId\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"previousRoundId\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"}],\"name\":\"getProposedFeed\",\"outputs\":[{\"internalType\":\"contract AggregatorV2V3Interface\",\"name\":\"proposedAggregator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"_roundId\",\"type\":\"uint80\"}],\"name\":\"getRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"}],\"name\":\"getRoundFeed\",\"outputs\":[{\"internalType\":\"contract AggregatorV2V3Interface\",\"name\":\"aggregator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"isFeedEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"}],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"}],\"name\":\"latestRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"}],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"}],\"name\":\"latestTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"proposeFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"}],\"name\":\"proposedGetRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"id\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"}],\"name\":\"proposedLatestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"id\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AccessControllerInterface\",\"name\":\"_accessController\",\"type\":\"address\"}],\"name\":\"setAccessController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denomination\",\"type\":\"address\"}],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"FeedRegistry","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}