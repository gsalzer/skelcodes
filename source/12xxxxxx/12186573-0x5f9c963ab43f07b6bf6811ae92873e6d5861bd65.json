{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/RandomNumber.sol\r\n\r\npragma solidity 0.8.2;\r\n\r\nlibrary RandomNumber {\r\n    function randomNum(uint256 seed) internal returns (uint256) {\r\n        uint256 _number =\r\n            (uint256(\r\n                keccak256(abi.encodePacked(blockhash(block.number - 1), seed))\r\n            ) % 100);\r\n        if (_number <= 0) {\r\n            _number = 1;\r\n        }\r\n\r\n        return _number;\r\n    }\r\n\r\n    function rand1To10(uint256 seed) internal returns (uint256) {\r\n        uint256 _number =\r\n            (uint256(\r\n                keccak256(abi.encodePacked(blockhash(block.number - 1), seed))\r\n            ) % 10);\r\n        if (_number <= 0) {\r\n            _number = 10;\r\n        }\r\n\r\n        return _number;\r\n    }\r\n\r\n    function randDecimal(uint256 seed) internal returns (uint256) {\r\n        return (rand1To10(seed) / 10);\r\n    }\r\n\r\n    function randomNumberToMax(uint256 seed, uint256 max)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        return (uint256(\r\n            keccak256(abi.encodePacked(blockhash(block.number - 1), seed))\r\n        ) % max);\r\n    }\r\n\r\n    function randomNumber1ToMax(uint256 seed, uint256 max)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint256 _number =\r\n            (uint256(\r\n                keccak256(abi.encodePacked(blockhash(block.number - 1), seed))\r\n            ) % max);\r\n        if (_number <= 0) {\r\n            _number = max;\r\n        }\r\n\r\n        return _number;\r\n    }\r\n}\r\n\r\n// File: contracts/base/Ownable.sol\r\n\r\npragma solidity 0.8.2;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/fighter/FighterConfig.sol\r\n\r\npragma solidity 0.8.2;\r\n\r\n\r\ncontract FighterConfig is Ownable {\r\n    uint256 public currentFighterCost = 50000000000000000 wei;\r\n\r\n    string public constant LEGENDARY = \"legendary\";\r\n    string public constant EPIC = \"epic\";\r\n    string public constant RARE = \"rare\";\r\n    string public constant UNCOMMON = \"uncommon\";\r\n    string public constant COMMON = \"common\";\r\n\r\n    // actually 1 higher than real life because of the issue with a 0 index fighter\r\n    uint256 public maxFighters = 6561;\r\n    uint256 public maxLegendaryFighters = 1;\r\n    uint256 public maxEpicFighters = 5;\r\n    uint256 public maxRareFighters = 25;\r\n    uint256 public maxUncommonFighters = 125;\r\n    uint256 public maxCommonFighters = 500;\r\n    uint256 public maxFightersPerChar = 656;\r\n    string public tokenMetadataEndpoint =\r\n        \"https://cryptobrawle.rs/api/getFighterInfo/\";\r\n    bool public isTrainingEnabled = false;\r\n\r\n    uint256 public trainingFactor = 3;\r\n    uint256 public trainingCost = 5000000000000000 wei; // cost of training in wei\r\n\r\n    function setTrainingFactor(uint256 newFactor) external onlyOwner {\r\n        trainingFactor = newFactor;\r\n    }\r\n\r\n    function setNewTrainingCost(uint256 newCost) external onlyOwner {\r\n        trainingCost = newCost;\r\n    }\r\n\r\n    function enableTraining() external onlyOwner {\r\n        isTrainingEnabled = true;\r\n    }\r\n}\r\n\r\n// File: contracts/fighter/FighterBase.sol\r\n\r\npragma solidity 0.8.2;\r\n\r\n\r\ncontract FighterBase is FighterConfig {\r\n    /*** EVENTS ***/\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n    event Creation(\r\n        address owner,\r\n        uint256 fighterId,\r\n        uint256 maxHealth,\r\n        uint256 speed,\r\n        uint256 strength,\r\n        string rarity,\r\n        string name,\r\n        string imageHash,\r\n        uint256 mintNum\r\n    );\r\n    event AttributeIncrease(\r\n        address owner,\r\n        uint256 fighterId,\r\n        string attribute,\r\n        uint256 increaseValue\r\n    );\r\n    event Healed(address owner, uint256 fighterId, uint256 maxHealth);\r\n\r\n    struct Fighter {\r\n        uint256 maxHealth;\r\n        uint256 health;\r\n        uint256 speed;\r\n        uint256 strength;\r\n        string name;\r\n        string rarity;\r\n        string image;\r\n        uint256 mintNum;\r\n    }\r\n\r\n    /*** STORAGE ***/\r\n\r\n    Fighter[] fighters;\r\n    mapping(uint256 => address) public fighterIdToOwner; // lookup for owner of a specific fighter\r\n    mapping(uint256 => address) public fighterIdToApproved; // Shows appoved address for sending of fighters, Needed for ERC721\r\n    mapping(address => address[]) public ownerToOperators;\r\n    mapping(address => uint256) internal ownedFightersCount;\r\n\r\n    string[] public availableFighterNames;\r\n    mapping(string => uint256) public indexOfAvailableFighterName;\r\n\r\n    mapping(string => uint256) public rarityToSkillBuff;\r\n    mapping(string => uint256) public fighterNameToMintedCount;\r\n    mapping(string => mapping(string => string))\r\n        public fighterNameToRarityImageHashes;\r\n    mapping(string => mapping(string => uint256))\r\n        public fighterNameToRarityCounts;\r\n\r\n    function getMintedCountForFighterRarity(\r\n        string memory _fighterName,\r\n        string memory _fighterRarity\r\n    ) external view returns (uint256 mintedCount) {\r\n        return fighterNameToRarityCounts[_fighterName][_fighterRarity];\r\n    }\r\n\r\n    function addFighterCharacter(\r\n        string memory newName,\r\n        string memory legendaryImageHash,\r\n        string memory epicImageHash,\r\n        string memory rareImageHash,\r\n        string memory uncommonImageHash,\r\n        string memory commonImageHash\r\n    ) external onlyOwner {\r\n        indexOfAvailableFighterName[newName] = availableFighterNames.length;\r\n        availableFighterNames.push(newName);\r\n        fighterNameToMintedCount[newName] = 0;\r\n\r\n        fighterNameToRarityImageHashes[newName][LEGENDARY] = legendaryImageHash;\r\n        fighterNameToRarityImageHashes[newName][EPIC] = epicImageHash;\r\n        fighterNameToRarityImageHashes[newName][RARE] = rareImageHash;\r\n        fighterNameToRarityImageHashes[newName][UNCOMMON] = uncommonImageHash;\r\n        fighterNameToRarityImageHashes[newName][COMMON] = commonImageHash;\r\n\r\n        fighterNameToRarityCounts[newName][LEGENDARY] = 0;\r\n        fighterNameToRarityCounts[newName][EPIC] = 0;\r\n        fighterNameToRarityCounts[newName][RARE] = 0;\r\n        fighterNameToRarityCounts[newName][UNCOMMON] = 0;\r\n        fighterNameToRarityCounts[newName][COMMON] = 0;\r\n    }\r\n\r\n    /// @dev Checks if a given address is the current owner of a particular fighter.\r\n    /// @param _claimant the address we are validating against.\r\n    /// @param _tokenId fighter id, only valid when > 0\r\n    function _owns(address _claimant, uint256 _tokenId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return fighterIdToOwner[_tokenId] == _claimant;\r\n    }\r\n\r\n    function _transfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _fighterId\r\n    ) internal {\r\n        fighterIdToOwner[_fighterId] = _to;\r\n        ownedFightersCount[_to]++;\r\n\r\n        // Check that it isn't a newly created fighter before messing with ownership values\r\n        if (_from != address(0)) {\r\n            // Remove any existing approvals for the token\r\n            fighterIdToApproved[_fighterId] = address(0);\r\n            ownedFightersCount[_from]--;\r\n        }\r\n        // Emit the transfer event.\r\n        emit Transfer(_from, _to, _fighterId);\r\n    }\r\n\r\n    function _createFighter(\r\n        uint256 _maxHealth,\r\n        uint256 _speed,\r\n        uint256 _strength,\r\n        address _owner,\r\n        string memory _rarity,\r\n        string memory _name,\r\n        uint256 _mintNum\r\n    ) internal returns (uint256) {\r\n        string memory _fighterImage =\r\n            fighterNameToRarityImageHashes[_name][_rarity];\r\n        Fighter memory _fighter =\r\n            Fighter({\r\n                maxHealth: _maxHealth,\r\n                health: _maxHealth, // Fighters are always created with maximum health\r\n                speed: _speed,\r\n                strength: _strength,\r\n                name: _name,\r\n                rarity: _rarity,\r\n                image: _fighterImage,\r\n                mintNum: _mintNum\r\n            });\r\n\r\n        uint256 newFighterId = fighters.length;\r\n        fighters.push(_fighter);\r\n\r\n        emit Creation(\r\n            _owner,\r\n            newFighterId,\r\n            _maxHealth,\r\n            _speed,\r\n            _strength,\r\n            _rarity,\r\n            _name,\r\n            _fighterImage,\r\n            _mintNum\r\n        );\r\n\r\n        // This will assign ownership, and also emit the Transfer event as\r\n        // per ERC721 draft\r\n        _transfer(address(0), _owner, newFighterId);\r\n\r\n        return newFighterId;\r\n    }\r\n\r\n    function _updateFighterInStorage(\r\n        Fighter memory _updatedFighter,\r\n        uint256 _fighterId\r\n    ) internal {\r\n        fighters[_fighterId] = _updatedFighter;\r\n    }\r\n\r\n    function _trainSpeed(\r\n        uint256 _fighterId,\r\n        uint256 _attributeIncrease,\r\n        address _owner\r\n    ) internal {\r\n        Fighter memory _fighter = fighters[_fighterId];\r\n        _fighter.speed += _attributeIncrease;\r\n        _updateFighterInStorage(_fighter, _fighterId);\r\n\r\n        emit AttributeIncrease(_owner, _fighterId, \"speed\", _attributeIncrease);\r\n    }\r\n\r\n    function _trainStrength(\r\n        uint256 _fighterId,\r\n        uint256 _attributeIncrease,\r\n        address _owner\r\n    ) internal {\r\n        Fighter memory _fighter = fighters[_fighterId];\r\n        _fighter.strength += _attributeIncrease;\r\n        _updateFighterInStorage(_fighter, _fighterId);\r\n\r\n        emit AttributeIncrease(\r\n            _owner,\r\n            _fighterId,\r\n            \"strength\",\r\n            _attributeIncrease\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/marketplace/MarketplaceConfig.sol\r\n\r\npragma solidity 0.8.2;\r\n\r\n\r\n\r\ncontract MarketplaceConfig is Ownable, FighterBase {\r\n    uint256 public marketplaceCut = 5;\r\n    struct Combatant {\r\n        uint256 fighterId;\r\n        Fighter fighter;\r\n        uint256 damageModifier;\r\n    }\r\n\r\n    struct Sale {\r\n        uint256 fighterId;\r\n        uint256 price;\r\n    }\r\n\r\n    mapping(uint256 => Sale) public fighterIdToSale; // Storing of figher Ids against their sale Struct\r\n    mapping(uint256 => uint256) public fighterIdToBrawl; // Map of fighter Ids to their max health\r\n\r\n    event PurchaseSuccess(\r\n        address buyer,\r\n        uint256 price,\r\n        uint256 fighterId,\r\n        address seller\r\n    );\r\n    event FightComplete(\r\n        address winner,\r\n        uint256 winnerId,\r\n        address loser,\r\n        uint256 loserId\r\n    );\r\n\r\n    event MarketplaceRemoval(address owner, uint256 fighterId);\r\n    event ArenaRemoval(address owner, uint256 fighterId);\r\n\r\n    event MarketplaceAdd(address owner, uint256 fighterId, uint256 price);\r\n    event ArenaAdd(address owner, uint256 fighterId);\r\n\r\n    function setNewMarketplaceCut(uint256 _newCut) external onlyOwner {\r\n        marketplaceCut = _newCut;\r\n    }\r\n\r\n    function withdrawBalance() external onlyOwner {\r\n        payable(owner).transfer(address(this).balance);\r\n    }\r\n\r\n    function withdrawBalanceToAddress(address _recipient) external onlyOwner {\r\n        payable(_recipient).transfer(address(this).balance);\r\n    }\r\n\r\n    function killContract() external onlyOwner {\r\n        selfdestruct(payable(owner));\r\n    }\r\n\r\n    function _calculateCut(uint256 _totalPrice) internal returns (uint256) {\r\n        return ((_totalPrice / 100) * marketplaceCut);\r\n    }\r\n\r\n    function _fighterIsForSale(uint256 _fighterId) internal returns (bool) {\r\n        return (fighterIdToSale[_fighterId].price > 0);\r\n    }\r\n\r\n    function _fighterIsForBrawl(uint256 _fighterId) internal returns (bool) {\r\n        return (fighterIdToBrawl[_fighterId] > 0);\r\n    }\r\n\r\n    function _removeFighterFromSale(uint256 _fighterId) internal {\r\n        delete fighterIdToSale[_fighterId];\r\n    }\r\n\r\n    function _removeFighterFromArena(uint256 _fighterId) internal {\r\n        delete fighterIdToBrawl[_fighterId];\r\n    }\r\n}\r\n\r\n// File: contracts/marketplace/Marketplace.sol\r\n\r\npragma solidity 0.8.2;\r\n\r\n\r\n\r\ncontract Marketplace is MarketplaceConfig {\r\n    function getPriceForFighter(uint256 _fighterId) external returns (uint256) {\r\n        return fighterIdToSale[_fighterId].price;\r\n    }\r\n\r\n    function removeFighterFromSale(uint256 _fighterId) external {\r\n        require(_owns(msg.sender, _fighterId));\r\n        // Just double check we can actually remove a fighter before we go any further\r\n        require(_fighterIsForSale(_fighterId));\r\n\r\n        _removeFighterFromSale(_fighterId);\r\n        emit MarketplaceRemoval(msg.sender, _fighterId);\r\n    }\r\n\r\n    function removeFighterFromArena(uint256 _fighterId) external {\r\n        require(_owns(msg.sender, _fighterId));\r\n        // Just double check we can actually remove a fighter before we go any further\r\n        require(_fighterIsForBrawl(_fighterId));\r\n\r\n        _removeFighterFromArena(_fighterId);\r\n        emit ArenaRemoval(msg.sender, _fighterId);\r\n    }\r\n\r\n    function makeFighterAvailableForSale(uint256 _fighterId, uint256 _price)\r\n        external\r\n    {\r\n        require(_owns(msg.sender, _fighterId));\r\n        // Fighters can't be both for sale and open for brawling\r\n        require(!_fighterIsForBrawl(_fighterId));\r\n        require(_price > 0);\r\n\r\n        // Double check there is not an existing third party transfer approval\r\n        require(fighterIdToApproved[_fighterId] == address(0));\r\n\r\n        fighterIdToSale[_fighterId] = Sale({\r\n            fighterId: _fighterId,\r\n            price: _price\r\n        });\r\n        emit MarketplaceAdd(msg.sender, _fighterId, _price);\r\n    }\r\n\r\n    function makeFighterAvailableForBrawl(uint256 _fighterId) external {\r\n        require(_owns(msg.sender, _fighterId));\r\n        // Fighters can't be both for sale and open for brawling\r\n        require(!_fighterIsForSale(_fighterId));\r\n        // We don't want fighters being added twice\r\n        require(!_fighterIsForBrawl(_fighterId));\r\n\r\n        // Double check there is not an existing third party transfer approval\r\n        require(fighterIdToApproved[_fighterId] == address(0));\r\n\r\n        fighterIdToBrawl[_fighterId] = _fighterId;\r\n        emit ArenaAdd(msg.sender, _fighterId);\r\n    }\r\n\r\n    function buyFighter(uint256 _fighterId) external payable {\r\n        address _seller = fighterIdToOwner[_fighterId];\r\n        _makePurchase(_fighterId, msg.value);\r\n        _transfer(_seller, msg.sender, _fighterId);\r\n\r\n        emit PurchaseSuccess(msg.sender, msg.value, _fighterId, _seller);\r\n    }\r\n\r\n    function _strike(\r\n        uint256 _attackerId,\r\n        uint256 _defenderId,\r\n        uint256 _attackerStrength,\r\n        uint256 _defenderStrength,\r\n        uint256 _seed\r\n    ) internal returns (bool) {\r\n        uint256 _attackerAttackRoll =\r\n            RandomNumber.randomNumber1ToMax(_seed, 20) + _attackerStrength;\r\n        uint256 _defenderDefenseRoll =\r\n            RandomNumber.randomNumber1ToMax(_seed * 3, 20) + _defenderStrength;\r\n\r\n        if (_attackerAttackRoll >= _defenderDefenseRoll) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function _performFight(\r\n        uint256 _attackerId,\r\n        uint256 _defenderId,\r\n        Fighter memory _attacker,\r\n        Fighter memory _defender,\r\n        uint256 _seed\r\n    ) internal returns (uint256 winnerId, uint256 loserId) {\r\n        uint256 _generatedSeed =\r\n            RandomNumber.randomNumber1ToMax(_seed, 99999999);\r\n        uint256 _totalSpeed = _attacker.speed + _defender.speed;\r\n        uint256 _attackerSpeedRoll =\r\n            RandomNumber.randomNumber1ToMax(_seed, 20) + _attacker.speed;\r\n        uint256 _defenderSpeedRoll =\r\n            RandomNumber.randomNumber1ToMax(_generatedSeed, 20) +\r\n                _defender.speed;\r\n\r\n        bool _attackerIsStrikingFirst =\r\n            _attackerSpeedRoll >= _defenderSpeedRoll;\r\n\r\n        if (_attackerIsStrikingFirst) {\r\n            if (\r\n                _strike(\r\n                    _attackerId,\r\n                    _defenderId,\r\n                    _attacker.strength,\r\n                    _defender.strength,\r\n                    _seed * 2\r\n                )\r\n            ) {\r\n                return (_attackerId, _defenderId);\r\n            }\r\n        } else {\r\n            if (\r\n                _strike(\r\n                    _defenderId,\r\n                    _attackerId,\r\n                    _defender.strength,\r\n                    _attacker.strength,\r\n                    _generatedSeed * 2\r\n                )\r\n            ) {\r\n                return (_defenderId, _attackerId);\r\n            }\r\n        }\r\n\r\n        if (_attackerIsStrikingFirst) {\r\n            if (\r\n                _strike(\r\n                    _defenderId,\r\n                    _attackerId,\r\n                    _defender.strength,\r\n                    _attacker.strength,\r\n                    _generatedSeed * 3\r\n                )\r\n            ) {\r\n                return (_defenderId, _attackerId);\r\n            }\r\n        } else {\r\n            if (\r\n                _strike(\r\n                    _attackerId,\r\n                    _defenderId,\r\n                    _attacker.strength,\r\n                    _defender.strength,\r\n                    _seed * 3\r\n                )\r\n            ) {\r\n                return (_attackerId, _defenderId);\r\n            }\r\n        }\r\n\r\n        uint256 _defenderEndCheck =\r\n            _defender.speed +\r\n                _defender.strength +\r\n                RandomNumber.randomNumber1ToMax(_generatedSeed, 20);\r\n        uint256 _attackerEndCheck =\r\n            _attacker.speed +\r\n                _attacker.strength +\r\n                RandomNumber.randomNumber1ToMax(_seed, 20);\r\n\r\n        if (_defenderEndCheck >= _attackerEndCheck) {\r\n            return (_defenderId, _attackerId);\r\n        }\r\n        return (_attackerId, _defenderId);\r\n    }\r\n\r\n    function fight(\r\n        uint256 _attackerId,\r\n        uint256 _defenderId,\r\n        uint256 _seed\r\n    ) external {\r\n        Fighter memory _attacker = fighters[_attackerId];\r\n        Fighter memory _defender = fighters[_defenderId];\r\n        // fighter actually in the arena is always the defender\r\n        require(_fighterIsForBrawl(_defenderId));\r\n        // Make sure the challenger is actually sending the transaction\r\n        require(_owns(msg.sender, _attackerId));\r\n        // Also make sure that the challenger is not attacking his own fighter\r\n        require(!_owns(msg.sender, _defenderId));\r\n        // Ensure that a 'stronger' fighter is not attacking a 'weaker' fighter\r\n        require(\r\n            (_attacker.speed + _attacker.strength) <=\r\n                (_defender.speed + _defender.strength)\r\n        );\r\n\r\n        (uint256 _winnerId, uint256 _loserId) =\r\n            _performFight(\r\n                _attackerId,\r\n                _defenderId,\r\n                _attacker,\r\n                _defender,\r\n                _seed\r\n            );\r\n\r\n        if (_fighterIsForBrawl(_winnerId)) {\r\n            _removeFighterFromArena(_winnerId);\r\n        } else {\r\n            _removeFighterFromArena(_loserId);\r\n        }\r\n        address _winnerAddress = fighterIdToOwner[_winnerId];\r\n        address _loserAddress = fighterIdToOwner[_loserId];\r\n\r\n        _transfer(_loserAddress, _winnerAddress, _loserId);\r\n        emit FightComplete(_winnerAddress, _winnerId, _loserAddress, _loserId);\r\n    }\r\n\r\n    function _makePurchase(uint256 _fighterId, uint256 _price) internal {\r\n        require(!_owns(msg.sender, _fighterId));\r\n        require(_fighterIsForSale(_fighterId));\r\n        require(_price >= fighterIdToSale[_fighterId].price);\r\n\r\n        address sellerAddress = fighterIdToOwner[_fighterId];\r\n        _removeFighterFromSale(_fighterId);\r\n\r\n        uint256 saleCut = _calculateCut(_price);\r\n        uint256 totalSale = _price - saleCut;\r\n        payable(sellerAddress).transfer(totalSale);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/Integers.sol\r\n\r\npragma solidity 0.8.2;\r\n\r\nlibrary Integers {\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File: contracts/base/ERC721.sol\r\n\r\npragma solidity 0.8.2;\r\n\r\nabstract contract ERC721 {\r\n    // Required methods\r\n    function totalSupply() public view virtual returns (uint256 total) {}\r\n\r\n    function balanceOf(address _owner)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 balance)\r\n    {}\r\n\r\n    function ownerOf(uint256 _tokenId)\r\n        external\r\n        view\r\n        virtual\r\n        returns (address owner)\r\n    {}\r\n\r\n    function approve(address _to, uint256 _tokenId) external virtual {}\r\n\r\n    function transfer(address _to, uint256 _tokenId) external virtual {}\r\n\r\n    function tokenURI(uint256 _tokenId)\r\n        external\r\n        view\r\n        virtual\r\n        returns (string memory _tokenURI)\r\n    {}\r\n\r\n    function baseURI() external view virtual returns (string memory _baseURI) {}\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external virtual {}\r\n\r\n    function getApproved(uint256 _tokenId)\r\n        external\r\n        virtual\r\n        returns (address _approvedAddress)\r\n    {}\r\n\r\n    function setApprovalForAll(address _to, bool approved) external virtual {}\r\n\r\n    function isApprovedForAll(address _owner, address _operator)\r\n        external\r\n        virtual\r\n        returns (bool isApproved)\r\n    {}\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external virtual {}\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) external virtual {}\r\n\r\n    // Events\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    function _isContract(address _addr)\r\n        internal\r\n        view\r\n        returns (bool isContract)\r\n    {\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return (size > 0);\r\n    }\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID)\r\n        external\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {}\r\n\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the\r\n    /// recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n    /// of other than the magic value MUST result in the transaction being reverted.\r\n    /// @notice The contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    /// unless throwing\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) external virtual returns (bytes4) {}\r\n}\r\n\r\n// File: contracts/base/Priced.sol\r\n\r\npragma solidity 0.8.2;\r\n\r\ncontract Priced {\r\n    modifier costs(uint256 price) {\r\n        if (msg.value >= price) {\r\n            _;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/base/Pausable.sol\r\n\r\npragma solidity 0.8.2;\r\n\r\n\r\ncontract Pausable is Ownable {\r\n    bool public isPaused = false;\r\n\r\n    modifier whenNotPaused() {\r\n        require(!isPaused);\r\n        _;\r\n    }\r\n\r\n    function pause() external onlyOwner {\r\n        isPaused = true;\r\n    }\r\n\r\n    function unPause() external onlyOwner {\r\n        isPaused = false;\r\n    }\r\n}\r\n\r\n// File: contracts/base/IERC721Receiver.sol\r\n\r\npragma solidity ^0.8.2;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: contracts/fighter/FighterTraining.sol\r\n\r\npragma solidity 0.8.2;\r\n\r\n\r\ncontract FighterTraining is FighterBase {\r\n    function _train(\r\n        uint256 _fighterId,\r\n        string memory _attribute,\r\n        uint256 _attributeIncrease\r\n    ) internal {\r\n        if (\r\n            keccak256(abi.encodePacked(_attribute)) ==\r\n            keccak256(abi.encodePacked(\"strength\"))\r\n        ) {\r\n            _trainStrength(_fighterId, _attributeIncrease, msg.sender);\r\n        } else if (\r\n            keccak256(abi.encodePacked(_attribute)) ==\r\n            keccak256(abi.encodePacked(\"speed\"))\r\n        ) {\r\n            _trainSpeed(_fighterId, _attributeIncrease, msg.sender);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/fighter/FighterOwnership.sol\r\n\r\npragma solidity 0.8.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract FighterOwnership is\r\n    FighterConfig,\r\n    FighterBase,\r\n    FighterTraining,\r\n    ERC721,\r\n    Priced,\r\n    Pausable,\r\n    MarketplaceConfig\r\n{\r\n    using Integers for uint256;\r\n    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\r\n    string public constant name = \"CryptoBrawlers\";\r\n    string public constant symbol = \"BRAWLER\";\r\n    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n    bytes4 constant InterfaceSignature_ERC165 =\r\n        bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n    /*\r\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\r\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\r\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\r\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\r\n     *\r\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\r\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n    /*\r\n     *     bytes4(keccak256('name()')) == 0x06fdde03\r\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\r\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\r\n     *\r\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n\r\n    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\r\n    ///  Returns true for any standardized interfaces implemented by this contract. We implement\r\n    ///  ERC-165 (obviously!) and ERC-721.\r\n    function supportsInterface(bytes4 _interfaceID)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return ((_interfaceID == InterfaceSignature_ERC165) ||\r\n            (_interfaceID == _INTERFACE_ID_ERC721) ||\r\n            (_interfaceID == _INTERFACE_ID_ERC721_METADATA));\r\n    }\r\n\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) external pure override returns (bytes4) {\r\n        revert();\r\n    }\r\n\r\n    // Internal utility functions: These functions all assume that their input arguments\r\n    // are valid. We leave it to public methods to sanitize their inputs and follow\r\n    // the required logic.\r\n\r\n    /// @dev Checks if a given address currently has transferApproval for a particular fighter.\r\n    /// @param _claimant the address we are confirming brawler is approved for.\r\n    /// @param _tokenId fighter id, only valid when > 0\r\n    function _approvedFor(address _claimant, uint256 _tokenId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (fighterIdToApproved[_tokenId] == _claimant) {\r\n            return true;\r\n        }\r\n\r\n        bool _senderIsOperator = false;\r\n        address _owner = fighterIdToOwner[_tokenId];\r\n        address[] memory _validOperators = ownerToOperators[_owner];\r\n\r\n        uint256 _operatorIndex;\r\n        for (\r\n            _operatorIndex = 0;\r\n            _operatorIndex < _validOperators.length;\r\n            _operatorIndex++\r\n        ) {\r\n            if (_validOperators[_operatorIndex] == _claimant) {\r\n                _senderIsOperator = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return _senderIsOperator;\r\n    }\r\n\r\n    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\r\n    ///  approval. Setting _approved to address(0) clears all transfer approval.\r\n    ///  NOTE: _approve() does NOT send the Approval event.\r\n    function _approve(uint256 _tokenId, address _approved) internal {\r\n        fighterIdToApproved[_tokenId] = _approved;\r\n    }\r\n\r\n    /// @notice Returns the number of Fighters owned by a specific address.\r\n    /// @param _owner The owner address to check.\r\n    /// @dev Required for ERC-721 compliance\r\n    function balanceOf(address _owner)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256 count)\r\n    {\r\n        require(_owner != address(0));\r\n        return ownedFightersCount[_owner];\r\n    }\r\n\r\n    /// @notice Transfers a Fighter to another address. If transferring to a smart\r\n    /// contract be VERY CAREFUL to ensure that it is aware of ERC-721.\r\n    /// @param _to The address of the recipient, can be a user or contract.\r\n    /// @param _tokenId The ID of the fighter to transfer.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function transfer(address _to, uint256 _tokenId) external override {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        require(_to != address(this));\r\n        // You can only send your own fighter.\r\n        require(_owns(msg.sender, _tokenId));\r\n        // If transferring we can't keep a fighter in the arena...\r\n        if (_fighterIsForBrawl(_tokenId)) {\r\n            _removeFighterFromArena(_tokenId);\r\n            emit ArenaRemoval(msg.sender, _tokenId);\r\n        }\r\n\r\n        // ...nor can they be in our marketplace.\r\n        if (_fighterIsForSale(_tokenId)) {\r\n            _removeFighterFromSale(_tokenId);\r\n            emit MarketplaceRemoval(msg.sender, _tokenId);\r\n        }\r\n\r\n        // Reassign ownership, clear pending approvals, emit Transfer event.\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /// @notice Grant another address the right to transfer a specific fighter via\r\n    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\r\n    /// @param _to The address to be granted transfer approval. Pass address(0) to\r\n    ///  clear all approvals.\r\n    /// @param _tokenId The ID of the fighter that can be transferred if this call succeeds.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function approve(address _to, uint256 _tokenId) external override {\r\n        // Only an owner can grant transfer approval.\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        // If selling on an external marketplace we can't keep a fighter in the arena...\r\n        if (_fighterIsForBrawl(_tokenId)) {\r\n            _removeFighterFromArena(_tokenId);\r\n            emit ArenaRemoval(msg.sender, _tokenId);\r\n        }\r\n\r\n        // ...nor can they be in our marketplace.\r\n        if (_fighterIsForSale(_tokenId)) {\r\n            _removeFighterFromSale(_tokenId);\r\n            emit MarketplaceRemoval(msg.sender, _tokenId);\r\n        }\r\n        // Register the approval (replacing any previous approval).\r\n        _approve(_tokenId, _to);\r\n\r\n        // Emit approval event.\r\n        emit Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /// @notice Transfer a fighter owned by another address, for which the calling address\r\n    ///  has previously been granted transfer approval by the owner.\r\n    /// @param _from The address that owns the fighter to be transfered.\r\n    /// @param _to The address that should take ownership of the fighter. Can be any address,\r\n    ///  including the caller.\r\n    /// @param _tokenId The ID of the fighter to be transferred.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external override {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        require(_to != address(this));\r\n        // Check for approval and valid ownership\r\n        require(_approvedFor(msg.sender, _tokenId));\r\n        require(_owns(_from, _tokenId));\r\n\r\n        // This should never be the case, but might as well check\r\n        if (_fighterIsForBrawl(_tokenId)) {\r\n            _removeFighterFromArena(_tokenId);\r\n            emit ArenaRemoval(msg.sender, _tokenId);\r\n        }\r\n\r\n        // ...nor can they be in our marketplace.\r\n        if (_fighterIsForSale(_tokenId)) {\r\n            _removeFighterFromSale(_tokenId);\r\n            emit MarketplaceRemoval(msg.sender, _tokenId);\r\n        }\r\n\r\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\r\n        _transfer(_from, _to, _tokenId);\r\n        // Remove an existing external approval to move the fighter.\r\n        _approve(_tokenId, address(0));\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) internal {\r\n        // This should never be the case, but might as well check\r\n        if (_fighterIsForBrawl(_tokenId)) {\r\n            _removeFighterFromArena(_tokenId);\r\n            emit ArenaRemoval(msg.sender, _tokenId);\r\n        }\r\n\r\n        // ...nor can they be in our marketplace.\r\n        if (_fighterIsForSale(_tokenId)) {\r\n            _removeFighterFromSale(_tokenId);\r\n            emit MarketplaceRemoval(msg.sender, _tokenId);\r\n        }\r\n\r\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\r\n        _transfer(_from, _to, _tokenId);\r\n        // Remove an existing external approval to move the fighter.\r\n        _approve(_tokenId, address(0));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external override {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        require(_to != address(this));\r\n        // Check for approval and valid ownership\r\n        require(_approvedFor(msg.sender, _tokenId));\r\n        require(_owns(_from, _tokenId));\r\n\r\n        _safeTransferFrom(_from, _to, _tokenId);\r\n\r\n        if (_isContract(_to)) {\r\n            bytes4 retval =\r\n                IERC721Receiver(_to).onERC721Received(_from, _to, _tokenId, \"\");\r\n            require(ERC721_RECEIVED == retval);\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) external override {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        require(_to != address(this));\r\n        // Check for approval and valid ownership\r\n        require(_approvedFor(msg.sender, _tokenId));\r\n        require(_owns(_from, _tokenId));\r\n\r\n        _safeTransferFrom(_from, _to, _tokenId);\r\n\r\n        if (_isContract(_to)) {\r\n            bytes4 retval =\r\n                IERC721Receiver(_to).onERC721Received(\r\n                    _from,\r\n                    _to,\r\n                    _tokenId,\r\n                    _data\r\n                );\r\n            require(ERC721_RECEIVED == retval);\r\n        }\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId)\r\n        external\r\n        view\r\n        override\r\n        returns (address _approvedAddress)\r\n    {\r\n        return fighterIdToApproved[_tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address _to, bool _approved) external override {\r\n        address[] memory _operatorsForSender = ownerToOperators[msg.sender];\r\n        if (_approved) {\r\n            ownerToOperators[msg.sender].push(_to);\r\n        }\r\n\r\n        if (!_approved) {\r\n            if (ownerToOperators[msg.sender].length == 0) {\r\n                emit ApprovalForAll(msg.sender, _to, false);\r\n                return;\r\n            }\r\n\r\n            uint256 _operatorIndex;\r\n            for (\r\n                _operatorIndex = 0;\r\n                _operatorIndex < _operatorsForSender.length;\r\n                _operatorIndex++\r\n            ) {\r\n                if (ownerToOperators[msg.sender][_operatorIndex] == _to) {\r\n                    ownerToOperators[msg.sender][\r\n                        _operatorIndex\r\n                    ] = ownerToOperators[msg.sender][\r\n                        ownerToOperators[msg.sender].length - 1\r\n                    ];\r\n                    ownerToOperators[msg.sender].pop();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        emit ApprovalForAll(msg.sender, _to, _approved);\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator)\r\n        external\r\n        view\r\n        override\r\n        returns (bool isApproved)\r\n    {\r\n        address[] memory _operatorsForSender = ownerToOperators[_owner];\r\n\r\n        if (_operatorsForSender.length == 0) {\r\n            return false;\r\n        }\r\n        bool _isApproved = true;\r\n        uint256 _operatorIndex;\r\n        for (\r\n            _operatorIndex = 0;\r\n            _operatorIndex < _operatorsForSender.length;\r\n            _operatorIndex++\r\n        ) {\r\n            if (_operatorsForSender[_operatorIndex] != _operator) {\r\n                _isApproved = false;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return _isApproved;\r\n    }\r\n\r\n    /// @notice Returns the total number of fighters currently in existence.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function totalSupply() public view override returns (uint256) {\r\n        return fighters.length - 1; // -1 because of the phantom 0 index fighter that doesn't play nicely\r\n    }\r\n\r\n    /// @notice Returns the address currently assigned ownership of a given fighter.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function ownerOf(uint256 _tokenId)\r\n        external\r\n        view\r\n        override\r\n        returns (address owner)\r\n    {\r\n        owner = fighterIdToOwner[_tokenId];\r\n        require(owner != address(0));\r\n\r\n        return owner;\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId)\r\n        external\r\n        view\r\n        override\r\n        returns (string memory)\r\n    {\r\n        return\r\n            string(\r\n                abi.encodePacked(tokenMetadataEndpoint, _tokenId.toString())\r\n            );\r\n    }\r\n\r\n    function baseURI() external view override returns (string memory) {\r\n        return tokenMetadataEndpoint;\r\n    }\r\n\r\n    modifier currentFighterPrice() {\r\n        require(msg.value >= currentFighterCost);\r\n        _;\r\n    }\r\n\r\n    function trainFighter(\r\n        uint256 _fighterId,\r\n        string memory _attribute,\r\n        uint256 _seed\r\n    ) external payable costs(trainingCost) returns (uint256 _increaseValue) {\r\n        require(isTrainingEnabled);\r\n        require(_owns(msg.sender, _fighterId));\r\n        uint256 _attributeIncrease =\r\n            (RandomNumber.rand1To10(_seed) / trainingFactor);\r\n        if (_attributeIncrease == 0) {\r\n            _attributeIncrease = 1;\r\n        }\r\n\r\n        _train(_fighterId, _attribute, _attributeIncrease);\r\n        return _attributeIncrease;\r\n    }\r\n\r\n    function _getFighterRarity(uint256 _seed, string memory _fighterName)\r\n        internal\r\n        returns (string memory)\r\n    {\r\n        uint256 _rarityRoll =\r\n            RandomNumber.randomNumber1ToMax(_seed, maxFightersPerChar);\r\n        uint256 _minEpicRoll =\r\n            maxFightersPerChar - (maxEpicFighters + maxLegendaryFighters);\r\n        uint256 _minRareRoll =\r\n            maxFightersPerChar -\r\n                (maxRareFighters + maxEpicFighters + maxLegendaryFighters);\r\n        uint256 _minUncommonRoll =\r\n            maxFightersPerChar -\r\n                (maxUncommonFighters +\r\n                    maxRareFighters +\r\n                    maxEpicFighters +\r\n                    maxLegendaryFighters);\r\n\r\n        if (\r\n            fighterNameToRarityCounts[_fighterName][LEGENDARY] <\r\n            maxLegendaryFighters &&\r\n            _rarityRoll == maxFightersPerChar\r\n        ) {\r\n            return LEGENDARY;\r\n        }\r\n        if (\r\n            fighterNameToRarityCounts[_fighterName][EPIC] < maxEpicFighters &&\r\n            _rarityRoll >= _minEpicRoll\r\n        ) {\r\n            return EPIC;\r\n        }\r\n        if (\r\n            fighterNameToRarityCounts[_fighterName][RARE] < maxRareFighters &&\r\n            _rarityRoll >= _minRareRoll\r\n        ) {\r\n            return RARE;\r\n        }\r\n        if (\r\n            fighterNameToRarityCounts[_fighterName][UNCOMMON] <\r\n            maxUncommonFighters &&\r\n            _rarityRoll >= _minUncommonRoll\r\n        ) {\r\n            return UNCOMMON;\r\n        }\r\n        if (\r\n            fighterNameToRarityCounts[_fighterName][COMMON] <\r\n            maxCommonFighters &&\r\n            _rarityRoll >= 1\r\n        ) {\r\n            return COMMON;\r\n        }\r\n\r\n        string[] memory _leftoverRarities;\r\n        if (\r\n            fighterNameToRarityCounts[_fighterName][LEGENDARY] <\r\n            maxLegendaryFighters\r\n        ) {\r\n            _leftoverRarities[_leftoverRarities.length] = LEGENDARY;\r\n        }\r\n        if (fighterNameToRarityCounts[_fighterName][EPIC] < maxEpicFighters) {\r\n            _leftoverRarities[_leftoverRarities.length] = EPIC;\r\n        }\r\n        if (fighterNameToRarityCounts[_fighterName][RARE] < maxRareFighters) {\r\n            _leftoverRarities[_leftoverRarities.length] = RARE;\r\n        }\r\n        if (\r\n            fighterNameToRarityCounts[_fighterName][UNCOMMON] <\r\n            maxUncommonFighters\r\n        ) {\r\n            _leftoverRarities[_leftoverRarities.length] = UNCOMMON;\r\n        }\r\n        if (\r\n            fighterNameToRarityCounts[_fighterName][COMMON] < maxCommonFighters\r\n        ) {\r\n            _leftoverRarities[_leftoverRarities.length] = COMMON;\r\n        }\r\n\r\n        if (_leftoverRarities.length == 1) {\r\n            return _leftoverRarities[0];\r\n        }\r\n\r\n        uint256 _leftoverRoll =\r\n            RandomNumber.randomNumberToMax(_seed, _leftoverRarities.length);\r\n        return _leftoverRarities[_leftoverRoll];\r\n    }\r\n\r\n    function _getFighterName(uint256 _seed)\r\n        internal\r\n        returns (string memory _fighterName)\r\n    {\r\n        uint256 _nameIndex =\r\n            RandomNumber.randomNumberToMax(_seed, availableFighterNames.length); // Use the whole array length because the random max number does not include the top end\r\n        return availableFighterNames[_nameIndex];\r\n    }\r\n\r\n    function _removeNameFromAvailableNamesArray(string memory _fighterName)\r\n        internal\r\n    {\r\n        uint256 _nameIndex = indexOfAvailableFighterName[_fighterName];\r\n        require(\r\n            keccak256(abi.encodePacked(availableFighterNames[_nameIndex])) ==\r\n                keccak256(abi.encodePacked(_fighterName))\r\n        ); // double check something wiggly hasn't happened\r\n\r\n        if (availableFighterNames.length > 1) {\r\n            availableFighterNames[_nameIndex] = availableFighterNames[\r\n                availableFighterNames.length - 1\r\n            ];\r\n        }\r\n        availableFighterNames.pop();\r\n    }\r\n\r\n    function searchForFighter(uint256 _seed)\r\n        external\r\n        payable\r\n        currentFighterPrice\r\n        whenNotPaused()\r\n        returns (uint256 newFighterId)\r\n    {\r\n        require(fighters.length < maxFighters);\r\n        string memory _fighterName = _getFighterName(_seed);\r\n        string memory _fighterRarity = _getFighterRarity(_seed, _fighterName);\r\n        uint256 _speed =\r\n            RandomNumber.rand1To10(_seed) + rarityToSkillBuff[_fighterRarity];\r\n        uint256 _strength =\r\n            RandomNumber.rand1To10(_speed + _seed) +\r\n                rarityToSkillBuff[_fighterRarity];\r\n\r\n        fighterNameToMintedCount[_fighterName] += 1;\r\n        fighterNameToRarityCounts[_fighterName][_fighterRarity] += 1;\r\n\r\n        uint256 _fighterId =\r\n            _createFighter(\r\n                10,\r\n                _speed,\r\n                _strength,\r\n                msg.sender,\r\n                _fighterRarity,\r\n                _fighterName,\r\n                fighterNameToRarityCounts[_fighterName][_fighterRarity]\r\n            );\r\n\r\n        if (fighterNameToMintedCount[_fighterName] >= maxFightersPerChar) {\r\n            _removeNameFromAvailableNamesArray(_fighterName);\r\n        }\r\n\r\n        uint256 _fighterCost = _getFighterCost();\r\n        if (_fighterCost > currentFighterCost) {\r\n            currentFighterCost = _fighterCost;\r\n        }\r\n\r\n        return _fighterId;\r\n    }\r\n\r\n    function _getFighterCost() internal returns (uint256 _cost) {\r\n        uint256 currentTotalFighters = fighters.length - 1;\r\n\r\n        if (currentTotalFighters < 500) {\r\n            return 50000000000000000 wei;\r\n        }\r\n        if (currentTotalFighters >= 500 && currentTotalFighters < 1000) {\r\n            return 100000000000000000 wei;\r\n        }\r\n        if (currentTotalFighters >= 1000 && currentTotalFighters < 1500) {\r\n            return 150000000000000000 wei;\r\n        }\r\n        if (currentTotalFighters >= 1500 && currentTotalFighters < 2000) {\r\n            return 200000000000000000 wei;\r\n        }\r\n        if (currentTotalFighters >= 2000 && currentTotalFighters < 2500) {\r\n            return 250000000000000000 wei;\r\n        }\r\n        if (currentTotalFighters >= 2500 && currentTotalFighters < 3000) {\r\n            return 300000000000000000 wei;\r\n        }\r\n        if (currentTotalFighters >= 3000 && currentTotalFighters < 3500) {\r\n            return 350000000000000000 wei;\r\n        }\r\n        if (currentTotalFighters >= 3500 && currentTotalFighters < 4000) {\r\n            return 400000000000000000 wei;\r\n        }\r\n        if (currentTotalFighters >= 4000 && currentTotalFighters < 4500) {\r\n            return 450000000000000000 wei;\r\n        }\r\n        if (currentTotalFighters >= 4500 && currentTotalFighters < 5000) {\r\n            return 500000000000000000 wei;\r\n        }\r\n        if (currentTotalFighters >= 5000 && currentTotalFighters < 5500) {\r\n            return 550000000000000000 wei;\r\n        }\r\n        if (currentTotalFighters >= 5500 && currentTotalFighters < 6000) {\r\n            return 600000000000000000 wei;\r\n        }\r\n        if (currentTotalFighters >= 6000) {\r\n            return 650000000000000000 wei;\r\n        }\r\n        return 650000000000000000 wei;\r\n    }\r\n}\r\n\r\n// File: contracts/CryptoBrawlers.sol\r\n\r\npragma solidity 0.8.2;\r\n\r\n\r\n\r\ncontract CryptoBrawlers is Marketplace, FighterOwnership {\r\n    constructor() {\r\n        rarityToSkillBuff[LEGENDARY] = 10;\r\n        rarityToSkillBuff[EPIC] = 5;\r\n        rarityToSkillBuff[RARE] = 3;\r\n        rarityToSkillBuff[UNCOMMON] = 1;\r\n        rarityToSkillBuff[COMMON] = 0;\r\n\r\n        fighters.push(); // phantom 0 index element in the fighters array to begin\r\n    }\r\n\r\n    function getInfoForFighter(uint256 _fighterId)\r\n        external\r\n        returns (\r\n            uint256 health,\r\n            uint256 speed,\r\n            uint256 strength,\r\n            string memory fighterName,\r\n            string memory image,\r\n            string memory rarity,\r\n            uint256 mintNum\r\n        )\r\n    {\r\n        Fighter memory _fighter = fighters[_fighterId];\r\n        return (\r\n            _fighter.health,\r\n            _fighter.speed,\r\n            _fighter.strength,\r\n            _fighter.name,\r\n            _fighter.image,\r\n            _fighter.rarity,\r\n            _fighter.mintNum\r\n        );\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fighterId\",\"type\":\"uint256\"}],\"name\":\"ArenaAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fighterId\",\"type\":\"uint256\"}],\"name\":\"ArenaRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fighterId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"increaseValue\",\"type\":\"uint256\"}],\"name\":\"AttributeIncrease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fighterId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxHealth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"speed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"strength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"rarity\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"imageHash\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintNum\",\"type\":\"uint256\"}],\"name\":\"Creation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winnerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loserId\",\"type\":\"uint256\"}],\"name\":\"FightComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fighterId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxHealth\",\"type\":\"uint256\"}],\"name\":\"Healed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fighterId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"MarketplaceAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fighterId\",\"type\":\"uint256\"}],\"name\":\"MarketplaceRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fighterId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"PurchaseSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"COMMON\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EPIC\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LEGENDARY\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RARE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNCOMMON\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"legendaryImageHash\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"epicImageHash\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"rareImageHash\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uncommonImageHash\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"commonImageHash\",\"type\":\"string\"}],\"name\":\"addFighterCharacter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"availableFighterNames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fighterId\",\"type\":\"uint256\"}],\"name\":\"buyFighter\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentFighterCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTraining\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_attackerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_defenderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"}],\"name\":\"fight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fighterIdToApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fighterIdToBrawl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fighterIdToOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fighterIdToSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fighterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"fighterNameToMintedCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"fighterNameToRarityCounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"fighterNameToRarityImageHashes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_approvedAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fighterId\",\"type\":\"uint256\"}],\"name\":\"getInfoForFighter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"health\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"speed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strength\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"fighterName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"image\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"rarity\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"mintNum\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_fighterName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_fighterRarity\",\"type\":\"string\"}],\"name\":\"getMintedCountForFighterRarity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintedCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fighterId\",\"type\":\"uint256\"}],\"name\":\"getPriceForFighter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"indexOfAvailableFighterName\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTrainingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"killContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fighterId\",\"type\":\"uint256\"}],\"name\":\"makeFighterAvailableForBrawl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fighterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"makeFighterAvailableForSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketplaceCut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxCommonFighters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxEpicFighters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFighters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFightersPerChar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLegendaryFighters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxRareFighters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxUncommonFighters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerToOperators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"rarityToSkillBuff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fighterId\",\"type\":\"uint256\"}],\"name\":\"removeFighterFromArena\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fighterId\",\"type\":\"uint256\"}],\"name\":\"removeFighterFromSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"}],\"name\":\"searchForFighter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newFighterId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newCut\",\"type\":\"uint256\"}],\"name\":\"setNewMarketplaceCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCost\",\"type\":\"uint256\"}],\"name\":\"setNewTrainingCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFactor\",\"type\":\"uint256\"}],\"name\":\"setTrainingFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenMetadataEndpoint\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fighterId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_attribute\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"}],\"name\":\"trainFighter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_increaseValue\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trainingCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trainingFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdrawBalanceToAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CryptoBrawlers","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6e89ee0f8d041e1bbc388a14a16b87316463cd4d1cba57214e40420abe5f58b6"}]}