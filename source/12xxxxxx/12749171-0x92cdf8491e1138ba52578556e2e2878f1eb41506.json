{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"./contracts/APContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/upgrades-core/contracts/Initializable.sol\\\";\\nimport \\\"./interfaces/IPriceModule.sol\\\";\\n\\ncontract APContract is Initializable {\\n    address public yieldsterDAO;\\n\\n    address public yieldsterTreasury;\\n\\n    address public yieldsterGOD;\\n\\n    address public emergencyVault;\\n\\n    address public yieldsterExchange;\\n\\n    address public stringUtils;\\n\\n    address public whitelistModule;\\n\\n    address public whitelistManager;\\n\\n    address public proxyFactory;\\n\\n    address public priceModule;\\n\\n    address public platFormManagementFee;\\n\\n    address public profitManagementFee;\\n\\n    address public stockDeposit;\\n\\n    address public stockWithdraw;\\n\\n    address public safeMinter;\\n\\n    address public safeUtils;\\n\\n    address public exchangeRegistry;\\n\\n    struct Vault {\\n        mapping(address => bool) vaultAssets;\\n        mapping(address => bool) vaultDepositAssets;\\n        mapping(address => bool) vaultWithdrawalAssets;\\n        mapping(address => bool) vaultEnabledStrategy;\\n        address depositStrategy;\\n        address withdrawStrategy;\\n        address vaultAPSManager;\\n        address vaultStrategyManager;\\n        uint256[] whitelistGroup;\\n        bool created;\\n        uint256 slippage;\\n    }\\n\\n    struct VaultActiveStrategy {\\n        mapping(address => bool) isActiveStrategy;\\n        mapping(address => uint256) activeStrategyIndex;\\n        address[] activeStrategyList;\\n    }\\n\\n    struct Strategy {\\n        mapping(address => bool) strategyProtocols;\\n        bool created;\\n        address minter;\\n        address executor;\\n        address benefeciary;\\n        uint256 managementFeePercentage;\\n    }\\n\\n    struct SmartStrategy {\\n        address minter;\\n        address executor;\\n        bool created;\\n    }\\n\\n    struct vaultActiveManagemetFee {\\n        mapping(address => bool) isActiveManagementFee;\\n        mapping(address => uint256) activeManagementFeeIndex;\\n        address[] activeManagementFeeList;\\n    }\\n\\n    event VaultCreation(address vaultAddress);\\n\\n    mapping(address => vaultActiveManagemetFee) managementFeeStrategies;\\n\\n    mapping(address => mapping(address => mapping(address => bool))) vaultStrategyEnabledProtocols;\\n\\n    mapping(address => VaultActiveStrategy) vaultActiveStrategies;\\n\\n    mapping(address => bool) assets;\\n\\n    mapping(address => bool) protocols;\\n\\n    mapping(address => Vault) vaults;\\n\\n    mapping(address => Strategy) strategies;\\n\\n    mapping(address => SmartStrategy) smartStrategies;\\n\\n    mapping(address => bool) vaultCreated;\\n\\n    mapping(address => bool) APSManagers;\\n\\n    mapping(address => address) minterStrategyMap;\\n\\n    function initialize(\\n        address _yieldsterDAO,\\n        address _yieldsterTreasury,\\n        address _yieldsterGOD,\\n        address _emergencyVault,\\n        address _apsManager\\n    ) external initializer {\\n        yieldsterDAO = _yieldsterDAO;\\n        yieldsterTreasury = _yieldsterTreasury;\\n        yieldsterGOD = _yieldsterGOD;\\n        emergencyVault = _emergencyVault;\\n        APSManagers[_apsManager] = true;\\n    }\\n\\n    function configureAPS(\\n        address _whitelistModule,\\n        address _platformManagementFee,\\n        address _profitManagementFee,\\n        address _stringUtils,\\n        address _yieldsterExchange,\\n        address _exchangeRegistry,\\n        address _priceModule,\\n        address _safeUtils\\n    ) external onlyYieldsterDAO {\\n        whitelistModule = _whitelistModule;\\n        platFormManagementFee = _platformManagementFee;\\n        stringUtils = _stringUtils;\\n        yieldsterExchange = _yieldsterExchange;\\n        exchangeRegistry = _exchangeRegistry;\\n        priceModule = _priceModule;\\n        safeUtils = _safeUtils;\\n        profitManagementFee = _profitManagementFee;\\n    }\\n\\n    /// @dev Function to add proxy Factory address to Yieldster.\\n    /// @param _proxyFactory Address of proxy factory.\\n    function addProxyFactory(address _proxyFactory) external onlyManager {\\n        proxyFactory = _proxyFactory;\\n    }\\n\\n    function setProfitAndPlatformManagementFeeStrategies(\\n        address _platformManagement,\\n        address _profitManagement\\n    ) external onlyYieldsterDAO {\\n        if (_profitManagement != address(0))\\n            profitManagementFee = _profitManagement;\\n        if (_platformManagement != address(0))\\n            platFormManagementFee = _platformManagement;\\n    }\\n\\n    //Modifiers\\n    modifier onlyYieldsterDAO {\\n        require(\\n            yieldsterDAO == msg.sender,\\n            \\\"Only Yieldster DAO is allowed to perform this operation\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyManager {\\n        require(\\n            APSManagers[msg.sender],\\n            \\\"Only APS managers allowed to perform this operation!\\\"\\n        );\\n        _;\\n    }\\n\\n    function isVault(address _address) external view returns (bool) {\\n        return vaults[_address].created;\\n    }\\n\\n    /// @dev Function to add APS manager to Yieldster.\\n    /// @param _manager Address of the manager.\\n    function addManager(address _manager) external onlyYieldsterDAO {\\n        APSManagers[_manager] = true;\\n    }\\n\\n    /// @dev Function to remove APS manager from Yieldster.\\n    /// @param _manager Address of the manager.\\n    function removeManager(address _manager) external onlyYieldsterDAO {\\n        APSManagers[_manager] = false;\\n    }\\n\\n    /// @dev Function to change whitelist Manager.\\n    /// @param _whitelistManager Address of the whitelist manager.\\n    function changeWhitelistManager(address _whitelistManager)\\n        external\\n        onlyYieldsterDAO\\n    {\\n        whitelistManager = _whitelistManager;\\n    }\\n\\n    /// @dev Function to set Yieldster GOD.\\n    /// @param _yieldsterGOD Address of the Yieldster GOD.\\n    function setYieldsterGOD(address _yieldsterGOD) external {\\n        require(\\n            msg.sender == yieldsterGOD,\\n            \\\"Only Yieldster GOD can perform this operation\\\"\\n        );\\n        yieldsterGOD = _yieldsterGOD;\\n    }\\n\\n    /// @dev Function to set Yieldster DAO.\\n    /// @param _yieldsterDAO Address of the Yieldster DAO.\\n    function setYieldsterDAO(address _yieldsterDAO) external {\\n        require(\\n            msg.sender == yieldsterDAO,\\n            \\\"Only Yieldster DAO can perform this operation\\\"\\n        );\\n        yieldsterDAO = _yieldsterDAO;\\n    }\\n\\n    /// @dev Function to set Yieldster Treasury.\\n    /// @param _yieldsterTreasury Address of the Yieldster Treasury.\\n    function setYieldsterTreasury(address _yieldsterTreasury) external {\\n        require(\\n            msg.sender == yieldsterDAO,\\n            \\\"Only Yieldster DAO can perform this operation\\\"\\n        );\\n        yieldsterTreasury = _yieldsterTreasury;\\n    }\\n\\n    /// @dev Function to disable Yieldster GOD.\\n    function disableYieldsterGOD() external {\\n        require(\\n            msg.sender == yieldsterGOD,\\n            \\\"Only Yieldster GOD can perform this operation\\\"\\n        );\\n        yieldsterGOD = address(0);\\n    }\\n\\n    /// @dev Function to set Emergency vault.\\n    /// @param _emergencyVault Address of the Yieldster Emergency vault.\\n    function setEmergencyVault(address _emergencyVault)\\n        external\\n        onlyYieldsterDAO\\n    {\\n        emergencyVault = _emergencyVault;\\n    }\\n\\n    /// @dev Function to set Safe Minter.\\n    /// @param _safeMinter Address of the Safe Minter.\\n    function setSafeMinter(address _safeMinter) external onlyYieldsterDAO {\\n        safeMinter = _safeMinter;\\n    }\\n\\n    /// @dev Function to set safeUtils contract.\\n    /// @param _safeUtils Address of the safeUtils contract.\\n    function setSafeUtils(address _safeUtils) external onlyYieldsterDAO {\\n        safeUtils = _safeUtils;\\n    }\\n\\n    /// @dev Function to set stringUtils contract.\\n    /// @param _stringUtils Address of the stringUtils contract.\\n    function setStringUtils(address _stringUtils) external onlyYieldsterDAO {\\n        stringUtils = _stringUtils;\\n    }\\n\\n    /// @dev Function to set whitelistModule contract.\\n    /// @param _whitelistModule Address of the whitelistModule contract.\\n    function setWhitelistModule(address _whitelistModule)\\n        external\\n        onlyYieldsterDAO\\n    {\\n        whitelistModule = _whitelistModule;\\n    }\\n\\n    /// @dev Function to set exchangeRegistry address.\\n    /// @param _exchangeRegistry Address of the exchangeRegistry.\\n    function setExchangeRegistry(address _exchangeRegistry)\\n        external\\n        onlyYieldsterDAO\\n    {\\n        exchangeRegistry = _exchangeRegistry;\\n    }\\n\\n    /// @dev Function to get strategy address from minter.\\n    /// @param _minter Address of the minter.\\n    function getStrategyFromMinter(address _minter)\\n        external\\n        view\\n        returns (address)\\n    {\\n        return minterStrategyMap[_minter];\\n    }\\n\\n    /// @dev Function to set Yieldster Exchange.\\n    /// @param _yieldsterExchange Address of the Yieldster exchange.\\n    function setYieldsterExchange(address _yieldsterExchange)\\n        external\\n        onlyYieldsterDAO\\n    {\\n        yieldsterExchange = _yieldsterExchange;\\n    }\\n\\n    /// @dev Function to set stock Deposit and Withdraw.\\n    /// @param _stockDeposit Address of the stock deposit contract.\\n    /// @param _stockWithdraw Address of the stock withdraw contract.\\n    function setStockDepositWithdraw(\\n        address _stockDeposit,\\n        address _stockWithdraw\\n    ) external onlyYieldsterDAO {\\n        stockDeposit = _stockDeposit;\\n        stockWithdraw = _stockWithdraw;\\n    }\\n\\n    /// @dev Function to change the APS Manager for a vault.\\n    /// @param _vaultAPSManager Address of the new APS Manager.\\n    function changeVaultAPSManager(address _vaultAPSManager) external {\\n        require(vaults[msg.sender].created, \\\"Vault is not present\\\");\\n        vaults[msg.sender].vaultAPSManager = _vaultAPSManager;\\n    }\\n\\n    /// @dev Function to change the Strategy Manager for a vault.\\n    /// @param _vaultStrategyManager Address of the new Strategy Manager.\\n    function changeVaultStrategyManager(address _vaultStrategyManager)\\n        external\\n    {\\n        require(vaults[msg.sender].created, \\\"Vault is not present\\\");\\n        vaults[msg.sender].vaultStrategyManager = _vaultStrategyManager;\\n    }\\n\\n    /// @dev Function to change the Slippage Settings for a vault.\\n    /// @param _slippage value of slippage.\\n    function setVaultSlippage(uint256 _slippage) external {\\n        require(vaults[msg.sender].created, \\\"Vault is not present\\\");\\n        vaults[msg.sender].slippage = _slippage;\\n    }\\n\\n    /// @dev Function to get the Slippage Settings for a vault.\\n    function getVaultSlippage() external view returns (uint256) {\\n        require(vaults[msg.sender].created, \\\"Vault is not present\\\");\\n        return vaults[msg.sender].slippage;\\n    }\\n\\n    //Price Module\\n    /// @dev Function to set Yieldster price module.\\n    /// @param _priceModule Address of the price module.\\n    function setPriceModule(address _priceModule) external onlyManager {\\n        priceModule = _priceModule;\\n    }\\n\\n    /// @dev Function to get the USD price for a token.\\n    /// @param _tokenAddress Address of the token.\\n    function getUSDPrice(address _tokenAddress)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return IPriceModule(priceModule).getUSDPrice(_tokenAddress);\\n    }\\n\\n    //Vaults\\n    /// @dev Function to create a vault.\\n    /// @param _vaultAddress Address of the new vault.\\n    function createVault(address _vaultAddress) external {\\n        require(\\n            msg.sender == proxyFactory,\\n            \\\"Only Proxy Factory can perform this operation\\\"\\n        );\\n        vaultCreated[_vaultAddress] = true;\\n    }\\n\\n    /// @dev Function to add a vault in the APS.\\n    /// @param _vaultAPSManager Address of the vaults APS Manager.\\n    /// @param _vaultStrategyManager Address of the vaults Strateg Manager.\\n    /// @param _whitelistGroup List of whitelist groups applied to the vault.\\n    function addVault(\\n        address _vaultAPSManager,\\n        address _vaultStrategyManager,\\n        uint256[] calldata _whitelistGroup\\n    ) external {\\n        require(vaultCreated[msg.sender], \\\"Vault not created\\\");\\n        Vault memory newVault = Vault({\\n            vaultAPSManager: _vaultAPSManager,\\n            vaultStrategyManager: _vaultStrategyManager,\\n            whitelistGroup: _whitelistGroup,\\n            depositStrategy: stockDeposit,\\n            withdrawStrategy: stockWithdraw,\\n            created: true,\\n            slippage: 50\\n        });\\n        vaults[msg.sender] = newVault;\\n\\n        //applying Platform management fee\\n        managementFeeStrategies[msg.sender].isActiveManagementFee[\\n            platFormManagementFee\\n        ] = true;\\n        managementFeeStrategies[msg.sender].activeManagementFeeIndex[\\n            platFormManagementFee\\n        ] = managementFeeStrategies[msg.sender].activeManagementFeeList.length;\\n        managementFeeStrategies[msg.sender].activeManagementFeeList.push(\\n            platFormManagementFee\\n        );\\n\\n        //applying Profit management fee\\n        managementFeeStrategies[msg.sender].isActiveManagementFee[\\n            profitManagementFee\\n        ] = true;\\n        managementFeeStrategies[msg.sender].activeManagementFeeIndex[\\n            profitManagementFee\\n        ] = managementFeeStrategies[msg.sender].activeManagementFeeList.length;\\n        managementFeeStrategies[msg.sender].activeManagementFeeList.push(\\n            profitManagementFee\\n        );\\n    }\\n\\n    /// @dev Function to Manage the vault assets.\\n    /// @param _enabledDepositAsset List of deposit assets to be enabled in the vault.\\n    /// @param _enabledWithdrawalAsset List of withdrawal assets to be enabled in the vault.\\n    /// @param _disabledDepositAsset List of deposit assets to be disabled in the vault.\\n    /// @param _disabledWithdrawalAsset List of withdrawal assets to be disabled in the vault.\\n    function setVaultAssets(\\n        address[] calldata _enabledDepositAsset,\\n        address[] calldata _enabledWithdrawalAsset,\\n        address[] calldata _disabledDepositAsset,\\n        address[] calldata _disabledWithdrawalAsset\\n    ) external {\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\n\\n        for (uint256 i = 0; i < _enabledDepositAsset.length; i++) {\\n            address asset = _enabledDepositAsset[i];\\n            require(_isAssetPresent(asset), \\\"Asset not supported by Yieldster\\\");\\n            vaults[msg.sender].vaultAssets[asset] = true;\\n            vaults[msg.sender].vaultDepositAssets[asset] = true;\\n        }\\n\\n        for (uint256 i = 0; i < _enabledWithdrawalAsset.length; i++) {\\n            address asset = _enabledWithdrawalAsset[i];\\n            require(_isAssetPresent(asset), \\\"Asset not supported by Yieldster\\\");\\n            vaults[msg.sender].vaultAssets[asset] = true;\\n            vaults[msg.sender].vaultWithdrawalAssets[asset] = true;\\n        }\\n\\n        for (uint256 i = 0; i < _disabledDepositAsset.length; i++) {\\n            address asset = _disabledDepositAsset[i];\\n            require(_isAssetPresent(asset), \\\"Asset not supported by Yieldster\\\");\\n            vaults[msg.sender].vaultAssets[asset] = false;\\n            vaults[msg.sender].vaultDepositAssets[asset] = false;\\n        }\\n\\n        for (uint256 i = 0; i < _disabledWithdrawalAsset.length; i++) {\\n            address asset = _disabledWithdrawalAsset[i];\\n            require(_isAssetPresent(asset), \\\"Asset not supported by Yieldster\\\");\\n            vaults[msg.sender].vaultAssets[asset] = false;\\n            vaults[msg.sender].vaultWithdrawalAssets[asset] = false;\\n        }\\n    }\\n\\n    /// @dev Function to get the list of management fee strategies applied to the vault.\\n    function getVaultManagementFee() external view returns (address[] memory) {\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\n        return managementFeeStrategies[msg.sender].activeManagementFeeList;\\n    }\\n\\n    /// @dev Function to get the deposit strategy applied to the vault.\\n    function getDepositStrategy() external view returns (address) {\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\n        return vaults[msg.sender].depositStrategy;\\n    }\\n\\n    /// @dev Function to get the withdrawal strategy applied to the vault.\\n    function getWithdrawStrategy() external view returns (address) {\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\n        return vaults[msg.sender].withdrawStrategy;\\n    }\\n\\n    /// @dev Function to set the management fee strategies applied to a vault.\\n    /// @param _vaultAddress Address of the vault.\\n    /// @param _managementFeeAddress Address of the management fee strategy.\\n    function setManagementFeeStrategies(\\n        address _vaultAddress,\\n        address _managementFeeAddress\\n    ) external {\\n        require(vaults[_vaultAddress].created, \\\"Vault not present\\\");\\n        require(\\n            vaults[_vaultAddress].vaultStrategyManager == msg.sender,\\n            \\\"Sender not Authorized\\\"\\n        );\\n        managementFeeStrategies[_vaultAddress].isActiveManagementFee[\\n            _managementFeeAddress\\n        ] = true;\\n        managementFeeStrategies[_vaultAddress].activeManagementFeeIndex[\\n            _managementFeeAddress\\n        ] = managementFeeStrategies[_vaultAddress]\\n        .activeManagementFeeList\\n        .length;\\n        managementFeeStrategies[_vaultAddress].activeManagementFeeList.push(\\n            _managementFeeAddress\\n        );\\n    }\\n\\n    /// @dev Function to deactivate a vault strategy.\\n    /// @param _managementFeeAddress Address of the Management Fee Strategy.\\n    function removeManagementFeeStrategies(\\n        address _vaultAddress,\\n        address _managementFeeAddress\\n    ) external {\\n        require(vaults[_vaultAddress].created, \\\"Vault not present\\\");\\n        require(\\n            managementFeeStrategies[_vaultAddress].isActiveManagementFee[\\n                _managementFeeAddress\\n            ],\\n            \\\"Provided ManagementFee is not active\\\"\\n        );\\n        require(\\n            vaults[_vaultAddress].vaultStrategyManager == msg.sender ||\\n                yieldsterDAO == msg.sender,\\n            \\\"Sender not Authorized\\\"\\n        );\\n        require(\\n            platFormManagementFee != _managementFeeAddress ||\\n                yieldsterDAO == msg.sender,\\n            \\\"Platfrom Management only changable by dao!\\\"\\n        );\\n        managementFeeStrategies[_vaultAddress].isActiveManagementFee[\\n            _managementFeeAddress\\n        ] = false;\\n\\n        if (\\n            managementFeeStrategies[_vaultAddress]\\n            .activeManagementFeeList\\n            .length == 1\\n        ) {\\n            managementFeeStrategies[_vaultAddress]\\n                .activeManagementFeeList\\n                .pop();\\n        } else {\\n            uint256 index = managementFeeStrategies[_vaultAddress]\\n            .activeManagementFeeIndex[_managementFeeAddress];\\n            uint256 lastIndex = managementFeeStrategies[_vaultAddress]\\n            .activeManagementFeeList\\n            .length - 1;\\n            delete managementFeeStrategies[_vaultAddress]\\n                .activeManagementFeeList[index];\\n            managementFeeStrategies[_vaultAddress].activeManagementFeeIndex[\\n                managementFeeStrategies[_vaultAddress].activeManagementFeeList[\\n                    lastIndex\\n                ]\\n            ] = index;\\n            managementFeeStrategies[_vaultAddress].activeManagementFeeList[\\n                index\\n            ] = managementFeeStrategies[_vaultAddress].activeManagementFeeList[\\n                lastIndex\\n            ];\\n            managementFeeStrategies[_vaultAddress]\\n                .activeManagementFeeList\\n                .pop();\\n        }\\n    }\\n\\n    /// @dev Function to set vault active strategy.\\n    /// @param _strategyAddress Address of the strategy.\\n    function setVaultActiveStrategy(address _strategyAddress) external {\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\n        require(\\n            _isStrategyEnabled(msg.sender, _strategyAddress),\\n            \\\"This strategy is not enabled\\\"\\n        );\\n        require(strategies[_strategyAddress].created, \\\"Strategy not present\\\");\\n        vaultActiveStrategies[msg.sender].isActiveStrategy[\\n            _strategyAddress\\n        ] = true;\\n        vaultActiveStrategies[msg.sender].activeStrategyIndex[\\n            _strategyAddress\\n        ] = vaultActiveStrategies[msg.sender].activeStrategyList.length;\\n        vaultActiveStrategies[msg.sender].activeStrategyList.push(\\n            _strategyAddress\\n        );\\n    }\\n\\n    /// @dev Function to deactivate a vault strategy.\\n    /// @param _strategyAddress Address of the strategy.\\n    function deactivateVaultStrategy(address _strategyAddress) external {\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\n        require(\\n            vaultActiveStrategies[msg.sender].isActiveStrategy[\\n                _strategyAddress\\n            ],\\n            \\\"Provided strategy is not active\\\"\\n        );\\n        vaultActiveStrategies[msg.sender].isActiveStrategy[\\n            _strategyAddress\\n        ] = false;\\n\\n        if (vaultActiveStrategies[msg.sender].activeStrategyList.length == 1) {\\n            vaultActiveStrategies[msg.sender].activeStrategyList.pop();\\n        } else {\\n            uint256 index = vaultActiveStrategies[msg.sender]\\n            .activeStrategyIndex[_strategyAddress];\\n            uint256 lastIndex = vaultActiveStrategies[msg.sender]\\n            .activeStrategyList\\n            .length - 1;\\n            delete vaultActiveStrategies[msg.sender].activeStrategyList[index];\\n            vaultActiveStrategies[msg.sender].activeStrategyIndex[\\n                vaultActiveStrategies[msg.sender].activeStrategyList[lastIndex]\\n            ] = index;\\n            vaultActiveStrategies[msg.sender].activeStrategyList[\\n                index\\n            ] = vaultActiveStrategies[msg.sender].activeStrategyList[lastIndex];\\n            vaultActiveStrategies[msg.sender].activeStrategyList.pop();\\n        }\\n    }\\n\\n    /// @dev Function to get vault active strategy.\\n    function getVaultActiveStrategy(address _vaultAddress)\\n        external\\n        view\\n        returns (address[] memory)\\n    {\\n        require(vaults[_vaultAddress].created, \\\"Vault not present\\\");\\n        return vaultActiveStrategies[_vaultAddress].activeStrategyList;\\n    }\\n\\n    function isStrategyActive(address _vaultAddress, address _strategyAddress)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return\\n            vaultActiveStrategies[_vaultAddress].isActiveStrategy[\\n                _strategyAddress\\n            ];\\n    }\\n\\n    function getStrategyManagementDetails(\\n        address _vaultAddress,\\n        address _strategyAddress\\n    ) external view returns (address, uint256) {\\n        require(vaults[_vaultAddress].created, \\\"Vault not present\\\");\\n        require(strategies[_strategyAddress].created, \\\"Strategy not present\\\");\\n        require(\\n            vaultActiveStrategies[_vaultAddress].isActiveStrategy[\\n                _strategyAddress\\n            ],\\n            \\\"Strategy not Active\\\"\\n        );\\n        return (\\n            strategies[_strategyAddress].benefeciary,\\n            strategies[_strategyAddress].managementFeePercentage\\n        );\\n    }\\n\\n    /// @dev Function to Manage the vault strategies.\\n    /// @param _vaultStrategy Address of the strategy.\\n    /// @param _enabledStrategyProtocols List of protocols that are enabled in the strategy.\\n    /// @param _disabledStrategyProtocols List of protocols that are disabled in the strategy.\\n    /// @param _assetsToBeEnabled List of assets that have to be enabled along with the strategy.\\n    function setVaultStrategyAndProtocol(\\n        address _vaultStrategy,\\n        address[] calldata _enabledStrategyProtocols,\\n        address[] calldata _disabledStrategyProtocols,\\n        address[] calldata _assetsToBeEnabled\\n    ) external {\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\n        require(strategies[_vaultStrategy].created, \\\"Strategy not present\\\");\\n        vaults[msg.sender].vaultEnabledStrategy[_vaultStrategy] = true;\\n\\n        for (uint256 i = 0; i < _enabledStrategyProtocols.length; i++) {\\n            address protocol = _enabledStrategyProtocols[i];\\n            require(\\n                _isProtocolPresent(protocol),\\n                \\\"Protocol not supported by Yieldster\\\"\\n            );\\n            vaultStrategyEnabledProtocols[msg.sender][_vaultStrategy][\\n                protocol\\n            ] = true;\\n        }\\n\\n        for (uint256 i = 0; i < _disabledStrategyProtocols.length; i++) {\\n            address protocol = _disabledStrategyProtocols[i];\\n            require(\\n                _isProtocolPresent(protocol),\\n                \\\"Protocol not supported by Yieldster\\\"\\n            );\\n            vaultStrategyEnabledProtocols[msg.sender][_vaultStrategy][\\n                protocol\\n            ] = false;\\n        }\\n\\n        for (uint256 i = 0; i < _assetsToBeEnabled.length; i++) {\\n            address asset = _assetsToBeEnabled[i];\\n            require(_isAssetPresent(asset), \\\"Asset not supported by Yieldster\\\");\\n            vaults[msg.sender].vaultAssets[asset] = true;\\n            vaults[msg.sender].vaultDepositAssets[asset] = true;\\n            vaults[msg.sender].vaultWithdrawalAssets[asset] = true;\\n        }\\n    }\\n\\n    /// @dev Function to disable the vault strategies.\\n    /// @param _strategyAddress Address of the strategy.\\n    /// @param _assetsToBeDisabled List of assets that have to be disabled along with the strategy.\\n    function disableVaultStrategy(\\n        address _strategyAddress,\\n        address[] calldata _assetsToBeDisabled\\n    ) external {\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\n        require(strategies[_strategyAddress].created, \\\"Strategy not present\\\");\\n        require(\\n            vaults[msg.sender].vaultEnabledStrategy[_strategyAddress],\\n            \\\"Strategy was not enabled\\\"\\n        );\\n        vaults[msg.sender].vaultEnabledStrategy[_strategyAddress] = false;\\n\\n        for (uint256 i = 0; i < _assetsToBeDisabled.length; i++) {\\n            address asset = _assetsToBeDisabled[i];\\n            require(_isAssetPresent(asset), \\\"Asset not supported by Yieldster\\\");\\n            vaults[msg.sender].vaultAssets[asset] = false;\\n            vaults[msg.sender].vaultDepositAssets[asset] = false;\\n            vaults[msg.sender].vaultWithdrawalAssets[asset] = false;\\n        }\\n    }\\n\\n    /// @dev Function to set smart strategy applied to the vault.\\n    /// @param _smartStrategyAddress Address of the smart strategy.\\n    /// @param _type type of smart strategy(deposit or withdraw).\\n    function setVaultSmartStrategy(address _smartStrategyAddress, uint256 _type)\\n        external\\n    {\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\n        require(\\n            _isSmartStrategyPresent(_smartStrategyAddress),\\n            \\\"Smart Strategy not Supported by Yieldster\\\"\\n        );\\n        if (_type == 1) {\\n            vaults[msg.sender].depositStrategy = _smartStrategyAddress;\\n        } else if (_type == 2) {\\n            vaults[msg.sender].withdrawStrategy = _smartStrategyAddress;\\n        } else {\\n            revert(\\\"Invalid type provided\\\");\\n        }\\n    }\\n\\n    /// @dev Function to check if a particular protocol is enabled in a strategy for a vault.\\n    /// @param _vaultAddress Address of the vault.\\n    /// @param _strategyAddress Address of the strategy.\\n    /// @param _protocolAddress Address of the protocol to check.\\n    function _isStrategyProtocolEnabled(\\n        address _vaultAddress,\\n        address _strategyAddress,\\n        address _protocolAddress\\n    ) external view returns (bool) {\\n        if (\\n            vaults[_vaultAddress].created &&\\n            strategies[_strategyAddress].created &&\\n            protocols[_protocolAddress] &&\\n            vaults[_vaultAddress].vaultEnabledStrategy[_strategyAddress] &&\\n            vaultStrategyEnabledProtocols[_vaultAddress][_strategyAddress][\\n                _protocolAddress\\n            ]\\n        ) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /// @dev Function to check if a strategy is enabled for the vault.\\n    /// @param _vaultAddress Address of the vault.\\n    /// @param _strategyAddress Address of the strategy.\\n    function _isStrategyEnabled(address _vaultAddress, address _strategyAddress)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        if (\\n            vaults[_vaultAddress].created &&\\n            strategies[_strategyAddress].created &&\\n            vaults[_vaultAddress].vaultEnabledStrategy[_strategyAddress]\\n        ) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /// @dev Function to check if the asset is supported by the vault.\\n    /// @param cleanUpAsset Address of the asset.\\n    function _isVaultAsset(address cleanUpAsset) external view returns (bool) {\\n        require(vaults[msg.sender].created, \\\"Vault is not present\\\");\\n        return vaults[msg.sender].vaultAssets[cleanUpAsset];\\n    }\\n\\n    // Assets\\n    /// @dev Function to check if an asset is supported by Yieldster.\\n    /// @param _address Address of the asset.\\n    function _isAssetPresent(address _address) private view returns (bool) {\\n        return assets[_address];\\n    }\\n\\n    /// @dev Function to add an asset to the Yieldster.\\n    /// @param _tokenAddress Address of the asset.\\n    function addAsset(address _tokenAddress) external onlyManager {\\n        require(!_isAssetPresent(_tokenAddress), \\\"Asset already present!\\\");\\n        assets[_tokenAddress] = true;\\n    }\\n\\n    /// @dev Function to remove an asset from the Yieldster.\\n    /// @param _tokenAddress Address of the asset.\\n    function removeAsset(address _tokenAddress) external onlyManager {\\n        require(_isAssetPresent(_tokenAddress), \\\"Asset not present!\\\");\\n        delete assets[_tokenAddress];\\n    }\\n\\n    /// @dev Function to check if an asset is supported deposit asset in the vault.\\n    /// @param _assetAddress Address of the asset.\\n    function isDepositAsset(address _assetAddress)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\n        return vaults[msg.sender].vaultDepositAssets[_assetAddress];\\n    }\\n\\n    /// @dev Function to check if an asset is supported withdrawal asset in the vault.\\n    /// @param _assetAddress Address of the asset.\\n    function isWithdrawalAsset(address _assetAddress)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\n        return vaults[msg.sender].vaultWithdrawalAssets[_assetAddress];\\n    }\\n\\n    //Strategies\\n    /// @dev Function to check if a strategy is supported by Yieldster.\\n    /// @param _address Address of the strategy.\\n    function _isStrategyPresent(address _address) private view returns (bool) {\\n        return strategies[_address].created;\\n    }\\n\\n    /// @dev Function to add a strategy to Yieldster.\\n    /// @param _strategyAddress Address of the strategy.\\n    /// @param _strategyProtocols List of protocols present in the strategy.\\n    /// @param _minter Address of strategy minter.\\n    /// @param _executor Address of strategy executor.\\n    function addStrategy(\\n        address _strategyAddress,\\n        address[] calldata _strategyProtocols,\\n        address _minter,\\n        address _executor,\\n        address _benefeciary,\\n        uint256 _managementFeePercentage\\n    ) external onlyManager {\\n        require(\\n            !_isStrategyPresent(_strategyAddress),\\n            \\\"Strategy already present!\\\"\\n        );\\n        Strategy memory newStrategy = Strategy({\\n            created: true,\\n            minter: _minter,\\n            executor: _executor,\\n            benefeciary: _benefeciary,\\n            managementFeePercentage: _managementFeePercentage\\n        });\\n        strategies[_strategyAddress] = newStrategy;\\n        minterStrategyMap[_minter] = _strategyAddress;\\n\\n        for (uint256 i = 0; i < _strategyProtocols.length; i++) {\\n            address protocol = _strategyProtocols[i];\\n            require(\\n                _isProtocolPresent(protocol),\\n                \\\"Protocol not supported by Yieldster\\\"\\n            );\\n            strategies[_strategyAddress].strategyProtocols[protocol] = true;\\n        }\\n    }\\n\\n    /// @dev Function to remove a strategy from Yieldster.\\n    /// @param _strategyAddress Address of the strategy.\\n    function removeStrategy(address _strategyAddress) external onlyManager {\\n        require(_isStrategyPresent(_strategyAddress), \\\"Strategy not present!\\\");\\n        delete strategies[_strategyAddress];\\n    }\\n\\n    /// @dev Function to get strategy executor address.\\n    /// @param _strategy Address of the strategy.\\n    function strategyExecutor(address _strategy)\\n        external\\n        view\\n        returns (address)\\n    {\\n        return strategies[_strategy].executor;\\n    }\\n\\n    /// @dev Function to change executor of strategy.\\n    /// @param _strategyAddress Address of the strategy.\\n    /// @param _executor Address of the executor.\\n    function changeStrategyExecutor(address _strategyAddress, address _executor)\\n        external\\n        onlyManager\\n    {\\n        require(_isStrategyPresent(_strategyAddress), \\\"Strategy not present!\\\");\\n        strategies[_strategyAddress].executor = _executor;\\n    }\\n\\n    //Smart Strategy\\n    /// @dev Function to check if a smart strategy is supported by Yieldster.\\n    /// @param _address Address of the smart strategy.\\n    function _isSmartStrategyPresent(address _address)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return smartStrategies[_address].created;\\n    }\\n\\n    /// @dev Function to add a smart strategy to Yieldster.\\n    /// @param _smartStrategyAddress Address of the smart strategy.\\n    function addSmartStrategy(\\n        address _smartStrategyAddress,\\n        address _minter,\\n        address _executor\\n    ) external onlyManager {\\n        require(\\n            !_isSmartStrategyPresent(_smartStrategyAddress),\\n            \\\"Smart Strategy already present!\\\"\\n        );\\n        SmartStrategy memory newSmartStrategy = SmartStrategy({\\n            minter: _minter,\\n            executor: _executor,\\n            created: true\\n        });\\n        smartStrategies[_smartStrategyAddress] = newSmartStrategy;\\n        minterStrategyMap[_minter] = _smartStrategyAddress;\\n    }\\n\\n    /// @dev Function to remove a smart strategy from Yieldster.\\n    /// @param _smartStrategyAddress Address of the smart strategy.\\n    function removeSmartStrategy(address _smartStrategyAddress)\\n        external\\n        onlyManager\\n    {\\n        require(\\n            !_isSmartStrategyPresent(_smartStrategyAddress),\\n            \\\"Smart Strategy not present\\\"\\n        );\\n        delete smartStrategies[_smartStrategyAddress];\\n    }\\n\\n    /// @dev Function to get ssmart strategy executor address.\\n    /// @param _smartStrategy Address of the strategy.\\n    function smartStrategyExecutor(address _smartStrategy)\\n        external\\n        view\\n        returns (address)\\n    {\\n        return smartStrategies[_smartStrategy].executor;\\n    }\\n\\n    /// @dev Function to change executor of smart strategy.\\n    /// @param _smartStrategy Address of the smart strategy.\\n    /// @param _executor Address of the executor.\\n    function changeSmartStrategyExecutor(\\n        address _smartStrategy,\\n        address _executor\\n    ) external onlyManager {\\n        require(\\n            _isSmartStrategyPresent(_smartStrategy),\\n            \\\"Smart Strategy not present!\\\"\\n        );\\n        smartStrategies[_smartStrategy].executor = _executor;\\n    }\\n\\n    // Protocols\\n    /// @dev Function to check if a protocol is supported by Yieldster.\\n    /// @param _address Address of the protocol.\\n    function _isProtocolPresent(address _address) private view returns (bool) {\\n        return protocols[_address];\\n    }\\n\\n    /// @dev Function to add a protocol to Yieldster.\\n    /// @param _protocolAddress Address of the protocol.\\n    function addProtocol(address _protocolAddress) external onlyManager {\\n        require(\\n            !_isProtocolPresent(_protocolAddress),\\n            \\\"Protocol already present!\\\"\\n        );\\n        protocols[_protocolAddress] = true;\\n    }\\n\\n    /// @dev Function to remove a protocol from Yieldster.\\n    /// @param _protocolAddress Address of the protocol.\\n    function removeProtocol(address _protocolAddress) external onlyManager {\\n        require(_isProtocolPresent(_protocolAddress), \\\"Protocol not present!\\\");\\n        delete protocols[_protocolAddress];\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/interfaces/IPriceModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.7.0;\\npragma experimental ABIEncoderV2;\\n\\ninterface IPriceModule\\n{\\n    function getUSDPrice(address ) external view returns(uint256);\\n}\"\r\n    },\r\n    \"@openzeppelin/upgrades-core/contracts/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"}],\"name\":\"VaultCreation\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strategyAddress\",\"type\":\"address\"}],\"name\":\"_isStrategyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strategyAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protocolAddress\",\"type\":\"address\"}],\"name\":\"_isStrategyProtocolEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cleanUpAsset\",\"type\":\"address\"}],\"name\":\"_isVaultAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"addAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocolAddress\",\"type\":\"address\"}],\"name\":\"addProtocol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxyFactory\",\"type\":\"address\"}],\"name\":\"addProxyFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_smartStrategyAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"name\":\"addSmartStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_strategyProtocols\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_benefeciary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_managementFeePercentage\",\"type\":\"uint256\"}],\"name\":\"addStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAPSManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vaultStrategyManager\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_whitelistGroup\",\"type\":\"uint256[]\"}],\"name\":\"addVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_smartStrategy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"name\":\"changeSmartStrategyExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"name\":\"changeStrategyExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAPSManager\",\"type\":\"address\"}],\"name\":\"changeVaultAPSManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultStrategyManager\",\"type\":\"address\"}],\"name\":\"changeVaultStrategyManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whitelistManager\",\"type\":\"address\"}],\"name\":\"changeWhitelistManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whitelistModule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_platformManagementFee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_profitManagementFee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stringUtils\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yieldsterExchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exchangeRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceModule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_safeUtils\",\"type\":\"address\"}],\"name\":\"configureAPS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"}],\"name\":\"createVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyAddress\",\"type\":\"address\"}],\"name\":\"deactivateVaultStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_assetsToBeDisabled\",\"type\":\"address[]\"}],\"name\":\"disableVaultStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableYieldsterGOD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"getStrategyFromMinter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strategyAddress\",\"type\":\"address\"}],\"name\":\"getStrategyManagementDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"getUSDPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"}],\"name\":\"getVaultActiveStrategy\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultManagementFee\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_yieldsterDAO\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yieldsterTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yieldsterGOD\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_emergencyVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_apsManager\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetAddress\",\"type\":\"address\"}],\"name\":\"isDepositAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strategyAddress\",\"type\":\"address\"}],\"name\":\"isStrategyActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetAddress\",\"type\":\"address\"}],\"name\":\"isWithdrawalAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platFormManagementFee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitManagementFee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"removeAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_managementFeeAddress\",\"type\":\"address\"}],\"name\":\"removeManagementFeeStrategies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocolAddress\",\"type\":\"address\"}],\"name\":\"removeProtocol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_smartStrategyAddress\",\"type\":\"address\"}],\"name\":\"removeSmartStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyAddress\",\"type\":\"address\"}],\"name\":\"removeStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeMinter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeUtils\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_emergencyVault\",\"type\":\"address\"}],\"name\":\"setEmergencyVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exchangeRegistry\",\"type\":\"address\"}],\"name\":\"setExchangeRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_managementFeeAddress\",\"type\":\"address\"}],\"name\":\"setManagementFeeStrategies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_priceModule\",\"type\":\"address\"}],\"name\":\"setPriceModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_platformManagement\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_profitManagement\",\"type\":\"address\"}],\"name\":\"setProfitAndPlatformManagementFeeStrategies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_safeMinter\",\"type\":\"address\"}],\"name\":\"setSafeMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_safeUtils\",\"type\":\"address\"}],\"name\":\"setSafeUtils\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stockDeposit\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stockWithdraw\",\"type\":\"address\"}],\"name\":\"setStockDepositWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stringUtils\",\"type\":\"address\"}],\"name\":\"setStringUtils\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyAddress\",\"type\":\"address\"}],\"name\":\"setVaultActiveStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_enabledDepositAsset\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_enabledWithdrawalAsset\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_disabledDepositAsset\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_disabledWithdrawalAsset\",\"type\":\"address[]\"}],\"name\":\"setVaultAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"setVaultSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_smartStrategyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"setVaultSmartStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultStrategy\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_enabledStrategyProtocols\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_disabledStrategyProtocols\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_assetsToBeEnabled\",\"type\":\"address[]\"}],\"name\":\"setVaultStrategyAndProtocol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whitelistModule\",\"type\":\"address\"}],\"name\":\"setWhitelistModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_yieldsterDAO\",\"type\":\"address\"}],\"name\":\"setYieldsterDAO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_yieldsterExchange\",\"type\":\"address\"}],\"name\":\"setYieldsterExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_yieldsterGOD\",\"type\":\"address\"}],\"name\":\"setYieldsterGOD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_yieldsterTreasury\",\"type\":\"address\"}],\"name\":\"setYieldsterTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_smartStrategy\",\"type\":\"address\"}],\"name\":\"smartStrategyExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stockDeposit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stockWithdraw\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"strategyExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stringUtils\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldsterDAO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldsterExchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldsterGOD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldsterTreasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"APContract","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://74f3c47ab93ad9770e7a029eefe333ed758c7fef59f28fef098dad74e7f6a947"}]}