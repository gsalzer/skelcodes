{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/v0.8/dev/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner {\\n\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(\\n    address indexed from,\\n    address indexed to\\n  );\\n  event OwnershipTransferred(\\n    address indexed from,\\n    address indexed to\\n  );\\n\\n  constructor(address newOwner) {\\n    s_owner = newOwner;\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(\\n    address to\\n  )\\n    external\\n    onlyOwner()\\n  {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership()\\n    external\\n  {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner()\\n    public\\n    view\\n    returns (\\n      address\\n    )\\n  {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n    _;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/ValidatorProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwner.sol\\\";\\nimport \\\"../interfaces/AggregatorValidatorInterface.sol\\\";\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\n\\ncontract ValidatorProxy is AggregatorValidatorInterface, TypeAndVersionInterface, ConfirmedOwner {\\n\\n  /// @notice Uses a single storage slot to store the current address\\n  struct AggregatorConfiguration {\\n    address target;\\n    bool hasNewProposal;\\n  }\\n\\n  struct ValidatorConfiguration {\\n    AggregatorValidatorInterface target;\\n    bool hasNewProposal;\\n  }\\n\\n  // Configuration for the current aggregator\\n  AggregatorConfiguration private s_currentAggregator;\\n  // Proposed aggregator address\\n  address private s_proposedAggregator;\\n\\n  // Configuration for the current validator\\n  ValidatorConfiguration private s_currentValidator;\\n  // Proposed validator address\\n  AggregatorValidatorInterface private s_proposedValidator;\\n\\n  event AggregatorProposed(\\n    address indexed aggregator\\n  );\\n  event AggregatorUpgraded(\\n    address indexed previous,\\n    address indexed current\\n  );\\n  event ValidatorProposed(\\n    AggregatorValidatorInterface indexed validator\\n  );\\n  event ValidatorUpgraded(\\n    AggregatorValidatorInterface indexed previous,\\n    AggregatorValidatorInterface indexed current\\n  );\\n  /// @notice The proposed aggregator called validate, but the call was not passed on to any validators\\n  event ProposedAggregatorValidateCall(\\n    address indexed proposed,\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  );\\n\\n  /**\\n   * @notice Construct the ValidatorProxy with an aggregator and a validator\\n   * @param aggregator address\\n   * @param validator address\\n   */\\n  constructor(\\n    address aggregator,\\n    AggregatorValidatorInterface validator\\n  )\\n    ConfirmedOwner(msg.sender)\\n  {\\n    s_currentAggregator = AggregatorConfiguration({\\n      target: aggregator,\\n      hasNewProposal: false\\n    });\\n    s_currentValidator = ValidatorConfiguration({\\n      target: validator,\\n      hasNewProposal: false\\n    });\\n  }\\n\\n  /**\\n   * @notice Validate a transmission\\n   * @dev Must be called by either the `s_currentAggregator.target`, or the `s_proposedAggregator`.\\n   * If called by the `s_currentAggregator.target` this function passes the call on to the `s_currentValidator.target`\\n   * and the `s_proposedValidator`, if it is set.\\n   * If called by the `s_proposedAggregator` this function emits a `ProposedAggregatorValidateCall` to signal that\\n   * the call was received.\\n   * @dev To guard against external `validate` calls reverting, we use raw calls here.\\n   * We favour `call` over try-catch to ensure that failures are avoided even if the validator address is incorrectly\\n   * set as a non-contract address.\\n   * @dev If the `aggregator` and `validator` are the same contract or collude, this could exhibit reentrancy behavior.\\n   * However, since that contract would have to be explicitly written for reentrancy and that the `owner` would have\\n   * to configure this contract to use that malicious contract, we refrain from using mutex or check here.\\n   * @dev This does not perform any checks on any roundId, so it is possible that a validator receive different reports\\n   * for the same roundId at different points in time. Validator implementations should be aware of this.\\n   * @param previousRoundId uint256\\n   * @param previousAnswer int256\\n   * @param currentRoundId uint256\\n   * @param currentAnswer int256\\n   * @return bool\\n   */\\n  function validate(\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  )\\n    external\\n    override\\n    returns (\\n      bool\\n    )\\n  {\\n    address currentAggregator = s_currentAggregator.target;\\n    if (msg.sender != currentAggregator) {\\n      address proposedAggregator = s_proposedAggregator;\\n      require(msg.sender == proposedAggregator, \\\"Not a configured aggregator\\\");\\n      // If the aggregator is still in proposed state, emit an event and don't push to any validator.\\n      // This is to confirm that `validate` is being called prior to upgrade.\\n      emit ProposedAggregatorValidateCall(\\n        proposedAggregator,\\n        previousRoundId,\\n        previousAnswer,\\n        currentRoundId,\\n        currentAnswer\\n      );\\n      return true;\\n    }\\n\\n    // Send the validate call to the current validator\\n    ValidatorConfiguration memory currentValidator = s_currentValidator;\\n    address currentValidatorAddress = address(currentValidator.target);\\n    require(currentValidatorAddress != address(0), \\\"No validator set\\\");\\n    currentValidatorAddress.call(\\n      abi.encodeWithSelector(\\n        AggregatorValidatorInterface.validate.selector,\\n        previousRoundId,\\n        previousAnswer,\\n        currentRoundId,\\n        currentAnswer\\n      )\\n    );\\n    // If there is a new proposed validator, send the validate call to that validator also\\n    if (currentValidator.hasNewProposal) {\\n      address(s_proposedValidator).call(\\n        abi.encodeWithSelector(\\n          AggregatorValidatorInterface.validate.selector,\\n          previousRoundId,\\n          previousAnswer,\\n          currentRoundId,\\n          currentAnswer\\n        )\\n      );\\n    }\\n    return true;\\n  }\\n\\n  /** AGGREGATOR CONFIGURATION FUNCTIONS **/\\n\\n  /**\\n   * @notice Propose an aggregator\\n   * @dev A zero address can be used to unset the proposed aggregator. Only owner can call.\\n   * @param proposed address\\n   */\\n  function proposeNewAggregator(\\n    address proposed\\n  )\\n    external\\n    onlyOwner()\\n  {\\n    require(s_proposedAggregator != proposed && s_currentAggregator.target != proposed, \\\"Invalid proposal\\\");\\n    s_proposedAggregator = proposed;\\n    // If proposed is zero address, hasNewProposal = false\\n    s_currentAggregator.hasNewProposal = (proposed != address(0));\\n    emit AggregatorProposed(proposed);\\n  }\\n\\n  /**\\n   * @notice Upgrade the aggregator by setting the current aggregator as the proposed aggregator.\\n   * @dev Must have a proposed aggregator. Only owner can call.\\n   */\\n  function upgradeAggregator()\\n    external\\n    onlyOwner()\\n  {\\n    // Get configuration in memory\\n    AggregatorConfiguration memory current = s_currentAggregator;\\n    address previous = current.target;\\n    address proposed = s_proposedAggregator;\\n\\n    // Perform the upgrade\\n    require(current.hasNewProposal, \\\"No proposal\\\");\\n    s_currentAggregator = AggregatorConfiguration({\\n      target: proposed,\\n      hasNewProposal: false\\n    });\\n    delete s_proposedAggregator;\\n\\n    emit AggregatorUpgraded(previous, proposed);\\n  }\\n\\n  /**\\n   * @notice Get aggregator details\\n   * @return current address\\n   * @return hasProposal bool\\n   * @return proposed address\\n   */\\n  function getAggregators()\\n    external\\n    view\\n    returns(\\n      address current,\\n      bool hasProposal,\\n      address proposed\\n    )\\n  {\\n    current = s_currentAggregator.target;\\n    hasProposal = s_currentAggregator.hasNewProposal;\\n    proposed = s_proposedAggregator;\\n  }\\n\\n  /** VALIDATOR CONFIGURATION FUNCTIONS **/\\n\\n  /**\\n   * @notice Propose an validator\\n   * @dev A zero address can be used to unset the proposed validator. Only owner can call.\\n   * @param proposed address\\n   */\\n  function proposeNewValidator(\\n    AggregatorValidatorInterface proposed\\n  )\\n    external\\n    onlyOwner()\\n  {\\n    require(s_proposedValidator != proposed && s_currentValidator.target != proposed, \\\"Invalid proposal\\\");\\n    s_proposedValidator = proposed;\\n    // If proposed is zero address, hasNewProposal = false\\n    s_currentValidator.hasNewProposal = (address(proposed) != address(0));\\n    emit ValidatorProposed(proposed);\\n  }\\n\\n  /**\\n   * @notice Upgrade the validator by setting the current validator as the proposed validator.\\n   * @dev Must have a proposed validator. Only owner can call.\\n   */\\n  function upgradeValidator()\\n    external\\n    onlyOwner()\\n  {\\n    // Get configuration in memory\\n    ValidatorConfiguration memory current = s_currentValidator;\\n    AggregatorValidatorInterface previous = current.target;\\n    AggregatorValidatorInterface proposed = s_proposedValidator;\\n\\n    // Perform the upgrade\\n    require(current.hasNewProposal, \\\"No proposal\\\");\\n    s_currentValidator = ValidatorConfiguration({\\n      target: proposed,\\n      hasNewProposal: false\\n    });\\n    delete s_proposedValidator;\\n\\n    emit ValidatorUpgraded(previous, proposed);\\n  }\\n\\n  /**\\n   * @notice Get validator details\\n   * @return current address\\n   * @return hasProposal bool\\n   * @return proposed address\\n   */\\n  function getValidators()\\n    external\\n    view\\n    returns(\\n      AggregatorValidatorInterface current,\\n      bool hasProposal,\\n      AggregatorValidatorInterface proposed\\n    )\\n  {\\n    current = s_currentValidator.target;\\n    hasProposal = s_currentValidator.hasNewProposal;\\n    proposed = s_proposedValidator;\\n  }\\n\\n  /**\\n   * @notice The type and version of this contract\\n   * @return Type and version string\\n   */\\n  function typeAndVersion()\\n    external\\n    pure\\n    virtual\\n    override\\n    returns (\\n      string memory\\n    )\\n  {\\n    return \\\"ValidatorProxy 1.0.0\\\";\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AggregatorValidatorInterface.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorValidatorInterface {\\n  function validate(\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  )\\n    external\\n    returns (\\n      bool\\n    );\\n}\"\r\n    },\r\n    \"src/v0.8/interfaces/TypeAndVersionInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract TypeAndVersionInterface{\\n  function typeAndVersion()\\n    external\\n    pure\\n    virtual\\n    returns (\\n      string memory\\n    );\\n}\"\r\n    },\r\n    \"src/v0.8/tests/MockAggregatorValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/AggregatorValidatorInterface.sol\\\";\\n\\ncontract MockAggregatorValidator is AggregatorValidatorInterface {\\n  \\n  uint8 immutable id;\\n\\n  constructor(uint8 id_) {\\n    id = id_;\\n  }\\n\\n  event ValidateCalled(\\n    uint8 id,\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  );\\n  \\n  function validate(\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  )\\n    external\\n    override\\n    returns (\\n      bool\\n    )\\n  {\\n    emit ValidateCalled(id, previousRoundId, previousAnswer, currentRoundId, currentAnswer);\\n    return true;\\n  }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"},{\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"validator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"AggregatorProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"AggregatorUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposed\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousRoundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"previousAnswer\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentRoundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"currentAnswer\",\"type\":\"int256\"}],\"name\":\"ProposedAggregatorValidateCall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"ValidatorProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"ValidatorUpgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAggregators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasProposal\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"proposed\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getValidators\",\"outputs\":[{\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"current\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasProposal\",\"type\":\"bool\"},{\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"proposed\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proposed\",\"type\":\"address\"}],\"name\":\"proposeNewAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"proposed\",\"type\":\"address\"}],\"name\":\"proposeNewValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"previousRoundId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"previousAnswer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"currentRoundId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"currentAnswer\",\"type\":\"int256\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ValidatorProxy","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000037bc7498f4ff12c19678ee8fe19d713b87f6a9e60000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}