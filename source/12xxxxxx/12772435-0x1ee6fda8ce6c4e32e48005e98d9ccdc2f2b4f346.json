{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": false,\r\n        \"peephole\": true,\r\n        \"yul\": false\r\n      },\r\n      \"runs\": 256\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@NutBerry/NutBerry/src/tsm/contracts/NutBerryCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport './NutBerryEvents.sol';\\n\\n/// @notice The Layer 2 core protocol.\\n// Audit-1: ok\\ncontract NutBerryCore is NutBerryEvents {\\n  /// @dev Constant, the maximum size a single block can be.\\n  /// Default: 31744 bytes\\n  function MAX_BLOCK_SIZE () public view virtual returns (uint24) {\\n    return 31744;\\n  }\\n\\n  /// @dev Constant, the inspection period defines how long it takes (in L1 blocks)\\n  /// until a submitted solution can be finalized.\\n  /// Default: 60 blocks ~ 14 minutes.\\n  function INSPECTION_PERIOD () public view virtual returns (uint16) {\\n    return 60;\\n  }\\n\\n  /// Add multiplicator parameter that says:\\n  /// if any N blocks get flagged, then increase the INSPECTION_PERIOD times INSPECTION_PERIOD_MULTIPLIER\\n  /// that puts the possible inspection period for these blocks higher up so that\\n  /// operators and chain users can cooperate on any situation within a bigger timeframe.\\n  /// That means if someone wrongfully flags valid solutions for blocks,\\n  /// then this just increases the INSPECTION_PERIOD and operators are not forced into challenges.\\n  /// If no one challenges any blocks within the increased timeframe,\\n  /// then the block(s) can be finalized as usual after the elevated INSPECTION_PERIOD.\\n  function INSPECTION_PERIOD_MULTIPLIER () public view virtual returns (uint256) {\\n    return 3;\\n  }\\n\\n  /// @dev The address of the contract that includes/handles the\\n  /// `onChallenge` and `onFinalizeSolution` logic.\\n  /// Default: address(this)\\n  function _CHALLENGE_IMPLEMENTATION_ADDRESS () internal virtual returns (address) {\\n    return address(this);\\n  }\\n\\n  /// @dev Returns the storage key used for storing the number of the highest finalized block.\\n  function _FINALIZED_HEIGHT_KEY () internal pure returns (uint256) {\\n    return 0x777302ffa8e0291a142b7d0ca91add4a3635f6d74d564879c14a0a3f2c9d251c;\\n  }\\n\\n  /// @dev Returns the highest finalized block.\\n  function finalizedHeight () public view returns (uint256 ret) {\\n    uint256 key = _FINALIZED_HEIGHT_KEY();\\n    assembly {\\n      ret := sload(key)\\n    }\\n  }\\n\\n  /// @dev Setter for `finalizedHeight`\\n  function _setFinalizedHeight (uint256 a) internal {\\n    uint256 key = _FINALIZED_HEIGHT_KEY();\\n    assembly {\\n      sstore(key, a)\\n    }\\n  }\\n\\n  /// @dev Returns the storage key used for storing the number of the highest block.\\n  function _PENDING_HEIGHT_KEY () internal pure returns (uint256) {\\n    return 0x8171e809ec4f72187317c49280c722650635ce37e7e1d8ea127c8ce58f432b98;\\n  }\\n\\n  /// @dev Highest not finalized block\\n  function pendingHeight () public view returns (uint256 ret) {\\n    uint256 key = _PENDING_HEIGHT_KEY();\\n    assembly {\\n      ret := sload(key)\\n    }\\n  }\\n\\n  /// @dev Setter for `pendingHeight`\\n  function _setPendingHeight (uint256 a) internal {\\n    uint256 key = _PENDING_HEIGHT_KEY();\\n    assembly {\\n      sstore(key, a)\\n    }\\n  }\\n\\n  /// @dev Returns the storage key used for storing the (byte) offset in chunked challenges.\\n  function _CHALLENGE_OFFSET_KEY () internal pure returns (uint256) {\\n    return 0xd733644cc0b916a23c558a3a2815e430d2373e6f5bf71acb729373a0dd995878;\\n  }\\n\\n  /// @dev tracks the block offset in chunked challenges.\\n  function _challengeOffset () internal view returns (uint256 ret) {\\n    uint256 key = _CHALLENGE_OFFSET_KEY();\\n    assembly {\\n      ret := sload(key)\\n    }\\n  }\\n\\n  /// @dev Setter for `_challengeOffset`\\n  function _setChallengeOffset (uint256 a) internal {\\n    uint256 key = _CHALLENGE_OFFSET_KEY();\\n    assembly {\\n      sstore(key, a)\\n    }\\n  }\\n\\n  /// @dev Returns the storage key for storing a block hash given `height`.\\n  function _BLOCK_HASH_KEY (uint256 height) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x4d8e47aa6de2727816b4bbef070a604f701f0084f916418d1cdc240661f562e1)\\n      mstore(32, height)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  /// @dev Returns the block hash for `height`.\\n  function _blockHashFor (uint256 height) internal view returns (bytes32 ret) {\\n    uint256 key = _BLOCK_HASH_KEY(height);\\n    assembly {\\n      ret := sload(key)\\n    }\\n  }\\n\\n  /// @dev Setter for `_blockHashFor`.\\n  function _setBlockHash (uint256 height, bytes32 hash) internal {\\n    uint256 key = _BLOCK_HASH_KEY(height);\\n    assembly {\\n      sstore(key, hash)\\n    }\\n  }\\n\\n  /// @dev Returns the storage key for storing a block solution hash for block at `height`.\\n  function _BLOCK_SOLUTIONS_KEY (uint256 height) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x5ba08b0dee3c3262140f1dba0d9c002446260e37aab5f8128649d20f79d70c24)\\n      mstore(32, height)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  /// @dev Returns the block solution hash for block at `height`, or zero.\\n  function _blockSolutionFor (uint256 height) internal view returns (bytes32 ret) {\\n    uint256 key = _BLOCK_SOLUTIONS_KEY(height);\\n    assembly {\\n      ret := sload(key)\\n    }\\n  }\\n\\n  /// @dev Setter for `_blockSolutionFor`.\\n  function _setBlockSolution (uint256 height, bytes32 hash) internal {\\n    uint256 key = _BLOCK_SOLUTIONS_KEY(height);\\n    assembly {\\n      sstore(key, hash)\\n    }\\n  }\\n\\n  function _BLOCK_META_KEY (uint256 height) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0xd2cb82084fde0be47b8bfd4b0990b9dd581ec724fb5aeb289572a3777b20326f)\\n      mstore(32, height)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  /// @dev Holds metadata for blocks.\\n  /// | finalization target (blockNumber) | least significant bit is a dispute flag |\\n  function blockMeta (uint256 height) public view returns (uint256 ret) {\\n    uint256 key = _BLOCK_META_KEY(height);\\n    assembly {\\n      ret := sload(key)\\n    }\\n  }\\n\\n  /// @dev Setter for `blockMeta`.\\n  function _setBlockMeta (uint256 height, uint256 val) internal {\\n    uint256 key = _BLOCK_META_KEY(height);\\n    assembly {\\n      sstore(key, val)\\n    }\\n  }\\n\\n  /// @dev Clears storage slots and moves `finalizedHeight` to `blockNumber`.\\n  /// @param blockNumber The number of the block to finalize.\\n  function _resolveBlock (uint256 blockNumber) internal {\\n    _setFinalizedHeight(blockNumber);\\n    _setChallengeOffset(0);\\n\\n    _setBlockHash(blockNumber, 0);\\n    _setBlockSolution(blockNumber, 0);\\n    _setBlockMeta(blockNumber, 0);\\n  }\\n\\n  constructor () {\\n    assembly {\\n      // created at block\\n      sstore(0x319a610c8254af7ecb1f669fb64fa36285b80cad26faf7087184ce1dceb114df, number())\\n    }\\n  }\\n\\n  function _onlyEOA () internal view {\\n    assembly {\\n      // if caller is not tx sender, then revert.\\n      // Thus, we make sure that only regular accounts can submit blocks.\\n\\n      if iszero(eq(origin(), caller())) {\\n        revert(0, 0)\\n      }\\n    }\\n  }\\n\\n  /// @dev This can be used to import custom data into the chain.\\n  /// This will create a new Block with type=3 and includes\\n  /// every byte from calldata starting from byte offset 4.\\n  /// Only regular accounts are allowed to submit blocks.\\n  function _createBlockMessage () internal {\\n    _onlyEOA();\\n\\n    uint256 blockNumber = pendingHeight() + 1;\\n    _setPendingHeight(blockNumber);\\n\\n    bytes32 blockHash;\\n    uint24 maxBlockSize = MAX_BLOCK_SIZE();\\n    assembly {\\n      // Computes blockHash from calldata excluding function signature.\\n\\n      let size := sub(calldatasize(), 4)\\n      if or(gt(size, maxBlockSize), iszero(size)) {\\n        // exceeded MAX_BLOCK_SIZE or zero-size block\\n        revert(0, 0)\\n      }\\n      // temporarily save the memory pointer\\n      let tmp := mload(64)\\n\\n      // the block nonce / block number.\\n      mstore(0, blockNumber)\\n      // block type = 3\\n      mstore(32, 3)\\n      mstore(64, timestamp())\\n\\n      // copy from calldata and hash\\n      calldatacopy(96, 4, size)\\n      blockHash := keccak256(0, add(size, 96))\\n\\n      // restore memory pointer\\n      mstore(64, tmp)\\n      // zero the slot\\n      mstore(96, 0)\\n    }\\n    _setBlockHash(blockNumber, blockHash);\\n\\n    emit CustomBlockBeacon();\\n  }\\n\\n  /// @dev Submit a transaction blob (a block).\\n  /// The block data is expected right after the 4-byte function signature.\\n  /// Only regular accounts are allowed to submit blocks.\\n  function submitBlock () external {\\n    _onlyEOA();\\n\\n    uint256 blockNumber = pendingHeight() + 1;\\n    _setPendingHeight(blockNumber);\\n\\n    // a user submitted blockType = 2\\n    bytes32 blockHash;\\n    uint24 maxBlockSize = MAX_BLOCK_SIZE();\\n    assembly {\\n      // Computes blockHash from calldata excluding function signature.\\n\\n      let size := sub(calldatasize(), 4)\\n      if or(gt(size, maxBlockSize), iszero(size)) {\\n        // exceeded MAX_BLOCK_SIZE or zero-size block\\n        revert(0, 0)\\n      }\\n      // temporarily save the memory pointer\\n      let tmp := mload(64)\\n\\n      // the block nonce / block number.\\n      mstore(0, blockNumber)\\n      // block type = 2\\n      mstore(32, 2)\\n      mstore(64, timestamp())\\n\\n      // copy from calldata and hash\\n      calldatacopy(96, 4, size)\\n      blockHash := keccak256(0, add(size, 96))\\n\\n      // restore memory pointer\\n      mstore(64, tmp)\\n      // zero the slot\\n      mstore(96, 0)\\n    }\\n    _setBlockHash(blockNumber, blockHash);\\n\\n    emit BlockBeacon();\\n  }\\n\\n  /// @dev Register solution for given `blockNumber`.\\n  /// Up to 256 solutions can be registered ahead in time.\\n  /// calldata layout:\\n  /// <4 byte function sig>\\n  /// <32 bytes number of first block>\\n  /// <32 bytes for each solution for blocks starting at first block (increments by one)>\\n  /// Note: You can put `holes` in the layout by inserting a 32 byte zero value.\\n  /// Only regular accounts are allowed to submit solutions.\\n  function submitSolution () external {\\n    _onlyEOA();\\n\\n    uint256 min = finalizedHeight() + 1;\\n    uint256 max = min + 255;\\n\\n    {\\n      uint256 tmp = pendingHeight();\\n      if (max > tmp) {\\n        max = tmp;\\n      }\\n    }\\n\\n    uint256 finalizationTarget = (block.number + INSPECTION_PERIOD()) << 1;\\n    assembly {\\n      // underflow ok\\n      let blockNum := sub(calldataload(4), 1)\\n\\n      for { let i := 36 } lt(i, calldatasize()) { i := add(i, 32) } {\\n        blockNum := add(blockNum, 1)\\n        let solutionHash := calldataload(i)\\n\\n        if or( iszero(solutionHash), or( lt(blockNum, min), gt(blockNum, max) ) ) {\\n          continue\\n        }\\n\\n        // inline _BLOCK_SOLUTIONS_KEY\\n        mstore(0, 0x5ba08b0dee3c3262140f1dba0d9c002446260e37aab5f8128649d20f79d70c24)\\n        mstore(32, blockNum)\\n        let key := keccak256(0, 64)\\n\\n        if iszero(sload(key)) {\\n          // store hash\\n          sstore(key, solutionHash)\\n\\n          // store finalizationTarget\\n          // inline _BLOCK_META_KEY\\n          mstore(0, 0xd2cb82084fde0be47b8bfd4b0990b9dd581ec724fb5aeb289572a3777b20326f)\\n          key := keccak256(0, 64)\\n          sstore(key, finalizationTarget)\\n        }\\n      }\\n\\n      // emit NewSolution();\\n      log1(0, 0, 0xd180748b1b0c35f46942acf30f64a94a79d303ffd18cce62cbbb733b436298cb)\\n      stop()\\n    }\\n  }\\n\\n  /// @dev Flags up to 256 solutions. This will increase the inspection period for the block(s).\\n  /// @param blockNumber the starting point.\\n  /// @param bitmask Up to 256 solutions can be flagged.\\n  /// Thus, a solution will be flagged if the corresponding bit is `1`.\\n  /// LSB first.\\n  function dispute (uint256 blockNumber, uint256 bitmask) external {\\n    uint256 min = finalizedHeight();\\n    uint256 finalizationTarget = 1 | ((block.number + (INSPECTION_PERIOD() * INSPECTION_PERIOD_MULTIPLIER())) << 1);\\n\\n    for (uint256 i = 0; i < 256; i++) {\\n      uint256 flag = (bitmask >> i) & 1;\\n      if (flag == 0) {\\n        continue;\\n      }\\n\\n      uint256 blockN = blockNumber + i;\\n\\n      if (blockN > min) {\\n        // if a solution exists and is not not already disputed\\n        uint256 v = blockMeta(blockN);\\n        if (v != 0 && v & 1 == 0) {\\n          // set dispute flag and finalization target\\n          _setBlockMeta(blockN, finalizationTarget);\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @dev Challenge the solution or just verify the next pending block directly.\\n  /// Expects the block data right after the function signature to be included in the call.\\n  /// calldata layout:\\n  /// < 4 bytes function sig >\\n  /// < 32 bytes size of block >\\n  /// < 32 bytes number of challenge rounds >\\n  /// < arbitrary witness data >\\n  /// < data of block >\\n  function challenge () external {\\n    uint256 blockSize;\\n    uint256 blockDataStart;\\n    assembly {\\n      blockSize := calldataload(4)\\n      blockDataStart := sub(calldatasize(), blockSize)\\n    }\\n\\n    uint256 blockNumber = finalizedHeight() + 1;\\n\\n    {\\n      // validate the block data\\n      bytes32 blockHash;\\n      assembly {\\n        let tmp := mload(64)\\n        calldatacopy(0, blockDataStart, blockSize)\\n        blockHash := keccak256(0, blockSize)\\n        mstore(64, tmp)\\n        mstore(96, 0)\\n      }\\n      // blockHash must match\\n      require(_blockHashFor(blockNumber) == blockHash);\\n    }\\n\\n    uint256 challengeOffset = _challengeOffset();\\n    address challengeHandler = _CHALLENGE_IMPLEMENTATION_ADDRESS();\\n    assembly {\\n      // function onChallenge ()\\n      mstore(128, 0xc47c519d)\\n      // additional arguments\\n      mstore(160, challengeOffset)\\n      mstore(192, challengeHandler)\\n      // copy calldata\\n      calldatacopy(224, 4, calldatasize())\\n\\n      // stay in this context\\n      let success := callcode(gas(), challengeHandler, 0, 156, add(calldatasize(), 64), 0, 32)\\n      if iszero(success) {\\n        // Problem:\\n        // If for whatever reason, the challenge never proceeds,\\n        // then using some kind of global timeout to determine\\n        // that the transactions in this block until the last challengeOffset are accepted\\n        // but everything else is discarded is one way to implement this recovery mechanism.\\n        // For simplicity, just revert now. This situation can be resolved via chain governance.\\n        revert(0, 0)\\n      }\\n      challengeOffset := mload(0)\\n    }\\n\\n    bool complete = !(challengeOffset < blockSize);\\n\\n    if (complete) {\\n      // if we are done, finalize this block\\n      _resolveBlock(blockNumber);\\n    } else {\\n      // not done yet, save offset\\n      _setChallengeOffset(challengeOffset);\\n    }\\n\\n    assembly {\\n      // this helps chain clients to better estimate challenge costs.\\n      // this may change in the future and thus is not part of the function sig.\\n      mstore(0, complete)\\n      mstore(32, challengeOffset)\\n      return(0, 64)\\n    }\\n  }\\n\\n  /// @dev Returns true if `blockNumber` can be finalized, else false.\\n  /// Helper function for chain clients.\\n  /// @param blockNumber The number of the block in question.\\n  /// @return True if the block can be finalized, otherwise false.\\n  function canFinalizeBlock (uint256 blockNumber) public view returns (bool) {\\n    // shift left by 1, the lsb is the dispute bit\\n    uint256 target = blockMeta(blockNumber) >> 1;\\n    // solution too young\\n    if (target == 0 || block.number < target) {\\n      return false;\\n    }\\n\\n    // if there is no active challenge, then yes\\n    return _challengeOffset() == 0;\\n  }\\n\\n  /// @dev Finalize solution and move to the next block.\\n  /// This must happen in block order.\\n  /// Nothing can be finalized if a challenge is still active.\\n  /// and cannot happen if there is an active challenge.\\n  /// calldata layout:\\n  /// < 4 byte function sig >\\n  /// < 32 byte block number >\\n  /// ---\\n  /// < 32 byte length of solution >\\n  /// < solution... >\\n  /// ---\\n  /// < repeat above (---) >\\n  function finalizeSolution () external {\\n    if (_challengeOffset() != 0) {\\n      revert();\\n    }\\n\\n    address challengeHandler = _CHALLENGE_IMPLEMENTATION_ADDRESS();\\n    assembly {\\n      if lt(calldatasize(), 68) {\\n        revert(0, 0)\\n      }\\n      // underflow ok\\n      let blockNumber := sub(calldataload(4), 1)\\n\\n      let ptr := 36\\n      for { } lt(ptr, calldatasize()) { } {\\n        blockNumber := add(blockNumber, 1)\\n        // this is going to be re-used\\n        mstore(32, blockNumber)\\n\\n        let length := calldataload(ptr)\\n        ptr := add(ptr, 32)\\n\\n        // being optimistic, clear all the storage values in advance\\n\\n        // reset _BLOCK_HASH_KEY\\n        mstore(0, 0x4d8e47aa6de2727816b4bbef070a604f701f0084f916418d1cdc240661f562e1)\\n        sstore(keccak256(0, 64), 0)\\n\\n        // inline _BLOCK_SOLUTIONS_KEY\\n        mstore(0, 0x5ba08b0dee3c3262140f1dba0d9c002446260e37aab5f8128649d20f79d70c24)\\n        let k := keccak256(0, 64)\\n        let solutionHash := sload(k)\\n        // reset - _BLOCK_SOLUTIONS_KEY\\n        sstore(k, 0)\\n\\n        // _BLOCK_META_KEY\\n        mstore(0, 0xd2cb82084fde0be47b8bfd4b0990b9dd581ec724fb5aeb289572a3777b20326f)\\n        k := keccak256(0, 64)\\n        // check if the finalization target is reached,\\n        // else revert\\n        let finalizationTarget := shr(1, sload(k))\\n        if or( lt( number(), finalizationTarget ), iszero(finalizationTarget) ) {\\n          // can not be finalized yet\\n          revert(0, 0)\\n        }\\n        // clear the slot\\n        sstore(k, 0)\\n\\n        // function onFinalizeSolution (uint256 blockNumber, bytes32 hash)\\n        mstore(0, 0xc8470b09)\\n        // blockNumber is still stored @ 32\\n        mstore(64, solutionHash)\\n        // witness\\n        calldatacopy(96, ptr, length)\\n        // call\\n        let success := callcode(gas(), challengeHandler, 0, 28, add(length, 68), 0, 0)\\n        if iszero(success) {\\n          revert(0, 0)\\n        }\\n\\n        ptr := add(ptr, length)\\n      }\\n\\n      if iszero(eq(ptr, calldatasize())) {\\n        // malformed calldata?\\n        revert(0, 0)\\n      }\\n\\n      // inline _setFinalizedHeight and save the new height.\\n      // at this point, blockNumber is assumed to be validated inside the loop\\n      sstore(0x777302ffa8e0291a142b7d0ca91add4a3635f6d74d564879c14a0a3f2c9d251c, blockNumber)\\n\\n      // done\\n      stop()\\n    }\\n  }\\n\\n  /// @dev Loads storage for `key`. Only attempts a load if execution happens\\n  /// inside a challenge, otherwise returns zero.\\n  function _getStorageL1 (bytes32 key) internal view returns (uint256 v) {\\n    assembly {\\n      if origin() {\\n        v := sload(key)\\n      }\\n    }\\n  }\\n\\n  /// @dev Reflect a storage slot `key` with `value` to Layer 1.\\n  /// Useful for propagating storage changes to the contract on L1.\\n  function _setStorageL1 (bytes32 key, uint256 value) internal {\\n    assembly {\\n      switch origin()\\n      case 0 {\\n        // emit a event on L2\\n        log3(0, 0, 1, key, value)\\n      }\\n      default {\\n        // apply the change directly on L1 (challenge)\\n        sstore(key, value)\\n      }\\n    }\\n  }\\n\\n  /// @dev Reflect a delta for storage slot with `key` to Layer 1.\\n  /// Useful for propagating storage changes to the contract on L1.\\n  function _incrementStorageL1 (bytes32 key, uint256 value) internal {\\n    assembly {\\n      switch origin()\\n      case 0 {\\n        // emit a event on L2\\n        log3(0, 0, 2, key, value)\\n      }\\n      default {\\n        // apply the change directly on L1 (challenge)\\n        sstore(key, add(sload(key), value))\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@NutBerry/NutBerry/src/tsm/contracts/NutBerryEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\n/// @notice Contains event declarations related to NutBerry.\\n// Audit-1: ok\\ninterface NutBerryEvents {\\n  event BlockBeacon();\\n  event CustomBlockBeacon();\\n  event NewSolution();\\n  event RollupUpgrade(address target);\\n}\\n\"\r\n    },\r\n    \"@NutBerry/NutBerry/src/tsm/contracts/NutBerryTokenBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport './NutBerryCore.sol';\\n\\n/// @notice Includes Deposit & Withdraw functionality\\n// Audit-1: ok\\ncontract NutBerryTokenBridge is NutBerryCore {\\n  event Deposit(address owner, address token, uint256 value, uint256 tokenType);\\n  event Withdraw(address owner, address token, uint256 value);\\n\\n  /// @dev Checks if the contract at `token` implements `ownerOf(uint)`.\\n  /// This function saves the result on first run and returns the token type from storage\\n  /// on subsequent invocations.\\n  /// Intended to be used in a L1 context.\\n  /// @return tokenType Either `1` for ERC-20 or `2` for ERC-721 like contracts (NFTs).\\n  function _probeTokenType (address token, uint256 tokenId) internal returns (uint256 tokenType) {\\n    uint256 key = _L1_TOKEN_TYPE_KEY(token);\\n    assembly {\\n      tokenType := sload(key)\\n\\n      if iszero(tokenType) {\\n        // defaults to ERC-20\\n        tokenType := 1\\n\\n        // call ownerOf(tokenId)\\n        mstore(0, 0x6352211e)\\n        mstore(32, tokenId)\\n        // Note: if there is less than 60k gas available,\\n        // this will either succeed or fail.\\n        // If it fails because there wasn't enough gas left,\\n        // then the current call context will highly likely fail too.\\n        let success := staticcall(60000, token, 28, 36, 0, 0)\\n        // ownerOf() should return a 32 bytes value\\n        if and(success, eq(returndatasize(), 32)) {\\n          tokenType := 2\\n        }\\n        // save the result\\n        sstore(key, tokenType)\\n      }\\n    }\\n  }\\n\\n  /// @dev Loads token type from storage for `token`.\\n  /// Intended to be used in a L2 context.\\n  function _getTokenType (address token) internal virtual returns (uint256) {\\n    uint256 key = _TOKEN_TYPE_KEY(token);\\n    return _sload(key);\\n  }\\n\\n  /// @dev Saves the token type for `token`.\\n  /// Intended to be used in a L2 context.\\n  function _setTokenType (address token, uint256 tokenType) internal virtual {\\n    uint256 key = _TOKEN_TYPE_KEY(token);\\n    _sstore(key, tokenType);\\n  }\\n\\n  /// @dev Deposit `token` and value (`amountOrId`) into bridge.\\n  /// @param token The ERC-20/ERC-721 token address.\\n  /// @param amountOrId Amount or the token id.\\n  /// @param receiver The account who receives the token(s).\\n  function deposit (address token, uint256 amountOrId, address receiver) external {\\n    uint256 pending = pendingHeight() + 1;\\n    _setPendingHeight(pending);\\n\\n    uint256 tokenType = _probeTokenType(token, amountOrId);\\n    bytes32 blockHash;\\n    assembly {\\n      // deposit block - header\\n\\n      // 32 bytes nonce\\n      mstore(128, pending)\\n      // 32 bytes block type\\n      mstore(160, 1)\\n      // 32 bytes timestamp\\n      mstore(192, timestamp())\\n\\n      // 20 byte receiver\\n      mstore(224, shl(96, receiver))\\n      // 20 byte token\\n      mstore(244, shl(96, token))\\n      // 32 byte amount or token id\\n      mstore(264, amountOrId)\\n      // 32 byte token type\\n      mstore(296, tokenType)\\n      blockHash := keccak256(128, 200)\\n    }\\n\\n    _setBlockHash(pending, blockHash);\\n    emit Deposit(receiver, token, amountOrId, tokenType);\\n\\n    assembly {\\n      // transferFrom\\n      mstore(0, 0x23b872dd)\\n      mstore(32, caller())\\n      mstore(64, address())\\n      mstore(96, amountOrId)\\n      let success := call(gas(), token, 0, 28, 100, 0, 32)\\n      if iszero(success) {\\n        revert(0, 0)\\n      }\\n      // some (old) ERC-20 contracts or ERC-721 do not have a return value.\\n      // those who do return a non-negative value.\\n      if returndatasize() {\\n        if iszero(mload(0)) {\\n          revert(0, 0)\\n        }\\n      }\\n      stop()\\n    }\\n  }\\n\\n  /// @dev Withdraw `token` and `tokenId` from bridge.\\n  /// `tokenId` is ignored if `token` is not a ERC-721.\\n  /// @param owner address of the account to withdraw from and to.\\n  /// @param token address of the token.\\n  /// @param tokenId ERC-721 token id.\\n  function withdraw (address owner, address token, uint256 tokenId) external {\\n    require(owner != address(0));\\n\\n    uint256 val;\\n    uint256 tokenType = _probeTokenType(token, tokenId);\\n\\n    if (tokenType == 1) {\\n      val = getERC20Exit(token, owner);\\n      _setERC20Exit(token, owner, 0);\\n    } else {\\n      address exitOwner = getERC721Exit(token, tokenId);\\n      if (owner != exitOwner) {\\n        revert();\\n      }\\n      val = tokenId;\\n      _setERC721Exit(token, address(0), val);\\n    }\\n\\n    emit Withdraw(owner, token, val);\\n\\n    assembly {\\n      // use transfer() for ERC-20's instead of transferFrom,\\n      // some token contracts check for allowance even if caller() == owner of tokens\\n      if eq(tokenType, 1) {\\n        // transfer(...)\\n        mstore(0, 0xa9059cbb)\\n        mstore(32, owner)\\n        mstore(64, val)\\n        let success := call(gas(), token, 0, 28, 68, 0, 32)\\n        if iszero(success) {\\n          revert(0, 0)\\n        }\\n        // some (old) contracts do not have a return value.\\n        // those who do return a non-negative value.\\n        if returndatasize() {\\n          if iszero(mload(0)) {\\n            revert(0, 0)\\n          }\\n        }\\n        stop()\\n      }\\n\\n      // else use transferFrom\\n      mstore(0, 0x23b872dd)\\n      mstore(32, address())\\n      mstore(64, owner)\\n      mstore(96, val)\\n      let success := call(gas(), token, 0, 28, 100, 0, 0)\\n      if iszero(success) {\\n        revert(0, 0)\\n      }\\n      stop()\\n    }\\n  }\\n\\n  function _hashERC20Exit (address target, address owner) internal pure returns (bytes32 ret) {\\n    assembly {\\n      let backup := mload(64)\\n      mstore(0, 0x409d98be992cf6feb2d0dd08517cea5626d092a062b587294f77c8867ee9ecae)\\n      mstore(32, target)\\n      mstore(64, owner)\\n      ret := keccak256(0, 96)\\n      mstore(64, backup)\\n    }\\n  }\\n\\n  function _hashERC721Exit (address target, uint256 tokenId) internal pure returns (bytes32 ret) {\\n    assembly {\\n      let backup := mload(64)\\n      mstore(0, 0xed93405f54628300c204dec35dc26ea0937dddc7eef817a80d167cf6034b6abe)\\n      mstore(32, target)\\n      mstore(64, tokenId)\\n      ret := keccak256(0, 96)\\n      mstore(64, backup)\\n    }\\n  }\\n\\n  function _L1_TOKEN_TYPE_KEY (address token) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x9e605931b4eb546bb835cd7af4f2eb8c79ca4254e07a7c8807e14ea0c9b99084)\\n      mstore(32, token)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _TOKEN_TYPE_KEY (address token) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x7e9dc5694c1711234663ad3120e3efc70aeefda23e219929e3785ccf356431ff)\\n      mstore(32, token)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _incrementExit (address target, address owner, uint256 value) internal {\\n    NutBerryCore._incrementStorageL1(_hashERC20Exit(target, owner), value);\\n  }\\n\\n  function getERC20Exit (address target, address owner) public view returns (uint256) {\\n    return NutBerryCore._getStorageL1(_hashERC20Exit(target, owner));\\n  }\\n\\n  function _setERC20Exit (address target, address owner, uint256 value) internal {\\n    NutBerryCore._setStorageL1(_hashERC20Exit(target, owner), value);\\n  }\\n\\n  function getERC721Exit (address target, uint256 tokenId) public view returns (address) {\\n    return address(NutBerryCore._getStorageL1(_hashERC721Exit(target, tokenId)));\\n  }\\n\\n  function _setERC721Exit (address target, address owner, uint256 tokenId) internal {\\n    NutBerryCore._setStorageL1(_hashERC721Exit(target, tokenId), uint256(owner));\\n  }\\n\\n  /// @dev SLOAD in a L2 context. Must be implemented by consumers of this contract.\\n  function _sload (uint256 key) internal virtual returns (uint256 ret) {\\n  }\\n\\n  /// @dev SSTORE in a L2 context. Must be implemented by consumers of this contract.\\n  function _sstore (uint256 key, uint256 value) internal virtual {\\n  }\\n}\\n\"\r\n    },\r\n    \"@NutBerry/NutBerry/src/v1/contracts/NutBerryFlavorV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport '../../tsm/contracts/NutBerryTokenBridge.sol';\\n\\n/// @notice Composition of EVM enabled, application specific rollup.\\n/// Version 1\\n// Audit-1: ok\\ncontract NutBerryFlavorV1 is NutBerryTokenBridge {\\n  /// @dev Returns the storage value for `key`.\\n  /// Verifies access on L1(inside challenge) and reverts if no witness for this key exists.\\n  function _sload (uint256 key) internal override returns (uint256 ret) {\\n    assembly {\\n      switch origin()\\n      case 0 {\\n        // nothing special needs to be done on layer 2\\n        ret := sload(key)\\n      }\\n      default {\\n        // on layer 1:\\n        // iterates over a list of keys (32 bytes).\\n        // if the key is found, then a valid witness was provided in a challenge,\\n        // otherwise we revert here :grumpy_cat\\n        //\\n        // < usual calldata... >\\n        // < read witnesses... - each 32 bytes >\\n        // < # of witness elements - 32 bytes>\\n        // < write witnesses - each 32 bytes >\\n        // < # of witness elements - 32 bytes >\\n\\n        let end := sub(calldatasize(), 32)\\n        end := sub(sub(end, 32), mul(calldataload(end), 32))\\n        let nKeys := calldataload(end)\\n        let start := sub(end, mul(nKeys, 32))\\n        let found := 0\\n\\n        for { let i := 0 } lt(i, nKeys) { i := add(i, 1) } {\\n          let ptr := add(start, mul(i, 32))\\n          if eq(calldataload(ptr), key) {\\n            found := 1\\n            break\\n          }\\n        }\\n\\n        if iszero(found) {\\n          revert(0, 0)\\n        }\\n\\n        ret := sload(key)\\n      }\\n    }\\n  }\\n\\n  /// @dev Stores `value` with `key`.\\n  /// Verifies access on L1(inside challenge) and reverts if no witness for this key exists.\\n  function _sstore (uint256 key, uint256 value) internal override {\\n    assembly {\\n      switch origin()\\n      case 0 {\\n        // nothing to do on layer 2\\n        sstore(key, value)\\n      }\\n      default {\\n        // layer 1\\n        // iterates over a list of keys\\n        // if the key is found, then a valid witness was provided in a challenge,\\n        // otherwise: revert\\n        //\\n        // < usual calldata... >\\n        // < read witnesses... - each 32 bytes >\\n        // < # of witness elements - 32 bytes>\\n        // < write witnesses - each 32 bytes >\\n        // < # of witness elements - 32 bytes >\\n        let end := sub(calldatasize(), 32)\\n        let nKeys := calldataload(end)\\n        let start := sub(end, mul(nKeys, 32))\\n        let found := 0\\n\\n        for { let i := 0 } lt(i, nKeys) { i := add(i, 1) } {\\n          let ptr := add(start, mul(i, 32))\\n          if eq(calldataload(ptr), key) {\\n            // this is used to verify that all provided (write) witnesses\\n            // was indeed written to.\\n            // rollup transactions must never write to this slot\\n            let SPECIAL_STORAGE_SLOT := 0xabcd\\n            let bitmask := sload(SPECIAL_STORAGE_SLOT)\\n\\n            sstore(SPECIAL_STORAGE_SLOT, and( bitmask, not(shl(i, 1)) ))\\n            found := 1\\n            break\\n          }\\n        }\\n\\n        if iszero(found) {\\n          revert(0, 0)\\n        }\\n\\n        sstore(key, value)\\n      }\\n    }\\n  }\\n\\n  /// @dev Returns the timestamp (in seconds) of the block this transaction is part of.\\n  /// It returns the equivalent of `~~(Date.now() / 1000)` for a not yet submitted block - (L2).\\n  function _getTime () internal virtual returns (uint256 ret) {\\n    assembly {\\n      switch origin()\\n      case 0 {\\n        // layer 2: return the equivalent of `~~(Date.now() / 1000)`\\n        ret := timestamp()\\n      }\\n      default {\\n        // load the timestamp from calldata on layer 1.\\n        // the setup is done inside a challenge\\n        //\\n        // < usual calldata... >\\n        // < 32 bytes timestamp >\\n        // < read witnesses... - each 32 bytes >\\n        // < # of witness elements - 32 bytes>\\n        // < write witnesses - each 32 bytes >\\n        // < # of witness elements - 32 bytes >\\n        let ptr := sub(calldatasize(), 32)\\n        // load the length of nElements and sub\\n        ptr := sub(ptr, mul(32, calldataload(ptr)))\\n        // points to the start of `write witnesses`\\n        ptr := sub(ptr, 32)\\n        // points at `# read witnesses` and subtracts\\n        ptr := sub(ptr, mul(32, calldataload(ptr)))\\n        // at the start of `read witnesses` sub 32 again\\n        ptr := sub(ptr, 32)\\n        // finish line\\n        ret := calldataload(ptr)\\n      }\\n    }\\n  }\\n\\n  /// @dev Emits a log event that signals the l2 node\\n  /// that this transactions has to be submitted in a block before `timeSeconds`.\\n  function _emitTransactionDeadline (uint256 timeSeconds) internal {\\n    assembly {\\n      // only if we are off-chain\\n      if iszero(origin()) {\\n        log2(0, 0, 3, timeSeconds)\\n      }\\n    }\\n  }\\n\\n  /// @dev Finalize solution for `blockNumber` and move to the next block.\\n  /// Calldata(data appended at the end) contains a blob of key:value pairs that go into storage.\\n  /// If this functions reverts, then the block can only be finalised by a call to `challenge`.\\n  /// - Should only be callable from self.\\n  /// - Supports relative value(delta) and absolute storage updates\\n  /// calldata layout:\\n  /// < 4 byte function sig >\\n  /// < 32 byte blockNumber >\\n  /// < 32 byte submitted solution hash >\\n  /// < witness data >\\n  function onFinalizeSolution (uint256 /*blockNumber*/, bytes32 hash) external {\\n    // all power to the core protocol\\n    require(msg.sender == address(this));\\n\\n    assembly {\\n      // the actual witness data should be appended after the function arguments.\\n      let witnessDataSize := sub(calldatasize(), 68)\\n\\n      calldatacopy(0, 68, witnessDataSize)\\n      // hash the key:value blob\\n      let solutionHash := keccak256(0, witnessDataSize)\\n\\n      // the hash of the witness should match\\n      if iszero(eq(solutionHash, hash)) {\\n        revert(0, 0)\\n      }\\n\\n      // update contract storage\\n      for { let ptr := 68 } lt(ptr, calldatasize()) { } {\\n        // first byte; 0 = abs, 1 = delta\\n        let storageType := byte(0, calldataload(ptr))\\n        ptr := add(ptr, 1)\\n\\n        // first 32 bytes is the key\\n        let key := calldataload(ptr)\\n        ptr := add(ptr, 32)\\n\\n        // second 32 bytes the value\\n        let val := calldataload(ptr)\\n        ptr := add(ptr, 32)\\n\\n        switch storageType\\n        case 0 {\\n          // the value is absolute\\n          sstore(key, val)\\n        }\\n        default {\\n          // the value is actually a delta\\n          sstore(key, add(sload(key), val))\\n        }\\n      }\\n      stop()\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/HabitatAccount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport './HabitatBase.sol';\\n\\n/// @notice Habitat Accounts, basic functionality for social features.\\n// Audit-1: ok\\ncontract HabitatAccount is HabitatBase {\\n  event ClaimUsername(address indexed account, bytes32 indexed shortString);\\n\\n  /// @dev State transition when a user claims a (short) username.\\n  /// Only one username can be claimed for `msgSender`.\\n  /// If `msgSender` already claimed a name, then it should be freed.\\n  function onClaimUsername (address msgSender, uint256 nonce, bytes32 shortString) external {\\n    HabitatBase._commonChecks();\\n    HabitatBase._checkUpdateNonce(msgSender, nonce);\\n\\n    // checks if the `shortString` is already taken\\n    require(HabitatBase._getStorage(_NAME_TO_ADDRESS_KEY(shortString)) == 0, 'SET');\\n\\n    {\\n      // free the old name, if any\\n      uint256 oldName = HabitatBase._getStorage(_ADDRESS_TO_NAME_KEY(msgSender));\\n      if (oldName != 0) {\\n        HabitatBase._setStorage(_NAME_TO_ADDRESS_KEY(bytes32(oldName)), bytes32(0));\\n      }\\n    }\\n\\n    HabitatBase._setStorage(_NAME_TO_ADDRESS_KEY(shortString), msgSender);\\n    HabitatBase._setStorage(_ADDRESS_TO_NAME_KEY(msgSender), shortString);\\n\\n    if (_shouldEmitEvents()) {\\n      emit ClaimUsername(msgSender, shortString);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/HabitatBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport '@NutBerry/NutBerry/src/v1/contracts/NutBerryFlavorV1.sol';\\nimport './UpgradableRollup.sol';\\n\\n/// @notice Global state and public utiltiy functions for the Habitat Rollup\\n// Audit-1: ok\\ncontract HabitatBase is NutBerryFlavorV1, UpgradableRollup {\\n  // Useful for fetching (compressed) metadata about a specific topic.\\n  event MetadataUpdated(uint256 indexed topic, bytes metadata);\\n\\n  /// @dev The maximum time drift between the time of block submission and a proposal's start date.\\n  /// This is here to avoid keeping proposals off-chain, accumulating votes and finalizing the proposal\\n  /// all at once on block submission without anyone being aware of it.\\n  function _PROPOSAL_DELAY () internal pure virtual returns (uint256) {\\n    // in seconds - 32 hrs\\n    return 3600 * 32;\\n  }\\n\\n  function EPOCH_GENESIS () public pure virtual returns (uint256) {\\n  }\\n\\n  function SECONDS_PER_EPOCH () public pure virtual returns (uint256) {\\n  }\\n\\n  /// @notice The divisor for every tribute. A fraction of the operator tribute always goes into the staking pool.\\n  function STAKING_POOL_FEE_DIVISOR () public pure virtual returns (uint256) {\\n  }\\n\\n  /// @dev Includes common checks for rollup transactions.\\n  function _commonChecks () internal view {\\n    // only allow calls from self\\n    require(msg.sender == address(this));\\n  }\\n\\n  /// @dev Verifies and updates the account nonce for `msgSender`.\\n  function _checkUpdateNonce (address msgSender, uint256 nonce) internal {\\n    require(nonce == txNonces(msgSender), 'NONCE');\\n\\n    _incrementStorage(_TX_NONCE_KEY(msgSender));\\n  }\\n\\n  /// @dev Helper function to calculate a unique seed. Primarily used for deriving addresses.\\n  function _calculateSeed (address msgSender, uint256 nonce) internal pure returns (bytes32 ret) {\\n    assembly {\\n      mstore(0, msgSender)\\n      mstore(32, nonce)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  // Storage helpers, functions will be replaced with special getters/setters to retrieve/store on the rollup\\n  /// @dev Increments `key` by `value`. Reverts on overflow or if `value` is zero.\\n  function _incrementStorage (uint256 key, uint256 value) internal returns (uint256 newValue) {\\n    uint256 oldValue = _sload(key);\\n    newValue = oldValue + value;\\n    require(newValue >= oldValue, 'INCR');\\n    _sstore(key, newValue);\\n  }\\n\\n  function _incrementStorage (uint256 key) internal returns (uint256 newValue) {\\n    newValue = _incrementStorage(key, 1);\\n  }\\n\\n  /// @dev Decrements `key` by `value`. Reverts on underflow or if `value` is zero.\\n  function _decrementStorage (uint256 key, uint256 value) internal returns (uint256 newValue) {\\n    uint256 oldValue = _sload(key);\\n    newValue = oldValue - value;\\n    require(newValue <= oldValue, 'DECR');\\n    _sstore(key, newValue);\\n  }\\n\\n  function _getStorage (uint256 key) internal returns (uint256 ret) {\\n    return _sload(key);\\n  }\\n\\n  function _setStorage (uint256 key, uint256 value) internal {\\n    _sstore(key, value);\\n  }\\n\\n  function _setStorage (uint256 key, bytes32 value) internal {\\n    _sstore(key, uint256(value));\\n  }\\n\\n  function _setStorage (uint256 key, address value) internal {\\n    _sstore(key, uint256(value));\\n  }\\n\\n  /// @dev Helper for `_setStorage`. Writes `uint256(-1)` if `value` is zero.\\n  function _setStorageInfinityIfZero (uint256 key, uint256 value) internal {\\n    if (value == 0) {\\n      value = uint256(-1);\\n    }\\n\\n    _setStorage(key, value);\\n  }\\n\\n  /// @dev Decrements storage for `key` if `a > b` else increments the delta between `a` and `b`.\\n  /// Reverts on over-/underflow and if `a` equals `b`.\\n  function _setStorageDelta (uint256 key, uint256 a, uint256 b) internal {\\n    uint256 newValue;\\n    {\\n      uint256 oldValue = _sload(key);\\n      if (a > b) {\\n        uint256 delta = a - b;\\n        newValue = oldValue - delta;\\n        require(newValue < oldValue, 'DECR');\\n      } else {\\n        uint256 delta = b - a;\\n        newValue = oldValue + delta;\\n        require(newValue > oldValue, 'INCR');\\n      }\\n    }\\n    _sstore(key, newValue);\\n  }\\n  // end of storage helpers\\n\\n  function _TX_NONCE_KEY (address a) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x1baf1b358a7f0088724e8c8008c24c8182cafadcf6b7d0da2db2b55b40320fbf)\\n      mstore(32, a)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _ERC20_KEY (address tkn, address account) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x24de14bddef9089376483557827abada7f1c6135d6d379c3519e56e7bc9067b9)\\n      mstore(32, tkn)\\n      let tmp := mload(64)\\n      mstore(64, account)\\n      ret := keccak256(0, 96)\\n      mstore(64, tmp)\\n    }\\n  }\\n\\n  function _ERC721_KEY (address tkn, uint256 b) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x0b0adec1d909ec867fdb1853ca8d859f7b8137ab9c01f734b3fbfc40d9061ded)\\n      mstore(32, tkn)\\n      let tmp := mload(64)\\n      mstore(64, b)\\n      ret := keccak256(0, 96)\\n      mstore(64, tmp)\\n    }\\n  }\\n\\n  function _VOTING_SHARES_KEY (bytes32 proposalId, address account) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x24ce236379086842ae19f4302972c7dd31f4c5054826cd3e431fd503205f3b67)\\n      mstore(32, proposalId)\\n      let tmp := mload(64)\\n      mstore(64, account)\\n      ret := keccak256(0, 96)\\n      mstore(64, tmp)\\n    }\\n  }\\n\\n  function _VOTING_SIGNAL_KEY (bytes32 proposalId, address account) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x12bc1ed237026cb917edecf1ca641d1047e3fc382300e8b3fab49ae10095e490)\\n      mstore(32, proposalId)\\n      let tmp := mload(64)\\n      mstore(64, account)\\n      ret := keccak256(0, 96)\\n      mstore(64, tmp)\\n    }\\n  }\\n\\n  function _VOTING_COUNT_KEY (bytes32 proposalId) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x637730e93bbd8200299f72f559c841dfae36a36f86ace777eac8fe48f977a46d)\\n      mstore(32, proposalId)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _VOTING_TOTAL_SHARE_KEY (bytes32 proposalId) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x847f5cbc41e438ef8193df4d65950ec6de3a1197e7324bffd84284b7940b2d4a)\\n      mstore(32, proposalId)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _VOTING_TOTAL_SIGNAL_KEY (bytes32 proposalId) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x3a5afbb81b36a1a15e90db8cc0deb491bf6379592f98c129fd8bdf0b887f82dc)\\n      mstore(32, proposalId)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _MEMBER_OF_COMMUNITY_KEY (bytes32 communityId, address account) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x0ff6c2ccfae404e7ec55109209ac7c793d30e6818af453a7c519ca59596ccde1)\\n      mstore(32, communityId)\\n      let tmp := mload(64)\\n      mstore(64, account)\\n      ret := keccak256(0, 96)\\n      mstore(64, tmp)\\n    }\\n  }\\n\\n  function _MEMBERS_TOTAL_COUNT_KEY (bytes32 communityId) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0xe1338c6a5be626513cff1cb54a827862ae2ab4810a79c8dfd1725e69363f4247)\\n      mstore(32, communityId)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _NAME_TO_ADDRESS_KEY (bytes32 shortString) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x09ec9a99acfe90ba324ac042a90e28c5458cfd65beba073b0a92ea7457cdfc56)\\n      mstore(32, shortString)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _ADDRESS_TO_NAME_KEY (address account) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x83cb99259282c2842186d0db03ab6fdfc530b2afa0eb2a4fe480c4815a5e1f34)\\n      mstore(32, account)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _PROPOSAL_VAULT_KEY (bytes32 a) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x622061f2b694ba7aa754d63e7f341f02ac8341e2b36ccbb1d3fc1bf00b57162d)\\n      mstore(32, a)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _PROPOSAL_START_DATE_KEY (bytes32 a) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x539a579b21c2852f7f3a22630162ab505d3fd0b33d6b46f926437d8082d494c1)\\n      mstore(32, a)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _TOKEN_OF_COMMUNITY_KEY (bytes32 a) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0xeadaeda4a4005f296730d16d047925edeb6f21ddc028289ebdd9904f9d65a662)\\n      mstore(32, a)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _COMMUNITY_OF_VAULT_KEY (address a) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0xf659eca1f5df040d1f35ff0bac6c4cd4017c26fe0dbe9317b2241af59edbfe06)\\n      mstore(32, a)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _MODULE_HASH_KEY (address a) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0xe6ab7761f522dca2c6f74f7f7b1083a1b184fec6b893cb3418cb3121c5eda5aa)\\n      mstore(32, a)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _VAULT_CONDITION_KEY (address a) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x615e61b2f7f9d8ca18a90a9b0d27a62ae27581219d586cb9aeb7c695bc7b92c8)\\n      mstore(32, a)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _PROPOSAL_STATUS_KEY (bytes32 a) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x40e11895caf89e87d4485af91bd7e72b6a6e56b94f6ea4b7edb16e869adb7fe9)\\n      mstore(32, a)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _TOKEN_TVL_KEY (address a) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x4e7484f055e36257052a570831d7e3114ad145e0c8d8de63ded89925c7e17cb6)\\n      mstore(32, a)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _PROPOSAL_HASH_INTERNAL_KEY (bytes32 proposalId) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x9f6ffbe6bd26bda84ec854c7775d819340fd4340bc8fa1ab853cdee0d60e7141)\\n      mstore(32, proposalId)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _PROPOSAL_HASH_EXTERNAL_KEY (bytes32 proposalId) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0xcd566f7f1fd69d79df8b7e0a3e28a2b559ab3e7f081db4a0c0640de4db78de9a)\\n      mstore(32, proposalId)\\n      ret := keccak256(0, 64)\\n    }\\n  }\\n\\n  function _EXECUTION_PERMIT_KEY (address vault, bytes32 proposalId) internal pure returns (uint256 ret) {\\n    assembly {\\n      let backup := mload(64)\\n      mstore(0, 0x8d47e278a5e048b636a1e1724246c4617684aff8b922d0878d0da2fb553d104e)\\n      mstore(32, vault)\\n      mstore(64, proposalId)\\n      ret := keccak256(0, 96)\\n      mstore(64, backup)\\n    }\\n  }\\n\\n  function _VOTING_ACTIVE_STAKE_KEY (address token, address account) internal pure returns (uint256 ret) {\\n    assembly {\\n      let backup := mload(64)\\n      mstore(0, 0x2a8a915836beef625eda7be8c32e4f94152e89551893f0eae870e80cab73c496)\\n      mstore(32, token)\\n      mstore(64, account)\\n      ret := keccak256(0, 96)\\n      mstore(64, backup)\\n    }\\n  }\\n\\n  /// @dev Tracks account owner > delegatee allowance for `token`\\n  function _DELEGATED_ACCOUNT_ALLOWANCE_KEY (address account, address delegatee, address token) internal pure returns (uint256 ret) {\\n    assembly {\\n      let backup := mload(64)\\n      mstore(0, 0xf8affafdc89531391d5ba543f3f243d05d9f0325e7bebb13e50d0158dfe7ff74)\\n      mstore(32, account)\\n      mstore(64, delegatee)\\n      mstore(96, token)\\n      ret := keccak256(0, 128)\\n      mstore(64, backup)\\n      mstore(96, 0)\\n    }\\n  }\\n\\n  /// @dev Tracks account owner > total delegated amount of `token`.\\n  function _DELEGATED_ACCOUNT_TOTAL_ALLOWANCE_KEY (address account, address token) internal pure returns (uint256 ret) {\\n    assembly {\\n      let backup := mload(64)\\n      mstore(0, 0x5f823da33b83835d30bb64c6b6539db24009aecef661452e8903ad12aee6bf8d)\\n      mstore(32, account)\\n      mstore(64, token)\\n      ret := keccak256(0, 96)\\n      mstore(64, backup)\\n    }\\n  }\\n\\n  /// @dev Tracks delegatee > total delegated amount of `token`.\\n  function _DELEGATED_ACCOUNT_TOTAL_AMOUNT_KEY (address delegatee, address token) internal pure returns (uint256 ret) {\\n    assembly {\\n      let backup := mload(64)\\n      mstore(0, 0x82dffec7bb13e333bbe061529a9dc24cdad0f5d0900f144abb0bf82b70e68452)\\n      mstore(32, delegatee)\\n      mstore(64, token)\\n      ret := keccak256(0, 96)\\n      mstore(64, backup)\\n    }\\n  }\\n\\n  function _DELEGATED_VOTING_SHARES_KEY (bytes32 proposalId, address delegatee) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x846d3c69e4bfb41c345a501556d4ab5cfb40fa2bbfa478d2d6863adb6a612ce7)\\n      mstore(32, proposalId)\\n      let tmp := mload(64)\\n      mstore(64, delegatee)\\n      ret := keccak256(0, 96)\\n      mstore(64, tmp)\\n    }\\n  }\\n\\n  function _DELEGATED_VOTING_SIGNAL_KEY (bytes32 proposalId, address delegatee) internal pure returns (uint256 ret) {\\n    assembly {\\n      mstore(0, 0x785294304b174fede6de17c61b65e5b77d3e5ad5a71821b78dad3e2dab50d10f)\\n      mstore(32, proposalId)\\n      let tmp := mload(64)\\n      mstore(64, delegatee)\\n      ret := keccak256(0, 96)\\n      mstore(64, tmp)\\n    }\\n  }\\n\\n  function _DELEGATED_VOTING_ACTIVE_STAKE_KEY (address token, address delegatee) internal pure returns (uint256 ret) {\\n    assembly {\\n      let backup := mload(64)\\n      mstore(0, 0xbe24be1148878e5dc0cfaecb52c8dd418ecc98483a44968747d43843653a5754)\\n      mstore(32, token)\\n      mstore(64, delegatee)\\n      ret := keccak256(0, 96)\\n      mstore(64, backup)\\n    }\\n  }\\n\\n  /// @dev The last total value locked of `token` in `epoch`.\\n  function _STAKING_EPOCH_TVL_KEY (uint256 epoch, address token) internal pure returns (uint256 ret) {\\n    assembly {\\n      let backup := mload(64)\\n      mstore(0, 0x8975800e5c219c77b3263a2c64fd28d02cabe02e45f8f9463d035b3c1aae8a62)\\n      mstore(32, epoch)\\n      mstore(64, token)\\n      ret := keccak256(0, 96)\\n      mstore(64, backup)\\n    }\\n  }\\n\\n  /// @dev The last total user balance for `account` in `epoch` of `token`.\\n  function _STAKING_EPOCH_TUB_KEY (uint256 epoch, address token, address account) internal pure returns (uint256 ret) {\\n    assembly {\\n      let backup := mload(64)\\n      mstore(0, 0x6094318105f3510ea893d7758a4f394f18bfa74ee039be1ce39d67a0ab12524c)\\n      mstore(32, epoch)\\n      mstore(64, token)\\n      mstore(96, account)\\n      ret := keccak256(0, 128)\\n      mstore(64, backup)\\n      mstore(96, 0)\\n    }\\n  }\\n\\n  function _STAKING_EPOCH_LAST_CLAIMED_KEY (address token, address account) internal pure returns (uint256 ret) {\\n    assembly {\\n      let backup := mload(64)\\n      mstore(0, 0x6094318105f3510ea893d7758a4f394f18bfa74ee039be1ce39d67a0ab12524f)\\n      mstore(32, token)\\n      mstore(64, account)\\n      ret := keccak256(0, 96)\\n      mstore(64, backup)\\n    }\\n  }\\n\\n  /// @notice Execution permit for <vault, proposalId> = keccak256(actions).\\n  function executionPermit (address vault, bytes32 proposalId) external virtual view returns (bytes32 ret) {\\n    uint256 key = _EXECUTION_PERMIT_KEY(vault, proposalId);\\n    assembly {\\n      ret := sload(key)\\n    }\\n  }\\n\\n  /// @dev Setter for `executionPermit`.\\n  /// Reflects the storage slot for `executionPermit` on L1.\\n  function _setExecutionPermit (address vault, bytes32 proposalId, bytes32 hash) internal {\\n    bytes32 key = bytes32(_EXECUTION_PERMIT_KEY(vault, proposalId));\\n    _setStorageL1(key, uint256(hash));\\n  }\\n\\n  /// @dev Updates the member count for the community if `account` is a new member.\\n  function _maybeUpdateMemberCount (bytes32 proposalId, address account) internal {\\n    address vault = address(_getStorage(_PROPOSAL_VAULT_KEY(proposalId)));\\n    bytes32 communityId = communityOfVault(vault);\\n    if (_getStorage(_MEMBER_OF_COMMUNITY_KEY(communityId, account)) == 0) {\\n      _setStorage(_MEMBER_OF_COMMUNITY_KEY(communityId, account), 1);\\n      _incrementStorage(_MEMBERS_TOTAL_COUNT_KEY(communityId));\\n    }\\n  }\\n\\n  /// @notice The nonce of account `a`.\\n  function txNonces (address a) public virtual returns (uint256) {\\n    uint256 key = _TX_NONCE_KEY(a);\\n    return _sload(key);\\n  }\\n\\n  /// @notice The token balance of `tkn` for `account. This works for ERC-20 and ERC-721.\\n  function getBalance (address tkn, address account) public virtual returns (uint256) {\\n    uint256 key = _ERC20_KEY(tkn, account);\\n    return _sload(key);\\n  }\\n\\n  /// @notice Returns the owner of a ERC-721 token.\\n  function getErc721Owner (address tkn, uint256 b) public virtual returns (address) {\\n    uint256 key = _ERC721_KEY(tkn, b);\\n    return address(_sload(key));\\n  }\\n\\n  /// @notice Returns the cumulative voted shares on `proposalId`.\\n  function getTotalVotingShares (bytes32 proposalId) public returns (uint256) {\\n    uint256 key = _VOTING_TOTAL_SHARE_KEY(proposalId);\\n    return _sload(key);\\n  }\\n\\n  /// @notice Returns the member count for `communityId`.\\n  /// An account automatically becomes a member if it interacts with community vaults & proposals.\\n  function getTotalMemberCount (bytes32 communityId) public returns (uint256) {\\n    uint256 key = _MEMBERS_TOTAL_COUNT_KEY(communityId);\\n    return _sload(key);\\n  }\\n\\n  /// @notice Governance Token of community.\\n  function tokenOfCommunity (bytes32 a) public virtual returns (address) {\\n    uint256 key = _TOKEN_OF_COMMUNITY_KEY(a);\\n    return address(_sload(key));\\n  }\\n\\n  /// @notice Returns the `communityId` of `vault`.\\n  function communityOfVault (address vault) public virtual returns (bytes32) {\\n    uint256 key = _COMMUNITY_OF_VAULT_KEY(vault);\\n    return bytes32(_sload(key));\\n  }\\n\\n  /// @notice Returns the voting status of proposal id `a`.\\n  function getProposalStatus (bytes32 a) public virtual returns (uint256) {\\n    uint256 key = _PROPOSAL_STATUS_KEY(a);\\n    return _sload(key);\\n  }\\n\\n  function getTotalValueLocked (address token) public virtual returns (uint256) {\\n    uint256 key = _TOKEN_TVL_KEY(token);\\n    return _sload(key);\\n  }\\n\\n  function getActiveVotingStake (address token, address account) public returns (uint256) {\\n    uint256 key = _VOTING_ACTIVE_STAKE_KEY(token, account);\\n    return _sload(key);\\n  }\\n\\n  function getActiveDelegatedVotingStake (address token, address account) public returns (uint256) {\\n    uint256 key = _DELEGATED_VOTING_ACTIVE_STAKE_KEY(token, account);\\n    return _sload(key);\\n  }\\n\\n  /// @notice Epoch should be greater than 0.\\n  function getCurrentEpoch () public virtual returns (uint256) {\\n    return ((_getTime() - EPOCH_GENESIS()) / SECONDS_PER_EPOCH()) + 1;\\n  }\\n\\n  /// @notice Used for testing purposes.\\n  function onModifyRollupStorage (address msgSender, uint256 nonce, bytes calldata data) external virtual {\\n    revert('OMRS1');\\n  }\\n\\n  /// @dev Returns true on Layer 2.\\n  function _shouldEmitEvents () internal returns (bool ret) {\\n    assembly {\\n      ret := iszero(origin())\\n    }\\n  }\\n\\n  function getLastClaimedEpoch (address token, address account) external returns (uint256) {\\n    return _getStorage(_STAKING_EPOCH_LAST_CLAIMED_KEY(token, account));\\n  }\\n\\n  function getHistoricTub (address token, address account, uint256 epoch) external returns (uint256) {\\n    return _getStorage(_STAKING_EPOCH_TUB_KEY(epoch, token, account));\\n  }\\n\\n  function getHistoricTvl (address token, uint256 epoch) external returns (uint256) {\\n    return _getStorage(_STAKING_EPOCH_TVL_KEY(epoch, token));\\n  }\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/HabitatCommunity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport './HabitatBase.sol';\\n\\n/// @notice Functionality for Habitat Communities.\\n// Audit-1: ok\\ncontract HabitatCommunity is HabitatBase {\\n  event CommunityCreated(address indexed governanceToken, bytes32 indexed communityId);\\n\\n  /// @dev Creates a Habitat Community.\\n  function onCreateCommunity (address msgSender, uint256 nonce, address governanceToken, bytes calldata metadata) external {\\n    HabitatBase._commonChecks();\\n    HabitatBase._checkUpdateNonce(msgSender, nonce);\\n\\n    require(governanceToken != address(0), 'OCC1');\\n    // calculate a deterministic community id\\n    bytes32 communityId = HabitatBase._calculateSeed(msgSender, nonce);\\n    // checks if the community was already created - should not be possible but anyway...\\n    require(HabitatBase.tokenOfCommunity(communityId) == address(0), 'OCC2');\\n\\n    // community > token\\n    HabitatBase._setStorage(_TOKEN_OF_COMMUNITY_KEY(communityId), governanceToken);\\n    // msgSender is now a member of the community\\n    HabitatBase._setStorage(_MEMBER_OF_COMMUNITY_KEY(communityId, msgSender), 1);\\n    // init total members count\\n    HabitatBase._setStorage(_MEMBERS_TOTAL_COUNT_KEY(communityId), 1);\\n\\n    if (_shouldEmitEvents()) {\\n      emit CommunityCreated(governanceToken, communityId);\\n      emit MetadataUpdated(uint256(communityId), metadata);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/HabitatModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport './HabitatBase.sol';\\n\\n/// @notice Functionality for Habitat Modules\\n// Audit-1: ok\\ncontract HabitatModule is HabitatBase {\\n  event ModuleRegistered(address indexed contractAddress, bytes metadata);\\n\\n  /// @dev Verifies that the bytecode at `contractAddress` can not\\n  /// introduce side effects on the rollup at will.\\n  /// The convention for Modules is that they handle a known set of callbacks\\n  /// without handling their own state. Thus, opcodes for state handling etc are not allowed.\\n  function _verifyModule (address contractAddress) internal view returns (bytes32 codehash) {\\n    assembly {\\n      function doRevert () {\\n        // revert with non-zero returndata to signal we are not out of gas\\n        revert(0, 1)\\n      }\\n\\n      let size := extcodesize(contractAddress)\\n      if iszero(size) {\\n        doRevert()\\n      }\\n\\n      let terminatedByOpcode := 0\\n      let ptr := mload(64)\\n      let end := add(ptr, size)\\n      // copy the bytecode into memory\\n      extcodecopy(contractAddress, ptr, 0, size)\\n      // and hash it\\n      codehash := keccak256(ptr, size)\\n\\n      // verify opcodes\\n      for { } lt(ptr, end) { ptr := add(ptr, 1) } {\\n        // this is used to detect metadata from the solidity compiler\\n        // at the end of the bytecode\\n        // this most likely doesn't work if strings or other data are appended\\n        // at the end of the bytecode,\\n        // but works if the developer follows some conventions.\\n        let terminatedByPreviousOpcode := terminatedByOpcode\\n        terminatedByOpcode := 0\\n        let opcode := byte(0, mload(ptr))\\n\\n        // PUSH opcodes\\n        if and(gt(opcode, 95), lt(opcode, 128)) {\\n          let len := sub(opcode, 95)\\n          ptr := add(ptr, len)\\n          continue\\n        }\\n\\n        // DUPx and SWAPx\\n        if and(gt(opcode, 127), lt(opcode, 160)) {\\n          continue\\n        }\\n\\n        // everything from 0x0 to 0x20 (inclusive)\\n        if lt(opcode, 0x21) {\\n          // in theory, opcode 0x0 (STOP) also terminates execution\\n          // but we will ignore this one\\n          continue\\n        }\\n\\n        // another set of allowed opcodes\\n        switch opcode\\n        // CALLVALUE\\n        case 0x34 {}\\n        // CALLDATALOAD\\n        case 0x35 {}\\n        // CALLDATASIZE\\n        case 0x36 {}\\n        // CALLDATACOPY\\n        case 0x37 {}\\n        // CODESIZE\\n        case 0x38 {}\\n        // CODECOPY\\n        case 0x39 {}\\n        // POP\\n        case 0x50 {}\\n        // MLOAD\\n        case 0x51 {}\\n        // MSTORE\\n        case 0x52 {}\\n        // MSTORE8\\n        case 0x53 {}\\n        // JUMP\\n        case 0x56 {}\\n        // JUMPI\\n        case 0x57 {}\\n        // PC\\n        case 0x58 {}\\n        // MSIZE\\n        case 0x59 {}\\n        // JUMPDEST\\n        case 0x5b {}\\n        // RETURN\\n        case 0xf3 {\\n          terminatedByOpcode := 1\\n        }\\n        // REVERT\\n        case 0xfd {\\n          terminatedByOpcode := 1\\n        }\\n        // INVALID\\n        case 0xfe {\\n          terminatedByOpcode := 1\\n        }\\n        default {\\n          // we fall through if the previous opcode terminates execution\\n          if iszero(terminatedByPreviousOpcode) {\\n            // everything else is not allowed\\n            doRevert()\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @notice Register a module to be used for Habitat Vaults (Treasuries).\\n  /// The bytecode at `contractAddress` must apply to some conventions, see `_verifyModule`.\\n  /// @param _type Must be `1`.\\n  /// @param contractAddress of the module.\\n  /// @param codeHash of the bytecode @ `contractAddress`\\n  function registerModule (\\n    uint256 _type,\\n    address contractAddress,\\n    bytes32 codeHash,\\n    bytes calldata /*metadata*/) external\\n  {\\n    if (_type != 1) {\\n      revert();\\n    }\\n\\n    _createBlockMessage();\\n\\n    // verify the contract code and returns the keccak256(bytecode) (reverts if invalid)\\n    require(_verifyModule(contractAddress) == codeHash && codeHash != 0);\\n  }\\n\\n  /// @notice Layer 2 callback for blocks created with `_createBlockMessage`.\\n  /// Used for module registration (type = 1).\\n  function onCustomBlockBeacon (bytes memory data) external {\\n    HabitatBase._commonChecks();\\n\\n    uint256 _type;\\n    assembly {\\n      _type := calldataload(68)\\n    }\\n\\n    if (_type == 1) {\\n      (, address contractAddress, bytes32 codeHash, bytes memory metadata) =\\n        abi.decode(data, (uint256, address, bytes32, bytes));\\n\\n      // same contract (address) should not be submitted twice\\n      require(HabitatBase._getStorage(_MODULE_HASH_KEY(contractAddress)) == 0, 'OSM1');\\n\\n      HabitatBase._setStorage(_MODULE_HASH_KEY(contractAddress), codeHash);\\n\\n      if (_shouldEmitEvents()) {\\n        emit ModuleRegistered(contractAddress, metadata);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/HabitatStakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport './HabitatBase.sol';\\nimport './HabitatWallet.sol';\\n\\n/// @notice Takes care of transferring value to a operator minus a few that goes to the staking pool.\\n// Audit-1: ok\\ncontract HabitatStakingPool is HabitatBase, HabitatWallet {\\n  event ClaimedStakingReward(address indexed account, address indexed token, uint256 indexed epoch, uint256 amount);\\n\\n  /// @dev Like `_getStorage` but with some additional conditions.\\n  function _specialLoad (uint256 oldValue, uint256 key) internal returns (uint256) {\\n    uint256 newValue = HabitatBase._getStorage(key);\\n\\n    // 0 means no record / no change\\n    if (newValue == 0) {\\n      return oldValue;\\n    }\\n\\n    // -1 means drained (no balance)\\n    if (newValue == uint256(-1)) {\\n      return 0;\\n    }\\n\\n    // default to newValue\\n    return newValue;\\n  }\\n\\n  /// @notice Claims staking rewards for `epoch`.\\n  function onClaimStakingReward (address msgSender, uint256 nonce, address token, uint256 sinceEpoch) external {\\n    HabitatBase._commonChecks();\\n    HabitatBase._checkUpdateNonce(msgSender, nonce);\\n\\n    // we ignore untilEpoch wrapping around because this is not a practical problem\\n    uint256 untilEpoch = sinceEpoch + 10;\\n    {\\n      // assuming getCurrentEpoch never returns 0\\n      uint256 max = getCurrentEpoch();\\n      // clamp\\n      if (untilEpoch > max) {\\n        untilEpoch = max;\\n      }\\n    }\\n    // checks if the account can claim rewards, starting from `sinceEpoch`\\n    require(\\n      sinceEpoch != 0\\n      && untilEpoch > sinceEpoch\\n      && sinceEpoch > HabitatBase._getStorage(_STAKING_EPOCH_LAST_CLAIMED_KEY(token, msgSender)),\\n      'OCSR1'\\n    );\\n\\n    // update last claimed epoch\\n    HabitatBase._setStorage(_STAKING_EPOCH_LAST_CLAIMED_KEY(token, msgSender), untilEpoch - 1);\\n\\n    // this is the total user balance for `token` in any given epoch\\n    uint256 historicTotalUserBalance;\\n\\n    for (uint256 epoch = sinceEpoch; epoch < untilEpoch; epoch++) {\\n      uint256 reward = 0;\\n      // special pool address\\n      address pool = address(epoch);\\n      uint256 poolBalance = getBalance(token, pool);\\n      // total value locked after the end of each epoch.\\n      // tvl being zero should imply that `historicPoolBalance` must also be zero\\n      uint256 historicTVL = HabitatBase._getStorage(_STAKING_EPOCH_TVL_KEY(epoch, token));\\n      // returns the last 'known' user balance up to `epoch`\\n      historicTotalUserBalance = _specialLoad(historicTotalUserBalance, _STAKING_EPOCH_TUB_KEY(epoch, token, msgSender));\\n\\n      if (\\n        poolBalance != 0\\n        && historicTVL != 0\\n        && historicTotalUserBalance != 0\\n        // `historicTotalUserBalance` should always be less than `historicTVL`\\n        && historicTotalUserBalance < historicTVL\\n      ) {\\n        // deduct pool balance from tvl\\n        // assuming `historicPoolBalance` must be less than `historicTVL`\\n        uint256 historicPoolBalance = HabitatBase._getStorage(_STAKING_EPOCH_TUB_KEY(epoch, token, pool));\\n        uint256 tvl = historicTVL - historicPoolBalance;\\n\\n        reward = historicPoolBalance / (tvl / historicTotalUserBalance);\\n\\n        if (reward != 0) {\\n          // this can happen\\n          if (reward > poolBalance) {\\n            reward = poolBalance;\\n          }\\n          _transferToken(token, pool, msgSender, reward);\\n        }\\n      }\\n\\n      if (_shouldEmitEvents()) {\\n        emit ClaimedStakingReward(msgSender, token, epoch, reward);\\n      }\\n    }\\n\\n    // store the tub for the user but do not overwrite if there is already\\n    // a non-zero entry\\n    uint256 key = _STAKING_EPOCH_TUB_KEY(untilEpoch, token, msgSender);\\n    if (HabitatBase._getStorage(key) == 0) {\\n      _setStorageInfinityIfZero(key, historicTotalUserBalance);\\n    }\\n  }\\n\\n  /// @notice Transfers funds to a (trusted) operator.\\n  /// A fraction `STAKING_POOL_FEE_DIVISOR` of the funds goes to the staking pool.\\n  function onTributeForOperator (\\n    address msgSender,\\n    uint256 nonce,\\n    address operator,\\n    address token,\\n    uint256 amount\\n  ) external {\\n    HabitatBase._commonChecks();\\n    HabitatBase._checkUpdateNonce(msgSender, nonce);\\n\\n    // fee can be zero\\n    uint256 fee = amount / STAKING_POOL_FEE_DIVISOR();\\n    // epoch is greater than zero\\n    uint256 currentEpoch = getCurrentEpoch();\\n    address pool = address(currentEpoch);\\n    // zero-value transfers are not a problem\\n    _transferToken(token, msgSender, pool, fee);\\n    _transferToken(token, msgSender, operator, amount - fee);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/HabitatV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport './HabitatV1Challenge.sol';\\nimport './HabitatBase.sol';\\nimport './HabitatAccount.sol';\\nimport './HabitatWallet.sol';\\nimport './HabitatCommunity.sol';\\nimport './HabitatVault.sol';\\nimport './HabitatVoting.sol';\\nimport './HabitatModule.sol';\\nimport './HabitatStakingPool.sol';\\n\\n/// @notice Composition of the full Habitat Rollup contracts (v1)\\n// Audit-1: ok\\ncontract HabitatV1 is\\n  HabitatBase,\\n  HabitatAccount,\\n  HabitatWallet,\\n  HabitatCommunity,\\n  HabitatVault,\\n  HabitatVoting,\\n  HabitatModule,\\n  HabitatStakingPool,\\n  HabitatV1Challenge\\n{\\n  /// @inheritdoc NutBerryCore\\n  function MAX_BLOCK_SIZE () public view override returns (uint24) {\\n    return 31744;\\n  }\\n\\n  /// @inheritdoc NutBerryCore\\n  function INSPECTION_PERIOD () public view virtual override returns (uint16) {\\n    // in blocks, (3600 * 24 * 7) seconds / 14s per block\\n    return 43200;\\n  }\\n\\n  /// @inheritdoc NutBerryCore\\n  function INSPECTION_PERIOD_MULTIPLIER () public view override returns (uint256) {\\n    return 3;\\n  }\\n\\n  /// @inheritdoc NutBerryCore\\n  function _CHALLENGE_IMPLEMENTATION_ADDRESS () internal override returns (address addr) {\\n    assembly {\\n      // loads the target contract adddress from the proxy slot\\n      addr := sload(not(0))\\n    }\\n  }\\n\\n  /// @inheritdoc UpgradableRollup\\n  function ROLLUP_MANAGER () public virtual override pure returns (address) {\\n    // Habitat multisig - will be replaced by the community governance proxy in the future\\n    return 0xc97f82c80DF57c34E84491C0EDa050BA924D7429;\\n  }\\n\\n  /// @inheritdoc HabitatBase\\n  function STAKING_POOL_FEE_DIVISOR () public virtual override pure returns (uint256) {\\n    // 1%\\n    return 100;\\n  }\\n\\n  /// @inheritdoc HabitatBase\\n  function EPOCH_GENESIS () public virtual override pure returns (uint256) {\\n    // Date.parse('2021-06-23') / 1000\\n    return 1624406400;\\n  }\\n\\n  /// @inheritdoc HabitatBase\\n  function SECONDS_PER_EPOCH () public virtual override pure returns (uint256) {\\n    // 7 days\\n    return 604800;\\n  }\\n\\n  /// @notice Used for fixing rollup storage due to logic bugs.\\n  function onModifyRollupStorage (address msgSender, uint256 nonce, bytes calldata data) external virtual override {\\n    HabitatBase._commonChecks();\\n    HabitatBase._checkUpdateNonce(msgSender, nonce);\\n\\n    {\\n      // MODIFIY_ROLLUP_STORAGE_ERRATA_KEY\\n      uint256 storageKey = 0xa7be6244e780b8d3f5c3e14f6a3ffd87b6bbc48b7b9cb71a2e521495d8905ecc;\\n      uint256 currentErrata = HabitatBase._getStorage(storageKey);\\n      require(currentErrata == 0, 'OMRS1');\\n      HabitatBase._setStorage(storageKey, 1);\\n    }\\n\\n    {\\n      // #1 - depositing from L1 to a vault on L2 resulted in incorrectly\\n      // increasing TVL\\n      // This happened 2x with HBT in epoch #2.\\n      uint256 epoch = 2;\\n      address token = 0x0aCe32f6E87Ac1457A5385f8eb0208F37263B415;\\n      // cumulative amount of HBT to remove from TVL\\n      uint256 tvlToRemove = 16800100000000000;\\n\\n      HabitatBase._decrementStorage(_TOKEN_TVL_KEY(token), tvlToRemove);\\n      HabitatBase._setStorage(\\n        _STAKING_EPOCH_TVL_KEY(epoch, token),\\n        HabitatBase._getStorage(_TOKEN_TVL_KEY(token))\\n      );\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/HabitatV1Challenge.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\n/// @dev Autogenerated file. Do not edit manually.\\ncontract HabitatV1Challenge {\\n  /// @dev Challenge the solution or just verify the next pending block directly.\\n  /// calldata layout:\\n  /// < 4 bytes function sig >\\n  /// < 32 bytes challenge offset >\\n  /// < 32 bytes address of challenge handler - contract (self) >\\n  /// < 32 bytes size of block >\\n  /// < 32 bytes number of challenge rounds >\\n  /// < arbitrary witness data >\\n  /// < data of block >\\n  function onChallenge () external returns (uint256) {\\n    // all power the core protocol\\n    require(msg.sender == address(this));\\n\\n    assembly {\\n      \\nfunction _parseTransaction (o) -> offset, success, inOffset, inSize {\\n  // zero memory\\n  calldatacopy(0, calldatasize(), msize())\\n  offset := o\\n\\n  let firstByte := byte(0, calldataload(offset))\\n  let v := add(and(firstByte, 1), 27)\\n  let primaryType := shr(1, firstByte)\\n  offset := add(offset, 1)\\n  let r := calldataload(offset)\\n  offset := add(offset, 32)\\n  let s := calldataload(offset)\\n  offset := add(offset, 32)\\n\\n  switch primaryType\\n\\n// start of TransferToken\\n// typeHash: 0xf121759935d81b9588e8434983e70b870ab10987a39b454ac893e1480f028e46\\n// function: onTransferToken(address,uint256,address,address,uint256)\\ncase 0 {\\n  let headSize := 160\\n  let typeLen := 0\\n  let txPtr := 384\\n  let endOfSlot := add(txPtr, 160)\\n\\n  txPtr := 416\\n  // typeHash of TransferToken\\n  mstore(0, 0xf121759935d81b9588e8434983e70b870ab10987a39b454ac893e1480f028e46)\\n  // uint256 TransferToken.nonce\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(32, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // address TransferToken.token\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(64, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // address TransferToken.to\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(96, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // uint256 TransferToken.value\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(128, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // typeHash\\n  let structHash := keccak256(0, 160)\\n  // prefix\\n  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n  // DOMAIN struct hash\\n  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)\\n  // transactionStructHash\\n  mstore(34, structHash)\\n  mstore(0, keccak256(0, 66))\\n  mstore(32, v)\\n  mstore(64, r)\\n  mstore(96, s)\\n  success := staticcall(gas(), 1, 0, 128, 128, 32)\\n  // functionSig\\n  mstore(352, 0x11d4aec1)\\n  mstore(384, mload(128))\\n\\n  inOffset := 380\\n  inSize := sub(endOfSlot, 380)\\n}\\n// end of TransferToken\\n\\n// start of ClaimUsername\\n// typeHash: 0x8b505a1c00897e3b1949f8e114b8f1a4cdeed6d6a26926931f57f885f33f6cfa\\n// function: onClaimUsername(address,uint256,bytes32)\\ncase 1 {\\n  let headSize := 96\\n  let typeLen := 0\\n  let txPtr := 256\\n  let endOfSlot := add(txPtr, 96)\\n\\n  txPtr := 288\\n  // typeHash of ClaimUsername\\n  mstore(0, 0x8b505a1c00897e3b1949f8e114b8f1a4cdeed6d6a26926931f57f885f33f6cfa)\\n  // uint256 ClaimUsername.nonce\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(32, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // bytes32 ClaimUsername.shortString\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(64, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // typeHash\\n  let structHash := keccak256(0, 96)\\n  // prefix\\n  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n  // DOMAIN struct hash\\n  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)\\n  // transactionStructHash\\n  mstore(34, structHash)\\n  mstore(0, keccak256(0, 66))\\n  mstore(32, v)\\n  mstore(64, r)\\n  mstore(96, s)\\n  success := staticcall(gas(), 1, 0, 128, 128, 32)\\n  // functionSig\\n  mstore(224, 0x0827bab8)\\n  mstore(256, mload(128))\\n\\n  inOffset := 252\\n  inSize := sub(endOfSlot, 252)\\n}\\n// end of ClaimUsername\\n\\n// start of CreateCommunity\\n// typeHash: 0x4b8e81699d7dc349aa2eca5d6740c23aff4244d26288627f4ca3be7d236f5127\\n// function: onCreateCommunity(address,uint256,address,bytes)\\ncase 2 {\\n  let headSize := 128\\n  let typeLen := 0\\n  let txPtr := 320\\n  let endOfSlot := add(txPtr, 128)\\n\\n  txPtr := 352\\n  // typeHash of CreateCommunity\\n  mstore(0, 0x4b8e81699d7dc349aa2eca5d6740c23aff4244d26288627f4ca3be7d236f5127)\\n  // uint256 CreateCommunity.nonce\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(32, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // address CreateCommunity.governanceToken\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(64, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // bytes CreateCommunity.metadata\\n  typeLen := shr(240, calldataload(offset))\\n  offset := add(offset, 2)\\n  mstore(txPtr, headSize)\\n  headSize := add(headSize, add( 32, mul( 32, div( add(typeLen, 31), 32 ) ) ))\\n  txPtr := add(txPtr, 32)\\n  mstore(endOfSlot, typeLen)\\n  endOfSlot := add(endOfSlot, 32)\\n  calldatacopy(endOfSlot, offset, typeLen)\\n  mstore(96, keccak256(endOfSlot, typeLen))\\n  endOfSlot := add(endOfSlot, mul( 32, div( add(typeLen, 31), 32 ) ))\\n  offset := add(offset, typeLen)\\n\\n  // typeHash\\n  let structHash := keccak256(0, 128)\\n  // prefix\\n  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n  // DOMAIN struct hash\\n  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)\\n  // transactionStructHash\\n  mstore(34, structHash)\\n  mstore(0, keccak256(0, 66))\\n  mstore(32, v)\\n  mstore(64, r)\\n  mstore(96, s)\\n  success := staticcall(gas(), 1, 0, 128, 128, 32)\\n  // functionSig\\n  mstore(288, 0x5b292e29)\\n  mstore(320, mload(128))\\n\\n  inOffset := 316\\n  inSize := sub(endOfSlot, 316)\\n}\\n// end of CreateCommunity\\n\\n// start of CreateVault\\n// typeHash: 0xd039a4c4cd9e9890710392eef9936bf5d690ec47246e5d6f4693c764d6b62635\\n// function: onCreateVault(address,uint256,bytes32,address,bytes)\\ncase 3 {\\n  let headSize := 160\\n  let typeLen := 0\\n  let txPtr := 384\\n  let endOfSlot := add(txPtr, 160)\\n\\n  txPtr := 416\\n  // typeHash of CreateVault\\n  mstore(0, 0xd039a4c4cd9e9890710392eef9936bf5d690ec47246e5d6f4693c764d6b62635)\\n  // uint256 CreateVault.nonce\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(32, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // bytes32 CreateVault.communityId\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(64, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // address CreateVault.condition\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(96, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // bytes CreateVault.metadata\\n  typeLen := shr(240, calldataload(offset))\\n  offset := add(offset, 2)\\n  mstore(txPtr, headSize)\\n  headSize := add(headSize, add( 32, mul( 32, div( add(typeLen, 31), 32 ) ) ))\\n  txPtr := add(txPtr, 32)\\n  mstore(endOfSlot, typeLen)\\n  endOfSlot := add(endOfSlot, 32)\\n  calldatacopy(endOfSlot, offset, typeLen)\\n  mstore(128, keccak256(endOfSlot, typeLen))\\n  endOfSlot := add(endOfSlot, mul( 32, div( add(typeLen, 31), 32 ) ))\\n  offset := add(offset, typeLen)\\n\\n  // typeHash\\n  let structHash := keccak256(0, 160)\\n  // prefix\\n  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n  // DOMAIN struct hash\\n  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)\\n  // transactionStructHash\\n  mstore(34, structHash)\\n  mstore(0, keccak256(0, 66))\\n  mstore(32, v)\\n  mstore(64, r)\\n  mstore(96, s)\\n  success := staticcall(gas(), 1, 0, 128, 128, 32)\\n  // functionSig\\n  mstore(352, 0x9617e0c5)\\n  mstore(384, mload(128))\\n\\n  inOffset := 380\\n  inSize := sub(endOfSlot, 380)\\n}\\n// end of CreateVault\\n\\n// start of CreateProposal\\n// typeHash: 0x4d8a9f544d08772d597445c015580bcc93a38fd87bcf6be01f7b542ccdb97814\\n// function: onCreateProposal(address,uint256,uint256,address,bytes,bytes,bytes)\\ncase 4 {\\n  let headSize := 224\\n  let typeLen := 0\\n  let txPtr := 512\\n  let endOfSlot := add(txPtr, 224)\\n\\n  txPtr := 544\\n  // typeHash of CreateProposal\\n  mstore(0, 0x4d8a9f544d08772d597445c015580bcc93a38fd87bcf6be01f7b542ccdb97814)\\n  // uint256 CreateProposal.nonce\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(32, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // uint256 CreateProposal.startDate\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(64, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // address CreateProposal.vault\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(96, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // bytes CreateProposal.internalActions\\n  typeLen := shr(240, calldataload(offset))\\n  offset := add(offset, 2)\\n  mstore(txPtr, headSize)\\n  headSize := add(headSize, add( 32, mul( 32, div( add(typeLen, 31), 32 ) ) ))\\n  txPtr := add(txPtr, 32)\\n  mstore(endOfSlot, typeLen)\\n  endOfSlot := add(endOfSlot, 32)\\n  calldatacopy(endOfSlot, offset, typeLen)\\n  mstore(128, keccak256(endOfSlot, typeLen))\\n  endOfSlot := add(endOfSlot, mul( 32, div( add(typeLen, 31), 32 ) ))\\n  offset := add(offset, typeLen)\\n\\n  // bytes CreateProposal.externalActions\\n  typeLen := shr(240, calldataload(offset))\\n  offset := add(offset, 2)\\n  mstore(txPtr, headSize)\\n  headSize := add(headSize, add( 32, mul( 32, div( add(typeLen, 31), 32 ) ) ))\\n  txPtr := add(txPtr, 32)\\n  mstore(endOfSlot, typeLen)\\n  endOfSlot := add(endOfSlot, 32)\\n  calldatacopy(endOfSlot, offset, typeLen)\\n  mstore(160, keccak256(endOfSlot, typeLen))\\n  endOfSlot := add(endOfSlot, mul( 32, div( add(typeLen, 31), 32 ) ))\\n  offset := add(offset, typeLen)\\n\\n  // bytes CreateProposal.metadata\\n  typeLen := shr(240, calldataload(offset))\\n  offset := add(offset, 2)\\n  mstore(txPtr, headSize)\\n  headSize := add(headSize, add( 32, mul( 32, div( add(typeLen, 31), 32 ) ) ))\\n  txPtr := add(txPtr, 32)\\n  mstore(endOfSlot, typeLen)\\n  endOfSlot := add(endOfSlot, 32)\\n  calldatacopy(endOfSlot, offset, typeLen)\\n  mstore(192, keccak256(endOfSlot, typeLen))\\n  endOfSlot := add(endOfSlot, mul( 32, div( add(typeLen, 31), 32 ) ))\\n  offset := add(offset, typeLen)\\n\\n  // typeHash\\n  let structHash := keccak256(0, 224)\\n  // prefix\\n  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n  // DOMAIN struct hash\\n  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)\\n  // transactionStructHash\\n  mstore(34, structHash)\\n  mstore(0, keccak256(0, 66))\\n  mstore(32, v)\\n  mstore(64, r)\\n  mstore(96, s)\\n  success := staticcall(gas(), 1, 0, 128, 128, 32)\\n  // functionSig\\n  mstore(480, 0x9cc39bbe)\\n  mstore(512, mload(128))\\n\\n  inOffset := 508\\n  inSize := sub(endOfSlot, 508)\\n}\\n// end of CreateProposal\\n\\n// start of VoteOnProposal\\n// typeHash: 0xeedce560579f8160e8bbb71ad5823fb1098eee0d1116be92232ee87ab1bce294\\n// function: onVoteOnProposal(address,uint256,bytes32,uint256,address,uint8)\\ncase 5 {\\n  let headSize := 192\\n  let typeLen := 0\\n  let txPtr := 448\\n  let endOfSlot := add(txPtr, 192)\\n\\n  txPtr := 480\\n  // typeHash of VoteOnProposal\\n  mstore(0, 0xeedce560579f8160e8bbb71ad5823fb1098eee0d1116be92232ee87ab1bce294)\\n  // uint256 VoteOnProposal.nonce\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(32, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // bytes32 VoteOnProposal.proposalId\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(64, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // uint256 VoteOnProposal.shares\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(96, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // address VoteOnProposal.delegatedFor\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(128, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // uint8 VoteOnProposal.signalStrength\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(160, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // typeHash\\n  let structHash := keccak256(0, 192)\\n  // prefix\\n  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n  // DOMAIN struct hash\\n  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)\\n  // transactionStructHash\\n  mstore(34, structHash)\\n  mstore(0, keccak256(0, 66))\\n  mstore(32, v)\\n  mstore(64, r)\\n  mstore(96, s)\\n  success := staticcall(gas(), 1, 0, 128, 128, 32)\\n  // functionSig\\n  mstore(416, 0xd87eafef)\\n  mstore(448, mload(128))\\n\\n  inOffset := 444\\n  inSize := sub(endOfSlot, 444)\\n}\\n// end of VoteOnProposal\\n\\n// start of ProcessProposal\\n// typeHash: 0xb4da110edbcfa262bdf7849c0e02e03ed15ced328922eca5a0bc1c547451b4af\\n// function: onProcessProposal(address,uint256,bytes32,bytes,bytes)\\ncase 6 {\\n  let headSize := 160\\n  let typeLen := 0\\n  let txPtr := 384\\n  let endOfSlot := add(txPtr, 160)\\n\\n  txPtr := 416\\n  // typeHash of ProcessProposal\\n  mstore(0, 0xb4da110edbcfa262bdf7849c0e02e03ed15ced328922eca5a0bc1c547451b4af)\\n  // uint256 ProcessProposal.nonce\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(32, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // bytes32 ProcessProposal.proposalId\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(64, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // bytes ProcessProposal.internalActions\\n  typeLen := shr(240, calldataload(offset))\\n  offset := add(offset, 2)\\n  mstore(txPtr, headSize)\\n  headSize := add(headSize, add( 32, mul( 32, div( add(typeLen, 31), 32 ) ) ))\\n  txPtr := add(txPtr, 32)\\n  mstore(endOfSlot, typeLen)\\n  endOfSlot := add(endOfSlot, 32)\\n  calldatacopy(endOfSlot, offset, typeLen)\\n  mstore(96, keccak256(endOfSlot, typeLen))\\n  endOfSlot := add(endOfSlot, mul( 32, div( add(typeLen, 31), 32 ) ))\\n  offset := add(offset, typeLen)\\n\\n  // bytes ProcessProposal.externalActions\\n  typeLen := shr(240, calldataload(offset))\\n  offset := add(offset, 2)\\n  mstore(txPtr, headSize)\\n  headSize := add(headSize, add( 32, mul( 32, div( add(typeLen, 31), 32 ) ) ))\\n  txPtr := add(txPtr, 32)\\n  mstore(endOfSlot, typeLen)\\n  endOfSlot := add(endOfSlot, 32)\\n  calldatacopy(endOfSlot, offset, typeLen)\\n  mstore(128, keccak256(endOfSlot, typeLen))\\n  endOfSlot := add(endOfSlot, mul( 32, div( add(typeLen, 31), 32 ) ))\\n  offset := add(offset, typeLen)\\n\\n  // typeHash\\n  let structHash := keccak256(0, 160)\\n  // prefix\\n  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n  // DOMAIN struct hash\\n  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)\\n  // transactionStructHash\\n  mstore(34, structHash)\\n  mstore(0, keccak256(0, 66))\\n  mstore(32, v)\\n  mstore(64, r)\\n  mstore(96, s)\\n  success := staticcall(gas(), 1, 0, 128, 128, 32)\\n  // functionSig\\n  mstore(352, 0x36b54032)\\n  mstore(384, mload(128))\\n\\n  inOffset := 380\\n  inSize := sub(endOfSlot, 380)\\n}\\n// end of ProcessProposal\\n\\n// start of TributeForOperator\\n// typeHash: 0x1d7f2e50c4a73ada77cc1796f78f259a43e44d6d99adaf69a6628ef42c527df7\\n// function: onTributeForOperator(address,uint256,address,address,uint256)\\ncase 7 {\\n  let headSize := 160\\n  let typeLen := 0\\n  let txPtr := 384\\n  let endOfSlot := add(txPtr, 160)\\n\\n  txPtr := 416\\n  // typeHash of TributeForOperator\\n  mstore(0, 0x1d7f2e50c4a73ada77cc1796f78f259a43e44d6d99adaf69a6628ef42c527df7)\\n  // uint256 TributeForOperator.nonce\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(32, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // address TributeForOperator.operator\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(64, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // address TributeForOperator.token\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(96, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // uint256 TributeForOperator.amount\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(128, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // typeHash\\n  let structHash := keccak256(0, 160)\\n  // prefix\\n  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n  // DOMAIN struct hash\\n  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)\\n  // transactionStructHash\\n  mstore(34, structHash)\\n  mstore(0, keccak256(0, 66))\\n  mstore(32, v)\\n  mstore(64, r)\\n  mstore(96, s)\\n  success := staticcall(gas(), 1, 0, 128, 128, 32)\\n  // functionSig\\n  mstore(352, 0x24fa29ea)\\n  mstore(384, mload(128))\\n\\n  inOffset := 380\\n  inSize := sub(endOfSlot, 380)\\n}\\n// end of TributeForOperator\\n\\n// start of DelegateAmount\\n// typeHash: 0x7595f378ac19fee39d9d6a79a8240d32afae43c5943289e491976d85c9e9ad54\\n// function: onDelegateAmount(address,uint256,address,address,uint256)\\ncase 8 {\\n  let headSize := 160\\n  let typeLen := 0\\n  let txPtr := 384\\n  let endOfSlot := add(txPtr, 160)\\n\\n  txPtr := 416\\n  // typeHash of DelegateAmount\\n  mstore(0, 0x7595f378ac19fee39d9d6a79a8240d32afae43c5943289e491976d85c9e9ad54)\\n  // uint256 DelegateAmount.nonce\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(32, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // address DelegateAmount.delegatee\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(64, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // address DelegateAmount.token\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(96, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // uint256 DelegateAmount.value\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(128, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // typeHash\\n  let structHash := keccak256(0, 160)\\n  // prefix\\n  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n  // DOMAIN struct hash\\n  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)\\n  // transactionStructHash\\n  mstore(34, structHash)\\n  mstore(0, keccak256(0, 66))\\n  mstore(32, v)\\n  mstore(64, r)\\n  mstore(96, s)\\n  success := staticcall(gas(), 1, 0, 128, 128, 32)\\n  // functionSig\\n  mstore(352, 0x1b5e17db)\\n  mstore(384, mload(128))\\n\\n  inOffset := 380\\n  inSize := sub(endOfSlot, 380)\\n}\\n// end of DelegateAmount\\n\\n// start of ClaimStakingReward\\n// typeHash: 0x56d7b9415a7ab01a4e256d5e8a8a100fcf839c82096289e6a835115c704aee67\\n// function: onClaimStakingReward(address,uint256,address,uint256)\\ncase 9 {\\n  let headSize := 128\\n  let typeLen := 0\\n  let txPtr := 320\\n  let endOfSlot := add(txPtr, 128)\\n\\n  txPtr := 352\\n  // typeHash of ClaimStakingReward\\n  mstore(0, 0x56d7b9415a7ab01a4e256d5e8a8a100fcf839c82096289e6a835115c704aee67)\\n  // uint256 ClaimStakingReward.nonce\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(32, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // address ClaimStakingReward.token\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(64, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // uint256 ClaimStakingReward.sinceEpoch\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(96, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // typeHash\\n  let structHash := keccak256(0, 128)\\n  // prefix\\n  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n  // DOMAIN struct hash\\n  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)\\n  // transactionStructHash\\n  mstore(34, structHash)\\n  mstore(0, keccak256(0, 66))\\n  mstore(32, v)\\n  mstore(64, r)\\n  mstore(96, s)\\n  success := staticcall(gas(), 1, 0, 128, 128, 32)\\n  // functionSig\\n  mstore(288, 0x8e7700c0)\\n  mstore(320, mload(128))\\n\\n  inOffset := 316\\n  inSize := sub(endOfSlot, 316)\\n}\\n// end of ClaimStakingReward\\n\\n// start of ModifyRollupStorage\\n// typeHash: 0x31a8f1b3e855fde3871d440618da073d0504133dc34db1896de6774ed15abb70\\n// function: onModifyRollupStorage(address,uint256,bytes)\\ncase 10 {\\n  let headSize := 96\\n  let typeLen := 0\\n  let txPtr := 256\\n  let endOfSlot := add(txPtr, 96)\\n\\n  txPtr := 288\\n  // typeHash of ModifyRollupStorage\\n  mstore(0, 0x31a8f1b3e855fde3871d440618da073d0504133dc34db1896de6774ed15abb70)\\n  // uint256 ModifyRollupStorage.nonce\\n  typeLen := byte(0, calldataload(offset))\\n  offset := add(offset, 1)\\n  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)\\n  mstore(32, mload(txPtr))\\n  offset := add(offset, typeLen)\\n  txPtr := add(txPtr, 32)\\n\\n  // bytes ModifyRollupStorage.data\\n  typeLen := shr(240, calldataload(offset))\\n  offset := add(offset, 2)\\n  mstore(txPtr, headSize)\\n  headSize := add(headSize, add( 32, mul( 32, div( add(typeLen, 31), 32 ) ) ))\\n  txPtr := add(txPtr, 32)\\n  mstore(endOfSlot, typeLen)\\n  endOfSlot := add(endOfSlot, 32)\\n  calldatacopy(endOfSlot, offset, typeLen)\\n  mstore(64, keccak256(endOfSlot, typeLen))\\n  endOfSlot := add(endOfSlot, mul( 32, div( add(typeLen, 31), 32 ) ))\\n  offset := add(offset, typeLen)\\n\\n  // typeHash\\n  let structHash := keccak256(0, 96)\\n  // prefix\\n  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n  // DOMAIN struct hash\\n  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)\\n  // transactionStructHash\\n  mstore(34, structHash)\\n  mstore(0, keccak256(0, 66))\\n  mstore(32, v)\\n  mstore(64, r)\\n  mstore(96, s)\\n  success := staticcall(gas(), 1, 0, 128, 128, 32)\\n  // functionSig\\n  mstore(224, 0x10ea8892)\\n  mstore(256, mload(128))\\n\\n  inOffset := 252\\n  inSize := sub(endOfSlot, 252)\\n}\\n// end of ModifyRollupStorage\\ndefault { }\\n}\\n\\n\\n      \\n// verifies a proof\\nfunction verifyUniform (proofOffset, len, key, root) -> valid, inTree, value {\\n  let _k := 0\\n  let _v := 0\\n  let ret := 0\\n\\n  if len {\\n    // if # of proof elements are greather than 0 and less than 2, revert\\n    if lt(len, 2) {\\n      revert(0, 0)\\n    }\\n\\n    _k := calldataload(proofOffset)\\n    proofOffset := add(proofOffset, 32)\\n    _v := calldataload(proofOffset)\\n    proofOffset := add(proofOffset, 32)\\n\\n    if _v {\\n      // leafHash\\n      // left, right = key, value\\n      inTree := eq(key, _k)\\n      \\n  // hash leaf\\n  mstore(0, _k)\\n  mstore(32, _v)\\n  mstore(64, 1)\\n  ret := keccak256(0, 96)\\n  // end of hash leaf\\n\\n    }\\n  }\\n\\n  // it is not used anyway if it underflows (see loop)\\n  let depth := sub(len, 2)\\n\\n  for { let i := 2 } lt(i, len) { i:= add(i, 1) } {\\n    depth := sub(depth, 1)\\n    let bitmask := shl(depth, 1)\\n    let goLeft := and(key, bitmask)\\n    let next := calldataload(proofOffset)\\n    proofOffset := add(proofOffset, 32)\\n\\n    \\n  // hash branch\\n  switch goLeft\\n  case 0 {\\n    mstore(0, next)\\n    mstore(32, ret)\\n  }\\n  default {\\n    mstore(0, ret)\\n    mstore(32, next)\\n  }\\n  ret := keccak256(0, 64)\\n  // end of hash branch\\n\\n  }\\n\\n  valid := eq(ret, root)\\n  if iszero(valid) {\\n    inTree := 0\\n  }\\n  if inTree {\\n    value := _v\\n  }\\n}\\n\\n      \\nfunction updateTree (ptr, len, key, newValue) -> ret {\\n  let _k := 0\\n  let _v := 0\\n\\n  if newValue {\\n    // insert or update\\n    // hash leaf\\n    \\n  // hash leaf\\n  mstore(0, key)\\n  mstore(32, newValue)\\n  mstore(64, 1)\\n  ret := keccak256(0, 96)\\n  // end of hash leaf\\n\\n  }\\n\\n  if len {\\n    if lt(len, 2) {\\n      // invalid proof\\n      revert(0, 0)\\n    }\\n\\n    _k := calldataload(ptr)\\n    ptr := add(ptr, 32)\\n    _v := calldataload(ptr)\\n    ptr := add(ptr, 32)\\n\\n    // _v != 0 && key != _k\\n    if and(iszero(iszero(_v)), iszero(eq(key, _k))) {\\n      // Update and create a new branch.\\n      // Compare against the key of the other leaf and loop until diverge.\\n      // Then create a new branch(es).\\n\\n      // minus [_k, _v]\\n      let depth := sub(len, 2)\\n      for {} true {} {\\n        let bitmask := shl(depth, 1)\\n        let goLeft := and(key, bitmask)\\n        let otherLeft := and(_k, bitmask)\\n\\n        if eq(goLeft, otherLeft) {\\n          // key and _k are still on the same path, go deeper\\n          depth := add(depth, 1)\\n          continue\\n        }\\n\\n        let other\\n        \\n  // hash leaf\\n  mstore(0, _k)\\n  mstore(32, _v)\\n  mstore(64, 1)\\n  other := keccak256(0, 96)\\n  // end of hash leaf\\n\\n        \\n  // hash branch\\n  switch goLeft\\n  case 0 {\\n    mstore(0, other)\\n    mstore(32, ret)\\n  }\\n  default {\\n    mstore(0, ret)\\n    mstore(32, other)\\n  }\\n  ret := keccak256(0, 64)\\n  // end of hash branch\\n\\n        break\\n      }\\n\\n      // now, walk back and hash each new branch with a zero-neighbor.\\n      let odepth := sub(len, 2)\\n      for {} iszero(eq(depth, odepth)) {} {\\n        depth := sub(depth, 1)\\n        let bitmask := shl(depth, 1)\\n        let goLeft := and(key, bitmask)\\n\\n        \\n  // hash branch\\n  switch goLeft\\n  case 0 {\\n    mstore(0, 0)\\n    mstore(32, ret)\\n  }\\n  default {\\n    mstore(0, ret)\\n    mstore(32, 0)\\n  }\\n  ret := keccak256(0, 64)\\n  // end of hash branch\\n\\n      }\\n    }\\n  }\\n\\n  // use the supplied proofs and walk back to the root (TM)\\n  // minus [_k, _v]\\n  let depth := sub(len, 2)\\n  for { let i := 2 } lt(i, len) {} {\\n    depth := sub(depth, 1)\\n\\n    let bitmask := shl(depth, 1)\\n    let goLeft := and(key, bitmask)\\n    let next := calldataload(ptr)\\n    ptr := add(ptr, 32)\\n    i := add(i, 1)\\n\\n    \\n  // hash branch\\n  switch goLeft\\n  case 0 {\\n    mstore(0, next)\\n    mstore(32, ret)\\n  }\\n  default {\\n    mstore(0, ret)\\n    mstore(32, next)\\n  }\\n  ret := keccak256(0, 64)\\n  // end of hash branch\\n\\n  }\\n\\n  // ret contains new root\\n}\\n\\n\\n      // pre & post transaction verification\\n      function verifyTransition (blockTimestamp, __rootHash, __witnessOffset, inOffset, inSize) -> witnessOffset, rootHash {\\n        // setup return value\\n        rootHash := __rootHash\\n        witnessOffset := __witnessOffset\\n\\n        // number of storage reads\\n        let nPairs := calldataload(witnessOffset)\\n        witnessOffset := add(witnessOffset, 32)\\n\\n        // append data to the end of the transaction\\n        let memPtr := add(inOffset, inSize)\\n        mstore(memPtr, blockTimestamp)\\n        memPtr := add(memPtr, 32)\\n\\n        for { let i := 0 } lt(i, nPairs) { i := add(i, 1) } {\\n          let key := calldataload(witnessOffset)\\n          witnessOffset := add(witnessOffset, 32)\\n          let nProofElements := calldataload(witnessOffset)\\n          witnessOffset := add(witnessOffset, 32)\\n\\n          // verify key, value\\n          let valid, inTree, value := verifyUniform(witnessOffset, nProofElements, key, rootHash)\\n          if iszero(valid) {\\n            // invalid proof\\n            revert(0, 0)\\n          }\\n          witnessOffset := add(witnessOffset, mul(nProofElements, 32))\\n\\n          // only store the value if the key is in the tree.\\n          // Consumers must take care of not introducing key collisions for L1 storage vs L2 storage.\\n          if inTree {\\n            sstore(key, value)\\n          }\\n\\n          // store key (for calldata)\\n          mstore(memPtr, key)\\n          memPtr := add(memPtr, 32)\\n        }\\n        // write number of storage (read access) keys\\n        mstore(memPtr, nPairs)\\n        memPtr := add(memPtr, 32)\\n\\n        {\\n          // make a copy\\n          // the current position of witnessOffset is the starting point in verifyPostTransition\\n          let witnessOffsetCopy := witnessOffset\\n          // storage writes (access)\\n          nPairs := calldataload(witnessOffsetCopy)\\n          if gt(nPairs, 0xff) {\\n            // too large\\n            revert(0, 0)\\n          }\\n          witnessOffsetCopy := add(witnessOffsetCopy, 32)\\n\\n          let bitmap := 0\\n          for { let i := 0 } lt(i, nPairs) { i := add(i, 1) } {\\n            bitmap := or(bitmap, shl(i, 1))\\n\\n            let key := calldataload(witnessOffsetCopy)\\n            witnessOffsetCopy := add(witnessOffsetCopy, 32)\\n            let nProofElements := calldataload(witnessOffsetCopy)\\n            witnessOffsetCopy := add(witnessOffsetCopy, 32)\\n            witnessOffsetCopy := add(witnessOffsetCopy, mul(nProofElements, 32))\\n\\n            // only remember the keys, the proof will be verified later\\n            mstore(memPtr, key)\\n            memPtr := add(memPtr, 32)\\n          }\\n          // write number of storage (writes) keys\\n          mstore(memPtr, nPairs)\\n          memPtr := add(memPtr, 32)\\n\\n          // SPECIAL_STORAGE_SLOT - store storage write access bitmap\\n          sstore(0xabcd, bitmap)\\n          // help the compiler :ouch\\n          pop(bitmap)\\n        }\\n\\n        // now, start calling the function\\n        // if returndatasize > 0\\n        //   success; even if reverted\\n        // else\\n        //   - out of gas?\\n        //   - implementation error?\\n        //   - something else?\\n        //\\n        // We can't proof if a transaction failed because of an implementation error or because it is out of gas\\n        // Well, technically we can enforce gas limits but div by zero, jump to invalid() or something else will\\n        // lead to a runtime exception and burn all gas (meh -.-).\\n        //\\n        // In this case:\\n        // - Revert\\n        // The core logic has to deal with it.\\n        // For example, the block could be skipped and marked as invalid partly or as a whole\\n        // if it's not possible to proceed the challenge for some reason.\\n        // Otherwise, without this functionality, it would be possible that we spin here forever.\\n        //\\n\\n        // calldataload = address of challenge contract\\n        let success := delegatecall(gas(), calldataload(36), inOffset, sub(memPtr, inOffset), 0, 0)\\n        success := or(success, returndatasize())\\n        switch success\\n        case 0 {\\n          revert(0, 0)\\n        }\\n        default {\\n          // verifyPostTransition, verification after executing a transaction\\n\\n          // SPECIAL_STORAGE_SLOT - all bits must be unset\\n          if sload(0xabcd) {\\n            revert(0, 0)\\n          }\\n\\n          // validate & clean write accesss\\n          nPairs := calldataload(witnessOffset)\\n          witnessOffset := add(witnessOffset, 32)\\n\\n          for { let i := 0 } lt(i, nPairs) { i := add(i, 1) } {\\n            let key := calldataload(witnessOffset)\\n            witnessOffset := add(witnessOffset, 32)\\n            let nProofElements := calldataload(witnessOffset)\\n            witnessOffset := add(witnessOffset, 32)\\n\\n            // verify proof\\n            let valid, inTree, value := verifyUniform(witnessOffset, nProofElements, key, rootHash)\\n            if iszero(valid) {\\n              // invalid proof\\n              revert(0, 0)\\n            }\\n            // calculate new state root\\n            rootHash := updateTree(witnessOffset, nProofElements, key, sload(key))\\n            // reset storage slot\\n            sstore(key, 0)\\n            witnessOffset := add(witnessOffset, mul(nProofElements, 32))\\n          }\\n        }\\n        // end of verifyTransition\\n      }\\n\\n      // load the stateRoot from storage\\n      let rootHash := sload(0xd27f023774f5a743d69cfc4b80b1efe4be7912753677c20f45ee5464160b7d24)\\n      // calldatasize - blockSize\\n      let startOfBlock := sub(calldatasize(), calldataload(68))\\n      // load timestamp for this block\\n      let blockTimestamp := calldataload(add(startOfBlock, 64))\\n      // start of arbitrary witness data in calldata\\n      let witnessOffset := 132\\n      // last block offset (byte offset for block)\\n      let challengeOffset := calldataload(4)\\n      if iszero(challengeOffset) {\\n        // add size of block header\\n        challengeOffset := add(challengeOffset, 96)\\n      }\\n      // fix the calldata offset\\n      challengeOffset := add(challengeOffset, startOfBlock)\\n\\n      // load blockType\\n      // 1 = Deposit\\n      // 2 = arbitrary submitted data - signed transactions\\n      // 3 = custom message\\n      switch calldataload(add(startOfBlock, 32))\\n      case 1 {\\n        // function onDeposit (address owner, address token, uint256 value, uint256 tokenType) external\\n        mstore(128, 0x62731ff1)\\n        // ^ assuming this will not be overwritten in the loop below\\n\\n        // iterate over the block data\\n        let rounds := calldataload(100)\\n        for { } lt(challengeOffset, calldatasize()) { } {\\n          if iszero(rounds) {\\n            break\\n          }\\n          rounds := sub(rounds, 1)\\n\\n          // owner\\n          mstore(160, shr(96, calldataload(challengeOffset)))\\n          challengeOffset := add(challengeOffset, 20)\\n\\n          // token\\n          mstore(192, shr(96, calldataload(challengeOffset)))\\n          challengeOffset := add(challengeOffset, 20)\\n\\n          // value\\n          mstore(224, calldataload(challengeOffset))\\n          challengeOffset := add(challengeOffset, 32)\\n\\n          // tokenType\\n          mstore(256, calldataload(challengeOffset))\\n          challengeOffset := add(challengeOffset, 32)\\n\\n          // setup & call\\n          witnessOffset, rootHash := verifyTransition(blockTimestamp, rootHash, witnessOffset, 156, 132)\\n        }\\n      }\\n      case 2 {\\n        // iterate over the block data and keep track of the number of rounds to do\\n        let rounds := calldataload(100)\\n        for { } lt(challengeOffset, calldatasize()) { } {\\n          if iszero(rounds) {\\n            break\\n          }\\n          rounds := sub(rounds, 1)\\n\\n          let success, inOffset, inSize\\n          challengeOffset, success, inOffset, inSize := _parseTransaction(challengeOffset)\\n\\n          switch success\\n          case 0 {\\n            // invalid tx, ignore and skip\\n            success := 1\\n            // skip [ 32 bytes readWitnessLength, 32 bytes writeWitnessLength ]\\n            witnessOffset := add(witnessOffset, 64)\\n          }\\n          default {\\n            // setup & call\\n            witnessOffset, rootHash := verifyTransition(blockTimestamp, rootHash, witnessOffset, inOffset, inSize)\\n          }\\n        }\\n        // end of blockType = 2\\n      }\\n      case 3 {\\n        // onCustomBlockBeacon(bytes)\\n        mstore(128, 0xa891fba3)\\n        // abi head size\\n        mstore(160, 32)\\n        // whole block data, minus header\\n        let sizeOfData := sub(calldatasize(), challengeOffset)\\n        // store length\\n        mstore(192, sizeOfData)\\n        // copy data into memory\\n        calldatacopy(224, challengeOffset, sizeOfData)\\n\\n        // setup & call\\n        witnessOffset, rootHash := verifyTransition(blockTimestamp, rootHash, witnessOffset, 156, add(sizeOfData, 68))\\n        // done\\n        challengeOffset := calldatasize()\\n      }\\n      default {\\n        // nothing todo - finish this block\\n        challengeOffset := calldatasize()\\n      }\\n\\n      // save stateRoot\\n      sstore(0xd27f023774f5a743d69cfc4b80b1efe4be7912753677c20f45ee5464160b7d24, rootHash)\\n\\n      // return challengeOffset.\\n      // if >= blockSize , then this block is done\\n      mstore(0, sub(challengeOffset, startOfBlock))\\n      return(0, 32)\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/HabitatVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport './HabitatBase.sol';\\n\\n/// @notice A Vault holds assets with a custom (contract) condition to unlock them.\\n// Audit-1: ok\\ncontract HabitatVault is HabitatBase {\\n  event VaultCreated(bytes32 indexed communityId, address indexed condition, address indexed vaultAddress);\\n\\n  /// @dev Lookup condition (module) for `vault`, reverts on error.\\n  /// @return address if the contract on L1\\n  function _getVaultCondition (address vault) internal returns (address) {\\n    address contractAddress = address(HabitatBase._getStorage(_VAULT_CONDITION_KEY(vault)));\\n    uint256 codeHash = HabitatBase._getStorage(_MODULE_HASH_KEY(contractAddress));\\n\\n    require(contractAddress != address(0) && codeHash != 0, 'GVC1');\\n\\n    return contractAddress;\\n  }\\n\\n  /// @dev Creates a Habitat Vault for a Community.\\n  function onCreateVault (\\n    address msgSender,\\n    uint256 nonce,\\n    bytes32 communityId,\\n    address condition,\\n    bytes calldata metadata\\n  ) external {\\n    HabitatBase._commonChecks();\\n    HabitatBase._checkUpdateNonce(msgSender, nonce);\\n\\n    // checks if the condition exists\\n    require(HabitatBase._getStorage(_MODULE_HASH_KEY(condition)) != 0, 'OCV1');\\n    // checks if the community exists\\n    require(tokenOfCommunity(communityId) != address(0), 'OCV2');\\n    // generate deterministic address\\n    address vaultAddress = address(bytes20(HabitatBase._calculateSeed(msgSender, nonce)));\\n    // checks if the vault already exists\\n    require(HabitatBase.communityOfVault(vaultAddress) == bytes32(0), 'OCV3');\\n    // save\\n    HabitatBase._setStorage(_COMMUNITY_OF_VAULT_KEY(vaultAddress), communityId);\\n    HabitatBase._setStorage(_VAULT_CONDITION_KEY(vaultAddress), condition);\\n\\n    if (_shouldEmitEvents()) {\\n      emit VaultCreated(communityId, condition, vaultAddress);\\n      emit MetadataUpdated(uint256(vaultAddress), metadata);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/HabitatVoting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport './HabitatBase.sol';\\nimport './HabitatWallet.sol';\\nimport './HabitatVault.sol';\\nimport './IModule.sol';\\n\\n/// @notice Voting Functionality.\\n// Audit-1: ok\\ncontract HabitatVoting is HabitatBase, HabitatWallet, HabitatVault {\\n  event ProposalCreated(address indexed vault, bytes32 indexed proposalId, uint256 startDate);\\n  event VotedOnProposal(address indexed account, bytes32 indexed proposalId, uint8 signalStrength, uint256 shares);\\n  event DelegateeVotedOnProposal(address indexed account, bytes32 indexed proposalId, uint8 signalStrength, uint256 shares);\\n  event ProposalProcessed(bytes32 indexed proposalId, uint256 indexed votingStatus);\\n\\n  /// @dev Validates if `timestamp` is inside a valid range.\\n  /// `timestamp` should not be under/over now +- `_PROPOSAL_DELAY`.\\n  function _validateTimestamp (uint256 timestamp) internal virtual {\\n    uint256 time = _getTime();\\n    uint256 delay = _PROPOSAL_DELAY();\\n\\n    if (time > timestamp) {\\n      require(time - timestamp < delay, 'VT1');\\n    } else {\\n      require(timestamp - time < delay, 'VT2');\\n    }\\n  }\\n\\n  /// @dev Parses and executes `internalActions`.\\n  /// TODO Only `TRANSFER_TOKEN` is currently implemented\\n  function _executeInternalActions (address vaultAddress, bytes calldata internalActions) internal {\\n    // Types, related to actionable proposal items on L2.\\n    // L1 has no such items and only provides an array of [<address><calldata] for on-chain execution.\\n    // enum L2ProposalActions {\\n    //  RESERVED,\\n    //  TRANSFER_TOKEN,\\n    //  UPDATE_COMMUNITY_METADATA\\n    // }\\n\\n    // assuming that `length` can never be > 2^16\\n    uint256 ptr;\\n    uint256 end;\\n    assembly {\\n      let len := internalActions.length\\n      ptr := internalActions.offset\\n      end := add(ptr, len)\\n    }\\n\\n    while (ptr < end) {\\n      uint256 actionType;\\n\\n      assembly {\\n        actionType := byte(0, calldataload(ptr))\\n        ptr := add(ptr, 1)\\n      }\\n\\n      // TRANSFER_TOKEN\\n      if (actionType == 1) {\\n        address token;\\n        address receiver;\\n        uint256 value;\\n        assembly {\\n          token := shr(96, calldataload(ptr))\\n          ptr := add(ptr, 20)\\n          receiver := shr(96, calldataload(ptr))\\n          ptr := add(ptr, 20)\\n          value := calldataload(ptr)\\n          ptr := add(ptr, 32)\\n        }\\n        _transferToken(token, vaultAddress, receiver, value);\\n        continue;\\n      }\\n\\n      revert('EIA1');\\n    }\\n\\n    // revert if out of bounds read(s) happened\\n    if (ptr > end) {\\n      revert('EIA2');\\n    }\\n  }\\n\\n  /// @dev Invokes IModule.onCreateProposal(...) on `vault`\\n  function _callCreateProposal (\\n    address vault,\\n    address proposer,\\n    uint256 startDate,\\n    bytes memory internalActions,\\n    bytes memory externalActions\\n  ) internal {\\n    bytes32 communityId = HabitatBase.communityOfVault(vault);\\n    address governanceToken = HabitatBase.tokenOfCommunity(communityId);\\n\\n    // encoding all all the statistics\\n    bytes memory _calldata = abi.encodeWithSelector(\\n      0x5e79ee45,\\n      communityId,\\n      HabitatBase.getTotalMemberCount(communityId),\\n      getTotalValueLocked(governanceToken),\\n      proposer,\\n      getBalance(governanceToken, proposer),\\n      startDate,\\n      internalActions,\\n      externalActions\\n    );\\n    uint256 MAX_GAS = 90000;\\n    address vaultCondition = _getVaultCondition(vault);\\n    assembly {\\n      // check if we have enough gas to spend (relevant in challenges)\\n      if lt(gas(), MAX_GAS) {\\n        // do a silent revert to signal the challenge routine that this is an exception\\n        revert(0, 0)\\n      }\\n      let success := staticcall(MAX_GAS, vaultCondition, add(_calldata, 32), mload(_calldata), 0, 0)\\n      // revert and forward any returndata\\n      if iszero(success) {\\n        // propagate any revert messages\\n        returndatacopy(0, 0, returndatasize())\\n        revert(0, returndatasize())\\n      }\\n    }\\n  }\\n\\n  /// @notice Creates a proposal belonging to `vault`.\\n  /// @param startDate Should be within a reasonable range. See `_PROPOSAL_DELAY`\\n  /// @param internalActions includes L2 specific actions if this proposal passes.\\n  /// @param externalActions includes L1 specific actions if this proposal passes. (execution permit)\\n  function onCreateProposal (\\n    address msgSender,\\n    uint256 nonce,\\n    uint256 startDate,\\n    address vault,\\n    bytes memory internalActions,\\n    bytes memory externalActions,\\n    bytes calldata metadata\\n  ) external {\\n    HabitatBase._commonChecks();\\n    HabitatBase._checkUpdateNonce(msgSender, nonce);\\n    _validateTimestamp(startDate);\\n\\n    // compute a deterministic id\\n    bytes32 proposalId = HabitatBase._calculateSeed(msgSender, nonce);\\n    // revert if such a proposal already exists (generally not possible due to msgSender, nonce)\\n    require(HabitatBase._getStorage(_PROPOSAL_VAULT_KEY(proposalId)) == 0, 'OCP1');\\n\\n    // The vault module receives a callback at creation\\n    // Reverts if the module does not allow the creation of this proposal or if `vault` is invalid.\\n    _callCreateProposal(vault, msgSender, startDate, internalActions, externalActions);\\n\\n    // store\\n    HabitatBase._setStorage(_PROPOSAL_START_DATE_KEY(proposalId), startDate);\\n    HabitatBase._setStorage(_PROPOSAL_VAULT_KEY(proposalId), vault);\\n    HabitatBase._setStorage(_PROPOSAL_HASH_INTERNAL_KEY(proposalId), keccak256(internalActions));\\n    HabitatBase._setStorage(_PROPOSAL_HASH_EXTERNAL_KEY(proposalId), keccak256(externalActions));\\n    // update member count\\n    HabitatBase._maybeUpdateMemberCount(proposalId, msgSender);\\n\\n    if (_shouldEmitEvents()) {\\n      emit ProposalCreated(vault, proposalId, startDate);\\n      // internal event for submission deadlines\\n      _emitTransactionDeadline(startDate + _PROPOSAL_DELAY());\\n    }\\n  }\\n\\n  /// @dev Helper function to retrieve the governance token given `proposalId`.\\n  /// Reverts if `proposalId` is invalid.\\n  function _getTokenOfProposal (bytes32 proposalId) internal returns (address) {\\n    address vault = address(HabitatBase._getStorage(_PROPOSAL_VAULT_KEY(proposalId)));\\n    bytes32 communityId = HabitatBase.communityOfVault(vault);\\n    address token = HabitatBase.tokenOfCommunity(communityId);\\n    // only check token here, assuming any invalid proposalId / vault will end with having a zero address\\n    require(token != address(0), 'GTOP1');\\n\\n    return token;\\n  }\\n\\n  /// @dev Helper function for validating and applying votes\\n  function _votingRoutine (\\n    address account,\\n    uint256 previousVote,\\n    uint256 previousSignal,\\n    uint256 signalStrength,\\n    uint256 shares,\\n    bytes32 proposalId,\\n    bool delegated\\n  ) internal {\\n    // requires that the signal is in a specific range...\\n    require(signalStrength < 101, 'VR1');\\n\\n    if (previousVote == 0 && shares != 0) {\\n      // a new vote - increment vote count\\n      HabitatBase._incrementStorage(HabitatBase._VOTING_COUNT_KEY(proposalId), 1);\\n    }\\n    if (shares == 0) {\\n      // removes a vote - decrement vote count\\n      require(signalStrength == 0 && previousVote != 0, 'VR2');\\n      HabitatBase._decrementStorage(HabitatBase._VOTING_COUNT_KEY(proposalId), 1);\\n    }\\n\\n    HabitatBase._maybeUpdateMemberCount(proposalId, account);\\n\\n    if (delegated) {\\n      HabitatBase._setStorage(_DELEGATED_VOTING_SHARES_KEY(proposalId, account), shares);\\n      HabitatBase._setStorage(_DELEGATED_VOTING_SIGNAL_KEY(proposalId, account), signalStrength);\\n    } else {\\n      HabitatBase._setStorage(_VOTING_SHARES_KEY(proposalId, account), shares);\\n      HabitatBase._setStorage(_VOTING_SIGNAL_KEY(proposalId, account), signalStrength);\\n    }\\n\\n    // update total share count and staking amount\\n    if (previousVote != shares) {\\n      address token = _getTokenOfProposal(proposalId);\\n      uint256 activeStakeKey =\\n        delegated ? _DELEGATED_VOTING_ACTIVE_STAKE_KEY(token, account) : _VOTING_ACTIVE_STAKE_KEY(token, account);\\n\\n      HabitatBase._setStorageDelta(activeStakeKey, previousVote, shares);\\n      HabitatBase._setStorageDelta(_VOTING_TOTAL_SHARE_KEY(proposalId), previousVote, shares);\\n    }\\n\\n    // update total signal\\n    if (previousSignal != signalStrength) {\\n      HabitatBase._setStorageDelta(_VOTING_TOTAL_SIGNAL_KEY(proposalId), previousSignal, signalStrength);\\n    }\\n  }\\n\\n  /// @dev State transition routine for `VoteOnProposal`.\\n  /// Note: Votes can be changed/removed anytime.\\n  function onVoteOnProposal (\\n    address msgSender,\\n    uint256 nonce,\\n    bytes32 proposalId,\\n    uint256 shares,\\n    address delegatee,\\n    uint8 signalStrength\\n  ) external {\\n    HabitatBase._commonChecks();\\n    HabitatBase._checkUpdateNonce(msgSender, nonce);\\n\\n    address token = _getTokenOfProposal(proposalId);\\n\\n    if (delegatee == address(0)) {\\n      // voter account\\n      address account = msgSender;\\n      uint256 previousVote = HabitatBase._getStorage(_VOTING_SHARES_KEY(proposalId, account));\\n      // check for discrepancy between balance and stake\\n      uint256 stakableBalance = getUnlockedBalance(token, account) + previousVote;\\n      require(stakableBalance >= shares, 'OVOP1');\\n      uint256 previousSignal = HabitatBase._getStorage(_VOTING_SIGNAL_KEY(proposalId, account));\\n\\n      _votingRoutine(account, previousVote, previousSignal, signalStrength, shares, proposalId, false);\\n\\n      if (_shouldEmitEvents()) {\\n        emit VotedOnProposal(account, proposalId, signalStrength, shares);\\n      }\\n    } else {\\n      uint256 previousVote = HabitatBase._getStorage(_DELEGATED_VOTING_SHARES_KEY(proposalId, delegatee));\\n      uint256 previousSignal = HabitatBase._getStorage(_DELEGATED_VOTING_SIGNAL_KEY(proposalId, delegatee));\\n      uint256 maxAmount = HabitatBase._getStorage(_DELEGATED_ACCOUNT_TOTAL_AMOUNT_KEY(delegatee, token));\\n      uint256 currentlyStaked = HabitatBase._getStorage(_DELEGATED_VOTING_ACTIVE_STAKE_KEY(token, delegatee));\\n      // should not happen but anyway...\\n      require(maxAmount >= currentlyStaked, 'ODVOP1');\\n\\n      if (msgSender == delegatee) {\\n        // the amount that is left\\n        uint256 freeAmount = maxAmount - (currentlyStaked - previousVote);\\n        // check for discrepancy between balance and stake\\n        require(freeAmount >= shares, 'ODVOP2');\\n      } else {\\n        // a user may only remove shares if there is no other choice\\n        // we have to account for\\n        // - msgSender balance\\n        // - msgSender personal stakes\\n        // - msgSender delegated balance\\n        // - delegatee staked balance\\n\\n        // new shares must be less than old shares, otherwise what are we doing here?\\n        require(shares < previousVote, 'ODVOP3');\\n\\n        if (shares != 0) {\\n          // the user is not allowed to change the signalStrength if not removing the vote\\n          require(signalStrength == previousSignal, 'ODVOP4');\\n        }\\n\\n        uint256 unusedBalance = maxAmount - currentlyStaked;\\n        uint256 maxRemovable = HabitatBase._getStorage(_DELEGATED_ACCOUNT_ALLOWANCE_KEY(msgSender, delegatee, token));\\n        // only allow changing the stake if the user has no other choice\\n        require(maxRemovable > unusedBalance, 'ODVOP5');\\n        // the max. removable amount is the total delegated amount - the unused balance of delegatee\\n        maxRemovable = maxRemovable - unusedBalance;\\n        if (maxRemovable > previousVote) {\\n          // clamp\\n          maxRemovable = previousVote;\\n        }\\n\\n        uint256 sharesToRemove = previousVote - shares;\\n        require(maxRemovable >= sharesToRemove, 'ODVOP6');\\n      }\\n\\n      _votingRoutine(delegatee, previousVote, previousSignal, signalStrength, shares, proposalId, true);\\n\\n      if (_shouldEmitEvents()) {\\n        emit DelegateeVotedOnProposal(delegatee, proposalId, signalStrength, shares);\\n      }\\n    }\\n  }\\n\\n  /// @dev Invokes IModule.onProcessProposal(...) on `vault`\\n  /// Assumes that `vault` was already validated.\\n  function _callProcessProposal (\\n    bytes32 proposalId,\\n    address vault\\n  ) internal returns (uint256 votingStatus, uint256 secondsTillClose, uint256 quorumPercent)\\n  {\\n    uint256 secondsPassed;\\n    {\\n      uint256 dateNow = _getTime();\\n      uint256 proposalStartDate = HabitatBase._getStorage(_PROPOSAL_START_DATE_KEY(proposalId));\\n\\n      if (dateNow > proposalStartDate) {\\n        secondsPassed = dateNow - proposalStartDate;\\n      }\\n    }\\n\\n    bytes32 communityId = HabitatBase.communityOfVault(vault);\\n    // call vault with all the statistics\\n    bytes memory _calldata = abi.encodeWithSelector(\\n      0xf8d8ade6,\\n      proposalId,\\n      communityId,\\n      HabitatBase.getTotalMemberCount(communityId),\\n      HabitatBase._getStorage(_VOTING_COUNT_KEY(proposalId)),\\n      HabitatBase.getTotalVotingShares(proposalId),\\n      HabitatBase._getStorage(_VOTING_TOTAL_SIGNAL_KEY(proposalId)),\\n      getTotalValueLocked(HabitatBase.tokenOfCommunity(communityId)),\\n      secondsPassed\\n    );\\n    uint256 MAX_GAS = 90000;\\n    address vaultCondition = _getVaultCondition(vault);\\n    assembly {\\n      let ptr := mload(64)\\n      // clear memory\\n      calldatacopy(ptr, calldatasize(), 96)\\n      // check if we have enough gas to spend (relevant in challenges)\\n      if lt(gas(), MAX_GAS) {\\n        // do a silent revert to signal the challenge routine that this is an exception\\n        revert(0, 0)\\n      }\\n      // call\\n      let success := staticcall(MAX_GAS, vaultCondition, add(_calldata, 32), mload(_calldata), ptr, 96)\\n      if success {\\n        votingStatus := mload(ptr)\\n        ptr := add(ptr, 32)\\n        secondsTillClose := mload(ptr)\\n        ptr := add(ptr, 32)\\n        quorumPercent := mload(ptr)\\n      }\\n    }\\n  }\\n\\n  /// @notice Updates the state of a proposal.\\n  /// @dev Only emits a event if the status changes to CLOSED or PASSED\\n  function onProcessProposal (\\n    address msgSender,\\n    uint256 nonce,\\n    bytes32 proposalId,\\n    bytes calldata internalActions,\\n    bytes calldata externalActions\\n  ) external returns (uint256 votingStatus, uint256 secondsTillClose, uint256 quorumPercent) {\\n    HabitatBase._commonChecks();\\n    HabitatBase._checkUpdateNonce(msgSender, nonce);\\n\\n    {\\n      uint256 previousVotingStatus = HabitatBase.getProposalStatus(proposalId);\\n      require(previousVotingStatus < uint256(IModule.VotingStatus.CLOSED), 'CLOSED');\\n    }\\n\\n    // this will revert in _getVaultCondition if the proposal doesn't exist or `vault` is invalid\\n    address vault = address(HabitatBase._getStorage(_PROPOSAL_VAULT_KEY(proposalId)));\\n\\n    (votingStatus, secondsTillClose, quorumPercent) = _callProcessProposal(proposalId, vault);\\n\\n    // finalize if the new status is CLOSED or PASSED\\n    if (votingStatus > uint256(IModule.VotingStatus.OPEN)) {\\n      // save voting status\\n      HabitatBase._setStorage(_PROPOSAL_STATUS_KEY(proposalId), votingStatus);\\n\\n      // PASSED\\n      if (votingStatus == uint256(IModule.VotingStatus.PASSED)) {\\n        // verify the internal actions and execute\\n        bytes32 hash = keccak256(internalActions);\\n        require(HabitatBase._getStorage(_PROPOSAL_HASH_INTERNAL_KEY(proposalId)) == uint256(hash), 'IHASH');\\n        _executeInternalActions(vault, internalActions);\\n\\n        // verify external actions and store a permit\\n        hash = keccak256(externalActions);\\n        require(HabitatBase._getStorage(_PROPOSAL_HASH_EXTERNAL_KEY(proposalId)) == uint256(hash), 'EHASH');\\n        if (externalActions.length != 0) {\\n          HabitatBase._setExecutionPermit(vault, proposalId, hash);\\n        }\\n      }\\n\\n      if (_shouldEmitEvents()) {\\n        emit ProposalProcessed(proposalId, votingStatus);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/HabitatWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport './HabitatBase.sol';\\n\\n/// @notice Functionality for user wallets and token accounting.\\n// Audit-1: ok\\ncontract HabitatWallet is HabitatBase {\\n  event TokenTransfer(address indexed token, address indexed from, address indexed to, uint256 value, uint256 epoch);\\n  event DelegatedAmount(address indexed account, address indexed delegatee, address indexed token, uint256 value);\\n\\n  /// @notice Returns the (free) balance (amount of `token`) for `account`.\\n  /// Free = balance of `token` for `account` - activeVotingStake & delegated stake for `account`.\\n  /// Supports ERC-20 and ERC-721 and takes staked balances into account.\\n  function getUnlockedBalance (address token, address account) public returns (uint256 ret) {\\n    uint256 locked =\\n      HabitatBase.getActiveVotingStake(token, account) +\\n      HabitatBase._getStorage(_DELEGATED_ACCOUNT_TOTAL_ALLOWANCE_KEY(account, token));\\n    ret = getBalance(token, account);\\n    // something must be wrong if this happens\\n    require(locked <= ret, 'GUB1');\\n    ret = ret - locked;\\n  }\\n\\n  /// @dev State transition when a user transfers a token.\\n  /// Updates Total Value Locked and does accounting needed for staking rewards.\\n  function _transferToken (address token, address from, address to, uint256 value) internal virtual {\\n    bool isERC721 = _getTokenType(token) > 1;\\n\\n    // update from\\n    if (isERC721) {\\n      require(HabitatBase.getErc721Owner(token, value) == from, 'OWNER');\\n      HabitatBase._setStorage(_ERC721_KEY(token, value), to);\\n    }\\n\\n    uint256 currentEpoch = getCurrentEpoch();\\n    // both ERC-20 & ERC-721\\n    uint256 balanceDelta = isERC721 ? 1 : value;\\n    // update `from`\\n    if (from != address(0)) {\\n      // not a deposit - check stake\\n      {\\n        uint256 availableAmount = getUnlockedBalance(token, from);\\n        require(availableAmount >= balanceDelta, 'LOCK');\\n      }\\n\\n      // can revert\\n      HabitatBase._decrementStorage(_ERC20_KEY(token, from), balanceDelta);\\n\\n      // update historic total user balance\\n      HabitatBase._setStorageInfinityIfZero(\\n        _STAKING_EPOCH_TUB_KEY(currentEpoch, token, from),\\n        getBalance(token, from)\\n      );\\n    }\\n    // update `to`\\n    {\\n      if (to == address(0)) {\\n        // exit\\n        if (isERC721) {\\n          _setERC721Exit(token, from, value);\\n        } else {\\n          _incrementExit(token, from, value);\\n        }\\n      } else {\\n        // can throw\\n        HabitatBase._incrementStorage(_ERC20_KEY(token, to), balanceDelta);\\n\\n        // update historic total user balance\\n        HabitatBase._setStorageInfinityIfZero(\\n          _STAKING_EPOCH_TUB_KEY(currentEpoch, token, to),\\n          getBalance(token, to)\\n        );\\n      }\\n    }\\n\\n    // TVL\\n    {\\n      // from == address(0) = deposit\\n      // to == address(0) = exit\\n      // classify deposits and exits in the same way as vaults (exempt from TVL)\\n      bool fromVault = from == address(0) || HabitatBase._getStorage(_VAULT_CONDITION_KEY(from)) != 0;\\n      bool toVault = to == address(0) || HabitatBase._getStorage(_VAULT_CONDITION_KEY(to)) != 0;\\n\\n      // considerations\\n      // - transfer from user to user, do nothing\\n      // - transfer from vault to vault, do nothing\\n      // - deposits (from = 0), increase if !toVault\\n      // - exits (to == 0), decrease if !fromVault\\n      // - transfer from user to vault, decrease\\n      // - transfer from vault to user, increase\\n      if (toVault && !fromVault) {\\n        HabitatBase._decrementStorage(_TOKEN_TVL_KEY(token), balanceDelta);\\n      }\\n      if (fromVault && !toVault) {\\n        HabitatBase._incrementStorage(_TOKEN_TVL_KEY(token), balanceDelta);\\n      }\\n    }\\n\\n    {\\n      // update tvl for epoch - accounting for staking rewards\\n      HabitatBase._setStorage(\\n        _STAKING_EPOCH_TVL_KEY(currentEpoch, token),\\n        HabitatBase._getStorage(_TOKEN_TVL_KEY(token))\\n      );\\n    }\\n\\n    if (_shouldEmitEvents()) {\\n      emit TokenTransfer(token, from, to, value, currentEpoch);\\n      // transactions should be submitted before the next epoch\\n      uint256 nextEpochTimestamp = EPOCH_GENESIS() + (SECONDS_PER_EPOCH() * (currentEpoch + 1));\\n      _emitTransactionDeadline(nextEpochTimestamp);\\n    }\\n  }\\n\\n  /// @dev State transition when a user deposits a token.\\n  function onDeposit (address owner, address token, uint256 value, uint256 tokenType) external {\\n    HabitatBase._commonChecks();\\n    _setTokenType(token, tokenType);\\n    _transferToken(token, address(0), owner, value);\\n  }\\n\\n  /// @dev State transition when a user transfers a token.\\n  function onTransferToken (address msgSender, uint256 nonce, address token, address to, uint256 value) external {\\n    HabitatBase._commonChecks();\\n    HabitatBase._checkUpdateNonce(msgSender, nonce);\\n    _transferToken(token, msgSender, to, value);\\n  }\\n\\n  /// @dev State transition when a user sets a delegate.\\n  function onDelegateAmount (address msgSender, uint256 nonce, address delegatee, address token, uint256 newAllowance) external {\\n    HabitatBase._commonChecks();\\n    HabitatBase._checkUpdateNonce(msgSender, nonce);\\n\\n    // can not delegate to self\\n    require(msgSender != delegatee, 'ODA1');\\n\\n    uint256 oldAllowance = HabitatBase._getStorage(_DELEGATED_ACCOUNT_ALLOWANCE_KEY(msgSender, delegatee, token));\\n\\n    // track the difference\\n    if (oldAllowance < newAllowance) {\\n      uint256 delta = newAllowance - oldAllowance;\\n      uint256 availableBalance = getUnlockedBalance(token, msgSender);\\n      // check\\n      require(availableBalance >= delta, 'ODA2');\\n\\n      // increment new total delegated balance for delegatee\\n      HabitatBase._incrementStorage(_DELEGATED_ACCOUNT_TOTAL_AMOUNT_KEY(delegatee, token), delta);\\n      // increment new total delegated amount for msgSender\\n      HabitatBase._incrementStorage(_DELEGATED_ACCOUNT_TOTAL_ALLOWANCE_KEY(msgSender, token), delta);\\n    } else {\\n      uint256 delta = oldAllowance - newAllowance;\\n      uint256 currentlyStaked = HabitatBase._getStorage(_DELEGATED_VOTING_ACTIVE_STAKE_KEY(token, delegatee));\\n      uint256 total = HabitatBase._getStorage(_DELEGATED_ACCOUNT_TOTAL_AMOUNT_KEY(delegatee, token));\\n      uint256 freeAmount = total - currentlyStaked;\\n      // check that delta is less or equal to the available balance\\n      require(delta <= freeAmount, 'ODA3');\\n\\n      // decrement new total delegated balance for delegatee\\n      HabitatBase._decrementStorage(_DELEGATED_ACCOUNT_TOTAL_AMOUNT_KEY(delegatee, token), delta);\\n      // decrement new total delegated amount for msgSender\\n      HabitatBase._decrementStorage(_DELEGATED_ACCOUNT_TOTAL_ALLOWANCE_KEY(msgSender, token), delta);\\n    }\\n\\n    // save the new allowance\\n    HabitatBase._setStorage(_DELEGATED_ACCOUNT_ALLOWANCE_KEY(msgSender, delegatee, token), newAllowance);\\n\\n    if (_shouldEmitEvents()) {\\n      emit DelegatedAmount(msgSender, delegatee, token, newAllowance);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/IModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\n// Audit-1: ok\\ninterface IModule {\\n  enum VotingStatus {\\n    UNKNOWN,\\n    OPEN,\\n    CLOSED,\\n    PASSED\\n  }\\n\\n  function onCreateProposal (\\n    bytes32 communityId,\\n    uint256 totalMemberCount,\\n    uint256 totalValueLocked,\\n    address proposer,\\n    uint256 proposerBalance,\\n    uint256 startDate,\\n    bytes calldata internalActions,\\n    bytes calldata externalActions\\n  ) external view;\\n\\n  function onProcessProposal (\\n    bytes32 proposalId,\\n    bytes32 communityId,\\n    uint256 totalMemberCount,\\n    uint256 totalVoteCount,\\n    uint256 totalVotingShares,\\n    uint256 totalVotingSignal,\\n    uint256 totalValueLocked,\\n    uint256 secondsPassed\\n  ) external view returns (VotingStatus, uint256 secondsTillClose, uint256 quorumPercent);\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/UpgradableRollup.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport '@NutBerry/NutBerry/src/tsm/contracts/NutBerryEvents.sol';\\n\\n// Audit-1: ok\\ncontract UpgradableRollup is NutBerryEvents {\\n  /// @notice Returns the address who is in charge of changing the rollup implementation.\\n  /// This contract should be managed by a `ExecutionProxy` that in turn verifies governance decisions\\n  /// from the rollup.\\n  /// The rollup will be managed by a multisig in the beginning until moving to community governance.\\n  /// It should be noted that there should be a emergency contract on L1 that can be used to recover from bad upgrades\\n  /// in case the rollup is malfunctioning itself.\\n  function ROLLUP_MANAGER () public virtual view returns (address) {\\n  }\\n\\n  /// @notice Upgrades the implementation.\\n  function upgradeRollup (address newImplementation) external {\\n    require(msg.sender == ROLLUP_MANAGER());\\n    assembly {\\n      // uint256(-1) - stores the contract address to delegate calls to (RollupProxy)\\n      sstore(not(returndatasize()), newImplementation)\\n    }\\n    emit NutBerryEvents.RollupUpgrade(newImplementation);\\n  }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[],\"name\":\"BlockBeacon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"shortString\",\"type\":\"bytes32\"}],\"name\":\"ClaimUsername\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedStakingReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"governanceToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"communityId\",\"type\":\"bytes32\"}],\"name\":\"CommunityCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CustomBlockBeacon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DelegatedAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"signalStrength\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"DelegateeVotedOnProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"topic\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"MetadataUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"ModuleRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NewSolution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"votingStatus\",\"type\":\"uint256\"}],\"name\":\"ProposalProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"RollupUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"TokenTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"communityId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"condition\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"}],\"name\":\"VaultCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"signalStrength\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"VotedOnProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EPOCH_GENESIS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INSPECTION_PERIOD\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INSPECTION_PERIOD_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BLOCK_SIZE\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLLUP_MANAGER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_PER_EPOCH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKING_POOL_FEE_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"}],\"name\":\"blockMeta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ret\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"canFinalizeBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challenge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"communityOfVault\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bitmask\",\"type\":\"uint256\"}],\"name\":\"dispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"}],\"name\":\"executionPermit\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"ret\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizeSolution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizedHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ret\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getActiveDelegatedVotingStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getActiveVotingStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getERC20Exit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getERC721Exit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"getErc721Owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getHistoricTub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getHistoricTvl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getLastClaimedEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"a\",\"type\":\"bytes32\"}],\"name\":\"getProposalStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"communityId\",\"type\":\"bytes32\"}],\"name\":\"getTotalMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTotalValueLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"}],\"name\":\"getTotalVotingShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUnlockedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ret\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onChallenge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sinceEpoch\",\"type\":\"uint256\"}],\"name\":\"onClaimStakingReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"shortString\",\"type\":\"bytes32\"}],\"name\":\"onClaimUsername\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"governanceToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"onCreateCommunity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"internalActions\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"externalActions\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"onCreateProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"communityId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"condition\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"onCreateVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onCustomBlockBeacon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newAllowance\",\"type\":\"uint256\"}],\"name\":\"onDelegateAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"name\":\"onDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"onFinalizeSolution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onModifyRollupStorage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"internalActions\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"externalActions\",\"type\":\"bytes\"}],\"name\":\"onProcessProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"votingStatus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondsTillClose\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quorumPercent\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"onTransferToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onTributeForOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"signalStrength\",\"type\":\"uint8\"}],\"name\":\"onVoteOnProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ret\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"codeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"registerModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"submitBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"submitSolution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"a\",\"type\":\"bytes32\"}],\"name\":\"tokenOfCommunity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"txNonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeRollup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"HabitatV1","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"256","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"none"}]}