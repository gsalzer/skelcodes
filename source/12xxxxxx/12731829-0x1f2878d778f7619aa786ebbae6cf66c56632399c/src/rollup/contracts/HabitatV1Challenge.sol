
// SPDX-License-Identifier: Unlicense
pragma solidity >=0.7.6;

/// @dev Autogenerated file. Do not edit manually.
contract HabitatV1Challenge {
  /// @dev Challenge the solution or just verify the next pending block directly.
  /// calldata layout:
  /// < 4 bytes function sig >
  /// < 32 bytes challenge offset >
  /// < 32 bytes address of challenge handler - contract (self) >
  /// < 32 bytes size of block >
  /// < 32 bytes number of challenge rounds >
  /// < arbitrary witness data >
  /// < data of block >
  function onChallenge () external returns (uint256) {
    // all power the core protocol
    require(msg.sender == address(this));

    assembly {
      
function _parseTransaction (o) -> offset, success, inOffset, inSize {
  // zero memory
  calldatacopy(0, calldatasize(), msize())
  offset := o

  let firstByte := byte(0, calldataload(offset))
  let v := add(and(firstByte, 1), 27)
  let primaryType := shr(1, firstByte)
  offset := add(offset, 1)
  let r := calldataload(offset)
  offset := add(offset, 32)
  let s := calldataload(offset)
  offset := add(offset, 32)

  switch primaryType

// start of TransferToken
// typeHash: 0xf121759935d81b9588e8434983e70b870ab10987a39b454ac893e1480f028e46
// function: onTransferToken(address,uint256,address,address,uint256)
case 0 {
  let headSize := 160
  let typeLen := 0
  let txPtr := 384
  let endOfSlot := add(txPtr, 160)

  txPtr := 416
  // typeHash of TransferToken
  mstore(0, 0xf121759935d81b9588e8434983e70b870ab10987a39b454ac893e1480f028e46)
  // uint256 TransferToken.nonce
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(32, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // address TransferToken.token
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(64, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // address TransferToken.to
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(96, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // uint256 TransferToken.value
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(128, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // typeHash
  let structHash := keccak256(0, 160)
  // prefix
  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)
  // DOMAIN struct hash
  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)
  // transactionStructHash
  mstore(34, structHash)
  mstore(0, keccak256(0, 66))
  mstore(32, v)
  mstore(64, r)
  mstore(96, s)
  success := staticcall(gas(), 1, 0, 128, 128, 32)
  // functionSig
  mstore(352, 0x11d4aec1)
  mstore(384, mload(128))

  inOffset := 380
  inSize := sub(endOfSlot, 380)
}
// end of TransferToken

// start of ClaimUsername
// typeHash: 0x8b505a1c00897e3b1949f8e114b8f1a4cdeed6d6a26926931f57f885f33f6cfa
// function: onClaimUsername(address,uint256,bytes32)
case 1 {
  let headSize := 96
  let typeLen := 0
  let txPtr := 256
  let endOfSlot := add(txPtr, 96)

  txPtr := 288
  // typeHash of ClaimUsername
  mstore(0, 0x8b505a1c00897e3b1949f8e114b8f1a4cdeed6d6a26926931f57f885f33f6cfa)
  // uint256 ClaimUsername.nonce
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(32, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // bytes32 ClaimUsername.shortString
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(64, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // typeHash
  let structHash := keccak256(0, 96)
  // prefix
  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)
  // DOMAIN struct hash
  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)
  // transactionStructHash
  mstore(34, structHash)
  mstore(0, keccak256(0, 66))
  mstore(32, v)
  mstore(64, r)
  mstore(96, s)
  success := staticcall(gas(), 1, 0, 128, 128, 32)
  // functionSig
  mstore(224, 0x0827bab8)
  mstore(256, mload(128))

  inOffset := 252
  inSize := sub(endOfSlot, 252)
}
// end of ClaimUsername

// start of CreateCommunity
// typeHash: 0x4b8e81699d7dc349aa2eca5d6740c23aff4244d26288627f4ca3be7d236f5127
// function: onCreateCommunity(address,uint256,address,bytes)
case 2 {
  let headSize := 128
  let typeLen := 0
  let txPtr := 320
  let endOfSlot := add(txPtr, 128)

  txPtr := 352
  // typeHash of CreateCommunity
  mstore(0, 0x4b8e81699d7dc349aa2eca5d6740c23aff4244d26288627f4ca3be7d236f5127)
  // uint256 CreateCommunity.nonce
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(32, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // address CreateCommunity.governanceToken
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(64, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // bytes CreateCommunity.metadata
  typeLen := shr(240, calldataload(offset))
  offset := add(offset, 2)
  mstore(txPtr, headSize)
  headSize := add(headSize, add( 32, mul( 32, div( add(typeLen, 31), 32 ) ) ))
  txPtr := add(txPtr, 32)
  mstore(endOfSlot, typeLen)
  endOfSlot := add(endOfSlot, 32)
  calldatacopy(endOfSlot, offset, typeLen)
  mstore(96, keccak256(endOfSlot, typeLen))
  endOfSlot := add(endOfSlot, mul( 32, div( add(typeLen, 31), 32 ) ))
  offset := add(offset, typeLen)

  // typeHash
  let structHash := keccak256(0, 128)
  // prefix
  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)
  // DOMAIN struct hash
  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)
  // transactionStructHash
  mstore(34, structHash)
  mstore(0, keccak256(0, 66))
  mstore(32, v)
  mstore(64, r)
  mstore(96, s)
  success := staticcall(gas(), 1, 0, 128, 128, 32)
  // functionSig
  mstore(288, 0x5b292e29)
  mstore(320, mload(128))

  inOffset := 316
  inSize := sub(endOfSlot, 316)
}
// end of CreateCommunity

// start of CreateVault
// typeHash: 0xd039a4c4cd9e9890710392eef9936bf5d690ec47246e5d6f4693c764d6b62635
// function: onCreateVault(address,uint256,bytes32,address,bytes)
case 3 {
  let headSize := 160
  let typeLen := 0
  let txPtr := 384
  let endOfSlot := add(txPtr, 160)

  txPtr := 416
  // typeHash of CreateVault
  mstore(0, 0xd039a4c4cd9e9890710392eef9936bf5d690ec47246e5d6f4693c764d6b62635)
  // uint256 CreateVault.nonce
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(32, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // bytes32 CreateVault.communityId
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(64, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // address CreateVault.condition
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(96, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // bytes CreateVault.metadata
  typeLen := shr(240, calldataload(offset))
  offset := add(offset, 2)
  mstore(txPtr, headSize)
  headSize := add(headSize, add( 32, mul( 32, div( add(typeLen, 31), 32 ) ) ))
  txPtr := add(txPtr, 32)
  mstore(endOfSlot, typeLen)
  endOfSlot := add(endOfSlot, 32)
  calldatacopy(endOfSlot, offset, typeLen)
  mstore(128, keccak256(endOfSlot, typeLen))
  endOfSlot := add(endOfSlot, mul( 32, div( add(typeLen, 31), 32 ) ))
  offset := add(offset, typeLen)

  // typeHash
  let structHash := keccak256(0, 160)
  // prefix
  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)
  // DOMAIN struct hash
  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)
  // transactionStructHash
  mstore(34, structHash)
  mstore(0, keccak256(0, 66))
  mstore(32, v)
  mstore(64, r)
  mstore(96, s)
  success := staticcall(gas(), 1, 0, 128, 128, 32)
  // functionSig
  mstore(352, 0x9617e0c5)
  mstore(384, mload(128))

  inOffset := 380
  inSize := sub(endOfSlot, 380)
}
// end of CreateVault

// start of CreateProposal
// typeHash: 0x4d8a9f544d08772d597445c015580bcc93a38fd87bcf6be01f7b542ccdb97814
// function: onCreateProposal(address,uint256,uint256,address,bytes,bytes,bytes)
case 4 {
  let headSize := 224
  let typeLen := 0
  let txPtr := 512
  let endOfSlot := add(txPtr, 224)

  txPtr := 544
  // typeHash of CreateProposal
  mstore(0, 0x4d8a9f544d08772d597445c015580bcc93a38fd87bcf6be01f7b542ccdb97814)
  // uint256 CreateProposal.nonce
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(32, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // uint256 CreateProposal.startDate
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(64, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // address CreateProposal.vault
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(96, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // bytes CreateProposal.internalActions
  typeLen := shr(240, calldataload(offset))
  offset := add(offset, 2)
  mstore(txPtr, headSize)
  headSize := add(headSize, add( 32, mul( 32, div( add(typeLen, 31), 32 ) ) ))
  txPtr := add(txPtr, 32)
  mstore(endOfSlot, typeLen)
  endOfSlot := add(endOfSlot, 32)
  calldatacopy(endOfSlot, offset, typeLen)
  mstore(128, keccak256(endOfSlot, typeLen))
  endOfSlot := add(endOfSlot, mul( 32, div( add(typeLen, 31), 32 ) ))
  offset := add(offset, typeLen)

  // bytes CreateProposal.externalActions
  typeLen := shr(240, calldataload(offset))
  offset := add(offset, 2)
  mstore(txPtr, headSize)
  headSize := add(headSize, add( 32, mul( 32, div( add(typeLen, 31), 32 ) ) ))
  txPtr := add(txPtr, 32)
  mstore(endOfSlot, typeLen)
  endOfSlot := add(endOfSlot, 32)
  calldatacopy(endOfSlot, offset, typeLen)
  mstore(160, keccak256(endOfSlot, typeLen))
  endOfSlot := add(endOfSlot, mul( 32, div( add(typeLen, 31), 32 ) ))
  offset := add(offset, typeLen)

  // bytes CreateProposal.metadata
  typeLen := shr(240, calldataload(offset))
  offset := add(offset, 2)
  mstore(txPtr, headSize)
  headSize := add(headSize, add( 32, mul( 32, div( add(typeLen, 31), 32 ) ) ))
  txPtr := add(txPtr, 32)
  mstore(endOfSlot, typeLen)
  endOfSlot := add(endOfSlot, 32)
  calldatacopy(endOfSlot, offset, typeLen)
  mstore(192, keccak256(endOfSlot, typeLen))
  endOfSlot := add(endOfSlot, mul( 32, div( add(typeLen, 31), 32 ) ))
  offset := add(offset, typeLen)

  // typeHash
  let structHash := keccak256(0, 224)
  // prefix
  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)
  // DOMAIN struct hash
  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)
  // transactionStructHash
  mstore(34, structHash)
  mstore(0, keccak256(0, 66))
  mstore(32, v)
  mstore(64, r)
  mstore(96, s)
  success := staticcall(gas(), 1, 0, 128, 128, 32)
  // functionSig
  mstore(480, 0x9cc39bbe)
  mstore(512, mload(128))

  inOffset := 508
  inSize := sub(endOfSlot, 508)
}
// end of CreateProposal

// start of VoteOnProposal
// typeHash: 0xeedce560579f8160e8bbb71ad5823fb1098eee0d1116be92232ee87ab1bce294
// function: onVoteOnProposal(address,uint256,bytes32,uint256,address,uint8)
case 5 {
  let headSize := 192
  let typeLen := 0
  let txPtr := 448
  let endOfSlot := add(txPtr, 192)

  txPtr := 480
  // typeHash of VoteOnProposal
  mstore(0, 0xeedce560579f8160e8bbb71ad5823fb1098eee0d1116be92232ee87ab1bce294)
  // uint256 VoteOnProposal.nonce
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(32, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // bytes32 VoteOnProposal.proposalId
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(64, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // uint256 VoteOnProposal.shares
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(96, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // address VoteOnProposal.delegatedFor
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(128, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // uint8 VoteOnProposal.signalStrength
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(160, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // typeHash
  let structHash := keccak256(0, 192)
  // prefix
  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)
  // DOMAIN struct hash
  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)
  // transactionStructHash
  mstore(34, structHash)
  mstore(0, keccak256(0, 66))
  mstore(32, v)
  mstore(64, r)
  mstore(96, s)
  success := staticcall(gas(), 1, 0, 128, 128, 32)
  // functionSig
  mstore(416, 0xd87eafef)
  mstore(448, mload(128))

  inOffset := 444
  inSize := sub(endOfSlot, 444)
}
// end of VoteOnProposal

// start of ProcessProposal
// typeHash: 0xb4da110edbcfa262bdf7849c0e02e03ed15ced328922eca5a0bc1c547451b4af
// function: onProcessProposal(address,uint256,bytes32,bytes,bytes)
case 6 {
  let headSize := 160
  let typeLen := 0
  let txPtr := 384
  let endOfSlot := add(txPtr, 160)

  txPtr := 416
  // typeHash of ProcessProposal
  mstore(0, 0xb4da110edbcfa262bdf7849c0e02e03ed15ced328922eca5a0bc1c547451b4af)
  // uint256 ProcessProposal.nonce
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(32, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // bytes32 ProcessProposal.proposalId
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(64, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // bytes ProcessProposal.internalActions
  typeLen := shr(240, calldataload(offset))
  offset := add(offset, 2)
  mstore(txPtr, headSize)
  headSize := add(headSize, add( 32, mul( 32, div( add(typeLen, 31), 32 ) ) ))
  txPtr := add(txPtr, 32)
  mstore(endOfSlot, typeLen)
  endOfSlot := add(endOfSlot, 32)
  calldatacopy(endOfSlot, offset, typeLen)
  mstore(96, keccak256(endOfSlot, typeLen))
  endOfSlot := add(endOfSlot, mul( 32, div( add(typeLen, 31), 32 ) ))
  offset := add(offset, typeLen)

  // bytes ProcessProposal.externalActions
  typeLen := shr(240, calldataload(offset))
  offset := add(offset, 2)
  mstore(txPtr, headSize)
  headSize := add(headSize, add( 32, mul( 32, div( add(typeLen, 31), 32 ) ) ))
  txPtr := add(txPtr, 32)
  mstore(endOfSlot, typeLen)
  endOfSlot := add(endOfSlot, 32)
  calldatacopy(endOfSlot, offset, typeLen)
  mstore(128, keccak256(endOfSlot, typeLen))
  endOfSlot := add(endOfSlot, mul( 32, div( add(typeLen, 31), 32 ) ))
  offset := add(offset, typeLen)

  // typeHash
  let structHash := keccak256(0, 160)
  // prefix
  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)
  // DOMAIN struct hash
  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)
  // transactionStructHash
  mstore(34, structHash)
  mstore(0, keccak256(0, 66))
  mstore(32, v)
  mstore(64, r)
  mstore(96, s)
  success := staticcall(gas(), 1, 0, 128, 128, 32)
  // functionSig
  mstore(352, 0x36b54032)
  mstore(384, mload(128))

  inOffset := 380
  inSize := sub(endOfSlot, 380)
}
// end of ProcessProposal

// start of TributeForOperator
// typeHash: 0x1d7f2e50c4a73ada77cc1796f78f259a43e44d6d99adaf69a6628ef42c527df7
// function: onTributeForOperator(address,uint256,address,address,uint256)
case 7 {
  let headSize := 160
  let typeLen := 0
  let txPtr := 384
  let endOfSlot := add(txPtr, 160)

  txPtr := 416
  // typeHash of TributeForOperator
  mstore(0, 0x1d7f2e50c4a73ada77cc1796f78f259a43e44d6d99adaf69a6628ef42c527df7)
  // uint256 TributeForOperator.nonce
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(32, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // address TributeForOperator.operator
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(64, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // address TributeForOperator.token
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(96, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // uint256 TributeForOperator.amount
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(128, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // typeHash
  let structHash := keccak256(0, 160)
  // prefix
  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)
  // DOMAIN struct hash
  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)
  // transactionStructHash
  mstore(34, structHash)
  mstore(0, keccak256(0, 66))
  mstore(32, v)
  mstore(64, r)
  mstore(96, s)
  success := staticcall(gas(), 1, 0, 128, 128, 32)
  // functionSig
  mstore(352, 0x24fa29ea)
  mstore(384, mload(128))

  inOffset := 380
  inSize := sub(endOfSlot, 380)
}
// end of TributeForOperator

// start of DelegateAmount
// typeHash: 0x7595f378ac19fee39d9d6a79a8240d32afae43c5943289e491976d85c9e9ad54
// function: onDelegateAmount(address,uint256,address,address,uint256)
case 8 {
  let headSize := 160
  let typeLen := 0
  let txPtr := 384
  let endOfSlot := add(txPtr, 160)

  txPtr := 416
  // typeHash of DelegateAmount
  mstore(0, 0x7595f378ac19fee39d9d6a79a8240d32afae43c5943289e491976d85c9e9ad54)
  // uint256 DelegateAmount.nonce
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(32, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // address DelegateAmount.delegatee
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(64, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // address DelegateAmount.token
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(96, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // uint256 DelegateAmount.value
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(128, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // typeHash
  let structHash := keccak256(0, 160)
  // prefix
  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)
  // DOMAIN struct hash
  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)
  // transactionStructHash
  mstore(34, structHash)
  mstore(0, keccak256(0, 66))
  mstore(32, v)
  mstore(64, r)
  mstore(96, s)
  success := staticcall(gas(), 1, 0, 128, 128, 32)
  // functionSig
  mstore(352, 0x1b5e17db)
  mstore(384, mload(128))

  inOffset := 380
  inSize := sub(endOfSlot, 380)
}
// end of DelegateAmount

// start of ClaimStakingReward
// typeHash: 0x56d7b9415a7ab01a4e256d5e8a8a100fcf839c82096289e6a835115c704aee67
// function: onClaimStakingReward(address,uint256,address,uint256)
case 9 {
  let headSize := 128
  let typeLen := 0
  let txPtr := 320
  let endOfSlot := add(txPtr, 128)

  txPtr := 352
  // typeHash of ClaimStakingReward
  mstore(0, 0x56d7b9415a7ab01a4e256d5e8a8a100fcf839c82096289e6a835115c704aee67)
  // uint256 ClaimStakingReward.nonce
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(32, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // address ClaimStakingReward.token
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(64, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // uint256 ClaimStakingReward.sinceEpoch
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(96, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // typeHash
  let structHash := keccak256(0, 128)
  // prefix
  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)
  // DOMAIN struct hash
  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)
  // transactionStructHash
  mstore(34, structHash)
  mstore(0, keccak256(0, 66))
  mstore(32, v)
  mstore(64, r)
  mstore(96, s)
  success := staticcall(gas(), 1, 0, 128, 128, 32)
  // functionSig
  mstore(288, 0x8e7700c0)
  mstore(320, mload(128))

  inOffset := 316
  inSize := sub(endOfSlot, 316)
}
// end of ClaimStakingReward

// start of ModifyRollupStorage
// typeHash: 0x31a8f1b3e855fde3871d440618da073d0504133dc34db1896de6774ed15abb70
// function: onModifyRollupStorage(address,uint256,bytes)
case 10 {
  let headSize := 96
  let typeLen := 0
  let txPtr := 256
  let endOfSlot := add(txPtr, 96)

  txPtr := 288
  // typeHash of ModifyRollupStorage
  mstore(0, 0x31a8f1b3e855fde3871d440618da073d0504133dc34db1896de6774ed15abb70)
  // uint256 ModifyRollupStorage.nonce
  typeLen := byte(0, calldataload(offset))
  offset := add(offset, 1)
  calldatacopy(add(txPtr, sub(32, typeLen)), offset, typeLen)
  mstore(32, mload(txPtr))
  offset := add(offset, typeLen)
  txPtr := add(txPtr, 32)

  // bytes ModifyRollupStorage.data
  typeLen := shr(240, calldataload(offset))
  offset := add(offset, 2)
  mstore(txPtr, headSize)
  headSize := add(headSize, add( 32, mul( 32, div( add(typeLen, 31), 32 ) ) ))
  txPtr := add(txPtr, 32)
  mstore(endOfSlot, typeLen)
  endOfSlot := add(endOfSlot, 32)
  calldatacopy(endOfSlot, offset, typeLen)
  mstore(64, keccak256(endOfSlot, typeLen))
  endOfSlot := add(endOfSlot, mul( 32, div( add(typeLen, 31), 32 ) ))
  offset := add(offset, typeLen)

  // typeHash
  let structHash := keccak256(0, 96)
  // prefix
  mstore(0, 0x1901000000000000000000000000000000000000000000000000000000000000)
  // DOMAIN struct hash
  mstore(2, 0x912f8ef55fd9ffcdd4f9ea4d504976c90bd78c1f95a3ca09ddc4c95af6622f46)
  // transactionStructHash
  mstore(34, structHash)
  mstore(0, keccak256(0, 66))
  mstore(32, v)
  mstore(64, r)
  mstore(96, s)
  success := staticcall(gas(), 1, 0, 128, 128, 32)
  // functionSig
  mstore(224, 0x10ea8892)
  mstore(256, mload(128))

  inOffset := 252
  inSize := sub(endOfSlot, 252)
}
// end of ModifyRollupStorage
default { }
}


      
// verifies a proof
function verifyUniform (proofOffset, len, key, root) -> valid, inTree, value {
  let _k := 0
  let _v := 0
  let ret := 0

  if len {
    // if # of proof elements are greather than 0 and less than 2, revert
    if lt(len, 2) {
      revert(0, 0)
    }

    _k := calldataload(proofOffset)
    proofOffset := add(proofOffset, 32)
    _v := calldataload(proofOffset)
    proofOffset := add(proofOffset, 32)

    if _v {
      // leafHash
      // left, right = key, value
      inTree := eq(key, _k)
      
  // hash leaf
  mstore(0, _k)
  mstore(32, _v)
  mstore(64, 1)
  ret := keccak256(0, 96)
  // end of hash leaf

    }
  }

  // it is not used anyway if it underflows (see loop)
  let depth := sub(len, 2)

  for { let i := 2 } lt(i, len) { i:= add(i, 1) } {
    depth := sub(depth, 1)
    let bitmask := shl(depth, 1)
    let goLeft := and(key, bitmask)
    let next := calldataload(proofOffset)
    proofOffset := add(proofOffset, 32)

    
  // hash branch
  switch goLeft
  case 0 {
    mstore(0, next)
    mstore(32, ret)
  }
  default {
    mstore(0, ret)
    mstore(32, next)
  }
  ret := keccak256(0, 64)
  // end of hash branch

  }

  valid := eq(ret, root)
  if iszero(valid) {
    inTree := 0
  }
  if inTree {
    value := _v
  }
}

      
function updateTree (ptr, len, key, newValue) -> ret {
  let _k := 0
  let _v := 0

  if newValue {
    // insert or update
    // hash leaf
    
  // hash leaf
  mstore(0, key)
  mstore(32, newValue)
  mstore(64, 1)
  ret := keccak256(0, 96)
  // end of hash leaf

  }

  if len {
    if lt(len, 2) {
      // invalid proof
      revert(0, 0)
    }

    _k := calldataload(ptr)
    ptr := add(ptr, 32)
    _v := calldataload(ptr)
    ptr := add(ptr, 32)

    // _v != 0 && key != _k
    if and(iszero(iszero(_v)), iszero(eq(key, _k))) {
      // Update and create a new branch.
      // Compare against the key of the other leaf and loop until diverge.
      // Then create a new branch(es).

      // minus [_k, _v]
      let depth := sub(len, 2)
      for {} true {} {
        let bitmask := shl(depth, 1)
        let goLeft := and(key, bitmask)
        let otherLeft := and(_k, bitmask)

        if eq(goLeft, otherLeft) {
          // key and _k are still on the same path, go deeper
          depth := add(depth, 1)
          continue
        }

        let other
        
  // hash leaf
  mstore(0, _k)
  mstore(32, _v)
  mstore(64, 1)
  other := keccak256(0, 96)
  // end of hash leaf

        
  // hash branch
  switch goLeft
  case 0 {
    mstore(0, other)
    mstore(32, ret)
  }
  default {
    mstore(0, ret)
    mstore(32, other)
  }
  ret := keccak256(0, 64)
  // end of hash branch

        break
      }

      // now, walk back and hash each new branch with a zero-neighbor.
      let odepth := sub(len, 2)
      for {} iszero(eq(depth, odepth)) {} {
        depth := sub(depth, 1)
        let bitmask := shl(depth, 1)
        let goLeft := and(key, bitmask)

        
  // hash branch
  switch goLeft
  case 0 {
    mstore(0, 0)
    mstore(32, ret)
  }
  default {
    mstore(0, ret)
    mstore(32, 0)
  }
  ret := keccak256(0, 64)
  // end of hash branch

      }
    }
  }

  // use the supplied proofs and walk back to the root (TM)
  // minus [_k, _v]
  let depth := sub(len, 2)
  for { let i := 2 } lt(i, len) {} {
    depth := sub(depth, 1)

    let bitmask := shl(depth, 1)
    let goLeft := and(key, bitmask)
    let next := calldataload(ptr)
    ptr := add(ptr, 32)
    i := add(i, 1)

    
  // hash branch
  switch goLeft
  case 0 {
    mstore(0, next)
    mstore(32, ret)
  }
  default {
    mstore(0, ret)
    mstore(32, next)
  }
  ret := keccak256(0, 64)
  // end of hash branch

  }

  // ret contains new root
}


      // pre & post transaction verification
      function verifyTransition (blockTimestamp, __rootHash, __witnessOffset, inOffset, inSize) -> witnessOffset, rootHash {
        // setup return value
        rootHash := __rootHash
        witnessOffset := __witnessOffset

        // number of storage reads
        let nPairs := calldataload(witnessOffset)
        witnessOffset := add(witnessOffset, 32)

        // append data to the end of the transaction
        let memPtr := add(inOffset, inSize)
        mstore(memPtr, blockTimestamp)
        memPtr := add(memPtr, 32)

        for { let i := 0 } lt(i, nPairs) { i := add(i, 1) } {
          let key := calldataload(witnessOffset)
          witnessOffset := add(witnessOffset, 32)
          let nProofElements := calldataload(witnessOffset)
          witnessOffset := add(witnessOffset, 32)

          // verify key, value
          let valid, inTree, value := verifyUniform(witnessOffset, nProofElements, key, rootHash)
          if iszero(valid) {
            // invalid proof
            revert(0, 0)
          }
          witnessOffset := add(witnessOffset, mul(nProofElements, 32))

          // only store the value if the key is in the tree.
          // Consumers must take care of not introducing key collisions for L1 storage vs L2 storage.
          if inTree {
            sstore(key, value)
          }

          // store key (for calldata)
          mstore(memPtr, key)
          memPtr := add(memPtr, 32)
        }
        // write number of storage (read access) keys
        mstore(memPtr, nPairs)
        memPtr := add(memPtr, 32)

        {
          // make a copy
          // the current position of witnessOffset is the starting point in verifyPostTransition
          let witnessOffsetCopy := witnessOffset
          // storage writes (access)
          nPairs := calldataload(witnessOffsetCopy)
          if gt(nPairs, 0xff) {
            // too large
            revert(0, 0)
          }
          witnessOffsetCopy := add(witnessOffsetCopy, 32)

          let bitmap := 0
          for { let i := 0 } lt(i, nPairs) { i := add(i, 1) } {
            bitmap := or(bitmap, shl(i, 1))

            let key := calldataload(witnessOffsetCopy)
            witnessOffsetCopy := add(witnessOffsetCopy, 32)
            let nProofElements := calldataload(witnessOffsetCopy)
            witnessOffsetCopy := add(witnessOffsetCopy, 32)
            witnessOffsetCopy := add(witnessOffsetCopy, mul(nProofElements, 32))

            // only remember the keys, the proof will be verified later
            mstore(memPtr, key)
            memPtr := add(memPtr, 32)
          }
          // write number of storage (writes) keys
          mstore(memPtr, nPairs)
          memPtr := add(memPtr, 32)

          // SPECIAL_STORAGE_SLOT - store storage write access bitmap
          sstore(0xabcd, bitmap)
          // help the compiler :ouch
          pop(bitmap)
        }

        // now, start calling the function
        // if returndatasize > 0
        //   success; even if reverted
        // else
        //   - out of gas?
        //   - implementation error?
        //   - something else?
        //
        // We can't proof if a transaction failed because of an implementation error or because it is out of gas
        // Well, technically we can enforce gas limits but div by zero, jump to invalid() or something else will
        // lead to a runtime exception and burn all gas (meh -.-).
        //
        // In this case:
        // - Revert
        // The core logic has to deal with it.
        // For example, the block could be skipped and marked as invalid partly or as a whole
        // if it's not possible to proceed the challenge for some reason.
        // Otherwise, without this functionality, it would be possible that we spin here forever.
        //

        // calldataload = address of challenge contract
        let success := delegatecall(gas(), calldataload(36), inOffset, sub(memPtr, inOffset), 0, 0)
        success := or(success, returndatasize())
        switch success
        case 0 {
          revert(0, 0)
        }
        default {
          // verifyPostTransition, verification after executing a transaction

          // SPECIAL_STORAGE_SLOT - all bits must be unset
          if sload(0xabcd) {
            revert(0, 0)
          }

          // validate & clean write accesss
          nPairs := calldataload(witnessOffset)
          witnessOffset := add(witnessOffset, 32)

          for { let i := 0 } lt(i, nPairs) { i := add(i, 1) } {
            let key := calldataload(witnessOffset)
            witnessOffset := add(witnessOffset, 32)
            let nProofElements := calldataload(witnessOffset)
            witnessOffset := add(witnessOffset, 32)

            // verify proof
            let valid, inTree, value := verifyUniform(witnessOffset, nProofElements, key, rootHash)
            if iszero(valid) {
              // invalid proof
              revert(0, 0)
            }
            // calculate new state root
            rootHash := updateTree(witnessOffset, nProofElements, key, sload(key))
            // reset storage slot
            sstore(key, 0)
            witnessOffset := add(witnessOffset, mul(nProofElements, 32))
          }
        }
        // end of verifyTransition
      }

      // load the stateRoot from storage
      let rootHash := sload(0xd27f023774f5a743d69cfc4b80b1efe4be7912753677c20f45ee5464160b7d24)
      // calldatasize - blockSize
      let startOfBlock := sub(calldatasize(), calldataload(68))
      // load timestamp for this block
      let blockTimestamp := calldataload(add(startOfBlock, 64))
      // start of arbitrary witness data in calldata
      let witnessOffset := 132
      // last block offset (byte offset for block)
      let challengeOffset := calldataload(4)
      if iszero(challengeOffset) {
        // add size of block header
        challengeOffset := add(challengeOffset, 96)
      }
      // fix the calldata offset
      challengeOffset := add(challengeOffset, startOfBlock)

      // load blockType
      // 1 = Deposit
      // 2 = arbitrary submitted data - signed transactions
      // 3 = custom message
      switch calldataload(add(startOfBlock, 32))
      case 1 {
        // function onDeposit (address owner, address token, uint256 value, uint256 tokenType) external
        mstore(128, 0x62731ff1)
        // ^ assuming this will not be overwritten in the loop below

        // iterate over the block data
        let rounds := calldataload(100)
        for { } lt(challengeOffset, calldatasize()) { } {
          if iszero(rounds) {
            break
          }
          rounds := sub(rounds, 1)

          // owner
          mstore(160, shr(96, calldataload(challengeOffset)))
          challengeOffset := add(challengeOffset, 20)

          // token
          mstore(192, shr(96, calldataload(challengeOffset)))
          challengeOffset := add(challengeOffset, 20)

          // value
          mstore(224, calldataload(challengeOffset))
          challengeOffset := add(challengeOffset, 32)

          // tokenType
          mstore(256, calldataload(challengeOffset))
          challengeOffset := add(challengeOffset, 32)

          // setup & call
          witnessOffset, rootHash := verifyTransition(blockTimestamp, rootHash, witnessOffset, 156, 132)
        }
      }
      case 2 {
        // iterate over the block data and keep track of the number of rounds to do
        let rounds := calldataload(100)
        for { } lt(challengeOffset, calldatasize()) { } {
          if iszero(rounds) {
            break
          }
          rounds := sub(rounds, 1)

          let success, inOffset, inSize
          challengeOffset, success, inOffset, inSize := _parseTransaction(challengeOffset)

          switch success
          case 0 {
            // invalid tx, ignore and skip
            success := 1
            // skip [ 32 bytes readWitnessLength, 32 bytes writeWitnessLength ]
            witnessOffset := add(witnessOffset, 64)
          }
          default {
            // setup & call
            witnessOffset, rootHash := verifyTransition(blockTimestamp, rootHash, witnessOffset, inOffset, inSize)
          }
        }
        // end of blockType = 2
      }
      case 3 {
        // onCustomBlockBeacon(bytes)
        mstore(128, 0xa891fba3)
        // abi head size
        mstore(160, 32)
        // whole block data, minus header
        let sizeOfData := sub(calldatasize(), challengeOffset)
        // store length
        mstore(192, sizeOfData)
        // copy data into memory
        calldatacopy(224, challengeOffset, sizeOfData)

        // setup & call
        witnessOffset, rootHash := verifyTransition(blockTimestamp, rootHash, witnessOffset, 156, add(sizeOfData, 68))
        // done
        challengeOffset := calldatasize()
      }
      default {
        // nothing todo - finish this block
        challengeOffset := calldatasize()
      }

      // save stateRoot
      sstore(0xd27f023774f5a743d69cfc4b80b1efe4be7912753677c20f45ee5464160b7d24, rootHash)

      // return challengeOffset.
      // if >= blockSize , then this block is done
      mstore(0, sub(challengeOffset, startOfBlock))
      return(0, 32)
    }
  }
}

