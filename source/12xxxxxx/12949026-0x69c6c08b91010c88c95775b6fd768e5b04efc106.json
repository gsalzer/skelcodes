{"status":"1","message":"OK","result":[{"SourceCode":"/// GebLenderFirstResortRewardsVested.sol\r\n\r\n// Copyright (C) 2021 Reflexer Labs, INC\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.6.7;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nabstract contract TokenLike {\r\n    function decimals() virtual public view returns (uint8);\r\n    function totalSupply() virtual public view returns (uint256);\r\n    function balanceOf(address) virtual public view returns (uint256);\r\n    function mint(address, uint) virtual public;\r\n    function burn(address, uint) virtual public;\r\n    function approve(address, uint256) virtual external returns (bool);\r\n    function transfer(address, uint256) virtual external returns (bool);\r\n    function transferFrom(address,address,uint256) virtual external returns (bool);\r\n}\r\nabstract contract AuctionHouseLike {\r\n    function activeStakedTokenAuctions() virtual public view returns (uint256);\r\n    function startAuction(uint256, uint256) virtual external returns (uint256);\r\n}\r\nabstract contract AccountingEngineLike {\r\n    function debtAuctionBidSize() virtual public view returns (uint256);\r\n    function unqueuedUnauctionedDebt() virtual public view returns (uint256);\r\n}\r\nabstract contract SAFEEngineLike {\r\n    function coinBalance(address) virtual public view returns (uint256);\r\n    function debtBalance(address) virtual public view returns (uint256);\r\n}\r\nabstract contract RewardDripperLike {\r\n    function dripReward() virtual external;\r\n    function dripReward(address) virtual external;\r\n    function rewardPerBlock() virtual external view returns (uint256);\r\n    function rewardToken() virtual external view returns (TokenLike);\r\n}\r\nabstract contract StakingRewardsEscrowLike {\r\n    function escrowRewards(address, uint256) virtual external;\r\n}\r\n\r\n// Stores tokens, owned by GebLenderFirstResortRewardsVested\r\ncontract TokenPool {\r\n    TokenLike public token;\r\n    address   public owner;\r\n\r\n    constructor(address token_) public {\r\n        token = TokenLike(token_);\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // @notice Transfers tokens from the pool (callable by owner only)\r\n    function transfer(address to, uint256 wad) public {\r\n        require(msg.sender == owner, \"unauthorized\");\r\n        require(token.transfer(to, wad), \"TokenPool/failed-transfer\");\r\n    }\r\n\r\n    // @notice Returns token balance of the pool\r\n    function balance() public view returns (uint256) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n}\r\n\r\ncontract GebLenderFirstResortRewardsVested is ReentrancyGuard {\r\n    // --- Auth ---\r\n    mapping (address => uint) public authorizedAccounts;\r\n    /**\r\n     * @notice Add auth to an account\r\n     * @param account Account to add auth to\r\n     */\r\n    function addAuthorization(address account) virtual external isAuthorized {\r\n        authorizedAccounts[account] = 1;\r\n        emit AddAuthorization(account);\r\n    }\r\n    /**\r\n     * @notice Remove auth from an account\r\n     * @param account Account to remove auth from\r\n     */\r\n    function removeAuthorization(address account) virtual external isAuthorized {\r\n        authorizedAccounts[account] = 0;\r\n        emit RemoveAuthorization(account);\r\n    }\r\n    /**\r\n    * @notice Checks whether msg.sender can call an authed function\r\n    **/\r\n    modifier isAuthorized {\r\n        require(authorizedAccounts[msg.sender] == 1, \"GebLenderFirstResortRewardsVested/account-not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Structs ---\r\n    struct ExitRequest {\r\n        // Exit window deadline\r\n        uint256 deadline;\r\n        // Ancestor amount queued for exit\r\n        uint256 lockedAmount;\r\n    }\r\n\r\n    // --- Variables ---\r\n    // Flag that allows/blocks joining\r\n    bool      public canJoin;\r\n    // Flag that indicates whether canPrintProtocolTokens can ignore auctioning ancestor tokens\r\n    bool      public bypassAuctions;\r\n    // Whether the contract allows forced exits or not\r\n    bool      public forcedExit;\r\n    // Last block when a reward was pulled\r\n    uint256   public lastRewardBlock;\r\n    // The current delay enforced on an exit\r\n    uint256   public exitDelay;\r\n    // Min maount of ancestor tokens that must remain in the contract and not be auctioned\r\n    uint256   public minStakedTokensToKeep;\r\n    // Max number of auctions that can be active at a time\r\n    uint256   public maxConcurrentAuctions;\r\n    // Amount of ancestor tokens to auction at a time\r\n    uint256   public tokensToAuction;\r\n    // Initial amount of system coins to request in exchange for tokensToAuction\r\n    uint256   public systemCoinsToRequest;\r\n    // Amount of rewards per share accumulated (total, see rewardDebt for more info)\r\n    uint256   public accTokensPerShare;\r\n    // Balance of the rewards token in this contract since last update\r\n    uint256   public rewardsBalance;\r\n    // Staked Supply (== sum of all staked balances)\r\n    uint256   public stakedSupply;\r\n    // Percentage of claimed rewards that will be vested\r\n    uint256   public percentageVested;\r\n    // Whether the escrow is paused or not\r\n    uint256   public escrowPaused;\r\n\r\n    // Balances (not affected by slashing)\r\n    mapping(address => uint256)    public descendantBalanceOf;\r\n    // Exit data\r\n    mapping(address => ExitRequest) public exitRequests;\r\n    // The amount of tokens inneligible for claiming rewards (see formula below)\r\n    mapping(address => uint256)    internal rewardDebt;\r\n    // Pending reward = (descendant.balanceOf(user) * accTokensPerShare) - rewardDebt[user]\r\n\r\n    // The token being deposited in the pool\r\n    TokenPool                public ancestorPool;\r\n    // The token used to pay rewards\r\n    TokenPool                public rewardPool;\r\n    // Descendant token\r\n    TokenLike                public descendant;\r\n    // Auction house for staked tokens\r\n    AuctionHouseLike         public auctionHouse;\r\n    // Accounting engine contract\r\n    AccountingEngineLike     public accountingEngine;\r\n    // The safe engine contract\r\n    SAFEEngineLike           public safeEngine;\r\n    // Contract that drips rewards\r\n    RewardDripperLike        public rewardDripper;\r\n    // Escrow for rewards\r\n    StakingRewardsEscrowLike public escrow;\r\n\r\n    // Max delay that can be enforced for an exit\r\n    uint256 public immutable MAX_DELAY;\r\n\r\n    // --- Events ---\r\n    event AddAuthorization(address account);\r\n    event RemoveAuthorization(address account);\r\n    event ModifyParameters(bytes32 indexed parameter, uint256 data);\r\n    event ModifyParameters(bytes32 indexed parameter, address data);\r\n    event ToggleJoin(bool canJoin);\r\n    event ToggleBypassAuctions(bool bypassAuctions);\r\n    event ToggleForcedExit(bool forcedExit);\r\n    event AuctionAncestorTokens(address auctionHouse, uint256 amountAuctioned, uint256 amountRequested);\r\n    event RequestExit(address indexed account, uint256 deadline, uint256 amount);\r\n    event Join(address indexed account, uint256 price, uint256 amount);\r\n    event Exit(address indexed account, uint256 price, uint256 amount);\r\n    event RewardsPaid(address account, uint256 amount);\r\n    event EscrowRewards(address escrow, address who, uint256 amount);\r\n    event PoolUpdated(uint256 accTokensPerShare, uint256 stakedSupply);\r\n    event FailEscrowRewards(bytes revertReason);\r\n\r\n    constructor(\r\n      address ancestor_,\r\n      address descendant_,\r\n      address rewardToken_,\r\n      address auctionHouse_,\r\n      address accountingEngine_,\r\n      address safeEngine_,\r\n      address rewardDripper_,\r\n      address escrow_,\r\n      uint256 maxDelay_,\r\n      uint256 exitDelay_,\r\n      uint256 minStakedTokensToKeep_,\r\n      uint256 tokensToAuction_,\r\n      uint256 systemCoinsToRequest_,\r\n      uint256 percentageVested_\r\n    ) public {\r\n        require(maxDelay_ > 0, \"GebLenderFirstResortRewardsVested/null-max-delay\");\r\n        require(exitDelay_ <= maxDelay_, \"GebLenderFirstResortRewardsVested/invalid-exit-delay\");\r\n        require(minStakedTokensToKeep_ > 0, \"GebLenderFirstResortRewardsVested/null-min-staked-tokens\");\r\n        require(tokensToAuction_ > 0, \"GebLenderFirstResortRewardsVested/null-tokens-to-auction\");\r\n        require(systemCoinsToRequest_ > 0, \"GebLenderFirstResortRewardsVested/null-sys-coins-to-request\");\r\n        require(auctionHouse_ != address(0), \"GebLenderFirstResortRewardsVested/null-auction-house\");\r\n        require(accountingEngine_ != address(0), \"GebLenderFirstResortRewardsVested/null-accounting-engine\");\r\n        require(safeEngine_ != address(0), \"GebLenderFirstResortRewardsVested/null-safe-engine\");\r\n        require(rewardDripper_ != address(0), \"GebLenderFirstResortRewardsVested/null-reward-dripper\");\r\n        require(escrow_ != address(0), \"GebLenderFirstResortRewardsVested/null-escrow\");\r\n        require(percentageVested_ < 100, \"GebLenderFirstResortRewardsVested/invalid-percentage-vested\");\r\n        require(descendant_ != address(0), \"GebLenderFirstResortRewardsVested/null-descendant\");\r\n\r\n        authorizedAccounts[msg.sender] = 1;\r\n        canJoin                        = true;\r\n        maxConcurrentAuctions          = uint(-1);\r\n\r\n        MAX_DELAY                      = maxDelay_;\r\n\r\n        exitDelay                      = exitDelay_;\r\n\r\n        minStakedTokensToKeep          = minStakedTokensToKeep_;\r\n        tokensToAuction                = tokensToAuction_;\r\n        systemCoinsToRequest           = systemCoinsToRequest_;\r\n        percentageVested               = percentageVested_;\r\n\r\n        auctionHouse                   = AuctionHouseLike(auctionHouse_);\r\n        accountingEngine               = AccountingEngineLike(accountingEngine_);\r\n        safeEngine                     = SAFEEngineLike(safeEngine_);\r\n        rewardDripper                  = RewardDripperLike(rewardDripper_);\r\n        escrow                         = StakingRewardsEscrowLike(escrow_);\r\n        descendant                     = TokenLike(descendant_);\r\n\r\n        ancestorPool                   = new TokenPool(ancestor_);\r\n        rewardPool                     = new TokenPool(rewardToken_);\r\n\r\n        lastRewardBlock                = block.number;\r\n\r\n        require(ancestorPool.token().decimals() == 18, \"GebLenderFirstResortRewardsVested/ancestor-decimal-mismatch\");\r\n        require(descendant.decimals() == 18, \"GebLenderFirstResortRewardsVested/descendant-decimal-mismatch\");\r\n\r\n        emit AddAuthorization(msg.sender);\r\n    }\r\n\r\n    // --- Boolean Logic ---\r\n    function both(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := and(x, y)}\r\n    }\r\n    function either(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := or(x, y)}\r\n    }\r\n\r\n    // --- Math ---\r\n    uint256 public constant WAD = 10 ** 18;\r\n    uint256 public constant RAY = 10 ** 27;\r\n\r\n    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"GebLenderFirstResortRewardsVested/add-overflow\");\r\n    }\r\n    function subtract(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"GebLenderFirstResortRewardsVested/sub-underflow\");\r\n    }\r\n    function multiply(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"GebLenderFirstResortRewardsVested/mul-overflow\");\r\n    }\r\n    function wdivide(uint x, uint y) internal pure returns (uint z) {\r\n        require(y > 0, \"GebLenderFirstResortRewardsVested/wdiv-by-zero\");\r\n        z = multiply(x, WAD) / y;\r\n    }\r\n    function wmultiply(uint x, uint y) internal pure returns (uint z) {\r\n        z = multiply(x, y) / WAD;\r\n    }\r\n\r\n    // --- Administration ---\r\n    /*\r\n    * @notify Switch between allowing and disallowing joins\r\n    */\r\n    function toggleJoin() external isAuthorized {\r\n        canJoin = !canJoin;\r\n        emit ToggleJoin(canJoin);\r\n    }\r\n    /*\r\n    * @notify Switch between ignoring and taking into account auctions in canPrintProtocolTokens\r\n    */\r\n    function toggleBypassAuctions() external isAuthorized {\r\n        bypassAuctions = !bypassAuctions;\r\n        emit ToggleBypassAuctions(bypassAuctions);\r\n    }\r\n    /*\r\n    * @notify Switch between allowing exits when the system is underwater or blocking them\r\n    */\r\n    function toggleForcedExit() external isAuthorized {\r\n        forcedExit = !forcedExit;\r\n        emit ToggleForcedExit(forcedExit);\r\n    }\r\n    /*\r\n    * @notify Modify an uint256 parameter\r\n    * @param parameter The name of the parameter to modify\r\n    * @param data New value for the parameter\r\n    */\r\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\r\n        if (parameter == \"exitDelay\") {\r\n          require(data <= MAX_DELAY, \"GebLenderFirstResortRewardsVested/invalid-exit-delay\");\r\n          exitDelay = data;\r\n        }\r\n        else if (parameter == \"minStakedTokensToKeep\") {\r\n          require(data > 0, \"GebLenderFirstResortRewardsVested/null-min-staked-tokens\");\r\n          minStakedTokensToKeep = data;\r\n        }\r\n        else if (parameter == \"tokensToAuction\") {\r\n          require(data > 0, \"GebLenderFirstResortRewardsVested/invalid-tokens-to-auction\");\r\n          tokensToAuction = data;\r\n        }\r\n        else if (parameter == \"systemCoinsToRequest\") {\r\n          require(data > 0, \"GebLenderFirstResortRewardsVested/invalid-sys-coins-to-request\");\r\n          systemCoinsToRequest = data;\r\n        }\r\n        else if (parameter == \"maxConcurrentAuctions\") {\r\n          require(data > 1, \"GebLenderFirstResortRewardsVested/invalid-max-concurrent-auctions\");\r\n          maxConcurrentAuctions = data;\r\n        }\r\n        else if (parameter == \"escrowPaused\") {\r\n          require(data <= 1, \"GebLenderFirstResortRewardsVested/invalid-escrow-paused\");\r\n          escrowPaused = data;\r\n        }\r\n        else if (parameter == \"percentageVested\") {\r\n          require(data < 100, \"GebLenderFirstResortRewardsVested/invalid-percentage-vested\");\r\n          percentageVested = data;\r\n        }\r\n        else revert(\"GebLenderFirstResortRewardsVested/modify-unrecognized-param\");\r\n        emit ModifyParameters(parameter, data);\r\n    }\r\n    /*\r\n    * @notify Modify an address parameter\r\n    * @param parameter The name of the parameter to modify\r\n    * @param data New value for the parameter\r\n    */\r\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\r\n        require(data != address(0), \"GebLenderFirstResortRewardsVested/null-data\");\r\n\r\n        if (parameter == \"auctionHouse\") {\r\n          auctionHouse = AuctionHouseLike(data);\r\n        }\r\n        else if (parameter == \"accountingEngine\") {\r\n          accountingEngine = AccountingEngineLike(data);\r\n        }\r\n        else if (parameter == \"rewardDripper\") {\r\n          rewardDripper = RewardDripperLike(data);\r\n        }\r\n        else if (parameter == \"escrow\") {\r\n          escrow = StakingRewardsEscrowLike(data);\r\n        }\r\n        else revert(\"GebLenderFirstResortRewardsVested/modify-unrecognized-param\");\r\n        emit ModifyParameters(parameter, data);\r\n    }\r\n\r\n    // --- Getters ---\r\n    /*\r\n    * @notify Return the ancestor token balance for this contract\r\n    */\r\n    function depositedAncestor() public view returns (uint256) {\r\n        return ancestorPool.balance();\r\n    }\r\n    /*\r\n    * @notify Returns how many ancestor tokens are offered for one descendant token\r\n    */\r\n    function ancestorPerDescendant() public view returns (uint256) {\r\n        return stakedSupply == 0 ? WAD : wdivide(depositedAncestor(), stakedSupply);\r\n    }\r\n    /*\r\n    * @notify Returns how many descendant tokens are offered for one ancestor token\r\n    */\r\n    function descendantPerAncestor() public view returns (uint256) {\r\n        return stakedSupply == 0 ? WAD : wdivide(stakedSupply, depositedAncestor());\r\n    }\r\n    /*\r\n    * @notify Given a custom amount of ancestor tokens, it returns the corresponding amount of descendant tokens to mint when someone joins\r\n    * @param wad The amount of ancestor tokens to compute the descendant tokens for\r\n    */\r\n    function joinPrice(uint256 wad) public view returns (uint256) {\r\n        return wmultiply(wad, descendantPerAncestor());\r\n    }\r\n    /*\r\n    * @notify Given a custom amount of descendant tokens, it returns the corresponding amount of ancestor tokens to send when someone exits\r\n    * @param wad The amount of descendant tokens to compute the ancestor tokens for\r\n    */\r\n    function exitPrice(uint256 wad) public view returns (uint256) {\r\n        return wmultiply(wad, ancestorPerDescendant());\r\n    }\r\n\r\n    /*\r\n    * @notice Returns whether the protocol is underwater or not\r\n    */\r\n    function protocolUnderwater() public view returns (bool) {\r\n        uint256 unqueuedUnauctionedDebt = accountingEngine.unqueuedUnauctionedDebt();\r\n\r\n        return both(\r\n          accountingEngine.debtAuctionBidSize() <= unqueuedUnauctionedDebt,\r\n          safeEngine.coinBalance(address(accountingEngine)) < unqueuedUnauctionedDebt\r\n        );\r\n    }\r\n\r\n    /*\r\n    * @notice Burn descendant tokens in exchange for getting ancestor tokens from this contract\r\n    * @return Whether the pool can auction ancestor tokens\r\n    */\r\n    function canAuctionTokens() public view returns (bool) {\r\n        return both(\r\n          both(protocolUnderwater(), addition(minStakedTokensToKeep, tokensToAuction) <= depositedAncestor()),\r\n          auctionHouse.activeStakedTokenAuctions() < maxConcurrentAuctions\r\n        );\r\n    }\r\n\r\n    /*\r\n    * @notice Returns whether the system can mint new ancestor tokens\r\n    */\r\n    function canPrintProtocolTokens() public view returns (bool) {\r\n        return both(\r\n          !canAuctionTokens(),\r\n          either(auctionHouse.activeStakedTokenAuctions() == 0, bypassAuctions)\r\n        );\r\n    }\r\n\r\n    /*\r\n    * @notice Returns unclaimed rewards for a given user\r\n    */\r\n    function pendingRewards(address user) public view returns (uint256) {\r\n        uint accTokensPerShare_ = accTokensPerShare;\r\n        if (block.number > lastRewardBlock && stakedSupply != 0) {\r\n            uint increaseInBalance = (block.number - lastRewardBlock) * rewardDripper.rewardPerBlock();\r\n            accTokensPerShare_ = addition(accTokensPerShare_, multiply(increaseInBalance, RAY) / stakedSupply);\r\n        }\r\n        return subtract(multiply(descendantBalanceOf[user], accTokensPerShare_) / RAY, rewardDebt[user]);\r\n    }\r\n\r\n    /*\r\n    * @notice Returns rewards earned per block for each token deposited (WAD)\r\n    */\r\n    function rewardRate() public view returns (uint256) {\r\n        if (stakedSupply == 0) return 0;\r\n        return (rewardDripper.rewardPerBlock() * WAD) / stakedSupply;\r\n    }\r\n\r\n    // --- Core Logic ---\r\n    /*\r\n    * @notify Updates the pool and pays rewards (if any)\r\n    * @dev Must be included in deposits and withdrawals\r\n    */\r\n    modifier payRewards() {\r\n        updatePool();\r\n\r\n        if (descendantBalanceOf[msg.sender] > 0 && rewardPool.balance() > 0) {\r\n            // Pays the reward\r\n            uint256 pending = subtract(multiply(descendantBalanceOf[msg.sender], accTokensPerShare) / RAY, rewardDebt[msg.sender]);\r\n\r\n            uint256 vested;\r\n            if (both(address(escrow) != address(0), escrowPaused == 0)) {\r\n              vested = multiply(pending, percentageVested) / 100;\r\n\r\n              try escrow.escrowRewards(msg.sender, vested) {\r\n                rewardPool.transfer(address(escrow), vested);\r\n                emit EscrowRewards(address(escrow), msg.sender, vested);\r\n              } catch(bytes memory revertReason) {\r\n                emit FailEscrowRewards(revertReason);\r\n              }\r\n            }\r\n\r\n            rewardPool.transfer(msg.sender, subtract(pending, vested));\r\n            rewardsBalance = rewardPool.balance();\r\n\r\n            emit RewardsPaid(msg.sender, pending);\r\n        }\r\n        _;\r\n\r\n        rewardDebt[msg.sender] = multiply(descendantBalanceOf[msg.sender], accTokensPerShare) / RAY;\r\n    }\r\n\r\n    /*\r\n    * @notify Pays outstanding rewards to msg.sender\r\n    */\r\n    function getRewards() external nonReentrant payRewards {}\r\n\r\n    /*\r\n    * @notify Pull funds from the dripper\r\n    */\r\n    function pullFunds() public {\r\n        rewardDripper.dripReward(address(rewardPool));\r\n    }\r\n\r\n    /*\r\n    * @notify Updates pool data\r\n    */\r\n    function updatePool() public {\r\n        if (block.number <= lastRewardBlock) return;\r\n        lastRewardBlock = block.number;\r\n        if (stakedSupply == 0) return;\r\n\r\n        pullFunds();\r\n        uint256 increaseInBalance = subtract(rewardPool.balance(), rewardsBalance);\r\n        rewardsBalance = addition(rewardsBalance, increaseInBalance);\r\n\r\n        // Updates distribution info\r\n        accTokensPerShare = addition(accTokensPerShare, multiply(increaseInBalance, RAY) / stakedSupply);\r\n        emit PoolUpdated(accTokensPerShare, stakedSupply);\r\n    }\r\n\r\n    /*\r\n    * @notify Create a new auction that sells ancestor tokens in exchange for system coins\r\n    */\r\n    function auctionAncestorTokens() external nonReentrant {\r\n        require(canAuctionTokens(), \"GebLenderFirstResortRewardsVested/cannot-auction-tokens\");\r\n\r\n        ancestorPool.transfer(address(this), tokensToAuction);\r\n        ancestorPool.token().approve(address(auctionHouse), tokensToAuction);\r\n        auctionHouse.startAuction(tokensToAuction, systemCoinsToRequest);\r\n        updatePool();\r\n\r\n        emit AuctionAncestorTokens(address(auctionHouse), tokensToAuction, systemCoinsToRequest);\r\n    }\r\n\r\n    /*\r\n    * @notify Join ancestor tokens\r\n    * @param wad The amount of ancestor tokens to join\r\n    */\r\n    function join(uint256 wad) external nonReentrant payRewards {\r\n        require(both(canJoin, !protocolUnderwater()), \"GebLenderFirstResortRewardsVested/join-not-allowed\");\r\n        require(wad > 0, \"GebLenderFirstResortRewardsVested/null-ancestor-to-join\");\r\n        uint256 price = joinPrice(wad);\r\n        require(price > 0, \"GebLenderFirstResortRewardsVested/null-join-price\");\r\n\r\n        require(ancestorPool.token().transferFrom(msg.sender, address(ancestorPool), wad), \"GebLenderFirstResortRewardsVested/could-not-transfer-ancestor\");\r\n        descendant.mint(msg.sender, price);\r\n\r\n        descendantBalanceOf[msg.sender] = addition(descendantBalanceOf[msg.sender], price);\r\n        stakedSupply = addition(stakedSupply, price);\r\n\r\n        emit Join(msg.sender, price, wad);\r\n    }\r\n    /*\r\n    * @notice Request an exit for a specific amount of ancestor tokens\r\n    * @param wad The amount of tokens to exit\r\n    */\r\n    function requestExit(uint wad) external nonReentrant payRewards {\r\n        require(wad > 0, \"GebLenderFirstResortRewardsVested/null-amount-to-exit\");\r\n\r\n        exitRequests[msg.sender].deadline      = addition(now, exitDelay);\r\n        exitRequests[msg.sender].lockedAmount  = addition(exitRequests[msg.sender].lockedAmount, wad);\r\n\r\n        descendantBalanceOf[msg.sender] = subtract(descendantBalanceOf[msg.sender], wad);\r\n        descendant.burn(msg.sender, wad);\r\n\r\n        emit RequestExit(msg.sender, exitRequests[msg.sender].deadline, wad);\r\n    }\r\n    /*\r\n    * @notify Exit ancestor tokens\r\n    */\r\n    function exit() external nonReentrant {\r\n        require(both(now >= exitRequests[msg.sender].deadline, exitRequests[msg.sender].lockedAmount > 0), \"GebLenderFirstResortRewardsVested/wait-more\");\r\n        require(either(!protocolUnderwater(), forcedExit), \"GebLenderFirstResortRewardsVested/exit-not-allowed\");\r\n\r\n        uint256 price = exitPrice(exitRequests[msg.sender].lockedAmount);\r\n        stakedSupply  = subtract(stakedSupply, exitRequests[msg.sender].lockedAmount);\r\n        ancestorPool.transfer(msg.sender, price);\r\n        emit Exit(msg.sender, price, exitRequests[msg.sender].lockedAmount);\r\n        delete exitRequests[msg.sender];\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ancestor_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"descendant_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"auctionHouse_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"accountingEngine_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"safeEngine_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardDripper_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"escrow_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxDelay_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exitDelay_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minStakedTokensToKeep_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensToAuction_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"systemCoinsToRequest_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentageVested_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"auctionHouse\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAuctioned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountRequested\",\"type\":\"uint256\"}],\"name\":\"AuctionAncestorTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"escrow\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EscrowRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Exit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"revertReason\",\"type\":\"bytes\"}],\"name\":\"FailEscrowRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Join\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accTokensPerShare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedSupply\",\"type\":\"uint256\"}],\"name\":\"PoolUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemoveAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"bypassAuctions\",\"type\":\"bool\"}],\"name\":\"ToggleBypassAuctions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"forcedExit\",\"type\":\"bool\"}],\"name\":\"ToggleForcedExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"canJoin\",\"type\":\"bool\"}],\"name\":\"ToggleJoin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accTokensPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accountingEngine\",\"outputs\":[{\"internalType\":\"contract AccountingEngineLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ancestorPerDescendant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ancestorPool\",\"outputs\":[{\"internalType\":\"contract TokenPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionAncestorTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionHouse\",\"outputs\":[{\"internalType\":\"contract AuctionHouseLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bypassAuctions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canAuctionTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canJoin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canPrintProtocolTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositedAncestor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"descendant\",\"outputs\":[{\"internalType\":\"contract TokenLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"descendantBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"descendantPerAncestor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"escrow\",\"outputs\":[{\"internalType\":\"contract StakingRewardsEscrowLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"escrowPaused\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"exitPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exitRequests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forcedExit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"join\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"joinPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxConcurrentAuctions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStakedTokensToKeep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentageVested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolUnderwater\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pullFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"requestExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardDripper\",\"outputs\":[{\"internalType\":\"contract RewardDripperLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPool\",\"outputs\":[{\"internalType\":\"contract TokenPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeEngine\",\"outputs\":[{\"internalType\":\"contract SAFEEngineLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"systemCoinsToRequest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleBypassAuctions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleForcedExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleJoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensToAuction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GebLenderFirstResortRewardsVested","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d6f3768e62ef92a9798e5a8cedd2b78907cecef9000000000000000000000000353efac5cab823a41bc0d6228d7061e92cf9ccb00000000000000000000000006243d8cea23066d098a15582d81a598b4e8391f40000000000000000000000002ba0a37c6603a79400806955e75be1c1219235be000000000000000000000000cee6aa1ab47d0fb0f24f51a3072ec16e20f90fce000000000000000000000000cc88a9d330da1133df3a7bd823b95e52511a696200000000000000000000000003da3d5e0b13b6f0917fa9bc3d65b46229d7ef470000000000000000000000008017f897aaaabd5701b63d819590062a87732ba0000000000000000000000000000000000000000000000000000000000024ea0000000000000000000000000000000000000000000000000000000000001baf800000000000000000000000000000000000000000000000004563918244f400000000000000000000000000000000000000000000000000056bc75e2d631000000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000004b","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://bde6a006d3fd32aba7bbfc2a86ae454f8041e58d11433384b9f9eff60effe7d5"}]}