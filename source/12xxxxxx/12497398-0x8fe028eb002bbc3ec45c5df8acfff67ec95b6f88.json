{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/Andrei/Documents/CerebellumNetwork/chainbridge-solidity/contracts/handlers/ERC20Handler.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/IDepositExecute.sol\\\";\\nimport \\\"./HandlerHelpers.sol\\\";\\nimport \\\"../ERC20Safe.sol\\\";\\n\\n/**\\n    @title Handles ERC20 deposits and deposit executions.\\n    @author ChainSafe Systems.\\n    @notice This contract is intended to be used with the Bridge contract.\\n */\\ncontract ERC20Handler is IDepositExecute, HandlerHelpers, ERC20Safe {\\n    struct DepositRecord {\\n        address _tokenAddress;\\n        uint8    _lenDestinationRecipientAddress;\\n        uint8   _destinationChainID;\\n        bytes32 _resourceID;\\n        bytes   _destinationRecipientAddress;\\n        address _depositer;\\n        uint    _amount;\\n    }\\n\\n    // depositNonce => Deposit Record\\n    mapping (uint8 => mapping(uint64 => DepositRecord)) public _depositRecords;\\n\\n    /**\\n        @param bridgeAddress Contract address of previously deployed Bridge.\\n        @param initialResourceIDs Resource IDs are used to identify a specific contract address.\\n        These are the Resource IDs this contract will initially support.\\n        @param initialContractAddresses These are the addresses the {initialResourceIDs} will point to, and are the contracts that will be\\n        called to perform various deposit calls.\\n\\n        @dev {initialResourceIDs} and {initialContractAddresses} must have the same length (one resourceID for every address).\\n        Also, these arrays must be ordered in the way that {initialResourceIDs}[0] is the intended resourceID for {initialContractAddresses}[0].\\n     */\\n    constructor(\\n        address          bridgeAddress,\\n        bytes32[] memory initialResourceIDs,\\n        address[] memory initialContractAddresses\\n    ) public {\\n        require(initialResourceIDs.length == initialContractAddresses.length,\\n            \\\"initialResourceIDs and initialContractAddresses len mismatch\\\");\\n\\n        _bridgeAddress = bridgeAddress;\\n\\n        for (uint256 i = 0; i < initialResourceIDs.length; i++) {\\n            _setResource(initialResourceIDs[i], initialContractAddresses[i]);\\n        }\\n\\n    }\\n\\n    /**\\n        @param depositNonce This ID will have been generated by the Bridge contract.\\n        @param destId ID of chain deposit will be bridged to.\\n        @return DepositRecord which consists of:\\n        - _tokenAddress Address used when {deposit} was executed.\\n        - _destinationChainID ChainID deposited tokens are intended to end up on.\\n        - _resourceID ResourceID used when {deposit} was executed.\\n        - _lenDestinationRecipientAddress Used to parse recipient's address from {_destinationRecipientAddress}\\n        - _destinationRecipientAddress Address tokens are intended to be deposited to on desitnation chain.\\n        - _depositer Address that initially called {deposit} in the Bridge contract.\\n        - _amount Amount of tokens that were deposited.\\n    */\\n    function getDepositRecord(uint64 depositNonce, uint8 destId) external view returns (DepositRecord memory) {\\n        return _depositRecords[destId][depositNonce];\\n    }\\n\\n    /**\\n        @notice A deposit is initiatied by making a deposit in the Bridge contract.\\n        @param destinationChainID Chain ID of chain tokens are expected to be bridged to.\\n        @param depositNonce This value is generated as an ID by the Bridge contract.\\n        @param depositer Address of account making the deposit in the Bridge contract.\\n        @param data Consists of: {resourceID}, {amount}, {lenRecipientAddress}, and {recipientAddress}\\n        all padded to 32 bytes.\\n        @notice Data passed into the function should be constructed as follows:\\n        amount                      uint256     bytes   0 - 32\\n        recipientAddress length     uint256     bytes  32 - 64\\n        recipientAddress            bytes       bytes  64 - END\\n        @dev Deposited tokens will be locked.\\n     */\\n    function deposit(\\n        bytes32 resourceID,\\n        uint8   destinationChainID,\\n        uint64  depositNonce,\\n        address depositer,\\n        bytes   calldata data\\n    ) external override onlyBridge {\\n        bytes   memory recipientAddress;\\n        uint256        amount;\\n        uint256        lenRecipientAddress;\\n\\n        assembly {\\n\\n            amount := calldataload(0xC4)\\n\\n            recipientAddress := mload(0x40)\\n            lenRecipientAddress := calldataload(0xE4)\\n            mstore(0x40, add(0x20, add(recipientAddress, lenRecipientAddress)))\\n\\n            calldatacopy(\\n                recipientAddress, // copy to destinationRecipientAddress\\n                0xE4, // copy from calldata @ 0x104\\n                sub(calldatasize(), 0xE) // copy size (calldatasize - 0x104)\\n            )\\n        }\\n\\n        address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\\n        require(_contractWhitelist[tokenAddress], \\\"provided tokenAddress is not whitelisted\\\");\\n\\n        lockERC20(tokenAddress, depositer, address(this), amount);\\n\\n        _depositRecords[destinationChainID][depositNonce] = DepositRecord(\\n            tokenAddress,\\n            uint8(lenRecipientAddress),\\n            destinationChainID,\\n            resourceID,\\n            recipientAddress,\\n            depositer,\\n            amount\\n        );\\n    }\\n\\n    /**\\n        @notice Proposal execution should be initiated when a proposal is finalized in the Bridge contract.\\n        by a relayer on the deposit's destination chain.\\n        @param data Consists of {resourceID}, {amount}, {lenDestinationRecipientAddress},\\n        and {destinationRecipientAddress} all padded to 32 bytes.\\n        @notice Data passed into the function should be constructed as follows:\\n        amount                                 uint256     bytes  0 - 32\\n        destinationRecipientAddress length     uint256     bytes  32 - 64\\n        destinationRecipientAddress            bytes       bytes  64 - END\\n     */\\n    function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {\\n        uint256       amount;\\n        bytes  memory destinationRecipientAddress;\\n\\n        assembly {\\n            amount := calldataload(0x64)\\n\\n            destinationRecipientAddress := mload(0x40)\\n            let lenDestinationRecipientAddress := calldataload(0x84)\\n            mstore(0x40, add(0x20, add(destinationRecipientAddress, lenDestinationRecipientAddress)))\\n\\n            // in the calldata the destinationRecipientAddress is stored at 0xC4 after accounting for the function signature and length declaration\\n            calldatacopy(\\n                destinationRecipientAddress, // copy to destinationRecipientAddress\\n                0x84, // copy from calldata @ 0x84\\n                sub(calldatasize(), 0x84) // copy size to the end of calldata\\n            )\\n        }\\n\\n        bytes20 recipientAddress;\\n        address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\\n\\n        assembly {\\n            recipientAddress := mload(add(destinationRecipientAddress, 0x20))\\n        }\\n\\n        require(_contractWhitelist[tokenAddress], \\\"provided tokenAddress is not whitelisted\\\");\\n\\n        releaseERC20(tokenAddress, address(recipientAddress), amount);\\n        \\n    }\\n\\n    /**\\n        @notice Used to manually release ERC20 tokens from ERC20Safe.\\n        @param tokenAddress Address of token contract to release.\\n        @param recipient Address to release tokens to.\\n        @param amount The amount of ERC20 tokens to release.\\n     */\\n    function withdraw(address tokenAddress, address recipient, uint amount) external override onlyBridge {\\n        releaseERC20(tokenAddress, recipient, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/Andrei/Documents/CerebellumNetwork/chainbridge-solidity/contracts/interfaces/IERCHandler.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n    @title Interface to be used with handlers that support ERC20s and ERC721s.\\n    @author ChainSafe Systems.\\n */\\ninterface IERCHandler {\\n    /**\\n        @notice Correlates {resourceID} with {contractAddress}.\\n        @param resourceID ResourceID to be used when making deposits.\\n        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\\n     */\\n    function setResource(bytes32 resourceID, address contractAddress) external;\\n    /**\\n        @notice Marks {contractAddress} as mintable/burnable.\\n        @param contractAddress Address of contract to be used when making or executing deposits.\\n     */\\n    function setBurnable(address contractAddress) external;\\n    /**\\n        @notice Used to manually release funds from ERC safes.\\n        @param tokenAddress Address of token contract to release.\\n        @param recipient Address to release tokens to.\\n        @param amountOrTokenID Either the amount of ERC20 tokens or the ERC721 token ID to release.\\n     */\\n    function withdraw(address tokenAddress, address recipient, uint256 amountOrTokenID) external;\\n}\\n\"\r\n    },\r\n    \"/Users/Andrei/Documents/CerebellumNetwork/chainbridge-solidity/contracts/interfaces/IDepositExecute.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n    @title Interface for handler contracts that support deposits and deposit executions.\\n    @author ChainSafe Systems.\\n */\\ninterface IDepositExecute {\\n    /**\\n        @notice It is intended that deposit are made using the Bridge contract.\\n        @param destinationChainID Chain ID deposit is expected to be bridged to.\\n        @param depositNonce This value is generated as an ID by the Bridge contract.\\n        @param depositer Address of account making the deposit in the Bridge contract.\\n        @param data Consists of additional data needed for a specific deposit.\\n     */\\n    function deposit(bytes32 resourceID, uint8 destinationChainID, uint64 depositNonce, address depositer, bytes calldata data) external;\\n\\n    /**\\n        @notice It is intended that proposals are executed by the Bridge contract.\\n        @param data Consists of additional data needed for a specific deposit execution.\\n     */\\n    function executeProposal(bytes32 resourceID, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"/Users/Andrei/Documents/CerebellumNetwork/chainbridge-solidity/contracts/handlers/HandlerHelpers.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../interfaces/IERCHandler.sol\\\";\\n\\n/**\\n    @title Function used across handler contracts.\\n    @author ChainSafe Systems.\\n    @notice This contract is intended to be used with the Bridge contract.\\n */\\ncontract HandlerHelpers is IERCHandler {\\n    address public _bridgeAddress;\\n\\n    // resourceID => token contract address\\n    mapping (bytes32 => address) public _resourceIDToTokenContractAddress;\\n\\n    // token contract address => resourceID\\n    mapping (address => bytes32) public _tokenContractAddressToResourceID;\\n\\n    // token contract address => is whitelisted\\n    mapping (address => bool) public _contractWhitelist;\\n\\n    // token contract address => is burnable\\n    mapping (address => bool) public _burnList;\\n\\n    modifier onlyBridge() {\\n        _onlyBridge();\\n        _;\\n    }\\n\\n    function _onlyBridge() private {\\n        require(msg.sender == _bridgeAddress, \\\"sender must be bridge contract\\\");\\n    }\\n\\n    /**\\n        @notice First verifies {_resourceIDToContractAddress}[{resourceID}] and\\n        {_contractAddressToResourceID}[{contractAddress}] are not already set,\\n        then sets {_resourceIDToContractAddress} with {contractAddress},\\n        {_contractAddressToResourceID} with {resourceID},\\n        and {_contractWhitelist} to true for {contractAddress}.\\n        @param resourceID ResourceID to be used when making deposits.\\n        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\\n     */\\n    function setResource(bytes32 resourceID, address contractAddress) external override onlyBridge {\\n\\n        _setResource(resourceID, contractAddress);\\n    }\\n\\n    /**\\n        @notice First verifies {contractAddress} is whitelisted, then sets {_burnList}[{contractAddress}]\\n        to true.\\n        @param contractAddress Address of contract to be used when making or executing deposits.\\n     */\\n    function setBurnable(address contractAddress) external override onlyBridge{\\n        _setBurnable(contractAddress);\\n    }\\n\\n    /**\\n        @notice Used to manually release funds from ERC safes.\\n        @param tokenAddress Address of token contract to release.\\n        @param recipient Address to release tokens to.\\n        @param amountOrTokenID Either the amount of ERC20 tokens or the ERC721 token ID to release.\\n     */\\n    function withdraw(address tokenAddress, address recipient, uint256 amountOrTokenID) external virtual override {}\\n\\n    function _setResource(bytes32 resourceID, address contractAddress) internal {\\n        _resourceIDToTokenContractAddress[resourceID] = contractAddress;\\n        _tokenContractAddressToResourceID[contractAddress] = resourceID;\\n\\n        _contractWhitelist[contractAddress] = true;\\n    }\\n\\n    function _setBurnable(address contractAddress) internal {\\n        require(_contractWhitelist[contractAddress], \\\"provided contract is not whitelisted\\\");\\n        _burnList[contractAddress] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/Andrei/Documents/CerebellumNetwork/chainbridge-solidity/contracts/ERC20Safe.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n    @title Manages deposited ERC20s.\\n    @author ChainSafe Systems.\\n    @notice This contract is intended to be used with ERC20Handler contract.\\n */\\ncontract ERC20Safe {\\n    using SafeMath for uint256;\\n\\n    /**\\n        @notice Used to transfer tokens into the safe to fund proposals.\\n        @param tokenAddress Address of ERC20 to transfer.\\n        @param owner Address of current token owner.\\n        @param amount Amount of tokens to transfer.\\n     */\\n    function fundERC20(address tokenAddress, address owner, uint256 amount) public {\\n        IERC20 erc20 = IERC20(tokenAddress);\\n        _safeTransferFrom(erc20, owner, address(this), amount);\\n    }\\n\\n    /**\\n        @notice Used to gain custody of deposited token.\\n        @param tokenAddress Address of ERC20 to transfer.\\n        @param owner Address of current token owner.\\n        @param recipient Address to transfer tokens to.\\n        @param amount Amount of tokens to transfer.\\n     */\\n    function lockERC20(address tokenAddress, address owner, address recipient, uint256 amount) internal {\\n        IERC20 erc20 = IERC20(tokenAddress);\\n        _safeTransferFrom(erc20, owner, recipient, amount);\\n    }\\n\\n    /**\\n        @notice Transfers custody of token to recipient.\\n        @param tokenAddress Address of ERC20 to transfer.\\n        @param recipient Address to transfer tokens to.\\n        @param amount Amount of tokens to transfer.\\n     */\\n    function releaseERC20(address tokenAddress, address recipient, uint256 amount) internal {\\n        IERC20 erc20 = IERC20(tokenAddress);\\n        _safeTransfer(erc20, recipient, amount);\\n    }\\n\\n\\n    /**\\n        @notice used to transfer ERC20s safely\\n        @param token Token instance to transfer\\n        @param to Address to transfer token to\\n        @param value Amount of token to transfer\\n     */\\n    function _safeTransfer(IERC20 token, address to, uint256 value) private {\\n        _safeCall(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n\\n    /**\\n        @notice used to transfer ERC20s safely\\n        @param token Token instance to transfer\\n        @param from Address to transfer token from\\n        @param to Address to transfer token to\\n        @param value Amount of token to transfer\\n     */\\n    function _safeTransferFrom(IERC20 token, address from, address to, uint256 value) private {\\n        _safeCall(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n        @notice used to make calls to ERC20s safely\\n        @param token Token instance call targets\\n        @param data encoded call data\\n     */\\n    function _safeCall(IERC20 token, bytes memory data) private {\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"ERC20: call failed\\\");\\n\\n        if (returndata.length > 0) {\\n\\n            require(abi.decode(returndata, (bool)), \\\"ERC20: operation did not succeed\\\");\\n        }\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bridgeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"initialResourceIDs\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"initialContractAddresses\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"_bridgeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_burnList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_contractWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"_depositRecords\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_lenDestinationRecipientAddress\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_destinationChainID\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_destinationRecipientAddress\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_depositer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_resourceIDToTokenContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_tokenContractAddressToResourceID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"destinationChainID\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"depositer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fundERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"destId\",\"type\":\"uint8\"}],\"name\":\"getDepositRecord\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_lenDestinationRecipientAddress\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_destinationChainID\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_destinationRecipientAddress\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_depositer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC20Handler.DepositRecord\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setBurnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setResource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ERC20Handler","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000caf65ab2ec9b39403966991eb34b1e8b9e44c0410000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}