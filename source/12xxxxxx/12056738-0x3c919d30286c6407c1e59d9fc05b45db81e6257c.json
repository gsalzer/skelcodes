{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/core/ElasticDAOFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLv3\\npragma solidity 0.7.2;\\npragma experimental ABIEncoderV2;\\n\\nimport './ElasticDAO.sol';\\n\\nimport '../models/Ecosystem.sol';\\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\\n\\nimport '@pie-dao/proxy/contracts/PProxy.sol';\\n\\n/**\\n * @dev The factory contract for ElasticDAO\\n * Deploys ElasticDAO's and also sets all the required parameters and permissions,\\n * Collects a fee which is later used by ELasticDAO for further development of the project.\\n */\\ncontract ElasticDAOFactory is ReentrancyGuard {\\n  address public ecosystemModelAddress;\\n  address public elasticDAOImplementationAddress;\\n  address public manager;\\n  address payable feeAddress;\\n  address[] public deployedDAOAddresses;\\n  uint256 public fee;\\n  bool public initialized = false;\\n\\n  event DeployedDAO(address indexed daoAddress);\\n  event ElasticDAOImplementationAddressUpdated(address indexed elasticDAOImplementationAddress);\\n  event FeeAddressUpdated(address indexed feeReceiver);\\n  event FeesCollected(address indexed feeAddress, uint256 amount);\\n  event FeeUpdated(uint256 amount);\\n  event ManagerUpdated(address indexed newManager);\\n\\n  modifier onlyManager() {\\n    require(manager == msg.sender, 'ElasticDAO: Only manager');\\n    _;\\n  }\\n\\n  /**\\n   * @notice Initializes the ElasticDAO factory\\n   *\\n   * @param _ecosystemModelAddress - the address of the ecosystem model\\n   * @dev\\n   * Requirements:\\n   * - The factory cannot already be initialized\\n   * - The ecosystem model address cannot be the zero address\\n   */\\n  function initialize(address _ecosystemModelAddress, address _elasticDAOImplementationAddress)\\n    external\\n    nonReentrant\\n  {\\n    require(initialized == false, 'ElasticDAO: Factory already initialized');\\n    require(\\n      _ecosystemModelAddress != address(0) && _elasticDAOImplementationAddress != address(0),\\n      'ElasticDAO: Address Zero'\\n    );\\n\\n    ecosystemModelAddress = _ecosystemModelAddress;\\n    elasticDAOImplementationAddress = _elasticDAOImplementationAddress;\\n    fee = 250000000000000000;\\n    initialized = true;\\n    manager = msg.sender;\\n  }\\n\\n  /**\\n   * @notice collects the fees sent to this contract\\n   *\\n   * @dev emits FeesCollected event\\n   * Requirement:\\n   * - The fee collection transaction should be successful\\n   */\\n  function collectFees() external nonReentrant {\\n    require(feeAddress != address(0), 'ElasticDAO: No feeAddress set');\\n\\n    uint256 amount = address(this).balance;\\n\\n    (bool success, ) = feeAddress.call{ value: amount }('');\\n    require(success, 'ElasticDAO: TransactionFailed');\\n    emit FeesCollected(address(feeAddress), amount);\\n  }\\n\\n  /**\\n   * @notice deploys DAO and initializes token and stores the address of the deployed DAO\\n   *\\n   * @param _summoners - an array containing address of summoners\\n   * @param _nameOfDAO - the name of the DAO\\n   * @param _nameOfToken - the name of the token\\n   * @param _eByL-the amount of lambda a summoner gets(per ETH) during the seeding phase of the DAO\\n   * @param _elasticity-the value by which the cost of entering the  DAO increases ( on every join )\\n   * @param _k - is the constant token multiplier,\\n   * it increases the number of tokens that each member of the DAO has with respect to their lambda\\n   * @param _maxLambdaPurchase - is the maximum amount of lambda that can be purchased per wallet\\n   * @param _maxVotingLambda - is the maximum amount of lambda that can be used to vote\\n   *\\n   * @dev emits DeployedDAO event\\n   * @dev\\n   * Requirement:\\n   * - The fee required should be sent in the call to the function\\n   */\\n  function deployDAOAndToken(\\n    address[] memory _summoners,\\n    string memory _nameOfDAO,\\n    string memory _nameOfToken,\\n    string memory _symbol,\\n    uint256 _eByL,\\n    uint256 _elasticity,\\n    uint256 _k,\\n    uint256 _maxLambdaPurchase,\\n    uint256 _maxVotingLambda\\n  ) external payable nonReentrant {\\n    require(fee == msg.value, 'ElasticDAO: A fee is required to deploy a DAO');\\n\\n    // Deploy the DAO behind PProxy\\n    PProxy proxy = new PProxy();\\n    proxy.setImplementation(elasticDAOImplementationAddress);\\n    proxy.setProxyOwner(msg.sender);\\n\\n    address payable daoAddress = address(proxy);\\n\\n    // initialize the DAO\\n    ElasticDAO(daoAddress).initialize(\\n      ecosystemModelAddress,\\n      msg.sender,\\n      _summoners,\\n      _nameOfDAO,\\n      _maxVotingLambda\\n    );\\n\\n    deployedDAOAddresses.push(daoAddress);\\n\\n    // initialize the token\\n    ElasticDAO(daoAddress).initializeToken(\\n      _nameOfToken,\\n      _symbol,\\n      _eByL,\\n      _elasticity,\\n      _k,\\n      _maxLambdaPurchase\\n    );\\n    emit DeployedDAO(daoAddress);\\n  }\\n\\n  /**\\n   * @notice returns deployed DAO count\\n   */\\n  function deployedDAOCount() external view returns (uint256) {\\n    return deployedDAOAddresses.length;\\n  }\\n\\n  /**\\n   * @notice updates the address of the elasticDAO implementation\\n   * @param _elasticDAOImplementationAddress - the new address\\n   * @dev emits ElasticDAOImplementationAddressUpdated event\\n   * @dev Requirement:\\n   * - The elasticDAO implementation address cannot be zero address\\n   */\\n  function updateElasticDAOImplementationAddress(address _elasticDAOImplementationAddress)\\n    external\\n    onlyManager\\n    nonReentrant\\n  {\\n    require(_elasticDAOImplementationAddress != address(0), 'ElasticDAO: Address Zero');\\n\\n    elasticDAOImplementationAddress = _elasticDAOImplementationAddress;\\n    emit ElasticDAOImplementationAddressUpdated(_elasticDAOImplementationAddress);\\n  }\\n\\n  /**\\n   * @notice updates the fee required to deploy a DAQ\\n   *\\n   * @param _amount - the new amount of the fees\\n   *\\n   * @dev emits FeeUpdated event\\n   */\\n  function updateFee(uint256 _amount) external onlyManager nonReentrant {\\n    fee = _amount;\\n    emit FeeUpdated(fee);\\n  }\\n\\n  /**\\n   * @notice updates the address of the fee reciever\\n   *\\n   * @param _feeReceiver - the new address of the fee reciever\\n   *\\n   * @dev emits FeeAddressUpdated event\\n   * @dev\\n   * Requirement:\\n   * - The fee receiver address cannot be zero address\\n   */\\n  function updateFeeAddress(address _feeReceiver) external onlyManager nonReentrant {\\n    require(_feeReceiver != address(0), 'ElasticDAO: Address Zero');\\n\\n    feeAddress = payable(_feeReceiver);\\n    emit FeeAddressUpdated(_feeReceiver);\\n  }\\n\\n  /**\\n   * @notice updates the manager address\\n   *\\n   * @param _newManager - the address of the new manager\\n   *\\n   * @dev Requirement\\n   * - Address of the manager cannot be zero\\n   * @dev emits ManagerUpdated event\\n   */\\n  function updateManager(address _newManager) external onlyManager nonReentrant {\\n    require(_newManager != address(0), 'ElasticDAO: Address Zero');\\n\\n    manager = _newManager;\\n    emit ManagerUpdated(manager);\\n  }\\n\\n  receive() external payable {}\\n\\n  fallback() external payable {}\\n}\\n\"\r\n    },\r\n    \"src/core/ElasticDAO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLv3\\npragma solidity 0.7.2;\\npragma experimental ABIEncoderV2;\\n\\nimport '../interfaces/IUniswapV2Pair.sol';\\n\\nimport '../libraries/ElasticMath.sol';\\n\\nimport '../models/DAO.sol';\\nimport '../models/Ecosystem.sol';\\nimport '../models/Token.sol';\\n\\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\\n\\nimport '@pie-dao/proxy/contracts/PProxy.sol';\\nimport 'hardhat/console.sol';\\n\\n/**\\n * @dev The ElasticDAO contract outlines and defines all the functionality\\n * such as initialize, Join, exit, etc for an elasticDAO.\\n *\\n * It also serves as the vault for ElasticDAO.\\n */\\ncontract ElasticDAO is ReentrancyGuard {\\n  address public deployer;\\n  address public ecosystemModelAddress;\\n  address public controller;\\n  address[] public summoners;\\n  address[] public liquidityPools;\\n  bool public initialized;\\n\\n  event ElasticGovernanceTokenDeployed(address indexed tokenAddress);\\n  event MaxVotingLambdaChanged(uint256 value);\\n  event ControllerChanged(address value);\\n  event ExitDAO(address indexed memberAddress, uint256 shareAmount, uint256 ethAmount);\\n  event FailedToFullyPenalize(\\n    address indexed memberAddress,\\n    uint256 attemptedAmount,\\n    uint256 actualAmount\\n  );\\n  event JoinDAO(address indexed memberAddress, uint256 shareAmount, uint256 ethAmount);\\n  event LiquidityPoolAdded(address indexed poolAddress);\\n  event LiquidityPoolRemoved(address indexed poolAddress);\\n  event SeedDAO(address indexed summonerAddress, uint256 amount);\\n  event SummonedDAO(address indexed summonedBy);\\n\\n  modifier onlyAfterSummoning() {\\n    DAO.Instance memory dao = _getDAO();\\n    require(dao.summoned, 'ElasticDAO: DAO must be summoned');\\n    _;\\n  }\\n  modifier onlyAfterTokenInitialized() {\\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\\n\\n    bool tokenInitialized =\\n      Token(ecosystem.tokenModelAddress).exists(\\n        ecosystem.governanceTokenAddress,\\n        ecosystem.daoAddress\\n      );\\n    require(tokenInitialized, 'ElasticDAO: Please call initializeToken first');\\n    _;\\n  }\\n  modifier onlyBeforeSummoning() {\\n    DAO.Instance memory dao = _getDAO();\\n    require(dao.summoned == false, 'ElasticDAO: DAO must not be summoned');\\n    _;\\n  }\\n  modifier onlyController() {\\n    require(msg.sender == controller, 'ElasticDAO: Only controller');\\n    _;\\n  }\\n  modifier onlyDeployer() {\\n    require(msg.sender == deployer, 'ElasticDAO: Only deployer');\\n    _;\\n  }\\n  modifier onlySummoners() {\\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\\n    DAO daoContract = DAO(ecosystem.daoModelAddress);\\n    DAO.Instance memory dao = daoContract.deserialize(address(this), ecosystem);\\n    bool summonerCheck = daoContract.isSummoner(dao, msg.sender);\\n\\n    require(summonerCheck, 'ElasticDAO: Only summoners');\\n    _;\\n  }\\n  modifier onlyWhenOpen() {\\n    require(address(this).balance > 0, 'ElasticDAO: This DAO is closed');\\n    _;\\n  }\\n\\n  /**\\n   * @notice Initializes and builds the ElasticDAO struct\\n   *\\n   * @param _ecosystemModelAddress - the address of the ecosystem model\\n   * @param _controller the address which can control the core DAO functions\\n   * @param _summoners - an array containing the addresses of the summoners\\n   * @param _name - the name of the DAO\\n   * @param _maxVotingLambda - the maximum amount of lambda that can be used to vote in the DAO\\n   *\\n   * @dev\\n   * Requirements:\\n   * - The DAO cannot already be initialized\\n   * - The ecosystem model address cannot be the zero address\\n   * - The DAO must have atleast one summoner to summon the DAO\\n   */\\n  function initialize(\\n    address _ecosystemModelAddress,\\n    address _controller,\\n    address[] memory _summoners,\\n    string memory _name,\\n    uint256 _maxVotingLambda\\n  ) external nonReentrant {\\n    require(initialized == false, 'ElasticDAO: Already initialized');\\n    require(\\n      _ecosystemModelAddress != address(0) && _controller != address(0),\\n      'ElasticDAO: Address Zero'\\n    );\\n    require(_summoners.length > 0, 'ElasticDAO: At least 1 summoner required');\\n\\n    for (uint256 i = 0; i < _summoners.length; i += 1) {\\n      if (_summoners[i] == address(0)) {\\n        revert('ElasticDAO: Summoner address can not be zero address');\\n      }\\n    }\\n\\n    controller = _controller;\\n    deployer = msg.sender;\\n    summoners = _summoners;\\n\\n    Ecosystem.Instance memory defaults = Ecosystem(_ecosystemModelAddress).deserialize(address(0));\\n    Ecosystem.Instance memory ecosystem = _buildEcosystem(controller, defaults);\\n    ecosystemModelAddress = ecosystem.ecosystemModelAddress;\\n\\n    bool success = _buildDAO(_summoners, _name, _maxVotingLambda, ecosystem);\\n    initialized = true;\\n    require(success, 'ElasticDAO: Build DAO Failed');\\n  }\\n\\n  function addLiquidityPool(address _poolAddress)\\n    external\\n    onlyController\\n    nonReentrant\\n    returns (bool)\\n  {\\n    liquidityPools.push(_poolAddress);\\n\\n    emit LiquidityPoolAdded(_poolAddress);\\n  }\\n\\n  /**\\n   * @notice initializes the token of the DAO\\n   *\\n   * @param _name - name of the token\\n   * @param _symbol - symbol of the token\\n   * @param _eByL -the amount of lambda a summoner gets(per ETH) during the seeding phase of the DAO\\n   * @param _elasticity the value by which the cost of entering the  DAO increases ( on every join )\\n   * @param _k - is the constant token multiplier\\n   * it increases the number of tokens that each member of the DAO has with respect to their lambda\\n   * @param _maxLambdaPurchase - is the maximum amount of lambda that can be purchased per wallet\\n   *\\n   * @dev emits ElasticGovernanceTokenDeployed event\\n   * @dev\\n   * Requirements:\\n   * - Only the deployer of the DAO can initialize the Token\\n   */\\n  function initializeToken(\\n    string memory _name,\\n    string memory _symbol,\\n    uint256 _eByL,\\n    uint256 _elasticity,\\n    uint256 _k,\\n    uint256 _maxLambdaPurchase\\n  ) external onlyBeforeSummoning onlyDeployer nonReentrant {\\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\\n\\n    Token.Instance memory token =\\n      _buildToken(\\n        controller,\\n        _name,\\n        _symbol,\\n        _eByL,\\n        _elasticity,\\n        _k,\\n        _maxLambdaPurchase,\\n        ecosystem\\n      );\\n\\n    emit ElasticGovernanceTokenDeployed(token.uuid);\\n  }\\n\\n  /**\\n   * @notice this function is to be used for exiting the DAO\\n   * for the underlying ETH value of  _deltaLambda\\n   *\\n   * The eth value of _deltaLambda is calculated using:\\n   *\\n   * eth to be transfered = ( deltaLambda/lambda ) * totalEthInTheDAO\\n   *\\n   * @param _deltaLambda - the amount of lambda the address exits with\\n   *\\n   * Requirement:\\n   * - ETH transfer must be successful\\n   * @dev emits ExitDAO event\\n   */\\n  function exit(uint256 _deltaLambda) external onlyAfterSummoning nonReentrant {\\n    // burn the shares\\n    Token.Instance memory token = _getToken();\\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(token.uuid);\\n\\n    // eth to be transfered = ( deltaLambda/lambda ) * totalEthInTheDAO\\n    uint256 ratioOfShares = ElasticMath.wdiv(_deltaLambda, token.lambda);\\n    uint256 ethToBeTransfered = ElasticMath.wmul(ratioOfShares, address(this).balance);\\n    // transfer the eth\\n    tokenContract.burnShares(msg.sender, _deltaLambda);\\n    (bool success, ) = msg.sender.call{ value: ethToBeTransfered }('');\\n    require(success, 'ElasticDAO: Exit Failed');\\n    emit ExitDAO(msg.sender, _deltaLambda, ethToBeTransfered);\\n  }\\n\\n  /**\\n   * @notice this function returns the length of the liquidity pools array\\n   *\\n   */\\n  function getLiquidityPoolCount() public view returns (uint256) {\\n    return liquidityPools.length;\\n  }\\n\\n  /**\\n   * @notice this function is used to join the DAO after it has been summoned\\n   * Joining the DAO is syntactically equal to minting _deltaLambda for the function caller.\\n   *\\n   * Based on the current state of the DAO, capitalDelta, deltaE, mDash are calulated,\\n   * after which  maxTokenLambda is minted for the address calling the function.\\n   *\\n   * @dev documentation and further math regarding capitalDelta, deltaE,\\n   * mDash can be found at ../libraries/ElasticMath.sol\\n   * @dev emits the JoinDAO event\\n   *\\n   * @dev Requirements:\\n   * (The value of maxLambdaPurchase is set during the initialzing of the DAO)\\n   * The correct value of ETH, calculated via deltaE,\\n   * must be sent in the transaction by the calling address\\n   * The token contract should be successfully be able to mint token.makxLambdaPurchase\\n   */\\n  function join() external payable onlyAfterSummoning onlyWhenOpen nonReentrant {\\n    Token.Instance memory token = _getToken();\\n\\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(token.uuid);\\n    uint256 capitalDelta =\\n      ElasticMath.capitalDelta(\\n        // the current totalBalance of the DAO is inclusive of msg.value,\\n        // capitalDelta is to be calculated without the msg.value\\n        SafeMath.sub(address(this).balance, msg.value),\\n        tokenContract.totalSupply()\\n      );\\n    uint256 deltaE =\\n      ElasticMath.deltaE(\\n        token.maxLambdaPurchase,\\n        capitalDelta,\\n        token.k,\\n        token.elasticity,\\n        token.lambda,\\n        token.m\\n      );\\n\\n    require(msg.value >= deltaE, 'ElasticDAO: Incorrect ETH amount');\\n\\n    // mdash\\n    uint256 lambdaDash = SafeMath.add(token.maxLambdaPurchase, token.lambda);\\n    uint256 mDash = ElasticMath.mDash(lambdaDash, token.lambda, token.m);\\n\\n    // serialize the token\\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\\n    Token tokenStorage = Token(ecosystem.tokenModelAddress);\\n    token.m = mDash;\\n    tokenStorage.serialize(token);\\n\\n    // tokencontract mint shares\\n    bool success = tokenContract.mintShares(msg.sender, token.maxLambdaPurchase);\\n    require(success, 'ElasticDAO: Mint Shares Failed during Join');\\n\\n    for (uint256 i = 0; i < liquidityPools.length; i += 1) {\\n      IUniswapV2Pair(liquidityPools[i]).sync();\\n    }\\n\\n    // return extra ETH\\n    if (success && msg.value > deltaE) {\\n      (success, ) = msg.sender.call{ value: SafeMath.sub(msg.value, deltaE) }('');\\n      require(success, 'ElasticDAO: TransactionFailed');\\n    }\\n\\n    emit JoinDAO(msg.sender, token.maxLambdaPurchase, msg.value);\\n  }\\n\\n  /**\\n   * @notice penalizes @param _addresses with @param _amounts respectively\\n   *\\n   * @param _addresses - an array of addresses\\n   * @param _amounts - an array containing the amounts each address has to be penalized respectively\\n   *\\n   * @dev Requirement:\\n   * - Each address must have a corresponding amount to be penalized with\\n   */\\n  function penalize(address[] memory _addresses, uint256[] memory _amounts)\\n    external\\n    onlyController\\n    nonReentrant\\n  {\\n    require(\\n      _addresses.length == _amounts.length,\\n      'ElasticDAO: An amount is required for each address'\\n    );\\n\\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(_getToken().uuid);\\n\\n    for (uint256 i = 0; i < _addresses.length; i += 1) {\\n      uint256 lambda = tokenContract.balanceOfInShares(_addresses[i]);\\n\\n      if (lambda < _amounts[i]) {\\n        if (lambda != 0) {\\n          tokenContract.burnShares(_addresses[i], lambda);\\n        }\\n\\n        FailedToFullyPenalize(_addresses[i], _amounts[i], lambda);\\n      } else {\\n        tokenContract.burnShares(_addresses[i], _amounts[i]);\\n      }\\n    }\\n  }\\n\\n  function removeLiquidityPool(address _poolAddress)\\n    external\\n    onlyController\\n    nonReentrant\\n    returns (bool)\\n  {\\n    for (uint256 i = 0; i < liquidityPools.length; i += 1) {\\n      if (liquidityPools[i] == _poolAddress) {\\n        liquidityPools[i] = liquidityPools[liquidityPools.length - 1];\\n        liquidityPools.pop();\\n      }\\n    }\\n\\n    emit LiquidityPoolRemoved(_poolAddress);\\n  }\\n\\n  /**\\n   * @notice rewards @param _addresess with @param _amounts respectively\\n   *\\n   * @param _addresses - an array of addresses\\n   * @param _amounts - an array containing the amounts each address has to be rewarded respectively\\n   *\\n   * @dev Requirement:\\n   * - Each address must have a corresponding amount to be rewarded with\\n   */\\n  function reward(address[] memory _addresses, uint256[] memory _amounts)\\n    external\\n    onlyController\\n    nonReentrant\\n  {\\n    require(\\n      _addresses.length == _amounts.length,\\n      'ElasticDAO: An amount is required for each address'\\n    );\\n\\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(_getToken().uuid);\\n\\n    for (uint256 i = 0; i < _addresses.length; i += 1) {\\n      tokenContract.mintShares(_addresses[i], _amounts[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice sets the controller of the DAO,\\n   * The controller of the DAO handles various responsibilities of the DAO,\\n   * such as burning and minting tokens on behalf of the DAO\\n   *\\n   * @param _controller - the new address of the controller of the DAO\\n   *\\n   * @dev emits ControllerChanged event\\n   * @dev Requirements:\\n   * - The controller must not be the 0 address\\n   * - The controller of the DAO should successfully be set as the burner of the tokens of the DAO\\n   * - The controller of the DAO should successfully be set as the minter of the tokens of the DAO\\n   */\\n  function setController(address _controller) external onlyController nonReentrant {\\n    require(_controller != address(0), 'ElasticDAO: Address Zero');\\n\\n    controller = _controller;\\n\\n    // Update minter / burner\\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(_getToken().uuid);\\n    bool success = tokenContract.setBurner(controller);\\n    require(success, 'ElasticDAO: Set Burner failed during setController');\\n    success = tokenContract.setMinter(controller);\\n    require(success, 'ElasticDAO: Set Minter failed during setController');\\n\\n    emit ControllerChanged(controller);\\n  }\\n\\n  /**\\n   * @notice sets the max voting lambda value for the DAO\\n   * @param _maxVotingLambda - the value of the maximum amount of lambda that can be used for voting\\n   * @dev emits MaxVotingLambdaChanged event\\n   */\\n  function setMaxVotingLambda(uint256 _maxVotingLambda) external onlyController nonReentrant {\\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\\n    DAO daoStorage = DAO(ecosystem.daoModelAddress);\\n    DAO.Instance memory dao = daoStorage.deserialize(address(this), ecosystem);\\n    dao.maxVotingLambda = _maxVotingLambda;\\n    daoStorage.serialize(dao);\\n\\n    emit MaxVotingLambdaChanged(_maxVotingLambda);\\n  }\\n\\n  /**\\n   * @notice seeds the DAO,\\n   * Essentially transferring of ETH by a summoner address, in return for lambda is seeding the DAO,\\n   * The lambda receieved is given by:\\n   * Lambda = Eth  / eByL\\n   *\\n   * @dev seeding of the DAO occurs after the DAO has been initialized,\\n   * and before the DAO has been summoned\\n   * @dev emits the SeedDAO event\\n   */\\n  function seedSummoning()\\n    external\\n    payable\\n    onlyBeforeSummoning\\n    onlySummoners\\n    onlyAfterTokenInitialized\\n    nonReentrant\\n  {\\n    Token.Instance memory token = _getToken();\\n\\n    uint256 deltaE = msg.value;\\n    uint256 deltaLambda = ElasticMath.wdiv(deltaE, token.eByL);\\n    ElasticGovernanceToken(token.uuid).mintShares(msg.sender, deltaLambda);\\n\\n    emit SeedDAO(msg.sender, deltaLambda);\\n  }\\n\\n  /**\\n   * @notice summons the DAO,\\n   * Summoning the DAO results in all summoners getting _deltaLambda\\n   * after which people can enter the DAO using the join function\\n   *\\n   * @param _deltaLambda - the amount of lambda each summoner address receives\\n   *\\n   * @dev emits SummonedDAO event\\n   * @dev Requirement:\\n   * The DAO must be seeded with ETH during the seeding phase\\n   * (This is to facilitate capitalDelta calculations after the DAO has been summoned).\\n   *\\n   * @dev documentation and further math regarding capitalDelta\\n   * can be found at ../libraries/ElasticMath.sol\\n   */\\n  function summon(uint256 _deltaLambda) external onlyBeforeSummoning onlySummoners nonReentrant {\\n    require(address(this).balance > 0, 'ElasticDAO: Please seed DAO with ETH to set ETH:EGT ratio');\\n\\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\\n    DAO daoContract = DAO(ecosystem.daoModelAddress);\\n    DAO.Instance memory dao = daoContract.deserialize(address(this), ecosystem);\\n    Token.Instance memory token =\\n      Token(ecosystem.tokenModelAddress).deserialize(ecosystem.governanceTokenAddress, ecosystem);\\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(token.uuid);\\n\\n    // number of summoners can not grow unboundly. it is fixed limit.\\n    for (uint256 i = 0; i < dao.numberOfSummoners; i += 1) {\\n      tokenContract.mintShares(daoContract.getSummoner(dao, i), _deltaLambda);\\n    }\\n    dao.summoned = true;\\n    daoContract.serialize(dao);\\n\\n    emit SummonedDAO(msg.sender);\\n  }\\n\\n  // Getters\\n\\n  function getDAO() external view returns (DAO.Instance memory) {\\n    return _getDAO();\\n  }\\n\\n  function getEcosystem() external view returns (Ecosystem.Instance memory) {\\n    return _getEcosystem();\\n  }\\n\\n  /**\\n   * @dev creates DAO.Instance record\\n   * @param _summoners addresses of the summoners\\n   * @param _name name of the DAO\\n   * @param _ecosystem instance of Ecosystem the DAO uses\\n   * @param _maxVotingLambda - the maximum amount of lambda that can be used to vote in the DAO\\n   * @return bool true\\n   */\\n  function _buildDAO(\\n    address[] memory _summoners,\\n    string memory _name,\\n    uint256 _maxVotingLambda,\\n    Ecosystem.Instance memory _ecosystem\\n  ) internal returns (bool) {\\n    DAO daoStorage = DAO(_ecosystem.daoModelAddress);\\n    DAO.Instance memory dao;\\n\\n    dao.uuid = address(this);\\n    dao.ecosystem = _ecosystem;\\n    dao.maxVotingLambda = _maxVotingLambda;\\n    dao.name = _name;\\n    dao.summoned = false;\\n    dao.summoners = _summoners;\\n    daoStorage.serialize(dao);\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Deploys proxies leveraging the implementation contracts found on the\\n   * default Ecosystem.Instance record.\\n   * @param _controller the address which can control the core DAO functions\\n   * @param _defaults instance of Ecosystem with the implementation addresses\\n   * @return ecosystem Ecosystem.Instance\\n   */\\n  function _buildEcosystem(address _controller, Ecosystem.Instance memory _defaults)\\n    internal\\n    returns (Ecosystem.Instance memory ecosystem)\\n  {\\n    ecosystem.daoAddress = address(this);\\n    ecosystem.daoModelAddress = _deployProxy(_defaults.daoModelAddress, _controller);\\n    ecosystem.ecosystemModelAddress = _deployProxy(_defaults.ecosystemModelAddress, _controller);\\n    ecosystem.governanceTokenAddress = _deployProxy(_defaults.governanceTokenAddress, _controller);\\n    ecosystem.tokenHolderModelAddress = _deployProxy(\\n      _defaults.tokenHolderModelAddress,\\n      _controller\\n    );\\n    ecosystem.tokenModelAddress = _deployProxy(_defaults.tokenModelAddress, _controller);\\n\\n    Ecosystem(ecosystem.ecosystemModelAddress).serialize(ecosystem);\\n    return ecosystem;\\n  }\\n\\n  /**\\n   * @dev creates a Token.Instance record and initializes the ElasticGovernanceToken.\\n   * @param _controller the address which can control the core DAO functions\\n   * @param _name name of the token\\n   * @param _symbol symbol of the token\\n   * @param _eByL initial ETH/token ratio\\n   * @param _elasticity the percentage by which capitalDelta should increase\\n   * @param _k a constant, initially set by the DAO\\n   * @param _maxLambdaPurchase maximum amount of lambda (shares) that can be\\n   * minted on each call to the join function in ElasticDAO.sol\\n   * @param _ecosystem the DAO's ecosystem instance\\n   * @return token Token.Instance\\n   */\\n  function _buildToken(\\n    address _controller,\\n    string memory _name,\\n    string memory _symbol,\\n    uint256 _eByL,\\n    uint256 _elasticity,\\n    uint256 _k,\\n    uint256 _maxLambdaPurchase,\\n    Ecosystem.Instance memory _ecosystem\\n  ) internal returns (Token.Instance memory token) {\\n    token.eByL = _eByL;\\n    token.ecosystem = _ecosystem;\\n    token.elasticity = _elasticity;\\n    token.k = _k;\\n    token.lambda = 0;\\n    token.m = 1000000000000000000;\\n    token.maxLambdaPurchase = _maxLambdaPurchase;\\n    token.name = _name;\\n    token.symbol = _symbol;\\n    token.uuid = _ecosystem.governanceTokenAddress;\\n\\n    // initialize the token within the ecosystem\\n    return\\n      ElasticGovernanceToken(token.uuid).initialize(_controller, _controller, _ecosystem, token);\\n  }\\n\\n  function _deployProxy(address _implementationAddress, address _owner) internal returns (address) {\\n    PProxy proxy = new PProxy();\\n    proxy.setImplementation(_implementationAddress);\\n    proxy.setProxyOwner(_owner);\\n    return address(proxy);\\n  }\\n\\n  // Private\\n\\n  function _getDAO() internal view returns (DAO.Instance memory) {\\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\\n    return DAO(ecosystem.daoModelAddress).deserialize(address(this), ecosystem);\\n  }\\n\\n  function _getEcosystem() internal view returns (Ecosystem.Instance memory) {\\n    return Ecosystem(ecosystemModelAddress).deserialize(address(this));\\n  }\\n\\n  function _getToken() internal view returns (Token.Instance memory) {\\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\\n    return\\n      Token(ecosystem.tokenModelAddress).deserialize(ecosystem.governanceTokenAddress, ecosystem);\\n  }\\n\\n  receive() external payable {}\\n\\n  fallback() external payable {}\\n}\\n\"\r\n    },\r\n    \"src/models/Ecosystem.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLv3\\npragma solidity 0.7.2;\\npragma experimental ABIEncoderV2;\\n\\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\\n\\nimport './EternalModel.sol';\\n\\n/**\\n * @title ElasticDAO ecosystem\\n * @author ElasticDAO - https://ElasticDAO.org\\n * @notice This contract is used for storing core dao data\\n * @dev ElasticDAO network contracts can read/write from this contract\\n * @dev Serialize - Translation of data from the concerned struct to key-value pairs\\n * @dev Deserialize - Translation of data from the key-value pairs to a struct\\n */\\ncontract Ecosystem is EternalModel, ReentrancyGuard {\\n  struct Instance {\\n    address daoAddress;\\n    // Models\\n    address daoModelAddress;\\n    address ecosystemModelAddress;\\n    address tokenHolderModelAddress;\\n    address tokenModelAddress;\\n    // Tokens\\n    address governanceTokenAddress;\\n  }\\n\\n  event Serialized(address indexed _daoAddress);\\n\\n  /**\\n   * @dev deserializes Instance struct\\n   * @param _daoAddress - address of the unique user ID\\n   * @return record Instance\\n   */\\n  function deserialize(address _daoAddress) external view returns (Instance memory record) {\\n    if (_exists(_daoAddress)) {\\n      record.daoAddress = _daoAddress;\\n      record.daoModelAddress = getAddress(\\n        keccak256(abi.encode(record.daoAddress, 'daoModelAddress'))\\n      );\\n      record.ecosystemModelAddress = address(this);\\n      record.governanceTokenAddress = getAddress(\\n        keccak256(abi.encode(record.daoAddress, 'governanceTokenAddress'))\\n      );\\n      record.tokenHolderModelAddress = getAddress(\\n        keccak256(abi.encode(record.daoAddress, 'tokenHolderModelAddress'))\\n      );\\n      record.tokenModelAddress = getAddress(\\n        keccak256(abi.encode(record.daoAddress, 'tokenModelAddress'))\\n      );\\n    }\\n\\n    return record;\\n  }\\n\\n  /**\\n   * @dev checks if @param _daoAddress\\n   * @param _daoAddress - address of the unique user ID\\n   * @return recordExists bool\\n   */\\n  function exists(address _daoAddress) external view returns (bool recordExists) {\\n    return _exists(_daoAddress);\\n  }\\n\\n  /**\\n   * @dev serializes Instance struct\\n   * @param _record Instance\\n   */\\n  function serialize(Instance memory _record) external nonReentrant {\\n    bool recordExists = _exists(_record.daoAddress);\\n\\n    require(\\n      msg.sender == _record.daoAddress || (_record.daoAddress == address(0) && !recordExists),\\n      'ElasticDAO: Unauthorized'\\n    );\\n\\n    setAddress(\\n      keccak256(abi.encode(_record.daoAddress, 'daoModelAddress')),\\n      _record.daoModelAddress\\n    );\\n    setAddress(\\n      keccak256(abi.encode(_record.daoAddress, 'governanceTokenAddress')),\\n      _record.governanceTokenAddress\\n    );\\n    setAddress(\\n      keccak256(abi.encode(_record.daoAddress, 'tokenHolderModelAddress')),\\n      _record.tokenHolderModelAddress\\n    );\\n    setAddress(\\n      keccak256(abi.encode(_record.daoAddress, 'tokenModelAddress')),\\n      _record.tokenModelAddress\\n    );\\n\\n    setBool(keccak256(abi.encode(_record.daoAddress, 'exists')), true);\\n\\n    emit Serialized(_record.daoAddress);\\n  }\\n\\n  function _exists(address _daoAddress) internal view returns (bool recordExists) {\\n    return getBool(keccak256(abi.encode(_daoAddress, 'exists')));\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@pie-dao/proxy/contracts/PProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.1;\\r\\n\\r\\nimport \\\"./PProxyStorage.sol\\\";\\r\\n\\r\\ncontract PProxy is PProxyStorage {\\r\\n\\r\\n    bytes32 constant IMPLEMENTATION_SLOT = keccak256(abi.encodePacked(\\\"IMPLEMENTATION_SLOT\\\"));\\r\\n    bytes32 constant OWNER_SLOT = keccak256(abi.encodePacked(\\\"OWNER_SLOT\\\"));\\r\\n\\r\\n    modifier onlyProxyOwner() {\\r\\n        require(msg.sender == readAddress(OWNER_SLOT), \\\"PProxy.onlyProxyOwner: msg sender not owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor () public {\\r\\n        setAddress(OWNER_SLOT, msg.sender);\\r\\n    }\\r\\n\\r\\n    function getProxyOwner() public view returns (address) {\\r\\n       return readAddress(OWNER_SLOT);\\r\\n    }\\r\\n\\r\\n    function setProxyOwner(address _newOwner) onlyProxyOwner public {\\r\\n        setAddress(OWNER_SLOT, _newOwner);\\r\\n    }\\r\\n\\r\\n    function getImplementation() public view returns (address) {\\r\\n        return readAddress(IMPLEMENTATION_SLOT);\\r\\n    }\\r\\n\\r\\n    function setImplementation(address _newImplementation) onlyProxyOwner public {\\r\\n        setAddress(IMPLEMENTATION_SLOT, _newImplementation);\\r\\n    }\\r\\n\\r\\n\\r\\n    fallback () external payable {\\r\\n       return internalFallback();\\r\\n    }\\r\\n\\r\\n    function internalFallback() internal virtual {\\r\\n        address contractAddr = readAddress(IMPLEMENTATION_SLOT);\\r\\n        assembly {\\r\\n            let ptr := mload(0x40)\\r\\n            calldatacopy(ptr, 0, calldatasize())\\r\\n            let result := delegatecall(gas(), contractAddr, ptr, calldatasize(), 0, 0)\\r\\n            let size := returndatasize()\\r\\n            returndatacopy(ptr, 0, size)\\r\\n\\r\\n            switch result\\r\\n            case 0 { revert(ptr, size) }\\r\\n            default { return(ptr, size) }\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"src/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLv3\\npragma solidity 0.7.2;\\n\\ninterface IUniswapV2Pair {\\n  function sync() external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/ElasticMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLv3\\npragma solidity 0.7.2;\\n\\nimport './SafeMath.sol';\\n\\n/**\\n * @dev Provides functions for performing ElasticDAO specific math.\\n *\\n * These functions correspond with functions provided by the JS SDK and should\\n * always be used instead of doing calculations within other contracts to avoid\\n * any inconsistencies in the math.\\n *\\n * Notes:\\n *\\n * - Dash values represent the state after a transaction has completed successfully.\\n * - Non-dash values represent the current state, before the transaction has completed.\\n * - Lambda is the math term for shares. We typically expose the value to users as\\n *   shares instead of lambda because it's easier to grok.\\n */\\nlibrary ElasticMath {\\n  /**\\n   * @dev calculates the value of capitalDelta; the amount of ETH backing each\\n   * governance token.\\n   * @param totalEthValue amount of ETH in the DAO contract\\n   * @param totalSupplyOfTokens number of tokens in existance\\n   *\\n   * capitalDelta = totalEthValue / totalSupplyOfTokens\\n   * @return uint256\\n   */\\n  function capitalDelta(uint256 totalEthValue, uint256 totalSupplyOfTokens)\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return wdiv(totalEthValue, totalSupplyOfTokens);\\n  }\\n\\n  /**\\n   * @dev calculates the value of deltaE; the amount of ETH required to mint deltaLambda\\n   * @param deltaLambda = lambdaDash - lambda\\n   * @param capitalDeltaValue the ETH/token ratio; see capitalDelta(uint256, uint256)\\n   * @param k constant token multiplier - it increases the number of tokens\\n   *  that each member of the DAO has with respect to their lambda\\n   * @param elasticity the percentage by which capitalDelta (cost of entering the  DAO)\\n   * should increase on every join\\n   * @param lambda outstanding shares\\n   * @param m - lambda modifier - it's value increases every time someone joins the DAO\\n   *\\n   * lambdaDash = deltaLambda + lambda\\n   * mDash = ( lambdaDash / lambda ) * m\\n   * deltaE = capitalDelta * k * ( lambdaDash * mDash * ( 1 + elasticity ) - lambda * m )\\n   * @return uint256\\n   */\\n  function deltaE(\\n    uint256 deltaLambda,\\n    uint256 capitalDeltaValue,\\n    uint256 k,\\n    uint256 elasticity,\\n    uint256 lambda,\\n    uint256 m\\n  ) internal pure returns (uint256) {\\n    uint256 lambdaDash = SafeMath.add(deltaLambda, lambda);\\n\\n    return\\n      wmul(\\n        wmul(capitalDeltaValue, k),\\n        SafeMath.sub(\\n          wmul(lambdaDash, wmul(mDash(lambdaDash, lambda, m), revamp(elasticity))),\\n          wmul(lambda, m)\\n        )\\n      );\\n  }\\n\\n  /**\\n   * @dev calculates the lambda value given t, k, & m\\n   * @param tokens t value; number of tokens for which lambda should be calculated\\n   * @param k constant token multiplier - it increases the number of tokens\\n   *  that each member of the DAO has with respect to their lambda\\n   * @param m - lambda modifier - it's value increases every time someone joins the DAO\\n   *\\n   * lambda = t / ( m * k)\\n   * @return uint256\\n   */\\n  function lambdaFromT(\\n    uint256 tokens,\\n    uint256 k,\\n    uint256 m\\n  ) internal pure returns (uint256) {\\n    return wdiv(tokens, wmul(k, m));\\n  }\\n\\n  /**\\n   * @dev calculates the future share modifier given the future value of\\n   * lambda (lambdaDash), the current value of lambda, and the current share modifier\\n   * @param m current share modifier\\n   * @param lambda current outstanding shares\\n   * @param lambdaDash future outstanding shares\\n   *\\n   * mDash = ( lambdaDash / lambda ) * m\\n   * @return uint256\\n   */\\n  function mDash(\\n    uint256 lambdaDash,\\n    uint256 lambda,\\n    uint256 m\\n  ) internal pure returns (uint256) {\\n    return wmul(wdiv(lambdaDash, lambda), m);\\n  }\\n\\n  /**\\n   * @dev calculates the value of revamp\\n   * @param elasticity the percentage by which capitalDelta should increase\\n   *\\n   * revamp = 1 + elasticity\\n   * @return uint256\\n   */\\n  function revamp(uint256 elasticity) internal pure returns (uint256) {\\n    return SafeMath.add(elasticity, 1000000000000000000);\\n  }\\n\\n  /**\\n   * @dev calculates the number of tokens represented by lambda given k & m\\n   * @param lambda shares\\n   * @param k a constant, initially set by the DAO\\n   * @param m share modifier\\n   *\\n   * t = lambda * m * k\\n   * @return uint256\\n   */\\n  function t(\\n    uint256 lambda,\\n    uint256 k,\\n    uint256 m\\n  ) internal view returns (uint256) {\\n    if (lambda == 0) {\\n      return 0;\\n    }\\n\\n    return wmul(wmul(lambda, k), m);\\n  }\\n\\n  /**\\n   * @dev multiplies two float values, required since solidity does not handle\\n   * floating point values\\n   *\\n   * inspiration: https://github.com/dapphub/ds-math/blob/master/src/math.sol\\n   *\\n   * @return uint256\\n   */\\n  function wmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return\\n      SafeMath.div(\\n        SafeMath.add(SafeMath.mul(a, b), SafeMath.div(1000000000000000000, 2)),\\n        1000000000000000000\\n      );\\n  }\\n\\n  /**\\n   * @dev divides two float values, required since solidity does not handle\\n   * floating point values.\\n   *\\n   * inspiration: https://github.com/dapphub/ds-math/blob/master/src/math.sol\\n   *\\n   * @return uint256\\n   */\\n  function wdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return SafeMath.div(SafeMath.add(SafeMath.mul(a, 1000000000000000000), SafeMath.div(b, 2)), b);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/models/DAO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLv3\\npragma solidity 0.7.2;\\npragma experimental ABIEncoderV2;\\n\\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\\n\\nimport './Ecosystem.sol';\\nimport './EternalModel.sol';\\n\\n/**\\n * @author ElasticDAO - https://ElasticDAO.org\\n * @notice This contract is used for storing core DAO data\\n * @dev ElasticDAO network contracts can read/write from this contract\\n */\\ncontract DAO is EternalModel, ReentrancyGuard {\\n  struct Instance {\\n    address uuid;\\n    address[] summoners;\\n    bool summoned;\\n    string name;\\n    uint256 maxVotingLambda;\\n    uint256 numberOfSummoners;\\n    Ecosystem.Instance ecosystem;\\n  }\\n\\n  event Serialized(address indexed uuid);\\n\\n  /**\\n   * @dev deserializes Instance struct\\n   * @param _uuid - address of the unique user ID\\n   * @return record Instance\\n   */\\n  function deserialize(address _uuid, Ecosystem.Instance memory _ecosystem)\\n    external\\n    view\\n    returns (Instance memory record)\\n  {\\n    record.uuid = _uuid;\\n    record.ecosystem = _ecosystem;\\n\\n    if (_exists(_uuid)) {\\n      record.maxVotingLambda = getUint(keccak256(abi.encode(_uuid, 'maxVotingLambda')));\\n      record.name = getString(keccak256(abi.encode(_uuid, 'name')));\\n      record.numberOfSummoners = getUint(keccak256(abi.encode(_uuid, 'numberOfSummoners')));\\n      record.summoned = getBool(keccak256(abi.encode(_uuid, 'summoned')));\\n    }\\n\\n    return record;\\n  }\\n\\n  /**\\n   * @dev checks if @param _uuid exists\\n   * @param _uuid - address of the unique user ID\\n   * @return recordExists bool\\n   */\\n  function exists(address _uuid) external view returns (bool) {\\n    return _exists(_uuid);\\n  }\\n\\n  function getSummoner(Instance memory _dao, uint256 _index) external view returns (address) {\\n    return getAddress(keccak256(abi.encode(_dao.uuid, 'summoners', _index)));\\n  }\\n\\n  /**\\n   * @dev checks if @param _uuid where _uuid is msg.sender - is a Summoner\\n   * @param _dao DAO.Instance\\n   * @param _summonerAddress address\\n   * @return bool\\n   */\\n  function isSummoner(Instance memory _dao, address _summonerAddress) external view returns (bool) {\\n    return getBool(keccak256(abi.encode(_dao.uuid, 'summoner', _summonerAddress)));\\n  }\\n\\n  /**\\n   * @dev serializes Instance struct\\n   * @param _record Instance\\n   */\\n  function serialize(Instance memory _record) external nonReentrant {\\n    require(msg.sender == _record.uuid, 'ElasticDAO: Unauthorized');\\n\\n    setUint(keccak256(abi.encode(_record.uuid, 'maxVotingLambda')), _record.maxVotingLambda);\\n    setString(keccak256(abi.encode(_record.uuid, 'name')), _record.name);\\n    setBool(keccak256(abi.encode(_record.uuid, 'summoned')), _record.summoned);\\n\\n    if (_record.summoners.length > 0) {\\n      _record.numberOfSummoners = _record.summoners.length;\\n      setUint(keccak256(abi.encode(_record.uuid, 'numberOfSummoners')), _record.numberOfSummoners);\\n      for (uint256 i = 0; i < _record.numberOfSummoners; i += 1) {\\n        setBool(keccak256(abi.encode(_record.uuid, 'summoner', _record.summoners[i])), true);\\n        setAddress(keccak256(abi.encode(_record.uuid, 'summoners', i)), _record.summoners[i]);\\n      }\\n    }\\n\\n    setBool(keccak256(abi.encode(_record.uuid, 'exists')), true);\\n\\n    emit Serialized(_record.uuid);\\n  }\\n\\n  function _exists(address _uuid) internal view returns (bool) {\\n    return getBool(keccak256(abi.encode(_uuid, 'exists')));\\n  }\\n}\\n\"\r\n    },\r\n    \"src/models/Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLv3\\npragma solidity 0.7.2;\\npragma experimental ABIEncoderV2;\\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\\n\\nimport './Ecosystem.sol';\\nimport './EternalModel.sol';\\nimport '../tokens/ElasticGovernanceToken.sol';\\n\\n/**\\n * @title A data storage for EGT (Elastic Governance Token)\\n * @notice More info about EGT could be found in ./tokens/ElasticGovernanceToken.sol\\n * @notice This contract is used for storing token data\\n * @dev ElasticDAO network contracts can read/write from this contract\\n * Serialize - Translation of data from the concerned struct to key-value pairs\\n * Deserialize - Translation of data from the key-value pairs to a struct\\n */\\ncontract Token is EternalModel, ReentrancyGuard {\\n  struct Instance {\\n    address uuid;\\n    string name;\\n    string symbol;\\n    uint256 eByL;\\n    uint256 elasticity;\\n    uint256 k;\\n    uint256 lambda;\\n    uint256 m;\\n    uint256 maxLambdaPurchase;\\n    uint256 numberOfTokenHolders;\\n    Ecosystem.Instance ecosystem;\\n  }\\n\\n  event Serialized(address indexed uuid);\\n\\n  /**\\n   * @dev deserializes Instance struct\\n   * @param _uuid - address of the unique user ID\\n   * @return record Instance\\n   */\\n  function deserialize(address _uuid, Ecosystem.Instance memory _ecosystem)\\n    external\\n    view\\n    returns (Instance memory record)\\n  {\\n    record.uuid = _uuid;\\n    record.ecosystem = _ecosystem;\\n\\n    if (_exists(_uuid, _ecosystem.daoAddress)) {\\n      record.eByL = getUint(keccak256(abi.encode(_uuid, record.ecosystem.daoAddress, 'eByL')));\\n      record.elasticity = getUint(\\n        keccak256(abi.encode(_uuid, record.ecosystem.daoAddress, 'elasticity'))\\n      );\\n      record.k = getUint(keccak256(abi.encode(_uuid, record.ecosystem.daoAddress, 'k')));\\n      record.lambda = getUint(keccak256(abi.encode(_uuid, record.ecosystem.daoAddress, 'lambda')));\\n      record.m = getUint(keccak256(abi.encode(_uuid, record.ecosystem.daoAddress, 'm')));\\n      record.maxLambdaPurchase = getUint(\\n        keccak256(abi.encode(_uuid, record.ecosystem.daoAddress, 'maxLambdaPurchase'))\\n      );\\n      record.name = getString(keccak256(abi.encode(_uuid, record.ecosystem.daoAddress, 'name')));\\n      record.numberOfTokenHolders = getUint(\\n        keccak256(abi.encode(_uuid, record.ecosystem.daoAddress, 'numberOfTokenHolders'))\\n      );\\n      record.symbol = getString(\\n        keccak256(abi.encode(_uuid, record.ecosystem.daoAddress, 'symbol'))\\n      );\\n    }\\n\\n    return record;\\n  }\\n\\n  function exists(address _uuid, address _daoAddress) external view returns (bool) {\\n    return _exists(_uuid, _daoAddress);\\n  }\\n\\n  /**\\n   * @dev serializes Instance struct\\n   * @param _record Instance\\n   */\\n  function serialize(Instance memory _record) external nonReentrant {\\n    require(\\n      msg.sender == _record.uuid ||\\n        (msg.sender == _record.ecosystem.daoAddress &&\\n          _exists(_record.uuid, _record.ecosystem.daoAddress)),\\n      'ElasticDAO: Unauthorized'\\n    );\\n\\n    setString(\\n      keccak256(abi.encode(_record.uuid, _record.ecosystem.daoAddress, 'name')),\\n      _record.name\\n    );\\n    setString(\\n      keccak256(abi.encode(_record.uuid, _record.ecosystem.daoAddress, 'symbol')),\\n      _record.symbol\\n    );\\n    setUint(\\n      keccak256(abi.encode(_record.uuid, _record.ecosystem.daoAddress, 'eByL')),\\n      _record.eByL\\n    );\\n    setUint(\\n      keccak256(abi.encode(_record.uuid, _record.ecosystem.daoAddress, 'elasticity')),\\n      _record.elasticity\\n    );\\n    setUint(keccak256(abi.encode(_record.uuid, _record.ecosystem.daoAddress, 'k')), _record.k);\\n    setUint(\\n      keccak256(abi.encode(_record.uuid, _record.ecosystem.daoAddress, 'lambda')),\\n      _record.lambda\\n    );\\n    setUint(keccak256(abi.encode(_record.uuid, _record.ecosystem.daoAddress, 'm')), _record.m);\\n    setUint(\\n      keccak256(abi.encode(_record.uuid, _record.ecosystem.daoAddress, 'maxLambdaPurchase')),\\n      _record.maxLambdaPurchase\\n    );\\n\\n    setBool(keccak256(abi.encode(_record.uuid, _record.ecosystem.daoAddress, 'exists')), true);\\n\\n    emit Serialized(_record.uuid);\\n  }\\n\\n  function updateNumberOfTokenHolders(Instance memory _record, uint256 numberOfTokenHolders)\\n    external\\n    nonReentrant\\n  {\\n    require(\\n      msg.sender == _record.uuid && _exists(_record.uuid, _record.ecosystem.daoAddress),\\n      'ElasticDAO: Unauthorized'\\n    );\\n\\n    setUint(\\n      keccak256(abi.encode(_record.uuid, _record.ecosystem.daoAddress, 'numberOfTokenHolders')),\\n      numberOfTokenHolders\\n    );\\n  }\\n\\n  function _exists(address _uuid, address _daoAddress) internal view returns (bool) {\\n    return getBool(keccak256(abi.encode(_uuid, _daoAddress, 'exists')));\\n  }\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"src/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.2;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a, 'SafeMath: subtraction overflow');\\n    uint256 c = a - b;\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    uint256 c = a / b;\\n    require(c > 0, 'SafeMath: division by zero');\\n\\n    return c;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/models/EternalModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLv3\\npragma solidity 0.7.2;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Implementation of Eternal Storage for ElasticDAO -\\n * - (https://fravoll.github.io/solidity-patterns/eternal_storage.html)\\n * @author ElasticDAO - https://ElasticDAO.org\\n * @notice This contract is used for storing contract network data\\n * @dev ElasticDAO network contracts can read/write from this contract\\n */\\ncontract EternalModel {\\n  struct Storage {\\n    mapping(bytes32 => address) addressStorage;\\n    mapping(bytes32 => bool) boolStorage;\\n    mapping(bytes32 => bytes) bytesStorage;\\n    mapping(bytes32 => int256) intStorage;\\n    mapping(bytes32 => string) stringStorage;\\n    mapping(bytes32 => uint256) uIntStorage;\\n  }\\n\\n  Storage internal s;\\n\\n  /**\\n   * @notice Getter Functions\\n   */\\n\\n  /**\\n   * @notice Gets stored contract data in unit256 format\\n   * @param _key bytes32 location should be keccak256 and abi.encodePacked\\n   * @return uint256 _value from storage _key location\\n   */\\n  function getUint(bytes32 _key) internal view returns (uint256) {\\n    return s.uIntStorage[_key];\\n  }\\n\\n  /**\\n   * @notice Get stored contract data in string format\\n   * @param _key bytes32 location should be keccak256 and abi.encodePacked\\n   * @return string _value from storage _key location\\n   */\\n  function getString(bytes32 _key) internal view returns (string memory) {\\n    return s.stringStorage[_key];\\n  }\\n\\n  /**\\n   * @notice Get stored contract data in address format\\n   * @param _key bytes32 location should be keccak256 and abi.encodePacked\\n   * @return address _value from storage _key location\\n   */\\n  function getAddress(bytes32 _key) internal view returns (address) {\\n    return s.addressStorage[_key];\\n  }\\n\\n  /**\\n   * @notice Get stored contract data in bool format\\n   * @param _key bytes32 location should be keccak256 and abi.encodePacked\\n   * @return bool _value from storage _key location\\n   */\\n  function getBool(bytes32 _key) internal view returns (bool) {\\n    return s.boolStorage[_key];\\n  }\\n\\n  /**\\n   * @notice Setters Functions\\n   */\\n\\n  /**\\n   * @notice Store contract data in uint256 format\\n   * @dev restricted to latest ElasticDAO Networks contracts\\n   * @param _key bytes32 location should be keccak256 and abi.encodePacked\\n   * @param _value uint256 value\\n   */\\n  function setUint(bytes32 _key, uint256 _value) internal {\\n    s.uIntStorage[_key] = _value;\\n  }\\n\\n  /**\\n   * @notice Store contract data in string format\\n   * @dev restricted to latest ElasticDAO Networks contracts\\n   * @param _key bytes32 location should be keccak256 and abi.encodePacked\\n   * @param _value string value\\n   */\\n  function setString(bytes32 _key, string memory _value) internal {\\n    s.stringStorage[_key] = _value;\\n  }\\n\\n  /**\\n   * @notice Store contract data in address format\\n   * @dev restricted to latest ElasticDAO Networks contracts\\n   * @param _key bytes32 location should be keccak256 and abi.encodePacked\\n   * @param _value address value\\n   */\\n  function setAddress(bytes32 _key, address _value) internal {\\n    s.addressStorage[_key] = _value;\\n  }\\n\\n  /**\\n   * @notice Store contract data in bool format\\n   * @dev restricted to latest ElasticDAO Networks contracts\\n   * @param _key bytes32 location should be keccak256 and abi.encodePacked\\n   * @param _value bool value\\n   */\\n  function setBool(bytes32 _key, bool _value) internal {\\n    s.boolStorage[_key] = _value;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/tokens/ElasticGovernanceToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLv3\\npragma solidity 0.7.2;\\npragma experimental ABIEncoderV2;\\n\\nimport '../interfaces/IElasticToken.sol';\\n\\nimport '../libraries/ElasticMath.sol';\\n\\nimport '../core/ElasticDAO.sol';\\nimport '../models/DAO.sol';\\nimport '../models/Ecosystem.sol';\\nimport '../models/Token.sol';\\nimport '../models/TokenHolder.sol';\\n\\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\\n\\n/**\\n * @dev ElasticGovernanceToken contract outlines and defines all the functionality\\n * of an ElasticGovernanceToken and also serves as it's storage\\n */\\ncontract ElasticGovernanceToken is IElasticToken, ReentrancyGuard {\\n  address public burner;\\n  address public daoAddress;\\n  address public ecosystemModelAddress;\\n  address public minter;\\n  bool public initialized;\\n\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  modifier onlyDAO() {\\n    require(msg.sender == daoAddress, 'ElasticDAO: Not authorized');\\n    _;\\n  }\\n\\n  modifier onlyDAOorBurner() {\\n    require(msg.sender == daoAddress || msg.sender == burner, 'ElasticDAO: Not authorized');\\n    _;\\n  }\\n\\n  modifier onlyDAOorMinter() {\\n    require(msg.sender == daoAddress || msg.sender == minter, 'ElasticDAO: Not authorized');\\n    _;\\n  }\\n\\n  /**\\n   * @notice initializes the ElasticGovernanceToken\\n   *\\n   * @param _burner - the address which can burn tokens\\n   * @param _minter - the address which can mint tokens\\n   * @param _ecosystem - Ecosystem Instance\\n   * @param _token - Token Instance\\n   *\\n   * @dev Requirements:\\n   * - The token should not already be initialized\\n   * - The address of the burner cannot be zero\\n   * - The address of the deployed ElasticDAO cannot be zero\\n   * - The address of the ecosystemModelAddress cannot be zero\\n   * - The address of the minter cannot be zero\\n   *\\n   * @return bool\\n   */\\n  function initialize(\\n    address _burner,\\n    address _minter,\\n    Ecosystem.Instance memory _ecosystem,\\n    Token.Instance memory _token\\n  ) external nonReentrant returns (Token.Instance memory) {\\n    require(initialized == false, 'ElasticDAO: Already initialized');\\n    require(_burner != address(0), 'ElasticDAO: Address Zero');\\n    require(_ecosystem.daoAddress != address(0), 'ElasticDAO: Address Zero');\\n    require(_ecosystem.ecosystemModelAddress != address(0), 'ElasticDAO: Address Zero');\\n    require(_minter != address(0), 'ElasticDAO: Address Zero');\\n\\n    initialized = true;\\n    burner = _burner;\\n    daoAddress = _ecosystem.daoAddress;\\n    ecosystemModelAddress = _ecosystem.ecosystemModelAddress;\\n    minter = _minter;\\n\\n    Token tokenStorage = Token(_ecosystem.tokenModelAddress);\\n    tokenStorage.serialize(_token);\\n\\n    return _token;\\n  }\\n\\n  /**\\n   * @notice Returns the remaining number of tokens that @param _spender will be\\n   * allowed to spend on behalf of @param _owner through {transferFrom}. This is\\n   * zero by default\\n   *\\n   * @param _spender - the address of the spender\\n   * @param _owner - the address of the owner\\n   *\\n   * @dev This value changes when {approve} or {transferFrom} are called\\n   *\\n   * @return uint256\\n   */\\n  function allowance(address _owner, address _spender) external view override returns (uint256) {\\n    return _allowances[_owner][_spender];\\n  }\\n\\n  /**\\n   * @notice Sets @param _amount as the allowance of @param _spender over the caller's tokens\\n   *\\n   * @param _spender - the address of the spender\\n   *\\n   * @dev\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * @dev Emits an {Approval} event\\n   *\\n   * @return bool\\n   */\\n  function approve(address _spender, uint256 _amount)\\n    external\\n    override\\n    nonReentrant\\n    returns (bool)\\n  {\\n    _approve(msg.sender, _spender, _amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Returns the amount of tokens owned by @param _account using ElasticMath\\n   *\\n   * @param _account - address of the account\\n   *\\n   * @dev the number of tokens is given by:\\n   * t = lambda * m * k\\n   *\\n   * t - number of tokens\\n   * m - lambda modifier - it's value increases every time someone joins the DAO\\n   * k - constant token multiplier - it increases the number of tokens\\n   *  that each member of the DAO has with respect to their lambda\\n   *\\n   * Further math and documentaion of 't' can be found at ../libraries/ElasticMath.sol\\n   *\\n   * @return uint256\\n   */\\n  function balanceOf(address _account) external view override returns (uint256) {\\n    Token.Instance memory token = _getToken();\\n    TokenHolder.Instance memory tokenHolder = _getTokenHolder(_account);\\n    uint256 t = ElasticMath.t(tokenHolder.lambda, token.k, token.m);\\n\\n    return t;\\n  }\\n\\n  /**\\n   * @notice Returns the amount of shares ( lambda ) owned by _account.\\n   *\\n   * @param _account - address of the account\\n   *\\n   * @return lambda uint256 - lambda is the number of shares\\n   */\\n  function balanceOfInShares(address _account) external view override returns (uint256) {\\n    TokenHolder.Instance memory tokenHolder = _getTokenHolder(_account);\\n    return tokenHolder.lambda;\\n  }\\n\\n  /**\\n   * @notice Returns the amount of tokens @param _account can vote with, using ElasticMath\\n   *\\n   * @param _account - the address of the account\\n   *\\n   * @dev checks if @param _account has more or less lambda than maxVotingLambda,\\n   * based on which number of tokens (t) @param _account can vote with is calculated.\\n   * Further math and documentaion of 't' can be found at ../libraries/ElasticMath.sol\\n   *\\n   * @return balance uint256 numberOfTokens (t)\\n   */\\n  function balanceOfVoting(address _account) external view returns (uint256 balance) {\\n    Token.Instance memory token = _getToken();\\n    TokenHolder.Instance memory tokenHolder = _getTokenHolder(_account);\\n    uint256 maxVotingLambda = _getDAO().maxVotingLambda;\\n\\n    if (tokenHolder.lambda > maxVotingLambda) {\\n      return ElasticMath.t(maxVotingLambda, token.k, token.m);\\n    } else {\\n      return ElasticMath.t(tokenHolder.lambda, token.k, token.m);\\n    }\\n  }\\n\\n  /**\\n   * @notice Reduces the balance(tokens) of @param _account by  _amount\\n   *\\n   * @param _account address of the account\\n   *\\n   * @param _amount - the amount by which the number of tokens is to be reduced\\n   *\\n   * @return bool\\n   */\\n  function burn(address _account, uint256 _amount)\\n    external\\n    override\\n    onlyDAOorBurner\\n    nonReentrant\\n    returns (bool)\\n  {\\n    _burn(_account, _amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Reduces the balance(lambda) of @param _account by  _amount\\n   *\\n   * @param _account - address of the account\\n   *\\n   * @param _amount - the amount by which the number of shares has to be reduced\\n   *\\n   * @return bool\\n   */\\n  function burnShares(address _account, uint256 _amount)\\n    external\\n    override\\n    onlyDAOorBurner\\n    nonReentrant\\n    returns (bool)\\n  {\\n    _burnShares(_account, _amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @notice returns the number of decimals\\n   *\\n   * @return 18\\n   */\\n  function decimals() external pure returns (uint256) {\\n    return 18;\\n  }\\n\\n  /**\\n   * @notice decreases the allowance of @param _spender by _subtractedValue\\n   *\\n   * @param _spender - address of the spender\\n   * @param _subtractedValue - the value the allowance has to be decreased by\\n   *\\n   * @dev Requirement:\\n   * Allowance cannot be lower than 0\\n   *\\n   * @return bool\\n   */\\n  function decreaseAllowance(address _spender, uint256 _subtractedValue)\\n    external\\n    nonReentrant\\n    returns (bool)\\n  {\\n    uint256 newAllowance = SafeMath.sub(_allowances[msg.sender][_spender], _subtractedValue);\\n    _approve(msg.sender, _spender, newAllowance);\\n    return true;\\n  }\\n\\n  /**\\n   * @notice increases the allowance of @param _spender by _addedValue\\n   *\\n   * @param _spender - address of the spender\\n   * @param _addedValue - the value the allowance has to be increased by\\n   *\\n   * @return bool\\n   */\\n  function increaseAllowance(address _spender, uint256 _addedValue)\\n    external\\n    nonReentrant\\n    returns (bool)\\n  {\\n    _approve(msg.sender, _spender, SafeMath.add(_allowances[msg.sender][_spender], _addedValue));\\n    return true;\\n  }\\n\\n  /**\\n   * @dev mints @param _amount tokens for @param _account\\n   * @param _account - the address of the account for whom the token have to be minted to\\n   * @param _amount - the amount of tokens to be minted\\n   * @return bool\\n   */\\n  function mint(address _account, uint256 _amount)\\n    external\\n    override\\n    onlyDAOorMinter\\n    nonReentrant\\n    returns (bool)\\n  {\\n    _mint(_account, _amount);\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev mints @param _amount of shares for @param _account\\n   * @param _account address of the account\\n   * @param _amount - the amount of shares to be minted\\n   * @return bool\\n   */\\n  function mintShares(address _account, uint256 _amount)\\n    external\\n    override\\n    onlyDAOorMinter\\n    nonReentrant\\n    returns (bool)\\n  {\\n    _mintShares(_account, _amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   * @return string - name of the token\\n   */\\n  function name() external view returns (string memory) {\\n    return _getToken().name;\\n  }\\n\\n  /**\\n   * @notice Returns the number of token holders of ElasticGovernanceToken\\n   *\\n   * @return uint256 numberOfTokenHolders\\n   */\\n  function numberOfTokenHolders() external view override returns (uint256) {\\n    return _getToken().numberOfTokenHolders;\\n  }\\n\\n  /**\\n   * @notice sets the burner of the ElasticGovernanceToken\\n   * a Burner is an address that can burn tokens(reduce the amount of tokens in circulation)\\n   *\\n   * @param _burner - the address of the burner\\n   *\\n   * @dev Requirement:\\n   * - Address of the burner cannot be zero address\\n   *\\n   * @return bool\\n   */\\n  function setBurner(address _burner) external onlyDAO nonReentrant returns (bool) {\\n    require(_burner != address(0), 'ElasticDAO: Address Zero');\\n\\n    burner = _burner;\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @notice sets the minter of the ElasticGovernanceToken\\n   * a Minter is an address that can mint tokens(increase the amount of tokens in circulation)\\n   *\\n   * @param _minter - address of the minter\\n   *\\n   * @dev Requirement:\\n   * - Address of the minter cannot be zero address\\n   *\\n   * @return bool\\n   */\\n  function setMinter(address _minter) external onlyDAO nonReentrant returns (bool) {\\n    require(_minter != address(0), 'ElasticDAO: Address Zero');\\n\\n    minter = _minter;\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token, usually a shorter version of the\\n   * name.\\n   *\\n   * @return string - the symbol of the token\\n   */\\n  function symbol() external view returns (string memory) {\\n    return _getToken().symbol;\\n  }\\n\\n  /**\\n   * @notice returns the totalSupply of tokens in the DAO\\n   *\\n   * @dev\\n   * t - the total number of tokens in the DAO\\n   * lambda - the total number of shares outstanding in the DAO currently\\n   * m - current value of the share modifier\\n   * k - constant\\n   * t = ( lambda * m * k )\\n   * Further math and documentaion of 't' can be found at ../libraries/ElasticMath.sol\\n   *\\n   * @return uint256 - the value of t\\n   */\\n  function totalSupply() external view override returns (uint256) {\\n    Token.Instance memory token = _getToken();\\n    return ElasticMath.t(token.lambda, token.k, token.m);\\n  }\\n\\n  /**\\n   * @notice Returns the current lambda value\\n   *\\n   * @return uint256 lambda\\n   */\\n  function totalSupplyInShares() external view override returns (uint256) {\\n    Token.Instance memory token = _getToken();\\n    return token.lambda;\\n  }\\n\\n  /**\\n   * @dev Moves @param _amount tokens from the caller's account to @param _to address\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded\\n   *\\n   * Emits a {Transfer} event\\n   * @return bool\\n   */\\n  function transfer(address _to, uint256 _amount) external override nonReentrant returns (bool) {\\n    _transfer(msg.sender, _to, _amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Moves @param _amount tokens from @param _from to @param _to using the\\n   * allowance mechanism. @param _amount is then deducted from the caller's\\n   * allowance\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded\\n   *\\n   * Emits a {Transfer} event\\n   * @return bool\\n   */\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _amount\\n  ) external override nonReentrant returns (bool) {\\n    require(msg.sender == _from || _amount <= _allowances[_from][msg.sender], 'ERC20: Bad Caller');\\n\\n    if (msg.sender != _from && _allowances[_from][msg.sender] != uint256(-1)) {\\n      _allowances[_from][msg.sender] = SafeMath.sub(_allowances[_from][msg.sender], _amount);\\n      emit Approval(_from, msg.sender, _allowances[_from][msg.sender]);\\n    }\\n\\n    _transfer(_from, _to, _amount);\\n    return true;\\n  }\\n\\n  // Private\\n\\n  function _approve(\\n    address _owner,\\n    address _spender,\\n    uint256 _amount\\n  ) internal {\\n    require(_owner != address(0), 'ERC20: approve from the zero address');\\n    require(_spender != address(0), 'ERC20: approve to the zero address');\\n\\n    _allowances[_owner][_spender] = _amount;\\n\\n    emit Approval(_owner, _spender, _amount);\\n  }\\n\\n  function _burn(address _account, uint256 _deltaT) internal {\\n    Token.Instance memory token = _getToken();\\n    uint256 deltaLambda = ElasticMath.lambdaFromT(_deltaT, token.k, token.m);\\n    _burnShares(_account, deltaLambda);\\n  }\\n\\n  function _burnShares(address _account, uint256 _deltaLambda) internal {\\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\\n    Token tokenStorage = Token(ecosystem.tokenModelAddress);\\n    Token.Instance memory token = tokenStorage.deserialize(address(this), ecosystem);\\n    TokenHolder.Instance memory tokenHolder = _getTokenHolder(_account);\\n    bool alreadyTokenHolder = tokenHolder.lambda > 0;\\n\\n    uint256 deltaT = ElasticMath.t(_deltaLambda, token.k, token.m);\\n\\n    tokenHolder = _updateBalance(tokenHolder, false, _deltaLambda);\\n\\n    token.lambda = SafeMath.sub(token.lambda, _deltaLambda);\\n    tokenStorage.serialize(token);\\n\\n    TokenHolder tokenHolderStorage = TokenHolder(ecosystem.tokenHolderModelAddress);\\n    tokenHolderStorage.serialize(tokenHolder);\\n    _updateNumberOfTokenHolders(alreadyTokenHolder, token, tokenHolder, tokenStorage);\\n    emit Transfer(_account, address(0), deltaT);\\n  }\\n\\n  function _mint(address _account, uint256 _deltaT) internal {\\n    Token.Instance memory token = _getToken();\\n    uint256 deltaLambda = ElasticMath.lambdaFromT(_deltaT, token.k, token.m);\\n    _mintShares(_account, deltaLambda);\\n  }\\n\\n  function _mintShares(address _account, uint256 _deltaLambda) internal {\\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\\n    Token tokenStorage = Token(ecosystem.tokenModelAddress);\\n    Token.Instance memory token = tokenStorage.deserialize(address(this), ecosystem);\\n    TokenHolder.Instance memory tokenHolder = _getTokenHolder(_account);\\n    bool alreadyTokenHolder = tokenHolder.lambda > 0;\\n\\n    uint256 deltaT = ElasticMath.t(_deltaLambda, token.k, token.m);\\n\\n    tokenHolder = _updateBalance(tokenHolder, true, _deltaLambda);\\n\\n    token.lambda = SafeMath.add(token.lambda, _deltaLambda);\\n    tokenStorage.serialize(token);\\n\\n    TokenHolder tokenHolderStorage = TokenHolder(ecosystem.tokenHolderModelAddress);\\n    tokenHolderStorage.serialize(tokenHolder);\\n    _updateNumberOfTokenHolders(alreadyTokenHolder, token, tokenHolder, tokenStorage);\\n\\n    emit Transfer(address(0), _account, deltaT);\\n  }\\n\\n  function _transfer(\\n    address _from,\\n    address _to,\\n    uint256 _deltaT\\n  ) internal {\\n    require(_from != _to, 'ElasticDAO: Can not transfer to self');\\n\\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\\n    Token tokenStorage = Token(ecosystem.tokenModelAddress);\\n    Token.Instance memory token = tokenStorage.deserialize(address(this), ecosystem);\\n\\n    TokenHolder.Instance memory fromTokenHolder = _getTokenHolder(_from);\\n    TokenHolder.Instance memory toTokenHolder = _getTokenHolder(_to);\\n    bool fromAlreadyTokenHolder = fromTokenHolder.lambda > 0;\\n    bool toAlreadyTokenHolder = toTokenHolder.lambda > 0;\\n\\n    uint256 deltaLambda = ElasticMath.lambdaFromT(_deltaT, token.k, token.m);\\n    uint256 deltaT = ElasticMath.t(deltaLambda, token.k, token.m);\\n\\n    fromTokenHolder = _updateBalance(fromTokenHolder, false, deltaLambda);\\n    toTokenHolder = _updateBalance(toTokenHolder, true, deltaLambda);\\n\\n    TokenHolder tokenHolderStorage = TokenHolder(ecosystem.tokenHolderModelAddress);\\n    tokenHolderStorage.serialize(fromTokenHolder);\\n    tokenHolderStorage.serialize(toTokenHolder);\\n    _updateNumberOfTokenHolders(fromAlreadyTokenHolder, token, fromTokenHolder, tokenStorage);\\n    _updateNumberOfTokenHolders(toAlreadyTokenHolder, token, toTokenHolder, tokenStorage);\\n\\n    emit Transfer(_from, _to, deltaT);\\n  }\\n\\n  function _updateBalance(\\n    TokenHolder.Instance memory _tokenHolder,\\n    bool _isIncreasing,\\n    uint256 _deltaLambda\\n  ) internal pure returns (TokenHolder.Instance memory) {\\n    if (_isIncreasing) {\\n      _tokenHolder.lambda = SafeMath.add(_tokenHolder.lambda, _deltaLambda);\\n    } else {\\n      _tokenHolder.lambda = SafeMath.sub(_tokenHolder.lambda, _deltaLambda);\\n    }\\n\\n    return _tokenHolder;\\n  }\\n\\n  function _updateNumberOfTokenHolders(\\n    bool alreadyTokenHolder,\\n    Token.Instance memory token,\\n    TokenHolder.Instance memory tokenHolder,\\n    Token tokenStorage\\n  ) internal {\\n    if (tokenHolder.lambda > 0 && alreadyTokenHolder == false) {\\n      tokenStorage.updateNumberOfTokenHolders(token, SafeMath.add(token.numberOfTokenHolders, 1));\\n    }\\n\\n    if (tokenHolder.lambda == 0 && alreadyTokenHolder) {\\n      tokenStorage.updateNumberOfTokenHolders(token, SafeMath.sub(token.numberOfTokenHolders, 1));\\n    }\\n  }\\n\\n  // Private Getters\\n\\n  function _getDAO() internal view returns (DAO.Instance memory) {\\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\\n    return DAO(ecosystem.daoModelAddress).deserialize(daoAddress, ecosystem);\\n  }\\n\\n  function _getEcosystem() internal view returns (Ecosystem.Instance memory) {\\n    return Ecosystem(ecosystemModelAddress).deserialize(daoAddress);\\n  }\\n\\n  function _getTokenHolder(address _account) internal view returns (TokenHolder.Instance memory) {\\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\\n    return\\n      TokenHolder(ecosystem.tokenHolderModelAddress).deserialize(\\n        _account,\\n        ecosystem,\\n        Token(ecosystem.tokenModelAddress).deserialize(address(this), ecosystem)\\n      );\\n  }\\n\\n  function _getToken() internal view returns (Token.Instance memory) {\\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\\n    return Token(ecosystem.tokenModelAddress).deserialize(address(this), ecosystem);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IElasticToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLv3\\npragma solidity 0.7.2;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IElasticToken is IERC20 {\\n  /**\\n   * @dev Returns the amount of shares owned by @param _account.\\n   * @param _account - address of the account\\n   * @return lambda uint256 - lambda is the number of shares\\n   */\\n  function balanceOfInShares(address _account) external view returns (uint256 lambda);\\n\\n  /**\\n   * @dev Reduces the balance(tokens) of @param _account by @param _amount\\n   * @param _account address of the account\\n   * @param _amount - the amount by which the number of tokens has to be reduced\\n   * @return bool\\n   */\\n  function burn(address _account, uint256 _amount) external returns (bool);\\n\\n  /**\\n   * @dev Reduces the balance(shares) of @param _account by @param _amount\\n   * @param _account - address of the account\\n   * @param _amount - the amount by which the number of shares has to be reduced\\n   * @return bool\\n   */\\n  function burnShares(address _account, uint256 _amount) external returns (bool);\\n\\n  /**\\n   * @dev mints @param _amount tokens for @param _account\\n   * @param _account - the address of the account for whom the token have to be minted to\\n   * @param _amount - the amount of tokens to be minted\\n   * @return bool\\n   */\\n  function mint(address _account, uint256 _amount) external returns (bool);\\n\\n  /**\\n   * @dev mints @param _amount of shares for @param _account\\n   * @param _account address of the account\\n   * @param _amount - the amount of shares to be minted\\n   * @return bool\\n   */\\n  function mintShares(address _account, uint256 _amount) external returns (bool);\\n\\n  /**\\n   * @dev returns total number of token holders\\n   * @return uint256\\n   */\\n  function numberOfTokenHolders() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the total supply of shares in the DAO\\n   * @return lambda uint256 - lambda is the number of shares\\n   */\\n  function totalSupplyInShares() external view returns (uint256 lambda);\\n}\\n\"\r\n    },\r\n    \"src/models/TokenHolder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLv3\\npragma solidity 0.7.2;\\npragma experimental ABIEncoderV2;\\n\\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\\n\\nimport './Ecosystem.sol';\\nimport './EternalModel.sol';\\nimport './Token.sol';\\n\\n/**\\n * @title a data storage for Token holders\\n * @author ElasticDAO - https://ElasticDAO.org\\n * @notice This contract is used for storing token data\\n * @dev ElasticDAO network contracts can read/write from this contract\\n * Serialize - Translation of data from the concerned struct to key-value pairs\\n * Deserialize - Translation of data from the key-value pairs to a struct\\n */\\ncontract TokenHolder is EternalModel, ReentrancyGuard {\\n  struct Instance {\\n    address account;\\n    uint256 lambda;\\n    Ecosystem.Instance ecosystem;\\n    Token.Instance token;\\n  }\\n\\n  event Serialized(address indexed account, address indexed token);\\n\\n  function deserialize(\\n    address _account,\\n    Ecosystem.Instance memory _ecosystem,\\n    Token.Instance memory _token\\n  ) external view returns (Instance memory record) {\\n    record.account = _account;\\n    record.ecosystem = _ecosystem;\\n    record.token = _token;\\n\\n    if (_exists(_account, _token)) {\\n      record.lambda = getUint(keccak256(abi.encode(record.token.uuid, record.account, 'lambda')));\\n    }\\n\\n    return record;\\n  }\\n\\n  function exists(address _account, Token.Instance memory _token) external view returns (bool) {\\n    return _exists(_account, _token);\\n  }\\n\\n  /**\\n   * @dev serializes Instance struct\\n   * @param _record Instance\\n   */\\n  function serialize(Instance memory _record) external nonReentrant {\\n    require(msg.sender == _record.token.uuid, 'ElasticDAO: Unauthorized');\\n\\n    setUint(keccak256(abi.encode(_record.token.uuid, _record.account, 'lambda')), _record.lambda);\\n    setBool(keccak256(abi.encode(_record.token.uuid, _record.account, 'exists')), true);\\n\\n    emit Serialized(_record.account, _record.token.uuid);\\n  }\\n\\n  function _exists(address _account, Token.Instance memory _token) internal view returns (bool) {\\n    return getBool(keccak256(abi.encode(_token.uuid, _account, 'exists')));\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@pie-dao/proxy/contracts/PProxyStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.1;\\r\\n\\r\\ncontract PProxyStorage {\\r\\n\\r\\n    function readBool(bytes32 _key) public view returns(bool) {\\r\\n        return storageRead(_key) == bytes32(uint256(1));\\r\\n    }\\r\\n\\r\\n    function setBool(bytes32 _key, bool _value) internal {\\r\\n        if(_value) {\\r\\n            storageSet(_key, bytes32(uint256(1)));\\r\\n        } else {\\r\\n            storageSet(_key, bytes32(uint256(0)));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function readAddress(bytes32 _key) public view returns(address) {\\r\\n        return bytes32ToAddress(storageRead(_key));\\r\\n    }\\r\\n\\r\\n    function setAddress(bytes32 _key, address _value) internal {\\r\\n        storageSet(_key, addressToBytes32(_value));\\r\\n    }\\r\\n\\r\\n    function storageRead(bytes32 _key) public view returns(bytes32) {\\r\\n        bytes32 value;\\r\\n        //solium-disable-next-line security/no-inline-assembly\\r\\n        assembly {\\r\\n            value := sload(_key)\\r\\n        }\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    function storageSet(bytes32 _key, bytes32 _value) internal {\\r\\n        // targetAddress = _address;  // No!\\r\\n        bytes32 implAddressStorageKey = _key;\\r\\n        //solium-disable-next-line security/no-inline-assembly\\r\\n        assembly {\\r\\n            sstore(implAddressStorageKey, _value)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function bytes32ToAddress(bytes32 _value) public pure returns(address) {\\r\\n        return address(uint160(uint256(_value)));\\r\\n    }\\r\\n\\r\\n    function addressToBytes32(address _value) public pure returns(bytes32) {\\r\\n        return bytes32(uint256(_value));\\r\\n    }\\r\\n\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"daoAddress\",\"type\":\"address\"}],\"name\":\"DeployedDAO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"elasticDAOImplementationAddress\",\"type\":\"address\"}],\"name\":\"ElasticDAOImplementationAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"}],\"name\":\"FeeAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeesCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagerUpdated\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"collectFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_summoners\",\"type\":\"address[]\"},{\"internalType\":\"string\",\"name\":\"_nameOfDAO\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_nameOfToken\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_eByL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_elasticity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_k\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxLambdaPurchase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxVotingLambda\",\"type\":\"uint256\"}],\"name\":\"deployDAOAndToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deployedDAOAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployedDAOCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ecosystemModelAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"elasticDAOImplementationAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ecosystemModelAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_elasticDAOImplementationAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_elasticDAOImplementationAddress\",\"type\":\"address\"}],\"name\":\"updateElasticDAOImplementationAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"updateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"updateFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newManager\",\"type\":\"address\"}],\"name\":\"updateManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ElasticDAOFactory","CompilerVersion":"v0.7.2+commit.51b20bc0","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}