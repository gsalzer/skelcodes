{"status":"1","message":"OK","result":[{"SourceCode":"// hevm: flattened sources of src/lender/coordinator.sol\r\npragma solidity >=0.5.15 >=0.5.15 <0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n////// lib/tinlake-auth/lib/ds-note/src/note.sol\r\n/// note.sol -- the `note' modifier, for logging calls as events\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n/* pragma solidity >=0.5.15; */\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint256           wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n        uint256 wad;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n            wad := callvalue()\r\n        }\r\n\r\n        _;\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\r\n    }\r\n}\r\n\r\n////// lib/tinlake-auth/src/auth.sol\r\n// Copyright (C) Centrifuge 2020, based on MakerDAO dss https://github.com/makerdao/dss\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity >=0.5.15 <0.6.0; */\r\n\r\n/* import \"ds-note/note.sol\"; */\r\n\r\ncontract Auth is DSNote {\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) public auth note { wards[usr] = 1; }\r\n    function deny(address usr) public auth note { wards[usr] = 0; }\r\n    modifier auth { require(wards[msg.sender] == 1); _; }\r\n}\r\n\r\n////// lib/tinlake-math/src/math.sol\r\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity >=0.5.15 <0.6.0; */\r\n\r\ncontract Math {\r\n    uint256 constant ONE = 10 ** 27;\r\n\r\n    function safeAdd(uint x, uint y) public pure returns (uint z) {\r\n        require((z = x + y) >= x, \"safe-add-failed\");\r\n    }\r\n\r\n    function safeSub(uint x, uint y) public pure returns (uint z) {\r\n        require((z = x - y) <= x, \"safe-sub-failed\");\r\n    }\r\n\r\n    function safeMul(uint x, uint y) public pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"safe-mul-failed\");\r\n    }\r\n\r\n    function safeDiv(uint x, uint y) public pure returns (uint z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function rmul(uint x, uint y) public pure returns (uint z) {\r\n        z = safeMul(x, y) / ONE;\r\n    }\r\n\r\n    function rdiv(uint x, uint y) public pure returns (uint z) {\r\n        require(y > 0, \"division by zero\");\r\n        z = safeAdd(safeMul(x, ONE), y / 2) / y;\r\n    }\r\n\r\n    function rdivup(uint x, uint y) internal pure returns (uint z) {\r\n        require(y > 0, \"division by zero\");\r\n        // always rounds up\r\n        z = safeAdd(safeMul(x, ONE), safeSub(y, 1)) / y;\r\n    }\r\n\r\n\r\n}\r\n\r\n////// src/fixed_point.sol\r\n// Copyright (C) 2020 Centrifuge\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity >=0.5.15 <0.6.0; */\r\n\r\ncontract FixedPoint {\r\n    struct Fixed27 {\r\n        uint value;\r\n    }\r\n}\r\n// Copyright (C) 2020 Centrifuge\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\n\r\ninterface EpochTrancheLike {\r\n    function epochUpdate(uint epochID, uint supplyFulfillment_,\r\n        uint redeemFulfillment_, uint tokenPrice_, uint epochSupplyCurrency, uint epochRedeemCurrency) external;\r\n    function closeEpoch() external returns(uint totalSupply, uint totalRedeem);\r\n    function payoutRequestedCurrency() external;\r\n}\r\n\r\ninterface ReserveLike {\r\n    function balance() external;\r\n}\r\n\r\ncontract AssessorLike is FixedPoint {\r\n    // definitions\r\n    function calcSeniorRatio(uint seniorAsset, uint NAV, uint reserve_) public pure returns(uint);\r\n    function calcSeniorAssetValue(uint seniorRedeem, uint seniorSupply,\r\n        uint currSeniorAsset, uint reserve_, uint nav_) public pure returns (uint seniorAsset);\r\n    function calcSeniorRatio(uint seniorRedeem, uint seniorSupply,\r\n        uint currSeniorAsset, uint newReserve, uint nav) public pure returns (uint seniorRatio);\r\n\r\n    // definitions based on assessor state\r\n    function calcSeniorTokenPrice(uint NAV, uint reserve) external returns(Fixed27 memory tokenPrice);\r\n    function calcJuniorTokenPrice(uint NAV, uint reserve) external returns(Fixed27 memory tokenPrice);\r\n\r\n    // get state\r\n    function maxReserve() external view returns(uint);\r\n    function calcUpdateNAV() external returns (uint);\r\n    function seniorDebt() external returns(uint);\r\n    function seniorBalance() external returns(uint);\r\n    function seniorRatioBounds() external view returns(Fixed27 memory minSeniorRatio, Fixed27 memory maxSeniorRatio);\r\n\r\n    function totalBalance() external returns(uint);\r\n    // change state\r\n    function changeBorrowAmountEpoch(uint currencyAmount) public;\r\n    function changeSeniorAsset(uint seniorSupply, uint seniorRedeem) external;\r\n    function changeSeniorAsset(uint seniorRatio, uint seniorSupply, uint seniorRedeem) external;\r\n}\r\n\r\n// The EpochCoordinator keeps track of the epochs and execute epochs them.\r\n// An epoch execution happens with the maximum amount of redeem and supply which still satisfies\r\n// all constraints or at least improve certain pool constraints.\r\n// In most cases all orders can be fulfilled with order maximum without violating any constraints.\r\n// If it is not possible to satisfy all orders at maximum the coordinators opens a submission period.\r\n// The problem of finding the maximum amount of supply and redeem orders which still satisfies all constraints\r\n// can be seen as a linear programming (linear optimization problem).\r\n// The optimal solution can be calculated off-chain\r\ncontract EpochCoordinator is Auth, Math, FixedPoint {\r\n    struct OrderSummary {\r\n        // all variables are stored in currency\r\n        uint  seniorRedeem;\r\n        uint  juniorRedeem;\r\n        uint  juniorSupply;\r\n        uint  seniorSupply;\r\n    }\r\n\r\n    modifier minimumEpochTimePassed {\r\n        require(safeSub(block.timestamp, lastEpochClosed) >= minimumEpochTime);\r\n        _;\r\n    }\r\n                        // timestamp last epoch closed\r\n    uint                public lastEpochClosed;\r\n                        // default minimum length of an epoch\r\n                        // (1 day, with 10 min buffer, so we can close the epochs automatically on a daily basis at the same time)\r\n    uint                public minimumEpochTime = 1 days - 10 minutes;\r\n\r\n    EpochTrancheLike    public juniorTranche;\r\n    EpochTrancheLike    public seniorTranche;\r\n\r\n    ReserveLike         public reserve;\r\n    AssessorLike        public assessor;\r\n\r\n    uint                public lastEpochExecuted;\r\n    uint                public currentEpoch;\r\n                        // current best solution submission for an epoch which satisfies all constraints\r\n    OrderSummary        public bestSubmission;\r\n                        // current best score of the best solution\r\n    uint                public bestSubScore;\r\n                        // flag which tracks if an submission period received a valid solution\r\n    bool                public gotFullValidSolution;\r\n                        // snapshot from the the orders in the tranches at epoch close\r\n    OrderSummary        public order;\r\n                        // snapshot from the senior token price at epoch close\r\n    Fixed27             public epochSeniorTokenPrice;\r\n                        // snapshot from the junior token price at epoch close\r\n    Fixed27             public epochJuniorTokenPrice;\r\n\r\n                        // snapshot from NAV (net asset value of the loans) at epoch close\r\n    uint                public epochNAV;\r\n                        // snapshot from the senior asset value at epoch close\r\n    uint                public epochSeniorAsset;\r\n                        // snapshot from reserve balance at epoch close\r\n    uint                public epochReserve;\r\n                        // flag which indicates if the coordinator is currently in a submission period\r\n    bool                public submissionPeriod;\r\n\r\n                        // weights of the scoring function\r\n                        // highest priority senior redeem and junior redeem before junior and senior supply\r\n    uint                public weightSeniorRedeem  = 1000000;\r\n    uint                public weightJuniorRedeem  =  100000;\r\n    uint                public weightJuniorSupply =   10000;\r\n    uint                public weightSeniorSupply =    1000;\r\n\r\n                        // challenge period end timestamp\r\n    uint                public minChallengePeriodEnd;\r\n                        // after a first valid solution is received others can submit better solutions\r\n                        // until challenge time is over\r\n    uint                public challengeTime;\r\n                        // if the current state is not healthy improvement submissions are allowed\r\n                        // ratio and reserve improvements receive score points\r\n                        // keeping track of the best improvements scores\r\n    uint                public bestRatioImprovement;\r\n    uint                public bestReserveImprovement;\r\n\r\n                        // flag for closing the pool (no new supplies allowed only redeem)\r\n    bool                public poolClosing = false;\r\n\r\n                        // constants\r\n    int                 public constant SUCCESS = 0;\r\n    int                 public constant NEW_BEST = 0;\r\n    int                 public constant ERR_CURRENCY_AVAILABLE = -1;\r\n    int                 public constant ERR_MAX_ORDER = -2;\r\n    int                 public constant ERR_MAX_RESERVE = - 3;\r\n    int                 public constant ERR_MIN_SENIOR_RATIO = -4;\r\n    int                 public constant ERR_MAX_SENIOR_RATIO = -5;\r\n    int                 public constant ERR_NOT_NEW_BEST = -6;\r\n    int                 public constant ERR_POOL_CLOSING = -7;\r\n    uint                public constant BIG_NUMBER = ONE * ONE;\r\n\r\n    uint                public constant IMPROVEMENT_WEIGHT =  10000;\r\n\r\n\r\n    constructor(uint challengeTime_) public {\r\n        wards[msg.sender] = 1;\r\n        challengeTime = challengeTime_;\r\n\r\n        lastEpochClosed = block.timestamp;\r\n        currentEpoch = 1;\r\n    }\r\n\r\n    function file(bytes32 name, uint value) public auth {\r\n        if(name == \"challengeTime\") {\r\n            challengeTime = value;\r\n        } else if (name == \"minimumEpochTime\") {\r\n            minimumEpochTime = value;\r\n        } else if (name == \"weightSeniorRedeem\") { weightSeniorRedeem = value;}\r\n          else if (name == \"weightJuniorRedeem\") { weightJuniorRedeem = value;}\r\n          else if (name == \"weightJuniorSupply\") { weightJuniorSupply = value;}\r\n          else if (name == \"weightSeniorSupply\") { weightSeniorSupply = value;}\r\n          else { revert(\"unkown-name\");}\r\n     }\r\n\r\n    /// sets the dependency to another contract\r\n    function depend (bytes32 contractName, address addr) public auth {\r\n        if (contractName == \"juniorTranche\") { juniorTranche = EpochTrancheLike(addr); }\r\n        else if (contractName == \"seniorTranche\") { seniorTranche = EpochTrancheLike(addr); }\r\n        else if (contractName == \"reserve\") { reserve = ReserveLike(addr); }\r\n        else if (contractName == \"assessor\") { assessor = AssessorLike(addr); }\r\n        else revert();\r\n    }\r\n\r\n    /// an epoch can be closed after a minimum epoch time has passed\r\n    /// closeEpoch creates a snapshot of the current lender state\r\n    /// if all orders can be fulfilled epoch is executed otherwise\r\n    /// submission period starts\r\n    function closeEpoch() external minimumEpochTimePassed {\r\n        require(submissionPeriod == false);\r\n        lastEpochClosed = block.timestamp;\r\n        currentEpoch = currentEpoch + 1;\r\n        reserve.balance();\r\n        assessor.changeBorrowAmountEpoch(0);\r\n\r\n        (uint orderJuniorSupply, uint orderJuniorRedeem) = juniorTranche.closeEpoch();\r\n        (uint orderSeniorSupply, uint orderSeniorRedeem) = seniorTranche.closeEpoch();\r\n        epochSeniorAsset = safeAdd(assessor.seniorDebt(), assessor.seniorBalance());\r\n\r\n        // create a snapshot of the current lender state\r\n\r\n        epochNAV = assessor.calcUpdateNAV();\r\n        epochReserve = assessor.totalBalance();\r\n        //  if no orders exist epoch can be executed without validation\r\n        if (orderSeniorRedeem == 0 && orderJuniorRedeem == 0 &&\r\n        orderSeniorSupply == 0 && orderJuniorSupply == 0) {\r\n\r\n            juniorTranche.epochUpdate(currentEpoch, 0, 0, 0, 0, 0);\r\n            seniorTranche.epochUpdate(currentEpoch, 0, 0, 0, 0, 0);\r\n            // assessor performs re-balancing\r\n            assessor.changeSeniorAsset(0, 0);\r\n            assessor.changeBorrowAmountEpoch(epochReserve);\r\n            lastEpochExecuted = safeAdd(lastEpochExecuted, 1);\r\n            return;\r\n        }\r\n\r\n        // calculate current token prices which are used for the execute\r\n\r\n        epochSeniorTokenPrice = assessor.calcSeniorTokenPrice(epochNAV, epochReserve);\r\n        epochJuniorTokenPrice = assessor.calcJuniorTokenPrice(epochNAV, epochReserve);\r\n        // start closing the pool if juniorTranche lost everything\r\n        // the flag will change the behaviour of the validate function for not allowing new supplies\r\n        if(epochJuniorTokenPrice.value == 0) {\r\n            poolClosing = true;\r\n        }\r\n\r\n        // convert redeem orders in token into currency\r\n        order.seniorRedeem = rmul(orderSeniorRedeem, epochSeniorTokenPrice.value);\r\n        order.juniorRedeem = rmul(orderJuniorRedeem, epochJuniorTokenPrice.value);\r\n        order.juniorSupply = orderJuniorSupply;\r\n        order.seniorSupply = orderSeniorSupply;\r\n\r\n        // epoch is executed if orders can be fulfilled to 100% without constraint violation\r\n        if (validate(order.seniorRedeem , order.juniorRedeem,\r\n            order.seniorSupply, order.juniorSupply) == SUCCESS) {\r\n            _executeEpoch(order.seniorRedeem, order.juniorRedeem,\r\n                orderSeniorSupply, orderJuniorSupply);\r\n            return;\r\n        }\r\n        // if 100% order fulfillment is not possible submission period starts\r\n        // challenge period time starts after first valid submission is received\r\n        submissionPeriod = true;\r\n    }\r\n\r\n\r\n    //// internal method to save new optimum\r\n    //// orders are expressed as currency\r\n    //// all parameter are 10^18\r\n    function _saveNewOptimum(uint seniorRedeem, uint juniorRedeem, uint juniorSupply,\r\n        uint seniorSupply, uint score) internal {\r\n\r\n        bestSubmission.seniorRedeem = seniorRedeem;\r\n        bestSubmission.juniorRedeem = juniorRedeem;\r\n        bestSubmission.juniorSupply = juniorSupply;\r\n        bestSubmission.seniorSupply = seniorSupply;\r\n\r\n        bestSubScore = score;\r\n    }\r\n\r\n\r\n    /// method to submit a solution for submission period\r\n    /// anybody can submit a solution for the current execution epoch\r\n    /// if solution satisfies all constraints (or at least improves an unhealthy state)\r\n    /// and has the highest score\r\n    function submitSolution(uint seniorRedeem, uint juniorRedeem,\r\n        uint juniorSupply, uint seniorSupply) public returns(int) {\r\n        require(submissionPeriod == true, \"submission-period-not-active\");\r\n\r\n        int valid = _submitSolution(seniorRedeem, juniorRedeem, juniorSupply, seniorSupply);\r\n\r\n        // if solution is the first valid for this epoch the challenge period starts\r\n        if(valid == SUCCESS && minChallengePeriodEnd == 0) {\r\n            minChallengePeriodEnd = safeAdd(block.timestamp, challengeTime);\r\n        }\r\n        return valid;\r\n    }\r\n\r\n    // internal method for submit solution\r\n    function _submitSolution(uint seniorRedeem, uint juniorRedeem,\r\n        uint juniorSupply, uint seniorSupply) internal returns(int) {\r\n\r\n        int valid = validate(seniorRedeem, juniorRedeem, seniorSupply, juniorSupply);\r\n\r\n        // every solution needs to satisfy all core constraints\r\n        // there is no exception\r\n        if(valid  == ERR_CURRENCY_AVAILABLE || valid == ERR_MAX_ORDER) {\r\n            // core constraint violated\r\n            return valid;\r\n        }\r\n\r\n        // all core constraints and all pool constraints are satisfied\r\n        if(valid == SUCCESS) {\r\n            uint score = scoreSolution(seniorRedeem, juniorRedeem, seniorSupply, juniorSupply);\r\n\r\n            if(gotFullValidSolution == false) {\r\n                gotFullValidSolution = true;\r\n                _saveNewOptimum(seniorRedeem, juniorRedeem, juniorSupply, seniorSupply, score);\r\n                // solution is new best => 0\r\n                return SUCCESS;\r\n            }\r\n\r\n            if (score < bestSubScore) {\r\n                // solution is not the best => -6\r\n                return ERR_NOT_NEW_BEST;\r\n            }\r\n\r\n            _saveNewOptimum(seniorRedeem, juniorRedeem, juniorSupply, seniorSupply, score);\r\n\r\n            // solution is new best => 0\r\n            return SUCCESS;\r\n        }\r\n\r\n        // proposed solution does not satisfy all pool constraints\r\n        // if we never received a solution which satisfies all constraints for this epoch\r\n        // we might accept it as an improvement\r\n        if (gotFullValidSolution == false) {\r\n            return _improveScore(seniorRedeem, juniorRedeem, juniorSupply, seniorSupply);\r\n        }\r\n\r\n        // proposed solution doesn't satisfy the pool constraints but a previous submission did\r\n        return ERR_NOT_NEW_BEST;\r\n    }\r\n\r\n    function absDistance(uint x, uint y) public pure returns(uint delta) {\r\n        if (x == y) {\r\n            // gas optimization: for avoiding an additional edge case of 0 distance\r\n            // distance is set to the smallest value possible\r\n            return 1;\r\n        }\r\n        if(x > y) {\r\n            return safeSub(x, y);\r\n        }\r\n        return safeSub(y, x);\r\n    }\r\n\r\n    function checkRatioInRange(Fixed27 memory ratio, Fixed27 memory minRatio,\r\n        Fixed27 memory maxRatio) public pure returns (bool) {\r\n        if (ratio.value >= minRatio.value && ratio.value <= maxRatio.value ) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// calculates the improvement score of a solution\r\n    function _improveScore(uint seniorRedeem, uint juniorRedeem,\r\n        uint juniorSupply, uint seniorSupply) internal returns(int) {\r\n        Fixed27 memory currSeniorRatio = Fixed27(assessor.calcSeniorRatio(epochSeniorAsset,\r\n            epochNAV, epochReserve));\r\n\r\n        int err = 0;\r\n        uint impScoreRatio = 0;\r\n        uint impScoreReserve = 0;\r\n\r\n        if (bestRatioImprovement == 0) {\r\n            // define no orders (current status) score as benchmark if no previous submission exists\r\n            // if the current state satisfies all pool constraints it has the highest score\r\n            (err, impScoreRatio, impScoreReserve) = scoreImprovement(currSeniorRatio, epochReserve);\r\n            saveNewImprovement(impScoreRatio, impScoreReserve);\r\n        }\r\n\r\n        uint newReserve = calcNewReserve(seniorRedeem, juniorRedeem, seniorSupply, juniorSupply);\r\n\r\n        Fixed27 memory newSeniorRatio = Fixed27(assessor.calcSeniorRatio(seniorRedeem, seniorSupply,\r\n            epochSeniorAsset, newReserve, epochNAV));\r\n\r\n        (err, impScoreRatio, impScoreReserve) = scoreImprovement(newSeniorRatio, newReserve);\r\n\r\n        if (err  == ERR_NOT_NEW_BEST) {\r\n            // solution is not the best => -1\r\n            return err;\r\n        }\r\n\r\n        saveNewImprovement(impScoreRatio, impScoreReserve);\r\n\r\n        // solution doesn't satisfy all pool constraints but improves the current violation\r\n        // improvement only gets 0 points only solutions in the feasible region receive more\r\n        _saveNewOptimum(seniorRedeem, juniorRedeem, juniorSupply, seniorSupply, 0);\r\n        return NEW_BEST;\r\n    }\r\n\r\n    // the score improvement reserve uses the normalized distance to maxReserve/2 as score\r\n    // as smaller the distance as higher is the score\r\n    // highest possible score if solution is not violating the reserve\r\n    function scoreReserveImprovement(uint newReserve_) public view returns (uint score) {\r\n        if (newReserve_ <= assessor.maxReserve()) {\r\n            // highest possible score\r\n            return BIG_NUMBER;\r\n        }\r\n\r\n        return rmul(IMPROVEMENT_WEIGHT, rdiv(ONE, safeSub(newReserve_, assessor.maxReserve())));\r\n    }\r\n\r\n    // the score improvement ratio uses the normalized distance to (minRatio+maxRatio)/2 as score\r\n    // as smaller the distance as higher is the score\r\n    // highest possible score if solution is not violating the ratio\r\n    function scoreRatioImprovement(Fixed27 memory newSeniorRatio) public view returns (uint) {\r\n        (Fixed27 memory minSeniorRatio, Fixed27 memory maxSeniorRatio) = assessor.seniorRatioBounds();\r\n        if (checkRatioInRange(newSeniorRatio, minSeniorRatio, maxSeniorRatio) == true) {\r\n\r\n            // highest possible score\r\n            return BIG_NUMBER;\r\n        }\r\n        // absDistance of ratio can never be zero\r\n        return rmul(IMPROVEMENT_WEIGHT, rdiv(ONE, absDistance(newSeniorRatio.value,\r\n                safeDiv(safeAdd(minSeniorRatio.value, maxSeniorRatio.value), 2))));\r\n    }\r\n\r\n    // internal method to save new improvement score\r\n    function saveNewImprovement(uint impScoreRatio, uint impScoreReserve) internal {\r\n        bestRatioImprovement = impScoreRatio;\r\n        bestReserveImprovement = impScoreReserve;\r\n    }\r\n\r\n    /// calculates improvement score for reserve and ratio pool constraints\r\n    function scoreImprovement(Fixed27 memory newSeniorRatio_, uint newReserve_) public view returns(int, uint, uint) {\r\n        uint impScoreRatio = scoreRatioImprovement(newSeniorRatio_);\r\n        uint impScoreReserve = scoreReserveImprovement(newReserve_);\r\n\r\n        // the highest priority has fixing the currentSeniorRatio\r\n        // if the ratio is improved, we can ignore reserve\r\n        if (impScoreRatio > bestRatioImprovement) {\r\n            // we found a new best\r\n            return (NEW_BEST, impScoreRatio, impScoreReserve);\r\n        }\r\n\r\n        // only if the submitted solution ratio score equals the current best ratio\r\n        // we determine if the submitted solution improves the reserve\r\n        if (impScoreRatio == bestRatioImprovement) {\r\n              if (impScoreReserve >= bestReserveImprovement) {\r\n                  return (NEW_BEST, impScoreRatio, impScoreReserve);\r\n              }\r\n        }\r\n        return (ERR_NOT_NEW_BEST, impScoreRatio, impScoreReserve);\r\n    }\r\n\r\n    /// scores a solution in the submission period\r\n    /// the scoring function is a linear function with high weights as coefficient to determine\r\n    /// the priorities. (non-preemptive goal programming)\r\n    function scoreSolution(uint seniorRedeem, uint juniorRedeem,\r\n        uint juniorSupply, uint seniorSupply) public view returns(uint) {\r\n        // the default priority order\r\n        // 1. senior redeem\r\n        // 2. junior redeem\r\n        // 3. junior supply\r\n        // 4. senior supply\r\n        return safeAdd(safeAdd(safeMul(seniorRedeem, weightSeniorRedeem), safeMul(juniorRedeem, weightJuniorRedeem)),\r\n            safeAdd(safeMul(juniorSupply, weightJuniorSupply), safeMul(seniorSupply, weightSeniorSupply)));\r\n    }\r\n\r\n    /// validates if a solution satisfy the core constraints\r\n    /// returns: first constraint which is not satisfied or success\r\n    function validateCoreConstraints(uint currencyAvailable, uint currencyOut, uint seniorRedeem, uint juniorRedeem,\r\n        uint seniorSupply, uint juniorSupply) public view returns (int err) {\r\n        // constraint 1: currency available\r\n        if (currencyOut > currencyAvailable) {\r\n            // currencyAvailableConstraint => -1\r\n            return ERR_CURRENCY_AVAILABLE;\r\n        }\r\n\r\n        // constraint 2: max order\r\n        if (seniorSupply > order.seniorSupply ||\r\n        juniorSupply > order.juniorSupply ||\r\n        seniorRedeem > order.seniorRedeem ||\r\n            juniorRedeem > order.juniorRedeem) {\r\n            // maxOrderConstraint => -2\r\n            return ERR_MAX_ORDER;\r\n        }\r\n\r\n        // successful => 0\r\n        return SUCCESS;\r\n    }\r\n\r\n    /// validates if a solution satisfies the ratio constraints\r\n    /// returns: first constraint which is not satisfied or success\r\n    function validateRatioConstraints(uint assets, uint seniorAsset) public view returns(int) {\r\n        (Fixed27 memory minSeniorRatio, Fixed27 memory maxSeniorRatio) = assessor.seniorRatioBounds();\r\n\r\n        // constraint 4: min senior ratio constraint\r\n        if (seniorAsset < rmul(assets, minSeniorRatio.value)) {\r\n            // minSeniorRatioConstraint => -4\r\n            return ERR_MIN_SENIOR_RATIO;\r\n        }\r\n        // constraint 5: max senior ratio constraint\r\n        if (seniorAsset > rmul(assets, maxSeniorRatio.value)) {\r\n            // maxSeniorRatioConstraint => -5\r\n            return ERR_MAX_SENIOR_RATIO;\r\n        }\r\n        // successful => 0\r\n        return SUCCESS;\r\n    }\r\n\r\n    /// validates if a solution satisfies the pool constraints\r\n    /// returns: first constraint which is not satisfied or success\r\n    function validatePoolConstraints(uint reserve_, uint seniorAsset, uint nav_) public view returns (int err) {\r\n        // constraint 3: max reserve\r\n        if (reserve_ > assessor.maxReserve()) {\r\n            // maxReserveConstraint => -3\r\n            return ERR_MAX_RESERVE;\r\n        }\r\n\r\n        uint assets = safeAdd(nav_, reserve_);\r\n        return validateRatioConstraints(assets, seniorAsset);\r\n    }\r\n\r\n    /// validates if a solution satisfies core and pool constraints\r\n    /// returns: first constraint which is not satisfied or success\r\n    function validate(uint seniorRedeem, uint juniorRedeem,\r\n        uint seniorSupply, uint juniorSupply) public view returns (int) {\r\n        return validate(epochReserve, epochNAV, epochSeniorAsset,\r\n            OrderSummary({seniorRedeem: seniorRedeem,\r\n                juniorRedeem:juniorRedeem,\r\n                seniorSupply: seniorSupply,\r\n                juniorSupply: juniorSupply}));\r\n    }\r\n\r\n    function validate(uint reserve_, uint nav_, uint seniorAsset_, uint seniorRedeem, uint juniorRedeem,\r\n        uint seniorSupply, uint juniorSupply) public returns (int) {\r\n        return validate(reserve_, nav_, seniorAsset_,\r\n            OrderSummary({seniorRedeem: seniorRedeem,\r\n            juniorRedeem: juniorRedeem,\r\n            seniorSupply: seniorSupply,\r\n            juniorSupply: juniorSupply}));\r\n    }\r\n\r\n    function validate(uint reserve_, uint nav_, uint seniorAsset_, OrderSummary memory trans) view internal returns (int) {\r\n        uint currencyAvailable = safeAdd(safeAdd(reserve_, trans.seniorSupply), trans.juniorSupply);\r\n        uint currencyOut = safeAdd(trans.seniorRedeem, trans.juniorRedeem);\r\n\r\n        int err = validateCoreConstraints(currencyAvailable, currencyOut, trans.seniorRedeem,\r\n            trans.juniorRedeem, trans.seniorSupply, trans.juniorSupply);\r\n\r\n        if(err != SUCCESS) {\r\n            return err;\r\n        }\r\n\r\n        uint newReserve = safeSub(currencyAvailable, currencyOut);\r\n        if(poolClosing == true) {\r\n            if(trans.seniorSupply == 0 && trans.juniorSupply == 0) {\r\n                return SUCCESS;\r\n            }\r\n            return ERR_POOL_CLOSING;\r\n\r\n        }\r\n        return validatePoolConstraints(newReserve, assessor.calcSeniorAssetValue(trans.seniorRedeem, trans.seniorSupply,\r\n            seniorAsset_, newReserve, nav_), nav_);\r\n    }\r\n\r\n    /// public method to execute an epoch which required a submission period and the challenge period is over\r\n    function executeEpoch() public {\r\n        require(block.timestamp >= minChallengePeriodEnd && minChallengePeriodEnd != 0);\r\n\r\n        _executeEpoch(bestSubmission.seniorRedeem ,bestSubmission.juniorRedeem,\r\n            bestSubmission.seniorSupply, bestSubmission.juniorSupply);\r\n    }\r\n\r\n    /// calculates the percentage of an order type which can be fulfilled for an epoch\r\n    function calcFulfillment(uint amount, uint totalOrder) public pure returns(Fixed27 memory percent) {\r\n        if(amount == 0 || totalOrder == 0) {\r\n            return Fixed27(0);\r\n        }\r\n        return Fixed27(rdiv(amount, totalOrder));\r\n    }\r\n\r\n    /// calculates the new reserve after a solution would be executed\r\n    function calcNewReserve(uint seniorRedeem, uint juniorRedeem,\r\n        uint seniorSupply, uint juniorSupply) public view returns(uint) {\r\n\r\n        return safeSub(safeAdd(safeAdd(epochReserve, seniorSupply), juniorSupply),\r\n            safeAdd(seniorRedeem, juniorRedeem));\r\n    }\r\n\r\n    /// internal execute epoch communicates the order fulfillment of the best solution to the tranches\r\n    function _executeEpoch(uint seniorRedeem, uint juniorRedeem,\r\n        uint seniorSupply, uint juniorSupply) internal {\r\n\r\n        uint epochID = safeAdd(lastEpochExecuted, 1);\r\n        submissionPeriod = false;\r\n\r\n        // tranche epochUpdates triggers currency transfers from/to reserve\r\n        // an mint/burn tokens\r\n        seniorTranche.epochUpdate(epochID, calcFulfillment(seniorSupply, order.seniorSupply).value,\r\n            calcFulfillment(seniorRedeem, order.seniorRedeem).value,\r\n            epochSeniorTokenPrice.value,order.seniorSupply, order.seniorRedeem);\r\n\r\n        juniorTranche.epochUpdate(epochID, calcFulfillment(juniorSupply, order.juniorSupply).value,\r\n            calcFulfillment(juniorRedeem, order.juniorRedeem).value,\r\n            epochJuniorTokenPrice.value, order.juniorSupply, order.juniorRedeem);\r\n\r\n        // sends requested currency to senior tranche, if currency was not available before\r\n        seniorTranche.payoutRequestedCurrency();\r\n\r\n        uint newReserve = calcNewReserve(seniorRedeem, juniorRedeem\r\n        , seniorSupply, juniorSupply);\r\n\r\n        // assessor performs senior debt reBalancing according to new ratio\r\n        assessor.changeSeniorAsset(seniorSupply, seniorRedeem);\r\n        // the new reserve after this epoch can be used for new loans\r\n        assessor.changeBorrowAmountEpoch(newReserve);\r\n        // reset state for next epochs\r\n        lastEpochExecuted = epochID;\r\n        minChallengePeriodEnd = 0;\r\n        bestSubScore = 0;\r\n        gotFullValidSolution = false;\r\n        bestRatioImprovement = 0;\r\n        bestReserveImprovement = 0;\r\n    }\r\n}\r\ncontract MigratedCoordinator is EpochCoordinator {\r\n    \r\n    bool public done;\r\n    address public migratedFrom;\r\n    \r\n    constructor(uint challengeTime) EpochCoordinator(challengeTime) public {}\r\n                \r\n    function migrate(address clone_) public auth {\r\n        require(!done, \"migration already finished\");\r\n        done = true;\r\n        migratedFrom = clone_;\r\n\r\n        EpochCoordinator clone = EpochCoordinator(clone_);\r\n        lastEpochClosed = clone.lastEpochClosed();\r\n        minimumEpochTime = clone.minimumEpochTime();\r\n        lastEpochExecuted = clone.lastEpochExecuted();\r\n        currentEpoch = clone.currentEpoch();\r\n\r\n        (uint seniorRedeemSubmission, uint juniorRedeemSubmission, uint juniorSupplySubmission, uint seniorSupplySubmission) = clone.bestSubmission();\r\n        bestSubmission.seniorRedeem = seniorRedeemSubmission;\r\n        bestSubmission.juniorRedeem = juniorRedeemSubmission;\r\n        bestSubmission.seniorSupply = seniorSupplySubmission;\r\n        bestSubmission.juniorSupply = juniorSupplySubmission;\r\n\r\n        (uint  seniorRedeemOrder, uint juniorRedeemOrder, uint juniorSupplyOrder, uint seniorSupplyOrder) = clone.order();\r\n        order.seniorRedeem = seniorRedeemOrder;\r\n        order.juniorRedeem = juniorRedeemOrder;\r\n        order.seniorSupply = seniorSupplyOrder;\r\n        order.juniorSupply = juniorSupplyOrder;\r\n\r\n        // bestSubmission = OrderSummary(clone.bestSubmission());\r\n        // order = OrderSummary(clone.order());\r\n\r\n        bestSubScore = clone.bestSubScore();\r\n        gotFullValidSolution = clone.gotFullValidSolution();\r\n\r\n        epochSeniorTokenPrice = Fixed27(clone.epochSeniorTokenPrice());\r\n        epochJuniorTokenPrice = Fixed27(clone.epochJuniorTokenPrice());\r\n        epochNAV = clone.epochNAV();\r\n        epochSeniorAsset = clone.epochSeniorAsset();\r\n        epochReserve = clone.epochReserve();\r\n        submissionPeriod = clone.submissionPeriod();\r\n\r\n        weightSeniorRedeem = clone.weightSeniorRedeem();\r\n        weightJuniorRedeem = clone.weightJuniorRedeem();\r\n        weightJuniorSupply = clone.weightJuniorSupply();\r\n        weightSeniorSupply = clone.weightSeniorSupply();\r\n\r\n        minChallengePeriodEnd = clone.minChallengePeriodEnd();\r\n        challengeTime = clone.challengeTime();\r\n        bestRatioImprovement = clone.bestRatioImprovement();\r\n        bestReserveImprovement = clone.bestReserveImprovement();\r\n\r\n        poolClosing = clone.poolClosing();           \r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"challengeTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"foo\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bar\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"fax\",\"type\":\"bytes\"}],\"name\":\"LogNote\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"BIG_NUMBER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERR_CURRENCY_AVAILABLE\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERR_MAX_ORDER\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERR_MAX_RESERVE\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERR_MAX_SENIOR_RATIO\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERR_MIN_SENIOR_RATIO\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERR_NOT_NEW_BEST\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERR_POOL_CLOSING\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IMPROVEMENT_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NEW_BEST\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUCCESS\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"absDistance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"delta\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"assessor\",\"outputs\":[{\"internalType\":\"contract AssessorLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bestRatioImprovement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bestReserveImprovement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bestSubScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bestSubmission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seniorRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seniorSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOrder\",\"type\":\"uint256\"}],\"name\":\"calcFulfillment\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Fixed27\",\"name\":\"percent\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seniorRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seniorSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorSupply\",\"type\":\"uint256\"}],\"name\":\"calcNewReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Fixed27\",\"name\":\"ratio\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Fixed27\",\"name\":\"minRatio\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Fixed27\",\"name\":\"maxRatio\",\"type\":\"tuple\"}],\"name\":\"checkRatioInRange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeEpoch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"contractName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"depend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"done\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"epochJuniorTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"epochNAV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"epochReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"epochSeniorAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"epochSeniorTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"executeEpoch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"file\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gotFullValidSolution\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"juniorTranche\",\"outputs\":[{\"internalType\":\"contract EpochTrancheLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastEpochClosed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastEpochExecuted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"clone_\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migratedFrom\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minChallengePeriodEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumEpochTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"order\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seniorRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seniorSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolClosing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"rdiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserve\",\"outputs\":[{\"internalType\":\"contract ReserveLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"rmul\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"safeDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Fixed27\",\"name\":\"newSeniorRatio_\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"newReserve_\",\"type\":\"uint256\"}],\"name\":\"scoreImprovement\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Fixed27\",\"name\":\"newSeniorRatio\",\"type\":\"tuple\"}],\"name\":\"scoreRatioImprovement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newReserve_\",\"type\":\"uint256\"}],\"name\":\"scoreReserveImprovement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seniorRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seniorSupply\",\"type\":\"uint256\"}],\"name\":\"scoreSolution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"seniorTranche\",\"outputs\":[{\"internalType\":\"contract EpochTrancheLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"submissionPeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seniorRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seniorSupply\",\"type\":\"uint256\"}],\"name\":\"submitSolution\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reserve_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nav_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seniorAsset_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seniorRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seniorSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorSupply\",\"type\":\"uint256\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seniorRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seniorSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorSupply\",\"type\":\"uint256\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currencyAvailable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currencyOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seniorRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seniorSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorSupply\",\"type\":\"uint256\"}],\"name\":\"validateCoreConstraints\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"err\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reserve_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seniorAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nav_\",\"type\":\"uint256\"}],\"name\":\"validatePoolConstraints\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"err\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seniorAsset\",\"type\":\"uint256\"}],\"name\":\"validateRatioConstraints\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weightJuniorRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weightJuniorSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weightSeniorRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weightSeniorSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MigratedCoordinator","CompilerVersion":"v0.5.15+commit.6a57276f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000708","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d4538bc7c8a310371d6f76655d66553d8fb37f1070f4ca4d62f19a152d7089bd"}]}