{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/IntelligentNFTv1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport \\\"./AccessExtension.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\n\\n/**\\n * @title Intelligent NFT Interface\\n *        Version 1\\n *\\n * @notice External interface of IntelligentNFTv1 declared to support ERC165 detection.\\n *      See Intelligent NFT documentation below.\\n *\\n * @author Basil Gorin\\n */\\ninterface IIntelligentNFTv1 {\\n\\tfunction totalSupply() external view returns (uint256);\\n\\tfunction exists(uint256 recordId) external view returns (bool);\\n\\tfunction ownerOf(uint256 recordId) external view returns (address);\\n}\\n\\n/**\\n * @title Intelligent NFT (iNFT)\\n *        Version 1\\n *\\n * @notice Intelligent NFT (iNFT) represents an enhancement to an existing NFT\\n *      (we call it a \\\"target\\\" or \\\"target NFT\\\"), it binds a GPT-3 prompt (a \\\"personality prompt\\\")\\n *      to the target to embed intelligence, is controlled and belongs to the owner of the target.\\n *\\n * @notice iNFT stores AI Pod and some amount of ALI tokens locked, available to\\n *      unlocking when iNFT is destroyed\\n *\\n * @notice iNFT is not an ERC721 token, but it has some very limited similarity to an ERC721:\\n *      every record is identified by ID and this ID has an owner, which is effectively the target NFT owner;\\n *      still, it doesn't store ownership information itself and fully relies on the target ownership instead\\n *\\n * @dev Internally iNFTs consist of:\\n *      - personality prompt - a GPT-3 prompt defining its intelligent capabilities\\n *      - target NFT - smart contract address and ID of the NFT the iNFT is bound to\\n *      - AI Pod - ID of the AI Pod used to produce given iNFT, locked within an iNFT\\n *      - ALI tokens amount - amount of the ALI tokens used to produce given iNFT, also locked\\n *\\n * @dev iNFTs can be\\n *      - created, this process requires an AI Pod and ALI tokens to be locked\\n *      - destroyed, this process releases an AI Pod and ALI tokens previously locked;\\n *         ALI token fee may get withheld upon destruction\\n *\\n * @dev Some known limitations of Version 1:\\n *      - doesn't support ERC1155 as a target NFT\\n *      - only one-to-one iNFT-NFT bindings,\\n *         no many-to-one, one-to-many, or many-to-many bindings not allowed\\n *      - no AI Pod ID -> iNFT ID binding, impossible to look for iNFT by AI Pod ID\\n *      - no enumeration support, iNFT IDs created must be tracked off-chain,\\n *         or [recommended] generated with a predictable deterministic integer sequence,\\n *         for example, 1, 2, 3, ...\\n *      - no support for personality prompt upgrades (no way to update personality prompt)\\n *      - burn: doesn't allow to specify where to send the iNFT burning fee, sends ALI tokens\\n *         burner / transaction sender (iNFT Linker)\\n *      - burn: doesn't verify if its safe to send ALI tokens released back to NFT owner;\\n *         ALI tokens may get lost if iNFT is burnt when NFT belongs to a smart contract which\\n *         is not aware of the ALI tokens being sent to it\\n *      - no target NFT ID optimization; storage usage for IntelliBinding can be optimized\\n *         if short target NFT IDs are recognized and stored optimized\\n *      - AI Pod ERC721 and ALI ERC20 smart contracts are set during the deployment and cannot be changed\\n *\\n * @author Basil Gorin\\n */\\ncontract IntelligentNFTv1 is IIntelligentNFTv1, AccessExtension {\\n\\t/**\\n\\t * @notice Deployer is responsible for AI Pod and ALI tokens contract address initialization\\n\\t *\\n\\t * @dev Role ROLE_DEPLOYER allows executing `setPodContract` and `setAliContract` functions\\n\\t */\\n\\tbytes32 public constant ROLE_DEPLOYER = keccak256(\\\"ROLE_DEPLOYER\\\");\\n\\n\\t/**\\n\\t * @notice Minter is responsible for creating (minting) iNFTs\\n\\t *\\n\\t * @dev Role ROLE_MINTER allows minting iNFTs (calling `mint` function)\\n\\t */\\n\\tbytes32 public constant ROLE_MINTER = keccak256(\\\"ROLE_MINTER\\\");\\n\\n\\t/**\\n\\t * @notice Burner is responsible for destroying (burning) iNFTs\\n\\t *\\n\\t * @dev Role ROLE_BURNER allows burning iNFTs (calling `burn` function)\\n\\t */\\n\\tbytes32 public constant ROLE_BURNER = keccak256(\\\"ROLE_BURNER\\\");\\n\\n\\t/**\\n\\t * @dev Each intelligent token, represented by its unique ID, is bound to the target NFT,\\n\\t *      defined by the pair of the target NFT smart contract address and unique token ID\\n\\t *      within the target NFT smart contract\\n\\t *\\n\\t * @dev Effectively iNFT is owned by the target NFT owner\\n\\t *\\n\\t * @dev Additionally, each token holds an AI Pod and some amount of ALI tokens bound to it\\n\\t *\\n\\t * @dev `IntelliBinding` keeps all the binding information, including target NFT coordinates,\\n\\t *      bound AI Pod ID, and amount of ALI ERC20 tokens bound to the iNFT\\n\\t */\\n\\tstruct IntelliBinding {\\n\\t\\t// Note: structure members are reordered to fit into less memory slots, see EVM memory layout\\n\\t\\t// ----- SLOT.1 (256/256)\\n\\t\\t/**\\n\\t\\t * @dev Personality prompt is a hash of the data used to feed GPT-3 algorithm\\n\\t\\t */\\n\\t\\tuint256 personalityPrompt;\\n\\n\\t\\t// ----- SLOT.2 (160/256)\\n\\t\\t/**\\n\\t\\t * @dev Address of the target NFT deployed smart contract,\\n\\t\\t *      this is a contract a particular iNFT is bound to\\n\\t\\t */\\n\\t\\taddress targetContract;\\n\\n\\t\\t// ----- SLOT.3 (256/256)\\n\\t\\t/**\\n\\t\\t * @dev Target NFT ID within the target NFT smart contract,\\n\\t\\t *      effectively target NFT ID and contract address define the owner of an iNFT\\n\\t\\t */\\n\\t\\tuint256 targetId;\\n\\n\\t\\t// ----- SLOT.4 (160/256)\\n\\t\\t/**\\n\\t\\t * @dev AI Pod ID bound to (owned by) the iNFT\\n\\t\\t *\\n\\t\\t * @dev Similar to target NFT, specific AI Pod is also defined by pair of AI Pod smart contract address\\n\\t\\t *       and AI Pod ID; the first one, however, is defined globally and stored in `podContract` constant.\\n\\t\\t */\\n\\t\\tuint64 podId;\\n\\n\\t\\t/**\\n\\t\\t * @dev Amount of an ALI ERC20 tokens bound to (owned by) the iNFTs\\n\\t\\t *\\n\\t\\t * @dev ALI ERC20 smart contract address is defined globally as `aliContract` constant\\n\\t\\t */\\n\\t\\tuint96 aliValue;\\n\\t}\\n\\n\\t/**\\n\\t * @notice iNFT binding storage, stores binding information for each existing iNFT\\n\\t * @dev Maps iNFT ID to its binding data, which includes underlying NFT data\\n\\t */\\n\\tmapping (uint256 => IntelliBinding) public bindings;\\n\\n\\t/**\\n\\t * @notice Reverse iNFT binding allows to find iNFT bound to a particular NFT\\n\\t * @dev Maps target NFT (smart contract address and unique token ID) to the linked iNFT:\\n\\t *      NFT Contract => NFT ID => iNFT ID\\n\\t */\\n\\tmapping (address => mapping(uint256 => uint256)) reverseBinding;\\n\\n\\t/**\\n\\t * @notice Total amount (maximum value estimate) of iNFT in existence.\\n\\t *       This value can be higher than number of effectively accessible iNFTs\\n\\t *       since when underlying NFT gets burned this value doesn't get updated.\\n\\t */\\n\\tuint256 public override totalSupply;\\n\\n\\t/**\\n\\t * @notice Each iNFT holds an AI Pod which is tracked by the AI Pod NFT smart contract defined here\\n\\t */\\n\\taddress public podContract;\\n\\n\\t/**\\n\\t * @notice Each iNFT holds some ALI tokens, which are tracked by the ALI token ERC20 smart contract defined here\\n\\t */\\n\\taddress public aliContract;\\n\\n\\t/**\\n\\t * @dev Fired in mint() when new iNFT is created\\n\\t *\\n\\t * @param by an address which executed the mint function\\n\\t * @param owner current owner of the NFT\\n\\t * @param recordId ID of the iNFT to mint (create, bind)\\n\\t * @param payer and address which funds the creation (supplies AI Pod and ALI tokens)\\n\\t * @param podId ID of the AI Pod to bind (transfer) to newly created iNFT\\n\\t * @param aliValue amount of ALI tokens to bind (transfer) to newly created iNFT\\n\\t * @param targetContract target NFT smart contract\\n\\t * @param targetId target NFT ID (where this iNFT binds to and belongs to)\\n\\t * @param personalityPrompt personality prompt for the minted iNFT\\n\\t */\\n\\tevent Minted(\\n\\t\\taddress indexed by,\\n\\t\\taddress owner,\\n\\t\\tuint64 recordId,\\n\\t\\taddress payer,\\n\\t\\tuint64 podId,\\n\\t\\tuint96 aliValue,\\n\\t\\taddress targetContract,\\n\\t\\tuint256 targetId,\\n\\t\\tuint256 personalityPrompt\\n\\t);\\n\\n\\t/**\\n\\t * @dev Fired in burn() when an existing iNFT gets destroyed\\n\\t *\\n\\t * @param by an address which executed the burn function\\n\\t * @param recordId ID of the iNFT to burn (destroy, unbind)\\n\\t * @param recipient and address which receives unlocked AI Pod and ALI tokens (NFT owner)\\n\\t * @param podId ID of the AI Pod to unbind (transfer) from the destroyed iNFT\\n\\t * @param aliValue amount of ALI tokens to unbind (transfer) from the destroyed iNFT\\n\\t * @param aliFee service fee in ALI tokens withheld by burn executor\\n\\t * @param targetContract target NFT smart contract\\n\\t * @param targetId target NFT ID (where this iNFT was bound to and belonged to)\\n\\t * @param personalityPrompt personality prompt for that iNFT\\n\\t */\\n\\tevent Burnt(\\n\\t\\taddress indexed by,\\n\\t\\tuint64 recordId,\\n\\t\\taddress recipient,\\n\\t\\tuint64 podId,\\n\\t\\tuint96 aliValue,\\n\\t\\tuint96 aliFee,\\n\\t\\taddress targetContract,\\n\\t\\tuint256 targetId,\\n\\t\\tuint256 personalityPrompt\\n\\t);\\n\\n\\t/**\\n\\t * @dev Fired in setPodContract()\\n\\t *\\n\\t * @param by an address which set the `podContract`\\n\\t * @param podContract AI Pod contract address set\\n\\t */\\n\\tevent PodContractSet(address indexed by, address podContract);\\n\\n\\t/**\\n\\t * @dev Fired in setAliContract()\\n\\t *\\n\\t * @param by an address which set the `aliContract`\\n\\t * @param aliContract ALI token contract address set\\n\\t */\\n\\tevent AliContractSet(address indexed by, address aliContract);\\n\\n\\t/**\\n\\t * @dev Creates/deploys an iNFT instance not bound to AI Pod / ALI token instances\\n\\t */\\n\\tconstructor() {\\n\\t\\t// setup admin role for smart contract deployer initially\\n\\t\\t_setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n\\t}\\n\\n\\t/**\\n\\t * @dev Binds an iNFT instance to already deployed AI Pod instance\\n\\t *\\n\\t * @param _pod address of the deployed AI Pod instance to bind iNFT to\\n\\t */\\n\\tfunction setPodContract(address _pod) public {\\n\\t\\t// verify sender has permission to access this function\\n\\t\\trequire(isSenderInRole(ROLE_DEPLOYER), \\\"access denied\\\");\\n\\n\\t\\t// verify the input is set\\n\\t\\trequire(_pod != address(0), \\\"AI Pod addr is not set\\\");\\n\\n\\t\\t// verify _pod is valid ERC721\\n\\t\\trequire(IERC165(_pod).supportsInterface(type(IERC721).interfaceId), \\\"AI Pod addr is not ERC721\\\");\\n\\n\\t\\t// setup smart contract internal state\\n\\t\\tpodContract = _pod;\\n\\n\\t\\t// emit an event\\n\\t\\temit PodContractSet(_msgSender(), _pod);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Binds an iNFT instance to already deployed ALI Token instance\\n\\t *\\n\\t * @param _ali address of the deployed ALI Token instance to bind iNFT to\\n\\t */\\n\\tfunction setAliContract(address _ali) public {\\n\\t\\t// verify sender has permission to access this function\\n\\t\\trequire(isSenderInRole(ROLE_DEPLOYER), \\\"access denied\\\");\\n\\n\\t\\t// verify the input is set\\n\\t\\trequire(_ali != address(0), \\\"ALI Token addr is not set\\\");\\n\\n\\t\\t// verify _ali is valid ERC20\\n\\t\\trequire(IERC165(_ali).supportsInterface(type(IERC20).interfaceId), \\\"ALI Token addr is not ERC20\\\");\\n\\n\\t\\t// setup smart contract internal state\\n\\t\\taliContract = _ali;\\n\\n\\t\\t// emit an event\\n\\t\\temit AliContractSet(_msgSender(), _ali);\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc IERC165\\n\\t */\\n\\tfunction supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n\\t\\t// reconstruct from current interface and super interface\\n\\t\\treturn interfaceId == type(IIntelligentNFTv1).interfaceId || super.supportsInterface(interfaceId);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Verifies if given iNFT exists\\n\\t *\\n\\t * @param recordId iNFT ID to verify existence of\\n\\t * @return true if iNFT exists, false otherwise\\n\\t */\\n\\tfunction exists(uint256 recordId) public view override returns (bool) {\\n\\t\\t// verify if biding exists for that tokenId and return the result\\n\\t\\treturn bindings[recordId].targetContract != address(0);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns an owner of the given iNFT.\\n\\t *      By definition iNFT owner is an owner of the target NFT\\n\\t *\\n\\t * @param recordId iNFT ID to query ownership information for\\n\\t * @return address of the given iNFT owner\\n\\t */\\n\\tfunction ownerOf(uint256 recordId) public view override returns (address) {\\n\\t\\t// read the token binding\\n\\t\\tIntelliBinding memory binding = bindings[recordId];\\n\\n\\t\\t// verify the binding exists and throw standard Zeppelin message if not\\n\\t\\trequire(binding.targetContract != address(0), \\\"iNFT doesn't exist\\\");\\n\\n\\t\\t// delegate `ownerOf` call to the target NFT smart contract\\n\\t\\treturn IERC721(binding.targetContract).ownerOf(binding.targetId);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Restricted access function which creates an iNFT, binding it to the specified\\n\\t *      NFT, locking the AI Pod specified, and funded with the amount of ALI specified\\n\\t *\\n\\t * @dev Transfers AI Pod defined by its ID into iNFT smart contract for locking;\\n\\t *      linking funder must authorize the transfer operation before the mint is called\\n\\t * @dev Transfers specified amount of ALI token into iNFT smart contract for locking;\\n\\t *      funder must authorize the transfer operation before the mint is called\\n\\t * @dev The NFT to be linked to doesn't required to belong to the funder, but it must exist\\n\\t *\\n\\t * @dev Throws if target NFT doesn't exist\\n\\t *\\n\\t * @dev This is a restricted function which is accessed by iNFT Linker\\n\\t *\\n\\t * @param recordId ID of the iNFT to mint (create, bind)\\n\\t * @param funder and address which funds the creation (supplies AI Pod and ALI tokens)\\n\\t * @param personalityPrompt personality prompt for that iNFT\\n\\t * @param podId ID of the AI Pod to bind (transfer) to newly created iNFT\\n\\t * @param aliValue amount of ALI tokens to bind (transfer) to newly created iNFT\\n\\t * @param targetContract target NFT smart contract\\n\\t * @param targetId target NFT ID (where this iNFT binds to and belongs to)\\n\\t */\\n\\tfunction mint(\\n\\t\\tuint64 recordId,\\n\\t\\taddress funder,\\n\\t\\tuint256 personalityPrompt,\\n\\t\\tuint64 podId,\\n\\t\\tuint96 aliValue,\\n\\t\\taddress targetContract,\\n\\t\\tuint256 targetId\\n\\t) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_MINTER), \\\"access denied\\\");\\n\\n\\t\\t// verify this token ID is not yet bound\\n\\t\\trequire(!exists(recordId), \\\"iNFT already exists\\\");\\n\\n\\t\\t// verify the NFT is not yet bound\\n\\t\\trequire(reverseBinding[targetContract][targetId] == 0, \\\"target NFT already linked\\\");\\n\\n\\t\\t// transfer the AI Pod from the specified address `_from`\\n\\t\\t// using unsafe transfer to avoid unnecessary `onERC721Received` triggering\\n\\t\\t// Note: we explicitly request AI Pod transfer from the linking funder to be safe\\n\\t\\t// from the scenarios of potential misuse of AI Pods\\n\\t\\tIERC721(podContract).transferFrom(funder, address(this), podId);\\n\\n\\t\\t// transfer the ALI tokens from the specified address `_from`\\n\\t\\t// using unsafe transfer to avoid unnecessary callback triggering\\n\\t\\tif(aliValue > 0) {\\n\\t\\t\\t// note: Zeppelin based AliERC20v1 transfer implementation fails on any error\\n\\t\\t\\tIERC20(aliContract).transferFrom(funder, address(this), aliValue);\\n\\t\\t}\\n\\n\\t\\t// retrieve NFT owner and verify if target NFT exists\\n\\t\\taddress owner = IERC721(targetContract).ownerOf(targetId);\\n\\t\\t// Note: we do not require funder to be NFT owner,\\n\\t\\t// if required this constraint should be added by the caller (iNFT Linker)\\n\\t\\trequire(owner != address(0), \\\"target NFT doesn't exist\\\");\\n\\n\\t\\t// bind AI Pod transferred and ALI ERC20 value transferred to an NFT specified\\n\\t\\tbindings[recordId] = IntelliBinding({\\n\\t\\t\\tpersonalityPrompt: personalityPrompt,\\n\\t\\t\\ttargetContract: targetContract,\\n\\t\\t\\ttargetId: targetId,\\n\\t\\t\\tpodId: podId,\\n\\t\\t\\taliValue: aliValue\\n\\t\\t});\\n\\n\\t\\t// fill in the reverse binding\\n\\t\\treverseBinding[targetContract][targetId] = recordId;\\n\\n\\t\\t// increase total supply counter\\n\\t\\ttotalSupply++;\\n\\n\\t\\t// emit an event\\n\\t\\temit Minted(_msgSender(), owner, recordId, funder, podId, aliValue, targetContract, targetId, personalityPrompt);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Restricted access function which destroys an iNFT, unbinding it from the\\n\\t *      linked NFT, releasing an AI Pod, and ALI tokens locked in the iNFT\\n\\t *\\n\\t * @dev Transfers an AI Pod locked in iNFT to its owner via ERC721.safeTransferFrom;\\n\\t *      owner must be an EOA or implement IERC721Receiver.onERC721Received properly\\n\\t * @dev Transfers ALI tokens locked in iNFT to its owner and a fee specified to\\n\\t *      transaction executor\\n\\t * @dev Since iNFT owner is determined as underlying NFT owner, this underlying NFT must\\n\\t *      exist and its ownerOf function must not throw and must return non-zero owner address\\n\\t *      for the underlying NFT ID\\n\\t *\\n\\t * @dev Doesn't verify if it's safe to send ALI tokens to the NFT owner, this check\\n\\t *      must be handled by the transaction executor\\n\\t *\\n\\t * @dev This is a restricted function which is accessed by iNFT Linker\\n\\t *\\n\\t * @param recordId ID of the iNFT to burn (destroy, unbind)\\n\\t * @param aliFee service fee in ALI tokens to be withheld\\n\\t */\\n\\tfunction burn(uint64 recordId, uint96 aliFee) public {\\n\\t\\t// verify the access permission\\n\\t\\trequire(isSenderInRole(ROLE_BURNER), \\\"access denied\\\");\\n\\n\\t\\t// decrease total supply counter\\n\\t\\ttotalSupply--;\\n\\n\\t\\t// read the token binding\\n\\t\\tIntelliBinding memory binding = bindings[recordId];\\n\\n\\t\\t// verify binding exists\\n\\t\\trequire(binding.targetContract != address(0), \\\"not bound\\\");\\n\\n\\t\\t// destroy binding first to protect from any reentrancy possibility\\n\\t\\tdelete bindings[recordId];\\n\\n\\t\\t// free the reverse binding\\n\\t\\tdelete reverseBinding[binding.targetContract][binding.targetId];\\n\\n\\t\\t// make sure fee doesn't exceed what is bound to iNFT\\n\\t\\trequire(aliFee <= binding.aliValue);\\n\\n\\t\\t// send the fee to transaction sender\\n\\t\\tif(aliFee > 0) {\\n\\t\\t\\t// note: Zeppelin based AliERC20v1 transfer implementation fails on any error\\n\\t\\t\\trequire(IERC20(aliContract).transfer(_msgSender(), aliFee));\\n\\t\\t}\\n\\n\\t\\t// determine an owner of the underlying NFT\\n\\t\\taddress owner = IERC721(binding.targetContract).ownerOf(binding.targetId);\\n\\n\\t\\t// verify that owner address is set (not a zero address)\\n\\t\\trequire(owner != address(0), \\\"no such NFT\\\");\\n\\n\\t\\t// transfer the AI Pod to the NFT owner\\n\\t\\t// using safe transfer since we don't know if owner address can accept the AI Pod right now\\n\\t\\tIERC721(podContract).safeTransferFrom(address(this), owner, binding.podId);\\n\\n\\t\\t// transfer the ALI tokens to the NFT owner\\n\\t\\tif(binding.aliValue > aliFee) {\\n\\t\\t\\t// note: Zeppelin based AliERC20v1 transfer implementation fails on any error\\n\\t\\t\\tIERC20(aliContract).transfer(owner, binding.aliValue - aliFee);\\n\\t\\t}\\n\\n\\t\\t// emit an event\\n\\t\\temit Burnt(_msgSender(), recordId, owner, binding.podId, binding.aliValue, aliFee, binding.targetContract, binding.targetId, binding.personalityPrompt);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/AccessExtension.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\n/**\\n * @title Access Control List Extension Interface\\n *\\n * @notice External interface of AccessExtension declared to support ERC165 detection.\\n *      See Access Control List Extension documentation below.\\n *\\n * @author Basil Gorin\\n */\\ninterface IAccessExtension is IAccessControl {\\n\\tfunction removeFeature(bytes32 feature) external;\\n\\tfunction addFeature(bytes32 feature) external;\\n\\tfunction isFeatureEnabled(bytes32 feature) external view returns(bool);\\n}\\n\\n/**\\n * @title Access Control List Extension\\n *\\n * @notice Access control smart contract provides an API to check\\n *      if specific operation is permitted globally and/or\\n *      if particular user has a permission to execute it.\\n *\\n * @notice It deals with two main entities: features and roles.\\n *\\n * @notice Features are designed to be used to enable/disable specific\\n *      functions (public functions) of the smart contract for everyone.\\n * @notice User roles are designed to restrict access to specific\\n *      functions (restricted functions) of the smart contract to some users.\\n *\\n * @notice Terms \\\"role\\\", \\\"permissions\\\" and \\\"set of permissions\\\" have equal meaning\\n *      in the documentation text and may be used interchangeably.\\n * @notice Terms \\\"permission\\\", \\\"single permission\\\" implies only one permission set.\\n *\\n * @dev OpenZeppelin AccessControl based implementation. Features are stored as\\n *      \\\"self\\\"-roles: feature is a role assigned to the smart contract itself\\n *\\n * @dev Automatically assigns the deployer an admin permission\\n *\\n * @dev This smart contract is designed to be inherited by other\\n *      smart contracts which require access control management capabilities.\\n *\\n * @author Basil Gorin\\n */\\ncontract AccessExtension is IAccessExtension, AccessControl {\\n\\tconstructor() {\\n\\t\\t// setup admin role for smart contract deployer initially\\n\\t\\t_setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc IERC165\\n\\t */\\n\\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n\\t\\t// reconstruct from current interface and super interface\\n\\t\\treturn interfaceId == type(IAccessExtension).interfaceId || super.supportsInterface(interfaceId);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Removes the feature from the set of the globally enabled features,\\n\\t *      taking into account sender's permissions\\n\\t *\\n\\t * @dev Requires transaction sender to have a permission to set the feature requested\\n\\t *\\n\\t * @param feature a feature to disable\\n\\t */\\n\\tfunction removeFeature(bytes32 feature) public override {\\n\\t\\t// delegate to Zeppelin's `revokeRole`\\n\\t\\trevokeRole(feature, address(this));\\n\\t}\\n\\n\\t/**\\n\\t * @notice Adds the feature to the set of the globally enabled features,\\n\\t *      taking into account sender's permissions\\n\\t *\\n\\t * @dev Requires transaction sender to have a permission to set the feature requested\\n\\t *\\n\\t * @param feature a feature to enable\\n\\t */\\n\\tfunction addFeature(bytes32 feature) public override {\\n\\t\\t// delegate to Zeppelin's `grantRole`\\n\\t\\tgrantRole(feature, address(this));\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if requested feature is enabled globally on the contract\\n\\t *\\n\\t * @param feature the feature to check\\n\\t * @return true if the feature requested is enabled, false otherwise\\n\\t */\\n\\tfunction isFeatureEnabled(bytes32 feature) public override view returns(bool) {\\n\\t\\t// delegate to Zeppelin's `hasRole`\\n\\t\\treturn hasRole(feature, address(this));\\n\\t}\\n\\n\\t/**\\n * @notice Checks if transaction sender `msg.sender` has the role required\\n *\\n * @param role the role to check against\\n * @return true if sender has the role required, false otherwise\\n */\\n\\tfunction isSenderInRole(bytes32 role) public view returns(bool) {\\n\\t\\t// delegate call to `isOperatorInRole`, passing transaction sender\\n\\t\\treturn hasRole(role, _msgSender());\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n    function grantRole(bytes32 role, address account) external;\\n    function revokeRole(bytes32 role, address account) external;\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping (address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if(!hasRole(role, account)) {\\n            revert(string(abi.encodePacked(\\n                \\\"AccessControl: account \\\",\\n                Strings.toHexString(uint160(account), 20),\\n                \\\" is missing role \\\",\\n                Strings.toHexString(uint256(role), 32)\\n            )));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = alphabet[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"aliContract\",\"type\":\"address\"}],\"name\":\"AliContractSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"recordId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"podId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"aliValue\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"aliFee\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"personalityPrompt\",\"type\":\"uint256\"}],\"name\":\"Burnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"recordId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"podId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"aliValue\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"personalityPrompt\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"podContract\",\"type\":\"address\"}],\"name\":\"PodContractSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_BURNER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_DEPLOYER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_MINTER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"}],\"name\":\"addFeature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aliContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bindings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"personalityPrompt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"targetId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"podId\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"aliValue\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"recordId\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"aliFee\",\"type\":\"uint96\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"recordId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"}],\"name\":\"isFeatureEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"isSenderInRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"recordId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"funder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"personalityPrompt\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"podId\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"aliValue\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"targetId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"recordId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"podContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"feature\",\"type\":\"bytes32\"}],\"name\":\"removeFeature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ali\",\"type\":\"address\"}],\"name\":\"setAliContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pod\",\"type\":\"address\"}],\"name\":\"setPodContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"IntelligentNFTv1","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}