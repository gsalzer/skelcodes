{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/StakeManager.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\nimport \\\"./interfaces/IStake.sol\\\";\\nimport \\\"./Stake.sol\\\";\\nimport \\\"./Base.sol\\\";\\n\\ncontract StakeManager is Base {\\n    event StakeCreated(\\n        address indexed from,\\n        address stakeToken,\\n        address rewardToken,\\n        address stake\\n    );\\n\\n    event LibUpdated(address indexed newLib);\\n\\n    address[] public stakes;\\n\\n    address public lib;\\n\\n    constructor(address _config, address _lib) Base(_config) {\\n        require(_lib != address(0), \\\"lib address = 0\\\");\\n        lib = _lib;\\n    }\\n\\n    /**\\n     * @dev update stake library\\n     */\\n    function updateLib(address _lib) external onlyCEO() {\\n        require(_lib != address(0), \\\"lib address = 0\\\");\\n        lib = _lib;\\n        emit LibUpdated(_lib);\\n    }\\n\\n    /**\\n     * @dev return number of stake\\n     */\\n    function stakeCount() external view returns (uint256) {\\n        return stakes.length;\\n    }\\n\\n    /**\\n     * @dev return array of all stake contracts\\n     * @return array of stakes\\n     */\\n    function allStakes() external view returns (address[] memory) {\\n        return stakes;\\n    }\\n\\n    /**\\n     * @dev claim rewards of sepcified address of stakes\\n     */\\n    function claims(address[] calldata _stakes) external {\\n        for (uint256 i; i < _stakes.length; i++) {\\n            IStake(_stakes[i]).claim0(msg.sender);\\n        }\\n    }\\n\\n    /**\\n     * @dev create a new stake contract\\n     * @param _stakeToken address of stakeable token\\n     * @param _startDate epoch seconds of mining start\\n     * @param _endDate epoch seconds of mining complete\\n     * @param _totalReward reward total\\n     */\\n    function createStake(\\n        address _stakeToken,\\n        uint256 _startDate,\\n        uint256 _endDate,\\n        uint256 _totalReward\\n    ) external onlyCEO() {\\n        require(_stakeToken != address(0), \\\"zero address\\\");\\n        require(_endDate > _startDate, \\\"_endDate <= _startDate\\\");\\n        address rewardToken = config.protocolToken();\\n\\n        address stakeAddress = clone(lib);\\n        IStake(stakeAddress).initialize(\\n            _stakeToken,\\n            rewardToken,\\n            _startDate,\\n            _endDate,\\n            _totalReward\\n        );\\n        TransferHelper.safeTransferFrom(\\n            rewardToken,\\n            msg.sender,\\n            stakeAddress,\\n            _totalReward\\n        );\\n        stakes.push(stakeAddress);\\n        emit StakeCreated(msg.sender, _stakeToken, rewardToken, stakeAddress);\\n        config.notify(IConfig.EventType.STAKE_CREATED, stakeAddress);\\n    }\\n\\n    function clone(address master) internal returns (address instance) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(\\n                ptr,\\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\\n            )\\n            mstore(add(ptr, 0x14), shl(0x60, master))\\n            mstore(\\n                add(ptr, 0x28),\\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\\n            )\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStake.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\ninterface IStake {\\n    function claim0(address _owner) external;\\n\\n    function initialize(\\n        address stakeToken,\\n        address rewardToken,\\n        uint256 start,\\n        uint256 end,\\n        uint256 rewardPerBlock\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Stake.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IConfig.sol\\\";\\nimport \\\"./interfaces/IStake.sol\\\";\\nimport \\\"./libs/TransferHelper.sol\\\";\\n\\ninterface IConfigable {\\n    function getConfig() external returns (IConfig);\\n}\\n\\ncontract Stake is IStake {\\n    event StakeUpdated(\\n        address indexed staker,\\n        bool isIncrease,\\n        uint256 stakeChanged,\\n        uint256 stakeAmount\\n    );\\n\\n    event Claimed(address indexed staker, uint256 reward);\\n\\n    // stake token address, ERC20\\n    address public stakeToken;\\n\\n    bool initialized;\\n\\n    bool locker;\\n\\n    // reward token address, ERC20\\n    address public rewardToken;\\n\\n    // Mining start date(epoch second)\\n    uint256 public startDateOfMining;\\n\\n    // Mining end date(epoch second)\\n    uint256 public endDateOfMining;\\n\\n    // controller address\\n    address controller;\\n\\n    // reward per Second\\n    uint256 public rewardPerSecond;\\n\\n    // timestamp of last updated\\n    uint256 public lastUpdatedTimestamp;\\n\\n    uint256 public rewardPerTokenStored;\\n\\n    // staked total\\n    uint256 private _totalSupply;\\n\\n    struct StakerInfo {\\n        // exclude reward's amount\\n        uint256 rewardDebt;\\n        // stake total\\n        uint256 amount;\\n        // pending reward\\n        uint256 reward;\\n    }\\n\\n    // staker's StakerInfo\\n    mapping(address => StakerInfo) public stakers;\\n\\n    /* ========== MODIFIER ========== */\\n\\n    modifier stakeable() {\\n        require(\\n            block.timestamp <= endDateOfMining,\\n            \\\"stake not begin or complete\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier enable() {\\n        require(initialized, \\\"initialized = false\\\");\\n        _;\\n    }\\n\\n    modifier onlyController {\\n        require(controller == msg.sender, \\\"only controller\\\");\\n        _;\\n    }\\n\\n    modifier lock() {\\n        require(locker == false, \\\"locked\\\");\\n        locker = true;\\n        _;\\n        locker = false;\\n    }\\n\\n    modifier updateReward(address _staker) {\\n        rewardPerTokenStored = rewardPerToken();\\n        lastUpdatedTimestamp = lastTimeRewardApplicable();\\n        if (_staker != address(0) && stakers[_staker].amount > 0) {\\n            stakers[_staker].reward = rewardOf(_staker);\\n            stakers[_staker].rewardDebt = rewardPerTokenStored;\\n        }\\n        _;\\n    }\\n\\n    constructor() {}\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n    /**\\n     * @dev initialize contract\\n     * @param _stake address of stake token\\n     * @param _reward address of reward token\\n     * @param _start epoch seconds of mining starts\\n     * @param _end epoch seconds of mining complete\\n     * @param _totalReward totalReward\\n     */\\n    function initialize(\\n        address _stake,\\n        address _reward,\\n        uint256 _start,\\n        uint256 _end,\\n        uint256 _totalReward\\n    ) external override {\\n        require(!initialized, \\\"initialized = true\\\");\\n        // only initialize once\\n        initialized = true;\\n        controller = msg.sender;\\n        stakeToken = _stake;\\n        rewardToken = _reward;\\n        startDateOfMining = _start;\\n        endDateOfMining = _end;\\n        rewardPerSecond = _totalReward / (_end - _start + 1);\\n    }\\n\\n    /**\\n     * @dev stake token\\n     * @param _amount amount of token to be staked\\n     */\\n    function stake(uint256 _amount)\\n        external\\n        enable()\\n        lock()\\n        updateReward(msg.sender)\\n    {\\n        require(_amount > 0, \\\"amount = 0\\\");\\n        require(\\n            block.timestamp <= endDateOfMining,\\n            \\\"stake not begin or complete\\\"\\n        );\\n        _totalSupply += _amount;\\n        stakers[msg.sender].amount += _amount;\\n        TransferHelper.safeTransferFrom(\\n            stakeToken,\\n            msg.sender,\\n            address(this),\\n            _amount\\n        );\\n        emit StakeUpdated(\\n            msg.sender,\\n            true,\\n            _amount,\\n            stakers[msg.sender].amount\\n        );\\n        _notify();\\n    }\\n\\n    /**\\n     * @dev unstake token\\n     * @param _amount amount of token to be unstaked\\n     */\\n    function unstake(uint256 _amount)\\n        public\\n        enable()\\n        lock()\\n        updateReward(msg.sender)\\n    {\\n        require(_amount > 0, \\\"amount = 0\\\");\\n        require(stakers[msg.sender].amount >= _amount, \\\"insufficient amount\\\");\\n        _claim(msg.sender);\\n        _totalSupply -= _amount;\\n        stakers[msg.sender].amount -= _amount;\\n        TransferHelper.safeTransfer(stakeToken, msg.sender, _amount);\\n        emit StakeUpdated(\\n            msg.sender,\\n            false,\\n            _amount,\\n            stakers[msg.sender].amount\\n        );\\n        _notify();\\n    }\\n\\n    /**\\n     * @dev claim rewards\\n     */\\n    function claim() external enable() lock() updateReward(msg.sender) {\\n        _claim(msg.sender);\\n    }\\n\\n    /**\\n     * @dev quit, claim reward + unstake all\\n     */\\n    function quit() external enable() lock() updateReward(msg.sender) {\\n        unstake(stakers[msg.sender].amount);\\n        _claim(msg.sender);\\n    }\\n\\n    /**\\n     * @dev claim rewards, only owner allowed\\n     * @param _staker staker address\\n     */\\n    function claim0(address _staker)\\n        external\\n        override\\n        onlyController()\\n        enable()\\n        updateReward(msg.sender)\\n    {\\n        _claim(_staker);\\n    }\\n\\n    /* ========== VIEWs ========== */\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\n        if (block.timestamp < startDateOfMining) return startDateOfMining;\\n        return\\n            block.timestamp > endDateOfMining\\n                ? endDateOfMining\\n                : block.timestamp;\\n    }\\n\\n    function rewardPerToken() public view returns (uint256) {\\n        if (_totalSupply == 0 || block.timestamp < startDateOfMining) {\\n            return rewardPerTokenStored;\\n        }\\n        return\\n            rewardPerTokenStored +\\n            (((lastTimeRewardApplicable() - lastUpdatedTimestamp) *\\n                rewardPerSecond) * 1e18) /\\n            _totalSupply;\\n    }\\n\\n    /**\\n     * @dev amount of stake per address\\n     * @param _staker staker address\\n     * @return amount of stake\\n     */\\n    function stakeOf(address _staker) external view returns (uint256) {\\n        return stakers[_staker].amount;\\n    }\\n\\n    /**\\n     * @dev amount of reward per address\\n     * @param _staker address\\n     * @return value reward amount of _staker\\n     */\\n    function rewardOf(address _staker) public view returns (uint256 value) {\\n        StakerInfo memory info = stakers[_staker];\\n        return\\n            (info.amount * (rewardPerToken() - info.rewardDebt)) /\\n            1e18 +\\n            info.reward;\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n    /**\\n     * @dev claim reward\\n     * @param _staker address\\n     */\\n    function _claim(address _staker) private {\\n        uint256 reward = stakers[_staker].reward;\\n        if (reward > 0) {\\n            stakers[_staker].reward = 0;\\n            IConfig config = IConfigable(controller).getConfig();\\n            uint256 claimFeeRate = config.claimFeeRate();\\n            uint256 out = (reward * (10000 - claimFeeRate)) / 10000;\\n            uint256 fee = reward - out;\\n            TransferHelper.safeTransfer(rewardToken, _staker, out);\\n\\n            if (fee > 0) {\\n                // transfer to feeTo\\n                TransferHelper.safeTransfer(rewardToken, config.feeTo(), fee);\\n            }\\n            emit Claimed(_staker, reward);\\n            _notify();\\n        }\\n    }\\n\\n    function _notify() private {\\n        IConfigable(controller).getConfig().notify(\\n            IConfig.EventType.STAKE_UPDATED,\\n            address(this)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Base.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\nimport \\\"./interfaces/IConfig.sol\\\";\\n\\ncontract Base {\\n    event ConfigUpdated(address indexed owner, address indexed config);\\n\\n    IConfig internal config;\\n\\n    modifier onlyCEO() {\\n        require(msg.sender == config.ceo(), \\\"only CEO\\\");\\n        _;\\n    }\\n\\n    constructor(address _configAddr) {\\n        require(_configAddr != address(0), \\\"config address = 0\\\");\\n        config = IConfig(_configAddr);\\n    }\\n\\n    function updateConfig(address _config) external onlyCEO() {\\n        require(_config != address(0), \\\"config address = 0\\\");\\n        require(address(config) != _config, \\\"address identical\\\");\\n        config = IConfig(_config);\\n        emit ConfigUpdated(msg.sender, _config);\\n    }\\n\\n    function configAddress() external view returns (address) {\\n        return address(config);\\n    }\\n\\n    function getConfig() external view returns (IConfig) {\\n        return config;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IConfig.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\ninterface IConfig {\\n    enum EventType {FUND_CREATED, FUND_UPDATED, STAKE_CREATED, STAKE_UPDATED, REG_CREATED, REG_UPDATED, PFUND_CREATED, PFUND_UPDATED}\\n\\n    function ceo() external view returns (address);\\n\\n    function protocolPool() external view returns (address);\\n\\n    function protocolToken() external view returns (address);\\n\\n    function feeTo() external view returns (address);\\n\\n    function nameRegistry() external view returns (address);\\n\\n    //  function investTokenWhitelist() external view returns (address[] memory);\\n\\n    function tokenMinFundSize(address token) external view returns (uint256);\\n\\n    function investFeeRate() external view returns (uint256);\\n\\n    function redeemFeeRate() external view returns (uint256);\\n\\n    function claimFeeRate() external view returns (uint256);\\n\\n    function poolCreationRate() external view returns (uint256);\\n\\n    function slot0() external view returns (uint256);\\n\\n    function slot1() external view returns (uint256);\\n\\n    function slot2() external view returns (uint256);\\n\\n    function slot3() external view returns (uint256);\\n\\n    function slot4() external view returns (uint256);\\n\\n    function notify(EventType _type, address _src) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libs/TransferHelper.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper: APPROVE_FAILED'\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper: TRANSFER_FAILED'\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper: TRANSFER_FROM_FAILED'\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_config\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lib\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"config\",\"type\":\"address\"}],\"name\":\"ConfigUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newLib\",\"type\":\"address\"}],\"name\":\"LibUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stake\",\"type\":\"address\"}],\"name\":\"StakeCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allStakes\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_stakes\",\"type\":\"address[]\"}],\"name\":\"claims\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalReward\",\"type\":\"uint256\"}],\"name\":\"createStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"contract IConfig\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lib\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_config\",\"type\":\"address\"}],\"name\":\"updateConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lib\",\"type\":\"address\"}],\"name\":\"updateLib\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StakeManager","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"000000000000000000000000a2d0b2148c84c71e873bcdc45dfed041822cfbb9000000000000000000000000373616539533ffb05cfe6f135dbc63a9fc967f11","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}