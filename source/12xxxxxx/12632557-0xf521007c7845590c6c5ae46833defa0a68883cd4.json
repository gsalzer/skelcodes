{"status":"1","message":"OK","result":[{"SourceCode":"/***\r\n *   _____                  _          __  __       _ _   _                    _           \r\n *  / ____|                | |        |  \\/  |     | | | (_)                  | |          \r\n * | |     _ __ _   _ _ __ | |_ ___   | \\  / |_   _| | |_ _ ___  ___ _ __   __| | ___ _ __ \r\n * | |    | '__| | | | '_ \\| __/ _ \\  | |\\/| | | | | | __| / __|/ _ \\ '_ \\ / _` |/ _ \\ '__|\r\n * | |____| |  | |_| | |_) | || (_) | | |  | | |_| | | |_| \\__ \\  __/ | | | (_| |  __/ |   \r\n *  \\_____|_|   \\__, | .__/ \\__\\___/  |_|  |_|\\__,_|_|\\__|_|___/\\___|_| |_|\\__,_|\\___|_|   \r\n *               __/ | |                                                                   \r\n *             |___/|_|                                                                   \r\n *        \r\n * \r\n * @author Zenos Pavlakou\r\n */\r\n \r\n \r\npragma solidity ^0.6.0;\r\n\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract Ownable {\r\n    \r\n    address public owner;\r\n    \r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n    \r\n    \r\n    /**\r\n     * Constructor assigns ownership to the address used to deploy the contract.\r\n     * */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    function getOwner() public view returns(address) {\r\n        return owner;\r\n    }\r\n\r\n\r\n    /**\r\n     * Any function with this modifier in its method signature can only be executed by\r\n     * the owner of the contract. Any attempt made by any other account to invoke the \r\n     * functions with this modifier will result in a loss of gas and the contract's state\r\n     * will remain untampered.\r\n     * */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Function restricted to owner of contract\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Allows for the transfer of ownership to another address;\r\n     * \r\n     * @param _newOwner The address to be assigned new ownership.\r\n     * */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(\r\n            _newOwner != address(0)\r\n            && _newOwner != owner \r\n        );\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * Contract acts as an interface between the DappleAirdrops contract and all ERC20 compliant\r\n * tokens. \r\n * */\r\nabstract contract ERCInterface {\r\n    function transferFrom(address _from, address _to, uint256 _value) public virtual;\r\n    function balanceOf(address who)  public virtual returns (uint256);\r\n    function allowance(address owner, address spender)  public view virtual returns (uint256);\r\n    function transfer(address to, uint256 value) public virtual returns(bool);\r\n}\r\n\r\n\r\n\r\ncontract CryptoMultisender is Ownable {\r\n    \r\n    using SafeMath for uint256;\r\n \r\n    mapping (address => uint256) public tokenTrialDrops;\r\n\r\n    mapping (address => bool) public isPremiumMember;\r\n    mapping (address => bool) public isAffiliate;\r\n    mapping (string => address) public affiliateCodeToAddr;\r\n    mapping (string => bool) public affiliateCodeExists;\r\n    mapping (address => string) public affiliateCodeOfAddr;\r\n    mapping (address => string) public isAffiliatedWith;\r\n        \r\n    uint256 public premiumMemberFee;\r\n    uint256 public rate;\r\n    uint256 public dropUnitPrice;\r\n\r\n\r\n    event TokenAirdrop(address indexed by, address indexed tokenAddress, uint256 totalTransfers);\r\n    event EthAirdrop(address indexed by, uint256 totalTransfers, uint256 ethValue);\r\n\r\n\r\n   \r\n    event RateChanged(uint256 from, uint256 to);\r\n    event RefundIssued(address indexed to, uint256 totalWei);\r\n    event ERC20TokensWithdrawn(address token, address sentTo, uint256 value);\r\n    event CommissionPaid(address indexed to, uint256 value);\r\n    event NewPremiumMembership(address indexed premiumMember);\r\n    event NewAffiliatePartnership(address indexed newAffiliate, string indexed affiliateCode);\r\n    event AffiliatePartnershipRevoked(address indexed affiliate, string indexed affiliateCode);\r\n    event PremiumMemberFeeUpdated(uint256 newFee);\r\n\r\n    \r\n    constructor() public {\r\n        rate = 10000;\r\n        dropUnitPrice = 1e14; \r\n        premiumMemberFee = 25e16;\r\n    }\r\n    \r\n\r\n    /**\r\n     * Allows the owner of this contract to change the fee for users to become premium members.\r\n     * \r\n     * @param _fee The new fee.\r\n     * \r\n     * @return True if the fee is changed successfully. False otherwise.\r\n     * */\r\n    function setPremiumMemberFee(uint256 _fee) public onlyOwner returns(bool) {\r\n        require(_fee > 0 && _fee != premiumMemberFee);\r\n        premiumMemberFee = _fee;\r\n        emit PremiumMemberFeeUpdated(_fee);\r\n        return true;\r\n    }\r\n    \r\n\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k-1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n\r\n    /**\r\n    * Used to give change to users who accidentally send too much ETH to payable functions. \r\n    *\r\n    * @param _price The service fee the user has to pay for function execution. \r\n    **/\r\n    function giveChange(uint256 _price) internal {\r\n        if(msg.value > _price) {\r\n            uint256 change = msg.value.sub(_price);\r\n            payable(msg.sender).transfer(change);\r\n        }\r\n    }\r\n\r\n    \r\n    /**\r\n    * Ensures that the correct affiliate code is used and also ensures that affiliate partners\r\n    * are not able to 'jack' commissions from existing users who they are not affiliated with. \r\n    *\r\n    * @param _afCode The affiliate code provided by the user.\r\n    *\r\n    * @return The correct affiliate code or void.\r\n    **/\r\n    function processAffiliateCode(string memory _afCode) internal returns(string memory) {\r\n        \r\n        if(stringsAreEqual(isAffiliatedWith[msg.sender], \"void\") || !isAffiliate[affiliateCodeToAddr[_afCode]]) {\r\n            isAffiliatedWith[msg.sender] = \"void\";\r\n            return \"void\";\r\n        }\r\n        \r\n        if(!stringsAreEqual(_afCode, \"\") && stringsAreEqual(isAffiliatedWith[msg.sender],\"\") \r\n                                                                && affiliateCodeExists[_afCode]) {\r\n            if(affiliateCodeToAddr[_afCode] == msg.sender) {\r\n                return \"void\";\r\n            }\r\n            isAffiliatedWith[msg.sender] = _afCode;\r\n        }\r\n\r\n        if(stringsAreEqual(_afCode,\"\") && !stringsAreEqual(isAffiliatedWith[msg.sender],\"\")) {\r\n            _afCode = isAffiliatedWith[msg.sender];\r\n        } \r\n        \r\n        if(stringsAreEqual(_afCode,\"\") || !affiliateCodeExists[_afCode]) {\r\n            isAffiliatedWith[msg.sender] = \"void\";\r\n            _afCode = \"void\";\r\n        }\r\n        \r\n        return _afCode;\r\n    }\r\n\r\n\r\n    /**\r\n    * Allows the owner of this contract to grant users with premium membership.\r\n    *\r\n    * @param _addr The address of the user who is being granted premium membership.\r\n    *\r\n    * @return True if premium membership is granted successfully. False otherwise. \r\n    **/\r\n    function grantPremiumMembership(address _addr) public onlyOwner returns(bool) {\r\n        require(!isPremiumMember[_addr], \"Is already premiumMember member\");\r\n        isPremiumMember[_addr] = true;\r\n        emit NewPremiumMembership(_addr);\r\n        return true; \r\n    }\r\n\r\n\r\n    /**\r\n    * Allows users to become premium members.\r\n    *\r\n    * @param _afCode If a user has been refferred by an affiliate partner, they can provide \r\n    * an affiliate code so the partner gets commission.\r\n    *\r\n    * @return True if user successfully becomes premium member. False otherwise. \r\n    **/\r\n    function becomePremiumMember(string memory _afCode) public payable returns(bool) {\r\n        require(!isPremiumMember[msg.sender], \"Is already premiumMember member\");\r\n        require(\r\n            msg.value >= premiumMemberFee,\r\n            string(abi.encodePacked(\r\n                \"premiumMember fee is: \", uint2str(premiumMemberFee), \". Not enough ETH sent. \", uint2str(msg.value)\r\n            ))\r\n        );\r\n        \r\n        isPremiumMember[msg.sender] = true;\r\n        \r\n        _afCode = processAffiliateCode(_afCode);\r\n\r\n        giveChange(premiumMemberFee);\r\n        \r\n        if(!stringsAreEqual(_afCode,\"void\") && isAffiliate[affiliateCodeToAddr[_afCode]]) {\r\n            payable(owner).transfer(premiumMemberFee.mul(80).div(100));\r\n            uint256 commission = premiumMemberFee.mul(20).div(100);\r\n            payable(affiliateCodeToAddr[_afCode]).transfer(commission);\r\n            emit CommissionPaid(affiliateCodeToAddr[_afCode], commission);\r\n        } else {\r\n            payable(owner).transfer(premiumMemberFee);\r\n        }\r\n        emit NewPremiumMembership(msg.sender);\r\n        return true; \r\n    }\r\n    \r\n    \r\n    /**\r\n    * Allows the owner of this contract to add an affiliate partner.\r\n    *\r\n    * @param _addr The address of the new affiliate partner.\r\n    * @param _code The affiliate code.\r\n    * \r\n    * @return True if the affiliate has been added successfully. False otherwise. \r\n    **/\r\n    function addAffiliate(address _addr, string memory _code) public onlyOwner returns(bool) {\r\n        require(!isAffiliate[_addr], \"Address is already an affiliate.\");\r\n        require(_addr != address(0));\r\n        require(!affiliateCodeExists[_code]);\r\n        affiliateCodeExists[_code] = true;\r\n        isAffiliate[_addr] = true;\r\n        affiliateCodeToAddr[_code] = _addr;\r\n        affiliateCodeOfAddr[_addr] = _code;\r\n        emit NewAffiliatePartnership(_addr,_code);\r\n        return true;\r\n    }\r\n    \r\n\r\n    /**\r\n    * Allows the owner of this contract to remove an affiliate partner. \r\n    *\r\n    * @param _addr The address of the affiliate partner.\r\n    *\r\n    * @return True if affiliate partner is removed successfully. False otherwise. \r\n    **/\r\n    function removeAffiliate(address _addr) public onlyOwner returns(bool) {\r\n        require(isAffiliate[_addr]);\r\n        isAffiliate[_addr] = false;\r\n        affiliateCodeToAddr[affiliateCodeOfAddr[_addr]] = address(0);\r\n        emit AffiliatePartnershipRevoked(_addr, affiliateCodeOfAddr[_addr]);\r\n        affiliateCodeOfAddr[_addr] = \"No longer an affiliate partner\";\r\n        return true;\r\n    }\r\n    \r\n\r\n    \r\n    /**\r\n     * Checks whether or not an ERC20 token has used its free trial of 100 drops. This is a constant \r\n     * function which does not alter the state of the contract and therefore does not require any gas \r\n     * or a signature to be executed. \r\n     * \r\n     * @param _addressOfToken The address of the token being queried.\r\n     * \r\n     * @return true if the token being queried has not used its 100 first free trial drops, false\r\n     * otherwise.\r\n     * */\r\n    function tokenHasFreeTrial(address _addressOfToken) public view returns(bool) {\r\n        return tokenTrialDrops[_addressOfToken] < 100;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Checks how many remaining free trial drops a token has.\r\n     * \r\n     * @param _addressOfToken the address of the token being queried.\r\n     * \r\n     * @return the total remaining free trial drops of a token.\r\n     * */\r\n    function getRemainingTrialDrops(address _addressOfToken) public view returns(uint256) {\r\n        if(tokenHasFreeTrial(_addressOfToken)) {\r\n            uint256 maxTrialDrops =  100;\r\n            return maxTrialDrops.sub(tokenTrialDrops[_addressOfToken]);\r\n        } \r\n        return 0;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for the price of drops to be changed by the owner of the contract. Any attempt made by \r\n     * any other account to invoke the function will result in a loss of gas and the price will remain \r\n     * untampered.\r\n     * \r\n     * @return true if function executes successfully, false otherwise.\r\n     * */\r\n    function setRate(uint256 _newRate) public onlyOwner returns(bool) {\r\n        require(\r\n            _newRate != rate \r\n            && _newRate > 0\r\n        );\r\n        emit RateChanged(rate, _newRate);\r\n        rate = _newRate;\r\n        uint256 eth = 1 ether;\r\n        dropUnitPrice = eth.div(rate);\r\n        return true;\r\n    }\r\n    \r\n    \r\n\r\n    /**\r\n     * Allows for the allowance of a token from its owner to this contract to be queried. \r\n     * \r\n     * As part of the ERC20 standard all tokens which fall under this category have an allowance \r\n     * function which enables owners of tokens to allow (or give permission) to another address \r\n     * to spend tokens on behalf of the owner. This contract uses this as part of its protocol.\r\n     * Users must first give permission to the contract to transfer tokens on their behalf, however,\r\n     * this does not mean that the tokens will ever be transferrable without the permission of the \r\n     * owner. This is a security feature which was implemented on this contract. It is not possible\r\n     * for the owner of this contract or anyone else to transfer the tokens which belong to others. \r\n     * \r\n     * @param _addr The address of the token's owner.\r\n     * @param _addressOfToken The contract address of the ERC20 token.\r\n     * \r\n     * @return The ERC20 token allowance from token owner to this contract. \r\n     * */\r\n    function getTokenAllowance(address _addr, address _addressOfToken) public view returns(uint256) {\r\n        ERCInterface token = ERCInterface(_addressOfToken);\r\n        return token.allowance(_addr, address(this));\r\n    }\r\n    \r\n    \r\n    fallback() external payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    receive() external payable {\r\n        revert();\r\n    }\r\n    \r\n    \r\n    /**\r\n    * Checks if two strings are the same.\r\n    *\r\n    * @param _a String 1\r\n    * @param _b String 2\r\n    *\r\n    * @return True if both strings are the same. False otherwise. \r\n    **/\r\n    function stringsAreEqual(string memory _a, string memory _b) internal pure returns(bool) {\r\n        bytes32 hashA = keccak256(abi.encodePacked(_a));\r\n        bytes32 hashB = keccak256(abi.encodePacked(_b));\r\n        return hashA == hashB;\r\n    }\r\n \r\n    \r\n    /**\r\n     * Allows for the distribution of Ether to be transferred to multiple recipients at \r\n     * a time. This function only facilitates batch transfers of constant values (i.e., all recipients\r\n     * will receive the same amount of tokens).\r\n     * \r\n     * @param _recipients The list of addresses which will receive tokens. \r\n     * @param _value The amount of tokens all addresses will receive. \r\n     * @param _afCode If the user is affiliated with a partner, they will provide this code so that \r\n     * the parter is paid commission.\r\n     * \r\n     * @return true if function executes successfully, false otherwise.\r\n     * */\r\n    function singleValueEthAirrop(address[] memory _recipients, uint256 _value, string memory _afCode) public payable returns(bool) {\r\n        \r\n        uint256 price = _recipients.length.mul(dropUnitPrice);\r\n        uint256 totalCost = _value.mul(_recipients.length).add(price);\r\n\r\n        require(\r\n            msg.value >= totalCost|| isPremiumMember[msg.sender],\r\n            \"Not enough ETH sent with transaction!\"\r\n        );\r\n\r\n        \r\n        _afCode = processAffiliateCode(_afCode);\r\n        \r\n        \r\n        if(!isPremiumMember[msg.sender]) {\r\n            distributeCommission(_recipients.length, _afCode);\r\n        }\r\n\r\n        giveChange(totalCost);\r\n        \r\n        for(uint i=0; i<_recipients.length; i++) {\r\n            if(_recipients[i] != address(0)) {\r\n                payable(_recipients[i]).transfer(_value);\r\n            }\r\n        }\r\n\r\n        emit EthAirdrop(msg.sender, _recipients.length, _value.mul(_recipients.length));\r\n        \r\n        return true;\r\n    }\r\n    \r\n\r\n    \r\n    function _getTotalEthValue(uint256[] memory _values) internal pure returns(uint256) {\r\n        uint256 totalVal = 0;\r\n        for(uint i = 0; i < _values.length; i++) {\r\n            totalVal = totalVal.add(_values[i]);\r\n        }\r\n        return totalVal;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for the distribution of Ether to be transferred to multiple recipients at \r\n     * a time. \r\n     * \r\n     * @param _recipients The list of addresses which will receive tokens. \r\n     * @param _values The corresponding amounts that the recipients will receive \r\n     * @param _afCode If the user is affiliated with a partner, they will provide this code so that \r\n     * the parter is paid commission.\r\n     * \r\n     * @return true if function executes successfully, false otherwise.\r\n     * */\r\n    function multiValueEthAirdrop(address[] memory _recipients, uint256[] memory _values, string memory _afCode) public payable returns(bool) {\r\n        require(_recipients.length == _values.length, \"Total number of recipients and values are not equal\");\r\n\r\n        uint256 totalEthValue = _getTotalEthValue(_values);\r\n        uint256 price = _recipients.length.mul(dropUnitPrice);\r\n        uint256 totalCost = totalEthValue.add(price);\r\n\r\n        require(\r\n            msg.value >= totalCost || isPremiumMember[msg.sender], \r\n            \"Not enough ETH sent with transaction!\"\r\n        );\r\n        \r\n        \r\n        _afCode = processAffiliateCode(_afCode);\r\n        \r\n        if(!isPremiumMember[msg.sender]) {\r\n            distributeCommission(_recipients.length, _afCode);\r\n        }\r\n\r\n        giveChange(totalCost);\r\n        \r\n        for(uint i = 0; i < _recipients.length; i++) {\r\n            if(_recipients[i] != address(0) && _values[i] > 0) {\r\n                payable(_recipients[i]).transfer(_values[i]);\r\n            }\r\n        }\r\n        \r\n        emit EthAirdrop(msg.sender, _recipients.length, totalEthValue);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for the distribution of an ERC20 token to be transferred to multiple recipients at \r\n     * a time. This function only facilitates batch transfers of constant values (i.e., all recipients\r\n     * will receive the same amount of tokens).\r\n     * \r\n     * @param _addressOfToken The contract address of an ERC20 token.\r\n     * @param _recipients The list of addresses which will receive tokens. \r\n     * @param _value The amount of tokens all addresses will receive. \r\n     * @param _afCode If the user is affiliated with a partner, they will provide this code so that \r\n     * the parter is paid commission.\r\n     * \r\n     * @return true if function executes successfully, false otherwise.\r\n     * */\r\n    function singleValueTokenAirdrop(address _addressOfToken,  address[] memory _recipients, uint256 _value, string memory _afCode) public payable returns(bool) {\r\n        ERCInterface token = ERCInterface(_addressOfToken);\r\n\r\n        uint256 price = _recipients.length.mul(dropUnitPrice);\r\n\r\n        require(\r\n            msg.value >= price || tokenHasFreeTrial(_addressOfToken) || isPremiumMember[msg.sender],\r\n            \"Not enough ETH sent with transaction!\"\r\n        );\r\n\r\n        giveChange(price);\r\n\r\n        _afCode = processAffiliateCode(_afCode);\r\n        \r\n        for(uint i = 0; i < _recipients.length; i++) {\r\n            if(_recipients[i] != address(0)) {\r\n                token.transferFrom(msg.sender, _recipients[i], _value);\r\n            }\r\n        }\r\n        if(tokenHasFreeTrial(_addressOfToken)) {\r\n            tokenTrialDrops[_addressOfToken] = tokenTrialDrops[_addressOfToken].add(_recipients.length);\r\n        } else {\r\n            if(!isPremiumMember[msg.sender]) {\r\n                distributeCommission(_recipients.length, _afCode);\r\n            }\r\n            \r\n        }\r\n\r\n        emit TokenAirdrop(msg.sender, _addressOfToken, _recipients.length);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for the distribution of an ERC20 token to be transferred to multiple recipients at \r\n     * a time. This function facilitates batch transfers of differing values (i.e., all recipients\r\n     * can receive different amounts of tokens).\r\n     * \r\n     * @param _addressOfToken The contract address of an ERC20 token.\r\n     * @param _recipients The list of addresses which will receive tokens. \r\n     * @param _values The corresponding values of tokens which each address will receive.\r\n     * @param _afCode If the user is affiliated with a partner, they will provide this code so that \r\n     * the parter is paid commission.\r\n     * \r\n     * @return true if function executes successfully, false otherwise.\r\n     * */    \r\n    function multiValueTokenAirdrop(address _addressOfToken,  address[] memory _recipients, uint256[] memory _values, string memory _afCode) public payable returns(bool) {\r\n        ERCInterface token = ERCInterface(_addressOfToken);\r\n        require(_recipients.length == _values.length, \"Total number of recipients and values are not equal\");\r\n\r\n        uint256 price = _recipients.length.mul(dropUnitPrice);\r\n\r\n        require(\r\n            msg.value >= price || tokenHasFreeTrial(_addressOfToken) || isPremiumMember[msg.sender],\r\n            \"Not enough ETH sent with transaction!\"\r\n        );\r\n\r\n        giveChange(price);\r\n        \r\n        _afCode = processAffiliateCode(_afCode);\r\n        \r\n        for(uint i = 0; i < _recipients.length; i++) {\r\n            if(_recipients[i] != address(0) && _values[i] > 0) {\r\n                token.transferFrom(msg.sender, _recipients[i], _values[i]);\r\n            }\r\n        }\r\n        if(tokenHasFreeTrial(_addressOfToken)) {\r\n            tokenTrialDrops[_addressOfToken] = tokenTrialDrops[_addressOfToken].add(_recipients.length);\r\n        } else {\r\n            if(!isPremiumMember[msg.sender]) {\r\n                distributeCommission(_recipients.length, _afCode);\r\n            }\r\n        }\r\n        emit TokenAirdrop(msg.sender, _addressOfToken, _recipients.length);\r\n        return true;\r\n    }\r\n        \r\n\r\n    /**\r\n    * Send the owner and affiliates commissions.\r\n    **/\r\n    function distributeCommission(uint256 _drops, string memory _afCode) internal {\r\n        if(!stringsAreEqual(_afCode,\"void\") && isAffiliate[affiliateCodeToAddr[_afCode]]) {\r\n            uint256 profitSplit = _drops.mul(dropUnitPrice).div(2);\r\n            payable(owner).transfer(profitSplit);\r\n            payable(affiliateCodeToAddr[_afCode]).transfer(profitSplit);\r\n            emit CommissionPaid(affiliateCodeToAddr[_afCode], profitSplit);\r\n        } else {\r\n            payable(owner).transfer(_drops.mul(dropUnitPrice));\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n\r\n    /**\r\n     * Allows for any ERC20 tokens which have been mistakenly  sent to this contract to be returned \r\n     * to the original sender by the owner of the contract. Any attempt made by any other account \r\n     * to invoke the function will result in a loss of gas and no tokens will be transferred out.\r\n     * \r\n     * @param _addressOfToken The contract address of an ERC20 token.\r\n     * @param _recipient The address which will receive tokens. \r\n     * @param _value The amount of tokens to refund.\r\n     * \r\n     * @return true if function executes successfully, false otherwise.\r\n     * */  \r\n    function withdrawERC20Tokens(address _addressOfToken,  address _recipient, uint256 _value) public onlyOwner returns(bool){\r\n        require(\r\n            _addressOfToken != address(0)\r\n            && _recipient != address(0)\r\n            && _value > 0\r\n        );\r\n        ERCInterface token = ERCInterface(_addressOfToken);\r\n        token.transfer(_recipient, _value);\r\n        emit ERC20TokensWithdrawn(_addressOfToken, _recipient, _value);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"affiliateCode\",\"type\":\"string\"}],\"name\":\"AffiliatePartnershipRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"CommissionPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sentTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ERC20TokensWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalTransfers\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethValue\",\"type\":\"uint256\"}],\"name\":\"EthAirdrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAffiliate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"affiliateCode\",\"type\":\"string\"}],\"name\":\"NewAffiliatePartnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"premiumMember\",\"type\":\"address\"}],\"name\":\"NewPremiumMembership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"PremiumMemberFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"RateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalWei\",\"type\":\"uint256\"}],\"name\":\"RefundIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalTransfers\",\"type\":\"uint256\"}],\"name\":\"TokenAirdrop\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_code\",\"type\":\"string\"}],\"name\":\"addAffiliate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"affiliateCodeExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"affiliateCodeOfAddr\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"affiliateCodeToAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_afCode\",\"type\":\"string\"}],\"name\":\"becomePremiumMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropUnitPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressOfToken\",\"type\":\"address\"}],\"name\":\"getRemainingTrialDrops\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addressOfToken\",\"type\":\"address\"}],\"name\":\"getTokenAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"grantPremiumMembership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAffiliate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAffiliatedWith\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPremiumMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"_afCode\",\"type\":\"string\"}],\"name\":\"multiValueEthAirdrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressOfToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"_afCode\",\"type\":\"string\"}],\"name\":\"multiValueTokenAirdrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"premiumMemberFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeAffiliate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setPremiumMemberFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newRate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_afCode\",\"type\":\"string\"}],\"name\":\"singleValueEthAirrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressOfToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_afCode\",\"type\":\"string\"}],\"name\":\"singleValueTokenAirdrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressOfToken\",\"type\":\"address\"}],\"name\":\"tokenHasFreeTrial\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenTrialDrops\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressOfToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20Tokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"CryptoMultisender","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://96dce15685d440ceb5d189949078d99a0c4a4ffe14225ab47a018e9900dc5000"}]}