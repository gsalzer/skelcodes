{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/IWCHI.sol\r\n\r\n// Copyright (C) 2021 Autonomous Worlds Ltd\r\n\r\npragma solidity ^0.7.6;\r\n\r\n\r\n/**\r\n * @dev Interface for the wrapped CHI (WCHI) token.\r\n */\r\ninterface IWCHI is IERC20\r\n{\r\n\r\n  /**\r\n   * @dev Burns the given number of tokens, reducing total supply.\r\n   */\r\n  function burn (uint256 value) external;\r\n\r\n  /**\r\n   * @dev Increases the allowance of a given spender by the given amount.\r\n   */\r\n  function increaseAllowance (address spender, uint256 addedValue)\r\n      external returns (bool);\r\n\r\n  /**\r\n   * @dev Decreases the allowance of a given spender by the given amount.\r\n   */\r\n  function decreaseAllowance (address spender, uint256 removedValue)\r\n      external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/WCHI.sol\r\n\r\n// Copyright (C) 2021 Autonomous Worlds Ltd\r\n\r\npragma solidity ^0.7.6;\r\n\r\n\r\n/**\r\n * @dev Wrapped CHI (WCHI) token.  This contract is not upgradable and not\r\n * owned, but it grants an initial supply to the contract creator.  The Xaya\r\n * team will hold these tokens, and give them out for CHI locked on the\r\n * Xaya network.  When WCHI tokens are returned, those CHI will be released\r\n * again.\r\n */\r\ncontract WCHI is IWCHI\r\n{\r\n\r\n  string public constant name = \"Wrapped CHI\";\r\n  string public constant symbol = \"WCHI\";\r\n\r\n  /** @dev Native CHI has 8 decimals (like BTC), we mimic that here.  */\r\n  uint8 public constant decimals = 8;\r\n\r\n  /**\r\n   * @dev Initial supply of tokens minted.  This is a bit larger than the\r\n   * real total supply of CHI.\r\n   */\r\n  uint256 internal constant initialSupply = 78 * 10**6 * 10**decimals;\r\n\r\n  /**\r\n   * @dev Total supply of tokens.  This includes tokens that are in the\r\n   * Xaya team's reserve, i.e. do not correspond to real CHI locked\r\n   * in the treasury.\r\n   */\r\n  uint256 public override totalSupply;\r\n\r\n  /** @dev Balances of tokens per address.  */\r\n  mapping (address => uint256) public override balanceOf;\r\n\r\n  /**\r\n   * @dev Allowances for accounts (second) to spend from the balance\r\n   * of an owner (first).\r\n   */\r\n  mapping (address => mapping (address => uint256)) public override allowance;\r\n\r\n  /**\r\n   * @dev In the constructor, we grant the contract creator the initial balance.\r\n   * This is the only place where any address has special rights compared\r\n   * to all others.\r\n   */\r\n  constructor ()\r\n  {\r\n    totalSupply = initialSupply;\r\n    balanceOf[msg.sender] = initialSupply;\r\n    emit Transfer (address (0), msg.sender, initialSupply);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the allowance afforded to the given spender by\r\n   * the message sender.\r\n   */\r\n  function approve (address spender, uint256 value)\r\n      external override returns (bool)\r\n  {\r\n    setApproval (msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Moves a given amount of tokens from the message sender's\r\n   * account to the recipient.  If to is the zero address, then those\r\n   * tokens are burnt and reduce the total supply.\r\n   */\r\n  function transfer (address to, uint256 value) external override returns (bool)\r\n  {\r\n    uncheckedTransfer (msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Moves a given amount of tokens from the sender account to the\r\n   * recipient.  If from is not the message sender, then it needs to have\r\n   * sufficient allowance.\r\n   */\r\n  function transferFrom (address from, address to, uint256 value)\r\n      external override returns (bool)\r\n  {\r\n    if (from != msg.sender)\r\n      {\r\n        /* Check for the allowance and reduce it.  */\r\n        uint256 allowed = allowance[from][msg.sender];\r\n        if (allowed != type (uint256).max)\r\n          {\r\n            require (allowed >= value, \"WCHI: allowance exceeded\");\r\n            uint256 newAllowed = allowed - value;\r\n            setApproval (from, msg.sender, newAllowed);\r\n          }\r\n      }\r\n\r\n    uncheckedTransfer (from, to, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal transfer implementation.  This is used to implement transfer\r\n   * and transferFrom, and does not check that the sender is actually\r\n   * allowed to spend the tokens.\r\n   */\r\n  function uncheckedTransfer (address from, address to, uint256 value) internal\r\n  {\r\n    require (to != address (0), \"WCHI: transfer to zero address\");\r\n    require (to != address (this), \"WCHI: transfer to contract address\");\r\n\r\n    deductBalance (from, value);\r\n    balanceOf[to] += value;\r\n\r\n    emit Transfer (from, to, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Burns tokens from the sender's balance, reducing total supply.\r\n   */\r\n  function burn (uint256 value) external override\r\n  {\r\n    deductBalance (msg.sender, value);\r\n    assert (totalSupply >= value);\r\n    totalSupply -= value;\r\n    emit Transfer (msg.sender, address (0), value);\r\n  }\r\n\r\n  /**\r\n   * @dev Increases the allowance of a given spender by a certain\r\n   * amount (rather than explicitly setting the new allowance).  This fails\r\n   * if the new allowance would be at infinity (or overflow).\r\n   */\r\n  function increaseAllowance (address spender, uint256 addedValue)\r\n      external override returns (bool)\r\n  {\r\n    uint256 allowed = allowance[msg.sender][spender];\r\n\r\n    uint256 increaseToInfinity = type (uint256).max - allowed;\r\n    require (addedValue < increaseToInfinity,\r\n             \"WCHI: increase allowance overflow\");\r\n\r\n    setApproval (msg.sender, spender, allowed + addedValue);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decreases the allowance of a given spender by a certain value.\r\n   * If the value is more than the current allowance, it is set to zero.\r\n   */\r\n  function decreaseAllowance (address spender, uint256 removedValue)\r\n      external override returns (bool)\r\n  {\r\n    uint256 allowed = allowance[msg.sender][spender];\r\n\r\n    if (removedValue >= allowed)\r\n      setApproval (msg.sender, spender, 0);\r\n    else\r\n      setApproval (msg.sender, spender, allowed - removedValue);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal helper function to check the balance of the given user\r\n   * and deduct the given amount.\r\n   */\r\n  function deductBalance (address from, uint256 value) internal\r\n  {\r\n    uint256 balance = balanceOf[from];\r\n    require (balance >= value, \"WCHI: insufficient balance\");\r\n    balanceOf[from] = balance - value;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal helper function to explicitly set the allowance of\r\n   * a spender without any checks, and emit the Approval event.\r\n   */\r\n  function setApproval (address owner, address spender, uint256 value) internal\r\n  {\r\n    allowance[owner][spender] = value;\r\n    emit Approval (owner, spender, value);\r\n  }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"removedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"WCHI","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5670d98d317cd3c17b8cba3f44e842857776337c386d585ac06c19e20228c0fd"}]}