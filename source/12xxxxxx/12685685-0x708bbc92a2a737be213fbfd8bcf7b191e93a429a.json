{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libraries/DateString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nlibrary DateString {\\n    uint256 public constant SECONDS_PER_DAY = 24 * 60 * 60;\\n    uint256 public constant SECONDS_PER_HOUR = 60 * 60;\\n    uint256 public constant SECONDS_PER_MINUTE = 60;\\n    int256 public constant OFFSET19700101 = 2440588;\\n\\n    // This function was forked from https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\n    // ------------------------------------------------------------------------\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // int L = days + 68569 + offset\\n    // int N = 4 * L / 146097\\n    // L = L - (146097 * N + 3) / 4\\n    // year = 4000 * (L + 1) / 1461001\\n    // L = L - 1461 * year / 4 + 31\\n    // month = 80 * L / 2447\\n    // dd = L - 2447 * month / 80\\n    // L = month / 11\\n    // month = month + 2 - 12 * L\\n    // year = 100 * (N - 49) + year + L\\n    // ------------------------------------------------------------------------\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    function _daysToDate(uint256 _days)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        int256 __days = int256(_days);\\n        // solhint-disable-next-line var-name-mixedcase\\n        int256 L = __days + 68569 + OFFSET19700101;\\n        // solhint-disable-next-line var-name-mixedcase\\n        int256 N = (4 * L) / 146097;\\n        L = L - (146097 * N + 3) / 4;\\n        int256 _year = (4000 * (L + 1)) / 1461001;\\n        L = L - (1461 * _year) / 4 + 31;\\n        int256 _month = (80 * L) / 2447;\\n        int256 _day = L - (2447 * _month) / 80;\\n        L = _month / 11;\\n        _month = _month + 2 - 12 * L;\\n        _year = 100 * (N - 49) + _year + L;\\n\\n        year = uint256(_year);\\n        month = uint256(_month);\\n        day = uint256(_day);\\n    }\\n\\n    /// @dev Writes a prefix and an timestamp encoding to an output storage location\\n    ///      This function is designed to only work with ASCII encoded strings. No emojis please.\\n    /// @param _prefix The string to write before the timestamp\\n    /// @param _timestamp the timestamp to encode and store\\n    /// @param _output the storage location of the output string\\n    /// NOTE - Current cost ~90k if gas is problem revisit and use assembly to remove the extra\\n    ///        sstore s.\\n    function encodeAndWriteTimestamp(\\n        string memory _prefix,\\n        uint256 _timestamp,\\n        string storage _output\\n    ) external {\\n        _encodeAndWriteTimestamp(_prefix, _timestamp, _output);\\n    }\\n\\n    /// @dev Sn internal version of the above function 'encodeAndWriteTimestamp'\\n    // solhint-disable-next-line\\n    function _encodeAndWriteTimestamp(\\n        string memory _prefix,\\n        uint256 _timestamp,\\n        string storage _output\\n    ) internal {\\n        // Cast the prefix string to a byte array\\n        bytes memory bytePrefix = bytes(_prefix);\\n        // Cast the output string to a byte array\\n        bytes storage bytesOutput = bytes(_output);\\n        // Copy the bytes from the prefix onto the byte array\\n        // NOTE - IF PREFIX CONTAINS NON-ASCII CHARS THIS WILL CAUSE AN INCORRECT STRING LENGTH\\n        for (uint256 i = 0; i < bytePrefix.length; i++) {\\n            bytesOutput.push(bytePrefix[i]);\\n        }\\n        // Add a '-' to the string to separate the prefix from the the date\\n        bytesOutput.push(bytes1(\\\"-\\\"));\\n        // Add the date string\\n        timestampToDateString(_timestamp, _output);\\n    }\\n\\n    /// @dev Converts a unix second encoded timestamp to a date format (year, month, day)\\n    ///      then writes the string encoding of that to the output pointer.\\n    /// @param _timestamp the unix seconds timestamp\\n    /// @param _outputPointer the storage pointer to change.\\n    function timestampToDateString(\\n        uint256 _timestamp,\\n        string storage _outputPointer\\n    ) public {\\n        _timestampToDateString(_timestamp, _outputPointer);\\n    }\\n\\n    /// @dev Sn internal version of the above function 'timestampToDateString'\\n    // solhint-disable-next-line\\n    function _timestampToDateString(\\n        uint256 _timestamp,\\n        string storage _outputPointer\\n    ) internal {\\n        // We pretend the string is a 'bytes' only push UTF8 encodings to it\\n        bytes storage output = bytes(_outputPointer);\\n        // First we get the day month and year\\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(\\n            _timestamp / SECONDS_PER_DAY\\n        );\\n        // First we add encoded day to the string\\n        {\\n            // Round out the second digit\\n            uint256 firstDigit = day / 10;\\n            // add it to the encoded byte for '0'\\n            output.push(bytes1(uint8(bytes1(\\\"0\\\")) + uint8(firstDigit)));\\n            // Extract the second digit\\n            uint256 secondDigit = day % 10;\\n            // add it to the string\\n            output.push(bytes1(uint8(bytes1(\\\"0\\\")) + uint8(secondDigit)));\\n        }\\n        // Next we encode the month string and add it\\n        if (month == 1) {\\n            stringPush(output, \\\"J\\\", \\\"A\\\", \\\"N\\\");\\n        } else if (month == 2) {\\n            stringPush(output, \\\"F\\\", \\\"E\\\", \\\"B\\\");\\n        } else if (month == 3) {\\n            stringPush(output, \\\"M\\\", \\\"A\\\", \\\"R\\\");\\n        } else if (month == 4) {\\n            stringPush(output, \\\"A\\\", \\\"P\\\", \\\"R\\\");\\n        } else if (month == 5) {\\n            stringPush(output, \\\"M\\\", \\\"A\\\", \\\"Y\\\");\\n        } else if (month == 6) {\\n            stringPush(output, \\\"J\\\", \\\"U\\\", \\\"N\\\");\\n        } else if (month == 7) {\\n            stringPush(output, \\\"J\\\", \\\"U\\\", \\\"L\\\");\\n        } else if (month == 8) {\\n            stringPush(output, \\\"A\\\", \\\"U\\\", \\\"G\\\");\\n        } else if (month == 9) {\\n            stringPush(output, \\\"S\\\", \\\"E\\\", \\\"P\\\");\\n        } else if (month == 10) {\\n            stringPush(output, \\\"O\\\", \\\"C\\\", \\\"T\\\");\\n        } else if (month == 11) {\\n            stringPush(output, \\\"N\\\", \\\"O\\\", \\\"V\\\");\\n        } else if (month == 12) {\\n            stringPush(output, \\\"D\\\", \\\"E\\\", \\\"C\\\");\\n        } else {\\n            revert(\\\"date decoding error\\\");\\n        }\\n        // We take the last two digits of the year\\n        // Hopefully that's enough\\n        {\\n            uint256 lastDigits = year % 100;\\n            // Round out the second digit\\n            uint256 firstDigit = lastDigits / 10;\\n            // add it to the encoded byte for '0'\\n            output.push(bytes1(uint8(bytes1(\\\"0\\\")) + uint8(firstDigit)));\\n            // Extract the second digit\\n            uint256 secondDigit = lastDigits % 10;\\n            // add it to the string\\n            output.push(bytes1(uint8(bytes1(\\\"0\\\")) + uint8(secondDigit)));\\n        }\\n    }\\n\\n    function stringPush(\\n        bytes storage output,\\n        bytes1 data1,\\n        bytes1 data2,\\n        bytes1 data3\\n    ) internal {\\n        output.push(data1);\\n        output.push(data2);\\n        output.push(data3);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 7500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"OFFSET19700101\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_PER_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_PER_HOUR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_PER_MINUTE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DateString","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"7500","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}