{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n \r\npragma solidity ^0.8.0;\r\n \r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n /**\r\n * @dev Returns the amount of tokens in existence.\r\n */\r\n function totalSupply() external view returns (uint256);\r\n \r\n /**\r\n * @dev Returns the amount of tokens owned by `account`.\r\n */\r\n function balanceOf(address account) external view returns (uint256);\r\n \r\n /**\r\n * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n *\r\n * Returns a boolean value indicating whether the operation succeeded.\r\n *\r\n * Emits a {Transfer} event.\r\n */\r\n function transfer(address recipient, uint256 amount) external returns (bool);\r\n \r\n /**\r\n * @dev Returns the remaining number of tokens that `spender` will be\r\n * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n * zero by default.\r\n *\r\n * This value changes when {approve} or {transferFrom} are called.\r\n */\r\n function allowance(address owner, address spender) external view returns (uint256);\r\n \r\n /**\r\n * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n *\r\n * Returns a boolean value indicating whether the operation succeeded.\r\n *\r\n * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n * that someone may use both the old and the new allowance by unfortunate\r\n * transaction ordering. One possible solution to mitigate this race\r\n * condition is to first reduce the spender's allowance to 0 and set the\r\n * desired value afterwards:\r\n * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n *\r\n * Emits an {Approval} event.\r\n */\r\n function approve(address spender, uint256 amount) external returns (bool);\r\n \r\n /**\r\n * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n * allowance mechanism. `amount` is then deducted from the caller's\r\n * allowance.\r\n *\r\n * Returns a boolean value indicating whether the operation succeeded.\r\n *\r\n * Emits a {Transfer} event.\r\n */\r\n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n \r\n /**\r\n * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n * another (`to`).\r\n *\r\n * Note that `value` may be zero.\r\n */\r\n event Transfer(address indexed from, address indexed to, uint256 value);\r\n \r\n /**\r\n * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n * a call to {approve}. `value` is the new allowance.\r\n */\r\n event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n \r\n// File: contracts/EVAICollateral.sol\r\n \r\n// SPDX-License-Identifier: MIT\r\n \r\npragma solidity 0.8.3;\r\n \r\n/// @title EvaiCollateral Contract\r\n/// @notice This contract is used to lock EVAI.IO ERC20 tokens as collateral for bridged BEP20 tokens on BSC\r\n \r\ncontract EvaiCollateral {\r\n IERC20 evaiETHToken;\r\n address owner;\r\n \r\n mapping(address => mapping(bytes32 => bool)) public processedTransactions;\r\n \r\n event BrigeFromBEP20(uint256 _amount);\r\n \r\n constructor(address _token) {\r\n evaiETHToken = IERC20(_token);\r\n owner = msg.sender;\r\n }\r\n \r\n function getLockedTokens() view public returns(uint256 lockedTokens) {\r\n lockedTokens = evaiETHToken.balanceOf(address(this)); \r\n }\r\n \r\n function bridgeFromBEP20 (bytes32 _txhash,address _from,uint256 tokens,uint256 nonce,bytes calldata signature) public {\r\n require(msg.sender == owner,\"EvaiCollateral: Caller is not owner\");\r\n require(tokens <= evaiETHToken.balanceOf(address(this)),\"Not Enough Tokens\");\r\n bytes32 message = prefixed(keccak256(abi.encodePacked(\r\n _txhash,_from,tokens,nonce)));\r\n require(processedTransactions[msg.sender][_txhash] == false,\"Transfer already processed\");\r\n require(recoverSigner(message,signature) == _from,\"Wrong Address\");\r\n processedTransactions[msg.sender][_txhash] = true;\r\n evaiETHToken.approve(address(this),tokens);\r\n evaiETHToken.transferFrom(address(this), _from,tokens);\r\n emit BrigeFromBEP20(tokens);\r\n }\r\n \r\n function prefixed(bytes32 hash) internal pure returns (bytes32) {\r\n return keccak256(abi.encodePacked(\r\n '\\x19Ethereum Signed Message:\\n32',hash\r\n ));\r\n }\r\n \r\n function recoverSigner(bytes32 message, bytes memory signature) internal pure returns(address) {\r\n uint8 v;\r\n bytes32 r;\r\n bytes32 s;\r\n \r\n (v,r,s) = splitSignature(signature);\r\n \r\n return ecrecover(message,v,r,s);\r\n \r\n }\r\n \r\n function splitSignature(bytes memory signature) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\r\n require(signature.length == 65,\"EVAICOLLATERAL: Length should be 65\");\r\n \r\n //bytes32 r;\r\n //bytes32 s;\r\n //uint8 v;\r\n \r\n assembly {\r\n // First 32 bytes, after the length prefix\r\n r := mload(add(signature,32))\r\n // second 32 Bytes\r\n s := mload(add(signature,64))\r\n //Final byte ( first byte of the next 32 bytes)\r\n v := byte(0,mload(add(signature,96)))\r\n }\r\n \r\n return(v,r,s);\r\n }\r\n \r\n \r\n \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BrigeFromBEP20\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_txhash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"bridgeFromBEP20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockedTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"processedTransactions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"EvaiCollateral","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000050f09629d0afdf40398a3f317cc676ca9132055c","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a7574f3e47184229c530c2131be9c6b5c4c8e928be7f0d5f4772eb78d74c3b89"}]}