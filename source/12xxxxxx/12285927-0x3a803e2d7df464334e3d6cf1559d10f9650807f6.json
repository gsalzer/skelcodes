{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.1.1 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol@v4.0.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol@v4.0.0\r\n\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol@v4.0.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20Upgradeable {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/library/ERC20ReInitializable.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ncontract ERC20ReInitializable is Initializable, IERC20Upgradeable {\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The defaut value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\r\n        __ERC20_init_unchained(name_, symbol_);\r\n    }\r\n\r\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function __ERC20_re_initialize(string memory name_, string memory symbol_) internal {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overloaded;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, msg.sender, currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = accountBalance - amount;\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n    uint256[45] private __gap;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IOwnable.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IOwnable{\r\n    function owner() external view returns(address);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IWhitelist.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * Source: https://raw.githubusercontent.com/simple-restricted-token/reference-implementation/master/contracts/token/ERC1404/ERC1404.sol\r\n * With ERC-20 APIs removed (will be implemented as a separate contract).\r\n * And adding authorizeTransfer.\r\n */\r\ninterface IWhitelist {\r\n  /**\r\n   * @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\r\n   * @param from Sending address\r\n   * @param to Receiving address\r\n   * @param value Amount of tokens being transferred\r\n   * @return Code by which to reference message for rejection reasoning\r\n   * @dev Overwrite with your custom transfer restriction logic\r\n   */\r\n  function detectTransferRestriction(\r\n    address from,\r\n    address to,\r\n    uint value\r\n  ) external view returns (uint8);\r\n\r\n  /**\r\n   * @notice Returns a human-readable message for a given restriction code\r\n   * @param restrictionCode Identifier for looking up a message\r\n   * @return Text showing the restriction's reasoning\r\n   * @dev Overwrite with your custom message and restrictionCode handling\r\n   */\r\n  function messageForTransferRestriction(uint8 restrictionCode)\r\n    external\r\n    pure\r\n    returns (string memory);\r\n\r\n  /**\r\n   * @notice Called by the DAT contract before a transfer occurs.\r\n   * @dev This call will revert when the transfer is not authorized.\r\n   * This is a mutable call to allow additional data to be recorded,\r\n   * such as when the user aquired their tokens.\r\n   */\r\n  function authorizeTransfer(\r\n    address _from,\r\n    address _to,\r\n    uint _value,\r\n    bool _isSell\r\n  ) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.0.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IERC20Metadata.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\n// File contracts/math/BigDiv.sol\r\n\r\npragma solidity ^0.8.0;\r\n/**\r\n * @title Reduces the size of terms before multiplication, to avoid an overflow, and then\r\n*stores the proper size after division.\r\n * @notice This effectively allows us to overflow values in the numerator and/or denominator\r\n* a fraction, so long as the end result does not overflow as well.\r\n * @dev Results may be off by 1 + 0.000001% for 2x1 calls and 2 + 0.00001% for 2x2 calls.\r\n * Do not use if your contract expects very small result values to be accurate.\r\n */\r\nlibrary BigDiv {\r\n    // When multiplying 2 terms <= this value the result won't overflow\r\n    uint private constant MAX_BEFORE_SQUARE = 2**128 - 1;\r\n\r\n    // The max error target is off by 1 plus up to 0.000001% error\r\n    // for bigDiv2x1 and that `* 2` for bigDiv2x2\r\n    uint private constant MAX_ERROR = 100000000;\r\n\r\n    // A larger error threshold to use when multiple rounding errors may apply\r\n    uint private constant MAX_ERROR_BEFORE_DIV = MAX_ERROR * 2;\r\n\r\n    /**\r\n     * @notice Returns the approx result of `a * b / d` so long as the result is <= MAX_UINT\r\n     * @param _numA the first numerator term\r\n     * @param _numB the second numerator term\r\n     * @param _den the denominator\r\n     * @return the approx result with up to off by 1 + MAX_ERROR, rounding down if needed\r\n     */\r\n    function bigDiv2x1(\r\n        uint _numA,\r\n        uint _numB,\r\n        uint _den\r\n    ) internal pure returns (uint) {\r\n        if (_numA == 0 || _numB == 0) {\r\n            // would div by 0 or underflow if we don't special case 0\r\n            return 0;\r\n        }\r\n\r\n        uint value;\r\n\r\n        if (type(uint256).max / _numA >= _numB) {\r\n            // a*b does not overflow, return exact math\r\n            value = _numA * _numB;\r\n            value /= _den;\r\n            return value;\r\n        }\r\n\r\n        // Sort numerators\r\n        uint numMax = _numB;\r\n        uint numMin = _numA;\r\n        if (_numA > _numB) {\r\n            numMax = _numA;\r\n            numMin = _numB;\r\n        }\r\n\r\n        value = numMax / _den;\r\n        if (value > MAX_ERROR) {\r\n            // _den is small enough to be MAX_ERROR or better w/o a factor\r\n            value = value * numMin;\r\n            return value;\r\n        }\r\n\r\n        // formula = ((a / f) * b) / (d / f)\r\n        // factor >= a / sqrt(MAX) * (b / sqrt(MAX))\r\n        uint factor = numMin - 1;\r\n        factor /= MAX_BEFORE_SQUARE;\r\n        factor += 1;\r\n        uint temp = numMax - 1;\r\n        temp /= MAX_BEFORE_SQUARE;\r\n        temp += 1;\r\n        if (type(uint256).max / factor >= temp) {\r\n            factor *= temp;\r\n            value = numMax / factor;\r\n            if (value > MAX_ERROR_BEFORE_DIV) {\r\n                value = value * numMin;\r\n                temp = _den - 1;\r\n                temp /= factor;\r\n                temp = temp + 1;\r\n                value /= temp;\r\n                return value;\r\n            }\r\n        }\r\n\r\n        // formula: (a / (d / f)) * (b / f)\r\n        // factor: b / sqrt(MAX)\r\n        factor = numMin - 1;\r\n        factor /= MAX_BEFORE_SQUARE;\r\n        factor += 1;\r\n        value = numMin / factor;\r\n        temp = _den - 1;\r\n        temp /= factor;\r\n        temp += 1;\r\n        temp = numMax / temp;\r\n        value = value * temp;\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the approx result of `a * b / d` so long as the result is <= MAX_UINT\r\n     * @param _numA the first numerator term\r\n     * @param _numB the second numerator term\r\n     * @param _den the denominator\r\n     * @return the approx result with up to off by 1 + MAX_ERROR, rounding down if needed\r\n     * @dev roundUp is implemented by first rounding down and then adding the max error to the result\r\n     */\r\n    function bigDiv2x1RoundUp(\r\n        uint _numA,\r\n        uint _numB,\r\n        uint _den\r\n    ) internal pure returns (uint) {\r\n        // first get the rounded down result\r\n        uint value = bigDiv2x1(_numA, _numB, _den);\r\n\r\n        if (value == 0) {\r\n            // when the value rounds down to 0, assume up to an off by 1 error\r\n            return 1;\r\n        }\r\n\r\n        // round down has a max error of MAX_ERROR, add that to the result\r\n        // for a round up error of <= MAX_ERROR\r\n        uint temp = value - 1;\r\n        temp /= MAX_ERROR;\r\n        temp += 1;\r\n        if (type(uint256).max - value < temp) {\r\n            // value + error would overflow, return MAX\r\n            return type(uint256).max;\r\n        }\r\n\r\n        value += temp;\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the approx result of `a * b / (c * d)` so long as the result is <= MAX_UINT\r\n     * @param _numA the first numerator term\r\n     * @param _numB the second numerator term\r\n     * @param _denA the first denominator term\r\n     * @param _denB the second denominator term\r\n     * @return the approx result with up to off by 2 + MAX_ERROR*10 error, rounding down if needed\r\n     * @dev this uses bigDiv2x1 and adds additional rounding error so the max error of this\r\n     * formula is larger\r\n     */\r\n    function bigDiv2x2(\r\n        uint _numA,\r\n        uint _numB,\r\n        uint _denA,\r\n        uint _denB\r\n    ) internal pure returns (uint) {\r\n        if (type(uint256).max / _denA >= _denB) {\r\n            // denA*denB does not overflow, use bigDiv2x1 instead\r\n            return bigDiv2x1(_numA, _numB, _denA * _denB);\r\n        }\r\n\r\n        if (_numA == 0 || _numB == 0) {\r\n            // would div by 0 or underflow if we don't special case 0\r\n            return 0;\r\n        }\r\n\r\n        // Sort denominators\r\n        uint denMax = _denB;\r\n        uint denMin = _denA;\r\n        if (_denA > _denB) {\r\n            denMax = _denA;\r\n            denMin = _denB;\r\n        }\r\n\r\n        uint value;\r\n\r\n        if (type(uint256).max / _numA >= _numB) {\r\n            // a*b does not overflow, use `a / d / c`\r\n            value = _numA * _numB;\r\n            value /= denMin;\r\n            value /= denMax;\r\n            return value;\r\n        }\r\n\r\n        // `ab / cd` where both `ab` and `cd` would overflow\r\n\r\n        // Sort numerators\r\n        uint numMax = _numB;\r\n        uint numMin = _numA;\r\n        if (_numA > _numB) {\r\n            numMax = _numA;\r\n            numMin = _numB;\r\n        }\r\n\r\n        // formula = (a/d) * b / c\r\n        uint temp = numMax / denMin;\r\n        if (temp > MAX_ERROR_BEFORE_DIV) {\r\n            return bigDiv2x1(temp, numMin, denMax);\r\n        }\r\n\r\n        // formula: ((a/f) * b) / d then either * f / c or / c * f\r\n        // factor >= a / sqrt(MAX) * (b / sqrt(MAX))\r\n        uint factor = numMin - 1;\r\n        factor /= MAX_BEFORE_SQUARE;\r\n        factor += 1;\r\n        temp = numMax - 1;\r\n        temp /= MAX_BEFORE_SQUARE;\r\n        temp += 1;\r\n        if (type(uint256).max / factor >= temp) {\r\n            factor *= temp;\r\n\r\n            value = numMax / factor;\r\n            if (value > MAX_ERROR_BEFORE_DIV) {\r\n                value = value * numMin;\r\n                value /= denMin;\r\n                if (value > 0 && type(uint256).max / value >= factor) {\r\n                    value *= factor;\r\n                    value /= denMax;\r\n                    return value;\r\n                }\r\n            }\r\n        }\r\n\r\n        // formula: (a/f) * b / ((c*d)/f)\r\n        // factor >= c / sqrt(MAX) * (d / sqrt(MAX))\r\n        factor = denMin;\r\n        factor /= MAX_BEFORE_SQUARE;\r\n        temp = denMax;\r\n        // + 1 here prevents overflow of factor*temp\r\n        temp /= MAX_BEFORE_SQUARE + 1;\r\n        factor *= temp;\r\n        return bigDiv2x1(numMax / factor, numMin, type(uint256).max);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/math/Sqrt.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Calculates the square root of a given value.\r\n * @dev Results may be off by 1.\r\n */\r\nlibrary Sqrt {\r\n    // Source: https://github.com/ethereum/dapp-bin/pull/50\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        if (x == 0) {\r\n            return 0;\r\n        } else if (x <= 3) {\r\n            return 1;\r\n        } else if (x == type(uint256).max) {\r\n            // Without this we fail on x + 1 below\r\n            return 2**128 - 1;\r\n        }\r\n\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol@v4.0.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal initializer {\r\n        __Context_init_unchained();\r\n    }\r\n\r\n    function __Context_init_unchained() internal initializer {\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n    uint256[50] private __gap;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol@v4.0.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init() internal initializer {\r\n        __Context_init_unchained();\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable_init_unchained() internal initializer {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n    uint256[49] private __gap;\r\n}\r\n\r\n\r\n// File contracts/mixins/OperatorRole.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// Original source: openzeppelin's SignerRole\r\n\r\n/**\r\n * @notice allows a single owner to manage a group of operators which may\r\n * have some special permissions in the contract.\r\n */\r\ncontract OperatorRole is OwnableUpgradeable {\r\n    mapping (address => bool) internal _operators;\r\n\r\n    event OperatorAdded(address indexed account);\r\n    event OperatorRemoved(address indexed account);\r\n\r\n    function _initializeOperatorRole() internal {\r\n        __Ownable_init();\r\n        _addOperator(msg.sender);\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(\r\n            isOperator(msg.sender),\r\n            \"OperatorRole: caller does not have the Operator role\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function isOperator(address account) public view returns (bool) {\r\n        return _operators[account];\r\n    }\r\n\r\n    function addOperator(address account) public onlyOwner {\r\n        _addOperator(account);\r\n    }\r\n\r\n    function removeOperator(address account) public onlyOwner {\r\n        _removeOperator(account);\r\n    }\r\n\r\n    function renounceOperator() public {\r\n        _removeOperator(msg.sender);\r\n    }\r\n\r\n    function _addOperator(address account) internal {\r\n        _operators[account] = true;\r\n        emit OperatorAdded(account);\r\n    }\r\n\r\n    function _removeOperator(address account) internal {\r\n        _operators[account] = false;\r\n        emit OperatorRemoved(account);\r\n    }\r\n\r\n    uint[50] private ______gap;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v4.0.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol@v4.0.0\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/CAFE.sol\r\n\r\npragma solidity ^0.8.3;\r\npragma abicoder v2;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Continuous Agreement for Future Equity\r\n */\r\ncontract CAFE\r\n    is ERC20ReInitializable\r\n{\r\n    using Sqrt for uint;\r\n    using SafeERC20 for IERC20;\r\n    event Buy(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint _currencyValue,\r\n        uint _fairValue\r\n    );\r\n    event Sell(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint _currencyValue,\r\n        uint _fairValue\r\n    );\r\n    event Burn(\r\n        address indexed _from,\r\n        uint _fairValue\r\n    );\r\n    event StateChange(\r\n        uint _previousState,\r\n        uint _newState\r\n    );\r\n    event Close();\r\n    event UpdateConfig(\r\n        address _whitelistAddress,\r\n        address indexed _beneficiary,\r\n        address indexed _control,\r\n        address indexed _feeCollector,\r\n        uint _feeBasisPoints,\r\n        uint _minInvestment,\r\n        uint _minDuration,\r\n        uint _stakeholdersPoolAuthorized,\r\n        uint _gasFee\r\n    );\r\n\r\n    //\r\n    // Constants\r\n    //\r\n\r\n    enum State {\r\n        Init,\r\n        Run,\r\n        Close,\r\n        Cancel\r\n    }\r\n\r\n    // The denominator component for values specified in basis points.\r\n    uint internal constant BASIS_POINTS_DEN = 10000;\r\n\r\n    uint internal constant MAX_ITERATION = 10;\r\n\r\n    /**\r\n     * Data specific to our token business logic\r\n     */\r\n\r\n    /// @notice The contract for transfer authorizations, if any.\r\n    IWhitelist public whitelist;\r\n\r\n    /// @notice The total number of burned FAIR tokens, excluding tokens burned from a `Sell` action in the DAT.\r\n    uint public burnedSupply;\r\n\r\n    /**\r\n     * Data for DAT business logic\r\n     */\r\n\r\n    /// @notice The address of the beneficiary organization which receives the investments.\r\n    /// Points to the wallet of the organization.\r\n    address payable public beneficiary;\r\n\r\n    struct BuySlope {\r\n        uint128 num;\r\n        uint128 den;\r\n    }\r\n\r\n    BuySlope public buySlope;\r\n\r\n    /// @notice The address from which the updatable variables can be updated\r\n    address public control;\r\n\r\n    /// @notice The address of the token used as reserve in the bonding curve\r\n    /// (e.g. the DAI contract). Use ETH if 0.\r\n    IERC20 public currency;\r\n\r\n    /// @notice The address where fees are sent.\r\n    address payable public feeCollector;\r\n\r\n    /// @notice The percent fee collected each time new FAIR are issued expressed in basis points.\r\n    uint public feeBasisPoints;\r\n\r\n    /// @notice The initial fundraising goal (expressed in FAIR) to start the c-org.\r\n    /// `0` means that there is no initial fundraising and the c-org immediately moves to run state.\r\n    uint public initGoal;\r\n\r\n    /// @notice A map with all investors in init state using address as a key and amount as value.\r\n    /// @dev This structure's purpose is to make sure that only investors can withdraw their money if init_goal is not reached.\r\n    mapping(address => uint) public initInvestors;\r\n\r\n    /// @notice The initial number of FAIR created at initialization for the beneficiary.\r\n    /// Technically however, this variable is not a constant as we must always have\r\n    ///`init_reserve>=total_supply+burnt_supply` which means that `init_reserve` will be automatically\r\n    /// decreased to equal `total_supply+burnt_supply` in case `init_reserve>total_supply+burnt_supply`\r\n    /// after an investor sells his FAIRs.\r\n    /// @dev Organizations may move these tokens into vesting contract(s)\r\n    uint public initReserve;\r\n\r\n    /// @notice The minimum amount of `currency` investment accepted.\r\n    uint public minInvestment;\r\n\r\n    /// @notice The current state of the contract.\r\n    /// @dev See the constants above for possible state values.\r\n    State public state;\r\n\r\n    /// @dev If this value changes we need to reconstruct the DOMAIN_SEPARATOR\r\n    string public constant version = \"cafe-2.0\";\r\n    // --- EIP712 niceties ---\r\n    // Original source: https://etherscan.io/address/0x6b175474e89094c44da98b954eedeac495271d0f#code\r\n    mapping (address => uint) public nonces;\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n    // The success fee (expressed in currency) that will be earned by setupFeeRecipient as soon as initGoal\r\n    // is reached. We must have setup_fee <= buy_slope*init_goal^(2)/2\r\n    uint public setupFee;\r\n\r\n    // The recipient of the setup_fee once init_goal is reached\r\n    address payable public setupFeeRecipient;\r\n\r\n    /// @notice The minimum time before which the c-org contract cannot be closed once the contract has\r\n    /// reached the `run` state.\r\n    /// @dev When updated, the new value of `minimum_duration` cannot be earlier than the previous value.\r\n    uint public minDuration;\r\n\r\n    /// @dev Initialized at `0` and updated when the contract switches from `init` state to `run` state\r\n    /// or when the initial trial period ends.\r\n    uint private startedOn;\r\n\r\n    // keccak256(\"PermitBuy(address from,address to,uint256 currencyValue,uint256 minTokensBought,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_BUY_TYPEHASH = 0xaf42a244b3020d6a2253d9f291b4d3e82240da42b22129a8113a58aa7a3ddb6a;\r\n\r\n    // keccak256(\"PermitSell(address from,address to,uint256 quantityToSell,uint256 minCurrencyReturned,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_SELL_TYPEHASH = 0x5dfdc7fb4c68a4c249de5e08597626b84fbbe7bfef4ed3500f58003e722cc548;\r\n\r\n    // stkaeholdersPool struct separated\r\n    uint public stakeholdersPoolIssued;\r\n\r\n    uint public stakeholdersPoolAuthorized;\r\n\r\n    // The orgs commitement that backs the value of CAFEs.\r\n    // This value may be increased but not decreased.\r\n    uint public equityCommitment;\r\n\r\n    // Total number of tokens that have been attributed to current shareholders\r\n    uint public shareholdersPool;\r\n\r\n    // The max number of CAFEs investors can purchase (excludes the stakeholdersPool)\r\n    uint public maxGoal;\r\n\r\n    // The amount of CAFE to be sold to exit the trial mode.\r\n    // 0 means there is no trial.\r\n    uint public initTrial;\r\n\r\n    // Represents the fundraising amount that can be sold as a fixed price\r\n    uint public fundraisingGoal;\r\n\r\n    // To fund operator a gasFee\r\n    uint public gasFee;\r\n\r\n    // increased when manual buy\r\n    uint public manualBuybackReserve;\r\n\r\n    uint public totalInvested;\r\n\r\n    bytes32 private constant BEACON_SLOT = keccak256(abi.encodePacked(\"fairmint.beaconproxy.beacon\"));\r\n    modifier onlyBeaconOperator() {\r\n        bytes32 slot = BEACON_SLOT;\r\n        address beacon;\r\n        assembly {\r\n            beacon := sload(slot)\r\n        }\r\n        require(beacon == address(0) || OperatorRole(beacon).isOperator(msg.sender), \"!BeaconOperator\");\r\n        _;\r\n    }\r\n\r\n    modifier authorizeTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint _value,\r\n        bool _isSell\r\n    )\r\n    {\r\n        require(state != State.Close, \"INVALID_STATE\");\r\n        if(address(whitelist) != address(0))\r\n        {\r\n            // This is not set for the minting of initialReserve\r\n            whitelist.authorizeTransfer(_from, _to, _value, _isSell);\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * BuySlope\r\n     */\r\n    function buySlopeNum() external view returns(uint256) {\r\n        return uint256(buySlope.num);\r\n    }\r\n\r\n    function buySlopeDen() external view returns(uint256) {\r\n        return uint256(buySlope.den);\r\n    }\r\n\r\n    /**\r\n     * Stakeholders Pool\r\n     */\r\n    function stakeholdersPool() public view returns (uint256 issued, uint256 authorized) {\r\n        return (stakeholdersPoolIssued, stakeholdersPoolAuthorized);\r\n    }\r\n\r\n    function trialEndedOn() public view returns(uint256 timestamp) {\r\n        return startedOn;\r\n    }\r\n\r\n    /**\r\n     * Buyback reserve\r\n     */\r\n\r\n    /// @notice The total amount of currency value currently locked in the contract and available to sellers.\r\n    function buybackReserve() public view returns (uint)\r\n    {\r\n        uint reserve = address(this).balance;\r\n        if(address(currency) != address(0))\r\n        {\r\n            reserve = currency.balanceOf(address(this));\r\n        }\r\n\r\n        if(reserve > type(uint128).max)\r\n        {\r\n            /// Math: If the reserve becomes excessive, cap the value to prevent overflowing in other formulas\r\n            return type(uint128).max;\r\n        }\r\n\r\n        return reserve + manualBuybackReserve;\r\n    }\r\n\r\n    /**\r\n     * Functions required by the ERC-20 token standard\r\n     */\r\n\r\n    /// @dev Moves tokens from one account to another if authorized.\r\n    function _transfer(\r\n        address _from,\r\n        address _to,\r\n        uint _amount\r\n    ) internal override\r\n        authorizeTransfer(_from, _to, _amount, false)\r\n    {\r\n        require(state != State.Init || _from == beneficiary, \"ONLY_BENEFICIARY_DURING_INIT\");\r\n        super._transfer(_from, _to, _amount);\r\n    }\r\n\r\n    /// @dev Removes tokens from the circulating supply.\r\n    function _burn(\r\n        address _from,\r\n        uint _amount,\r\n        bool _isSell\r\n    ) internal\r\n        authorizeTransfer(_from, address(0), _amount, _isSell)\r\n    {\r\n        super._burn(_from, _amount);\r\n\r\n        if(!_isSell)\r\n        {\r\n            // This is a burn\r\n            // SafeMath not required as we cap how high this value may get during mint\r\n            burnedSupply += _amount;\r\n            emit Burn(_from, _amount);\r\n        }\r\n    }\r\n\r\n    /// @notice Called to mint tokens on `buy`.\r\n    function _mint(\r\n        address _to,\r\n        uint _quantity\r\n    ) internal override\r\n        authorizeTransfer(address(0), _to, _quantity, false)\r\n    {\r\n        super._mint(_to, _quantity);\r\n\r\n        // Math: If this value got too large, the DAT may overflow on sell\r\n        require(totalSupply() + burnedSupply <= type(uint128).max, \"EXCESSIVE_SUPPLY\");\r\n    }\r\n\r\n    /**\r\n     * Transaction Helpers\r\n     */\r\n\r\n    /// @notice Confirms the transfer of `_quantityToInvest` currency to the contract.\r\n    function _collectInvestment(\r\n        address payable _from,\r\n        uint _quantityToInvest,\r\n        uint _msgValue\r\n    ) internal\r\n    {\r\n        if(address(currency) == address(0))\r\n        {\r\n            // currency is ETH\r\n            require(_quantityToInvest == _msgValue, \"INCORRECT_MSG_VALUE\");\r\n        }\r\n        else\r\n        {\r\n            // currency is ERC20\r\n            require(_msgValue == 0, \"DO_NOT_SEND_ETH\");\r\n\r\n            currency.safeTransferFrom(_from, address(this), _quantityToInvest);\r\n        }\r\n    }\r\n\r\n    /// @dev Send `_amount` currency from the contract to the `_to` account.\r\n    function _transferCurrency(\r\n        address payable _to,\r\n        uint _amount\r\n    ) internal\r\n    {\r\n        if(_amount > 0)\r\n        {\r\n            if(address(currency) == address(0))\r\n            {\r\n                Address.sendValue(_to, _amount);\r\n            }\r\n            else\r\n            {\r\n                currency.safeTransfer(_to, _amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Config / Control\r\n     */\r\n\r\n    struct MileStone {\r\n        uint128 initReserve;\r\n        uint128 initTrial;\r\n        uint128 initGoal;\r\n        uint128 maxGoal;\r\n    }\r\n\r\n    /// @notice Called once after deploy to set the initial configuration.\r\n    /// None of the values provided here may change once initially set.\r\n    /// @dev using the init pattern in order to support zos upgrades\r\n    function initialize(\r\n        string calldata _name,\r\n        string calldata _symbol,\r\n        address _currencyAddress,\r\n        MileStone calldata _mileStone,\r\n        BuySlope calldata _buySlope,\r\n        uint _stakeholdersAuthorized,\r\n        uint _equityCommitment,\r\n        uint _setupFee,\r\n        address payable _setupFeeRecipient\r\n    ) external\r\n        onlyBeaconOperator\r\n    {\r\n        // _initialize will enforce this is only called once\r\n        // The ERC-20 implementation will confirm initialize is only run once\r\n        ERC20ReInitializable.__ERC20_init(_name, _symbol);\r\n        _initialize(\r\n            _currencyAddress,\r\n            _mileStone,\r\n            _buySlope,\r\n            _stakeholdersAuthorized,\r\n            _equityCommitment,\r\n            _setupFee,\r\n            _setupFeeRecipient\r\n        );\r\n    }\r\n\r\n    function reInitialize(\r\n        string calldata _name,\r\n        string calldata _symbol,\r\n        address _currencyAddress,\r\n        MileStone calldata _mileStone,\r\n        BuySlope calldata _buySlope,\r\n        uint _stakeholdersAuthorized,\r\n        uint _equityCommitment,\r\n        uint _setupFee,\r\n        address payable _setupFeeRecipient\r\n    ) external {\r\n        require(msg.sender == beneficiary, \"ONLY_BENEFICIARY_CAN_REINITIALIZE\");\r\n        require(balanceOf(msg.sender) == totalSupply(), \"BENEFICIARY_SHOULD_HAVE_ALL_TOKENS\");\r\n        require(initReserve == totalSupply(), \"SHOULD_NOT_HAVE_RECEIVED_ANY_FUND\");\r\n        ERC20ReInitializable.__ERC20_re_initialize(_name, _symbol);\r\n        _burn(msg.sender, totalSupply());\r\n        _initialize(\r\n            _currencyAddress,\r\n            _mileStone,\r\n            _buySlope,\r\n            _stakeholdersAuthorized,\r\n            _equityCommitment,\r\n            _setupFee,\r\n            _setupFeeRecipient\r\n        );\r\n    }\r\n\r\n    function _initialize(\r\n        address _currencyAddress,\r\n        MileStone memory _mileStone,\r\n        BuySlope memory _buySlope,\r\n        uint _stakeholdersAuthorized,\r\n        uint _equityCommitment,\r\n        uint _setupFee,\r\n        address payable _setupFeeRecipient\r\n    ) internal {\r\n        require(_buySlope.num > 0, \"INVALID_SLOPE_NUM\");\r\n        require(_buySlope.den > 0, \"INVALID_SLOPE_DEN\");\r\n        buySlope = _buySlope;\r\n\r\n        // Setup Fee\r\n        require(_setupFee == 0 || _setupFeeRecipient != address(0), \"MISSING_SETUP_FEE_RECIPIENT\");\r\n        require(_setupFeeRecipient == address(0) || _setupFee != 0, \"MISSING_SETUP_FEE\");\r\n        // setup_fee <= (n/d)*(g^2)/2\r\n        uint initGoalInCurrency = uint256(_mileStone.initGoal) * uint256(_mileStone.initGoal);\r\n        initGoalInCurrency = initGoalInCurrency * uint256(_buySlope.num);\r\n        initGoalInCurrency /= 2 * uint256(_buySlope.den);\r\n        require(_setupFee <= initGoalInCurrency, \"EXCESSIVE_SETUP_FEE\");\r\n        setupFee = _setupFee;\r\n        setupFeeRecipient = _setupFeeRecipient;\r\n\r\n        // Set default values (which may be updated using `updateConfig`)\r\n        uint decimals = 18;\r\n        if(_currencyAddress != address(0)){\r\n            decimals = IERC20Metadata(_currencyAddress).decimals();\r\n        }\r\n        minInvestment = 100 * (10 ** decimals);\r\n        beneficiary = payable(msg.sender);\r\n        control = msg.sender;\r\n        feeCollector = payable(msg.sender);\r\n\r\n        // Save currency\r\n        currency = IERC20(_currencyAddress);\r\n\r\n        // Mint the initial reserve\r\n        if(_mileStone.initReserve > 0)\r\n        {\r\n            initReserve = _mileStone.initReserve;\r\n            _mint(beneficiary, initReserve);\r\n        }\r\n\r\n        initializeDomainSeparator();\r\n        // Math: If this value got too large, the DAT would overflow on sell\r\n        // new settings for CAFE\r\n        require(_mileStone.maxGoal == 0 || _mileStone.initGoal == 0 || _mileStone.maxGoal >= _mileStone.initGoal, \"MAX_GOAL_SMALLER_THAN_INIT_GOAL\");\r\n        require(_mileStone.initGoal == 0 || _mileStone.initTrial == 0 || _mileStone.initGoal >= _mileStone.initTrial, \"INIT_GOAL_SMALLER_THAN_INIT_TRIAL\");\r\n        maxGoal = _mileStone.maxGoal;\r\n        initTrial = _mileStone.initTrial;\r\n        stakeholdersPoolIssued = _mileStone.initReserve;\r\n        require(_stakeholdersAuthorized <= BASIS_POINTS_DEN, \"STAKEHOLDERS_POOL_AUTHORIZED_SHOULD_BE_SMALLER_THAN_BASIS_POINTS_DEN\");\r\n        stakeholdersPoolAuthorized = _stakeholdersAuthorized;\r\n        require(_equityCommitment > 0, \"EQUITY_COMMITMENT_CANNOT_BE_ZERO\");\r\n        require(_equityCommitment <= BASIS_POINTS_DEN, \"EQUITY_COMMITMENT_SHOULD_BE_LESS_THAN_100%\");\r\n        equityCommitment = _equityCommitment;\r\n        // Set initGoal, which in turn defines the initial state\r\n        if(_mileStone.initGoal == 0)\r\n        {\r\n            _stateChange(State.Run);\r\n            startedOn = block.timestamp;\r\n        }\r\n        else\r\n        {\r\n            initGoal = _mileStone.initGoal;\r\n            state = State.Init;\r\n            startedOn = 0;\r\n        }\r\n    }\r\n\r\n    function _stateChange(State _state) internal {\r\n        emit StateChange(uint256(state), uint256(_state));\r\n        state = _state;\r\n    }\r\n\r\n    function updateConfig(\r\n        address _whitelistAddress,\r\n        address payable _beneficiary,\r\n        address _control,\r\n        address payable _feeCollector,\r\n        uint _feeBasisPoints,\r\n        uint _minInvestment,\r\n        uint _minDuration,\r\n        uint _stakeholdersAuthorized,\r\n        uint _gasFee\r\n    ) external\r\n    {\r\n        // This require(also confirms that initialize has been called.\r\n        require(msg.sender == control, \"CONTROL_ONLY\");\r\n\r\n        // address(0) is okay\r\n        whitelist = IWhitelist(_whitelistAddress);\r\n\r\n        require(_control != address(0), \"INVALID_ADDRESS\");\r\n        control = _control;\r\n\r\n        require(_feeCollector != address(0), \"INVALID_ADDRESS\");\r\n        feeCollector = _feeCollector;\r\n\r\n        require(_feeBasisPoints <= BASIS_POINTS_DEN, \"INVALID_FEE\");\r\n        feeBasisPoints = _feeBasisPoints;\r\n\r\n        require(_minInvestment > 0, \"INVALID_MIN_INVESTMENT\");\r\n        minInvestment = _minInvestment;\r\n\r\n        require(_minDuration >= minDuration, \"MIN_DURATION_MAY_NOT_BE_REDUCED\");\r\n        minDuration = _minDuration;\r\n\r\n        if(beneficiary != _beneficiary)\r\n        {\r\n            require(_beneficiary != address(0), \"INVALID_ADDRESS\");\r\n            uint tokens = balanceOf(beneficiary);\r\n            initInvestors[_beneficiary] = initInvestors[_beneficiary] + initInvestors[beneficiary];\r\n            initInvestors[beneficiary] = 0;\r\n            if(tokens > 0)\r\n            {\r\n                _transfer(beneficiary, _beneficiary, tokens);\r\n            }\r\n            beneficiary = _beneficiary;\r\n        }\r\n\r\n        // new settings for CAFE\r\n        require(_stakeholdersAuthorized <= BASIS_POINTS_DEN, \"STAKEHOLDERS_POOL_AUTHORIZED_SHOULD_BE_SMALLER_THAN_BASIS_POINTS_DEN\");\r\n        stakeholdersPoolAuthorized = _stakeholdersAuthorized;\r\n\r\n        gasFee = _gasFee;\r\n\r\n        emit UpdateConfig(\r\n            _whitelistAddress,\r\n            _beneficiary,\r\n            _control,\r\n            _feeCollector,\r\n            _feeBasisPoints,\r\n            _minInvestment,\r\n            _minDuration,\r\n            _stakeholdersAuthorized,\r\n            _gasFee\r\n        );\r\n    }\r\n\r\n    /// @notice Used to initialize the domain separator used in meta-transactions\r\n    /// @dev This is separate from `initialize` to allow upgraded contracts to update the version\r\n    /// There is no harm in calling this multiple times / no permissions required\r\n    function initializeDomainSeparator() public\r\n    {\r\n        uint id;\r\n        // solium-disable-next-line\r\n        assembly\r\n        {\r\n            id := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                keccak256(bytes(name())),\r\n                keccak256(bytes(version)),\r\n                id,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Functions for our business logic\r\n     */\r\n\r\n    /// @notice Burn the amount of tokens from the address msg.sender if authorized.\r\n    /// @dev Note that this is not the same as a `sell` via the DAT.\r\n    function burn(\r\n        uint _amount\r\n    ) public\r\n    {\r\n        require(state == State.Run, \"INVALID_STATE\");\r\n        require(msg.sender == beneficiary, \"BENEFICIARY_ONLY\");\r\n        _burn(msg.sender, _amount, false);\r\n    }\r\n\r\n    // Buy\r\n\r\n    /// @notice Purchase FAIR tokens with the given amount of currency.\r\n    /// @param _to The account to receive the FAIR tokens from this purchase.\r\n    /// @param _currencyValue How much currency to spend in order to buy FAIR.\r\n    /// @param _minTokensBought Buy at least this many FAIR tokens or the transaction reverts.\r\n    /// @dev _minTokensBought is necessary as the price will change if some elses transaction mines after\r\n    /// yours was submitted.\r\n    function buy(\r\n        address _to,\r\n        uint _currencyValue,\r\n        uint _minTokensBought\r\n    ) public payable\r\n    {\r\n        _collectInvestment(payable(msg.sender), _currencyValue, msg.value);\r\n        //deduct gas fee and send it to feeCollector\r\n        uint256 currencyValue = _currencyValue - gasFee;\r\n        _transferCurrency(feeCollector, gasFee);\r\n        _buy(payable(msg.sender), _to, currencyValue, _minTokensBought, false);\r\n    }\r\n\r\n    /// @notice Allow users to sign a message authorizing a buy\r\n    function permitBuy(\r\n        address payable _from,\r\n        address _to,\r\n        uint _currencyValue,\r\n        uint _minTokensBought,\r\n        uint _deadline,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external\r\n    {\r\n        require(_deadline >= block.timestamp, \"EXPIRED\");\r\n        bytes32 digest = keccak256(abi.encode(PERMIT_BUY_TYPEHASH, _from, _to, _currencyValue, _minTokensBought, nonces[_from]++, _deadline));\r\n        digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                digest\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == _from, \"INVALID_SIGNATURE\");\r\n        // CHECK !!! this is suspicious!! 0 should be msg.value but this is not payable function\r\n        // msg.value will be zero since it is non-payable function and designed to be used to usdc-base CAFE contract\r\n        _collectInvestment(_from, _currencyValue, 0);\r\n        uint256 currencyValue = _currencyValue - gasFee;\r\n        _transferCurrency(feeCollector, gasFee);\r\n        _buy(_from, _to, currencyValue, _minTokensBought, false);\r\n    }\r\n\r\n    function _buy(\r\n        address payable _from,\r\n        address _to,\r\n        uint _currencyValue,\r\n        uint _minTokensBought,\r\n        bool _manual\r\n    ) internal\r\n    {\r\n        require(_to != address(0), \"INVALID_ADDRESS\");\r\n        require(_to != beneficiary, \"BENEFICIARY_CANNOT_BUY\");\r\n        require(_minTokensBought > 0, \"MUST_BUY_AT_LEAST_1\");\r\n        require(state == State.Init || state == State.Run, \"ONLY_BUY_IN_INIT_OR_RUN\");\r\n        // Calculate the tokenValue for this investment\r\n        // returns zero if _currencyValue < minInvestment\r\n        uint tokenValue = _estimateBuyValue(_currencyValue);\r\n        require(tokenValue >= _minTokensBought, \"PRICE_SLIPPAGE\");\r\n        if(state == State.Init){\r\n            if(tokenValue + shareholdersPool < initTrial){\r\n                //already received all currency from _collectInvestment\r\n                if(!_manual) {\r\n                    initInvestors[_to] = initInvestors[_to] + tokenValue;\r\n                }\r\n                initTrial = initTrial - tokenValue;\r\n            }\r\n            else if (initTrial > shareholdersPool){\r\n                //already received all currency from _collectInvestment\r\n                //send setup fee to beneficiary\r\n                if(setupFee > 0){\r\n                    _transferCurrency(setupFeeRecipient, setupFee);\r\n                }\r\n                _distributeInvestment(buybackReserve() - manualBuybackReserve);\r\n                manualBuybackReserve = 0;\r\n                initTrial = shareholdersPool;\r\n                startedOn = block.timestamp;\r\n            }\r\n            else{\r\n                _distributeInvestment(buybackReserve() - manualBuybackReserve);\r\n                manualBuybackReserve = 0;\r\n            }\r\n        }\r\n        else { //state == State.Run\r\n            require(maxGoal == 0 || tokenValue + totalSupply() - stakeholdersPoolIssued <= maxGoal, \"EXCEEDING_MAX_GOAL\");\r\n            _distributeInvestment(buybackReserve() - manualBuybackReserve);\r\n            manualBuybackReserve = 0;\r\n            if(fundraisingGoal != 0){\r\n                if (tokenValue >= fundraisingGoal){\r\n                    changeBuySlope(totalSupply() - stakeholdersPoolIssued, fundraisingGoal + totalSupply() - stakeholdersPoolIssued);\r\n                    fundraisingGoal = 0;\r\n                } else { //if (tokenValue < fundraisingGoal) {\r\n                    changeBuySlope(totalSupply() - stakeholdersPoolIssued, tokenValue + totalSupply() - stakeholdersPoolIssued);\r\n                    fundraisingGoal -= tokenValue;\r\n                }\r\n            }\r\n        }\r\n\r\n        totalInvested = totalInvested + _currencyValue;\r\n\r\n        emit Buy(_from, _to, _currencyValue, tokenValue);\r\n        _mint(_to, tokenValue);\r\n\r\n        if(state == State.Init && totalSupply() - stakeholdersPoolIssued >= initGoal){\r\n            _stateChange(State.Run);\r\n        }\r\n    }\r\n\r\n    /// @dev Distributes _value currency between the beneficiary and feeCollector.\r\n    function _distributeInvestment(\r\n        uint _value\r\n    ) internal\r\n    {\r\n        uint fee = _value * feeBasisPoints;\r\n        fee /= BASIS_POINTS_DEN;\r\n\r\n        // Math: since feeBasisPoints is <= BASIS_POINTS_DEN, this will never underflow.\r\n        _transferCurrency(beneficiary, _value - fee);\r\n        _transferCurrency(feeCollector, fee);\r\n    }\r\n\r\n    function estimateBuyValue(\r\n        uint _currencyValue\r\n    ) external view\r\n    returns(uint)\r\n    {\r\n        return _estimateBuyValue(_currencyValue - gasFee);\r\n    }\r\n\r\n    /// @notice Calculate how many FAIR tokens you would buy with the given amount of currency if `buy` was called now.\r\n    /// @param _currencyValue How much currency to spend in order to buy FAIR.\r\n    function _estimateBuyValue(\r\n        uint _currencyValue\r\n    ) internal view\r\n    returns(uint)\r\n    {\r\n        if(_currencyValue < minInvestment){\r\n            return 0;\r\n        }\r\n        if(state == State.Init){\r\n            uint currencyValue = _currencyValue;\r\n            uint _totalSupply = totalSupply();\r\n            uint max = BigDiv.bigDiv2x1(\r\n                initGoal * buySlope.num,\r\n                initGoal - (_totalSupply - stakeholdersPoolIssued),\r\n                buySlope.den\r\n            );\r\n\r\n            if(currencyValue > max)\r\n            {\r\n                currencyValue = max;\r\n            }\r\n\r\n            uint256 tokenAmount = BigDiv.bigDiv2x1(\r\n                currencyValue,\r\n                buySlope.den,\r\n                initGoal * buySlope.num\r\n            );\r\n            if(currencyValue != _currencyValue)\r\n            {\r\n                currencyValue = _currencyValue - max;\r\n                // ((2*next_amount/buy_slope)+init_goal^2)^(1/2)-init_goal\r\n                // a: next_amount | currencyValue\r\n                // n/d: buy_slope (type(uint128).max / type(uint128).max)\r\n                // g: init_goal (type(uint128).max/2)\r\n                // r: init_reserve (type(uint128).max/2)\r\n                // sqrt(((2*a/(n/d))+g^2)-g\r\n                // sqrt((2 d a + n g^2)/n) - g\r\n\r\n                // currencyValue == 2 d a\r\n                uint temp = 2 * buySlope.den;\r\n                currencyValue = temp * currencyValue;\r\n\r\n                // temp == g^2\r\n                temp = initGoal;\r\n                temp *= temp;\r\n\r\n                // temp == n g^2\r\n                temp = temp * buySlope.num;\r\n\r\n                // temp == (2 d a) + n g^2\r\n                temp = currencyValue + temp;\r\n\r\n                // temp == (2 d a + n g^2)/n\r\n                temp /= buySlope.num;\r\n\r\n                // temp == sqrt((2 d a + n g^2)/n)\r\n                temp = temp.sqrt();\r\n\r\n                // temp == sqrt((2 d a + n g^2)/n) - g\r\n                temp -= initGoal;\r\n\r\n                tokenAmount = tokenAmount + temp;\r\n            }\r\n            return tokenAmount;\r\n        }\r\n        else if(state == State.Run) {//state == State.Run{\r\n            uint supply = totalSupply() - stakeholdersPoolIssued;\r\n            // calculate fundraising amount (static price)\r\n            uint currencyValue = _currencyValue;\r\n            uint fundraisedAmount;\r\n            if(fundraisingGoal > 0){\r\n                uint max = BigDiv.bigDiv2x1(\r\n                    supply,\r\n                    fundraisingGoal * buySlope.num,\r\n                    buySlope.den\r\n                );\r\n                if(currencyValue > max){\r\n                    currencyValue = max;\r\n                }\r\n                fundraisedAmount = BigDiv.bigDiv2x2(\r\n                    currencyValue,\r\n                    buySlope.den,\r\n                    supply,\r\n                    buySlope.num\r\n                );\r\n                //forward leftover currency to be used as normal buy\r\n                currencyValue = _currencyValue - currencyValue;\r\n            }\r\n\r\n            // initReserve is reduced on sell as necessary to ensure that this line will not overflow\r\n            // Math: worst case\r\n            // MAX * 2 * type(uint128).max\r\n            // / type(uint128).max\r\n            uint tokenAmount = BigDiv.bigDiv2x1(\r\n                currencyValue,\r\n                2 * buySlope.den,\r\n                buySlope.num\r\n            );\r\n\r\n            // Math: worst case MAX + (type(uint128).max * type(uint128).max)\r\n            tokenAmount = tokenAmount + supply * supply;\r\n            tokenAmount = tokenAmount.sqrt();\r\n\r\n            // Math: small chance of underflow due to possible rounding in sqrt\r\n            tokenAmount = tokenAmount - supply;\r\n            return fundraisedAmount + tokenAmount;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    // Sell\r\n\r\n    /// @notice Sell FAIR tokens for at least the given amount of currency.\r\n    /// @param _to The account to receive the currency from this sale.\r\n    /// @param _quantityToSell How many FAIR tokens to sell for currency value.\r\n    /// @param _minCurrencyReturned Get at least this many currency tokens or the transaction reverts.\r\n    /// @dev _minCurrencyReturned is necessary as the price will change if some elses transaction mines after\r\n    /// yours was submitted.\r\n    function sell(\r\n        address payable _to,\r\n        uint _quantityToSell,\r\n        uint _minCurrencyReturned\r\n    ) public\r\n    {\r\n        _sell(msg.sender, _to, _quantityToSell, _minCurrencyReturned);\r\n    }\r\n\r\n    /// @notice Allow users to sign a message authorizing a sell\r\n    function permitSell(\r\n        address _from,\r\n        address payable _to,\r\n        uint _quantityToSell,\r\n        uint _minCurrencyReturned,\r\n        uint _deadline,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external\r\n    {\r\n        require(_deadline >= block.timestamp, \"EXPIRED\");\r\n        bytes32 digest = keccak256(\r\n            abi.encode(PERMIT_SELL_TYPEHASH, _from, _to, _quantityToSell, _minCurrencyReturned, nonces[_from]++, _deadline)\r\n        );\r\n        digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                digest\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == _from, \"INVALID_SIGNATURE\");\r\n        _sell(_from, _to, _quantityToSell, _minCurrencyReturned);\r\n    }\r\n\r\n    function _sell(\r\n        address _from,\r\n        address payable _to,\r\n        uint _quantityToSell,\r\n        uint _minCurrencyReturned\r\n    ) internal\r\n    {\r\n        require(_from != beneficiary, \"BENEFICIARY_CANNOT_SELL\");\r\n        require(state != State.Init || initTrial != shareholdersPool, \"INIT_TRIAL_ENDED\");\r\n        require(state == State.Init || state == State.Cancel, \"ONLY_SELL_IN_INIT_OR_CANCEL\");\r\n        require(_minCurrencyReturned > 0, \"MUST_SELL_AT_LEAST_1\");\r\n        // check for slippage\r\n        uint currencyValue = estimateSellValue(_quantityToSell);\r\n        require(currencyValue >= _minCurrencyReturned, \"PRICE_SLIPPAGE\");\r\n        // it will work as checking _from has morethan _quantityToSell as initInvestors\r\n        initInvestors[_from] = initInvestors[_from] - _quantityToSell;\r\n        _burn(_from, _quantityToSell, true);\r\n        _transferCurrency(_to, currencyValue);\r\n        if(state == State.Init && initTrial != 0){\r\n            // this can only happen if initTrial is set to zero from day one\r\n            initTrial = initTrial + _quantityToSell;\r\n        }\r\n        totalInvested = totalInvested - currencyValue;\r\n        emit Sell(_from, _to, currencyValue, _quantityToSell);\r\n    }\r\n\r\n    function estimateSellValue(\r\n        uint _quantityToSell\r\n    ) public view\r\n        returns(uint)\r\n    {\r\n        if(state != State.Init && state != State.Cancel){\r\n            return 0;\r\n        }\r\n        uint reserve = buybackReserve();\r\n\r\n        // Calculate currencyValue for this sale\r\n        uint currencyValue;\r\n        // State.Init or State.Cancel\r\n        // Math worst case:\r\n        // MAX * type(uint128).max\r\n        currencyValue = _quantityToSell * reserve;\r\n        // Math: FAIR blocks initReserve from being burned unless we reach the RUN state which prevents an underflow\r\n        currencyValue /= totalSupply() - stakeholdersPoolIssued - shareholdersPool;\r\n\r\n        return currencyValue;\r\n    }\r\n\r\n\r\n    // Close\r\n\r\n    /// @notice Called by the beneficiary account to State.Close or State.Cancel the c-org,\r\n    /// preventing any more tokens from being minted.\r\n    function close() public\r\n    {\r\n        _close();\r\n        emit Close();\r\n    }\r\n\r\n    /// @notice Called by the beneficiary account to State.Close or State.Cancel the c-org,\r\n    /// preventing any more tokens from being minted.\r\n    /// @dev Requires an `exitFee` to be paid.    If the currency is ETH, include a little more than\r\n    /// what appears to be required and any remainder will be returned to your account.    This is\r\n    /// because another user may have a transaction mined which changes the exitFee required.\r\n    /// For other `currency` types, the beneficiary account will be billed the exact amount required.\r\n    function _close() internal\r\n    {\r\n        require(msg.sender == beneficiary, \"BENEFICIARY_ONLY\");\r\n\r\n        if(state == State.Init)\r\n        {\r\n            // Allow the org to cancel anytime if the initGoal was not reached.\r\n            require(initTrial > shareholdersPool,\"CANNOT_CANCEL_IF_INITTRIAL_IS_ZERO\");\r\n            _stateChange(State.Cancel);\r\n        }\r\n        else if(state == State.Run)\r\n        {\r\n            require(type(uint256).max - minDuration > startedOn, \"MAY_NOT_CLOSE\");\r\n            require(minDuration + startedOn <= block.timestamp, \"TOO_EARLY\");\r\n            _stateChange(State.Close);\r\n        }\r\n        else\r\n        {\r\n            revert(\"INVALID_STATE\");\r\n        }\r\n    }\r\n\r\n    /// @notice mint new CAFE and send them to `wallet`\r\n    function mint(\r\n        address _wallet,\r\n        uint256 _amount\r\n    ) external\r\n    {\r\n        require(msg.sender == beneficiary, \"ONLY_BENEFICIARY_CAN_MINT\");\r\n        require(\r\n            _amount + stakeholdersPoolIssued <= (stakeholdersPoolAuthorized * (totalSupply() + _amount)) / BASIS_POINTS_DEN,\r\n            \"CANNOT_MINT_MORE_THAN_AUTHORIZED_PERCENTAGE\"\r\n        );\r\n        //update stakeholdersPool issued value\r\n        stakeholdersPoolIssued = stakeholdersPoolIssued + _amount;\r\n        address to = _wallet == address(0) ? beneficiary : _wallet;\r\n        //check if wallet is whitelist in the _mint() function\r\n        _mint(to, _amount);\r\n    }\r\n\r\n    function manualBuy(\r\n        address payable _wallet,\r\n        uint256 _currencyValue\r\n    ) external\r\n    {\r\n        require(msg.sender == beneficiary, \"ONLY_BENEFICIARY_CAN_MINT\");\r\n        manualBuybackReserve += _currencyValue;\r\n        _buy(_wallet, _wallet, _currencyValue, 1, true);\r\n    }\r\n\r\n    function increaseCommitment(\r\n        uint256 _newCommitment,\r\n        uint256 _amount\r\n    ) external\r\n    {\r\n        require(state == State.Init || state == State.Run, \"ONLY_IN_INIT_OR_RUN\");\r\n        require(msg.sender == beneficiary, \"ONLY_BENEFICIARY_CAN_INCREASE_COMMITMENT\");\r\n        require(_newCommitment > 0, \"COMMITMENT_CANT_BE_ZERO\");\r\n        require(equityCommitment + _newCommitment <= BASIS_POINTS_DEN, \"EQUITY_COMMITMENT_SHOULD_BE_LESS_THAN_100%\");\r\n        equityCommitment = equityCommitment + _newCommitment;\r\n        if(_amount > 0 ){\r\n            if(state == State.Init){\r\n                changeBuySlope(initGoal, _amount + initGoal);\r\n                initGoal = initGoal + _amount;\r\n            } else {\r\n                fundraisingGoal = _amount;\r\n            }\r\n            if(maxGoal != 0){\r\n                maxGoal = maxGoal + _amount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function convertToCafe(\r\n        uint256 _newCommitment,\r\n        uint256 _amount,\r\n        address _wallet\r\n    ) external {\r\n        require(state == State.Init || state == State.Run, \"ONLY_IN_INIT_OR_RUN\");\r\n        require(msg.sender == beneficiary, \"ONLY_BENEFICIARY_CAN_INCREASE_COMMITMENT\");\r\n        require(_newCommitment > 0, \"COMMITMENT_CANT_BE_ZERO\");\r\n        require(equityCommitment + _newCommitment <= BASIS_POINTS_DEN, \"EQUITY_COMMITMENT_SHOULD_BE_LESS_THAN_100%\");\r\n        require(_wallet != beneficiary && _wallet != address(0), \"WALLET_CANNOT_BE_ZERO_OR_BENEFICIARY\");\r\n        equityCommitment = equityCommitment + _newCommitment;\r\n        if(_amount > 0 ){\r\n            shareholdersPool = shareholdersPool + _amount;\r\n            if(state == State.Init){\r\n                changeBuySlope(initGoal, _amount + initGoal);\r\n                initGoal = initGoal + _amount;\r\n                if(initTrial != 0){\r\n                    initTrial = initTrial + _amount;\r\n                }\r\n            }\r\n            else {\r\n                changeBuySlope(totalSupply() - stakeholdersPoolIssued, _amount + totalSupply() - stakeholdersPoolIssued);\r\n            }\r\n            _mint(_wallet, _amount);\r\n            if(maxGoal != 0){\r\n                maxGoal = maxGoal + _amount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function increaseValuation(uint256 _newValuation) external {\r\n        require(state == State.Init || state == State.Run, \"ONLY_IN_INIT_OR_RUN\");\r\n        require(msg.sender == beneficiary, \"ONLY_BENEFICIARY_CAN_INCREASE_VALUATION\");\r\n        uint256 oldValuation;\r\n        if(state == State.Init){\r\n            oldValuation = (initGoal * initGoal * buySlope.num * BASIS_POINTS_DEN) / (buySlope.den * equityCommitment);\r\n            require(_newValuation > oldValuation, \"VALUATION_CAN_NOT_DECREASE\");\r\n            changeBuySlope(_newValuation, oldValuation);\r\n        }else {\r\n            oldValuation = ((totalSupply() - stakeholdersPoolIssued) * (totalSupply() - stakeholdersPoolIssued) * buySlope.num * BASIS_POINTS_DEN) / (buySlope.den * equityCommitment);\r\n            require(_newValuation > oldValuation, \"VALUATION_CAN_NOT_DECREASE\");\r\n            changeBuySlope(_newValuation, oldValuation);\r\n        }\r\n    }\r\n\r\n    function changeBuySlope(uint256 _numerator, uint256 _denominator) internal {\r\n        require(_denominator > 0, \"DIV_0\");\r\n        if(_numerator == 0){\r\n            buySlope.num = 0;\r\n            return;\r\n        }\r\n        uint256 tryDen = BigDiv.bigDiv2x1(\r\n            buySlope.den,\r\n            _denominator,\r\n            _numerator\r\n        );\r\n        if(tryDen <= type(uint128).max){\r\n            buySlope.den = uint128(tryDen);\r\n            return;\r\n        }\r\n        //if den exceeds type(uint128).max try num\r\n        uint256 tryNum = BigDiv.bigDiv2x1(\r\n            buySlope.num,\r\n            _numerator,\r\n            _denominator\r\n        );\r\n        if(tryNum > 0 && tryNum <= type(uint128).max) {\r\n            buySlope.num = uint128(tryNum);\r\n            return;\r\n        }\r\n        revert(\"error while changing slope\");\r\n    }\r\n\r\n    function batchTransfer(address[] calldata recipients, uint256[] calldata amounts) external {\r\n        require(msg.sender == beneficiary, \"ONLY_BENEFICIARY_CAN_BATCH_TRANSFER\");\r\n        require(recipients.length == amounts.length, \"ARRAY_LENGTH_DIFF\");\r\n        require(recipients.length <= MAX_ITERATION, \"EXCEEDS_MAX_ITERATION\");\r\n        for(uint256 i = 0; i<recipients.length; i++) {\r\n            _transfer(msg.sender, recipients[i], amounts[0]);\r\n        }\r\n    }\r\n\r\n    /// @notice Pay the organization on-chain without minting any tokens.\r\n    /// @dev This allows you to add funds directly to the buybackReserve.\r\n    receive() external payable {\r\n        require(address(currency) == address(0), \"ONLY_FOR_CURRENCY_ETH\");\r\n    }\r\n\r\n\r\n    // --- Approve by signature ---\r\n    // EIP-2612\r\n    // Original source: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint value,\r\n        uint deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external\r\n    {\r\n        require(deadline >= block.timestamp, \"EXPIRED\");\r\n        bytes32 digest = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\r\n        digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                digest\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNATURE\");\r\n        _approve(owner, spender, value);\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fairValue\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_currencyValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fairValue\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Close\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_currencyValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fairValue\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_previousState\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newState\",\"type\":\"uint256\"}],\"name\":\"StateChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_whitelistAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_control\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_feeBasisPoints\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_minInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_minDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeholdersPoolAuthorized\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gasFee\",\"type\":\"uint256\"}],\"name\":\"UpdateConfig\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_BUY_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_SELL_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_currencyValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minTokensBought\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buySlope\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"num\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"den\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buySlopeDen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buySlopeNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buybackReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"control\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newCommitment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"convertToCafe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currency\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"equityCommitment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_currencyValue\",\"type\":\"uint256\"}],\"name\":\"estimateBuyValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_quantityToSell\",\"type\":\"uint256\"}],\"name\":\"estimateSellValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundraisingGoal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newCommitment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"increaseCommitment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newValuation\",\"type\":\"uint256\"}],\"name\":\"increaseValuation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initGoal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"initInvestors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initTrial\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_currencyAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"initReserve\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"initTrial\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"initGoal\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"maxGoal\",\"type\":\"uint128\"}],\"internalType\":\"struct CAFE.MileStone\",\"name\":\"_mileStone\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"num\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"den\",\"type\":\"uint128\"}],\"internalType\":\"struct CAFE.BuySlope\",\"name\":\"_buySlope\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_stakeholdersAuthorized\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_equityCommitment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_setupFee\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_setupFeeRecipient\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializeDomainSeparator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_currencyValue\",\"type\":\"uint256\"}],\"name\":\"manualBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualBuybackReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxGoal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_currencyValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minTokensBought\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"permitBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_quantityToSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minCurrencyReturned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"permitSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_currencyAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"initReserve\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"initTrial\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"initGoal\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"maxGoal\",\"type\":\"uint128\"}],\"internalType\":\"struct CAFE.MileStone\",\"name\":\"_mileStone\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"num\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"den\",\"type\":\"uint128\"}],\"internalType\":\"struct CAFE.BuySlope\",\"name\":\"_buySlope\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_stakeholdersAuthorized\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_equityCommitment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_setupFee\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_setupFeeRecipient\",\"type\":\"address\"}],\"name\":\"reInitialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_quantityToSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minCurrencyReturned\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setupFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setupFeeRecipient\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shareholdersPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeholdersPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"issued\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"authorized\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeholdersPoolAuthorized\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeholdersPoolIssued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum CAFE.State\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trialEndedOn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whitelistAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_control\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_feeCollector\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeholdersAuthorized\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasFee\",\"type\":\"uint256\"}],\"name\":\"updateConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"contract IWhitelist\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"CAFE","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://04358a9123bf5dce233b5c93884315acfc0dfda660b2e465f79c9775a4eb82e6"}]}