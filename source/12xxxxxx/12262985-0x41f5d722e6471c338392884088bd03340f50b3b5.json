{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/governance/executor/DefaultExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {DefaultExecutorWithTimelock} from './DefaultExecutorWithTimelock.sol';\\nimport {DefaultProposalValidator} from './DefaultProposalValidator.sol';\\n\\n/**\\n * @title Time Locked, Validator, Executor Contract\\n * @dev Contract\\n * - Validate Proposal creations/ cancellation\\n * - Validate Vote Quorum and Vote success on proposal\\n * - Queue, Execute, Cancel, successful proposals' transactions.\\n **/\\ncontract DefaultExecutor is DefaultExecutorWithTimelock, DefaultProposalValidator {\\n  constructor(\\n    address admin,\\n    uint256 delay,\\n    uint256 gracePeriod,\\n    uint256 minimumDelay,\\n    uint256 maximumDelay,\\n    uint256 minVoteDuration,\\n    uint256 maxVotingOptions,\\n    uint256 voteDifferential,\\n    uint256 minimumQuorum\\n  )\\n    DefaultExecutorWithTimelock(admin, delay, gracePeriod, minimumDelay, maximumDelay)\\n    DefaultProposalValidator(minVoteDuration, maxVotingOptions, voteDifferential, minimumQuorum)\\n  {}\\n}\\n\"\r\n    },\r\n    \"contracts/governance/executor/DefaultExecutorWithTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IExecutorWithTimelock} from '../../interfaces/governance/IExecutorWithTimelock.sol';\\nimport {IKyberGovernance} from '../../interfaces/governance/IKyberGovernance.sol';\\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\\n\\n/**\\n * @title Time Locked Executor Contract, inherited by Aave Governance Executors\\n * @dev Contract that can queue, execute, cancel transactions voted by Governance\\n * Queued transactions can be executed after a delay and until\\n * Grace period is not over.\\n * @author Aave\\n **/\\ncontract DefaultExecutorWithTimelock is IExecutorWithTimelock {\\n  using SafeMath for uint256;\\n\\n  uint256 public immutable override GRACE_PERIOD;\\n  uint256 public immutable override MINIMUM_DELAY;\\n  uint256 public immutable override MAXIMUM_DELAY;\\n\\n  address private _admin;\\n  address private _pendingAdmin;\\n  uint256 private _delay;\\n\\n  mapping(bytes32 => bool) private _queuedTransactions;\\n\\n  /**\\n   * @dev Constructor\\n   * @param admin admin address, that can call the main functions, (Governance)\\n   * @param delay minimum time between queueing and execution of proposal\\n   * @param gracePeriod time after `delay` while a proposal can be executed\\n   * @param minimumDelay lower threshold of `delay`, in seconds\\n   * @param maximumDelay upper threhold of `delay`, in seconds\\n   **/\\n  constructor(\\n    address admin,\\n    uint256 delay,\\n    uint256 gracePeriod,\\n    uint256 minimumDelay,\\n    uint256 maximumDelay\\n  ) {\\n    require(delay >= minimumDelay, 'DELAY_SHORTER_THAN_MINIMUM');\\n    require(delay <= maximumDelay, 'DELAY_LONGER_THAN_MAXIMUM');\\n    _delay = delay;\\n    _admin = admin;\\n\\n    GRACE_PERIOD = gracePeriod;\\n    MINIMUM_DELAY = minimumDelay;\\n    MAXIMUM_DELAY = maximumDelay;\\n\\n    emit NewDelay(delay);\\n    emit NewAdmin(admin);\\n  }\\n\\n  modifier onlyAdmin() {\\n    require(msg.sender == _admin, 'ONLY_BY_ADMIN');\\n    _;\\n  }\\n\\n  modifier onlyTimelock() {\\n    require(msg.sender == address(this), 'ONLY_BY_THIS_TIMELOCK');\\n    _;\\n  }\\n\\n  modifier onlyPendingAdmin() {\\n    require(msg.sender == _pendingAdmin, 'ONLY_BY_PENDING_ADMIN');\\n    _;\\n  }\\n\\n  /**\\n   * @dev Set the delay\\n   * @param delay delay between queue and execution of proposal\\n   **/\\n  function setDelay(uint256 delay) public onlyTimelock {\\n    _validateDelay(delay);\\n    _delay = delay;\\n\\n    emit NewDelay(delay);\\n  }\\n\\n  /**\\n   * @dev Function enabling pending admin to become admin\\n   **/\\n  function acceptAdmin() public onlyPendingAdmin {\\n    _admin = msg.sender;\\n    _pendingAdmin = address(0);\\n\\n    emit NewAdmin(msg.sender);\\n  }\\n\\n  /**\\n   * @dev Setting a new pending admin (that can then become admin)\\n   * Can only be called by this executor (i.e via proposal)\\n   * @param newPendingAdmin address of the new admin\\n   **/\\n  function setPendingAdmin(address newPendingAdmin) public onlyTimelock {\\n    _pendingAdmin = newPendingAdmin;\\n\\n    emit NewPendingAdmin(newPendingAdmin);\\n  }\\n\\n  /**\\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @return the action Hash\\n   **/\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) public override onlyAdmin returns (bytes32) {\\n    require(executionTime >= block.timestamp.add(_delay), 'EXECUTION_TIME_UNDERESTIMATED');\\n\\n    bytes32 actionHash = keccak256(\\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\\n    );\\n    _queuedTransactions[actionHash] = true;\\n\\n    emit QueuedAction(actionHash, target, value, signature, data, executionTime, withDelegatecall);\\n    return actionHash;\\n  }\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @return the action Hash of the canceled tx\\n   **/\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) public override onlyAdmin returns (bytes32) {\\n    bytes32 actionHash = keccak256(\\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\\n    );\\n    _queuedTransactions[actionHash] = false;\\n\\n    emit CancelledAction(\\n      actionHash,\\n      target,\\n      value,\\n      signature,\\n      data,\\n      executionTime,\\n      withDelegatecall\\n    );\\n    return actionHash;\\n  }\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @return the callData executed as memory bytes\\n   **/\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) public override payable onlyAdmin returns (bytes memory) {\\n    bytes32 actionHash = keccak256(\\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\\n    );\\n    require(_queuedTransactions[actionHash], 'ACTION_NOT_QUEUED');\\n    require(block.timestamp >= executionTime, 'TIMELOCK_NOT_FINISHED');\\n    require(block.timestamp <= executionTime.add(GRACE_PERIOD), 'GRACE_PERIOD_FINISHED');\\n\\n    _queuedTransactions[actionHash] = false;\\n\\n    bytes memory callData;\\n\\n    if (bytes(signature).length == 0) {\\n      callData = data;\\n    } else {\\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\n    }\\n\\n    bool success;\\n    bytes memory resultData;\\n    if (withDelegatecall) {\\n      require(msg.value >= value, 'NOT_ENOUGH_MSG_VALUE');\\n      // solium-disable-next-line security/no-call-value\\n      (success, resultData) = target.delegatecall(callData);\\n    } else {\\n      // solium-disable-next-line security/no-call-value\\n      (success, resultData) = target.call{value: value}(callData);\\n    }\\n\\n    require(success, 'FAILED_ACTION_EXECUTION');\\n\\n    emit ExecutedAction(\\n      actionHash,\\n      target,\\n      value,\\n      signature,\\n      data,\\n      executionTime,\\n      withDelegatecall,\\n      resultData\\n    );\\n\\n    return resultData;\\n  }\\n\\n  /**\\n   * @dev Getter of the current admin address (should be governance)\\n   * @return The address of the current admin\\n   **/\\n  function getAdmin() external override view returns (address) {\\n    return _admin;\\n  }\\n\\n  /**\\n   * @dev Getter of the current pending admin address\\n   * @return The address of the pending admin\\n   **/\\n  function getPendingAdmin() external override view returns (address) {\\n    return _pendingAdmin;\\n  }\\n\\n  /**\\n   * @dev Getter of the delay between queuing and execution\\n   * @return The delay in seconds\\n   **/\\n  function getDelay() external override view returns (uint256) {\\n    return _delay;\\n  }\\n\\n  /**\\n   * @dev Returns whether an action (via actionHash) is queued\\n   * @param actionHash hash of the action to be checked\\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\\n   * @return true if underlying action of actionHash is queued\\n   **/\\n  function isActionQueued(bytes32 actionHash) external override view returns (bool) {\\n    return _queuedTransactions[actionHash];\\n  }\\n\\n  /**\\n   * @dev Checks whether a proposal is over its grace period\\n   * @param governance Governance contract\\n   * @param proposalId Id of the proposal against which to test\\n   * @return true of proposal is over grace period\\n   **/\\n  function isProposalOverGracePeriod(IKyberGovernance governance, uint256 proposalId)\\n    external\\n    override\\n    view\\n    returns (bool)\\n  {\\n    IKyberGovernance.ProposalWithoutVote memory proposal = governance.getProposalById(proposalId);\\n\\n    return (block.timestamp > proposal.executionTime.add(GRACE_PERIOD));\\n  }\\n\\n  function _validateDelay(uint256 delay) internal view {\\n    require(delay >= MINIMUM_DELAY, 'DELAY_SHORTER_THAN_MINIMUM');\\n    require(delay <= MAXIMUM_DELAY, 'DELAY_LONGER_THAN_MAXIMUM');\\n  }\\n\\n  receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/governance/executor/DefaultProposalValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IKyberGovernance} from '../../interfaces/governance/IKyberGovernance.sol';\\nimport {IVotingPowerStrategy} from '../../interfaces/governance/IVotingPowerStrategy.sol';\\nimport {IProposalValidator} from '../../interfaces/governance/IProposalValidator.sol';\\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\\nimport {Utils} from '@kyber.network/utils-sc/contracts/Utils.sol';\\n\\n/**\\n * @title Proposal Validator Contract, inherited by Kyber Executors\\n * @dev Validates/Invalidates propositions state modifications\\n * Proposition Power functions: Validates proposition creations/ cancellation\\n * Voting Power functions: Validates success of propositions.\\n * @author Aave\\n **/\\ncontract DefaultProposalValidator is IProposalValidator, Utils {\\n  using SafeMath for uint256;\\n\\n  uint256 public immutable override MIN_VOTING_DURATION;\\n  uint256 public immutable override MAX_VOTING_OPTIONS;\\n  uint256 public immutable override VOTE_DIFFERENTIAL;\\n  uint256 public immutable override MINIMUM_QUORUM;\\n\\n  uint256 public constant YES_INDEX = 0;\\n  uint256 public constant NO_INDEX = 1;\\n\\n  /**\\n   * @dev Constructor\\n   * @param minVotingDuration minimum duration in seconds of the voting period\\n   * @param maxVotingOptions maximum no. of vote options possible for a generic proposal\\n   * @param voteDifferential percentage of supply that `for` votes need to be over `against`\\n   *   in order for the proposal to pass\\n   * - In BPS\\n   * @param minimumQuorum minimum percentage of the supply in FOR-voting-power need for a proposal to pass\\n   * - In BPS\\n   **/\\n  constructor(\\n    uint256 minVotingDuration,\\n    uint256 maxVotingOptions,\\n    uint256 voteDifferential,\\n    uint256 minimumQuorum\\n  ) {\\n    MIN_VOTING_DURATION = minVotingDuration;\\n    MAX_VOTING_OPTIONS = maxVotingOptions;\\n    VOTE_DIFFERENTIAL = voteDifferential;\\n    MINIMUM_QUORUM = minimumQuorum;\\n  }\\n\\n  /**\\n   * @dev Called to validate the cancellation of a proposal\\n   * @param governance governance contract to fetch proposals from\\n   * @param proposalId Id of the generic proposal\\n   * @param user entity initiating the cancellation\\n   * @return boolean, true if can be cancelled\\n   **/\\n  function validateProposalCancellation(\\n    IKyberGovernance governance,\\n    uint256 proposalId,\\n    address user\\n  ) external override pure returns (bool) {\\n    // silence compilation warnings\\n    governance;\\n    proposalId;\\n    user;\\n    return false;\\n  }\\n\\n  /**\\n   * @dev Called to validate a binary proposal\\n   * @notice creator of proposals must be the daoOperator\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param creator address of the creator\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param daoOperator address of daoOperator\\n   * @return boolean, true if can be created\\n   **/\\n  function validateBinaryProposalCreation(\\n    IVotingPowerStrategy strategy,\\n    address creator,\\n    uint256 startTime,\\n    uint256 endTime,\\n    address daoOperator\\n  ) external override view returns (bool) {\\n    // check authorization\\n    if (creator != daoOperator) return false;\\n    // check vote duration\\n    if (endTime.sub(startTime) < MIN_VOTING_DURATION) return false;\\n\\n    return strategy.validateProposalCreation(startTime, endTime);\\n  }\\n\\n  /**\\n   * @dev Called to validate a generic proposal\\n   * @notice creator of proposals must be the daoOperator\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param creator address of the creator\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param options list of proposal vote options\\n   * @param daoOperator address of daoOperator\\n   * @return boolean, true if can be created\\n   **/\\n  function validateGenericProposalCreation(\\n    IVotingPowerStrategy strategy,\\n    address creator,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string[] calldata options,\\n    address daoOperator\\n  ) external override view returns (bool) {\\n    // check authorization\\n    if (creator != daoOperator) return false;\\n    // check vote duration\\n    if (endTime.sub(startTime) < MIN_VOTING_DURATION) return false;\\n    // check options length\\n    if (options.length <= 1 || options.length > MAX_VOTING_OPTIONS) return false;\\n\\n    return strategy.validateProposalCreation(startTime, endTime);\\n  }\\n\\n  /**\\n   * @dev Returns whether a binary proposal passed or not\\n   * @param governance governance contract to fetch proposals from\\n   * @param proposalId Id of the proposal to set\\n   * @return true if proposal passed\\n   **/\\n  function isBinaryProposalPassed(IKyberGovernance governance, uint256 proposalId)\\n    public\\n    override\\n    view\\n    returns (bool)\\n  {\\n    return (isQuorumValid(governance, proposalId) &&\\n      isVoteDifferentialValid(governance, proposalId));\\n  }\\n\\n  /**\\n   * @dev Check whether a binary proposal has reached quorum\\n   * Here quorum is not the number of votes reached, but number of YES_VOTES\\n   * @param governance governance contract to fetch proposals from\\n   * @param proposalId Id of the proposal to verify\\n   * @return true if minimum quorum is reached\\n   **/\\n  function isQuorumValid(IKyberGovernance governance, uint256 proposalId)\\n    public\\n    override\\n    view\\n    returns (bool)\\n  {\\n    IKyberGovernance.ProposalWithoutVote memory proposal = governance.getProposalById(proposalId);\\n    if (proposal.proposalType != IKyberGovernance.ProposalType.Binary) return false;\\n    return isMinimumQuorumReached(proposal.voteCounts[YES_INDEX], proposal.maxVotingPower);\\n  }\\n\\n  /**\\n   * @dev Check whether a binary proposal has sufficient YES_VOTES\\n   * YES_VOTES - NO_VOTES > VOTE_DIFFERENTIAL * voting supply\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to verify\\n   * @return true if enough YES_VOTES\\n   **/\\n  function isVoteDifferentialValid(IKyberGovernance governance, uint256 proposalId)\\n    public\\n    override\\n    view\\n    returns (bool)\\n  {\\n    IKyberGovernance.ProposalWithoutVote memory proposal = governance.getProposalById(proposalId);\\n    if (proposal.proposalType != IKyberGovernance.ProposalType.Binary) return false;\\n    return (\\n      proposal.voteCounts[YES_INDEX].mul(BPS).div(proposal.maxVotingPower) >\\n      proposal.voteCounts[NO_INDEX].mul(BPS).div(proposal.maxVotingPower).add(\\n      VOTE_DIFFERENTIAL\\n    ));\\n  }\\n\\n  function isMinimumQuorumReached(uint256 votes, uint256 voteSupply) internal view returns (bool) {\\n    return votes >= voteSupply.mul(MINIMUM_QUORUM).div(BPS);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/governance/IExecutorWithTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IKyberGovernance} from './IKyberGovernance.sol';\\n\\ninterface IExecutorWithTimelock {\\n  /**\\n   * @dev emitted when a new pending admin is set\\n   * @param newPendingAdmin address of the new pending admin\\n   **/\\n  event NewPendingAdmin(address newPendingAdmin);\\n\\n  /**\\n   * @dev emitted when a new admin is set\\n   * @param newAdmin address of the new admin\\n   **/\\n  event NewAdmin(address newAdmin);\\n\\n  /**\\n   * @dev emitted when a new delay (between queueing and execution) is set\\n   * @param delay new delay\\n   **/\\n  event NewDelay(uint256 delay);\\n\\n  /**\\n   * @dev emitted when a new (trans)action is Queued.\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  event QueuedAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  );\\n\\n  /**\\n   * @dev emitted when an action is Cancelled\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  event CancelledAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  );\\n\\n  /**\\n   * @dev emitted when an action is Cancelled\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @param resultData the actual callData used on the target\\n   **/\\n  event ExecutedAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall,\\n    bytes resultData\\n  );\\n\\n  /**\\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external returns (bytes32);\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external payable returns (bytes memory);\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external returns (bytes32);\\n\\n  /**\\n   * @dev Getter of the current admin address (should be governance)\\n   * @return The address of the current admin\\n   **/\\n  function getAdmin() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the current pending admin address\\n   * @return The address of the pending admin\\n   **/\\n  function getPendingAdmin() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the delay between queuing and execution\\n   * @return The delay in seconds\\n   **/\\n  function getDelay() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns whether an action (via actionHash) is queued\\n   * @param actionHash hash of the action to be checked\\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\\n   * @return true if underlying action of actionHash is queued\\n   **/\\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\\n\\n  /**\\n   * @dev Checks whether a proposal is over its grace period\\n   * @param governance Governance contract\\n   * @param proposalId Id of the proposal against which to test\\n   * @return true of proposal is over grace period\\n   **/\\n  function isProposalOverGracePeriod(IKyberGovernance governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Getter of grace period constant\\n   * @return grace period in seconds\\n   **/\\n  function GRACE_PERIOD() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of minimum delay constant\\n   * @return minimum delay in seconds\\n   **/\\n  function MINIMUM_DELAY() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of maximum delay constant\\n   * @return maximum delay in seconds\\n   **/\\n  function MAXIMUM_DELAY() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/governance/IKyberGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IExecutorWithTimelock} from './IExecutorWithTimelock.sol';\\nimport {IVotingPowerStrategy} from './IVotingPowerStrategy.sol';\\n\\ninterface IKyberGovernance {\\n  enum ProposalState {\\n    Pending,\\n    Canceled,\\n    Active,\\n    Failed,\\n    Succeeded,\\n    Queued,\\n    Expired,\\n    Executed,\\n    Finalized\\n  }\\n  enum ProposalType {Generic, Binary}\\n\\n  /// For Binary proposal, optionBitMask is 0/1/2\\n  /// For Generic proposal, optionBitMask is bitmask of voted options\\n  struct Vote {\\n    uint32 optionBitMask;\\n    uint224 votingPower;\\n  }\\n\\n  struct ProposalWithoutVote {\\n    uint256 id;\\n    ProposalType proposalType;\\n    address creator;\\n    IExecutorWithTimelock executor;\\n    IVotingPowerStrategy strategy;\\n    address[] targets;\\n    uint256[] weiValues;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n    string[] options;\\n    uint256[] voteCounts;\\n    uint256 totalVotes;\\n    uint256 maxVotingPower;\\n    uint256 startTime;\\n    uint256 endTime;\\n    uint256 executionTime;\\n    string link;\\n    bool executed;\\n    bool canceled;\\n  }\\n\\n  struct Proposal {\\n    ProposalWithoutVote proposalData;\\n    mapping(address => Vote) votes;\\n  }\\n\\n  struct BinaryProposalParams {\\n    address[] targets;\\n    uint256[] weiValues;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n  }\\n\\n  /**\\n   * @dev emitted when a new binary proposal is created\\n   * @param proposalId id of the binary proposal\\n   * @param creator address of the creator\\n   * @param executor ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param targets list of contracts called by proposal's associated transactions\\n   * @param weiValues list of value in wei for each propoposal's associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used\\n   *     when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty,\\n   *     calldata ready, else calldata is arguments\\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget,\\n   *    else calls the target\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param link URL link of the proposal\\n   * @param maxVotingPower max voting power for this proposal\\n   **/\\n  event BinaryProposalCreated(\\n    uint256 proposalId,\\n    address indexed creator,\\n    IExecutorWithTimelock indexed executor,\\n    IVotingPowerStrategy indexed strategy,\\n    address[] targets,\\n    uint256[] weiValues,\\n    string[] signatures,\\n    bytes[] calldatas,\\n    bool[] withDelegatecalls,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string link,\\n    uint256 maxVotingPower\\n  );\\n\\n  /**\\n   * @dev emitted when a new generic proposal is created\\n   * @param proposalId id of the generic proposal\\n   * @param creator address of the creator\\n   * @param executor ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param options list of proposal vote options\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param link URL link of the proposal\\n   * @param maxVotingPower max voting power for this proposal\\n   **/\\n  event GenericProposalCreated(\\n    uint256 proposalId,\\n    address indexed creator,\\n    IExecutorWithTimelock indexed executor,\\n    IVotingPowerStrategy indexed strategy,\\n    string[] options,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string link,\\n    uint256 maxVotingPower\\n  );\\n\\n  /**\\n   * @dev emitted when a proposal is canceled\\n   * @param proposalId id of the proposal\\n   **/\\n  event ProposalCanceled(uint256 proposalId);\\n\\n  /**\\n   * @dev emitted when a proposal is queued\\n   * @param proposalId id of the proposal\\n   * @param executionTime time when proposal underlying transactions can be executed\\n   * @param initiatorQueueing address of the initiator of the queuing transaction\\n   **/\\n  event ProposalQueued(\\n    uint256 indexed proposalId,\\n    uint256 executionTime,\\n    address indexed initiatorQueueing\\n  );\\n  /**\\n   * @dev emitted when a proposal is executed\\n   * @param proposalId id of the proposal\\n   * @param initiatorExecution address of the initiator of the execution transaction\\n   **/\\n  event ProposalExecuted(uint256 proposalId, address indexed initiatorExecution);\\n  /**\\n   * @dev emitted when a vote is registered\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @param voteOptions vote options selected by voter\\n   * @param votingPower Power of the voter/vote\\n   **/\\n  event VoteEmitted(\\n    uint256 indexed proposalId,\\n    address indexed voter,\\n    uint32 indexed voteOptions,\\n    uint224 votingPower\\n  );\\n\\n  /**\\n   * @dev emitted when a vote is registered\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @param voteOptions vote options selected by voter\\n   * @param oldVotingPower Old power of the voter/vote\\n   * @param newVotingPower New power of the voter/vote\\n   **/\\n  event VotingPowerChanged(\\n    uint256 indexed proposalId,\\n    address indexed voter,\\n    uint32 indexed voteOptions,\\n    uint224 oldVotingPower,\\n    uint224 newVotingPower\\n  );\\n\\n  event DaoOperatorTransferred(address indexed newDaoOperator);\\n\\n  event ExecutorAuthorized(address indexed executor);\\n\\n  event ExecutorUnauthorized(address indexed executor);\\n\\n  event VotingPowerStrategyAuthorized(address indexed strategy);\\n\\n  event VotingPowerStrategyUnauthorized(address indexed strategy);\\n\\n  /**\\n   * @dev Function is triggered when users withdraw from staking and change voting power\\n   */\\n  function handleVotingPowerChanged(\\n    address staker,\\n    uint256 newVotingPower,\\n    uint256[] calldata proposalIds\\n  ) external;\\n\\n  /**\\n   * @dev Creates a Binary Proposal (needs to be validated by the Proposal Validator)\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy voting power strategy of the proposal\\n   * @param executionParams data for execution, includes\\n   *   targets list of contracts called by proposal's associated transactions\\n   *   weiValues list of value in wei for each proposal's associated transaction\\n   *   signatures list of function signatures (can be empty)\\n   *        to be used when created the callData\\n   *   calldatas list of calldatas: if associated signature empty,\\n   *        calldata ready, else calldata is arguments\\n   *   withDelegatecalls boolean, true = transaction delegatecalls the taget,\\n   *        else calls the target\\n   * @param startTime start timestamp to allow vote\\n   * @param endTime end timestamp of the proposal\\n   * @param link link to the proposal description\\n   **/\\n  function createBinaryProposal(\\n    IExecutorWithTimelock executor,\\n    IVotingPowerStrategy strategy,\\n    BinaryProposalParams memory executionParams,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string memory link\\n  ) external returns (uint256 proposalId);\\n\\n  /**\\n   * @dev Creates a Generic Proposal\\n   * @param executor ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param options list of proposal vote options\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param link URL link of the proposal\\n   **/\\n  function createGenericProposal(\\n    IExecutorWithTimelock executor,\\n    IVotingPowerStrategy strategy,\\n    string[] memory options,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string memory link\\n  ) external returns (uint256 proposalId);\\n\\n  /**\\n   * @dev Cancels a Proposal,\\n   * either at anytime by guardian\\n   * or when proposal is Pending/Active and threshold no longer reached\\n   * @param proposalId id of the proposal\\n   **/\\n  function cancel(uint256 proposalId) external;\\n\\n  /**\\n   * @dev Queue the proposal (If Proposal Succeeded)\\n   * @param proposalId id of the proposal to queue\\n   **/\\n  function queue(uint256 proposalId) external;\\n\\n  /**\\n   * @dev Execute the proposal (If Proposal Queued)\\n   * @param proposalId id of the proposal to execute\\n   **/\\n  function execute(uint256 proposalId) external payable;\\n\\n  /**\\n   * @dev Function allowing msg.sender to vote for/against a proposal\\n   * @param proposalId id of the proposal\\n   * @param optionBitMask vote option(s) selected\\n   **/\\n  function submitVote(uint256 proposalId, uint256 optionBitMask) external;\\n\\n  /**\\n   * @dev Function to register the vote of user that has voted offchain via signature\\n   * @param proposalId id of the proposal\\n   * @param choice the bit mask of voted options\\n   * @param v v part of the voter signature\\n   * @param r r part of the voter signature\\n   * @param s s part of the voter signature\\n   **/\\n  function submitVoteBySignature(\\n    uint256 proposalId,\\n    uint256 choice,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized executors\\n   * @param executors list of new addresses to be authorized executors\\n   **/\\n  function authorizeExecutors(address[] calldata executors) external;\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized executors\\n   * @param executors list of addresses to be removed as authorized executors\\n   **/\\n  function unauthorizeExecutors(address[] calldata executors) external;\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized strategies\\n   * @param strategies list of new addresses to be authorized strategies\\n   **/\\n  function authorizeVotingPowerStrategies(address[] calldata strategies) external;\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized strategies\\n   * @param strategies list of addresses to be removed as authorized strategies\\n   **/\\n  function unauthorizeVotingPowerStrategies(address[] calldata strategies) external;\\n\\n  /**\\n   * @dev Returns whether an address is an authorized executor\\n   * @param executor address to evaluate as authorized executor\\n   * @return true if authorized\\n   **/\\n  function isExecutorAuthorized(address executor) external view returns (bool);\\n\\n  /**\\n   * @dev Returns whether an address is an authorized strategy\\n   * @param strategy address to evaluate as authorized strategy\\n   * @return true if authorized\\n   **/\\n  function isVotingPowerStrategyAuthorized(address strategy) external view returns (bool);\\n\\n  /**\\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\\n   * @return The address of the guardian\\n   **/\\n  function getDaoOperator() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the proposal count (the current number of proposals ever created)\\n   * @return the proposal count\\n   **/\\n  function getProposalsCount() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of a proposal by id\\n   * @param proposalId id of the proposal to get\\n   * @return the proposal as ProposalWithoutVote memory object\\n   **/\\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVote memory);\\n\\n  /**\\n   * @dev Getter of the vote data of a proposal by id\\n   * including totalVotes, voteCounts and options\\n   * @param proposalId id of the proposal\\n   * @return (totalVotes, voteCounts, options)\\n   **/\\n  function getProposalVoteDataById(uint256 proposalId)\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256[] memory,\\n      string[] memory\\n    );\\n\\n  /**\\n   * @dev Getter of the Vote of a voter about a proposal\\n   * Note: Vote is a struct: ({uint32 bitOptionMask, uint224 votingPower})\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @return The associated Vote memory object\\n   **/\\n  function getVoteOnProposal(uint256 proposalId, address voter)\\n    external\\n    view\\n    returns (Vote memory);\\n\\n  /**\\n   * @dev Get the current state of a proposal\\n   * @param proposalId id of the proposal\\n   * @return The current state if the proposal\\n   **/\\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/governance/IVotingPowerStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IWithdrawHandler} from '../staking/IWithdrawHandler.sol';\\n\\ninterface IVotingPowerStrategy is IWithdrawHandler {\\n  /**\\n   * @dev call by governance when create a proposal\\n   */\\n  function handleProposalCreation(\\n    uint256 proposalId,\\n    uint256 startTime,\\n    uint256 endTime\\n  ) external;\\n\\n  /**\\n   * @dev call by governance when cancel a proposal\\n   */\\n  function handleProposalCancellation(uint256 proposalId) external;\\n\\n  /**\\n   * @dev call by governance when submitting a vote\\n   * @param choice: unused param for future usage\\n   * @return votingPower of voter\\n   */\\n  function handleVote(\\n    address voter,\\n    uint256 proposalId,\\n    uint256 choice\\n  ) external returns (uint256 votingPower);\\n\\n  /**\\n   * @dev get voter's voting power given timestamp\\n   * @dev for reading purposes and validating voting power for creating/canceling proposal in the furture\\n   * @dev when submitVote, should call 'handleVote' instead\\n   */\\n  function getVotingPower(address voter, uint256 timestamp)\\n    external\\n    view\\n    returns (uint256 votingPower);\\n\\n  /**\\n   * @dev validate that startTime and endTime are suitable for calculating voting power\\n   * @dev with current version, startTime and endTime must be in the sameEpcoh\\n   */\\n  function validateProposalCreation(uint256 startTime, uint256 endTime)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev getMaxVotingPower at current time\\n   * @dev call by governance when creating a proposal\\n   */\\n  function getMaxVotingPower() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/staking/IWithdrawHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n/**\\n * @title Interface for callbacks hooks when user withdraws from staking contract\\n */\\ninterface IWithdrawHandler {\\n  function handleWithdrawal(address staker, uint256 reduceAmount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/governance/IProposalValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IKyberGovernance} from './IKyberGovernance.sol';\\nimport {IVotingPowerStrategy} from './IVotingPowerStrategy.sol';\\n\\ninterface IProposalValidator {\\n  /**\\n   * @dev Called to validate a binary proposal\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param creator address of the creator\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param daoOperator address of daoOperator\\n   * @return boolean, true if can be created\\n   **/\\n  function validateBinaryProposalCreation(\\n    IVotingPowerStrategy strategy,\\n    address creator,\\n    uint256 startTime,\\n    uint256 endTime,\\n    address daoOperator\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Called to validate a generic proposal\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param creator address of the creator\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param options list of proposal vote options\\n   * @param daoOperator address of daoOperator\\n   * @return boolean, true if can be created\\n   **/\\n  function validateGenericProposalCreation(\\n    IVotingPowerStrategy strategy,\\n    address creator,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string[] calldata options,\\n    address daoOperator\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Called to validate the cancellation of a proposal\\n   * @param governance governance contract to fetch proposals from\\n   * @param proposalId Id of the generic proposal\\n   * @param user entity initiating the cancellation\\n   * @return boolean, true if can be cancelled\\n   **/\\n  function validateProposalCancellation(\\n    IKyberGovernance governance,\\n    uint256 proposalId,\\n    address user\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Returns whether a binary proposal passed or not\\n   * @param governance governance contract to fetch proposals from\\n   * @param proposalId Id of the proposal to set\\n   * @return true if proposal passed\\n   **/\\n  function isBinaryProposalPassed(IKyberGovernance governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Check whether a proposal has reached quorum\\n   * @param governance governance contract to fetch proposals from\\n   * @param proposalId Id of the proposal to verify\\n   * @return voting power needed for a proposal to pass\\n   **/\\n  function isQuorumValid(IKyberGovernance governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\\n   * @param governance governance contract to fetch proposals from\\n   * @param proposalId Id of the proposal to verify\\n   * @return true if enough For-Votes\\n   **/\\n  function isVoteDifferentialValid(IKyberGovernance governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Get maximum vote options for a generic proposal\\n   * @return the maximum no. of vote options possible for a generic proposal\\n   **/\\n  function MAX_VOTING_OPTIONS() external view returns (uint256);\\n\\n  /**\\n   * @dev Get minimum voting duration constant value\\n   * @return the minimum voting duration value in seconds\\n   **/\\n  function MIN_VOTING_DURATION() external view returns (uint256);\\n\\n  /**\\n   * @dev Get the vote differential threshold constant value\\n   * to compare with % of for votes/total supply - % of against votes/total supply\\n   * @return the vote differential threshold value (100 <=> 1%)\\n   **/\\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\\n\\n  /**\\n   * @dev Get quorum threshold constant value\\n   * to compare with % of for votes/total supply\\n   * @return the quorum threshold value (100 <=> 1%)\\n   **/\\n  function MINIMUM_QUORUM() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@kyber.network/utils-sc/contracts/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nimport \\\"./IERC20Ext.sol\\\";\\n\\n\\n/**\\n * @title Kyber utility file\\n * mostly shared constants and rate calculation helpers\\n * inherited by most of kyber contracts.\\n * previous utils implementations are for previous solidity versions.\\n */\\nabstract contract Utils {\\n    // Declared constants below to be used in tandem with\\n    // getDecimalsConstant(), for gas optimization purposes\\n    // which return decimals from a constant list of popular\\n    // tokens.\\n    IERC20Ext internal constant ETH_TOKEN_ADDRESS = IERC20Ext(\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\\n    );\\n    IERC20Ext internal constant USDT_TOKEN_ADDRESS = IERC20Ext(\\n        0xdAC17F958D2ee523a2206206994597C13D831ec7\\n    );\\n    IERC20Ext internal constant DAI_TOKEN_ADDRESS = IERC20Ext(\\n        0x6B175474E89094C44Da98b954EedeAC495271d0F\\n    );\\n    IERC20Ext internal constant USDC_TOKEN_ADDRESS = IERC20Ext(\\n        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\\n    );\\n    IERC20Ext internal constant WBTC_TOKEN_ADDRESS = IERC20Ext(\\n        0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\\n    );\\n    IERC20Ext internal constant KNC_TOKEN_ADDRESS = IERC20Ext(\\n        0xdd974D5C2e2928deA5F71b9825b8b646686BD200\\n    );\\n    uint256 public constant BPS = 10000; // Basic Price Steps. 1 step = 0.01%\\n    uint256 internal constant PRECISION = (10**18);\\n    uint256 internal constant MAX_QTY = (10**28); // 10B tokens\\n    uint256 internal constant MAX_RATE = (PRECISION * 10**7); // up to 10M tokens per eth\\n    uint256 internal constant MAX_DECIMALS = 18;\\n    uint256 internal constant ETH_DECIMALS = 18;\\n    uint256 internal constant MAX_ALLOWANCE = uint256(-1); // token.approve inifinite\\n\\n    mapping(IERC20Ext => uint256) internal decimals;\\n\\n    /// @dev Sets the decimals of a token to storage if not already set, and returns\\n    ///      the decimals value of the token. Prefer using this function over\\n    ///      getDecimals(), to avoid forgetting to set decimals in local storage.\\n    /// @param token The token type\\n    /// @return tokenDecimals The decimals of the token\\n    function getSetDecimals(IERC20Ext token) internal returns (uint256 tokenDecimals) {\\n        tokenDecimals = getDecimalsConstant(token);\\n        if (tokenDecimals > 0) return tokenDecimals;\\n\\n        tokenDecimals = decimals[token];\\n        if (tokenDecimals == 0) {\\n            tokenDecimals = token.decimals();\\n            decimals[token] = tokenDecimals;\\n        }\\n    }\\n\\n    /// @dev Get the balance of a user\\n    /// @param token The token type\\n    /// @param user The user's address\\n    /// @return The balance\\n    function getBalance(IERC20Ext token, address user) internal view returns (uint256) {\\n        if (token == ETH_TOKEN_ADDRESS) {\\n            return user.balance;\\n        } else {\\n            return token.balanceOf(user);\\n        }\\n    }\\n\\n    /// @dev Get the decimals of a token, read from the constant list, storage,\\n    ///      or from token.decimals(). Prefer using getSetDecimals when possible.\\n    /// @param token The token type\\n    /// @return tokenDecimals The decimals of the token\\n    function getDecimals(IERC20Ext token) internal view returns (uint256 tokenDecimals) {\\n        // return token decimals if has constant value\\n        tokenDecimals = getDecimalsConstant(token);\\n        if (tokenDecimals > 0) return tokenDecimals;\\n\\n        // handle case where token decimals is not a declared decimal constant\\n        tokenDecimals = decimals[token];\\n        // moreover, very possible that old tokens have decimals 0\\n        // these tokens will just have higher gas fees.\\n        return (tokenDecimals > 0) ? tokenDecimals : token.decimals();\\n    }\\n\\n    function calcDestAmount(\\n        IERC20Ext src,\\n        IERC20Ext dest,\\n        uint256 srcAmount,\\n        uint256 rate\\n    ) internal view returns (uint256) {\\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\\n    }\\n\\n    function calcSrcAmount(\\n        IERC20Ext src,\\n        IERC20Ext dest,\\n        uint256 destAmount,\\n        uint256 rate\\n    ) internal view returns (uint256) {\\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\\n    }\\n\\n    function calcDstQty(\\n        uint256 srcQty,\\n        uint256 srcDecimals,\\n        uint256 dstDecimals,\\n        uint256 rate\\n    ) internal pure returns (uint256) {\\n        require(srcQty <= MAX_QTY, \\\"srcQty > MAX_QTY\\\");\\n        require(rate <= MAX_RATE, \\\"rate > MAX_RATE\\\");\\n\\n        if (dstDecimals >= srcDecimals) {\\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \\\"dst - src > MAX_DECIMALS\\\");\\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\\n        } else {\\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \\\"src - dst > MAX_DECIMALS\\\");\\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\\n        }\\n    }\\n\\n    function calcSrcQty(\\n        uint256 dstQty,\\n        uint256 srcDecimals,\\n        uint256 dstDecimals,\\n        uint256 rate\\n    ) internal pure returns (uint256) {\\n        require(dstQty <= MAX_QTY, \\\"dstQty > MAX_QTY\\\");\\n        require(rate <= MAX_RATE, \\\"rate > MAX_RATE\\\");\\n\\n        //source quantity is rounded up. to avoid dest quantity being too low.\\n        uint256 numerator;\\n        uint256 denominator;\\n        if (srcDecimals >= dstDecimals) {\\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \\\"src - dst > MAX_DECIMALS\\\");\\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\\n            denominator = rate;\\n        } else {\\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \\\"dst - src > MAX_DECIMALS\\\");\\n            numerator = (PRECISION * dstQty);\\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\\n        }\\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\\n    }\\n\\n    function calcRateFromQty(\\n        uint256 srcAmount,\\n        uint256 destAmount,\\n        uint256 srcDecimals,\\n        uint256 dstDecimals\\n    ) internal pure returns (uint256) {\\n        require(srcAmount <= MAX_QTY, \\\"srcAmount > MAX_QTY\\\");\\n        require(destAmount <= MAX_QTY, \\\"destAmount > MAX_QTY\\\");\\n\\n        if (dstDecimals >= srcDecimals) {\\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \\\"dst - src > MAX_DECIMALS\\\");\\n            return ((destAmount * PRECISION) / ((10**(dstDecimals - srcDecimals)) * srcAmount));\\n        } else {\\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \\\"src - dst > MAX_DECIMALS\\\");\\n            return ((destAmount * PRECISION * (10**(srcDecimals - dstDecimals))) / srcAmount);\\n        }\\n    }\\n\\n    /// @dev save storage access by declaring token decimal constants\\n    /// @param token The token type\\n    /// @return token decimals\\n    function getDecimalsConstant(IERC20Ext token) internal pure returns (uint256) {\\n        if (token == ETH_TOKEN_ADDRESS) {\\n            return ETH_DECIMALS;\\n        } else if (token == USDT_TOKEN_ADDRESS) {\\n            return 6;\\n        } else if (token == DAI_TOKEN_ADDRESS) {\\n            return 18;\\n        } else if (token == USDC_TOKEN_ADDRESS) {\\n            return 6;\\n        } else if (token == WBTC_TOKEN_ADDRESS) {\\n            return 8;\\n        } else if (token == KNC_TOKEN_ADDRESS) {\\n            return 18;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function minOf(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x > y ? y : x;\\n    }\\n}\\n\"\r\n    },\r\n    \"@kyber.network/utils-sc/contracts/IERC20Ext.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n\\n/**\\n * @dev Interface extending ERC20 standard to include decimals() as\\n *      it is optional in the OpenZeppelin IERC20 interface.\\n */\\ninterface IERC20Ext is IERC20 {\\n    /**\\n     * @dev This function is required as Kyber requires to interact\\n     *      with token.decimals() with many of its operations.\\n     */\\n    function decimals() external view returns (uint8 digits);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gracePeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minVoteDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxVotingOptions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteDifferential\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumQuorum\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"actionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"}],\"name\":\"CancelledAction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"actionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"resultData\",\"type\":\"bytes\"}],\"name\":\"ExecutedAction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"NewDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"actionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"}],\"name\":\"QueuedAction\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GRACE_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_VOTING_OPTIONS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_QUORUM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_VOTING_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NO_INDEX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VOTE_DIFFERENTIAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"YES_INDEX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"}],\"name\":\"cancelTransaction\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"}],\"name\":\"executeTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"actionHash\",\"type\":\"bytes32\"}],\"name\":\"isActionQueued\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKyberGovernance\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"isBinaryProposalPassed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKyberGovernance\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"isProposalOverGracePeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKyberGovernance\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"isQuorumValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKyberGovernance\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"isVoteDifferentialValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"}],\"name\":\"queueTransaction\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"setDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IVotingPowerStrategy\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"daoOperator\",\"type\":\"address\"}],\"name\":\"validateBinaryProposalCreation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IVotingPowerStrategy\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"string[]\",\"name\":\"options\",\"type\":\"string[]\"},{\"internalType\":\"address\",\"name\":\"daoOperator\",\"type\":\"address\"}],\"name\":\"validateGenericProposalCreation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKyberGovernance\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"validateProposalCancellation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"DefaultExecutor","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"0000000000000000000000007ec8fcc26be7e9e85b57e73083e5fe0550d8a7fe000000000000000000000000000000000000000000000000000000000000a8c000000000000000000000000000000000000000000000000000000000000546000000000000000000000000000000000000000000000000000000000000000e1000000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000190","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}