{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\n\n\n// Part: IOpenSea\n\ninterface IOpenSea {\n    /**\n     * @dev Call atomicMatch - Solidity ABI encoding limitation workaround, hopefully temporary.\n     */\n    function atomicMatch_(\n        address[14] memory addrs,\n        uint[18] memory uints,\n        uint8[8] memory feeMethodsSidesKindsHowToCalls,\n        bytes memory calldataBuy,\n        bytes memory calldataSell,\n        bytes memory replacementPatternBuy,\n        bytes memory replacementPatternSell,\n        bytes memory staticExtradataBuy,\n        bytes memory staticExtradataSell,\n        uint8[2] memory vs,\n        bytes32[5] memory rssMetadata\n    ) external payable;\n}\n\n// File: OpenSeaMarket.sol\n\nlibrary OpenSeaMarket {\n\n    address public constant OPENSEA = 0x7Be8076f4EA4A4AD08075C2508e481d6C946D12b;\n\n    struct OpenSeaBuy {\n        address[14] addrs;\n        uint[18] uints;\n        uint8[8] feeMethodsSidesKindsHowToCalls;\n        bytes calldataBuy;\n        bytes calldataSell;\n        bytes replacementPatternBuy;\n        bytes replacementPatternSell;\n        bytes staticExtradataBuy;\n        bytes staticExtradataSell;\n        uint8[2] vs;\n        bytes32[5] rssMetadata;\n    }\n\n    function buyAssetsForEth(bytes memory data) public {\n        OpenSeaBuy[] memory openSeaBuys;\n        (openSeaBuys) = abi.decode(\n            data,\n            (OpenSeaBuy[])\n        );\n\n        for (uint256 i = 0; i < openSeaBuys.length; i++) {\n            _buyAssetForEth(openSeaBuys[i]);\n        }\n    }\n\n    function estimateBatchAssetPriceInEth(bytes memory data) public view returns(uint256 totalCost) {\n        OpenSeaBuy[] memory openSeaBuys;\n        (openSeaBuys) = abi.decode(\n            data,\n            (OpenSeaBuy[])\n        );\n\n        for (uint256 i = 0; i < openSeaBuys.length; i++) {\n            totalCost += openSeaBuys[i].uints[4];\n        }\n    }\n\n    function _buyAssetForEth(OpenSeaBuy memory _openSeaBuy) internal {\n        bytes memory _data = abi.encodeWithSelector(IOpenSea(OPENSEA).atomicMatch_.selector, _openSeaBuy.addrs, _openSeaBuy.uints, _openSeaBuy.feeMethodsSidesKindsHowToCalls, _openSeaBuy.calldataBuy, _openSeaBuy.calldataSell, _openSeaBuy.replacementPatternBuy, _openSeaBuy.replacementPatternSell, _openSeaBuy.staticExtradataBuy, _openSeaBuy.staticExtradataSell, _openSeaBuy.vs, _openSeaBuy.rssMetadata);\n\n        (bool success, ) = OPENSEA.call{value:_openSeaBuy.uints[4]}(_data);\n        require(success, \"_buyAssetForEth: opensea buy failed.\");\n    }\n}\n","ABI":"[{\"inputs\":[],\"name\":\"OPENSEA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"estimateBatchAssetPriceInEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalCost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"OpenSeaMarket","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}