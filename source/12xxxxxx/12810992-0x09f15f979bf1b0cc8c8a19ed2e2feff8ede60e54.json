{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.12\r\n\r\n\"\"\"\r\n@title Unagii EthFundManager\r\n@author stakewith.us\r\n@license AGPL-3.0-or-later\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface Vault:\r\n    def token() -> address: view\r\n    def debt() -> uint256: view\r\n    def borrow(amount: uint256) -> uint256: nonpayable\r\n    def repay(amount: uint256) -> uint256: payable\r\n    def report(gain: uint256, loss: uint256): payable\r\n\r\n\r\ninterface IStrategy:\r\n    def fundManager() -> address: view\r\n    def token() -> address: view\r\n    def withdraw(amount: uint256) -> uint256: nonpayable\r\n    def migrate(newVersion: address): nonpayable\r\n\r\n\r\n# interface to new version of FundManager used for migration\r\ninterface FundManager:\r\n    def token() -> address: view\r\n    def vault() -> address: view\r\n    def totalDebt() -> uint256: view\r\n    def totalDebtRatio() -> uint256: view\r\n    def queue(i: uint256) -> address: view\r\n    def strategies(\r\n        addr: address,\r\n    ) -> (bool, bool, bool, uint256, uint256, uint256, uint256): view\r\n    def initialize(): payable\r\n\r\n\r\n# maximum number of active strategies\r\nMAX_QUEUE: constant(uint256) = 20\r\n\r\n\r\nstruct Strategy:\r\n    approved: bool\r\n    active: bool\r\n    activated: bool  # sent to True once after strategy is active\r\n    debtRatio: uint256  # ratio of total assets this strategy can borrow\r\n    debt: uint256  # current amount borrowed\r\n    minBorrow: uint256  # minimum amount to borrow per call to borrow()\r\n    maxBorrow: uint256  # maximum amount to borrow per call to borrow()\r\n\r\n\r\nevent SetNextTimeLock:\r\n    nextTimeLock: address\r\n\r\n\r\nevent AcceptTimeLock:\r\n    timeLock: address\r\n\r\n\r\nevent SetAdmin:\r\n    admin: address\r\n\r\n\r\nevent SetGuardian:\r\n    guardian: address\r\n\r\n\r\nevent SetWorker:\r\n    worker: address\r\n\r\n\r\nevent SetPause:\r\n    paused: bool\r\n\r\n\r\nevent SetVault:\r\n    vault: address\r\n\r\n\r\nevent ApproveStrategy:\r\n    strategy: indexed(address)\r\n\r\n\r\nevent RevokeStrategy:\r\n    strategy: indexed(address)\r\n\r\n\r\nevent AddStrategyToQueue:\r\n    strategy: indexed(address)\r\n\r\n\r\nevent RemoveStrategyFromQueue:\r\n    strategy: indexed(address)\r\n\r\n\r\nevent SetQueue:\r\n    queue: address[MAX_QUEUE]\r\n\r\n\r\nevent SetDebtRatios:\r\n    debtRatios: uint256[MAX_QUEUE]\r\n\r\n\r\nevent SetMinMaxBorrow:\r\n    strategy: indexed(address)\r\n    minBorrow: uint256\r\n    maxBorrow: uint256\r\n\r\n\r\nevent ReceiveEth:\r\n    sender: indexed(address)\r\n    amount: uint256\r\n\r\n\r\nevent BorrowFromVault:\r\n    vault: indexed(address)\r\n    amount: uint256\r\n    borrowed: uint256\r\n\r\n\r\nevent RepayVault:\r\n    vault: indexed(address)\r\n    amount: uint256\r\n    repaid: uint256\r\n\r\n\r\nevent ReportToVault:\r\n    vault: indexed(address)\r\n    total: uint256\r\n    debt: uint256\r\n    gain: uint256\r\n    loss: uint256\r\n\r\n\r\nevent Withdraw:\r\n    vault: indexed(address)\r\n    amount: uint256\r\n    actual: uint256\r\n    loss: uint256\r\n\r\n\r\nevent WithdrawStrategy:\r\n    strategy: indexed(address)\r\n    debt: uint256\r\n    need: uint256\r\n    loss: uint256\r\n    diff: uint256\r\n\r\n\r\nevent Borrow:\r\n    strategy: indexed(address)\r\n    amount: uint256\r\n    borrowed: uint256\r\n\r\n\r\nevent Repay:\r\n    strategy: indexed(address)\r\n    amount: uint256\r\n    repaid: uint256\r\n\r\n\r\nevent Report:\r\n    strategy: indexed(address)\r\n    gain: uint256\r\n    loss: uint256\r\n    debt: uint256\r\n\r\n\r\nevent MigrateStrategy:\r\n    oldStrategy: indexed(address)\r\n    newStrategy: indexed(address)\r\n\r\n\r\nevent Migrate:\r\n    fundManager: address\r\n    bal: uint256\r\n    totalDebt: uint256\r\n\r\n\r\npaused: public(bool)\r\ninitialized: public(bool)\r\n\r\nvault: public(Vault)\r\nETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\n# privileges - time lock >= admin >= guardian, worker\r\ntimeLock: public(address)\r\nnextTimeLock: public(address)\r\nadmin: public(address)\r\nguardian: public(address)\r\nworker: public(address)\r\n\r\ntotalDebt: public(uint256)  # sum of all debts of strategies\r\nMAX_TOTAL_DEBT_RATIO: constant(uint256) = 10000\r\ntotalDebtRatio: public(uint256)  # sum of all debtRatios of strategies\r\nstrategies: public(HashMap[address, Strategy])  # all strategies\r\nqueue: public(address[MAX_QUEUE])  # list of active strategies\r\n\r\n# migration\r\nOLD_MAX_QUEUE: constant(uint256) = 20  # must be <= MAX_QUEUE\r\noldFundManager: public(FundManager)\r\n\r\n\r\n@external\r\ndef __init__(guardian: address, worker: address, oldFundManager: address):\r\n    self.timeLock = msg.sender\r\n    self.admin = msg.sender\r\n    self.guardian = guardian\r\n    self.worker = worker\r\n\r\n    if oldFundManager != ZERO_ADDRESS:\r\n        self.oldFundManager = FundManager(oldFundManager)\r\n        assert self.oldFundManager.token() == ETH, \"old fund manager token != ETH\"\r\n\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    pass\r\n    # log ReceiveEth(msg.sender, msg.value)\r\n\r\n\r\n@external\r\n@view\r\ndef token() -> address:\r\n    return ETH\r\n\r\n\r\n@internal\r\ndef _sendEth(to: address, amount: uint256):\r\n    assert to != ZERO_ADDRESS, \"to = 0 address\"\r\n    raw_call(to, b\"\", value=amount)\r\n\r\n\r\n@internal\r\ndef _safeTransfer(token: address, receiver: address, amount: uint256):\r\n    res: Bytes[32] = raw_call(\r\n        token,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(receiver, bytes32),\r\n            convert(amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(res) > 0:\r\n        assert convert(res, bool), \"transfer failed\"\r\n\r\n\r\n@external\r\n@payable\r\ndef initialize():\r\n    \"\"\"\r\n    @notice Initialize fund manager. Transfer ETH and copy states if\r\n            old fund manager is set.\r\n    \"\"\"\r\n    assert not self.initialized, \"initialized\"\r\n\r\n    if self.oldFundManager.address == ZERO_ADDRESS:\r\n        assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    else:\r\n        assert msg.sender == self.oldFundManager.address, \"!old fund manager\"\r\n\r\n        assert (\r\n            self.vault.address == self.oldFundManager.vault()\r\n        ), \"old fund manager vault != vault\"\r\n\r\n        self.totalDebt = self.oldFundManager.totalDebt()\r\n        self.totalDebtRatio = self.oldFundManager.totalDebtRatio()\r\n\r\n        for i in range(OLD_MAX_QUEUE):\r\n            addr: address = self.oldFundManager.queue(i)\r\n            if addr == ZERO_ADDRESS:\r\n                break\r\n\r\n            assert (\r\n                IStrategy(addr).fundManager() == self\r\n            ), \"strategy fund manager != self\"\r\n\r\n            approved: bool = False\r\n            active: bool = False\r\n            activated: bool = False\r\n            debtRatio: uint256 = 0\r\n            debt: uint256 = 0\r\n            minBorrow: uint256 = 0\r\n            maxBorrow: uint256 = 0\r\n            (\r\n                approved,\r\n                active,\r\n                activated,\r\n                debtRatio,\r\n                debt,\r\n                minBorrow,\r\n                maxBorrow,\r\n            ) = self.oldFundManager.strategies(addr)\r\n            assert approved, \"!approved\"\r\n            assert active, \"!active\"\r\n            assert activated, \"!activated\"\r\n\r\n            self.queue[i] = addr\r\n            self.strategies[addr] = Strategy(\r\n                {\r\n                    approved: True,\r\n                    active: True,\r\n                    activated: True,\r\n                    debtRatio: debtRatio,\r\n                    debt: debt,\r\n                    minBorrow: minBorrow,\r\n                    maxBorrow: maxBorrow,\r\n                }\r\n            )\r\n\r\n    self.initialized = True\r\n\r\n\r\n# Migration steps to new fund manager\r\n#\r\n# v = vault\r\n# f1 = fund manager 1\r\n# f2 = fund manager 2\r\n# strats = active strategies of f1\r\n#\r\n# action                         | caller\r\n# ----------------------------------------\r\n# 1. f2.setVault(v)              | time lock\r\n# 2. f1.setPause(true)           | admin\r\n# 3. for s in strats             |\r\n#      s.setFundManager(f2)      | time lock\r\n# 4. send ETH to f2              | f1\r\n# 5. f2 copy states from f1      | f2\r\n#    - totalDebt                 |\r\n#    - totalDebtRatio            |\r\n#    - queue                     |\r\n#    - active strategy params    |\r\n# 6. f1 reset state              | f1\r\n#    - totalDebt                 |\r\n#    - active strategy debt      |\r\n# 7. v.setFundManager(f2)        | time lock\r\n\r\n\r\n@external\r\ndef migrate(fundManager: address):\r\n    \"\"\"\r\n    @notice Migrate to new fund manager\r\n    @param fundManager Address of new fund manager\r\n    \"\"\"\r\n    assert msg.sender == self.timeLock, \"!time lock\"\r\n    assert self.initialized, \"!initialized\"\r\n    assert self.paused, \"!paused\"\r\n\r\n    assert FundManager(fundManager).token() == ETH, \"new fund manager token != ETH\"\r\n    assert (\r\n        FundManager(fundManager).vault() == self.vault.address\r\n    ), \"new fund manager vault != vault\"\r\n\r\n    for strat in self.queue:\r\n        if strat == ZERO_ADDRESS:\r\n            break\r\n        assert (\r\n            IStrategy(strat).fundManager() == fundManager\r\n        ), \"strategy fund manager != new fund manager\"\r\n\r\n    bal: uint256 = self.balance\r\n    FundManager(fundManager).initialize(value=bal)\r\n\r\n    log Migrate(fundManager, bal, self.totalDebt)\r\n\r\n    self.totalDebt = 0\r\n\r\n    for strat in self.queue:\r\n        if strat == ZERO_ADDRESS:\r\n            break\r\n        self.strategies[strat].debt = 0\r\n\r\n\r\n@external\r\ndef setNextTimeLock(nextTimeLock: address):\r\n    \"\"\"\r\n    @notice Set next time lock\r\n    @param nextTimeLock Address of next time lock\r\n    \"\"\"\r\n    assert msg.sender == self.timeLock, \"!time lock\"\r\n    self.nextTimeLock = nextTimeLock\r\n    log SetNextTimeLock(nextTimeLock)\r\n\r\n\r\n@external\r\ndef acceptTimeLock():\r\n    \"\"\"\r\n    @notice Accept time lock\r\n    @dev Only `nextTimeLock` can claim time lock\r\n    \"\"\"\r\n    assert msg.sender == self.nextTimeLock, \"!next time lock\"\r\n    self.timeLock = msg.sender\r\n    log AcceptTimeLock(msg.sender)\r\n\r\n\r\n@external\r\ndef setAdmin(admin: address):\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    self.admin = admin\r\n    log SetAdmin(admin)\r\n\r\n\r\n@external\r\ndef setGuardian(guardian: address):\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    self.guardian = guardian\r\n    log SetGuardian(guardian)\r\n\r\n\r\n@external\r\ndef setWorker(worker: address):\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    self.worker = worker\r\n    log SetWorker(worker)\r\n\r\n\r\n@external\r\ndef setPause(paused: bool):\r\n    assert msg.sender in [self.timeLock, self.admin, self.guardian], \"!auth\"\r\n    self.paused = paused\r\n    log SetPause(paused)\r\n\r\n\r\n@external\r\ndef setVault(vault: address):\r\n    \"\"\"\r\n    @notice Set vault\r\n    @param vault Address of vault\r\n    \"\"\"\r\n    assert msg.sender == self.timeLock, \"!time lock\"\r\n    assert Vault(vault).token() == ETH, \"vault token != ETH\"\r\n\r\n    self.vault = Vault(vault)\r\n\r\n    log SetVault(vault)\r\n\r\n\r\n@internal\r\n@view\r\ndef _totalAssets() -> uint256:\r\n    \"\"\"\r\n    @notice Total amount of ETH in this fund manager + total amount borrowed\r\n            by strategies\r\n    @dev Returns total amount of ETH managed by this contract\r\n    \"\"\"\r\n    return self.balance + self.totalDebt\r\n\r\n\r\n@external\r\n@view\r\ndef totalAssets() -> uint256:\r\n    return self._totalAssets()\r\n\r\n\r\n# array functions tested in test/Array.vy\r\n@internal\r\ndef _pack():\r\n    arr: address[MAX_QUEUE] = empty(address[MAX_QUEUE])\r\n    i: uint256 = 0\r\n    for strat in self.queue:\r\n        if strat != ZERO_ADDRESS:\r\n            arr[i] = strat\r\n            i += 1\r\n    self.queue = arr\r\n\r\n\r\n@internal\r\ndef _append(strategy: address):\r\n    assert self.queue[MAX_QUEUE - 1] == ZERO_ADDRESS, \"queue > max\"\r\n    self.queue[MAX_QUEUE - 1] = strategy\r\n    self._pack()\r\n\r\n\r\n@internal\r\ndef _remove(i: uint256):\r\n    assert i < MAX_QUEUE, \"i >= max\"\r\n    assert self.queue[i] != ZERO_ADDRESS, \"!zero address\"\r\n    self.queue[i] = ZERO_ADDRESS\r\n    self._pack()\r\n\r\n\r\n@internal\r\n@view\r\ndef _find(strategy: address) -> uint256:\r\n    for i in range(MAX_QUEUE):\r\n        if self.queue[i] == strategy:\r\n            return i\r\n    raise \"not found\"\r\n\r\n\r\n@external\r\ndef approveStrategy(strategy: address):\r\n    \"\"\"\r\n    @notice Approve strategy\r\n    @param strategy Address of strategy\r\n    \"\"\"\r\n    assert msg.sender == self.timeLock, \"!time lock\"\r\n\r\n    assert not self.strategies[strategy].approved, \"approved\"\r\n    assert IStrategy(strategy).fundManager() == self, \"strategy fund manager != this\"\r\n    assert IStrategy(strategy).token() == ETH, \"strategy token != ETH\"\r\n\r\n    self.strategies[strategy] = Strategy(\r\n        {\r\n            approved: True,\r\n            active: False,\r\n            activated: False,\r\n            debtRatio: 0,\r\n            debt: 0,\r\n            minBorrow: 0,\r\n            maxBorrow: 0,\r\n        }\r\n    )\r\n\r\n    log ApproveStrategy(strategy)\r\n\r\n\r\n@external\r\ndef revokeStrategy(strategy: address):\r\n    \"\"\"\r\n    @notice Disapprove strategy\r\n    @param strategy Address of strategy\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    assert self.strategies[strategy].approved, \"!approved\"\r\n    assert not self.strategies[strategy].active, \"active\"\r\n\r\n    self.strategies[strategy].approved = False\r\n    log RevokeStrategy(strategy)\r\n\r\n\r\n@external\r\ndef addStrategyToQueue(\r\n    strategy: address, debtRatio: uint256, minBorrow: uint256, maxBorrow: uint256\r\n):\r\n    \"\"\"\r\n    @notice Activate strategy\r\n    @param strategy Address of strategy\r\n    @param debtRatio Ratio of total assets this strategy can borrow\r\n    @param minBorrow Minimum amount to borrow per call to borrow()\r\n    @param maxBorrow Maximum amount to borrow per call to borrow()\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    assert self.strategies[strategy].approved, \"!approved\"\r\n    assert not self.strategies[strategy].active, \"active\"\r\n    assert self.totalDebtRatio + debtRatio <= MAX_TOTAL_DEBT_RATIO, \"ratio > max\"\r\n    assert minBorrow <= maxBorrow, \"min borrow > max borrow\"\r\n\r\n    self._append(strategy)\r\n    self.strategies[strategy].active = True\r\n    self.strategies[strategy].activated = True\r\n    self.strategies[strategy].debtRatio = debtRatio\r\n    self.strategies[strategy].minBorrow = minBorrow\r\n    self.strategies[strategy].maxBorrow = maxBorrow\r\n    self.totalDebtRatio += debtRatio\r\n\r\n    log AddStrategyToQueue(strategy)\r\n\r\n\r\n@external\r\ndef removeStrategyFromQueue(strategy: address):\r\n    \"\"\"\r\n    @notice Deactivate strategy\r\n    @param strategy Addres of strategy\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin, self.guardian], \"!auth\"\r\n    assert self.strategies[strategy].active, \"!active\"\r\n\r\n    self._remove(self._find(strategy))\r\n    self.strategies[strategy].active = False\r\n    self.totalDebtRatio -= self.strategies[strategy].debtRatio\r\n    self.strategies[strategy].debtRatio = 0\r\n\r\n    log RemoveStrategyFromQueue(strategy)\r\n\r\n\r\n@external\r\ndef setQueue(queue: address[MAX_QUEUE]):\r\n    \"\"\"\r\n    @notice Reorder queue\r\n    @param queue Array of active strategies\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n\r\n    # check no gaps in new queue\r\n    zero: bool = False\r\n    for i in range(MAX_QUEUE):\r\n        strat: address = queue[i]\r\n        if strat == ZERO_ADDRESS:\r\n            if not zero:\r\n                zero = True\r\n        else:\r\n            assert not zero, \"gap\"\r\n\r\n    # Check old and new queue counts of non zero strategies are equal\r\n    for i in range(MAX_QUEUE):\r\n        oldStrat: address = self.queue[i]\r\n        newStrat: address = queue[i]\r\n        if oldStrat == ZERO_ADDRESS:\r\n            assert newStrat == ZERO_ADDRESS, \"new != 0\"\r\n        else:\r\n            assert newStrat != ZERO_ADDRESS, \"new = 0\"\r\n\r\n    # Check new strategy is active and no duplicate\r\n    for i in range(MAX_QUEUE):\r\n        strat: address = queue[i]\r\n        if strat == ZERO_ADDRESS:\r\n            break\r\n        # code below will fail if duplicate strategy in new queue\r\n        assert self.strategies[strat].active, \"!active\"\r\n        self.strategies[strat].active = False\r\n\r\n    # update queue\r\n    for i in range(MAX_QUEUE):\r\n        strat: address = queue[i]\r\n        if strat == ZERO_ADDRESS:\r\n            break\r\n        self.strategies[strat].active = True\r\n        self.queue[i] = strat\r\n\r\n    log SetQueue(queue)\r\n\r\n\r\n@external\r\ndef setDebtRatios(debtRatios: uint256[MAX_QUEUE]):\r\n    \"\"\"\r\n    @notice Update debt ratios of active strategies\r\n    @param debtRatios Array of debt ratios\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n\r\n    # check that we're only setting debt ratio on active strategy\r\n    for i in range(MAX_QUEUE):\r\n        if self.queue[i] == ZERO_ADDRESS:\r\n            assert debtRatios[i] == 0, \"debt ratio != 0\"\r\n\r\n    # use memory to save gas\r\n    totalDebtRatio: uint256 = 0\r\n    for i in range(MAX_QUEUE):\r\n        addr: address = self.queue[i]\r\n        if addr == ZERO_ADDRESS:\r\n            break\r\n\r\n        debtRatio: uint256 = debtRatios[i]\r\n        self.strategies[addr].debtRatio = debtRatio\r\n        totalDebtRatio += debtRatio\r\n\r\n    self.totalDebtRatio = totalDebtRatio\r\n\r\n    assert self.totalDebtRatio <= MAX_TOTAL_DEBT_RATIO, \"total > max\"\r\n\r\n    log SetDebtRatios(debtRatios)\r\n\r\n\r\n@external\r\ndef setMinMaxBorrow(strategy: address, minBorrow: uint256, maxBorrow: uint256):\r\n    \"\"\"\r\n    @notice Update `minBorrow` and `maxBorrow` of approved strategy\r\n    @param minBorrow Minimum amount to borrow per call to borrow()\r\n    @param maxBorrow Maximum amount to borrow per call to borrow()\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    assert self.strategies[strategy].approved, \"!approved\"\r\n    assert minBorrow <= maxBorrow, \"min borrow > max borrow\"\r\n\r\n    self.strategies[strategy].minBorrow = minBorrow\r\n    self.strategies[strategy].maxBorrow = maxBorrow\r\n\r\n    log SetMinMaxBorrow(strategy, minBorrow, maxBorrow)\r\n\r\n\r\n# functions between Vault and this contract #\r\n@external\r\ndef borrowFromVault(amount: uint256, _min: uint256):\r\n    \"\"\"\r\n    @notice Borrow ETH from vault\r\n    @param amount Amount of ETH to borrow\r\n    @param _min Minimum amount to borrow\r\n    \"\"\"\r\n    assert self.initialized, \"!initialized\"\r\n    assert msg.sender in [self.timeLock, self.admin, self.worker], \"!auth\"\r\n    # fails if vault not set\r\n    borrowed: uint256 = self.vault.borrow(amount)\r\n    assert borrowed >= _min, \"borrowed < min\"\r\n\r\n    log BorrowFromVault(self.vault.address, amount, borrowed)\r\n\r\n\r\n@external\r\ndef repayVault(amount: uint256, _min: uint256):\r\n    \"\"\"\r\n    @notice Repay ETH to vault\r\n    @param amount Amount to repay\r\n    @param _min Minimum amount to repay\r\n    \"\"\"\r\n    assert self.initialized, \"!initialized\"\r\n    assert msg.sender in [self.timeLock, self.admin, self.worker], \"!auth\"\r\n    # fails if vault not set\r\n    repaid: uint256 = self.vault.repay(amount, value=amount)\r\n    assert repaid >= _min, \"repaid < min\"\r\n\r\n    log RepayVault(self.vault.address, amount, repaid)\r\n\r\n\r\n@external\r\ndef reportToVault(_minTotal: uint256, _maxTotal: uint256):\r\n    \"\"\"\r\n    @notice Report gain and loss to vault\r\n    @param _minTotal Minumum of total assets\r\n    @param _maxTotal Maximum of total assets\r\n    @dev `_minTotal` and `_maxTotal` is used to check that totalAssets is\r\n         within a reasonable range before this function is called\r\n    \"\"\"\r\n    assert self.initialized, \"!initialized\"\r\n    assert msg.sender in [self.timeLock, self.admin, self.worker], \"!auth\"\r\n\r\n    total: uint256 = self._totalAssets()\r\n    assert total >= _minTotal and total <= _maxTotal, \"total not in range\"\r\n\r\n    debt: uint256 = self.vault.debt()\r\n    gain: uint256 = 0\r\n    loss: uint256 = 0\r\n\r\n    if total > debt:\r\n        gain = min(total - debt, self.balance)\r\n    else:\r\n        loss = debt - total\r\n\r\n    if gain > 0 or loss > 0:\r\n        self.vault.report(gain, loss, value=gain)\r\n\r\n    log ReportToVault(self.vault.address, total, debt, gain, loss)\r\n\r\n\r\n# functions between vault -> this contract -> strategies #\r\n@internal\r\ndef _withdraw(amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw ETH from active strategies\r\n    @param amount Amount of ETH to withdraw\r\n    @dev Returns sum of losses from active strategies that were withdrawn.\r\n    \"\"\"\r\n    _amount: uint256 = amount\r\n    totalLoss: uint256 = 0\r\n    for strategy in self.queue:\r\n        if strategy == ZERO_ADDRESS:\r\n            break\r\n\r\n        bal: uint256 = self.balance\r\n        if bal >= _amount:\r\n            break\r\n\r\n        debt: uint256 = self.strategies[strategy].debt\r\n        need: uint256 = min(_amount - bal, debt)\r\n        if need == 0:\r\n            continue\r\n\r\n        # loss must be <= debt\r\n        loss: uint256 = IStrategy(strategy).withdraw(need)\r\n        diff: uint256 = self.balance - bal\r\n\r\n        if loss > 0:\r\n            _amount -= loss\r\n            totalLoss += loss\r\n            self.strategies[strategy].debt -= loss\r\n            self.totalDebt -= loss\r\n\r\n        self.strategies[strategy].debt -= diff\r\n        self.totalDebt -= diff\r\n\r\n        log WithdrawStrategy(strategy, debt, need, loss, diff)\r\n\r\n    return totalLoss\r\n\r\n\r\n@external\r\ndef withdraw(amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw ETH from fund manager back to vault\r\n    @param amount Amount of ETH to withdraw\r\n    @dev Returns sum of losses from active strategies that were withdrawn.\r\n    \"\"\"\r\n    assert self.initialized, \"!initialized\"\r\n    assert msg.sender == self.vault.address, \"!vault\"\r\n\r\n    total: uint256 = self._totalAssets()\r\n    _amount: uint256 = min(amount, total)\r\n    assert _amount > 0, \"withdraw = 0\"\r\n\r\n    debt: uint256 = self.vault.debt()\r\n    loss: uint256 = 0\r\n    if debt > total:\r\n        # debt > total can occur when strategies reported losses to this contract\r\n        # but this contract has not reported losses back to vault\r\n        loss = debt - total\r\n\r\n    bal: uint256 = self.balance\r\n    if _amount > bal:\r\n        # try to withdraw until balance of fund manager >= _amount\r\n        loss += self._withdraw(_amount)\r\n        _amount = min(_amount, self.balance)\r\n\r\n    if _amount > 0:\r\n        self._sendEth(msg.sender, _amount)\r\n\r\n    log Withdraw(msg.sender, amount, _amount, loss)\r\n\r\n    return loss\r\n\r\n\r\n# functions between this contract and strategies #\r\n@internal\r\n@view\r\ndef _calcMaxBorrow(strategy: address) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate how much ETH strategy can borrow\r\n    @param strategy Address of strategy\r\n    @dev Returns amount of ETH that `strategy` can borrow\r\n    \"\"\"\r\n    if (not self.initialized) or self.paused or self.totalDebtRatio == 0:\r\n        return 0\r\n\r\n    # strategy debtRatio > 0 only if strategy is active\r\n    limit: uint256 = (\r\n        self.strategies[strategy].debtRatio * self._totalAssets() / self.totalDebtRatio\r\n    )\r\n    debt: uint256 = self.strategies[strategy].debt\r\n\r\n    if debt >= limit:\r\n        return 0\r\n\r\n    available: uint256 = min(limit - debt, self.balance)\r\n\r\n    if available < self.strategies[strategy].minBorrow:\r\n        return 0\r\n    else:\r\n        return min(available, self.strategies[strategy].maxBorrow)\r\n\r\n\r\n@external\r\n@view\r\ndef calcMaxBorrow(strategy: address) -> uint256:\r\n    return self._calcMaxBorrow(strategy)\r\n\r\n\r\n@internal\r\n@view\r\ndef _calcOutstandingDebt(strategy: address) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate amount of ETH that `strategy` should pay back to fund manager\r\n    @param strategy Address of strategy\r\n    @dev Returns minimum amount of ETH strategy should repay\r\n    \"\"\"\r\n    if not self.initialized:\r\n        return 0\r\n\r\n    if self.totalDebtRatio == 0:\r\n        return self.strategies[strategy].debt\r\n\r\n    limit: uint256 = (\r\n        self.strategies[strategy].debtRatio * self.totalDebt / self.totalDebtRatio\r\n    )\r\n    debt: uint256 = self.strategies[strategy].debt\r\n\r\n    if self.paused:\r\n        return debt\r\n    elif debt <= limit:\r\n        return 0\r\n    else:\r\n        return debt - limit\r\n\r\n\r\n@external\r\n@view\r\ndef calcOutstandingDebt(strategy: address) -> uint256:\r\n    return self._calcOutstandingDebt(strategy)\r\n\r\n\r\n@external\r\n@view\r\ndef getDebt(strategy: address) -> uint256:\r\n    \"\"\"\r\n    @notice Return debt of strategy\r\n    @param strategy Address of strategy\r\n    @dev Returns current debt of strategy\r\n    \"\"\"\r\n    return self.strategies[strategy].debt\r\n\r\n\r\n@external\r\ndef borrow(amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Borrow ETH from fund manager\r\n    @param amount Amount of ETH to borrow\r\n    @dev Returns actual amount sent\r\n    @dev Only active strategy can borrow\r\n    \"\"\"\r\n    assert self.initialized, \"!initialized\"\r\n    assert not self.paused, \"paused\"\r\n    assert self.strategies[msg.sender].active, \"!active\"\r\n\r\n    _amount: uint256 = min(amount, self._calcMaxBorrow(msg.sender))\r\n    assert _amount > 0, \"borrow = 0\"\r\n\r\n    self._sendEth(msg.sender, _amount)\r\n\r\n    # include any fee on transfer to debt\r\n    self.strategies[msg.sender].debt += _amount\r\n    self.totalDebt += _amount\r\n\r\n    log Borrow(msg.sender, amount, _amount)\r\n\r\n    return _amount\r\n\r\n\r\n@external\r\n@payable\r\ndef repay(amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Repay debt to fund manager\r\n    @param amount Amount of ETH to repay\r\n    @dev Returns actual amount repaid\r\n    @dev Only approved strategy can repay\r\n    \"\"\"\r\n    assert self.initialized, \"!initialized\"\r\n    assert self.strategies[msg.sender].approved, \"!approved\"\r\n\r\n    assert amount == msg.value, \"amount != msg.value\"\r\n    assert amount > 0, \"repay = 0\"\r\n\r\n    self.strategies[msg.sender].debt -= amount\r\n    self.totalDebt -= amount\r\n\r\n    log Repay(msg.sender, amount, amount)\r\n\r\n    return amount\r\n\r\n\r\n@external\r\n@payable\r\ndef report(gain: uint256, loss: uint256):\r\n    \"\"\"\r\n    @notice Report gain and loss from strategy\r\n    @param gain Amount of profit\r\n    @param loss Amount of loss\r\n    \"\"\"\r\n    assert self.initialized, \"!initialized\"\r\n    assert self.strategies[msg.sender].active, \"!active\"\r\n    # can't have both gain and loss > 0\r\n    assert (gain >= 0 and loss == 0) or (gain == 0 and loss >= 0), \"gain and loss > 0\"\r\n    assert gain == msg.value, \"gain != msg.value\"\r\n\r\n    if gain > 0:\r\n        pass\r\n    elif loss > 0:\r\n        self.strategies[msg.sender].debt -= loss\r\n        self.totalDebt -= loss\r\n\r\n    log Report(msg.sender, gain, loss, self.strategies[msg.sender].debt)\r\n\r\n\r\n@external\r\ndef migrateStrategy(oldStrat: address, newStrat: address):\r\n    \"\"\"\r\n    @notice Migrate strategy\r\n    @param oldStrat Address of current strategy\r\n    @param newStrat Address of strategy to migrate to\r\n    \"\"\"\r\n    assert self.initialized, \"!initialized\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    assert self.strategies[oldStrat].active, \"old !active\"\r\n    assert self.strategies[newStrat].approved, \"new !approved\"\r\n    assert not self.strategies[newStrat].activated, \"activated\"\r\n\r\n    strat: Strategy = self.strategies[oldStrat]\r\n\r\n    self.strategies[newStrat] = Strategy(\r\n        {\r\n            approved: True,\r\n            active: True,\r\n            activated: True,\r\n            debtRatio: strat.debtRatio,\r\n            debt: strat.debt,\r\n            minBorrow: strat.minBorrow,\r\n            maxBorrow: strat.maxBorrow,\r\n        }\r\n    )\r\n\r\n    self.strategies[oldStrat].active = False\r\n    self.strategies[oldStrat].debtRatio = 0\r\n    self.strategies[oldStrat].debt = 0\r\n    self.strategies[oldStrat].minBorrow = 0\r\n    self.strategies[oldStrat].maxBorrow = 0\r\n\r\n    # find and replace strategy\r\n    i: uint256 = self._find(oldStrat)\r\n    self.queue[i] = newStrat\r\n\r\n    IStrategy(oldStrat).migrate(newStrat)\r\n    log MigrateStrategy(oldStrat, newStrat)\r\n\r\n\r\n@external\r\ndef sweep(token: address):\r\n    \"\"\"\r\n    @notice Transfer any token accidentally sent to this contract to admin or\r\n            time lock\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    self._safeTransfer(token, msg.sender, ERC20(token).balanceOf(self))","ABI":"[{\"name\":\"SetNextTimeLock\",\"inputs\":[{\"name\":\"nextTimeLock\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AcceptTimeLock\",\"inputs\":[{\"name\":\"timeLock\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetAdmin\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetGuardian\",\"inputs\":[{\"name\":\"guardian\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetWorker\",\"inputs\":[{\"name\":\"worker\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetPause\",\"inputs\":[{\"name\":\"paused\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetVault\",\"inputs\":[{\"name\":\"vault\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApproveStrategy\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RevokeStrategy\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddStrategyToQueue\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveStrategyFromQueue\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetQueue\",\"inputs\":[{\"name\":\"queue\",\"type\":\"address[20]\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetDebtRatios\",\"inputs\":[{\"name\":\"debtRatios\",\"type\":\"uint256[20]\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetMinMaxBorrow\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true},{\"name\":\"minBorrow\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"maxBorrow\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ReceiveEth\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"BorrowFromVault\",\"inputs\":[{\"name\":\"vault\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"borrowed\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RepayVault\",\"inputs\":[{\"name\":\"vault\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"repaid\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ReportToVault\",\"inputs\":[{\"name\":\"vault\",\"type\":\"address\",\"indexed\":true},{\"name\":\"total\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"debt\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"gain\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"loss\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"vault\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"actual\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"loss\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"WithdrawStrategy\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true},{\"name\":\"debt\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"need\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"loss\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"diff\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Borrow\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"borrowed\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Repay\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"repaid\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Report\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true},{\"name\":\"gain\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"loss\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"debt\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"MigrateStrategy\",\"inputs\":[{\"name\":\"oldStrategy\",\"type\":\"address\",\"indexed\":true},{\"name\":\"newStrategy\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Migrate\",\"inputs\":[{\"name\":\"fundManager\",\"type\":\"address\",\"indexed\":false},{\"name\":\"bal\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"totalDebt\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"guardian\",\"type\":\"address\"},{\"name\":\"worker\",\"type\":\"address\"},{\"name\":\"oldFundManager\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":378},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[],\"outputs\":[],\"gas\":5994021},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"migrate\",\"inputs\":[{\"name\":\"fundManager\",\"type\":\"address\"}],\"outputs\":[],\"gas\":625644},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setNextTimeLock\",\"inputs\":[{\"name\":\"nextTimeLock\",\"type\":\"address\"}],\"outputs\":[],\"gas\":39101},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"acceptTimeLock\",\"inputs\":[],\"outputs\":[],\"gas\":39023},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setAdmin\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"outputs\":[],\"gas\":41682},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setGuardian\",\"inputs\":[{\"name\":\"guardian\",\"type\":\"address\"}],\"outputs\":[],\"gas\":41712},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setWorker\",\"inputs\":[{\"name\":\"worker\",\"type\":\"address\"}],\"outputs\":[],\"gas\":41742},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setPause\",\"inputs\":[{\"name\":\"paused\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":44040},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setVault\",\"inputs\":[{\"name\":\"vault\",\"type\":\"address\"}],\"outputs\":[],\"gas\":41776},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalAssets\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3635},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approveStrategy\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"}],\"outputs\":[],\"gas\":166804},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"revokeStrategy\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"}],\"outputs\":[],\"gas\":31656},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"addStrategyToQueue\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"},{\"name\":\"debtRatio\",\"type\":\"uint256\"},{\"name\":\"minBorrow\",\"type\":\"uint256\"},{\"name\":\"maxBorrow\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":1773871},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"removeStrategyFromQueue\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"}],\"outputs\":[],\"gas\":1673031},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setQueue\",\"inputs\":[{\"name\":\"queue\",\"type\":\"address[20]\"}],\"outputs\":[],\"gas\":1941256},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setDebtRatios\",\"inputs\":[{\"name\":\"debtRatios\",\"type\":\"uint256[20]\"}],\"outputs\":[],\"gas\":862108},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setMinMaxBorrow\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"},{\"name\":\"minBorrow\",\"type\":\"uint256\"},{\"name\":\"maxBorrow\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":80916},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"borrowFromVault\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_min\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":19116},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"repayVault\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_min\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":53149},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"reportToVault\",\"inputs\":[{\"name\":\"_minTotal\",\"type\":\"uint256\"},{\"name\":\"_maxTotal\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":66905},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3286612},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calcMaxBorrow\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":26763},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calcOutstandingDebt\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":20613},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getDebt\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3491},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"borrow\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":149965},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"repay\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":82977},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"report\",\"inputs\":[{\"name\":\"gain\",\"type\":\"uint256\"},{\"name\":\"loss\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":86034},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"migrateStrategy\",\"inputs\":[{\"name\":\"oldStrat\",\"type\":\"address\"},{\"name\":\"newStrat\",\"type\":\"address\"}],\"outputs\":[],\"gas\":468847},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"sweep\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"outputs\":[],\"gas\":18727},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"paused\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3378},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initialized\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3408},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vault\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3438},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"timeLock\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3468},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nextTimeLock\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3498},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3528},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"guardian\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3558},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"worker\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3588},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalDebt\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3618},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalDebtRatio\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3648},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"strategies\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"approved\",\"type\":\"bool\"},{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"activated\",\"type\":\"bool\"},{\"name\":\"debtRatio\",\"type\":\"uint256\"},{\"name\":\"debt\",\"type\":\"uint256\"},{\"name\":\"minBorrow\",\"type\":\"uint256\"},{\"name\":\"maxBorrow\",\"type\":\"uint256\"}],\"gas\":17837},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"queue\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3817},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"oldFundManager\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3738}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.12","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"00000000000000000000000086d10751b18f3fe331c146546868a07224a8598b00000000000000000000000086d10751b18f3fe331c146546868a07224a8598b0000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":""}]}