{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/MerkleProof.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle trees (hash trees),\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == root;\r\n    }\r\n}\r\n\r\n// File: contracts/IERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/SafeMath.sol\r\n\r\npragma solidity  ^0.6.0;\r\n\r\ncontract SafeMath {\r\n   /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeSub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function safeSub(uint256 a, uint256 b, string memory error) internal pure returns (uint256) {\r\n        require(b <= a, error);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeDiv(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function safeDiv(uint256 a, uint256 b, string memory error) internal pure returns (uint256) {\r\n        require(b > 0, error);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function safeExponent(uint256 a,uint256 b) internal pure returns (uint256) {\r\n        uint256 result;\r\n        assembly {\r\n            result:=exp(a, b)\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n// File: contracts/Constant.sol\r\n\r\npragma solidity  ^0.6.0;\r\n\r\ncontract Constant {\r\n    string constant ERR_CONTRACT_SELF_ADDRESS = \"ERR_CONTRACT_SELF_ADDRESS\";\r\n    string constant ERR_ZERO_ADDRESS = \"ERR_ZERO_ADDRESS\";\r\n    string constant ERR_NOT_OWN_ADDRESS = \"ERR_NOT_OWN_ADDRESS\";\r\n    string constant ERR_VALUE_IS_ZERO = \"ERR_VALUE_IS_ZERO\";\r\n    string constant ERR_AUTHORIZED_ADDRESS_ONLY = \"ERR_AUTHORIZED_ADDRESS_ONLY\";\r\n    string constant ERR_NOT_ENOUGH_BALANCE = \"ERR_NOT_ENOUGH_BALANCE\";\r\n\r\n    modifier notOwnAddress(address _which) {\r\n        require(msg.sender != _which, ERR_NOT_OWN_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    // validates an address is not zero\r\n    modifier notZeroAddress(address _which) {\r\n        require(_which != address(0), ERR_ZERO_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThisAddress(address _which) {\r\n        require(_which != address(this), ERR_CONTRACT_SELF_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    modifier notZeroValue(uint256 _value) {\r\n        require(_value > 0, ERR_VALUE_IS_ZERO);\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/Ownable.sol\r\n\r\npragma solidity  ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Constant {\r\n    \r\n    address payable public owner;\r\n    \r\n    address payable public newOwner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    \r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _trasnferOwnership(msg.sender);\r\n    }\r\n    \r\n    function _trasnferOwnership(address payable _whom) internal {\r\n        emit OwnershipTransferred(owner,_whom);\r\n        owner = _whom;\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address payable _newOwner)\r\n        external\r\n        virtual\r\n        notZeroAddress(_newOwner)\r\n        onlyOwner\r\n    {\r\n        // emit OwnershipTransferred(owner, newOwner);\r\n        newOwner = _newOwner;\r\n    }\r\n    \r\n    function acceptOwnership() external\r\n        virtual\r\n        returns (bool){\r\n            require(msg.sender == newOwner,\"ERR_ONLY_NEW_OWNER\");\r\n            owner = newOwner;\r\n            emit OwnershipTransferred(owner, newOwner);\r\n            newOwner = address(0);\r\n            return true;\r\n        }\r\n    \r\n    \r\n}\r\n\r\n// File: contracts/MerkleDrop.sol\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\ncontract TokenVault {\r\n    address public owner;\r\n    address public token;\r\n\r\n    constructor(address _owner, address _token) public {\r\n        owner = _owner;\r\n        token = _token;\r\n    }\r\n     /**\r\n     * @dev transfers token to 'whom' address with 'amount'.\r\n     */\r\n    function transferToken(address _whom, uint256 _amount)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(msg.sender == owner, \"caller should be owner\");\r\n        safeTransfer(_whom, _amount);\r\n        return true;\r\n    }\r\n\r\n    function safeTransfer(address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))),\"TransferHelper: TRANSFER_FAILED\" );\r\n    }\r\n}\r\n\r\nabstract contract MerkleDropStorage {\r\n    \r\n    /**\r\n     *  airdropCreator - token airdropCreator\r\n     * 'tokenAddress '  - token's contract address\r\n     *  'amount' - amount of tokens to be airdropped\r\n     *  'rootHash' -  merkle root hash\r\n     *  'airdropDate' - airdrop creation date\r\n     *  'airdropExpirationDate'- token's airdrop Exipration Date\r\n     */\r\n    struct MerkleAirDrop {\r\n        address airdropCreator; \r\n        address tokenAddress; \r\n        bytes32 rootHash; \r\n        uint256 amount; \r\n        uint256 airdropStartDate; \r\n        uint256 airdropExpirationDate;\r\n       \r\n    }\r\n    \r\n    //Events\r\n    event AirDropSubmitted(\r\n        address indexed _airdropCreator,\r\n        address indexed _token,\r\n        uint256 _amount,\r\n        uint256 _airdropDate,\r\n        uint256 _airdropExpirationDate\r\n    );\r\n\r\n    event Claimed(address indexed account, uint256 amount, address vault);\r\n\r\n    //Mapping\r\n    mapping(address => MerkleAirDrop) public airdroppedtokens;\r\n    mapping(address => mapping(uint256 => bool)) public claimedMap;\r\n    mapping(bytes32 => address) public vaultAddress;\r\n    \r\n}\r\n\r\ncontract MerkleDrop is MerkleDropStorage,SafeMath,Ownable {\r\n    using MerkleProof for bytes32[];\r\n    \r\n    address public tokenAddress;\r\n    \r\n    uint256 public feeInToken;\r\n    \r\n    uint256 public feeInEth;\r\n    \r\n    address public walletAddress;\r\n    \r\n    constructor(address _token,uint256 _feeToken,uint256 _feeEth,address _walletAddress)public{\r\n        tokenAddress = _token;\r\n        feeInToken = _feeToken;\r\n        feeInEth = _feeEth;\r\n        walletAddress = _walletAddress;\r\n    }\r\n    \r\n    //To perform safe transfer of token\r\n    function safeTransferFrom(\r\n        address _token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))),\"TransferHelper: TRANSFER_FROM_FAILED\");\r\n    }\r\n    \r\n    /**\r\n     * @dev creates token airdrop.\r\n     * \r\n     * @param\r\n     * ' _token '  - token's contract address\r\n     *  ' _amount' - amount of tokens to be airdropped\r\n     *  '_root' -  merkle root hash\r\n     *  '_airdropStartDate' airdrop start date\r\n     *  '_airdropExpirationDate'- token's airdrop Exipration Date\r\n     *  '_paymentInToken' - pay in tokens\r\n     */\r\n    function createAirDrop(\r\n        address _token, \r\n        uint256 _amount, \r\n        bytes32 _root, \r\n        uint256  _airdropStartDate,\r\n        uint256 _airdropExpirationDate,\r\n        bool _paymentInToken\r\n    ) external payable returns (bool) {\r\n        if(_paymentInToken){\r\n            IERC20(tokenAddress).transferFrom(msg.sender,walletAddress,feeInToken);\r\n        }\r\n        else{\r\n            (bool success,) = walletAddress.call{value:feeInEth}(new bytes(0));\r\n            require(success,\"ERR_TRANSFER_FAILED\");\r\n        }\r\n        require(vaultAddress[_root] == address(0),\"ERR_HASH_ALREADY_CREATED\");\r\n        TokenVault vault = new TokenVault(address(this), _token);\r\n        safeTransferFrom(_token, msg.sender, address(vault), _amount);\r\n        MerkleAirDrop memory merkledrop = MerkleAirDrop(msg.sender,_token, _root,_amount,_airdropStartDate,_airdropExpirationDate);\r\n        airdroppedtokens[address(vault)] = merkledrop;\r\n        vaultAddress[_root] = address(vault);\r\n        emit AirDropSubmitted(msg.sender,_token,_amount,now,_airdropExpirationDate);\r\n        return true;\r\n    }\r\n\r\n    //To set token fee \r\n    function setTokenFee(uint256 _fee) external onlyOwner(){\r\n        feeInToken = _fee;\r\n    }\r\n    \r\n    //To set eth fee\r\n    function setEthFee(uint256 _fee) external onlyOwner(){\r\n        feeInEth = _fee;\r\n    }\r\n    \r\n    //To set walletAddress\r\n    function setWalletAddress(address _walletAddress)external onlyOwner(){\r\n        walletAddress = _walletAddress;\r\n    }\r\n    \r\n     /**\r\n     * @dev to claim the airdropped tokens.\r\n     * \r\n     *  @param\r\n     * ' _hex'  - hex bytes\r\n     *  ' _proof' - merkle proof\r\n     *  'index' - address index\r\n     *  '_amount' -  amount of token to be claimed\r\n     */\r\n    function claim(\r\n        bytes32[] memory _hex,\r\n        bytes32[][] memory _proof,\r\n        uint256[] memory index,\r\n        uint256[] memory amount\r\n    ) external returns (bool) {\r\n        address _userAddress = msg.sender;\r\n        for (uint256 i = 0; i < _hex.length; i++) {\r\n            address vault = vaultAddress[_hex[i]];\r\n            MerkleAirDrop memory merkledrop = airdroppedtokens[vault];\r\n            require(now > merkledrop.airdropStartDate ,\"ERR_AIRDROP_NOT_STARTED\");\r\n            require(merkledrop.airdropExpirationDate > now,\"ERR_AIRDROP_HAS_EXPIRED\");\r\n            require(!claimedMap[vault][index[i]],\"ERR_AIRDROP_ALREADY_CLAIMED\");\r\n            bytes32 root = merkledrop.rootHash;\r\n            bytes32 node = keccak256(abi.encodePacked(index[i], _userAddress, amount[i]));\r\n            bytes32[] memory proof = _proof[i];\r\n            if (MerkleProof.verify(proof, root, node)){\r\n                TokenVault(vault).transferToken(msg.sender,amount[i]);\r\n                claimedMap[vault][index[i]] = true;\r\n                emit Claimed(msg.sender, amount[i],vault);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n     /**\r\n     * @dev to send the airdropped tokens back to AirDropper.\r\n     * \r\n     *  @param\r\n     * ' _vault'  - vault Address\r\n     */\r\n    function sendTokenBackToAirDropperByVault(address _vault) external returns (bool) {\r\n        MerkleAirDrop memory merkledrop = airdroppedtokens[_vault];\r\n        require(merkledrop.airdropCreator == msg.sender, \"ERR_NOT_AUTHORIZED\");\r\n        require(merkledrop.airdropExpirationDate < now, \"ERR_TOKEN_AIRDROP_HASNOT_EXPIRED\");\r\n        TokenVault(_vault).transferToken(merkledrop.airdropCreator,IERC20(TokenVault(_vault).token()).balanceOf(_vault));\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev to send the airdropped tokens back to AirDropper.\r\n     * \r\n     *  @param\r\n     * ' _hex'  - hex bytes\r\n     */\r\n    function sendTokenBackToAirDropperByHex(bytes32 _hex) external returns (bool) {\r\n        address _vault = vaultAddress[_hex];\r\n        MerkleAirDrop memory merkledrop = airdroppedtokens[_vault];\r\n        require(merkledrop.airdropCreator == msg.sender, \"ERR_NOT_AUTHORIZED\");\r\n        require(merkledrop.airdropExpirationDate < now, \"ERR_TOKEN_AIRDROP_HASNOT_EXPIRED\");\r\n        TokenVault(_vault).transferToken(merkledrop.airdropCreator,IERC20(TokenVault(_vault).token()).balanceOf(_vault));\r\n        return true;\r\n    }\r\n    \r\n    fallback() external payable {\r\n        revert();\r\n    }\r\n\r\n    receive() external payable {\r\n        revert();\r\n    }  \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeEth\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_walletAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_airdropCreator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_airdropDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_airdropExpirationDate\",\"type\":\"uint256\"}],\"name\":\"AirDropSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"airdroppedtokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"airdropCreator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdropStartDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdropExpirationDate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_hex\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"_proof\",\"type\":\"bytes32[][]\"},{\"internalType\":\"uint256[]\",\"name\":\"index\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimedMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_airdropStartDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_airdropExpirationDate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_paymentInToken\",\"type\":\"bool\"}],\"name\":\"createAirDrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeInEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeInToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hex\",\"type\":\"bytes32\"}],\"name\":\"sendTokenBackToAirDropperByHex\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"sendTokenBackToAirDropperByVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setEthFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setTokenFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_walletAddress\",\"type\":\"address\"}],\"name\":\"setWalletAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"vaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MerkleDrop","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000605cc9088882C549f40CE093cb90eB0319b6676d0000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000b1a2bc2ec50000000000000000000000000000284F214Df3F85526A910979F52C96e54fB228136","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://97bae49851158c654589b0e3b10eb9b936247f7586023609b49b05992dc998f1"}]}