{"status":"1","message":"OK","result":[{"SourceCode":"// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/saviours/NativeUnderlyingUniswapV2SafeSaviour.sol\npragma solidity =0.6.7 >=0.6.0 <0.8.0 >=0.6.7 <0.7.0;\n\n////// src/interfaces/CoinJoinLike.sol\n/* pragma solidity 0.6.7; */\n\nabstract contract CoinJoinLike {\n    function systemCoin() virtual public view returns (address);\n    function safeEngine() virtual public view returns (address);\n    function join(address, uint256) virtual external;\n}\n\n////// src/interfaces/CollateralJoinLike.sol\n/* pragma solidity ^0.6.7; */\n\nabstract contract CollateralJoinLike {\n    function safeEngine() virtual public view returns (address);\n    function collateralType() virtual public view returns (bytes32);\n    function collateral() virtual public view returns (address);\n    function decimals() virtual public view returns (uint256);\n    function contractEnabled() virtual public view returns (uint256);\n    function join(address, uint256) virtual external;\n}\n\n////// src/interfaces/ERC20Like.sol\n/* pragma solidity ^0.6.7; */\n\nabstract contract ERC20Like {\n    function approve(address guy, uint wad) virtual public returns (bool);\n    function transfer(address dst, uint wad) virtual public returns (bool);\n    function balanceOf(address) virtual external view returns (uint256);\n    function transferFrom(address src, address dst, uint wad)\n        virtual\n        public\n        returns (bool);\n}\n\n////// src/interfaces/GebSafeManagerLike.sol\n/* pragma solidity ^0.6.7; */\n\nabstract contract GebSafeManagerLike {\n    function safes(uint256) virtual public view returns (address);\n    function ownsSAFE(uint256) virtual public view returns (address);\n    function safeCan(address,uint256,address) virtual public view returns (uint256);\n}\n\n////// src/interfaces/LiquidationEngineLike.sol\n/* pragma solidity ^0.6.7; */\n\nabstract contract LiquidationEngineLike_3 {\n    function safeSaviours(address) virtual public view returns (uint256);\n}\n\n////// src/interfaces/OracleRelayerLike.sol\n/* pragma solidity ^0.6.7; */\n\nabstract contract OracleRelayerLike_2 {\n    function collateralTypes(bytes32) virtual public view returns (address, uint256, uint256);\n    function liquidationCRatio(bytes32) virtual public view returns (uint256);\n    function redemptionPrice() virtual public returns (uint256);\n}\n\n////// src/interfaces/PriceFeedLike.sol\n/* pragma solidity ^0.6.7; */\n\nabstract contract PriceFeedLike {\n    function priceSource() virtual public view returns (address);\n    function read() virtual public view returns (uint256);\n    function getResultWithValidity() virtual external view returns (uint256,bool);\n}\n\n////// src/interfaces/SAFEEngineLike.sol\n/* pragma solidity ^0.6.7; */\n\nabstract contract SAFEEngineLike_8 {\n    function approveSAFEModification(address) virtual external;\n    function safeRights(address,address) virtual public view returns (uint256);\n    function collateralTypes(bytes32) virtual public view returns (\n        uint256 debtAmount,        // [wad]\n        uint256 accumulatedRate,   // [ray]\n        uint256 safetyPrice,       // [ray]\n        uint256 debtCeiling,       // [rad]\n        uint256 debtFloor,         // [rad]\n        uint256 liquidationPrice   // [ray]\n    );\n    function safes(bytes32,address) virtual public view returns (\n        uint256 lockedCollateral,  // [wad]\n        uint256 generatedDebt      // [wad]\n    );\n    function modifySAFECollateralization(\n        bytes32 collateralType,\n        address safe,\n        address collateralSource,\n        address debtDestination,\n        int256 deltaCollateral,    // [wad]\n        int256 deltaDebt           // [wad]\n    ) virtual external;\n}\n\n////// src/interfaces/SAFESaviourRegistryLike.sol\n/* pragma solidity ^0.6.7; */\n\nabstract contract SAFESaviourRegistryLike {\n    function markSave(bytes32 collateralType, address safeHandler) virtual external;\n}\n\n////// src/interfaces/TaxCollectorLike.sol\n/* pragma solidity 0.6.7; */\n\nabstract contract TaxCollectorLike {\n    function taxSingle(bytes32) public virtual returns (uint256);\n}\n\n////// src/utils/ReentrancyGuard.sol\n// SPDX-License-Identifier: MIT\n\n/* pragma solidity >=0.6.0 <0.8.0; */\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n////// src/interfaces/SafeSaviourLike.sol\n// Copyright (C) 2020 Reflexer Labs, INC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity ^0.6.7; */\n\n/* import \"./CollateralJoinLike.sol\"; */\n/* import \"./CoinJoinLike.sol\"; */\n/* import \"./OracleRelayerLike.sol\"; */\n/* import \"./SAFEEngineLike.sol\"; */\n/* import \"./LiquidationEngineLike.sol\"; */\n/* import \"./PriceFeedLike.sol\"; */\n/* import \"./ERC20Like.sol\"; */\n/* import \"./GebSafeManagerLike.sol\"; */\n/* import \"./TaxCollectorLike.sol\"; */\n/* import \"./SAFESaviourRegistryLike.sol\"; */\n\n/* import \"../utils/ReentrancyGuard.sol\"; */\n\nabstract contract SafeSaviourLike is ReentrancyGuard {\n    // Checks whether a saviour contract has been approved by governance in the LiquidationEngine\n    modifier liquidationEngineApproved(address saviour) {\n        require(liquidationEngine.safeSaviours(saviour) == 1, \"SafeSaviour/not-approved-in-liquidation-engine\");\n        _;\n    }\n    // Checks whether someone controls a safe handler inside the GebSafeManager\n    modifier controlsSAFE(address owner, uint256 safeID) {\n        require(owner != address(0), \"SafeSaviour/null-owner\");\n        require(either(owner == safeManager.ownsSAFE(safeID), safeManager.safeCan(safeManager.ownsSAFE(safeID), safeID, owner) == 1), \"SafeSaviour/not-owning-safe\");\n\n        _;\n    }\n\n    // --- Variables ---\n    LiquidationEngineLike_3   public liquidationEngine;\n    TaxCollectorLike        public taxCollector;\n    OracleRelayerLike_2       public oracleRelayer;\n    GebSafeManagerLike      public safeManager;\n    SAFEEngineLike_8          public safeEngine;\n    SAFESaviourRegistryLike public saviourRegistry;\n\n    // The amount of tokens the keeper gets in exchange for the gas spent to save a SAFE\n    uint256 public keeperPayout;          // [wad]\n    // The minimum fiat value that the keeper must get in exchange for saving a SAFE\n    uint256 public minKeeperPayoutValue;  // [wad]\n    /*\n      The proportion between the keeperPayout (if it's in collateral) and the amount of collateral or debt that's in a SAFE to be saved.\n      Alternatively, it can be the proportion between the fiat value of keeperPayout and the fiat value of the profit that a keeper\n      could make if a SAFE is liquidated right now. It ensures there's no incentive to intentionally put a SAFE underwater and then\n      save it just to make a profit that's greater than the one from participating in collateral auctions\n    */\n    uint256 public payoutToSAFESize;\n\n    // --- Constants ---\n    uint256 public constant ONE               = 1;\n    uint256 public constant HUNDRED           = 100;\n    uint256 public constant THOUSAND          = 1000;\n    uint256 public constant WAD_COMPLEMENT    = 10**9;\n    uint256 public constant WAD               = 10**18;\n    uint256 public constant RAY               = 10**27;\n    uint256 public constant MAX_UINT          = uint(-1);\n\n    // --- Boolean Logic ---\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y) }\n    }\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n\n    // --- Events ---\n    event SaveSAFE(address indexed keeper, bytes32 indexed collateralType, address indexed safeHandler, uint256 collateralAddedOrDebtRepaid);\n\n    // --- Functions to Implement ---\n    function saveSAFE(address,bytes32,address) virtual external returns (bool,uint256,uint256);\n    function getKeeperPayoutValue() virtual public returns (uint256);\n    function keeperPayoutExceedsMinValue() virtual public returns (bool);\n    function canSave(bytes32,address) virtual external returns (bool);\n    function tokenAmountUsedToSave(bytes32,address) virtual public returns (uint256);\n}\n\n////// src/interfaces/SaviourCRatioSetterLike.sol\n/* pragma solidity 0.6.7; */\n\n/* import \"./OracleRelayerLike.sol\"; */\n/* import \"./GebSafeManagerLike.sol\"; */\n\n/* import \"../utils/ReentrancyGuard.sol\"; */\n\nabstract contract SaviourCRatioSetterLike is ReentrancyGuard {\n    // --- Auth ---\n    mapping (address => uint256) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"SaviourCRatioSetter/account-not-authorized\");\n        _;\n    }\n\n    // Checks whether someone controls a safe handler inside the GebSafeManager\n    modifier controlsSAFE(address owner, uint256 safeID) {\n        require(owner != address(0), \"SaviourCRatioSetter/null-owner\");\n        require(either(owner == safeManager.ownsSAFE(safeID), safeManager.safeCan(safeManager.ownsSAFE(safeID), safeID, owner) == 1), \"SaviourCRatioSetter/not-owning-safe\");\n\n        _;\n    }\n\n    // --- Variables ---\n    OracleRelayerLike_2  public oracleRelayer;\n    GebSafeManagerLike public safeManager;\n\n    // Default desired cratio for each individual collateral type\n    mapping(bytes32 => uint256)                     public defaultDesiredCollateralizationRatios;\n    // Minimum bound for the desired cratio for each collateral type\n    mapping(bytes32 => uint256)                     public minDesiredCollateralizationRatios;\n    // Desired CRatios for each SAFE after they're saved\n    mapping(bytes32 => mapping(address => uint256)) public desiredCollateralizationRatios;\n\n    // --- Constants ---\n    uint256 public constant MAX_CRATIO        = 1000;\n    uint256 public constant CRATIO_SCALE_DOWN = 10**25;\n\n    // --- Boolean Logic ---\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y) }\n    }\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 indexed parameter, address data);\n    event SetDefaultCRatio(bytes32 indexed collateralType, uint256 cRatio);\n    event SetMinDesiredCollateralizationRatio(\n      bytes32 indexed collateralType,\n      uint256 cRatio\n    );\n    event SetDesiredCollateralizationRatio(\n      address indexed caller,\n      bytes32 indexed collateralType,\n      uint256 safeID,\n      address indexed safeHandler,\n      uint256 cRatio\n    );\n\n    // --- Functions ---\n    function setDefaultCRatio(bytes32, uint256) virtual external;\n    function setMinDesiredCollateralizationRatio(bytes32 collateralType, uint256 cRatio) virtual external;\n    function setDesiredCollateralizationRatio(bytes32 collateralType, uint256 safeID, uint256 cRatio) virtual external;\n}\n\n////// src/interfaces/UniswapLiquidityManagerLike.sol\n/* pragma solidity 0.6.7; */\n\nabstract contract UniswapLiquidityManagerLike {\n    function getToken0FromLiquidity(uint256) virtual public view returns (uint256);\n    function getToken1FromLiquidity(uint256) virtual public view returns (uint256);\n\n    function getLiquidityFromToken0(uint256) virtual public view returns (uint256);\n    function getLiquidityFromToken1(uint256) virtual public view returns (uint256);\n\n    function removeLiquidity(\n      uint256 liquidity,\n      uint128 amount0Min,\n      uint128 amount1Min,\n      address to\n    ) public virtual returns (uint256, uint256);\n}\n\n////// src/math/SafeMath.sol\n// SPDX-License-Identifier: MIT\n\n/* pragma solidity >=0.6.0 <0.8.0; */\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\ncontract SafeMath_2 {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n////// src/saviours/NativeUnderlyingUniswapV2SafeSaviour.sol\n// Copyright (C) 2021 Reflexer Labs, INC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity 0.6.7; */\n\n/* import \"../interfaces/UniswapLiquidityManagerLike.sol\"; */\n/* import \"../interfaces/SaviourCRatioSetterLike.sol\"; */\n/* import \"../interfaces/SafeSaviourLike.sol\"; */\n/* import \"../math/SafeMath.sol\"; */\n\ncontract NativeUnderlyingUniswapV2SafeSaviour is SafeMath_2, SafeSaviourLike {\n    // --- Auth ---\n    mapping (address => uint256) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"NativeUnderlyingUniswapV2SafeSaviour/account-not-authorized\");\n        _;\n    }\n\n    mapping (address => uint256) public allowedUsers;\n    /**\n     * @notice Allow a user to deposit assets\n     * @param usr User to whitelist\n     */\n    function allowUser(address usr) external isAuthorized {\n        allowedUsers[usr] = 1;\n        emit AllowUser(usr);\n    }\n    /**\n     * @notice Disallow a user from depositing assets\n     * @param usr User to disallow\n     */\n    function disallowUser(address usr) external isAuthorized {\n        allowedUsers[usr] = 0;\n        emit DisallowUser(usr);\n    }\n    /**\n    * @notice Checks whether an address is an allowed user\n    **/\n    modifier isAllowed {\n        require(\n          either(restrictUsage == 0, both(restrictUsage == 1, allowedUsers[msg.sender] == 1)),\n          \"NativeUnderlyingUniswapV2SafeSaviour/account-not-allowed\"\n        );\n        _;\n    }\n\n    // --- Structs ---\n    struct Reserves {\n        uint256 systemCoins;\n        uint256 collateralCoins;\n    }\n\n    // --- Variables ---\n    // Flag that tells whether usage of the contract is restricted to allowed users\n    uint256                        public restrictUsage;\n\n    // Whether the system coin is token0 in the Uniswap pool or not\n    bool                           public isSystemCoinToken0;\n    // Amount of LP tokens currently protecting each position\n    mapping(address => uint256)    public lpTokenCover;\n    // Amount of system coin/collateral tokens that Safe owners can get back\n    mapping(address => Reserves)   public underlyingReserves;\n    // Liquidity manager contract for Uniswap v2/v3\n    UniswapLiquidityManagerLike    public liquidityManager;\n    // The ERC20 system coin\n    ERC20Like                      public systemCoin;\n    // The system coin join contract\n    CoinJoinLike                   public coinJoin;\n    // The collateral join contract for adding collateral in the system\n    CollateralJoinLike             public collateralJoin;\n    // The LP token\n    ERC20Like                      public lpToken;\n    // The collateral token\n    ERC20Like                      public collateralToken;\n    // Oracle providing the system coin price feed\n    PriceFeedLike                  public systemCoinOrcl;\n    // Contract that defines desired CRatios for each Safe after it is saved\n    SaviourCRatioSetterLike        public cRatioSetter;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event AllowUser(address usr);\n    event DisallowUser(address usr);\n    event ModifyParameters(bytes32 indexed parameter, uint256 val);\n    event ModifyParameters(bytes32 indexed parameter, address data);\n    event Deposit(\n      address indexed caller,\n      address indexed safeHandler,\n      uint256 lpTokenAmount\n    );\n    event Withdraw(\n      address indexed caller,\n      address indexed safeHandler,\n      address dst,\n      uint256 lpTokenAmount\n    );\n    event GetReserves(\n      address indexed caller,\n      address indexed safeHandler,\n      uint256 systemCoinAmount,\n      uint256 collateralAmount,\n      address dst\n    );\n\n    constructor(\n        bool isSystemCoinToken0_,\n        address coinJoin_,\n        address collateralJoin_,\n        address cRatioSetter_,\n        address systemCoinOrcl_,\n        address liquidationEngine_,\n        address taxCollector_,\n        address oracleRelayer_,\n        address safeManager_,\n        address saviourRegistry_,\n        address liquidityManager_,\n        address lpToken_,\n        uint256 minKeeperPayoutValue_\n    ) public {\n        require(coinJoin_ != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-coin-join\");\n        require(collateralJoin_ != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-collateral-join\");\n        require(cRatioSetter_ != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-cratio-setter\");\n        require(systemCoinOrcl_ != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-system-coin-oracle\");\n        require(oracleRelayer_ != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-oracle-relayer\");\n        require(liquidationEngine_ != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-liquidation-engine\");\n        require(taxCollector_ != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-tax-collector\");\n        require(safeManager_ != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-safe-manager\");\n        require(saviourRegistry_ != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-saviour-registry\");\n        require(liquidityManager_ != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-liq-manager\");\n        require(lpToken_ != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-lp-token\");\n        require(minKeeperPayoutValue_ > 0, \"NativeUnderlyingUniswapV2SafeSaviour/invalid-min-payout-value\");\n\n        authorizedAccounts[msg.sender] = 1;\n\n        isSystemCoinToken0   = isSystemCoinToken0_;\n        minKeeperPayoutValue = minKeeperPayoutValue_;\n\n        coinJoin             = CoinJoinLike(coinJoin_);\n        collateralJoin       = CollateralJoinLike(collateralJoin_);\n        cRatioSetter         = SaviourCRatioSetterLike(cRatioSetter_);\n        liquidationEngine    = LiquidationEngineLike_3(liquidationEngine_);\n        taxCollector         = TaxCollectorLike(taxCollector_);\n        oracleRelayer        = OracleRelayerLike_2(oracleRelayer_);\n        systemCoinOrcl       = PriceFeedLike(systemCoinOrcl_);\n        systemCoin           = ERC20Like(coinJoin.systemCoin());\n        safeEngine           = SAFEEngineLike_8(coinJoin.safeEngine());\n        safeManager          = GebSafeManagerLike(safeManager_);\n        saviourRegistry      = SAFESaviourRegistryLike(saviourRegistry_);\n        liquidityManager     = UniswapLiquidityManagerLike(liquidityManager_);\n        lpToken              = ERC20Like(lpToken_);\n        collateralToken      = ERC20Like(collateralJoin.collateral());\n\n        systemCoinOrcl.getResultWithValidity();\n        oracleRelayer.redemptionPrice();\n\n        require(collateralJoin.contractEnabled() == 1, \"NativeUnderlyingUniswapV2SafeSaviour/join-disabled\");\n        require(address(collateralToken) != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-col-token\");\n        require(address(safeEngine) != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-safe-engine\");\n        require(address(systemCoin) != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-sys-coin\");\n\n        emit AddAuthorization(msg.sender);\n        emit ModifyParameters(\"minKeeperPayoutValue\", minKeeperPayoutValue);\n        emit ModifyParameters(\"oracleRelayer\", oracleRelayer_);\n        emit ModifyParameters(\"taxCollector\", taxCollector_);\n        emit ModifyParameters(\"systemCoinOrcl\", systemCoinOrcl_);\n        emit ModifyParameters(\"liquidationEngine\", liquidationEngine_);\n        emit ModifyParameters(\"liquidityManager\", liquidityManager_);\n    }\n\n    // --- Administration ---\n    /**\n     * @notice Modify an uint256 param\n     * @param parameter The name of the parameter\n     * @param val New value for the parameter\n     */\n    function modifyParameters(bytes32 parameter, uint256 val) external isAuthorized {\n        if (parameter == \"minKeeperPayoutValue\") {\n            require(val > 0, \"NativeUnderlyingUniswapV2SafeSaviour/null-min-payout\");\n            minKeeperPayoutValue = val;\n        }\n        else if (parameter == \"restrictUsage\") {\n            require(val <= 1, \"NativeUnderlyingUniswapV2SafeSaviour/invalid-restriction\");\n            restrictUsage = val;\n        }\n        else revert(\"NativeUnderlyingUniswapV2SafeSaviour/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, val);\n    }\n    /**\n     * @notice Modify an address param\n     * @param parameter The name of the parameter\n     * @param data New address for the parameter\n     */\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        require(data != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-data\");\n\n        if (parameter == \"systemCoinOrcl\") {\n            systemCoinOrcl = PriceFeedLike(data);\n            systemCoinOrcl.getResultWithValidity();\n        }\n        else if (parameter == \"oracleRelayer\") {\n            oracleRelayer = OracleRelayerLike_2(data);\n            oracleRelayer.redemptionPrice();\n        }\n        else if (parameter == \"liquidityManager\") {\n            liquidityManager = UniswapLiquidityManagerLike(data);\n        }\n        else if (parameter == \"liquidationEngine\") {\n            liquidationEngine = LiquidationEngineLike_3(data);\n        }\n        else if (parameter == \"taxCollector\") {\n            taxCollector = TaxCollectorLike(data);\n        }\n        else revert(\"NativeUnderlyingUniswapV2SafeSaviour/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Transferring Reserves ---\n    /*\n    * @notify Get back system coins or collateral tokens that were withdrawn from Uniswap and not used to save a specific SAFE\n    * @param safeID The ID of the safe that was previously saved and has leftover funds that can be withdrawn\n    * @param dst The address that will receive\n    */\n    function getReserves(uint256 safeID, address dst) external controlsSAFE(msg.sender, safeID) nonReentrant {\n        address safeHandler = safeManager.safes(safeID);\n        (uint256 systemCoins, uint256 collateralCoins) =\n          (underlyingReserves[safeHandler].systemCoins, underlyingReserves[safeHandler].collateralCoins);\n\n        require(either(systemCoins > 0, collateralCoins > 0), \"NativeUnderlyingUniswapV2SafeSaviour/no-reserves\");\n        delete(underlyingReserves[safeManager.safes(safeID)]);\n\n        if (systemCoins > 0) {\n          systemCoin.transfer(dst, systemCoins);\n        }\n\n        if (collateralCoins > 0) {\n          collateralToken.transfer(dst, collateralCoins);\n        }\n\n        emit GetReserves(msg.sender, safeHandler, systemCoins, collateralCoins, dst);\n    }\n\n    // --- Adding/Withdrawing Cover ---\n    /*\n    * @notice Deposit lpToken in the contract in order to provide cover for a specific SAFE managed by the SAFE Manager\n    * @param safeID The ID of the SAFE to protect. This ID should be registered inside GebSafeManager\n    * @param lpTokenAmount The amount of collateralToken to deposit\n    */\n    function deposit(uint256 safeID, uint256 lpTokenAmount) external isAllowed() liquidationEngineApproved(address(this)) nonReentrant {\n        require(lpTokenAmount > 0, \"NativeUnderlyingUniswapV2SafeSaviour/null-lp-amount\");\n\n        // Check that the SAFE exists inside GebSafeManager\n        address safeHandler = safeManager.safes(safeID);\n        require(safeHandler != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-handler\");\n\n        // Check that the SAFE has debt\n        (, uint256 safeDebt) =\n          SAFEEngineLike_8(collateralJoin.safeEngine()).safes(collateralJoin.collateralType(), safeHandler);\n        require(safeDebt > 0, \"NativeUnderlyingUniswapV2SafeSaviour/safe-does-not-have-debt\");\n\n        // Update the lpToken balance used to cover the SAFE and transfer tokens to this contract\n        lpTokenCover[safeHandler] = add(lpTokenCover[safeHandler], lpTokenAmount);\n        require(lpToken.transferFrom(msg.sender, address(this), lpTokenAmount), \"NativeUnderlyingUniswapV2SafeSaviour/could-not-transfer-lp\");\n\n        emit Deposit(msg.sender, safeHandler, lpTokenAmount);\n    }\n    /*\n    * @notice Withdraw lpToken from the contract and provide less cover for a SAFE\n    * @dev Only an address that controls the SAFE inside the SAFE Manager can call this\n    * @param safeID The ID of the SAFE to remove cover from. This ID should be registered inside the SAFE Manager\n    * @param lpTokenAmount The amount of lpToken to withdraw\n    * @param dst The address that will receive the LP tokens\n    */\n    function withdraw(uint256 safeID, uint256 lpTokenAmount, address dst) external controlsSAFE(msg.sender, safeID) nonReentrant {\n        require(lpTokenAmount > 0, \"NativeUnderlyingUniswapV2SafeSaviour/null-lp-amount\");\n\n        // Fetch the handler from the SAFE manager\n        address safeHandler = safeManager.safes(safeID);\n        require(lpTokenCover[safeHandler] >= lpTokenAmount, \"NativeUnderlyingUniswapV2SafeSaviour/not-enough-to-withdraw\");\n\n        // Withdraw cover and transfer collateralToken to the caller\n        lpTokenCover[safeHandler] = sub(lpTokenCover[safeHandler], lpTokenAmount);\n        lpToken.transfer(dst, lpTokenAmount);\n\n        emit Withdraw(msg.sender, safeHandler, dst, lpTokenAmount);\n    }\n\n    // --- Saving Logic ---\n    /*\n    * @notice Saves a SAFE by withdrawing liquidity and repaying debt and/or adding more collateral\n    * @dev Only the LiquidationEngine can call this\n    * @param keeper The keeper that called LiquidationEngine.liquidateSAFE and that should be rewarded for spending gas to save a SAFE\n    * @param collateralType The collateral type backing the SAFE that's being liquidated\n    * @param safeHandler The handler of the SAFE that's being liquidated\n    * @return Whether the SAFE has been saved, the amount of LP tokens that were used to withdraw liquidity as well as the amount of\n    *         system coins sent to the keeper as their payment (this implementation always returns 0)\n    */\n    function saveSAFE(address keeper, bytes32 collateralType, address safeHandler) override external returns (bool, uint256, uint256) {\n        require(address(liquidationEngine) == msg.sender, \"NativeUnderlyingUniswapV2SafeSaviour/caller-not-liquidation-engine\");\n        require(keeper != address(0), \"NativeUnderlyingUniswapV2SafeSaviour/null-keeper-address\");\n\n        if (both(both(collateralType == \"\", safeHandler == address(0)), keeper == address(liquidationEngine))) {\n            return (true, uint(-1), uint(-1));\n        }\n\n        // Check that this is handling the correct collateral\n        require(collateralType == collateralJoin.collateralType(), \"NativeUnderlyingUniswapV2SafeSaviour/invalid-collateral-type\");\n\n        // Check that the SAFE has a non null amount of LP tokens covering it\n        require(lpTokenCover[safeHandler] > 0, \"NativeUnderlyingUniswapV2SafeSaviour/null-cover\");\n\n        // Tax the collateral\n        taxCollector.taxSingle(collateralType);\n\n        // Get the amount of tokens used to top up the SAFE\n        (uint256 safeDebtRepaid, uint256 safeCollateralAdded) =\n          getTokensForSaving(safeHandler, oracleRelayer.redemptionPrice());\n\n        // There must be tokens used to save the SAVE\n        require(either(safeDebtRepaid > 0, safeCollateralAdded > 0), \"NativeUnderlyingUniswapV2SafeSaviour/cannot-save-safe\");\n\n        // Get the amounts of tokens sent to the keeper as payment\n        (uint256 keeperSysCoins, uint256 keeperCollateralCoins) =\n          getKeeperPayoutTokens(safeHandler, oracleRelayer.redemptionPrice(), safeDebtRepaid, safeCollateralAdded);\n\n        // There must be tokens that go to the keeper\n        require(either(keeperSysCoins > 0, keeperCollateralCoins > 0), \"NativeUnderlyingUniswapV2SafeSaviour/cannot-pay-keeper\");\n\n        // Store cover amount in local var\n        uint256 totalCover = lpTokenCover[safeHandler];\n        delete(lpTokenCover[safeHandler]);\n\n        // Mark the SAFE in the registry as just having been saved\n        saviourRegistry.markSave(collateralType, safeHandler);\n\n        // Withdraw all liquidity\n        uint256 sysCoinBalance        = systemCoin.balanceOf(address(this));\n        uint256 collateralCoinBalance = collateralToken.balanceOf(address(this));\n\n        lpToken.approve(address(liquidityManager), totalCover);\n        liquidityManager.removeLiquidity(totalCover, 0, 0, address(this));\n\n        // Checks after removing liquidity\n        require(\n          either(systemCoin.balanceOf(address(this)) > sysCoinBalance, collateralToken.balanceOf(address(this)) > collateralCoinBalance),\n          \"NativeUnderlyingUniswapV2SafeSaviour/faulty-remove-liquidity\"\n        );\n\n        // Compute remaining balances of tokens that will go into reserves\n        sysCoinBalance        = sub(sub(systemCoin.balanceOf(address(this)), sysCoinBalance), add(safeDebtRepaid, keeperSysCoins));\n        collateralCoinBalance = sub(\n          sub(collateralToken.balanceOf(address(this)), collateralCoinBalance), add(safeCollateralAdded, keeperCollateralCoins)\n        );\n\n        // Update reserves\n        if (sysCoinBalance > 0) {\n          underlyingReserves[safeHandler].systemCoins = add(\n            underlyingReserves[safeHandler].systemCoins, sysCoinBalance\n          );\n        }\n        if (collateralCoinBalance > 0) {\n          underlyingReserves[safeHandler].collateralCoins = add(\n            underlyingReserves[safeHandler].collateralCoins, collateralCoinBalance\n          );\n        }\n\n        // Save the SAFE\n        if (safeDebtRepaid > 0) {\n          // Approve the coin join contract to take system coins and repay debt\n          systemCoin.approve(address(coinJoin), safeDebtRepaid);\n          // Calculate the non adjusted system coin amount\n          uint256 nonAdjustedSystemCoinsToRepay = div(mul(safeDebtRepaid, RAY), getAccumulatedRate(collateralType));\n\n          // Join system coins in the system and repay the SAFE's debt\n          coinJoin.join(address(this), safeDebtRepaid);\n          safeEngine.modifySAFECollateralization(\n            collateralType,\n            safeHandler,\n            address(0),\n            address(this),\n            int256(0),\n            -int256(nonAdjustedSystemCoinsToRepay)\n          );\n        }\n\n        if (safeCollateralAdded > 0) {\n          // Approve collateralToken to the collateral join contract\n          collateralToken.approve(address(collateralJoin), safeCollateralAdded);\n\n          // Join collateralToken in the system and add it in the saved SAFE\n          collateralJoin.join(address(this), safeCollateralAdded);\n          safeEngine.modifySAFECollateralization(\n            collateralType,\n            safeHandler,\n            address(this),\n            address(0),\n            int256(safeCollateralAdded),\n            int256(0)\n          );\n        }\n\n        // Pay keeper\n        if (keeperSysCoins > 0) {\n          systemCoin.transfer(keeper, keeperSysCoins);\n        }\n\n        if (keeperCollateralCoins > 0) {\n          collateralToken.transfer(keeper, keeperCollateralCoins);\n        }\n\n        // Emit an event\n        emit SaveSAFE(keeper, collateralType, safeHandler, totalCover);\n\n        return (true, totalCover, 0);\n    }\n\n    // --- Getters ---\n    /*\n    * @notify Must be implemented according to the interface although it always returns 0\n    */\n    function getKeeperPayoutValue() override public returns (uint256) {\n        return 0;\n    }\n    /*\n    * @notify Must be implemented according to the interface although it always returns false\n    */\n    function keeperPayoutExceedsMinValue() override public returns (bool) {\n        return false;\n    }\n    /*\n    * @notice Determine whether a SAFE can be saved with the current amount of lpTokenCover deposited as cover for it\n    * @param safeHandler The handler of the SAFE which the function takes into account\n    * @return Whether the SAFE can be saved or not\n    */\n    function canSave(bytes32, address safeHandler) override external returns (bool) {\n        // Fetch the redemption price first\n        uint256 redemptionPrice = oracleRelayer.redemptionPrice();\n\n        // Fetch the amount of tokens used to save the SAFE\n        (uint256 safeDebtRepaid, uint256 safeCollateralAdded) =\n          getTokensForSaving(safeHandler, redemptionPrice);\n\n        // Fetch the amount of tokens sent to the keeper\n        (uint256 keeperSysCoins, uint256 keeperCollateralCoins) =\n          getKeeperPayoutTokens(safeHandler, redemptionPrice, safeDebtRepaid, safeCollateralAdded);\n\n        // If there are some tokens used to save the SAFE and some tokens used to repay the keeper, return true\n        if (both(\n          either(safeDebtRepaid > 0, safeCollateralAdded > 0),\n          either(keeperSysCoins > 0, keeperCollateralCoins > 0)\n        )) {\n          return true;\n        }\n\n        return false;\n    }\n    /*\n    * @notice Return the total amount of LP tokens covering a specific SAFE\n    * @param collateralType The SAFE collateral type (ignored in this implementation)\n    * @param safeHandler The handler of the SAFE which the function takes into account\n    * @return The total LP token cover for a specific SAFE\n    */\n    function tokenAmountUsedToSave(bytes32, address safeHandler) override public returns (uint256) {\n        return lpTokenCover[safeHandler];\n    }\n    /*\n    * @notify Fetch the collateral's price\n    */\n    function getCollateralPrice() public view returns (uint256) {\n        (address ethFSM,,) = oracleRelayer.collateralTypes(collateralJoin.collateralType());\n        if (ethFSM == address(0)) return 0;\n\n        (uint256 priceFeedValue, bool hasValidValue) = PriceFeedLike(ethFSM).getResultWithValidity();\n        if (!hasValidValue) return 0;\n\n        return priceFeedValue;\n    }\n    /*\n    * @notify Fetch the system coin's market price\n    */\n    function getSystemCoinMarketPrice() public view returns (uint256) {\n        (uint256 priceFeedValue, bool hasValidValue) = systemCoinOrcl.getResultWithValidity();\n        if (!hasValidValue) return 0;\n\n        return priceFeedValue;\n    }\n    /*\n    * @notify Get the target collateralization ratio that a SAFE should have after it's saved\n    * @param safeHandler The handler/address of the SAFE whose target collateralization ratio is retrieved\n    */\n    function getTargetCRatio(address safeHandler) public view returns (uint256) {\n        bytes32 collateralType = collateralJoin.collateralType();\n        uint256 defaultCRatio  = cRatioSetter.defaultDesiredCollateralizationRatios(collateralType);\n        uint256 targetCRatio   = (cRatioSetter.desiredCollateralizationRatios(collateralType, safeHandler) == 0) ?\n          defaultCRatio : cRatioSetter.desiredCollateralizationRatios(collateralType, safeHandler);\n        return targetCRatio;\n    }\n    /*\n    * @notify Return the amount of system coins and collateral tokens retrieved from the LP position covering a specific SAFE\n    * @param safeHandler The handler/address of the targeted SAFE\n    */\n    function getLPUnderlying(address safeHandler) public view returns (uint256, uint256) {\n        uint256 coverAmount = lpTokenCover[safeHandler];\n\n        if (coverAmount == 0) return (0, 0);\n\n        (uint256 sysCoinsFromLP, uint256 collateralFromLP) = (isSystemCoinToken0) ?\n          (liquidityManager.getToken0FromLiquidity(coverAmount), liquidityManager.getToken1FromLiquidity(coverAmount)) :\n          (liquidityManager.getToken1FromLiquidity(coverAmount), liquidityManager.getToken0FromLiquidity(coverAmount));\n\n        return (sysCoinsFromLP, collateralFromLP);\n    }\n    /*\n    * @notice Return the amount of system coins and/or collateral tokens used to save a SAFE\n    * @param safeHandler The handler/address of the targeted SAFE\n    * @param redemptionPrice The system coin redemption price used in calculations\n    */\n    function getTokensForSaving(address safeHandler, uint256 redemptionPrice)\n      public view returns (uint256, uint256) {\n        if (either(lpTokenCover[safeHandler] == 0, redemptionPrice == 0)) {\n            return (0, 0);\n        }\n\n        // Get the default CRatio for the SAFE\n        (uint256 depositedCollateralToken, uint256 safeDebt) =\n          SAFEEngineLike_8(collateralJoin.safeEngine()).safes(collateralJoin.collateralType(), safeHandler);\n        uint256 targetCRatio = getTargetCRatio(safeHandler);\n        if (either(safeDebt == 0, targetCRatio == 0)) {\n            return (0, 0);\n        }\n\n        // Get the collateral market price\n        uint256 collateralPrice = getCollateralPrice();\n        if (collateralPrice == 0) {\n            return (0, 0);\n        }\n\n        // Calculate how much debt would need to be repaid\n        uint256 debtToRepay = mul(\n          mul(HUNDRED, mul(depositedCollateralToken, collateralPrice) / WAD) / targetCRatio, RAY\n        ) / redemptionPrice;\n\n        if (either(debtToRepay >= safeDebt, debtBelowFloor(collateralJoin.collateralType(), debtToRepay))) {\n            return (0, 0);\n        }\n        safeDebt    = mul(safeDebt, getAccumulatedRate(collateralJoin.collateralType())) / RAY;\n        debtToRepay = sub(safeDebt, debtToRepay);\n\n        // Calculate underlying amounts received from LP withdrawal\n        (uint256 sysCoinsFromLP, uint256 collateralFromLP) = getLPUnderlying(safeHandler);\n\n        // Determine total debt to repay; return if the SAFE can be saved solely by repaying debt, continue calculations otherwise\n        if (sysCoinsFromLP >= debtToRepay) {\n            return (debtToRepay, 0);\n        } else {\n            // Calculate the amount of collateral that would need to be added to the SAFE\n            uint256 scaledDownDebtValue = mul(add(mul(redemptionPrice, sub(safeDebt, sysCoinsFromLP)) / RAY, ONE), targetCRatio) / HUNDRED;\n\n            uint256 collateralTokenNeeded = div(mul(scaledDownDebtValue, WAD), collateralPrice);\n            collateralTokenNeeded         = (depositedCollateralToken < collateralTokenNeeded) ?\n              sub(collateralTokenNeeded, depositedCollateralToken) : MAX_UINT;\n\n            // See if there's enough collateral to add to the SAFE in order to save it\n            if (collateralTokenNeeded <= collateralFromLP) {\n              return (sysCoinsFromLP, collateralTokenNeeded);\n            } else {\n              return (0, 0);\n            }\n        }\n    }\n    /*\n    * @notice Return the amount of system coins and/or collateral tokens used to pay a keeper\n    * @param safeHandler The handler/address of the targeted SAFE\n    * @param redemptionPrice The system coin redemption price used in calculations\n    * @param safeDebtRepaid The amount of system coins that are already used to save the targeted SAFE\n    * @param safeCollateralAdded The amount of collateral tokens that are already used to save the targeted SAFE\n    */\n    function getKeeperPayoutTokens(address safeHandler, uint256 redemptionPrice, uint256 safeDebtRepaid, uint256 safeCollateralAdded)\n      public view returns (uint256, uint256) {\n        // Get the system coin and collateral market prices\n        uint256 collateralPrice    = getCollateralPrice();\n        uint256 sysCoinMarketPrice = getSystemCoinMarketPrice();\n        if (either(collateralPrice == 0, sysCoinMarketPrice == 0)) {\n            return (0, 0);\n        }\n\n        // Calculate underlying amounts received from LP withdrawal\n        (uint256 sysCoinsFromLP, uint256 collateralFromLP) = getLPUnderlying(safeHandler);\n\n        // Check if the keeper can get system coins and if yes, compute how many\n        uint256 keeperSysCoins;\n        if (sysCoinsFromLP > safeDebtRepaid) {\n            uint256 remainingSystemCoins = sub(sysCoinsFromLP, safeDebtRepaid);\n            uint256 payoutInSystemCoins  = div(mul(minKeeperPayoutValue, WAD), sysCoinMarketPrice);\n\n            if (payoutInSystemCoins <= remainingSystemCoins) {\n              return (payoutInSystemCoins, 0);\n            } else {\n              keeperSysCoins = remainingSystemCoins;\n            }\n        }\n\n        // Calculate how much collateral the keeper will get\n        if (collateralFromLP <= safeCollateralAdded) return (0, 0);\n\n        uint256 remainingCollateral        = sub(collateralFromLP, safeCollateralAdded);\n        uint256 remainingKeeperPayoutValue = sub(minKeeperPayoutValue, mul(keeperSysCoins, sysCoinMarketPrice) / WAD);\n        uint256 collateralTokenNeeded      = div(mul(remainingKeeperPayoutValue, WAD), collateralPrice);\n\n        // If there are enough collateral tokens retreived from LP in order to pay the keeper, return the token amounts\n        if (collateralTokenNeeded <= remainingCollateral) {\n          return (keeperSysCoins, collateralTokenNeeded);\n        } else {\n          // Otherwise, return zeroes\n          return (0, 0);\n        }\n    }\n    /*\n    * @notify Returns whether a target debt amount is below the debt floor of a specific collateral type\n    * @param collateralType The collateral type whose floor we compare against\n    * @param targetDebtAmount The target debt amount for a SAFE that has collateralType collateral in it\n    */\n    function debtBelowFloor(bytes32 collateralType, uint256 targetDebtAmount) public view returns (bool) {\n        (, , , , uint256 debtFloor, ) = safeEngine.collateralTypes(collateralType);\n        return (mul(targetDebtAmount, RAY) < debtFloor);\n    }\n    /*\n    * @notify Get the accumulated interest rate for a specific collateral type\n    * @param The collateral type for which to retrieve the rate\n    */\n    function getAccumulatedRate(bytes32 collateralType)\n      public view returns (uint256 accumulatedRate) {\n        (, accumulatedRate, , , , ) = safeEngine.collateralTypes(collateralType);\n    }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isSystemCoinToken0_\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"coinJoin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralJoin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cRatioSetter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"systemCoinOrcl_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidationEngine_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taxCollector_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracleRelayer_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"safeManager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"saviourRegistry_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityManager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpToken_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minKeeperPayoutValue_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"AllowUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"safeHandler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"DisallowUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"safeHandler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"systemCoinAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"GetReserves\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemoveAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"safeHandler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAddedOrDebtRepaid\",\"type\":\"uint256\"}],\"name\":\"SaveSAFE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"safeHandler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenAmount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HUNDRED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_UINT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"THOUSAND\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAD_COMPLEMENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"allowUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cRatioSetter\",\"outputs\":[{\"internalType\":\"contract SaviourCRatioSetterLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"safeHandler\",\"type\":\"address\"}],\"name\":\"canSave\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coinJoin\",\"outputs\":[{\"internalType\":\"contract CoinJoinLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralJoin\",\"outputs\":[{\"internalType\":\"contract CollateralJoinLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralToken\",\"outputs\":[{\"internalType\":\"contract ERC20Like\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"targetDebtAmount\",\"type\":\"uint256\"}],\"name\":\"debtBelowFloor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"safeID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokenAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"disallowUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"}],\"name\":\"getAccumulatedRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"accumulatedRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCollateralPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"safeHandler\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redemptionPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safeDebtRepaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safeCollateralAdded\",\"type\":\"uint256\"}],\"name\":\"getKeeperPayoutTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getKeeperPayoutValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"safeHandler\",\"type\":\"address\"}],\"name\":\"getLPUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"safeID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"getReserves\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSystemCoinMarketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"safeHandler\",\"type\":\"address\"}],\"name\":\"getTargetCRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"safeHandler\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redemptionPrice\",\"type\":\"uint256\"}],\"name\":\"getTokensForSaving\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSystemCoinToken0\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keeperPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keeperPayoutExceedsMinValue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidationEngine\",\"outputs\":[{\"internalType\":\"contract LiquidationEngineLike_3\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityManager\",\"outputs\":[{\"internalType\":\"contract UniswapLiquidityManagerLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpToken\",\"outputs\":[{\"internalType\":\"contract ERC20Like\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lpTokenCover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minKeeperPayoutValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleRelayer\",\"outputs\":[{\"internalType\":\"contract OracleRelayerLike_2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payoutToSAFESize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restrictUsage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeEngine\",\"outputs\":[{\"internalType\":\"contract SAFEEngineLike_8\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeManager\",\"outputs\":[{\"internalType\":\"contract GebSafeManagerLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"safeHandler\",\"type\":\"address\"}],\"name\":\"saveSAFE\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saviourRegistry\",\"outputs\":[{\"internalType\":\"contract SAFESaviourRegistryLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"systemCoin\",\"outputs\":[{\"internalType\":\"contract ERC20Like\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"systemCoinOrcl\",\"outputs\":[{\"internalType\":\"contract PriceFeedLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxCollector\",\"outputs\":[{\"internalType\":\"contract TaxCollectorLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"safeHandler\",\"type\":\"address\"}],\"name\":\"tokenAmountUsedToSave\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"underlyingReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"systemCoins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralCoins\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"safeID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NativeUnderlyingUniswapV2SafeSaviour","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000a5653cca4db1b6e265f47caf6969e64f1cfdc450000000000000000000000002d3cd7b81c93f188f3cb8ad87c8acc73d6226e3a000000000000000000000000d58e867e1548d8294bc6c77585af4015ab457880000000000000000000000000b7e06d980b17f168ce1b57189f8aa34d0254fee200000000000000000000000027efc6ffe79692e0521e7e27657cf228240a06c2000000000000000000000000cdb05aeda142a1b0d6044c09c64e4226c1a281eb0000000000000000000000004ed9c0dca0479bc64d8f4eb3007126d5791f7851000000000000000000000000efe0b4ca532769a3ae758fd82e1426a03a94f1850000000000000000000000002c6f6784585b45906fce24f30c99f8ad6d94b5d40000000000000000000000005d447cbe791e2f4c11d82f1f3e901dec76f617630000000000000000000000008ae720a71622e824f576b4a8c03031066548a3b100000000000000000000000000000000000000000000006c6b935b8bbd400000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}