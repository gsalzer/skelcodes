{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.14;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface ICToken {\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function redeem(uint redeemAmount) external returns (uint);\r\n    function exchangeRateStore() external view returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function balanceOf(address owner) external view returns (uint256);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n}\r\n\r\ninterface ICETH{\r\n    function mint() external payable;\r\n}\r\n\r\ninterface IController {\r\n    function fastForward(uint blocks) external returns (uint);\r\n    function getBlockNumber() external view returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\ncontract Constant {\r\n    enum ActionType { DepositAction, WithdrawAction, BorrowAction, RepayAction }\r\n    address public constant ETH_ADDR = 0x000000000000000000000000000000000000000E;\r\n    uint256 public constant INT_UNIT = 10 ** uint256(18);\r\n    uint256 public constant ACCURACY = 10 ** 18;\r\n    uint256 public constant BLOCKS_PER_YEAR = 2102400;\r\n}\r\n\r\ncontract Bank is Constant, Initializable{\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) public totalLoans;     // amount of lended tokens\r\n    mapping(address => uint256) public totalReserve;   // amount of tokens in reservation\r\n    mapping(address => uint256) public totalCompound;  // amount of tokens in compound\r\n    // Token => block-num => rate\r\n    mapping(address => mapping(uint => uint)) public depositRateIndex; // the index curve of deposit rate\r\n    // Token => block-num => rate\r\n    mapping(address => mapping(uint => uint)) public borrowRateIndex;   // the index curve of borrow rate\r\n    // token address => block number\r\n    mapping(address => uint) public lastCheckpoint;            // last checkpoint on the index curve\r\n    // cToken address => rate\r\n    mapping(address => uint) public lastCTokenExchangeRate;    // last compound cToken exchange rate\r\n    mapping(address => ThirdPartyPool) compoundPool;    // the compound pool\r\n\r\n    IGlobalConfig globalConfig;            // global configuration contract address\r\n\r\n    mapping(address => mapping(uint => uint)) public depositFINRateIndex;\r\n    mapping(address => mapping(uint => uint)) public borrowFINRateIndex;\r\n    mapping(address => uint) public lastDepositFINRateCheckpoint;\r\n    mapping(address => uint) public lastBorrowFINRateCheckpoint;\r\n\r\n    modifier onlyAuthorized() {\r\n        require(msg.sender == address(globalConfig.savingAccount()) || msg.sender == address(globalConfig.accounts()),\r\n            \"Only authorized to call from DeFiner internal contracts.\");\r\n        _;\r\n    }\r\n\r\n    struct ThirdPartyPool {\r\n        bool supported;             // if the token is supported by the third party platforms such as Compound\r\n        uint capitalRatio;          // the ratio of the capital in third party to the total asset\r\n        uint depositRatePerBlock;   // the deposit rate of the token in third party\r\n        uint borrowRatePerBlock;    // the borrow rate of the token in third party\r\n    }\r\n\r\n    event UpdateIndex(address indexed token, uint256 depositRateIndex, uint256 borrowRateIndex);\r\n    event UpdateDepositFINIndex(address indexed _token, uint256 depositFINRateIndex);\r\n    event UpdateBorrowFINIndex(address indexed _token, uint256 borrowFINRateIndex);\r\n\r\n    /**\r\n     * Initialize the Bank\r\n     * @param _globalConfig the global configuration contract\r\n     */\r\n    function initialize(\r\n        IGlobalConfig _globalConfig\r\n    ) public initializer {\r\n        globalConfig = _globalConfig;\r\n    }\r\n\r\n    /**\r\n     * Total amount of the token in Saving account\r\n     * @param _token token address\r\n     */\r\n    function getTotalDepositStore(address _token) public view returns(uint) {\r\n        address cToken = ITokenRegistry(globalConfig.tokenInfoRegistry()).getCToken(_token);\r\n        // totalLoans[_token] = U   totalReserve[_token] = R\r\n        return totalCompound[cToken].add(totalLoans[_token]).add(totalReserve[_token]); // return totalAmount = C + U + R\r\n    }\r\n\r\n    /**\r\n     * Update total amount of token in Compound as the cToken price changed\r\n     * @param _token token address\r\n     */\r\n    function updateTotalCompound(address _token) internal {\r\n        address cToken = ITokenRegistry(globalConfig.tokenInfoRegistry()).getCToken(_token);\r\n        if(cToken != address(0)) {\r\n            totalCompound[cToken] = ICToken(cToken).balanceOfUnderlying(address(globalConfig.savingAccount()));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the total reservation. Before run this function, make sure that totalCompound has been updated\r\n     * by calling updateTotalCompound. Otherwise, totalCompound may not equal to the exact amount of the\r\n     * token in Compound.\r\n     * @param _token token address\r\n     * @param _action indicate if user's operation is deposit or withdraw, and borrow or repay.\r\n     * @return the actuall amount deposit/withdraw from the saving pool\r\n     */\r\n    function updateTotalReserve(address _token, uint _amount, ActionType _action) internal returns(uint256 compoundAmount){\r\n        address cToken = ITokenRegistry(globalConfig.tokenInfoRegistry()).getCToken(_token);\r\n        uint totalAmount = getTotalDepositStore(_token);\r\n        if (_action == ActionType.DepositAction || _action == ActionType.RepayAction) {\r\n            // Total amount of token after deposit or repay\r\n            if (_action == ActionType.DepositAction)\r\n                totalAmount = totalAmount.add(_amount);\r\n            else\r\n                totalLoans[_token] = totalLoans[_token].sub(_amount);\r\n\r\n            // Expected total amount of token in reservation after deposit or repay\r\n            uint totalReserveBeforeAdjust = totalReserve[_token].add(_amount);\r\n\r\n            if (cToken != address(0) &&\r\n            totalReserveBeforeAdjust > totalAmount.mul(globalConfig.maxReserveRatio()).div(100)) {\r\n                uint toCompoundAmount = totalReserveBeforeAdjust.sub(totalAmount.mul(globalConfig.midReserveRatio()).div(100));\r\n                //toCompound(_token, toCompoundAmount);\r\n                compoundAmount = toCompoundAmount;\r\n                totalCompound[cToken] = totalCompound[cToken].add(toCompoundAmount);\r\n                totalReserve[_token] = totalReserve[_token].add(_amount).sub(toCompoundAmount);\r\n            }\r\n            else {\r\n                totalReserve[_token] = totalReserve[_token].add(_amount);\r\n            }\r\n        } else {\r\n            // The lack of liquidity exception happens when the pool doesn't have enough tokens for borrow/withdraw\r\n            // It happens when part of the token has lended to the other accounts.\r\n            // However in case of withdrawAll, even if the token has no loan, this requirment may still false because\r\n            // of the precision loss in the rate calcuation. So we put a logic here to deal with this case: in case\r\n            // of withdrawAll and there is no loans for the token, we just adjust the balance in bank contract to the\r\n            // to the balance of that individual account.\r\n            if(_action == ActionType.WithdrawAction) {\r\n                if(totalLoans[_token] != 0)\r\n                    require(getPoolAmount(_token) >= _amount, \"Lack of liquidity when withdraw.\");\r\n                else if (getPoolAmount(_token) < _amount)\r\n                    totalReserve[_token] = _amount.sub(totalCompound[cToken]);\r\n                totalAmount = getTotalDepositStore(_token);\r\n            }\r\n            else\r\n                require(getPoolAmount(_token) >= _amount, \"Lack of liquidity when borrow.\");\r\n\r\n            // Total amount of token after withdraw or borrow\r\n            if (_action == ActionType.WithdrawAction)\r\n                totalAmount = totalAmount.sub(_amount);\r\n            else\r\n                totalLoans[_token] = totalLoans[_token].add(_amount);\r\n\r\n            // Expected total amount of token in reservation after deposit or repay\r\n            uint totalReserveBeforeAdjust = totalReserve[_token] > _amount ? totalReserve[_token].sub(_amount) : 0;\r\n\r\n            // Trigger fromCompound if the new reservation ratio is less than 10%\r\n            if(cToken != address(0) &&\r\n            (totalAmount == 0 || totalReserveBeforeAdjust < totalAmount.mul(globalConfig.minReserveRatio()).div(100))) {\r\n\r\n                uint totalAvailable = totalReserve[_token].add(totalCompound[cToken]).sub(_amount);\r\n                if (totalAvailable < totalAmount.mul(globalConfig.midReserveRatio()).div(100)){\r\n                    // Withdraw all the tokens from Compound\r\n                    compoundAmount = totalCompound[cToken];\r\n                    totalCompound[cToken] = 0;\r\n                    totalReserve[_token] = totalAvailable;\r\n                } else {\r\n                    // Withdraw partial tokens from Compound\r\n                    uint totalInCompound = totalAvailable.sub(totalAmount.mul(globalConfig.midReserveRatio()).div(100));\r\n                    compoundAmount = totalCompound[cToken].sub(totalInCompound);\r\n                    totalCompound[cToken] = totalInCompound;\r\n                    totalReserve[_token] = totalAvailable.sub(totalInCompound);\r\n                }\r\n            }\r\n            else {\r\n                totalReserve[_token] = totalReserve[_token].sub(_amount);\r\n            }\r\n        }\r\n        return compoundAmount;\r\n    }\r\n\r\n     function update(address _token, uint _amount, ActionType _action) public onlyAuthorized returns(uint256 compoundAmount) {\r\n        updateTotalCompound(_token);\r\n        // updateTotalLoan(_token);\r\n        compoundAmount = updateTotalReserve(_token, _amount, _action);\r\n        return compoundAmount;\r\n    }\r\n\r\n    /**\r\n     * The function is called in Bank.deposit(), Bank.withdraw() and Accounts.claim() functions.\r\n     * The function should be called AFTER the newRateIndexCheckpoint function so that the account balances are\r\n     * accurate, and BEFORE the account balance acutally updated due to deposit/withdraw activities.\r\n     */\r\n    function updateDepositFINIndex(address _token) public onlyAuthorized{\r\n        uint currentBlock = getBlockNumber();\r\n        uint deltaBlock;\r\n        // If it is the first deposit FIN rate checkpoint, set the deltaBlock value be 0 so that the first\r\n        // point on depositFINRateIndex is zero.\r\n        deltaBlock = lastDepositFINRateCheckpoint[_token] == 0 ? 0 : currentBlock.sub(lastDepositFINRateCheckpoint[_token]);\r\n        // If the totalDeposit of the token is zero, no FIN token should be mined and the FINRateIndex is unchanged.\r\n        depositFINRateIndex[_token][currentBlock] = depositFINRateIndex[_token][lastDepositFINRateCheckpoint[_token]].add(\r\n            getTotalDepositStore(_token) == 0 ? 0 : depositRateIndex[_token][lastCheckpoint[_token]]\r\n                .mul(deltaBlock)\r\n                .mul(ITokenRegistry(globalConfig.tokenInfoRegistry()).depositeMiningSpeeds(_token))\r\n                .div(getTotalDepositStore(_token)));\r\n        lastDepositFINRateCheckpoint[_token] = currentBlock;\r\n\r\n        emit UpdateDepositFINIndex(_token, depositFINRateIndex[_token][currentBlock]);\r\n    }\r\n\r\n    function updateBorrowFINIndex(address _token) public onlyAuthorized{\r\n        uint currentBlock = getBlockNumber();\r\n        uint deltaBlock;\r\n        // If it is the first borrow FIN rate checkpoint, set the deltaBlock value be 0 so that the first\r\n        // point on borrowFINRateIndex is zero.\r\n        deltaBlock = lastBorrowFINRateCheckpoint[_token] == 0 ? 0 : currentBlock.sub(lastBorrowFINRateCheckpoint[_token]);\r\n        // If the totalBorrow of the token is zero, no FIN token should be mined and the FINRateIndex is unchanged.\r\n        borrowFINRateIndex[_token][currentBlock] = borrowFINRateIndex[_token][lastBorrowFINRateCheckpoint[_token]].add(\r\n            totalLoans[_token] == 0 ? 0 : borrowRateIndex[_token][lastCheckpoint[_token]]\r\n                    .mul(deltaBlock)\r\n                    .mul(ITokenRegistry(globalConfig.tokenInfoRegistry()).borrowMiningSpeeds(_token))\r\n                    .div(totalLoans[_token]));\r\n        lastBorrowFINRateCheckpoint[_token] = currentBlock;\r\n\r\n        emit UpdateBorrowFINIndex(_token, borrowFINRateIndex[_token][currentBlock]);\r\n    }\r\n\r\n    function updateMining(address _token) public onlyAuthorized{\r\n        newRateIndexCheckpoint(_token);\r\n        updateTotalCompound(_token);\r\n    }\r\n\r\n    /**\r\n     * Get the borrowing interest rate Borrowing interest rate.\r\n     * @param _token token address\r\n     * @return the borrow rate for the current block\r\n     */\r\n    function getBorrowRatePerBlock(address _token) public view returns(uint) {\r\n        if(!ITokenRegistry(globalConfig.tokenInfoRegistry()).isSupportedOnCompound(_token))\r\n        // If the token is NOT supported by the third party, borrowing rate = 3% + U * 15%.\r\n            return getCapitalUtilizationRatio(_token).mul(globalConfig.rateCurveSlope()).div(INT_UNIT).add(globalConfig.rateCurveConstant()).div(BLOCKS_PER_YEAR);\r\n\r\n        // if the token is suppored in third party, borrowing rate = Compound Supply Rate * 0.4 + Compound Borrow Rate * 0.6\r\n        return (compoundPool[_token].depositRatePerBlock).mul(globalConfig.compoundSupplyRateWeights()).\r\n            add((compoundPool[_token].borrowRatePerBlock).mul(globalConfig.compoundBorrowRateWeights())).div(10);\r\n    }\r\n\r\n    /**\r\n    * Get Deposit Rate.  Deposit APR = (Borrow APR * Utilization Rate (U) +  Compound Supply Rate *\r\n    * Capital Compound Ratio (C) )* (1- DeFiner Community Fund Ratio (D)). The scaling is 10 ** 18\r\n    * @param _token token address\r\n    * @return deposite rate of blocks before the current block\r\n    */\r\n    function getDepositRatePerBlock(address _token) public view returns(uint) {\r\n        uint256 borrowRatePerBlock = getBorrowRatePerBlock(_token);\r\n        uint256 capitalUtilRatio = getCapitalUtilizationRatio(_token);\r\n        if(!ITokenRegistry(globalConfig.tokenInfoRegistry()).isSupportedOnCompound(_token))\r\n            return borrowRatePerBlock.mul(capitalUtilRatio).div(INT_UNIT);\r\n\r\n        return borrowRatePerBlock.mul(capitalUtilRatio).add(compoundPool[_token].depositRatePerBlock\r\n            .mul(compoundPool[_token].capitalRatio)).div(INT_UNIT);\r\n    }\r\n\r\n    /**\r\n     * Get capital utilization. Capital Utilization Rate (U )= total loan outstanding / Total market deposit\r\n     * @param _token token address\r\n     */\r\n    function getCapitalUtilizationRatio(address _token) public view returns(uint) {\r\n        uint256 totalDepositsNow = getTotalDepositStore(_token);\r\n        if(totalDepositsNow == 0) {\r\n            return 0;\r\n        } else {\r\n            return totalLoans[_token].mul(INT_UNIT).div(totalDepositsNow);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ratio of the capital in Compound\r\n     * @param _token token address\r\n     */\r\n    function getCapitalCompoundRatio(address _token) public view returns(uint) {\r\n        address cToken = ITokenRegistry(globalConfig.tokenInfoRegistry()).getCToken(_token);\r\n        if(totalCompound[cToken] == 0 ) {\r\n            return 0;\r\n        } else {\r\n            return uint(totalCompound[cToken].mul(INT_UNIT).div(getTotalDepositStore(_token)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * It's a utility function. Get the cummulative deposit rate in a block interval ending in current block\r\n     * @param _token token address\r\n     * @param _depositRateRecordStart the start block of the interval\r\n     * @dev This function should always be called after current block is set as a new rateIndex point.\r\n     */\r\n    function getDepositAccruedRate(address _token, uint _depositRateRecordStart) external view returns (uint256) {\r\n        uint256 depositRate = depositRateIndex[_token][_depositRateRecordStart];\r\n        require(depositRate != 0, \"_depositRateRecordStart is not a check point on index curve.\");\r\n        return depositRateIndexNow(_token).mul(INT_UNIT).div(depositRate);\r\n    }\r\n\r\n    /**\r\n     * Get the cummulative borrow rate in a block interval ending in current block\r\n     * @param _token token address\r\n     * @param _borrowRateRecordStart the start block of the interval\r\n     * @dev This function should always be called after current block is set as a new rateIndex point.\r\n     */\r\n    function getBorrowAccruedRate(address _token, uint _borrowRateRecordStart) external view returns (uint256) {\r\n        uint256 borrowRate = borrowRateIndex[_token][_borrowRateRecordStart];\r\n        require(borrowRate != 0, \"_borrowRateRecordStart is not a check point on index curve.\");\r\n        return borrowRateIndexNow(_token).mul(INT_UNIT).div(borrowRate);\r\n    }\r\n\r\n    /**\r\n     * Set a new rate index checkpoint.\r\n     * @param _token token address\r\n     * @dev The rate set at the checkpoint is the rate from the last checkpoint to this checkpoint\r\n     */\r\n    function newRateIndexCheckpoint(address _token) public onlyAuthorized {\r\n\r\n        // return if the rate check point already exists\r\n        uint blockNumber = getBlockNumber();\r\n        if (blockNumber == lastCheckpoint[_token])\r\n            return;\r\n\r\n        uint256 UNIT = INT_UNIT;\r\n        address cToken = ITokenRegistry(globalConfig.tokenInfoRegistry()).getCToken(_token);\r\n\r\n        // If it is the first check point, initialize the rate index\r\n        uint256 previousCheckpoint = lastCheckpoint[_token];\r\n        if (lastCheckpoint[_token] == 0) {\r\n            if(cToken == address(0)) {\r\n                compoundPool[_token].supported = false;\r\n                borrowRateIndex[_token][blockNumber] = UNIT;\r\n                depositRateIndex[_token][blockNumber] = UNIT;\r\n                // Update the last checkpoint\r\n                lastCheckpoint[_token] = blockNumber;\r\n            }\r\n            else {\r\n                compoundPool[_token].supported = true;\r\n                uint cTokenExchangeRate = ICToken(cToken).exchangeRateCurrent();\r\n                // Get the curretn cToken exchange rate in Compound, which is need to calculate DeFiner's rate\r\n                compoundPool[_token].capitalRatio = getCapitalCompoundRatio(_token);\r\n                compoundPool[_token].borrowRatePerBlock = ICToken(cToken).borrowRatePerBlock();  // initial value\r\n                compoundPool[_token].depositRatePerBlock = ICToken(cToken).supplyRatePerBlock(); // initial value\r\n                borrowRateIndex[_token][blockNumber] = UNIT;\r\n                depositRateIndex[_token][blockNumber] = UNIT;\r\n                // Update the last checkpoint\r\n                lastCheckpoint[_token] = blockNumber;\r\n                lastCTokenExchangeRate[cToken] = cTokenExchangeRate;\r\n            }\r\n\r\n        } else {\r\n            if(cToken == address(0)) {\r\n                compoundPool[_token].supported = false;\r\n                borrowRateIndex[_token][blockNumber] = borrowRateIndexNow(_token);\r\n                depositRateIndex[_token][blockNumber] = depositRateIndexNow(_token);\r\n                // Update the last checkpoint\r\n                lastCheckpoint[_token] = blockNumber;\r\n            } else {\r\n                compoundPool[_token].supported = true;\r\n                uint cTokenExchangeRate = ICToken(cToken).exchangeRateCurrent();\r\n                // Get the curretn cToken exchange rate in Compound, which is need to calculate DeFiner's rate\r\n                compoundPool[_token].capitalRatio = getCapitalCompoundRatio(_token);\r\n                compoundPool[_token].borrowRatePerBlock = ICToken(cToken).borrowRatePerBlock();\r\n                compoundPool[_token].depositRatePerBlock = cTokenExchangeRate.mul(UNIT).div(lastCTokenExchangeRate[cToken])\r\n                    .sub(UNIT).div(blockNumber.sub(lastCheckpoint[_token]));\r\n                borrowRateIndex[_token][blockNumber] = borrowRateIndexNow(_token);\r\n                depositRateIndex[_token][blockNumber] = depositRateIndexNow(_token);\r\n                // Update the last checkpoint\r\n                lastCheckpoint[_token] = blockNumber;\r\n                lastCTokenExchangeRate[cToken] = cTokenExchangeRate;\r\n            }\r\n        }\r\n\r\n        // Update the total loan\r\n        if(borrowRateIndex[_token][blockNumber] != UNIT) {\r\n            totalLoans[_token] = totalLoans[_token].mul(borrowRateIndex[_token][blockNumber])\r\n                .div(borrowRateIndex[_token][previousCheckpoint]);\r\n        }\r\n\r\n        emit UpdateIndex(_token, depositRateIndex[_token][getBlockNumber()], borrowRateIndex[_token][getBlockNumber()]);\r\n    }\r\n\r\n    /**\r\n     * Calculate a token deposite rate of current block\r\n     * @param _token token address\r\n     * @dev This is an looking forward estimation from last checkpoint and not the exactly rate that the user will pay or earn.\r\n     */\r\n    function depositRateIndexNow(address _token) public view returns(uint) {\r\n        uint256 lcp = lastCheckpoint[_token];\r\n        // If this is the first checkpoint, set the index be 1.\r\n        if(lcp == 0)\r\n            return INT_UNIT;\r\n\r\n        uint256 lastDepositeRateIndex = depositRateIndex[_token][lcp];\r\n        uint256 depositRatePerBlock = getDepositRatePerBlock(_token);\r\n        // newIndex = oldIndex*(1+r*delta_block). If delta_block = 0, i.e. the last checkpoint is current block, index doesn't change.\r\n        return lastDepositeRateIndex.mul(getBlockNumber().sub(lcp).mul(depositRatePerBlock).add(INT_UNIT)).div(INT_UNIT);\r\n    }\r\n\r\n    /**\r\n     * Calculate a token borrow rate of current block\r\n     * @param _token token address\r\n     */\r\n    function borrowRateIndexNow(address _token) public view returns(uint) {\r\n        uint256 lcp = lastCheckpoint[_token];\r\n        // If this is the first checkpoint, set the index be 1.\r\n        if(lcp == 0)\r\n            return INT_UNIT;\r\n        uint256 lastBorrowRateIndex = borrowRateIndex[_token][lcp];\r\n        uint256 borrowRatePerBlock = getBorrowRatePerBlock(_token);\r\n        return lastBorrowRateIndex.mul(getBlockNumber().sub(lcp).mul(borrowRatePerBlock).add(INT_UNIT)).div(INT_UNIT);\r\n    }\r\n\r\n    /**\r\n\t * Get the state of the given token\r\n     * @param _token token address\r\n\t */\r\n    function getTokenState(address _token) public view returns (uint256 deposits, uint256 loans, uint256 reserveBalance, uint256 remainingAssets){\r\n        return (\r\n        getTotalDepositStore(_token),\r\n        totalLoans[_token],\r\n        totalReserve[_token],\r\n        totalReserve[_token].add(totalCompound[ITokenRegistry(globalConfig.tokenInfoRegistry()).getCToken(_token)])\r\n        );\r\n    }\r\n\r\n    function getPoolAmount(address _token) public view returns(uint) {\r\n        return totalReserve[_token].add(totalCompound[ITokenRegistry(globalConfig.tokenInfoRegistry()).getCToken(_token)]);\r\n    }\r\n\r\n    function deposit(address _to, address _token, uint256 _amount) external onlyAuthorized {\r\n\r\n        require(_amount != 0, \"Amount is zero\");\r\n\r\n        // Add a new checkpoint on the index curve.\r\n        newRateIndexCheckpoint(_token);\r\n        updateDepositFINIndex(_token);\r\n\r\n        // Update tokenInfo. Add the _amount to principal, and update the last deposit block in tokenInfo\r\n        IAccount(globalConfig.accounts()).deposit(_to, _token, _amount);\r\n\r\n        // Update the amount of tokens in compound and loans, i.e. derive the new values\r\n        // of C (Compound Ratio) and U (Utilization Ratio).\r\n        uint compoundAmount = update(_token, _amount, ActionType.DepositAction);\r\n\r\n        if(compoundAmount > 0) {\r\n            ISavingAccount(globalConfig.savingAccount()).toCompound(_token, compoundAmount);\r\n        }\r\n    }\r\n\r\n    function borrow(address _from, address _token, uint256 _amount) external onlyAuthorized {\r\n\r\n        // Add a new checkpoint on the index curve.\r\n        newRateIndexCheckpoint(_token);\r\n        updateBorrowFINIndex(_token);\r\n\r\n        // Update tokenInfo for the user\r\n        IAccount(globalConfig.accounts()).borrow(_from, _token, _amount);\r\n\r\n        // Update pool balance\r\n        // Update the amount of tokens in compound and loans, i.e. derive the new values\r\n        // of C (Compound Ratio) and U (Utilization Ratio).\r\n        uint compoundAmount = update(_token, _amount, ActionType.BorrowAction);\r\n\r\n        if(compoundAmount > 0) {\r\n            ISavingAccount(globalConfig.savingAccount()).fromCompound(_token, compoundAmount);\r\n        }\r\n    }\r\n\r\n    function repay(address _to, address _token, uint256 _amount) external onlyAuthorized returns(uint) {\r\n\r\n        // Add a new checkpoint on the index curve.\r\n        newRateIndexCheckpoint(_token);\r\n        updateBorrowFINIndex(_token);\r\n\r\n        // Sanity check\r\n        require(IAccount(globalConfig.accounts()).getBorrowPrincipal(_to, _token) > 0,\r\n            \"Token BorrowPrincipal must be greater than 0. To deposit balance, please use deposit button.\"\r\n        );\r\n\r\n        // Update tokenInfo\r\n        uint256 remain = IAccount(globalConfig.accounts()).repay(_to, _token, _amount);\r\n\r\n        // Update the amount of tokens in compound and loans, i.e. derive the new values\r\n        // of C (Compound Ratio) and U (Utilization Ratio).\r\n        uint compoundAmount = update(_token, _amount.sub(remain), ActionType.RepayAction);\r\n        if(compoundAmount > 0) {\r\n           ISavingAccount(globalConfig.savingAccount()).toCompound(_token, compoundAmount);\r\n        }\r\n\r\n        // Return actual amount repaid\r\n        return _amount.sub(remain);\r\n    }\r\n\r\n    /**\r\n     * Withdraw a token from an address\r\n     * @param _from address to be withdrawn from\r\n     * @param _token token address\r\n     * @param _amount amount to be withdrawn\r\n     * @return The actually amount withdrawed, which will be the amount requested minus the commission fee.\r\n     */\r\n    function withdraw(address _from, address _token, uint256 _amount) external onlyAuthorized returns(uint) {\r\n\r\n        require(_amount != 0, \"Amount is zero\");\r\n\r\n        // Add a new checkpoint on the index curve.\r\n        newRateIndexCheckpoint(_token);\r\n        updateDepositFINIndex(_token);\r\n\r\n        // Withdraw from the account\r\n        uint amount = IAccount(globalConfig.accounts()).withdraw(_from, _token, _amount);\r\n\r\n        // Update pool balance\r\n        // Update the amount of tokens in compound and loans, i.e. derive the new values\r\n        // of C (Compound Ratio) and U (Utilization Ratio).\r\n        uint compoundAmount = update(_token, amount, ActionType.WithdrawAction);\r\n\r\n        // Check if there are enough tokens in the pool.\r\n        if(compoundAmount > 0) {\r\n            ISavingAccount(globalConfig.savingAccount()).fromCompound(_token, compoundAmount);\r\n        }\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * Get current block number\r\n     * @return the current block number\r\n     */\r\n    function getBlockNumber() private view returns (uint) {\r\n        return block.number;\r\n    }\r\n}\r\n\r\ninterface IGlobalConfig {\r\n    function constants() external view returns (address);\r\n    function tokenInfoRegistry() external view returns (address);\r\n    function chainLink() external view returns (address);\r\n    function bank() external view returns (address);\r\n    function savingAccount() external view returns (address);\r\n    function accounts() external view returns (address);\r\n    function maxReserveRatio() external view returns (uint256);\r\n    function midReserveRatio() external view returns (uint256);\r\n    function minReserveRatio() external view returns (uint256);\r\n    function rateCurveSlope() external view returns (uint256);\r\n    function rateCurveConstant() external view returns (uint256);\r\n    function compoundSupplyRateWeights() external view returns (uint256);\r\n    function compoundBorrowRateWeights() external view returns (uint256);\r\n}\r\n\r\ninterface ITokenRegistry {\r\n    function getTokenDecimals(address) external view returns (uint8);\r\n    function getCToken(address) external view returns (address);\r\n    function depositeMiningSpeeds(address) external view returns (uint256);\r\n    function borrowMiningSpeeds(address) external view returns (uint256);\r\n    function isSupportedOnCompound(address) external view returns (bool);\r\n}\r\n\r\ninterface IAccount {\r\n    function deposit(address, address, uint256) external;\r\n    function borrow(address, address, uint256) external;\r\n    function getBorrowPrincipal(address, address) external view returns (uint256);\r\n    function withdraw(address, address, uint256) external returns (uint256);\r\n    function repay(address, address, uint256) external returns (uint256);\r\n}\r\n\r\ninterface ISavingAccount {\r\n    function toCompound(address, uint256) external;\r\n    function fromCompound(address, uint256) external;\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowFINRateIndex\",\"type\":\"uint256\"}],\"name\":\"UpdateBorrowFINIndex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositFINRateIndex\",\"type\":\"uint256\"}],\"name\":\"UpdateDepositFINIndex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositRateIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowRateIndex\",\"type\":\"uint256\"}],\"name\":\"UpdateIndex\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"ACCURACY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BLOCKS_PER_YEAR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INT_UNIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"borrowFINRateIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"borrowRateIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"borrowRateIndexNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositFINRateIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositRateIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"depositRateIndexNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_borrowRateRecordStart\",\"type\":\"uint256\"}],\"name\":\"getBorrowAccruedRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getBorrowRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getCapitalCompoundRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getCapitalUtilizationRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_depositRateRecordStart\",\"type\":\"uint256\"}],\"name\":\"getDepositAccruedRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getDepositRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getPoolAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getTokenState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loans\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingAssets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getTotalDepositStore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IGlobalConfig\",\"name\":\"_globalConfig\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastBorrowFINRateCheckpoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastCTokenExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastCheckpoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastDepositFINRateCheckpoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"newRateIndexCheckpoint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalCompound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalLoans\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"enum Constant.ActionType\",\"name\":\"_action\",\"type\":\"uint8\"}],\"name\":\"update\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"compoundAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"updateBorrowFINIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"updateDepositFINIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"updateMining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Bank","CompilerVersion":"v0.5.14+commit.01f1aaa4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv2.1","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0c5c4e18223a52feb79e06417473b7502bd1310e5c0c093f602e74bbb8e180af"}]}