{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4 <0.9.0;\r\n\r\n// OpenZeppelin Upgradeability contracts modified by Sam Porter. Proxy for Nameless Protocol contracts\r\n// You can find original set of contracts here: https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/proxy\r\n\r\n// Had to pack OpenZeppelin upgradeability contracts in one single contract for readability. It's basically the same OpenZeppelin functions \r\n// but in one contract with some differences:\r\n// 1. DEADLINE is a block after which it becomes impossible to upgrade the contract. Defined in constructor and here it's ~2 years.\r\n// Maybe not even required for most contracts, but I kept it in case if something happens to developers.\r\n// 2. PROPOSE_BLOCK defines how often the contract can be upgraded. Defined in _setNextLogic() function and the interval here is set\r\n// to 172800 blocks ~1 month.\r\n// 3. Admin rights are burnable\r\n// 4. prolongLock() allows to add to PROPOSE_BLOCK. Basically allows to prolong lock. For example if there no upgrades planned soon,\r\n// then this function could be called to set next upgrade being possible only in a year, so investors won't need to monitor the code too closely\r\n// all the time. Could prolong to maximum solidity number so the deadline might not be needed \r\n// 5. logic contract is not being set suddenly. it's being stored in NEXT_LOGIC_SLOT for a month and only after that it can be set as LOGIC_SLOT.\r\n// Users have time to decide on if the deployer or the governance is malicious and exit safely.\r\n// 6. constructor does not require arguments\r\n// 7. before removeTrust() is called, the proxy acts like eip-1967 proxy, can be upgraded at any point in time. it's to counter human error,\r\n// after deployer confirms that everything is deployed correctly, must be called\r\n\r\n// It fixes \"upgradeability bug\" I believe. Also I sincerely believe that upgradeability is not about fixing bugs, but about upgradeability,\r\n// so yeah, proposed logic has to be clean and without typos(!) or overflows(!).\r\n// In my heart it exists as eip-1984 but it's too late for that number. https://ethereum-magicians.org/t/trust-minimized-proxy/5742/2\r\n\r\ncontract AletheoJobMarketTrustMinimizedProxy{ // THE CODE FITS ON THE SCREEN UNBELIAVABLE LETS STOP ENDLESS SCROLLING UP AND DOWN\r\n\tevent Upgraded(address indexed toLogic);\r\n\tevent AdminChanged(address indexed previousAdmin, address indexed newAdmin);\r\n\tevent NextLogicDefined(address indexed nextLogic, uint earliestArrivalBlock);\r\n\tevent UpgradesRestrictedUntil(uint block);\r\n\tevent NextLogicCanceled();\r\n\tevent TrustRemoved();\r\n\r\n\tbytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\tbytes32 internal constant LOGIC_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\tbytes32 internal constant NEXT_LOGIC_SLOT = 0xb182d207b11df9fb38eec1e3fe4966cf344774ba58fb0e9d88ea35ad46f3601e;\r\n\tbytes32 internal constant NEXT_LOGIC_BLOCK_SLOT = 0x96de003e85302815fe026bddb9630a50a1d4dc51c5c355def172204c3fd1c733;\r\n\tbytes32 internal constant PROPOSE_BLOCK_SLOT = 0xbc9d35b69e82e85049be70f91154051f5e20e574471195334bde02d1a9974c90;\r\n//\tbytes32 internal constant DEADLINE_SLOT = 0xb124b82d2ac46ebdb08de751ebc55102cc7325d133e09c1f1c25014e20b979ad;\r\n\tbytes32 internal constant TRUST_MINIMIZED_SLOT = 0xa0ea182b754772c4f5848349cff27d3431643ba25790e0c61a8e4bdf4cec9201;\r\n\r\n\tconstructor() payable {\r\n//\t\trequire(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1) && LOGIC_SLOT==bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1) // this require is simply against human error, can be removed if you know what you are doing\r\n//\t\t&& NEXT_LOGIC_SLOT == bytes32(uint256(keccak256('eip1984.proxy.nextLogic')) - 1) && NEXT_LOGIC_BLOCK_SLOT == bytes32(uint256(keccak256('eip1984.proxy.nextLogicBlock')) - 1)\r\n//\t\t&& PROPOSE_BLOCK_SLOT == bytes32(uint256(keccak256('eip1984.proxy.proposeBlock')) - 1)/* && DEADLINE_SLOT == bytes32(uint256(keccak256('eip1984.proxy.deadline')) - 1)*/\r\n//\t\t&& TRUST_MINIMIZED_SLOT == bytes32(uint256(keccak256('eip1984.proxy.trustMinimized')) - 1));\r\n\t\t_setAdmin(msg.sender);\r\n//\t\tuint deadline = block.number + 4204800; // ~2 years as default\r\n//\t\tassembly {sstore(DEADLINE_SLOT,deadline)}\r\n\t}\r\n\r\n\tmodifier ifAdmin() {if (msg.sender == _admin()) {_;} else {_fallback();}}\r\n\tfunction _logic() internal view returns (address logic) {assembly { logic := sload(LOGIC_SLOT) }}\r\n\tfunction _proposeBlock() internal view returns (uint bl) {assembly { bl := sload(PROPOSE_BLOCK_SLOT) }}\r\n\tfunction _nextLogicBlock() internal view returns (uint bl) {assembly { bl := sload(NEXT_LOGIC_BLOCK_SLOT) }}\r\n//\tfunction _deadline() internal view returns (uint bl) {assembly { bl := sload(DEADLINE_SLOT) }}\r\n\tfunction _trustMinimized() internal view returns (bool tm) {assembly { tm := sload(TRUST_MINIMIZED_SLOT) }}\r\n\tfunction _admin() internal view returns (address adm) {assembly { adm := sload(ADMIN_SLOT) }}\r\n\tfunction _setAdmin(address newAdm) internal {assembly {sstore(ADMIN_SLOT, newAdm)}}\r\n\tfunction changeAdmin(address newAdm) external ifAdmin {emit AdminChanged(_admin(), newAdm);_setAdmin(newAdm);}\r\n\tfunction upgrade() external ifAdmin {require(block.number>=_nextLogicBlock());address logic;assembly {logic := sload(NEXT_LOGIC_SLOT) sstore(LOGIC_SLOT,logic)}emit Upgraded(logic);}\r\n\tfallback () external payable {_fallback();}\r\n\treceive () external payable {_fallback();}\r\n\tfunction _fallback() internal {require(msg.sender != _admin());_delegate(_logic());}\r\n\tfunction cancelUpgrade() external ifAdmin {address logic; assembly {logic := sload(LOGIC_SLOT)sstore(NEXT_LOGIC_SLOT, logic)}emit NextLogicCanceled();}\r\n\tfunction prolongLock(uint b) external ifAdmin {require(b > _proposeBlock()); assembly {sstore(PROPOSE_BLOCK_SLOT,b)} emit UpgradesRestrictedUntil(b);}\r\n\tfunction removeTrust() external ifAdmin {assembly{ sstore(TRUST_MINIMIZED_SLOT, true) }emit TrustRemoved();} // before this called acts like a normal eip 1967 transparent proxy. after the deployer confirms everything is deployed correctly must be called\r\n\tfunction _updateBlockSlot() internal {uint nlb = block.number + 172800; assembly {sstore(NEXT_LOGIC_BLOCK_SLOT,nlb)}}\r\n\tfunction _setNextLogic(address nl) internal {require(block.number >= _proposeBlock());_updateBlockSlot();assembly { sstore(NEXT_LOGIC_SLOT, nl)}emit NextLogicDefined(nl,block.number + 172800);}\r\n\r\n\tfunction proposeToAndCall(address newLogic, bytes calldata data) payable external ifAdmin {\r\n\t\tif (_logic() == address(0) || _trustMinimized() == false) {assembly {sstore(LOGIC_SLOT,newLogic)}emit Upgraded(newLogic);}else{_setNextLogic(newLogic);}\r\n\t\t(bool success,) = newLogic.delegatecall(data);require(success);\r\n\t}\r\n\r\n\tfunction _delegate(address logic_) internal {\r\n\t\tassembly {\r\n\t\t\tcalldatacopy(0, 0, calldatasize())\r\n\t\t\tlet result := delegatecall(gas(), logic_, 0, calldatasize(), 0, 0)\r\n\t\t\treturndatacopy(0, 0, returndatasize())\r\n\t\t\tswitch result\r\n\t\t\tcase 0 { revert(0, returndatasize()) }\r\n\t\t\tdefault { return(0, returndatasize()) }\r\n\t\t}\r\n\t}\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NextLogicCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nextLogic\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earliestArrivalBlock\",\"type\":\"uint256\"}],\"name\":\"NextLogicDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TrustRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toLogic\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"UpgradesRestrictedUntil\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"cancelUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdm\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"prolongLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLogic\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"proposeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeTrust\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"AletheoJobMarketTrustMinimizedProxy","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://254fcf8e4ed08ffa275c00dcf99a43bee040089095283a711e7dc3b979b553eb"}]}