{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/proposals/ProposalIncentivesExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {IERC20} from '@aave/aave-stake/contracts/interfaces/IERC20.sol';\\nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol';\\nimport {ILendingPoolConfigurator} from '../interfaces/ILendingPoolConfigurator.sol';\\nimport {IAaveIncentivesController} from '../interfaces/IAaveIncentivesController.sol';\\nimport {IAaveEcosystemReserveController} from '../interfaces/IAaveEcosystemReserveController.sol';\\nimport {IProposalIncentivesExecutor} from '../interfaces/IProposalIncentivesExecutor.sol';\\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\\nimport {DataTypes} from '../utils/DataTypes.sol';\\nimport {ILendingPoolData} from '../interfaces/ILendingPoolData.sol';\\nimport {IATokenDetailed} from '../interfaces/IATokenDetailed.sol';\\nimport {PercentageMath} from '../utils/PercentageMath.sol';\\nimport {SafeMath} from '../lib/SafeMath.sol';\\n\\ncontract ProposalIncentivesExecutor is IProposalIncentivesExecutor {\\n  using SafeMath for uint256;\\n  using PercentageMath for uint256;\\n\\n  address constant AAVE_TOKEN = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\\n  address constant POOL_CONFIGURATOR = 0x311Bb771e4F8952E6Da169b425E7e92d6Ac45756;\\n  address constant ADDRESSES_PROVIDER = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;\\n  address constant LENDING_POOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\\n  address constant ECO_RESERVE_ADDRESS = 0x1E506cbb6721B83B1549fa1558332381Ffa61A93;\\n  address constant INCENTIVES_CONTROLLER_PROXY_ADDRESS = 0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5;\\n  address constant INCENTIVES_CONTROLLER_IMPL_ADDRESS = 0x83D055D382f25e6793099713505c68a5C7535a35;\\n\\n  uint256 constant DISTRIBUTION_DURATION = 7776000; // 90 days\\n  uint256 constant DISTRIBUTION_AMOUNT = 198000000000000000000000; // 198000 AAVE during 90 days\\n\\n  function execute(\\n    address[6] memory aTokenImplementations,\\n    address[6] memory variableDebtImplementations\\n  ) external override {\\n    uint256 tokensCounter;\\n\\n    address[] memory assets = new address[](12);\\n\\n    // Reserves Order: DAI/GUSD/USDC/USDT/WBTC/WETH\\n    address payable[6] memory reserves =\\n      [\\n        0x6B175474E89094C44Da98b954EedeAC495271d0F,\\n        0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd,\\n        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48,\\n        0xdAC17F958D2ee523a2206206994597C13D831ec7,\\n        0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599,\\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\\n      ];\\n\\n    uint256[] memory emissions = new uint256[](12);\\n\\n    emissions[0] = 1706018518518520; //aDAI\\n    emissions[1] = 1706018518518520; //vDebtDAI\\n    emissions[2] = 92939814814815; //aGUSD\\n    emissions[3] = 92939814814815; //vDebtGUSD\\n    emissions[4] = 5291203703703700; //aUSDC\\n    emissions[5] = 5291203703703700; //vDebtUSDC\\n    emissions[6] = 3293634259259260; //aUSDT\\n    emissions[7] = 3293634259259260; //vDebtUSDT\\n    emissions[8] = 1995659722222220; //aWBTC\\n    emissions[9] = 105034722222222; //vDebtWBTC\\n    emissions[10] = 2464942129629630; //aETH\\n    emissions[11] = 129733796296296; //vDebtWETH\\n\\n    ILendingPoolConfigurator poolConfigurator = ILendingPoolConfigurator(POOL_CONFIGURATOR);\\n    IAaveIncentivesController incentivesController =\\n      IAaveIncentivesController(INCENTIVES_CONTROLLER_PROXY_ADDRESS);\\n    IAaveEcosystemReserveController ecosystemReserveController =\\n      IAaveEcosystemReserveController(ECO_RESERVE_ADDRESS);\\n\\n    ILendingPoolAddressesProvider provider = ILendingPoolAddressesProvider(ADDRESSES_PROVIDER);\\n\\n    //adding the incentives controller proxy to the addresses provider\\n    provider.setAddress(keccak256('INCENTIVES_CONTROLLER'), INCENTIVES_CONTROLLER_PROXY_ADDRESS);\\n\\n    //updating the implementation of the incentives controller proxy\\n    provider.setAddressAsProxy(keccak256('INCENTIVES_CONTROLLER'), INCENTIVES_CONTROLLER_IMPL_ADDRESS);\\n\\n    require(\\n      aTokenImplementations.length == variableDebtImplementations.length &&\\n        aTokenImplementations.length == reserves.length,\\n      'ARRAY_LENGTH_MISMATCH'\\n    );\\n\\n    // Update each reserve AToken implementation, Debt implementation, and prepare incentives configuration input\\n    for (uint256 x = 0; x < reserves.length; x++) {\\n      require(\\n        IATokenDetailed(aTokenImplementations[x]).UNDERLYING_ASSET_ADDRESS() == reserves[x],\\n        'AToken underlying does not match'\\n      );\\n      require(\\n        IATokenDetailed(variableDebtImplementations[x]).UNDERLYING_ASSET_ADDRESS() == reserves[x],\\n        'Debt Token underlying does not match'\\n      );\\n      DataTypes.ReserveData memory reserveData =\\n        ILendingPoolData(LENDING_POOL).getReserveData(reserves[x]);\\n\\n      // Update aToken impl\\n      poolConfigurator.updateAToken(reserves[x], aTokenImplementations[x]);\\n\\n      // Update variable debt impl\\n      poolConfigurator.updateVariableDebtToken(reserves[x], variableDebtImplementations[x]);\\n\\n      assets[tokensCounter++] = reserveData.aTokenAddress;\\n\\n      // Configure variable debt token at incentives controller\\n      assets[tokensCounter++] = reserveData.variableDebtTokenAddress;\\n\\n    }\\n    // Transfer AAVE funds to the Incentives Controller\\n    ecosystemReserveController.transfer(\\n      AAVE_TOKEN,\\n      INCENTIVES_CONTROLLER_PROXY_ADDRESS,\\n      DISTRIBUTION_AMOUNT\\n    );\\n\\n    // Enable incentives in aTokens and Variable Debt tokens\\n    incentivesController.configureAssets(assets, emissions);\\n\\n    // Sets the end date for the distribution\\n    incentivesController.setDistributionEnd(block.timestamp + DISTRIBUTION_DURATION);\\n  }\\n}\\n\"\r\n    },\r\n    \"@aave/aave-stake/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n * From https://github.com/OpenZeppelin/openzeppelin-contracts\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingPoolAddressesProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\n/**\\n * @title LendingPoolAddressesProvider contract\\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\\n * - Owned by the Aave Governance\\n * @author Aave\\n **/\\ninterface ILendingPoolAddressesProvider {\\n  event MarketIdSet(string newMarketId);\\n  event LendingPoolUpdated(address indexed newAddress);\\n  event ConfigurationAdminUpdated(address indexed newAddress);\\n  event EmergencyAdminUpdated(address indexed newAddress);\\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\\n  event PriceOracleUpdated(address indexed newAddress);\\n  event LendingRateOracleUpdated(address indexed newAddress);\\n  event ProxyCreated(bytes32 id, address indexed newAddress);\\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\\n\\n  function getMarketId() external view returns (string memory);\\n\\n  function setMarketId(string calldata marketId) external;\\n\\n  function setAddress(bytes32 id, address newAddress) external;\\n\\n  function setAddressAsProxy(bytes32 id, address impl) external;\\n\\n  function getAddress(bytes32 id) external view returns (address);\\n\\n  function getLendingPool() external view returns (address);\\n\\n  function setLendingPoolImpl(address pool) external;\\n\\n  function getLendingPoolConfigurator() external view returns (address);\\n\\n  function setLendingPoolConfiguratorImpl(address configurator) external;\\n\\n  function getLendingPoolCollateralManager() external view returns (address);\\n\\n  function setLendingPoolCollateralManager(address manager) external;\\n\\n  function getPoolAdmin() external view returns (address);\\n\\n  function setPoolAdmin(address admin) external;\\n\\n  function getEmergencyAdmin() external view returns (address);\\n\\n  function setEmergencyAdmin(address admin) external;\\n\\n  function getPriceOracle() external view returns (address);\\n\\n  function setPriceOracle(address priceOracle) external;\\n\\n  function getLendingRateOracle() external view returns (address);\\n\\n  function setLendingRateOracle(address lendingRateOracle) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingPoolConfigurator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\ninterface ILendingPoolConfigurator {\\n  function updateAToken(address reserve, address implementation) external;\\n\\n  function updateVariableDebtToken(address reserve, address implementation) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveIncentivesController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {IAaveDistributionManager} from '../interfaces/IAaveDistributionManager.sol';\\n\\ninterface IAaveIncentivesController is IAaveDistributionManager {\\n  \\n  event RewardsAccrued(address indexed user, uint256 amount);\\n  \\n  event RewardsClaimed(\\n    address indexed user,\\n    address indexed to,\\n    address indexed claimer,\\n    uint256 amount\\n  );\\n\\n  event ClaimerSet(address indexed user, address indexed claimer);\\n\\n  /**\\n   * @dev Whitelists an address to claim the rewards on behalf of another address\\n   * @param user The address of the user\\n   * @param claimer The address of the claimer\\n   */\\n  function setClaimer(address user, address claimer) external;\\n\\n  /**\\n   * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\\n   * @param user The address of the user\\n   * @return The claimer address\\n   */\\n  function getClaimer(address user) external view returns (address);\\n\\n  /**\\n   * @dev Configure assets for a certain rewards emission\\n   * @param assets The assets to incentivize\\n   * @param emissionsPerSecond The emission for each asset\\n   */\\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\\n    external;\\n\\n\\n  /**\\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\\n   * @param asset The address of the user\\n   * @param userBalance The balance of the user of the asset in the lending pool\\n   * @param totalSupply The total supply of the asset in the lending pool\\n   **/\\n  function handleAction(\\n    address asset,\\n    uint256 userBalance,\\n    uint256 totalSupply\\n  ) external;\\n\\n  /**\\n   * @dev Returns the total of rewards of an user, already accrued + not yet accrued\\n   * @param user The address of the user\\n   * @return The rewards\\n   **/\\n  function getRewardsBalance(address[] calldata assets, address user)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\\n   * @param amount Amount of rewards to claim\\n   * @param to Address that will be receiving the rewards\\n   * @return Rewards claimed\\n   **/\\n  function claimRewards(\\n    address[] calldata assets,\\n    uint256 amount,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\\n   * be whitelisted via \\\"allowClaimOnBehalf\\\" function by the RewardsAdmin role manager\\n   * @param amount Amount of rewards to claim\\n   * @param user Address to check and claim rewards\\n   * @param to Address that will be receiving the rewards\\n   * @return Rewards claimed\\n   **/\\n  function claimRewardsOnBehalf(\\n    address[] calldata assets,\\n    uint256 amount,\\n    address user,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev returns the unclaimed rewards of the user\\n   * @param user the address of the user\\n   * @return the unclaimed user rewards\\n   */\\n  function getUserUnclaimedRewards(address user) external view returns (uint256);\\n\\n  /**\\n  * @dev for backward compatibility with previous implementation of the Incentives controller\\n  */\\n  function REWARD_TOKEN() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveDistributionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\\n\\ninterface IAaveDistributionManager {\\n  \\n  event AssetConfigUpdated(address indexed asset, uint256 emission);\\n  event AssetIndexUpdated(address indexed asset, uint256 index);\\n  event UserIndexUpdated(address indexed user, address indexed asset, uint256 index);\\n  event DistributionEndUpdated(uint256 newDistributionEnd);\\n\\n  /**\\n  * @dev Sets the end date for the distribution\\n  * @param distributionEnd The end date timestamp\\n  **/\\n  function setDistributionEnd(uint256 distributionEnd) external;\\n\\n  /**\\n  * @dev Gets the end date for the distribution\\n  * @return The end of the distribution\\n  **/\\n  function getDistributionEnd() external view returns (uint256);\\n\\n  /**\\n  * @dev for backwards compatibility with the previous DistributionManager used\\n  * @return The end of the distribution\\n  **/\\n  function DISTRIBUTION_END() external view returns(uint256);\\n\\n   /**\\n   * @dev Returns the data of an user on a distribution\\n   * @param user Address of the user\\n   * @param asset The address of the reference asset of the distribution\\n   * @return The new index\\n   **/\\n   function getUserAssetData(address user, address asset) external view returns (uint256);\\n\\n   /**\\n   * @dev Returns the configuration of the distribution for a certain asset\\n   * @param asset The address of the reference asset of the distribution\\n   * @return The asset index, the emission per second and the last updated timestamp\\n   **/\\n   function getAssetData(address asset) external view returns (uint256, uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/DistributionTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nlibrary DistributionTypes {\\n  struct AssetConfigInput {\\n    uint104 emissionPerSecond;\\n    uint256 totalStaked;\\n    address underlyingAsset;\\n  }\\n\\n  struct UserStakeInput {\\n    address underlyingAsset;\\n    uint256 stakedByUser;\\n    uint256 totalStaked;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveEcosystemReserveController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\ninterface IAaveEcosystemReserveController {\\n  function AAVE_RESERVE_ECOSYSTEM() external view returns (address);\\n\\n  function approve(\\n    address token,\\n    address recipient,\\n    uint256 amount\\n  ) external;\\n\\n  function owner() external view returns (address);\\n\\n  function renounceOwnership() external;\\n\\n  function transfer(\\n    address token,\\n    address recipient,\\n    uint256 amount\\n  ) external;\\n\\n  function transferOwnership(address newOwner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IProposalIncentivesExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\n\\ninterface IProposalIncentivesExecutor {\\n  function execute(\\n    address[6] memory aTokenImplementations,\\n    address[6] memory variableDebtImplementation\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\nlibrary DataTypes {\\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\n  struct ReserveData {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    //the liquidity index. Expressed in ray\\n    uint128 liquidityIndex;\\n    //variable borrow index. Expressed in ray\\n    uint128 variableBorrowIndex;\\n    //the current supply rate. Expressed in ray\\n    uint128 currentLiquidityRate;\\n    //the current variable borrow rate. Expressed in ray\\n    uint128 currentVariableBorrowRate;\\n    //the current stable borrow rate. Expressed in ray\\n    uint128 currentStableBorrowRate;\\n    uint40 lastUpdateTimestamp;\\n    //tokens addresses\\n    address aTokenAddress;\\n    address stableDebtTokenAddress;\\n    address variableDebtTokenAddress;\\n    //address of the interest rate strategy\\n    address interestRateStrategyAddress;\\n    //the id of the reserve. Represents the position in the list of the active reserves\\n    uint8 id;\\n  }\\n\\n  struct ReserveConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 48-55: Decimals\\n    //bit 56: Reserve is active\\n    //bit 57: reserve is frozen\\n    //bit 58: borrowing is enabled\\n    //bit 59: stable rate borrowing enabled\\n    //bit 60-63: reserved\\n    //bit 64-79: reserve factor\\n    uint256 data;\\n  }\\n\\n  struct UserConfigurationMap {\\n    uint256 data;\\n  }\\n\\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingPoolData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {DataTypes} from '../utils/DataTypes.sol';\\n\\ninterface ILendingPoolData {\\n  /**\\n   * @dev Returns the state and configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The state of the reserve\\n   **/\\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IATokenDetailed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\ninterface IATokenDetailed {\\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/PercentageMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\n/**\\n * @title PercentageMath library\\n * @author Aave\\n * @notice Provides functions to perform percentage calculations\\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\\n * @dev Operations are rounded half up\\n **/\\n\\nlibrary PercentageMath {\\n  uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\\n  uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\\n\\n  /**\\n   * @dev Executes a percentage multiplication\\n   * @param value The value of which the percentage needs to be calculated\\n   * @param percentage The percentage of the value to be calculated\\n   * @return The percentage of value\\n   **/\\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {\\n    if (value == 0 || percentage == 0) {\\n      return 0;\\n    }\\n\\n    require(\\n      value <= (type(uint256).max - HALF_PERCENT) / percentage,\\n      'MATH_MULTIPLICATION_OVERFLOW'\\n    );\\n\\n    return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;\\n  }\\n\\n  /**\\n   * @dev Executes a percentage division\\n   * @param value The value of which the percentage needs to be calculated\\n   * @param percentage The percentage of the value to be calculated\\n   * @return The value divided the percentage\\n   **/\\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {\\n    require(percentage != 0, 'MATH_DIVISION_BY_ZERO');\\n    uint256 halfPercentage = percentage / 2;\\n\\n    require(\\n      value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR,\\n      'MATH_MULTIPLICATION_OVERFLOW'\\n    );\\n\\n    return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.7.5;\\n\\n/// @title Optimized overflow and underflow safe math operations\\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\\n/// inspired by uniswap V3\\nlibrary SafeMath {\\n    /// @notice Returns x + y, reverts if sum overflows uint256\\n    /// @param x The augend\\n    /// @param y The addend\\n    /// @return z The sum of x and y\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x);\\n    }\\n\\n    /// @notice Returns x - y, reverts if underflows\\n    /// @param x The minuend\\n    /// @param y The subtrahend\\n    /// @return z The difference of x and y\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x);\\n    }\\n\\n    /// @notice Returns x * y, reverts if overflows\\n    /// @param x The multiplicand\\n    /// @param y The multiplier\\n    /// @return z The product of x and y\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(x == 0 || (z = x * y) / x == y);\\n    }\\n\\n    function div(uint256 x, uint256 y) internal pure returns(uint256) {\\n        // no need to check for division by zero - solidity already reverts\\n        return x / y;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[6]\",\"name\":\"aTokenImplementations\",\"type\":\"address[6]\"},{\"internalType\":\"address[6]\",\"name\":\"variableDebtImplementations\",\"type\":\"address[6]\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ProposalIncentivesExecutor","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}