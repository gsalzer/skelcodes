{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IMorpherStaking.sol\":{\"content\":\"pragma solidity 0.5.16;\\ncontract IMorpherStaking {\\n    \\n    function lastReward() public view returns (uint256);\\n\\n    function totalShares() public view returns (uint256);\\n\\n    function interestRate() public view returns (uint256);\\n\\n    function lockupPeriod() public view returns (uint256);\\n    \\n    function minimumStake() public view returns (uint256);\\n\\n    function stakingAdmin() public view returns (address);\\n\\n    function updatePoolShareValue() public returns (uint256 _newPoolShareValue) ;\\n\\n    function stake(uint256 _amount) public returns (uint256 _poolShares);\\n\\n    function unStake(uint256 _numOfShares) public returns (uint256 _amount);\\n\\n}\\n\"},\"IMorpherState.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\ncontract IMorpherState {\\n    function setPosition(\\n        address _address,\\n        bytes32 _marketId,\\n        uint256 _timeStamp,\\n        uint256 _longShares,\\n        uint256 _shortShares,\\n        uint256 _meanEntryPrice,\\n        uint256 _meanEntrySpread,\\n        uint256 _meanEntryLeverage,\\n        uint256 _liquidationPrice\\n    ) public; \\n\\n    function getPosition(\\n        address _address,\\n        bytes32 _marketId\\n    ) public view returns (\\n        uint256 _longShares,\\n        uint256 _shortShares,\\n        uint256 _meanEntryPrice,\\n        uint256 _meanEntrySpread,\\n        uint256 _meanEntryLeverage,\\n        uint256 _liquidationPrice\\n    );\\n\\n    function getLastUpdated(address _address, bytes32 _marketId) public view returns (uint256 _lastUpdated);\\n\\n    function transfer(address _from, address _to, uint256 _token) public;\\n    \\n    function balanceOf(address _tokenOwner) public view returns (uint256 balance);\\n\\n    function mint(address _address, uint256 _token) public;\\n\\n    function burn(address _address, uint256 _token) public;\\n\\n     function getSideChainOperator() public view returns (address _address);\\n\\n    function inactivityPeriod() public view returns (uint256);\\n\\n    function getSideChainMerkleRootWrittenAtTime() public view returns(uint256 _sideChainMerkleRoot);\\n\\n    function fastTransfersEnabled() public view returns(bool);\\n\\n    function mainChain() public view returns(bool);\\n\\n    function setInactivityPeriod(uint256 _periodLength) public;\\n\\n    function disableFastWithdraws() public;\\n\\n    function setSideChainMerkleRoot(bytes32 _sideChainMerkleRoot) public;\\n\\n    function resetLast24HoursAmountWithdrawn() public;\\n\\n    function set24HourWithdrawLimit(uint256 _limit) public;\\n\\n    function getTokenSentToLinkedChain(address _address) public view returns (uint256 _token);\\n\\n    function getTokenClaimedOnThisChain(address _address) public view returns (uint256 _token);\\n\\n    function getTokenSentToLinkedChainTime(address _address) public view returns (uint256 _timeStamp);\\n\\n    function lastWithdrawLimitReductionTime() public view returns (uint256);\\n\\n    function withdrawLimit24Hours() public view returns (uint256);\\n\\n    function update24HoursWithdrawLimit(uint256 _amount) public;\\n\\n    function last24HoursAmountWithdrawn() public view returns (uint256);\\n\\n    function setTokenSentToLinkedChain(address _address, uint256 _token) public;\\n\\n    function setTokenClaimedOnThisChain(address _address, uint256 _token) public;\\n\\n    function add24HoursWithdrawn(uint256 _amount) public;\\n\\n    function getPositionHash(\\n        address _address,\\n        bytes32 _marketId,\\n        uint256 _timeStamp,\\n        uint256 _longShares,\\n        uint256 _shortShares,\\n        uint256 _meanEntryPrice,\\n        uint256 _meanEntrySpread,\\n        uint256 _meanEntryLeverage,\\n        uint256 _liquidationPrice\\n    ) public pure returns (bytes32 _hash);\\n\\n    function getPositionClaimedOnMainChain(bytes32 _positionHash) public view returns (bool _alreadyClaimed);\\n\\n    function setPositionClaimedOnMainChain(bytes32 _positionHash) public;\\n\\n     function getBalanceHash(address _address, uint256 _balance) public pure returns (bytes32 _hash);\\n\\n     function getSideChainMerkleRoot() public view returns(bytes32 _sideChainMerkleRoot);\\n\\n     function getBridgeNonce() public returns (uint256 _nonce);\\n}\"},\"IMorpherToken.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\ninterface IMorpherToken {\\n    /**\\n     * Emits a {Transfer} event in ERC-20 token contract.\\n     */\\n    function emitTransfer(address _from, address _to, uint256 _amount) external;\\n}\\n\"},\"MerkleProof.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        require(proof.length \\u003c 100, \\\"MerkleProof: proof too long. Use only sibling hashes.\\\");\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i \\u003c proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash \\u003c proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"},\"MorpherBridge.sol\":{\"content\":\"// ------------------------------------------------------------------------\\n// MorpherBridge\\n// Handles deposit to and withdraws from the side chain, writing of the merkle\\n// root to the main chain by the side chain operator, and enforces a rolling 24 hours\\n// token withdraw limit from side chain to main chain.\\n// If side chain operator doesn\\u0027t write a merkle root hash to main chain for more than\\n// 72 hours positions and balaces from side chain can be transferred to main chain.\\n// ------------------------------------------------------------------------\\n\\npragma solidity 0.5.16;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IMorpherState.sol\\\";\\nimport \\\"./MerkleProof.sol\\\";\\n\\ncontract MorpherBridge is Ownable {\\n\\n    IMorpherState state;\\n    using SafeMath for uint256;\\n\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) withdrawalPerDay; //[address][day] = withdrawalAmount\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) withdrawalPerMonth; //[address][month] = withdrawalAmount\\n\\n    uint256 public withdrawalLimitDaily = 200000 * (10**18); //200k MPH per day\\n    uint256 public withdrawalLimitMonthly = 1000000 * (10 ** 18); //1M MPH per month\\n\\n    event TransferToLinkedChain(\\n        address indexed from,\\n        uint256 tokens,\\n        uint256 totalTokenSent,\\n        uint256 timeStamp,\\n        uint256 transferNonce,\\n        bytes32 indexed transferHash\\n    );\\n    event TrustlessWithdrawFromSideChain(address indexed from, uint256 tokens);\\n    event OperatorChainTransfer(address indexed from, uint256 tokens, bytes32 sidechainTransactionHash);\\n    event ClaimFailedTransferToSidechain(address indexed from, uint256 tokens);\\n    event PositionRecoveryFromSideChain(address indexed from, bytes32 positionHash);\\n    event TokenRecoveryFromSideChain(address indexed from, bytes32 positionHash);\\n    event SideChainMerkleRootUpdated(bytes32 _rootHash);\\n    event WithdrawLimitReset();\\n    event WithdrawLimitChanged(uint256 _withdrawLimit);\\n    event WithdrawLimitDailyChanged(uint256 _oldLimit, uint256 _newLimit);\\n    event WithdrawLimitMonthlyChanged(uint256 _oldLimit, uint256 _newLimit);\\n    event LinkState(address _address);\\n\\n    constructor(address _stateAddress, address _coldStorageOwnerAddress) public {\\n        setMorpherState(_stateAddress);\\n        transferOwnership(_coldStorageOwnerAddress);\\n    }\\n\\n    modifier onlySideChainOperator {\\n        require(msg.sender == state.getSideChainOperator(), \\\"MorpherBridge: Function can only be called by Sidechain Operator.\\\");\\n        _;\\n    }\\n\\n    modifier sideChainInactive {\\n        require(now - state.inactivityPeriod() \\u003e state.getSideChainMerkleRootWrittenAtTime(), \\\"MorpherBridge: Function can only be called if sidechain is inactive.\\\");\\n        _;\\n    }\\n    \\n    modifier fastTransfers {\\n        require(state.fastTransfersEnabled() == true, \\\"MorpherBridge: Fast transfers have been disabled permanently.\\\");\\n        _;\\n    }\\n\\n    modifier onlyMainchain {\\n        require(state.mainChain() == true, \\\"MorpherBridge: Function can only be executed on Ethereum.\\\" );\\n        _;\\n    }\\n    \\n    // ------------------------------------------------------------------------\\n    // Links Token Contract with State\\n    // ------------------------------------------------------------------------\\n    function setMorpherState(address _stateAddress) public onlyOwner {\\n        state = IMorpherState(_stateAddress);\\n        emit LinkState(_stateAddress);\\n    }\\n\\n    function setInactivityPeriod(uint256 _periodInSeconds) private {\\n        state.setInactivityPeriod(_periodInSeconds);\\n    }\\n\\n    function disableFastTransfers() public onlyOwner  {\\n        state.disableFastWithdraws();\\n    }\\n\\n    function updateSideChainMerkleRoot(bytes32 _rootHash) public onlySideChainOperator {\\n        state.setSideChainMerkleRoot(_rootHash);\\n        emit SideChainMerkleRootUpdated(_rootHash);\\n    }\\n\\n    function resetLast24HoursAmountWithdrawn() public onlySideChainOperator {\\n        state.resetLast24HoursAmountWithdrawn();\\n        emit WithdrawLimitReset();\\n    }\\n\\n    function set24HourWithdrawLimit(uint256 _withdrawLimit) public onlySideChainOperator {\\n        state.set24HourWithdrawLimit(_withdrawLimit);\\n        emit WithdrawLimitChanged(_withdrawLimit);\\n    }\\n\\n    function updateWithdrawLimitDaily(uint256 _withdrawLimit) public onlySideChainOperator {\\n        emit WithdrawLimitDailyChanged(withdrawalLimitDaily, _withdrawLimit);\\n        withdrawalLimitDaily = _withdrawLimit;\\n    }\\n\\n    function updateWithdrawLimitMonthly(uint256 _withdrawLimit) public onlySideChainOperator {\\n        emit WithdrawLimitMonthlyChanged(withdrawalLimitMonthly, _withdrawLimit);\\n        withdrawalLimitMonthly = _withdrawLimit;\\n    }\\n\\n    function getTokenSentToLinkedChain(address _address) public view returns (uint256 _token) {\\n        return state.getTokenSentToLinkedChain(_address);\\n    }\\n\\n    function getTokenClaimedOnThisChain(address _address) public view returns (uint256 _token)  {\\n        return state.getTokenClaimedOnThisChain(_address);\\n    }\\n\\n    function getTokenSentToLinkedChainTime(address _address) public view returns (uint256 _time)  {\\n        return state.getTokenSentToLinkedChainTime(_address);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // verifyWithdrawOk(uint256 _amount)\\n    // Checks if creating _amount token on main chain does not violate the 24 hour transfer limit\\n    // ------------------------------------------------------------------------\\n    function verifyWithdrawOk(uint256 _amount) public returns (bool _authorized) {\\n        uint256 _lastWithdrawLimitReductionTime = state.lastWithdrawLimitReductionTime();\\n        uint256 _withdrawLimit24Hours = state.withdrawLimit24Hours();\\n        \\n        if (now \\u003e _lastWithdrawLimitReductionTime) {\\n            uint256 _timePassed = now.sub(_lastWithdrawLimitReductionTime);\\n            state.update24HoursWithdrawLimit(_timePassed.mul(_withdrawLimit24Hours).div(1 days));\\n        }\\n        \\n        if (state.last24HoursAmountWithdrawn().add(_amount) \\u003c= _withdrawLimit24Hours) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function isNotDailyLimitExceeding(uint256 _amount) public view returns(bool) {\\n        return (withdrawalPerDay[msg.sender][block.timestamp / 1 days].add(_amount) \\u003c= withdrawalLimitDaily);\\n    }\\n    function isNotMonthlyLimitExceeding(uint256 _amount) public view returns(bool) {\\n        return (withdrawalPerMonth[msg.sender][block.timestamp / 30 days].add(_amount) \\u003c= withdrawalLimitMonthly);\\n    }\\n\\n    function verifyUpdateDailyLimit(uint256 _amount) public {\\n        require(isNotDailyLimitExceeding(_amount), \\\"MorpherBridge: Withdrawal Amount exceeds daily limit\\\");\\n        withdrawalPerDay[msg.sender][block.timestamp / 1 days] = withdrawalPerDay[msg.sender][block.timestamp / 1 days].add(_amount);\\n    }\\n\\n    function verifyUpdateMonthlyLimit(uint256 _amount) public {\\n        require(isNotMonthlyLimitExceeding(_amount), \\\"MorpherBridge: Withdrawal Amount exceeds monthly limit\\\");\\n        withdrawalPerMonth[msg.sender][block.timestamp / 30 days] = withdrawalPerMonth[msg.sender][block.timestamp / 30 days].add(_amount);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // transferToSideChain(uint256 _tokens)\\n    // Transfer token to Morpher\\u0027s side chain to trade without fees and near instant\\n    // settlement.\\n    // - Owner\\u0027s account must have sufficient balance to transfer\\n    // - 0 value transfers are not supported\\n    // Token are burned on the main chain and are created and credited to msg.sender\\n    //  on the side chain\\n    // ------------------------------------------------------------------------\\n    function transferToSideChain(uint256 _tokens) public {\\n        require(_tokens \\u003e= 0, \\\"MorpherBridge: Amount of tokens must be positive.\\\");\\n        require(state.balanceOf(msg.sender) \\u003e= _tokens, \\\"MorpherBridge: Insufficient balance.\\\");\\n        state.burn(msg.sender, _tokens);\\n        uint256 _newTokenSentToLinkedChain = getTokenSentToLinkedChain(msg.sender).add(_tokens);\\n        uint256 _transferNonce = state.getBridgeNonce();\\n        uint256 _timeStamp = now;\\n        bytes32 _transferHash = keccak256(\\n            abi.encodePacked(\\n                msg.sender,\\n                _tokens,\\n                _newTokenSentToLinkedChain,\\n                _timeStamp,\\n                _transferNonce\\n            )\\n        );\\n        state.setTokenSentToLinkedChain(msg.sender, _newTokenSentToLinkedChain);\\n        emit TransferToLinkedChain(msg.sender, _tokens, _newTokenSentToLinkedChain, _timeStamp, _transferNonce, _transferHash);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // fastTransferFromSideChain(uint256 _numOfToken, uint256 _tokenBurnedOnLinkedChain, bytes32[] memory _proof)\\n    // The sidechain operator can credit users with token they burend on the sidechain. Transfers\\n    // happen immediately. To be removed after Beta.\\n    // ------------------------------------------------------------------------\\n    function fastTransferFromSideChain(address _address, uint256 _numOfToken, uint256 _tokenBurnedOnLinkedChain, bytes32 _sidechainTransactionHash) public onlySideChainOperator fastTransfers {\\n        uint256 _tokenClaimed = state.getTokenClaimedOnThisChain(_address);\\n        require(verifyWithdrawOk(_numOfToken), \\\"MorpherBridge: Withdraw amount exceeds permitted 24 hour limit. Please try again in a few hours.\\\");\\n        require(_tokenClaimed.add(_numOfToken) \\u003c= _tokenBurnedOnLinkedChain, \\\"MorpherBridge: Token amount exceeds token deleted on linked chain.\\\");\\n        _chainTransfer(_address, _tokenClaimed, _numOfToken);\\n        emit OperatorChainTransfer(_address, _numOfToken, _sidechainTransactionHash);\\n    }\\n    \\n    // ------------------------------------------------------------------------\\n    // trustlessTransferFromSideChain(uint256 _numOfToken, uint256 _claimLimit, bytes32[] memory _proof)\\n    // Performs a merkle proof on the number of token that have been burned by the user on the side chain.\\n    // If the number of token claimed on the main chain is less than the number of burned token on the side chain\\n    // the difference (or less) can be claimed on the main chain.\\n    // ------------------------------------------------------------------------\\n    function trustlessTransferFromLinkedChain(uint256 _numOfToken, uint256 _claimLimit, bytes32[] memory _proof) public {\\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _claimLimit));\\n        uint256 _tokenClaimed = state.getTokenClaimedOnThisChain(msg.sender);        \\n        require(mProof(_proof, leaf), \\\"MorpherBridge: Merkle Proof failed. Please make sure you entered the correct claim limit.\\\");\\n        require(verifyWithdrawOk(_numOfToken), \\\"MorpherBridge: Withdraw amount exceeds permitted 24 hour limit. Please try again in a few hours.\\\");\\n        verifyUpdateDailyLimit(_numOfToken);\\n        verifyUpdateMonthlyLimit(_numOfToken);\\n        require(_tokenClaimed.add(_numOfToken) \\u003c= _claimLimit, \\\"MorpherBridge: Token amount exceeds token deleted on linked chain.\\\");     \\n        _chainTransfer(msg.sender, _tokenClaimed, _numOfToken);   \\n        emit TrustlessWithdrawFromSideChain(msg.sender, _numOfToken);\\n    }\\n    \\n    // ------------------------------------------------------------------------\\n    // _chainTransfer(address _address, uint256 _tokenClaimed, uint256 _numOfToken)\\n    // Creates token on the chain for the user after proving their distruction on the \\n    // linked chain has been proven before \\n    // ------------------------------------------------------------------------\\n    function _chainTransfer(address _address, uint256 _tokenClaimed, uint256 _numOfToken) private {\\n        state.setTokenClaimedOnThisChain(_address, _tokenClaimed.add(_numOfToken));\\n        state.add24HoursWithdrawn(_numOfToken);\\n        state.mint(_address, _numOfToken);\\n    }\\n        \\n    // ------------------------------------------------------------------------\\n    // claimFailedTransferToSidechain(uint256 _wrongSideChainBalance, bytes32[] memory _proof)\\n    // If token sent to side chain were not credited to the user on the side chain within inactivityPeriod\\n    // they can reclaim the token on the main chain by submitting the proof that their\\n    // side chain balance is less than the number of token sent from main chain.\\n    // ------------------------------------------------------------------------\\n    function claimFailedTransferToSidechain(uint256 _wrongSideChainBalance, bytes32[] memory _proof) public {\\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _wrongSideChainBalance));\\n        uint256 _tokenSentToLinkedChain = getTokenSentToLinkedChain(msg.sender);\\n        uint256 _tokenSentToLinkedChainTime = getTokenSentToLinkedChainTime(msg.sender);\\n        uint256 _inactivityPeriod = state.inactivityPeriod();\\n        \\n        require(now \\u003e _tokenSentToLinkedChainTime.add(_inactivityPeriod), \\\"MorpherBridge: Failed deposits can only be claimed after inactivity period.\\\");\\n        require(_wrongSideChainBalance \\u003c _tokenSentToLinkedChain, \\\"MorpherBridge: Other chain credit is greater equal to wrongSideChainBalance.\\\");\\n        require(verifyWithdrawOk(_tokenSentToLinkedChain.sub(_wrongSideChainBalance)), \\\"MorpherBridge: Claim amount exceeds permitted 24 hour limit.\\\");\\n        require(mProof(_proof, leaf), \\\"MorpherBridge: Merkle Proof failed. Enter total amount of deposits on side chain.\\\");\\n        \\n        uint256 _claimAmount = _tokenSentToLinkedChain.sub(_wrongSideChainBalance);\\n        state.setTokenSentToLinkedChain(msg.sender, _tokenSentToLinkedChain.sub(_claimAmount));\\n        state.add24HoursWithdrawn(_claimAmount);\\n        state.mint(msg.sender, _claimAmount);\\n        emit ClaimFailedTransferToSidechain(msg.sender, _claimAmount);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // recoverPositionFromSideChain(bytes32[] memory _proof, bytes32 _leaf, bytes32 _marketId, uint256 _timeStamp, uint256 _longShares, uint256 _shortShares, uint256 _meanEntryPrice, uint256 _meanEntrySpread, uint256 _meanEntryLeverage)\\n    // Failsafe against side chain operator becoming inactive or withholding Times (Time withhold attack).\\n    // After 72 hours of no update of the side chain merkle root users can withdraw their last recorded\\n    // positions from side chain to main chain. Overwrites eventually existing position on main chain.\\n    // ------------------------------------------------------------------------\\n    function recoverPositionFromSideChain(\\n        bytes32[] memory _proof,\\n        bytes32 _leaf,\\n        bytes32 _marketId,\\n        uint256 _timeStamp,\\n        uint256 _longShares,\\n        uint256 _shortShares,\\n        uint256 _meanEntryPrice,\\n        uint256 _meanEntrySpread,\\n        uint256 _meanEntryLeverage,\\n        uint256 _liquidationPrice\\n        ) public sideChainInactive onlyMainchain {\\n        require(_leaf == state.getPositionHash(msg.sender, _marketId, _timeStamp, _longShares, _shortShares, _meanEntryPrice, _meanEntrySpread, _meanEntryLeverage, _liquidationPrice), \\\"MorpherBridge: leaf does not equal position hash.\\\");\\n        require(state.getPositionClaimedOnMainChain(_leaf) == false, \\\"MorpherBridge: Position already transferred.\\\");\\n        require(mProof(_proof,_leaf) == true, \\\"MorpherBridge: Merkle proof failed.\\\");\\n        state.setPositionClaimedOnMainChain(_leaf);\\n        state.setPosition(msg.sender, _marketId, _timeStamp, _longShares, _shortShares, _meanEntryPrice, _meanEntrySpread, _meanEntryLeverage, _liquidationPrice);\\n        emit PositionRecoveryFromSideChain(msg.sender, _leaf);\\n        // Remark: After resuming operations side chain operator has 72 hours to sync and eliminate transferred positions on side chain to avoid double spend\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // recoverTokenFromSideChain(bytes32[] memory _proof, bytes32 _leaf, bytes32 _marketId, uint256 _timeStamp, uint256 _longShares, uint256 _shortShares, uint256 _meanEntryPrice, uint256 _meanEntrySpread, uint256 _meanEntryLeverage)\\n    // Failsafe against side chain operator becoming inactive or withholding times (time withhold attack).\\n    // After 72 hours of no update of the side chain merkle root users can withdraw their last recorded\\n    // token balance from side chain to main chain.\\n    // ------------------------------------------------------------------------\\n    function recoverTokenFromSideChain(bytes32[] memory _proof, bytes32 _leaf, uint256 _balance) public sideChainInactive onlyMainchain {\\n        // Require side chain root hash not set on Mainchain for more than 72 hours (=3 days)\\n        require(_leaf == state.getBalanceHash(msg.sender, _balance), \\\"MorpherBridge: Wrong balance.\\\");\\n        require(state.getPositionClaimedOnMainChain(_leaf) == false, \\\"MorpherBridge: Token already transferred.\\\");\\n        require(mProof(_proof,_leaf) == true, \\\"MorpherBridge: Merkle proof failed.\\\");\\n        require(verifyWithdrawOk(_balance), \\\"MorpherBridge: Withdraw amount exceeds permitted 24 hour limit.\\\");\\n        state.setPositionClaimedOnMainChain(_leaf);\\n        _chainTransfer(msg.sender, state.getTokenClaimedOnThisChain(msg.sender), _balance);\\n        emit TokenRecoveryFromSideChain(msg.sender, _leaf);\\n        // Remark: Side chain operator must adjust side chain balances for token recoveries before restarting operations to avoid double spend\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // mProof(bytes32[] memory _proof, bytes32 _leaf)\\n    // Computes merkle proof against the root hash of the sidechain stored in Morpher state\\n    // ------------------------------------------------------------------------\\n    function mProof(bytes32[] memory _proof, bytes32 _leaf) public view returns(bool _isTrue) {\\n        return MerkleProof.verify(_proof, state.getSideChainMerkleRoot(), _leaf);\\n    }\\n}\\n\"},\"MorpherEscrow.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n// ----------------------------------------------------------------------------------\\n// Escrow contract to safely store and release the token allocated to Morpher at\\n// protocol inception\\n// ----------------------------------------------------------------------------------\\n\\ncontract MorpherEscrow is Ownable{\\n    using SafeMath for uint256;\\n\\n    uint256 public lastEscrowTransferTime;\\n    address public recipient;\\n    address public morpherToken;\\n\\n    uint256 public constant RELEASEAMOUNT = 10**25;\\n    uint256 public constant RELEASEPERIOD = 30 days;\\n\\n    event EscrowReleased(uint256 _released, uint256 _leftInEscrow);\\n\\n    constructor(address _recipientAddress, address _morpherToken, address _coldStorageOwnerAddress) public {\\n        setRecipientAddress(_recipientAddress);\\n        setMorpherTokenAddress(_morpherToken);\\n        lastEscrowTransferTime = now;\\n        transferOwnership(_coldStorageOwnerAddress);\\n    }\\n\\n    // ----------------------------------------------------------------------------------\\n    // Owner can modify recipient address and update morpherToken adddress\\n    // ----------------------------------------------------------------------------------\\n    function setRecipientAddress(address _recipientAddress) public onlyOwner {\\n        recipient = _recipientAddress;\\n    }\\n\\n    function setMorpherTokenAddress(address _address) public onlyOwner {\\n        morpherToken = _address;\\n    }\\n\\n    // ----------------------------------------------------------------------------------\\n    // Anyone can release funds from escrow if enough time has elapsed\\n    // Every 30 days 1% of the total initial supply or 10m token are released to Morpher\\n    // ----------------------------------------------------------------------------------\\n    function releaseFromEscrow() public {\\n        require(IERC20(morpherToken).balanceOf(address(this)) \\u003e 0, \\\"No funds left in escrow.\\\");\\n        uint256 _releasedAmount;\\n        if (now \\u003e lastEscrowTransferTime.add(RELEASEPERIOD)) {\\n            if (IERC20(morpherToken).balanceOf(address(this)) \\u003e RELEASEAMOUNT) {\\n                _releasedAmount = RELEASEAMOUNT;\\n            } else {\\n                _releasedAmount = IERC20(morpherToken).balanceOf(address(this));\\n            }\\n            IERC20(morpherToken).transfer(recipient, _releasedAmount);\\n            lastEscrowTransferTime = lastEscrowTransferTime.add(RELEASEPERIOD);\\n            emit EscrowReleased(_releasedAmount, IERC20(morpherToken).balanceOf(address(this)));\\n        }\\n    }\\n}\\n\"},\"MorpherFaucet.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./MorpherToken.sol\\\";\\n\\n// ----------------------------------------------------------------------------------\\n// Holds the Faucet Token balance on contract addressrdrop.\\n// Users can topup to fillUpAmount\\n// ----------------------------------------------------------------------------------\\n\\ncontract MorpherFaucet is Ownable {\\n    using SafeMath for uint256;\\n\\n    MorpherToken morpherToken;\\n\\n    uint public fillUpAmount; //100 * 10**18; //fill up to 100 MPH.\\n\\n    event MorpherFaucetTopUp(address indexed _receiver, uint _amount);\\n    event MorpherFaucetFillUpAmountChanged(uint _oldAmount, uint _newAmount);\\n\\n    constructor(address payable _morpherToken, address _coldStorageOwnerAddress, uint _fillUpAmount) public {\\n        morpherToken = MorpherToken(_morpherToken);\\n        transferOwnership(_coldStorageOwnerAddress);\\n        setFillUpAmount(_fillUpAmount);\\n    }\\n  \\n    function setMorpherTokenAddress(address payable _address) public onlyOwner {\\n        morpherToken = MorpherToken(_address);\\n    }\\n\\n    function setFillUpAmount(uint _newFillUpAmount) public onlyOwner {\\n        emit MorpherFaucetFillUpAmountChanged(fillUpAmount, _newFillUpAmount);\\n        fillUpAmount = _newFillUpAmount;\\n    }\\n\\n\\n    /**\\n     * Only important function: User can top-up to his max amount. Needs to have less than fillUpAmount, otherwise it will fail.\\n     */\\n    function topUpToken() public {\\n        require(morpherToken.balanceOf(msg.sender) \\u003c fillUpAmount, \\\"FILLUP_AMOUNT_REACHED\\\");\\n        morpherToken.transfer(msg.sender, fillUpAmount.sub(morpherToken.balanceOf(msg.sender)));\\n        emit MorpherFaucetTopUp(msg.sender, fillUpAmount.sub(morpherToken.balanceOf(msg.sender)));\\n    }\\n\\n    function () external payable {\\n        revert(\\\"MorpherFaucet: you can\\u0027t deposit Ether here\\\");\\n    }\\n\\n\\n}\\n\"},\"MorpherGovernance.sol\":{\"content\":\"pragma solidity 0.5.16;\\n// ------------------------------------------------------------------------\\n// Morpher Governance (MAIN CHAIN ONLY)\\n//\\n// Every user able and willig to lock up sufficient token can become a validator\\n// of the Morpher protocol. Validators function similiar to a board of directors\\n// and vote on the protocol Administrator and the Oracle contract.\\n// The Administrator (=Protocol CEO) has the power to add/delete markets and to\\n// pause the contracts to allow for updates.\\n// The Oracle contract is the address of the contract allowed to fetch prices\\n// from outside the smart contract.\\n//\\n// It becomes progressively harder to become a valdiator. Each new validator\\n// has to lock up (numberOfValidators + 1) * 10m Morpher token. Upon stepping\\n// down as validator only 99% of the locked up token are returned, the other 1%\\n// are burned.\\n//\\n// Governance is expected to become more sophisticated in the future\\n// ------------------------------------------------------------------------\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./MorpherState.sol\\\";\\n\\ncontract MorpherGovernance is Ownable {\\n\\n    using SafeMath for uint256;\\n    MorpherState state;\\n    \\n    event BecomeValidator(address indexed _sender, uint256 indexed _myValidatorIndex);\\n    event StepDownAsValidator(address indexed _sender, uint256 indexed _myValidatorIndex);\\n    event ElectedAdministrator(address indexed _administratorAddress, uint256 _votes);\\n    event ElectedOracle(address indexed _oracleAddress, uint256 _votes);\\n\\n    uint256 public constant MINVALIDATORLOCKUP = 10**25;\\n    uint256 public constant MAXVALIDATORS = 21;\\n    uint256 public constant VALIDATORWARMUPPERIOD = 7 days;\\n\\n    uint256 public numberOfValidators;\\n    uint256 public lastValidatorJoined;\\n    uint256 public rewardBasisPoints;\\n\\n    address public morpherToken;\\n\\n    mapping(address =\\u003e uint256) private validatorIndex;\\n    mapping(address =\\u003e uint256) private validatorJoinedAtTime;\\n    mapping(uint256 =\\u003e address) private validatorAddress;\\n    mapping(address =\\u003e address) private oracleVote;\\n    mapping(address =\\u003e address) private administratorVote;\\n    mapping(address =\\u003e uint256) private countVotes;\\n\\n    constructor(address _stateAddress, address _coldStorageOwnerAddress) public {\\n        setMorpherState(_stateAddress);\\n        transferOwnership(_coldStorageOwnerAddress);        \\n    }\\n    \\n    modifier onlyValidator() {\\n        require(isValidator(msg.sender), \\\"MorpherGovernance: Only Validators can invoke that function.\\\");\\n        _;\\n    }\\n\\n    function setMorpherState(address _stateAddress) private {\\n        state = MorpherState(_stateAddress);\\n    }\\n\\n    function setMorpherTokenAddress(address _address) public onlyOwner {\\n        morpherToken = _address;\\n    }\\n\\n    function getValidatorAddress(uint256 _index) public view returns (address _address) {\\n        return validatorAddress[_index];\\n    }\\n\\n    function getValidatorIndex(address _address) public view returns (uint256 _index) {\\n        return validatorIndex[_address];\\n    }\\n\\n    function isValidator(address _address) public view returns (bool) {\\n        return validatorIndex[_address] \\u003e 0;\\n    }\\n\\n    function setOracle(address  _oracleAddress) private {\\n        state.setOracleContract(_oracleAddress);\\n    }\\n\\n    function setAdministrator(address _administratorAddress) private {\\n        state.setAdministrator(_administratorAddress);\\n    }\\n\\n    function getMorpherAdministrator() public view returns (address _address) {\\n        return state.getAdministrator();\\n    }\\n\\n    function getMorpherOracle() public view returns (address _address)  {\\n        return state.getOracleContract();\\n    }\\n\\n    function getOracleVote(address _address) public view returns (address _votedOracleAddress) {\\n        return oracleVote[_address];\\n    }\\n\\n    function becomeValidator() public {\\n        // To become a validator you have to lock up 10m * (number of validators + 1) Morpher Token in escrow\\n        // After a warmup period of 7 days the new validator can vote on Oracle contract and protocol Administrator\\n        uint256 _requiredAmount = MINVALIDATORLOCKUP.mul(numberOfValidators.add(1));\\n        require(state.balanceOf(msg.sender) \\u003e= _requiredAmount, \\\"MorpherGovernance: Insufficient balance to become Validator.\\\");\\n        require(isValidator(msg.sender) == false, \\\"MorpherGovernance: Address is already Validator.\\\");\\n        require(numberOfValidators \\u003c= MAXVALIDATORS, \\\"MorpherGovernance: number of Validators can not exceed Max Validators.\\\");\\n        state.transfer(msg.sender, address(this), _requiredAmount);\\n        numberOfValidators = numberOfValidators.add(1);\\n        validatorIndex[msg.sender] = numberOfValidators;\\n        validatorJoinedAtTime[msg.sender] = now;\\n        lastValidatorJoined = now;\\n        validatorAddress[numberOfValidators] = msg.sender;\\n        emit BecomeValidator(msg.sender, numberOfValidators);\\n    }\\n\\n    function stepDownValidator() public onlyValidator {\\n        // Stepping down as validator nullifies the validator\\u0027s votes and releases his token\\n        // from escrow. If the validator stepping down is not the validator that joined last,\\n        // all validators who joined after the validator stepping down receive 10^7 * 0.99 token from\\n        // escrow, and their validator ordinal number is reduced by one. E.g. if validator 3 of 5 steps down\\n        // validator 4 becomes validator 3, and validator 5 becomes validator 4. Both receive 10^7 * 0.99 token\\n        // from escrow, as their new position requires fewer token in lockup. 1% of the token released from escrow \\n        // are burned for every validator receiving a payout. \\n        // Burning prevents vote delay attacks: validators stepping down and re-joining could\\n        // delay votes for VALIDATORWARMUPPERIOD.\\n        uint256 _myValidatorIndex = validatorIndex[msg.sender];\\n        require(state.balanceOf(address(this)) \\u003e= MINVALIDATORLOCKUP.mul(numberOfValidators), \\\"MorpherGovernance: Escrow does not have enough funds. Should not happen.\\\");\\n        // Stepping down as validator potentially releases token to the other validatorAddresses\\n        for (uint256 i = _myValidatorIndex; i \\u003c numberOfValidators; i++) {\\n            validatorAddress[i] = validatorAddress[i+1];\\n            validatorIndex[validatorAddress[i]] = i;\\n            // Release 9.9m of token to every validator moving up, burn 0.1m token\\n            state.transfer(address(this), validatorAddress[i], MINVALIDATORLOCKUP.div(100).mul(99));\\n            state.burn(address(this), MINVALIDATORLOCKUP.div(100));\\n        }\\n        // Release 99% of escrow token of validator dropping out, burn 1%\\n        validatorAddress[numberOfValidators] = address(0);\\n        validatorIndex[msg.sender] = 0;\\n        validatorJoinedAtTime[msg.sender] = 0;\\n        oracleVote[msg.sender] = address(0);\\n        administratorVote[msg.sender] = address(0);\\n        numberOfValidators = numberOfValidators.sub(1);\\n        countOracleVote();\\n        countAdministratorVote();\\n        state.transfer(address(this), msg.sender, MINVALIDATORLOCKUP.mul(_myValidatorIndex).div(100).mul(99));\\n        state.burn(address(this), MINVALIDATORLOCKUP.mul(_myValidatorIndex).div(100));\\n        emit StepDownAsValidator(msg.sender, validatorIndex[msg.sender]);\\n    }\\n\\n    function voteOracle(address _oracleAddress) public onlyValidator {\\n        require(validatorJoinedAtTime[msg.sender].add(VALIDATORWARMUPPERIOD) \\u003c now, \\\"MorpherGovernance: Validator was just appointed and is not eligible to vote yet.\\\");\\n        require(lastValidatorJoined.add(VALIDATORWARMUPPERIOD) \\u003c now, \\\"MorpherGovernance: New validator joined the board recently, please wait for the end of the warm up period.\\\");\\n        oracleVote[msg.sender] = _oracleAddress;\\n        // Count Oracle Votes\\n        (address _votedOracleAddress, uint256 _votes) = countOracleVote();\\n        emit ElectedOracle(_votedOracleAddress, _votes);\\n    }\\n\\n    function voteAdministrator(address _administratorAddress) public onlyValidator {\\n        require(validatorJoinedAtTime[msg.sender].add(VALIDATORWARMUPPERIOD) \\u003c now, \\\"MorpherGovernance: Validator was just appointed and is not eligible to vote yet.\\\");\\n        require(lastValidatorJoined.add(VALIDATORWARMUPPERIOD) \\u003c now, \\\"MorpherGovernance: New validator joined the board recently, please wait for the end of the warm up period.\\\");\\n        administratorVote[msg.sender] = _administratorAddress;\\n        // Count Administrator Votes\\n        (address _appointedAdministrator, uint256 _votes) = countAdministratorVote();\\n        emit ElectedAdministrator(_appointedAdministrator, _votes);\\n    }\\n\\n    function countOracleVote() public returns (address _votedOracleAddress, uint256 _votes) {\\n        // Count oracle votes\\n        for (uint256 i = 1; i \\u003c= numberOfValidators; i++) {\\n            countVotes[oracleVote[validatorAddress[i]]]++;\\n            if (countVotes[oracleVote[validatorAddress[i]]] \\u003e _votes) {\\n                _votes = countVotes[oracleVote[validatorAddress[i]]];\\n                _votedOracleAddress = oracleVote[validatorAddress[i]];\\n            }\\n        }\\n        // Evaluate: Simple majority of Validators resets oracleAddress\\n        if (_votes \\u003e numberOfValidators.div(2)) {\\n            setOracle(_votedOracleAddress);\\n        }\\n        for (uint256 i = 1; i \\u003c= numberOfValidators; i++) {\\n            countVotes[administratorVote[validatorAddress[i]]] = 0;\\n        }\\n        return(_votedOracleAddress, _votes);\\n    }\\n\\n    function countAdministratorVote() public returns (address _appointedAdministrator, uint256 _votes) {\\n        // Count Administrator votes\\n        for (uint256 i=1; i\\u003c=numberOfValidators; i++) {\\n            countVotes[administratorVote[validatorAddress[i]]]++;\\n            if (countVotes[administratorVote[validatorAddress[i]]] \\u003e _votes) {\\n                _votes = countVotes[administratorVote[validatorAddress[i]]];\\n                _appointedAdministrator = administratorVote[validatorAddress[i]];\\n            }\\n        }\\n        // Evaluate: Simple majority of Validators resets administratorAddress\\n        if (_votes \\u003e numberOfValidators / 2) {\\n            setAdministrator(_appointedAdministrator);\\n        }\\n        for (uint256 i = 1; i \\u003c= numberOfValidators; i++) {\\n            countVotes[administratorVote[validatorAddress[i]]] = 0;\\n        }\\n        return(_appointedAdministrator, _votes);\\n    }\\n}\\n\"},\"MorpherMintingLimiter.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./MorpherState.sol\\\";\\nimport \\\"./MorpherTradeEngine.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract MorpherMintingLimiter {\\n    using SafeMath for uint256; \\n\\n    uint256 public mintingLimitPerUser;\\n    uint256 public mintingLimitDaily;\\n    uint256 public timeLockingPeriod;\\n\\n    mapping(address =\\u003e uint256) public escrowedTokens;\\n    mapping(address =\\u003e uint256) public lockedUntil;\\n    mapping(uint256 =\\u003e uint256) public dailyMintedTokens;\\n\\n    address tradeEngineAddress; \\n    MorpherState state;\\n\\n    event MintingEscrowed(address _user, uint256 _tokenAmount);\\n    event EscrowReleased(address _user, uint256 _tokenAmount);\\n    event MintingDenied(address _user, uint256 _tokenAmount);\\n    event MintingLimitUpdatedPerUser(uint256 _mintingLimitOld, uint256 _mintingLimitNew);\\n    event MintingLimitUpdatedDaily(uint256 _mintingLimitOld, uint256 _mintingLimitNew);\\n    event TimeLockPeriodUpdated(uint256 _timeLockPeriodOld, uint256 _timeLockPeriodNew);\\n    event TradeEngineAddressSet(address _tradeEngineAddress);\\n    event DailyMintedTokensReset();\\n\\n    modifier onlyTradeEngine() {\\n        require(msg.sender == tradeEngineAddress, \\\"MorpherMintingLimiter: Only Trade Engine is allowed to call this function\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdministrator() {\\n        require(msg.sender == state.getAdministrator(), \\\"MorpherMintingLimiter: Only Administrator can call this function\\\");\\n        _;\\n    }\\n\\n    constructor(address _stateAddress, uint256 _mintingLimitPerUser, uint256 _mintingLimitDaily, uint256 _timeLockingPeriodInSeconds) public {\\n        state = MorpherState(_stateAddress);\\n        mintingLimitPerUser = _mintingLimitPerUser;\\n        mintingLimitDaily = _mintingLimitDaily;\\n        timeLockingPeriod = _timeLockingPeriodInSeconds;\\n    }\\n\\n    function setTradeEngineAddress(address _tradeEngineAddress) public onlyAdministrator {\\n        emit TradeEngineAddressSet(_tradeEngineAddress);\\n        tradeEngineAddress = _tradeEngineAddress;\\n    }\\n    \\n\\n    function setMintingLimitDaily(uint256 _newMintingLimit) public onlyAdministrator {\\n        emit MintingLimitUpdatedDaily(mintingLimitDaily, _newMintingLimit);\\n        mintingLimitDaily = _newMintingLimit;\\n    }\\n    function setMintingLimitPerUser(uint256 _newMintingLimit) public onlyAdministrator {\\n        emit MintingLimitUpdatedPerUser(mintingLimitDaily, _newMintingLimit);\\n        mintingLimitPerUser = _newMintingLimit;\\n    }\\n\\n    function setTimeLockingPeriod(uint256 _newTimeLockingPeriodInSeconds) public onlyAdministrator {\\n        emit TimeLockPeriodUpdated(timeLockingPeriod, _newTimeLockingPeriodInSeconds);\\n        timeLockingPeriod = _newTimeLockingPeriodInSeconds;\\n    }\\n\\n    function mint(address _user, uint256 _tokenAmount) public onlyTradeEngine {\\n        uint256 mintingDay = block.timestamp / 1 days;\\n        if((mintingLimitDaily == 0 || dailyMintedTokens[mintingDay].add(_tokenAmount) \\u003c= mintingLimitDaily) \\u0026\\u0026 (mintingLimitPerUser == 0 || _tokenAmount \\u003c= mintingLimitPerUser )) {\\n            state.mint(_user, _tokenAmount);\\n            dailyMintedTokens[mintingDay] = dailyMintedTokens[mintingDay].add(_tokenAmount);\\n        } else {\\n            escrowedTokens[_user] = escrowedTokens[_user].add(_tokenAmount);\\n            lockedUntil[_user] = block.timestamp + timeLockingPeriod;\\n            emit MintingEscrowed(_user, _tokenAmount);\\n        }\\n    }\\n\\n    function delayedMint(address _user) public {\\n        require(lockedUntil[_user] \\u003c= block.timestamp, \\\"MorpherMintingLimiter: Funds are still time locked\\\");\\n        uint256 sendAmount = escrowedTokens[_user];\\n        escrowedTokens[_user] = 0;\\n        state.mint(_user, sendAmount);\\n        emit EscrowReleased(_user, sendAmount);\\n    }\\n\\n    function adminApprovedMint(address _user, uint256 _tokenAmount) public onlyAdministrator {\\n        escrowedTokens[_user] = escrowedTokens[_user].sub(_tokenAmount);\\n        state.mint(_user, _tokenAmount);\\n        emit EscrowReleased(_user, _tokenAmount);\\n    }\\n\\n    function adminDisapproveMint(address _user, uint256 _tokenAmount) public onlyAdministrator {\\n        escrowedTokens[_user] = escrowedTokens[_user].sub(_tokenAmount);\\n        emit MintingDenied(_user, _tokenAmount);\\n    }\\n\\n    function resetDailyMintedTokens() public onlyAdministrator {\\n        dailyMintedTokens[block.timestamp / 1 days] = 0;\\n        emit DailyMintedTokensReset();\\n    }\\n\\n    function getDailyMintedTokens() public view returns(uint256) {\\n        return dailyMintedTokens[block.timestamp / 1 days];\\n    }\\n}\"},\"MorpherOracle.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./MorpherTradeEngine.sol\\\";\\nimport \\\"./MorpherState.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n// ----------------------------------------------------------------------------------\\n// Morpher Oracle contract v 2.0\\n// The oracle initates a new trade by calling trade engine and requesting a new orderId.\\n// An event is fired by the contract notifying the oracle operator to query a price/liquidation unchecked\\n// for a market/user and return the information via the callback function. Since calling\\n// the callback function requires gas, the user must send a fixed amount of Ether when\\n// creating their order.\\n// ----------------------------------------------------------------------------------\\n\\ncontract MorpherOracle is Ownable {\\n\\n    MorpherTradeEngine tradeEngine;\\n    MorpherState state; // read only, Oracle doesn\\u0027t need writing access to state\\n\\n    using SafeMath for uint256;\\n\\n    bool public paused;\\n    bool public useWhiteList; //always false at the moment\\n\\n    uint256 public gasForCallback;\\n\\n    address payable public callBackCollectionAddress;\\n\\n    mapping(address =\\u003e bool) public callBackAddress;\\n    mapping(address =\\u003e bool) public whiteList;\\n    \\n    mapping(bytes32 =\\u003e uint256) public priceBelow;\\n    mapping(bytes32 =\\u003e uint256) public priceAbove;\\n    mapping(bytes32 =\\u003e uint256) public goodFrom;\\n    mapping(bytes32 =\\u003e uint256) public goodUntil;\\n\\n    mapping(bytes32 =\\u003e bool) public orderCancellationRequested;\\n\\n    mapping(bytes32 =\\u003e address) public orderIdTradeEngineAddress;\\n    address public previousTradeEngineAddress;\\n    address public skipPreviousTradeEngineAddress; //skips a trade engine address, e.g. typos\\n    address public previousOracleAddress;\\n\\n// ----------------------------------------------------------------------------------\\n// Events\\n// ----------------------------------------------------------------------------------\\n    event OrderCreated(\\n        bytes32 indexed _orderId,\\n        address indexed _address,\\n        bytes32 indexed _marketId,\\n        uint256 _closeSharesAmount,\\n        uint256 _openMPHTokenAmount,\\n        bool _tradeDirection,\\n        uint256 _orderLeverage,\\n        uint256 _onlyIfPriceBelow,\\n        uint256 _onlyIfPriceAbove,\\n        uint256 _goodFrom,\\n        uint256 _goodUntil\\n        );\\n\\n    event LiquidationOrderCreated(\\n        bytes32 indexed _orderId,\\n        address _sender,\\n        address indexed _address,\\n        bytes32 indexed _marketId\\n\\n        );\\n\\n    event OrderProcessed(\\n        bytes32 indexed _orderId,\\n        uint256 _price,\\n        uint256 _unadjustedMarketPrice,\\n        uint256 _spread,\\n        uint256 _positionLiquidationTimestamp,\\n        uint256 _timeStamp,\\n        uint256 _newLongShares,\\n        uint256 _newShortShares,\\n        uint256 _newMeanEntry,\\n        uint256 _newMeanSprad,\\n        uint256 _newMeanLeverage,\\n        uint256 _liquidationPrice\\n        );\\n\\n    event OrderFailed(\\n        bytes32 indexed _orderId,\\n        address indexed _address,\\n        bytes32 indexed _marketId,\\n        uint256 _closeSharesAmount,\\n        uint256 _openMPHTokenAmount,\\n        bool _tradeDirection,\\n        uint256 _orderLeverage,\\n        uint256 _onlyIfPriceBelow,\\n        uint256 _onlyIfPriceAbove,\\n        uint256 _goodFrom,\\n        uint256 _goodUntil\\n        );\\n\\n    event OrderCancelled(\\n        bytes32 indexed _orderId,\\n        address indexed _sender,\\n        address indexed _oracleAddress\\n        );\\n    \\n    event AdminOrderCancelled(\\n        bytes32 indexed _orderId,\\n        address indexed _sender,\\n        address indexed _oracleAddress\\n        );\\n\\n    event OrderCancellationRequestedEvent(\\n        bytes32 indexed _orderId,\\n        address indexed _sender\\n        );\\n\\n    event CallbackAddressEnabled(\\n        address indexed _address\\n        );\\n\\n    event CallbackAddressDisabled(\\n        address indexed _address\\n        );\\n\\n    event OraclePaused(\\n        bool _paused\\n        );\\n        \\n    event CallBackCollectionAddressChange(\\n        address _address\\n        );\\n\\n    event SetGasForCallback(\\n        uint256 _gasForCallback\\n        );\\n\\n    event LinkTradeEngine(\\n        address _address\\n        );\\n\\n    event LinkMorpherState(\\n        address _address\\n        );\\n\\n    event SetUseWhiteList(\\n        bool _useWhiteList\\n        );\\n\\n    event AddressWhiteListed(\\n        address _address\\n        );\\n\\n    event AddressBlackListed(\\n        address _address\\n        );\\n\\n    event AdminLiquidationOrderCreated(\\n        bytes32 indexed _orderId,\\n        address indexed _address,\\n        bytes32 indexed _marketId,\\n        uint256 _closeSharesAmount,\\n        uint256 _openMPHTokenAmount,\\n        bool _tradeDirection,\\n        uint256 _orderLeverage\\n        );\\n\\n    /**\\n     * Delisting markets is a function that stops when gas is running low\\n     * if it reached all positions it will emit \\\"DelistMarketComplete\\\"\\n     * otherwise it needs to be re-run.\\n     */\\n    event DelistMarketIncomplete(bytes32 _marketId, uint256 _processedUntilIndex);\\n    event DelistMarketComplete(bytes32 _marketId);\\n    event LockedPriceForClosingPositions(bytes32 _marketId, uint256 _price);\\n\\n\\n    event FallbackOracleUpdated(address _oldFallbackOracle, address _newFallbackOracle);\\n    event FallbackTradeEngineUpdated(address _oldFallbackTradeEngine, address _newFallbackTradeEngine);\\n    event UpdateSkipPreviousTradeEngineAddress(address _oldAddress, address _newAddress);\\n\\n    modifier onlyOracleOperator {\\n        require(isCallbackAddress(msg.sender), \\\"MorpherOracle: Only the oracle operator can call this function.\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdministrator {\\n        require(msg.sender == state.getAdministrator(), \\\"Function can only be called by the Administrator.\\\");\\n        _;\\n    }\\n\\n    modifier notPaused {\\n        require(paused == false, \\\"MorpherOracle: Oracle paused, aborting\\\");\\n        _;\\n    }\\n\\n   constructor(address _tradeEngineAddress, address _morpherState, address _callBackAddress, address payable _gasCollectionAddress, uint256 _gasForCallback, address _coldStorageOwnerAddress, address _previousTradeEngineAddress, address _previousOracleAddress) public {\\n        setTradeEngineAddress(_tradeEngineAddress);\\n        setStateAddress(_morpherState);\\n        enableCallbackAddress(_callBackAddress);\\n        setCallbackCollectionAddress(_gasCollectionAddress);\\n        setGasForCallback(_gasForCallback);\\n        transferOwnership(_coldStorageOwnerAddress);\\n        previousTradeEngineAddress = _previousTradeEngineAddress; //that is the address before updating the trade engine. Can set to 0x0000 if a completely new deployment happens. It is only valid when mid-term updating the tradeengine\\n        previousOracleAddress = _previousOracleAddress; //if we are updating the oracle, then this is the previous oracle address. Can be set to 0x00 if a completely new deployment happens.\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// Setter/getter functions for trade engine address, oracle operator (callback) address,\\n// and prepaid gas limit for callback function\\n// ----------------------------------------------------------------------------------\\n    function setTradeEngineAddress(address _address) public onlyOwner {\\n        tradeEngine = MorpherTradeEngine(_address);\\n        emit LinkTradeEngine(_address);\\n    }\\n\\n    function setStateAddress(address _address) public onlyOwner {\\n        state = MorpherState(_address);\\n        emit LinkMorpherState(_address);\\n    }\\n\\n    function overrideGasForCallback(uint256 _gasForCallback) public onlyOwner {\\n        gasForCallback = _gasForCallback;\\n        emit SetGasForCallback(_gasForCallback);\\n    }\\n    \\n    function setGasForCallback(uint256 _gasForCallback) private {\\n        gasForCallback = _gasForCallback;\\n        emit SetGasForCallback(_gasForCallback);\\n    }\\n\\n    function enableCallbackAddress(address _address) public onlyOwner {\\n        callBackAddress[_address] = true;\\n        emit CallbackAddressEnabled(_address);\\n    }\\n\\n    function disableCallbackAddress(address _address) public onlyOwner {\\n        callBackAddress[_address] = false;\\n        emit CallbackAddressDisabled(_address);\\n    }\\n\\n    function isCallbackAddress(address _address) public view returns (bool _isCallBackAddress) {\\n        return callBackAddress[_address];\\n    }\\n\\n    function setCallbackCollectionAddress(address payable _address) public onlyOwner {\\n        callBackCollectionAddress = _address;\\n        emit CallBackCollectionAddressChange(_address);\\n    }\\n\\n    function getAdministrator() public view returns(address _administrator) {\\n        return state.getAdministrator();\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// Oracle Owner can use a whitelist and authorize individual addresses\\n// ----------------------------------------------------------------------------------\\n    function setUseWhiteList(bool _useWhiteList) public onlyOracleOperator {\\n        require(false, \\\"MorpherOracle: Cannot use this functionality in the oracle at the moment\\\");\\n        useWhiteList = _useWhiteList;\\n        emit SetUseWhiteList(_useWhiteList);\\n    }\\n\\n    function setWhiteList(address _whiteList) public onlyOracleOperator {\\n        whiteList[_whiteList] = true;\\n        emit AddressWhiteListed(_whiteList);\\n    }\\n\\n    function setBlackList(address _blackList) public onlyOracleOperator {\\n        whiteList[_blackList] = false;\\n        emit AddressBlackListed(_blackList);\\n    }\\n\\n    function isWhiteListed(address _address) public view returns (bool _whiteListed) {\\n        if (useWhiteList == false ||  whiteList[_address] == true) {\\n            _whiteListed = true;\\n        }\\n        return(_whiteListed);\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// emitOrderFailed\\n// Can be called by Oracle Operator to notifiy user of failed order\\n// ----------------------------------------------------------------------------------\\n    function emitOrderFailed(\\n        bytes32 _orderId,\\n        address _address,\\n        bytes32 _marketId,\\n        uint256 _closeSharesAmount,\\n        uint256 _openMPHTokenAmount,\\n        bool _tradeDirection,\\n        uint256 _orderLeverage,\\n        uint256 _onlyIfPriceBelow,\\n        uint256 _onlyIfPriceAbove,\\n        uint256 _goodFrom,\\n        uint256 _goodUntil\\n    ) public onlyOracleOperator {\\n        emit OrderFailed(\\n            _orderId,\\n            _address,\\n            _marketId,\\n            _closeSharesAmount,\\n            _openMPHTokenAmount,\\n            _tradeDirection,\\n            _orderLeverage,\\n            _onlyIfPriceBelow,\\n            _onlyIfPriceAbove,\\n            _goodFrom,\\n            _goodUntil);\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// createOrder(bytes32  _marketId, bool _tradeAmountGivenInShares, uint256 _tradeAmount, bool _tradeDirection, uint256 _orderLeverage)\\n// Request a new orderId from trade engine and fires event for price/liquidation check request.\\n// ----------------------------------------------------------------------------------\\n    function createOrder(\\n        bytes32 _marketId,\\n        uint256 _closeSharesAmount,\\n        uint256 _openMPHTokenAmount,\\n        bool _tradeDirection,\\n        uint256 _orderLeverage,\\n        uint256 _onlyIfPriceAbove,\\n        uint256 _onlyIfPriceBelow,\\n        uint256 _goodUntil,\\n        uint256 _goodFrom\\n        ) public payable notPaused returns (bytes32 _orderId) {\\n        require(isWhiteListed(msg.sender),\\\"MorpherOracle: Address not eligible to create an order.\\\");\\n        if (gasForCallback \\u003e 0) {\\n            require(msg.value \\u003e= gasForCallback, \\\"MorpherOracle: Must transfer gas costs for Oracle Callback function.\\\");\\n            callBackCollectionAddress.transfer(msg.value);\\n        }\\n        _orderId = tradeEngine.requestOrderId(msg.sender, _marketId, _closeSharesAmount, _openMPHTokenAmount, _tradeDirection, _orderLeverage);\\n        orderIdTradeEngineAddress[_orderId] = address(tradeEngine);\\n\\n        //if the market was deactivated, and the trader didn\\u0027t fail yet, then we got an orderId to close the position with a locked in price\\n        if(state.getMarketActive(_marketId) == false) {\\n\\n            //price will come from the position where price is stored forever\\n            tradeEngine.processOrder(_orderId, tradeEngine.getDeactivatedMarketPrice(_marketId), 0, 0, now.mul(1000));\\n            \\n            emit OrderProcessed(\\n                _orderId,\\n                tradeEngine.getDeactivatedMarketPrice(_marketId),\\n                0,\\n                0,\\n                0,\\n                now.mul(1000),\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                0\\n                );\\n        } else {\\n            priceAbove[_orderId] = _onlyIfPriceAbove;\\n            priceBelow[_orderId] = _onlyIfPriceBelow;\\n            goodFrom[_orderId]   = _goodFrom;\\n            goodUntil[_orderId]  = _goodUntil;\\n            emit OrderCreated(\\n                _orderId,\\n                msg.sender,\\n                _marketId,\\n                _closeSharesAmount,\\n                _openMPHTokenAmount,\\n                _tradeDirection,\\n                _orderLeverage,\\n                _onlyIfPriceBelow,\\n                _onlyIfPriceAbove,\\n                _goodFrom,\\n                _goodUntil\\n                );\\n        }\\n\\n        return _orderId;\\n    }\\n\\n    function getTradeEngineFromOrderId(bytes32 _orderId) public view returns (address) {\\n        //get the current trade engine\\n        if(orderIdTradeEngineAddress[_orderId] != address(0)){\\n            return orderIdTradeEngineAddress[_orderId];\\n        }\\n\\n        if(previousOracleAddress != address(0)) {\\n            MorpherOracle _oracle = MorpherOracle(previousOracleAddress);\\n            address _previousTradeEngine = _oracle.getTradeEngineFromOrderId(_orderId);\\n            if(_previousTradeEngine != skipPreviousTradeEngineAddress) { //fixing a typo\\n                return _previousTradeEngine;\\n            }\\n        }\\n\\n        //nothing in there, take the previous tradeEngine then.\\n        return previousTradeEngineAddress;\\n    }\\n\\n    function updateSkipTradeEngineAddress(address _skipTradeEngineAddress) public onlyAdministrator {\\n        emit UpdateSkipPreviousTradeEngineAddress(skipPreviousTradeEngineAddress, _skipTradeEngineAddress);\\n        skipPreviousTradeEngineAddress = _skipTradeEngineAddress;\\n    }\\n\\n\\n    function updateFallbackTradeEngineAddress(address _tradeEngineFallbackAddress) public onlyAdministrator {\\n        emit FallbackTradeEngineUpdated(previousTradeEngineAddress, _tradeEngineFallbackAddress);\\n        previousTradeEngineAddress = _tradeEngineFallbackAddress;\\n    }\\n\\n\\n    function updateFallbackOracleAddress(address _oracleFallbackAddress) public onlyAdministrator {\\n        emit FallbackOracleUpdated(previousOracleAddress, _oracleFallbackAddress);\\n        previousOracleAddress = _oracleFallbackAddress;\\n    }\\n\\n    function initiateCancelOrder(bytes32 _orderId) public {\\n        MorpherTradeEngine _tradeEngine = MorpherTradeEngine(getTradeEngineFromOrderId(_orderId));\\n        require(orderCancellationRequested[_orderId] == false, \\\"MorpherOracle: Order was already canceled.\\\");\\n        (address userId, , , , , , ) = _tradeEngine.getOrder(_orderId);\\n        require(userId == msg.sender, \\\"MorpherOracle: Only the user can request an order cancellation.\\\");\\n        orderCancellationRequested[_orderId] = true;\\n        emit OrderCancellationRequestedEvent(_orderId, msg.sender);\\n\\n    }\\n    // ----------------------------------------------------------------------------------\\n    // cancelOrder(bytes32  _orderId)\\n    // User or Administrator can cancel their own orders before the _callback has been executed\\n    // ----------------------------------------------------------------------------------\\n    function cancelOrder(bytes32 _orderId) public onlyOracleOperator {\\n        require(orderCancellationRequested[_orderId] == true, \\\"MorpherOracle: Order-Cancellation was not requested.\\\");\\n        MorpherTradeEngine _tradeEngine = MorpherTradeEngine(getTradeEngineFromOrderId(_orderId));\\n        (address userId, , , , , , ) = _tradeEngine.getOrder(_orderId);\\n        _tradeEngine.cancelOrder(_orderId, userId);\\n        clearOrderConditions(_orderId);\\n        emit OrderCancelled(\\n            _orderId,\\n            userId,\\n            msg.sender\\n            );\\n    }\\n    \\n    // ----------------------------------------------------------------------------------\\n    // adminCancelOrder(bytes32  _orderId)\\n    // Administrator can cancel before the _callback has been executed to provide an updateOrder functionality\\n    // ----------------------------------------------------------------------------------\\n    function adminCancelOrder(bytes32 _orderId) public onlyOracleOperator {\\n        MorpherTradeEngine _tradeEngine = MorpherTradeEngine(getTradeEngineFromOrderId(_orderId));\\n        (address userId, , , , , , ) = _tradeEngine.getOrder(_orderId);\\n        _tradeEngine.cancelOrder(_orderId, userId);\\n        clearOrderConditions(_orderId);\\n        emit AdminOrderCancelled(\\n            _orderId,\\n            userId,\\n            msg.sender\\n            );\\n    }\\n\\n    function getGoodUntil(bytes32 _orderId) public view returns(uint) {\\n        if(goodUntil[_orderId] \\u003e 0) {\\n            return goodUntil[_orderId];\\n        }\\n\\n        //just return the old one\\n        if(previousOracleAddress != address(0)) {\\n            MorpherOracle _oldOracle = MorpherOracle(previousOracleAddress);\\n            return _oldOracle.goodUntil(_orderId);\\n        }\\n\\n        return 0;\\n    }\\n    function getGoodFrom(bytes32 _orderId) public view returns(uint) {\\n        if(goodFrom[_orderId] \\u003e 0) {\\n            return goodFrom[_orderId];\\n        }\\n\\n        //just return the old one\\n        if(previousOracleAddress != address(0)) {\\n            MorpherOracle _oldOracle = MorpherOracle(previousOracleAddress);\\n            return _oldOracle.goodFrom(_orderId);\\n        }\\n        return 0;\\n    }\\n    function getPriceAbove(bytes32 _orderId) public view returns(uint) {\\n        if(priceAbove[_orderId] \\u003e 0) {\\n            return priceAbove[_orderId];\\n        }\\n\\n        //just return the old one\\n        if(previousOracleAddress != address(0)) {\\n            MorpherOracle _oldOracle = MorpherOracle(previousOracleAddress);\\n            return _oldOracle.priceAbove(_orderId);\\n        }\\n        return 0;\\n    }\\n    function getPriceBelow(bytes32 _orderId) public view returns(uint) {\\n        if(priceBelow[_orderId] \\u003e 0) {\\n            return priceBelow[_orderId];\\n        }\\n\\n        //just return the old one\\n        if(previousOracleAddress != address(0)) {\\n            MorpherOracle _oldOracle = MorpherOracle(previousOracleAddress);\\n            return _oldOracle.priceBelow(_orderId);\\n        }\\n        return 0;\\n    }\\n\\n// ------------------------------------------------------------------------\\n// checkOrderConditions(bytes32 _orderId, uint256 _price)\\n// Checks if callback satisfies the order conditions\\n// ------------------------------------------------------------------------\\n    function checkOrderConditions(bytes32 _orderId, uint256 _price) public view returns (bool _conditionsMet) {\\n        _conditionsMet = true;\\n        if (now \\u003e getGoodUntil(_orderId) \\u0026\\u0026 getGoodUntil(_orderId) \\u003e 0) {\\n            _conditionsMet = false;\\n        }\\n        if (now \\u003c getGoodFrom(_orderId) \\u0026\\u0026 getGoodFrom(_orderId) \\u003e 0) {\\n            _conditionsMet = false;\\n        }\\n\\n        if(getPriceAbove(_orderId) \\u003e 0 \\u0026\\u0026 getPriceBelow(_orderId) \\u003e 0) {\\n            if(_price \\u003c getPriceAbove(_orderId) \\u0026\\u0026 _price \\u003e getPriceBelow(_orderId)) {\\n                _conditionsMet = false;\\n            }\\n        } else {\\n            if (_price \\u003c getPriceAbove(_orderId) \\u0026\\u0026 getPriceAbove(_orderId) \\u003e 0) {\\n                _conditionsMet = false;\\n            }\\n            if (_price \\u003e getPriceBelow(_orderId) \\u0026\\u0026 getPriceBelow(_orderId) \\u003e 0) {\\n                _conditionsMet = false;\\n            }\\n        }\\n        \\n        return _conditionsMet;\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// Deletes parameters of cancelled or processed orders\\n// ----------------------------------------------------------------------------------\\n    function clearOrderConditions(bytes32 _orderId) internal {\\n        priceAbove[_orderId] = 0;\\n        priceBelow[_orderId] = 0;\\n        goodFrom[_orderId]   = 0;\\n        goodUntil[_orderId]  = 0;\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// Pausing/unpausing the Oracle contract\\n// ----------------------------------------------------------------------------------\\n    function pauseOracle() public onlyOwner {\\n        paused = true;\\n        emit OraclePaused(true);\\n    }\\n\\n    function unpauseOracle() public onlyOwner {\\n        paused = false;\\n        emit OraclePaused(false);\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// createLiquidationOrder(address _address, bytes32 _marketId)\\n// Checks if position has been liquidated since last check. Requires gas for callback\\n// function. Anyone can issue a liquidation order for any other address and market.\\n// ----------------------------------------------------------------------------------\\n    function createLiquidationOrder(\\n        address _address,\\n        bytes32 _marketId\\n        ) public notPaused onlyOracleOperator payable returns (bytes32 _orderId) {\\n        if (gasForCallback \\u003e 0) {\\n            require(msg.value \\u003e= gasForCallback, \\\"MorpherOracle: Must transfer gas costs for Oracle Callback function.\\\");\\n            callBackCollectionAddress.transfer(msg.value);\\n        }\\n        _orderId = tradeEngine.requestOrderId(_address, _marketId, 0, 0, true, 10**8);\\n        orderIdTradeEngineAddress[_orderId] = address(tradeEngine);\\n        emit LiquidationOrderCreated(_orderId, msg.sender, _address, _marketId);\\n        return _orderId;\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// __callback(bytes32 _orderId, uint256 _price, uint256 _spread, uint256 _liquidationTimestamp, uint256 _timeStamp)\\n// Called by the oracle operator. Writes price/spread/liquidiation check to the blockchain.\\n// Trade engine processes the order and updates the portfolio in state if successful.\\n// ----------------------------------------------------------------------------------\\n    function __callback(\\n        bytes32 _orderId,\\n        uint256 _price,\\n        uint256 _unadjustedMarketPrice,\\n        uint256 _spread,\\n        uint256 _liquidationTimestamp,\\n        uint256 _timeStamp,\\n        uint256 _gasForNextCallback\\n        ) public onlyOracleOperator notPaused returns (uint256 _newLongShares, uint256 _newShortShares, uint256 _newMeanEntry, uint256 _newMeanSpread, uint256 _newMeanLeverage, uint256 _liquidationPrice)  {\\n        \\n        require(checkOrderConditions(_orderId, _price), \\u0027MorpherOracle Error: Order Conditions are not met\\u0027);\\n       \\n       MorpherTradeEngine _tradeEngine = MorpherTradeEngine(getTradeEngineFromOrderId(_orderId));\\n        (\\n            _newLongShares,\\n            _newShortShares,\\n            _newMeanEntry,\\n            _newMeanSpread,\\n            _newMeanLeverage,\\n            _liquidationPrice\\n        ) = _tradeEngine.processOrder(_orderId, _price, _spread, _liquidationTimestamp, _timeStamp);\\n        \\n        clearOrderConditions(_orderId);\\n        emit OrderProcessed(\\n            _orderId,\\n            _price,\\n            _unadjustedMarketPrice,\\n            _spread,\\n            _liquidationTimestamp,\\n            _timeStamp,\\n            _newLongShares,\\n            _newShortShares,\\n            _newMeanEntry,\\n            _newMeanSpread,\\n            _newMeanLeverage,\\n            _liquidationPrice\\n            );\\n        setGasForCallback(_gasForNextCallback);\\n        return (_newLongShares, _newShortShares, _newMeanEntry, _newMeanSpread, _newMeanLeverage, _liquidationPrice);\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// delistMarket(bytes32 _marketId)\\n// Administrator closes out all existing positions on _marketId market at current prices\\n// ----------------------------------------------------------------------------------\\n\\n    uint delistMarketFromIx = 0;\\n    function delistMarket(bytes32 _marketId, bool _startFromScratch) public onlyAdministrator {\\n        require(state.getMarketActive(_marketId) == true, \\\"Market must be active to process position liquidations.\\\");\\n        // If no _fromIx and _toIx specified, do entire _list\\n        if (_startFromScratch) {\\n            delistMarketFromIx = 0;\\n        }\\n        \\n        uint _toIx = state.getMaxMappingIndex(_marketId);\\n        \\n        address _address;\\n        for (uint256 i = delistMarketFromIx; i \\u003c= _toIx; i++) {\\n             if(gasleft() \\u003c 250000 \\u0026\\u0026 i != _toIx) { //stop if there\\u0027s not enough gas to write the next transaction\\n                delistMarketFromIx = i;\\n                emit DelistMarketIncomplete(_marketId, _toIx);\\n                return;\\n            } \\n            \\n            _address = state.getExposureMappingAddress(_marketId, i);\\n            adminLiquidationOrder(_address, _marketId);\\n            \\n        }\\n        emit DelistMarketComplete(_marketId);\\n    }\\n\\n    /**\\n     * Course of action would be:\\n     * 1. de-activate market through state\\n     * 2. set the Deactivated Market Price\\n     * 3. let users still close their positions\\n     */\\n    function setDeactivatedMarketPrice(bytes32 _marketId, uint256 _price) public onlyAdministrator {\\n        //todo updateable tradeEngine\\n        tradeEngine.setDeactivatedMarketPrice(_marketId, _price);\\n        emit LockedPriceForClosingPositions(_marketId, _price);\\n\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// adminLiquidationOrder(address _address, bytes32 _marketId)\\n// Administrator closes out an existing position of _address on _marketId market at current price\\n// ----------------------------------------------------------------------------------\\n    function adminLiquidationOrder(\\n        address _address,\\n        bytes32 _marketId\\n        ) public onlyAdministrator returns (bytes32 _orderId) {\\n            uint256 _positionLongShares = state.getLongShares(_address, _marketId);\\n            uint256 _positionShortShares = state.getShortShares(_address, _marketId);\\n            if (_positionLongShares \\u003e 0) {\\n                _orderId = tradeEngine.requestOrderId(_address, _marketId, _positionLongShares, 0, false, 10**8);\\n                emit AdminLiquidationOrderCreated(_orderId, _address, _marketId, _positionLongShares, 0, false, 10**8);\\n            }\\n            if (_positionShortShares \\u003e 0) {\\n                _orderId = tradeEngine.requestOrderId(_address, _marketId, _positionShortShares, 0, true, 10**8);\\n                emit AdminLiquidationOrderCreated(_orderId, _address, _marketId, _positionShortShares, 0, true, 10**8);\\n            }\\n            orderIdTradeEngineAddress[_orderId] = address(tradeEngine);\\n            return _orderId;\\n    }\\n    \\n// ----------------------------------------------------------------------------------\\n// Auxiliary function to hash a string market name i.e.\\n// \\\"CRYPTO_BTC\\\" =\\u003e 0x0bc89e95f9fdaab7e8a11719155f2fd638cb0f665623f3d12aab71d1a125daf9;\\n// ----------------------------------------------------------------------------------\\n    function stringToHash(string memory _source) public pure returns (bytes32 _result) {\\n        return keccak256(abi.encodePacked(_source));\\n    }\\n}\\n\\n\"},\"MorpherStaking.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IMorpherState.sol\\\";\\n\\n// ----------------------------------------------------------------------------------\\n// Staking Morpher Token generates interest\\n// The interest is set to 0.015% a day or ~5.475% in the first year\\n// Stakers will be able to vote on all ProtocolDecisions in MorpherGovernance (soon...)\\n// There is a lockup after staking or topping up (30 days) and a minimum stake (100k MPH)\\n// ----------------------------------------------------------------------------------\\n\\ncontract MorpherStaking is Ownable {\\n    using SafeMath for uint256;\\n    IMorpherState state;\\n\\n    uint256 constant PRECISION = 10**8;\\n    uint256 constant INTERVAL  = 1 days;\\n\\n    //mapping(address =\\u003e uint256) private poolShares;\\n    //mapping(address =\\u003e uint256) private lockup;\\n\\n    uint256 public poolShareValue = PRECISION;\\n    uint256 public lastReward;\\n    uint256 public totalShares;\\n    uint256 public interestRate = 15000; // 0.015% per day initially, diminishing returns over time\\n    uint256 public lockupPeriod = 30 days; // to prevent tactical staking and ensure smooth governance\\n    uint256 public minimumStake = 10**23; // 100k MPH minimum\\n\\n    address public stakingAdmin;\\n\\n    address public stakingAddress = 0x2222222222222222222222222222222222222222;\\n    bytes32 public marketIdStakingMPH = 0x9a31fdde7a3b1444b1befb10735dcc3b72cbd9dd604d2ff45144352bf0f359a6; //STAKING_MPH\\n\\n// ----------------------------------------------------------------------------\\n// Events\\n// ----------------------------------------------------------------------------\\n    event SetInterestRate(uint256 newInterestRate);\\n    event SetLockupPeriod(uint256 newLockupPeriod);\\n    event SetMinimumStake(uint256 newMinimumStake);\\n    event LinkState(address stateAddress);\\n    event SetStakingAdmin(address stakingAdmin);\\n    \\n    event PoolShareValueUpdated(uint256 indexed lastReward, uint256 poolShareValue);\\n    event StakingRewardsMinted(uint256 indexed lastReward, uint256 delta);\\n    event Staked(address indexed userAddress, uint256 indexed amount, uint256 poolShares, uint256 lockedUntil);\\n    event Unstaked(address indexed userAddress, uint256 indexed amount, uint256 poolShares);\\n    \\n    modifier onlyStakingAdmin {\\n        require(msg.sender == stakingAdmin, \\\"MorpherStaking: can only be called by Staking Administrator.\\\");\\n        _;\\n    }\\n    \\n    constructor(address _morpherState, address _stakingAdmin) public {\\n        setStakingAdmin(_stakingAdmin);\\n        setMorpherStateAddress(_morpherState);\\n        emit SetLockupPeriod(lockupPeriod);\\n        emit SetMinimumStake(minimumStake);\\n        emit SetInterestRate(interestRate);\\n        lastReward = now;\\n        // missing: transferOwnership to Governance once deployed\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// updatePoolShareValue\\n// Updates the value of the Pool Shares and returns the new value.\\n// Staking rewards are linear, there is no compound interest.\\n// ----------------------------------------------------------------------------\\n    \\n    function updatePoolShareValue() public returns (uint256 _newPoolShareValue) {\\n        if (now \\u003e= lastReward.add(INTERVAL)) {\\n            uint256 _numOfIntervals = now.sub(lastReward).div(INTERVAL);\\n            poolShareValue = poolShareValue.add(_numOfIntervals.mul(interestRate));\\n            lastReward = lastReward.add(_numOfIntervals.mul(INTERVAL));\\n            emit PoolShareValueUpdated(lastReward, poolShareValue);\\n        }\\n        mintStakingRewards();\\n        return poolShareValue;        \\n    }\\n\\n// ----------------------------------------------------------------------------\\n// Staking rewards are minted if necessary\\n// ----------------------------------------------------------------------------\\n\\n    function mintStakingRewards() private {\\n        uint256 _targetBalance = poolShareValue.mul(totalShares);\\n        if (state.balanceOf(stakingAddress) \\u003c _targetBalance) {\\n            // If there are not enough token held by the contract, mint them\\n            uint256 _delta = _targetBalance.sub(state.balanceOf(stakingAddress));\\n            state.mint(stakingAddress, _delta);\\n            emit StakingRewardsMinted(lastReward, _delta);\\n        }\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// stake(uint256 _amount)\\n// User specifies an amount they intend to stake. Pool Shares are issued accordingly\\n// and the _amount is transferred to the staking contract\\n// ----------------------------------------------------------------------------\\n\\n    function stake(uint256 _amount) public returns (uint256 _poolShares) {\\n        require(state.balanceOf(msg.sender) \\u003e= _amount, \\\"MorpherStaking: insufficient MPH token balance\\\");\\n        updatePoolShareValue();\\n        _poolShares = _amount.div(poolShareValue);\\n        (uint256 _numOfShares, , , , , ) = state.getPosition(msg.sender, marketIdStakingMPH);\\n        require(minimumStake \\u003c= _numOfShares.add(_poolShares).mul(poolShareValue), \\\"MorpherStaking: stake amount lower than minimum stake\\\");\\n        state.transfer(msg.sender, stakingAddress, _poolShares.mul(poolShareValue));\\n        totalShares = totalShares.add(_poolShares);\\n        state.setPosition(msg.sender, marketIdStakingMPH, now.add(lockupPeriod), _numOfShares.add(_poolShares), 0, 0, 0, 0, 0);\\n        emit Staked(msg.sender, _amount, _poolShares, now.add(lockupPeriod));\\n        return _poolShares;\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// unstake(uint256 _amount)\\n// User specifies number of Pool Shares they want to unstake. \\n// Pool Shares get deleted and the user receives their MPH plus interest\\n// ----------------------------------------------------------------------------\\n\\n    function unstake(uint256 _numOfShares) public returns (uint256 _amount) {\\n        (uint256 _numOfExistingShares, , , , , ) = state.getPosition(msg.sender, marketIdStakingMPH);\\n        require(_numOfShares \\u003c= _numOfExistingShares, \\\"MorpherStaking: insufficient pool shares\\\");\\n\\n        uint256 lockedInUntil = state.getLastUpdated(msg.sender, marketIdStakingMPH);\\n        require(now \\u003e= lockedInUntil, \\\"MorpherStaking: cannot unstake before lockup expiration\\\");\\n        updatePoolShareValue();\\n        state.setPosition(msg.sender, marketIdStakingMPH, lockedInUntil, _numOfExistingShares.sub(_numOfShares), 0, 0, 0, 0, 0);\\n        totalShares = totalShares.sub(_numOfShares);\\n        _amount = _numOfShares.mul(poolShareValue);\\n        state.transfer(stakingAddress, msg.sender, _amount);\\n        emit Unstaked(msg.sender, _amount, _numOfShares);\\n        return _amount;\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// Administrative functions\\n// ----------------------------------------------------------------------------\\n\\n    function setStakingAdmin(address _address) public onlyOwner {\\n        stakingAdmin = _address;\\n        emit SetStakingAdmin(_address);\\n    }\\n\\n    function setMorpherStateAddress(address _stateAddress) public onlyOwner {\\n        state = IMorpherState(_stateAddress);\\n        emit LinkState(_stateAddress);\\n    }\\n\\n    function setInterestRate(uint256 _interestRate) public onlyStakingAdmin {\\n        interestRate = _interestRate;\\n        emit SetInterestRate(_interestRate);\\n    }\\n\\n    function setLockupPeriodRate(uint256 _lockupPeriod) public onlyStakingAdmin {\\n        lockupPeriod = _lockupPeriod;\\n        emit SetLockupPeriod(_lockupPeriod);\\n    }\\n    \\n    function setMinimumStake(uint256 _minimumStake) public onlyStakingAdmin {\\n        minimumStake = _minimumStake;\\n        emit SetMinimumStake(_minimumStake);\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// Getter functions\\n// ----------------------------------------------------------------------------\\n\\n    function getTotalPooledValue() public view returns (uint256 _totalPooled) {\\n        // Only accurate if poolShareValue is up to date\\n        return poolShareValue.mul(totalShares);\\n    }\\n\\n    function getStake(address _address) public view returns (uint256 _poolShares) {\\n        (uint256 _numOfShares, , , , , ) = state.getPosition(_address, marketIdStakingMPH);\\n        return _numOfShares;\\n    }\\n\\n    function getStakeValue(address _address) public view returns(uint256 _value, uint256 _lastUpdate) {\\n        // Only accurate if poolShareValue is up to date\\n        \\n        (uint256 _numOfShares, , , , , ) = state.getPosition(_address, marketIdStakingMPH);\\n\\n        return (_numOfShares.mul(poolShareValue), lastReward);\\n    }\\n    \\n// ------------------------------------------------------------------------\\n// Don\\u0027t accept ETH\\n// ------------------------------------------------------------------------\\n\\n    function () external payable {\\n        revert(\\\"MorpherStaking: you can\\u0027t deposit Ether here\\\");\\n    }\\n}\\n\"},\"MorpherState.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IMorpherToken.sol\\\";\\n\\n// ----------------------------------------------------------------------------------\\n// Data and token balance storage of the Morpher platform\\n// Writing access is only granted to platform contracts. The contract can be paused\\n// by an elected platform administrator (see MorpherGovernance) to perform protocol updates.\\n// ----------------------------------------------------------------------------------\\n\\ncontract MorpherState is Ownable {\\n    using SafeMath for uint256;\\n\\n    bool public mainChain;\\n    uint256 public totalSupply;\\n    uint256 public totalToken;\\n    uint256 public totalInPositions;\\n    uint256 public totalOnOtherChain;\\n    uint256 public maximumLeverage = 10**9; // Leverage precision is 1e8, maximum leverage set to 10 initially\\n    uint256 constant PRECISION = 10**8;\\n    uint256 constant DECIMALS = 18;\\n    uint256 constant REWARDPERIOD = 1 days;\\n    bool public paused = false;\\n\\n    address public morpherGovernance;\\n    address public morpherRewards;\\n    address public administrator;\\n    address public oracleContract;\\n    address public sideChainOperator;\\n    address public morpherBridge;\\n    address public morpherToken;\\n\\n    uint256 public rewardBasisPoints;\\n    uint256 public lastRewardTime;\\n\\n    bytes32 public sideChainMerkleRoot;\\n    uint256 public sideChainMerkleRootWrittenAtTime;\\n\\n    // Set initial withdraw limit from sidechain to 20m token or 2% of initial supply\\n    uint256 public mainChainWithdrawLimit24 = 2 * 10**25;\\n\\n    mapping(address =\\u003e bool) private stateAccess;\\n    mapping(address =\\u003e bool) private transferAllowed;\\n\\n    mapping(address =\\u003e uint256) private balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private allowed;\\n\\n    mapping(bytes32 =\\u003e bool) private marketActive;\\n\\n    // ----------------------------------------------------------------------------\\n    // Position struct records virtual futures\\n    // ----------------------------------------------------------------------------\\n    struct position {\\n        uint256 lastUpdated;\\n        uint256 longShares;\\n        uint256 shortShares;\\n        uint256 meanEntryPrice;\\n        uint256 meanEntrySpread;\\n        uint256 meanEntryLeverage;\\n        uint256 liquidationPrice;\\n        bytes32 positionHash;\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // A portfolio is an address specific collection of postions\\n    // ----------------------------------------------------------------------------\\n    mapping(address =\\u003e mapping(bytes32 =\\u003e position)) private portfolio;\\n\\n    // ----------------------------------------------------------------------------\\n    // Record all addresses that hold a position of a market, needed for clean stock splits\\n    // ----------------------------------------------------------------------------\\n    struct hasExposure {\\n        uint256 maxMappingIndex;\\n        mapping(address =\\u003e uint256) index;\\n        mapping(uint256 =\\u003e address) addy;\\n    }\\n\\n    mapping(bytes32 =\\u003e hasExposure) private exposureByMarket;\\n\\n    // ----------------------------------------------------------------------------\\n    // Bridge Variables\\n    // ----------------------------------------------------------------------------\\n    mapping (address =\\u003e uint256) private tokenClaimedOnThisChain;\\n    mapping (address =\\u003e uint256) private tokenSentToLinkedChain;\\n    mapping (address =\\u003e uint256) private tokenSentToLinkedChainTime;\\n    mapping (bytes32 =\\u003e bool) private positionClaimedOnMainChain;\\n\\n    uint256 public lastWithdrawLimitReductionTime;\\n    uint256 public last24HoursAmountWithdrawn;\\n    uint256 public withdrawLimit24Hours;\\n    uint256 public inactivityPeriod = 3 days;\\n    uint256 public transferNonce;\\n    bool public fastTransfersEnabled;\\n\\n    // ----------------------------------------------------------------------------\\n    // Sidechain spam protection\\n    // ----------------------------------------------------------------------------\\n\\n    mapping(address =\\u003e uint256) private lastRequestBlock;\\n    mapping(address =\\u003e uint256) private numberOfRequests;\\n    uint256 public numberOfRequestsLimit;\\n\\n    // ----------------------------------------------------------------------------\\n    // Events\\n    // ----------------------------------------------------------------------------\\n    event StateAccessGranted(address indexed whiteList, uint256 indexed blockNumber);\\n    event StateAccessDenied(address indexed blackList, uint256 indexed blockNumber);\\n\\n    event TransfersEnabled(address indexed whiteList);\\n    event TransfersDisabled(address indexed blackList);\\n\\n    event Transfer(address indexed sender, address indexed recipient, uint256 amount);\\n    event Mint(address indexed recipient, uint256 amount, uint256 totalToken);\\n    event Burn(address indexed recipient, uint256 amount, uint256 totalToken);\\n    event NewTotalSupply(uint256 newTotalSupply);\\n    event NewTotalOnOtherChain(uint256 newTotalOnOtherChain);\\n    event NewTotalInPositions(uint256 newTotalOnOtherChain);\\n    event OperatingRewardMinted(address indexed recipient, uint256 amount);\\n\\n    event RewardsChange(address indexed rewardsAddress, uint256 indexed rewardsBasisPoints);\\n    event LastRewardTime(uint256 indexed rewardsTime);\\n    event GovernanceChange(address indexed governanceAddress);\\n    event TokenChange(address indexed tokenAddress);\\n    event AdministratorChange(address indexed administratorAddress);\\n    event OracleChange(address indexed oracleContract);\\n    event MaximumLeverageChange(uint256 maxLeverage);\\n    event MarketActivated(bytes32 indexed activateMarket);\\n    event MarketDeActivated(bytes32 indexed deActivateMarket);\\n    event BridgeChange(address _bridgeAddress);\\n    event SideChainMerkleRootUpdate(bytes32 indexed sideChainMerkleRoot);\\n    event NewSideChainOperator(address indexed sideChainOperator);\\n    event NumberOfRequestsLimitUpdate(uint256 _numberOfRequests);\\n\\n    event MainChainWithdrawLimitUpdate(uint256 indexed mainChainWithdrawLimit24);\\n    event TokenSentToLinkedChain(address _address, uint256 _token, uint256 _totalTokenSent, bytes32 indexed _tokenSentToLinkedChainHash);\\n    event TransferredTokenClaimed(address _address, uint256 _token);\\n    event LastWithdrawAt();\\n    event RollingWithdrawnAmountUpdated(uint256 _last24HoursAmountWithdrawn, uint256 _lastWithdrawLimitReductionTime);\\n    event WithdrawLimitUpdated(uint256 _amount);\\n    event InactivityPeriodUpdated(uint256 _periodLength);\\n    event FastWithdrawsDisabled();\\n    event NewBridgeNonce(uint256 _transferNonce);\\n    event Last24HoursAmountWithdrawnReset();\\n\\n    event StatePaused(address administrator, bool _paused);\\n\\n    event SetAllowance(address indexed sender, address indexed spender, uint256 tokens);\\n    event SetPosition(bytes32 indexed positionHash,\\n        address indexed sender,\\n        bytes32 indexed marketId,\\n        uint256 timeStamp,\\n        uint256 longShares,\\n        uint256 shortShares,\\n        uint256 meanEntryPrice,\\n        uint256 meanEntrySpread,\\n        uint256 meanEntryLeverage,\\n        uint256 liquidationPrice\\n    );\\n    event SetBalance(address indexed account, uint256 balance, bytes32 indexed balanceHash);\\n    event TokenTransferredToOtherChain(address indexed account, uint256 tokenTransferredToOtherChain, bytes32 indexed transferHash);\\n\\n    modifier notPaused {\\n        require(paused == false, \\\"MorpherState: Contract paused, aborting\\\");\\n        _;\\n    }\\n\\n    modifier onlyPlatform {\\n        require(stateAccess[msg.sender] == true, \\\"MorpherState: Only Platform is allowed to execute operation.\\\");\\n        _;\\n    }\\n\\n    modifier onlyGovernance {\\n        require(msg.sender == getGovernance(), \\\"MorpherState: Calling contract not the Governance Contract. Aborting.\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdministrator {\\n        require(msg.sender == getAdministrator(), \\\"MorpherState: Caller is not the Administrator. Aborting.\\\");\\n        _;\\n    }\\n\\n    modifier onlySideChainOperator {\\n        require(msg.sender == sideChainOperator, \\\"MorpherState: Caller is not the Sidechain Operator. Aborting.\\\");\\n        _;\\n    }\\n\\n    modifier canTransfer {\\n        require(getCanTransfer(msg.sender), \\\"MorpherState: Caller may not transfer token. Aborting.\\\");\\n        _;\\n    }\\n\\n    modifier onlyBridge {\\n        require(msg.sender == getMorpherBridge(), \\\"MorpherState: Caller is not the Bridge. Aborting.\\\");\\n        _;\\n    }\\n\\n    modifier onlyMainChain {\\n        require(mainChain == true, \\\"MorpherState: Can only be called on mainchain.\\\");\\n        _;\\n    }\\n\\n    modifier onlySideChain {\\n        require(mainChain == false, \\\"MorpherState: Can only be called on mainchain.\\\");\\n        _;\\n    }\\n\\n    constructor(bool _mainChain, address _sideChainOperator, address _morpherTreasury) public {\\n        // @Deployer: Transfer State Ownership to cold storage address after deploying protocol\\n        mainChain = _mainChain; // true for Ethereum, false for Morpher PoA sidechain\\n        setLastRewardTime(now);\\n        uint256 _sideChainMint = 575000000 * 10**(DECIMALS);\\n        uint256 _mainChainMint = 425000000 * 10**(DECIMALS);\\n        \\n        administrator = owner(); //first set the owner as administrator\\n        morpherGovernance = owner(); //first set the owner as governance\\n        \\n        grantAccess(owner());\\n        setSideChainOperator(owner());\\n        if (mainChain == false) { // Create token only on sidechain\\n            balances[owner()] = _sideChainMint; // Create airdrop and team token on sidechain\\n            totalToken = _sideChainMint;\\n            emit Mint(owner(), balanceOf(owner()), _sideChainMint);\\n            setRewardBasisPoints(0); // Reward is minted on mainchain\\n            setRewardAddress(address(0));\\n            setTotalOnOtherChain(_mainChainMint);\\n        } else {\\n            balances[owner()] = _mainChainMint; // Create treasury and investor token on mainchain\\n            totalToken = _mainChainMint;\\n            emit Mint(owner(), balanceOf(owner()), _mainChainMint);\\n            setRewardBasisPoints(15000); // 15000 / PRECISION = 0.00015\\n            setRewardAddress(_morpherTreasury);\\n            setTotalOnOtherChain(_sideChainMint);\\n        }\\n        fastTransfersEnabled = true;\\n        setNumberOfRequestsLimit(3);\\n        setMainChainWithdrawLimit(totalSupply / 50);\\n        setSideChainOperator(_sideChainOperator);\\n        denyAccess(owner());\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for market wise exposure\\n    // ----------------------------------------------------------------------------\\n\\n    function getMaxMappingIndex(bytes32 _marketId) public view returns(uint256 _maxMappingIndex) {\\n        return exposureByMarket[_marketId].maxMappingIndex;\\n    }\\n\\n    function getExposureMappingIndex(bytes32 _marketId, address _address) public view returns(uint256 _mappingIndex) {\\n        return exposureByMarket[_marketId].index[_address];\\n    }\\n\\n    function getExposureMappingAddress(bytes32 _marketId, uint256 _mappingIndex) public view returns(address _address) {\\n        return exposureByMarket[_marketId].addy[_mappingIndex];\\n    }\\n\\n    function setMaxMappingIndex(bytes32 _marketId, uint256 _maxMappingIndex) public onlyPlatform {\\n        exposureByMarket[_marketId].maxMappingIndex = _maxMappingIndex;\\n    }\\n\\n    function setExposureMapping(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform  {\\n        setExposureMappingIndex(_marketId, _address, _index);\\n        setExposureMappingAddress(_marketId, _address, _index);\\n    }\\n\\n    function setExposureMappingIndex(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform {\\n        exposureByMarket[_marketId].index[_address] = _index;\\n    }\\n\\n    function setExposureMappingAddress(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform {\\n        exposureByMarket[_marketId].addy[_index] = _address;\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for bridge variables\\n    // ----------------------------------------------------------------------------\\n    function setTokenClaimedOnThisChain(address _address, uint256 _token) public onlyBridge {\\n        tokenClaimedOnThisChain[_address] = _token;\\n        emit TransferredTokenClaimed(_address, _token);\\n    }\\n\\n    function getTokenClaimedOnThisChain(address _address) public view returns (uint256 _token) {\\n        return tokenClaimedOnThisChain[_address];\\n    }\\n\\n    function setTokenSentToLinkedChain(address _address, uint256 _token) public onlyBridge {\\n        tokenSentToLinkedChain[_address] = _token;\\n        tokenSentToLinkedChainTime[_address] = now;\\n        emit TokenSentToLinkedChain(_address, _token, tokenSentToLinkedChain[_address], getBalanceHash(_address, tokenSentToLinkedChain[_address]));\\n    }\\n\\n    function getTokenSentToLinkedChain(address _address) public view returns (uint256 _token) {\\n        return tokenSentToLinkedChain[_address];\\n    }\\n\\n    function getTokenSentToLinkedChainTime(address _address) public view returns (uint256 _timeStamp) {\\n        return tokenSentToLinkedChainTime[_address];\\n    }\\n\\n    function add24HoursWithdrawn(uint256 _amount) public onlyBridge {\\n        last24HoursAmountWithdrawn = last24HoursAmountWithdrawn.add(_amount);\\n        emit RollingWithdrawnAmountUpdated(last24HoursAmountWithdrawn, lastWithdrawLimitReductionTime);\\n    }\\n\\n    function update24HoursWithdrawLimit(uint256 _amount) public onlyBridge {\\n        if (last24HoursAmountWithdrawn \\u003e _amount) {\\n            last24HoursAmountWithdrawn = last24HoursAmountWithdrawn.sub(_amount);\\n        } else {\\n            last24HoursAmountWithdrawn = 0;\\n        }\\n        lastWithdrawLimitReductionTime = now;\\n        emit RollingWithdrawnAmountUpdated(last24HoursAmountWithdrawn, lastWithdrawLimitReductionTime);\\n    }\\n\\n    function set24HourWithdrawLimit(uint256 _limit) public onlyBridge {\\n        withdrawLimit24Hours = _limit;\\n        emit WithdrawLimitUpdated(_limit);\\n    }\\n\\n    function resetLast24HoursAmountWithdrawn() public onlyBridge {\\n        last24HoursAmountWithdrawn = 0;\\n        emit Last24HoursAmountWithdrawnReset();\\n    }\\n\\n    function setInactivityPeriod(uint256 _periodLength) public onlyBridge {\\n        inactivityPeriod = _periodLength;\\n        emit InactivityPeriodUpdated(_periodLength);\\n    }\\n\\n    function getBridgeNonce() public onlyBridge returns (uint256 _nonce) {\\n        transferNonce++;\\n        emit NewBridgeNonce(transferNonce);\\n        return transferNonce;\\n    }\\n\\n    function disableFastWithdraws() public onlyBridge {\\n        fastTransfersEnabled = false;\\n        emit FastWithdrawsDisabled();\\n    }\\n\\n    function setPositionClaimedOnMainChain(bytes32 _positionHash) public onlyBridge {\\n        positionClaimedOnMainChain[_positionHash] = true;\\n    }\\n\\n    function getPositionClaimedOnMainChain(bytes32 _positionHash) public view returns (bool _alreadyClaimed) {\\n        return positionClaimedOnMainChain[_positionHash];\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for spam protection\\n    // ----------------------------------------------------------------------------\\n\\n    function setLastRequestBlock(address _address) public onlyPlatform {\\n        lastRequestBlock[_address] = block.number;\\n    }\\n\\n    function getLastRequestBlock(address _address) public view returns(uint256 _lastRequestBlock) {\\n        return lastRequestBlock[_address];\\n    }\\n\\n    function setNumberOfRequests(address _address, uint256 _numberOfRequests) public onlyPlatform {\\n        numberOfRequests[_address] = _numberOfRequests;\\n    }\\n\\n    function increaseNumberOfRequests(address _address) public onlyPlatform{\\n        numberOfRequests[_address]++;\\n    }\\n\\n    function getNumberOfRequests(address _address) public view returns(uint256 _numberOfRequests) {\\n        return numberOfRequests[_address];\\n    }\\n\\n    function setNumberOfRequestsLimit(uint256 _numberOfRequestsLimit) public onlyPlatform {\\n        numberOfRequestsLimit = _numberOfRequestsLimit;\\n        emit NumberOfRequestsLimitUpdate(_numberOfRequestsLimit);\\n    }\\n\\n    function getNumberOfRequestsLimit() public view returns (uint256 _numberOfRequestsLimit) {\\n        return numberOfRequestsLimit;\\n    }\\n\\n    function setMainChainWithdrawLimit(uint256 _mainChainWithdrawLimit24) public onlyGovernance {\\n        mainChainWithdrawLimit24 = _mainChainWithdrawLimit24;\\n        emit MainChainWithdrawLimitUpdate(_mainChainWithdrawLimit24);\\n    }\\n\\n    function getMainChainWithdrawLimit() public view returns (uint256 _mainChainWithdrawLimit24) {\\n        return mainChainWithdrawLimit24;\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for state access\\n    // ----------------------------------------------------------------------------\\n\\n    function grantAccess(address _address) public onlyAdministrator {\\n        stateAccess[_address] = true;\\n        emit StateAccessGranted(_address, block.number);\\n    }\\n\\n    function denyAccess(address _address) public onlyAdministrator {\\n        stateAccess[_address] = false;\\n        emit StateAccessDenied(_address, block.number);\\n    }\\n\\n    function getStateAccess(address _address) public view returns(bool _hasAccess) {\\n        return stateAccess[_address];\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for addresses that can transfer tokens (sidechain only)\\n    // ----------------------------------------------------------------------------\\n\\n    function enableTransfers(address _address) public onlyAdministrator {\\n        transferAllowed[_address] = true;\\n        emit TransfersEnabled(_address);\\n    }\\n\\n    function disableTransfers(address _address) public onlyAdministrator {\\n        transferAllowed[_address] = false;\\n        emit TransfersDisabled(_address);\\n    }\\n\\n    function getCanTransfer(address _address) public view returns(bool _hasAccess) {\\n        return mainChain || transferAllowed[_address];\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Minting/burning/transfer of token\\n    // ----------------------------------------------------------------------------\\n\\n    function transfer(address _from, address _to, uint256 _token) public onlyPlatform notPaused {\\n        require(balances[_from] \\u003e= _token, \\\"MorpherState: Not enough token.\\\");\\n        balances[_from] = balances[_from].sub(_token);\\n        balances[_to] = balances[_to].add(_token);\\n        IMorpherToken(morpherToken).emitTransfer(_from, _to, _token);\\n        emit Transfer(_from, _to, _token);\\n        emit SetBalance(_from, balances[_from], getBalanceHash(_from, balances[_from]));\\n        emit SetBalance(_to, balances[_to], getBalanceHash(_to, balances[_to]));\\n    }\\n\\n    function mint(address _address, uint256 _token) public onlyPlatform notPaused {\\n        balances[_address] = balances[_address].add(_token);\\n        totalToken = totalToken.add(_token);\\n        updateTotalSupply();\\n        IMorpherToken(morpherToken).emitTransfer(address(0), _address, _token);\\n        emit Mint(_address, _token, totalToken);\\n        emit SetBalance(_address, balances[_address], getBalanceHash(_address, balances[_address]));\\n    }\\n\\n    function burn(address _address, uint256 _token) public onlyPlatform notPaused {\\n        require(balances[_address] \\u003e= _token, \\\"MorpherState: Not enough token.\\\");\\n        balances[_address] = balances[_address].sub(_token);\\n        totalToken = totalToken.sub(_token);\\n        updateTotalSupply();\\n        IMorpherToken(morpherToken).emitTransfer(_address, address(0), _token);\\n        emit Burn(_address, _token, totalToken);\\n        emit SetBalance(_address, balances[_address], getBalanceHash(_address, balances[_address]));\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for balance and token functions (ERC20)\\n    // ----------------------------------------------------------------------------\\n    function updateTotalSupply() private {\\n        totalSupply = totalToken.add(totalInPositions).add(totalOnOtherChain);\\n        emit NewTotalSupply(totalSupply);\\n    }\\n\\n    function setTotalInPositions(uint256 _totalInPositions) public onlyAdministrator {\\n        totalInPositions = _totalInPositions;\\n        updateTotalSupply();\\n        emit NewTotalInPositions(_totalInPositions);\\n    }\\n\\n    function setTotalOnOtherChain(uint256 _newTotalOnOtherChain) public onlySideChainOperator {\\n        totalOnOtherChain = _newTotalOnOtherChain;\\n        updateTotalSupply();\\n        emit NewTotalOnOtherChain(_newTotalOnOtherChain);\\n    }\\n\\n    function balanceOf(address _tokenOwner) public view returns (uint256 balance) {\\n        return balances[_tokenOwner];\\n    }\\n\\n    function setAllowance(address _from, address _spender, uint256 _tokens) public onlyPlatform {\\n        allowed[_from][_spender] = _tokens;\\n        emit SetAllowance(_from, _spender, _tokens);\\n    }\\n\\n    function getAllowance(address _tokenOwner, address spender) public view returns (uint256 remaining) {\\n        return allowed[_tokenOwner][spender];\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for platform roles\\n    // ----------------------------------------------------------------------------\\n\\n    function setGovernanceContract(address _newGovernanceContractAddress) public onlyGovernance {\\n        morpherGovernance = _newGovernanceContractAddress;\\n        emit GovernanceChange(_newGovernanceContractAddress);\\n    }\\n\\n    function getGovernance() public view returns (address _governanceContract) {\\n        return morpherGovernance;\\n    }\\n\\n    function setMorpherBridge(address _newBridge) public onlyGovernance {\\n        morpherBridge = _newBridge;\\n        emit BridgeChange(_newBridge);\\n    }\\n\\n    function getMorpherBridge() public view returns (address _currentBridge) {\\n        return morpherBridge;\\n    }\\n\\n    function setOracleContract(address _newOracleContract) public onlyGovernance {\\n        oracleContract = _newOracleContract;\\n        emit OracleChange(_newOracleContract);\\n    }\\n\\n    function getOracleContract() public view returns(address) {\\n        return oracleContract;\\n    }\\n\\n    function setTokenContract(address _newTokenContract) public onlyGovernance {\\n        morpherToken = _newTokenContract;\\n        emit TokenChange(_newTokenContract);\\n    }\\n\\n    function getTokenContract() public view returns(address) {\\n        return morpherToken;\\n    }\\n\\n    function setAdministrator(address _newAdministrator) public onlyGovernance {\\n        administrator = _newAdministrator;\\n        emit AdministratorChange(_newAdministrator);\\n    }\\n\\n    function getAdministrator() public view returns(address) {\\n        return administrator;\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for platform operating rewards\\n    // ----------------------------------------------------------------------------\\n\\n    function setRewardAddress(address _newRewardsAddress) public onlyGovernance {\\n        morpherRewards = _newRewardsAddress;\\n        emit RewardsChange(_newRewardsAddress, rewardBasisPoints);\\n    }\\n\\n    function setRewardBasisPoints(uint256 _newRewardBasisPoints) public onlyGovernance {\\n        if (mainChain == true) {\\n            require(_newRewardBasisPoints \\u003c= 15000, \\\"MorpherState: Reward basis points need to be less or equal to 15000.\\\");\\n        } else {\\n            require(_newRewardBasisPoints == 0, \\\"MorpherState: Reward basis points can only be set on Ethereum.\\\");\\n        }\\n        rewardBasisPoints = _newRewardBasisPoints;\\n        emit RewardsChange(morpherRewards, _newRewardBasisPoints);\\n    }\\n\\n    function setLastRewardTime(uint256 _lastRewardTime) private {\\n        lastRewardTime = _lastRewardTime;\\n        emit LastRewardTime(_lastRewardTime);\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for platform administration\\n    // ----------------------------------------------------------------------------\\n\\n    function activateMarket(bytes32 _activateMarket) public onlyAdministrator {\\n        marketActive[_activateMarket] = true;\\n        emit MarketActivated(_activateMarket);\\n    }\\n\\n    function deActivateMarket(bytes32 _deActivateMarket) public onlyAdministrator {\\n        marketActive[_deActivateMarket] = false;\\n        emit MarketDeActivated(_deActivateMarket);\\n    }\\n\\n    function getMarketActive(bytes32 _marketId) public view returns(bool _active) {\\n        return marketActive[_marketId];\\n    }\\n\\n    function setMaximumLeverage(uint256 _newMaximumLeverage) public onlyAdministrator {\\n        require(_newMaximumLeverage \\u003e PRECISION, \\\"MorpherState: Leverage precision is 1e8\\\");\\n        maximumLeverage = _newMaximumLeverage;\\n        emit MaximumLeverageChange(_newMaximumLeverage);\\n    }\\n\\n    function getMaximumLeverage() public view returns(uint256 _maxLeverage) {\\n        return maximumLeverage;\\n    }\\n\\n    function pauseState() public onlyAdministrator {\\n        paused = true;\\n        emit StatePaused(msg.sender, true);\\n    }\\n\\n    function unPauseState() public onlyAdministrator {\\n        paused = false;\\n        emit StatePaused(msg.sender, false);\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter for side chain state\\n    // ----------------------------------------------------------------------------\\n\\n    function setSideChainMerkleRoot(bytes32 _sideChainMerkleRoot) public onlyBridge {\\n        sideChainMerkleRoot = _sideChainMerkleRoot;\\n        sideChainMerkleRootWrittenAtTime = now;\\n        payOperatingReward();\\n        emit SideChainMerkleRootUpdate(_sideChainMerkleRoot);\\n    }\\n\\n    function getSideChainMerkleRoot() public view returns(bytes32 _sideChainMerkleRoot) {\\n        return sideChainMerkleRoot;\\n    }\\n\\n    function setSideChainOperator(address _address) public onlyAdministrator {\\n        sideChainOperator = _address;\\n        emit NewSideChainOperator(_address);\\n    }\\n\\n    function getSideChainOperator() public view returns (address _address) {\\n        return sideChainOperator;\\n    }\\n\\n    function getSideChainMerkleRootWrittenAtTime() public view returns(uint256 _sideChainMerkleRoot) {\\n        return sideChainMerkleRootWrittenAtTime;\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for portfolio\\n    // ----------------------------------------------------------------------------\\n\\n    function setPosition(\\n        address _address,\\n        bytes32 _marketId,\\n        uint256 _timeStamp,\\n        uint256 _longShares,\\n        uint256 _shortShares,\\n        uint256 _meanEntryPrice,\\n        uint256 _meanEntrySpread,\\n        uint256 _meanEntryLeverage,\\n        uint256 _liquidationPrice\\n    ) public onlyPlatform {\\n        portfolio[_address][_marketId].lastUpdated = _timeStamp;\\n        portfolio[_address][_marketId].longShares = _longShares;\\n        portfolio[_address][_marketId].shortShares = _shortShares;\\n        portfolio[_address][_marketId].meanEntryPrice = _meanEntryPrice;\\n        portfolio[_address][_marketId].meanEntrySpread = _meanEntrySpread;\\n        portfolio[_address][_marketId].meanEntryLeverage = _meanEntryLeverage;\\n        portfolio[_address][_marketId].liquidationPrice = _liquidationPrice;\\n        portfolio[_address][_marketId].positionHash = getPositionHash(\\n            _address,\\n            _marketId,\\n            _timeStamp,\\n            _longShares,\\n            _shortShares,\\n            _meanEntryPrice,\\n            _meanEntrySpread,\\n            _meanEntryLeverage,\\n            _liquidationPrice\\n        );\\n        if (_longShares \\u003e 0 || _shortShares \\u003e 0) {\\n            addExposureByMarket(_marketId, _address);\\n        } else {\\n            deleteExposureByMarket(_marketId, _address);\\n        }\\n        emit SetPosition(\\n            portfolio[_address][_marketId].positionHash,\\n            _address,\\n            _marketId,\\n            _timeStamp,\\n            _longShares,\\n            _shortShares,\\n            _meanEntryPrice,\\n            _meanEntrySpread,\\n            _meanEntryLeverage,\\n            _liquidationPrice\\n        );\\n    }\\n\\n    function getPosition(\\n        address _address,\\n        bytes32 _marketId\\n    ) public view returns (\\n        uint256 _longShares,\\n        uint256 _shortShares,\\n        uint256 _meanEntryPrice,\\n        uint256 _meanEntrySpread,\\n        uint256 _meanEntryLeverage,\\n        uint256 _liquidationPrice\\n    ) {\\n        return(\\n        portfolio[_address][_marketId].longShares,\\n        portfolio[_address][_marketId].shortShares,\\n        portfolio[_address][_marketId].meanEntryPrice,\\n        portfolio[_address][_marketId].meanEntrySpread,\\n        portfolio[_address][_marketId].meanEntryLeverage,\\n        portfolio[_address][_marketId].liquidationPrice\\n        );\\n    }\\n\\n    function getPositionHash(\\n        address _address,\\n        bytes32 _marketId,\\n        uint256 _timeStamp,\\n        uint256 _longShares,\\n        uint256 _shortShares,\\n        uint256 _meanEntryPrice,\\n        uint256 _meanEntrySpread,\\n        uint256 _meanEntryLeverage,\\n        uint256 _liquidationPrice\\n    ) public pure returns (bytes32 _hash) {\\n        return keccak256(\\n            abi.encodePacked(\\n                _address,\\n                _marketId,\\n                _timeStamp,\\n                _longShares,\\n                _shortShares,\\n                _meanEntryPrice,\\n                _meanEntrySpread,\\n                _meanEntryLeverage,\\n                _liquidationPrice\\n            )\\n        );\\n    }\\n\\n    function getBalanceHash(address _address, uint256 _balance) public pure returns (bytes32 _hash) {\\n        return keccak256(abi.encodePacked(_address, _balance));\\n    }\\n\\n    function getLastUpdated(address _address, bytes32 _marketId) public view returns (uint256 _lastUpdated) {\\n        return(portfolio[_address][_marketId].lastUpdated);\\n    }\\n\\n    function getLongShares(address _address, bytes32 _marketId) public view returns (uint256 _longShares) {\\n        return(portfolio[_address][_marketId].longShares);\\n    }\\n\\n    function getShortShares(address _address, bytes32 _marketId) public view returns (uint256 _shortShares) {\\n        return(portfolio[_address][_marketId].shortShares);\\n    }\\n\\n    function getMeanEntryPrice(address _address, bytes32 _marketId) public view returns (uint256 _meanEntryPrice) {\\n        return(portfolio[_address][_marketId].meanEntryPrice);\\n    }\\n\\n    function getMeanEntrySpread(address _address, bytes32 _marketId) public view returns (uint256 _meanEntrySpread) {\\n        return(portfolio[_address][_marketId].meanEntrySpread);\\n    }\\n\\n    function getMeanEntryLeverage(address _address, bytes32 _marketId) public view returns (uint256 _meanEntryLeverage) {\\n        return(portfolio[_address][_marketId].meanEntryLeverage);\\n    }\\n\\n    function getLiquidationPrice(address _address, bytes32 _marketId) public view returns (uint256 _liquidationPrice) {\\n        return(portfolio[_address][_marketId].liquidationPrice);\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Record positions by market by address. Needed for exposure aggregations\\n    // and spits and dividends.\\n    // ----------------------------------------------------------------------------\\n    function addExposureByMarket(bytes32 _symbol, address _address) private {\\n        // Address must not be already recored\\n        uint256 _myExposureIndex = getExposureMappingIndex(_symbol, _address);\\n        if (_myExposureIndex == 0) {\\n            uint256 _maxMappingIndex = getMaxMappingIndex(_symbol).add(1);\\n            setMaxMappingIndex(_symbol, _maxMappingIndex);\\n            setExposureMapping(_symbol, _address, _maxMappingIndex);\\n        }\\n    }\\n\\n    function deleteExposureByMarket(bytes32 _symbol, address _address) private {\\n        // Get my index in mapping\\n        uint256 _myExposureIndex = getExposureMappingIndex(_symbol, _address);\\n        // Get last element of mapping\\n        uint256 _lastIndex = getMaxMappingIndex(_symbol);\\n        address _lastAddress = getExposureMappingAddress(_symbol, _lastIndex);\\n        // If _myExposureIndex is greater than 0 (i.e. there is an exposure of that address on that market) delete it\\n        if (_myExposureIndex \\u003e 0) {\\n            // If _myExposureIndex is less than _lastIndex overwrite element at _myExposureIndex with element at _lastIndex in\\n            // deleted elements position.\\n            if (_myExposureIndex \\u003c _lastIndex) {\\n                setExposureMappingAddress(_symbol, _lastAddress, _myExposureIndex);\\n                setExposureMappingIndex(_symbol, _lastAddress, _myExposureIndex);\\n            }\\n            // Delete _lastIndex and _lastAddress element and reduce maxExposureIndex\\n            setExposureMappingAddress(_symbol, address(0), _lastIndex);\\n            setExposureMappingIndex(_symbol, _address, 0);\\n            // Shouldn\\u0027t happen, but check that not empty\\n            if (_lastIndex \\u003e 0) {\\n                setMaxMappingIndex(_symbol, _lastIndex.sub(1));\\n            }\\n        }\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Calculate and send operating reward\\n    // Every 24 hours the protocol mints rewardBasisPoints/(PRECISION) percent of the total\\n    // supply as reward for the protocol operator. The amount can not exceed 0.015% per\\n    // day.\\n    // ----------------------------------------------------------------------------\\n\\n    function payOperatingReward() public onlyMainChain {\\n        if (now \\u003e lastRewardTime.add(REWARDPERIOD)) {\\n            uint256 _reward = totalSupply.mul(rewardBasisPoints).div(PRECISION);\\n            setLastRewardTime(lastRewardTime.add(REWARDPERIOD));\\n            mint(morpherRewards, _reward);\\n            emit OperatingRewardMinted(morpherRewards, _reward);\\n        }\\n    }\\n}\\n\"},\"MorpherToken.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./MorpherState.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn\\u0027t required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract MorpherToken is IERC20, Ownable {\\n\\n    MorpherState state;\\n    using SafeMath for uint256;\\n\\n    string public constant name     = \\\"Morpher\\\";\\n    string public constant symbol   = \\\"MPH\\\";\\n    uint8  public constant decimals = 18;\\n    \\n    modifier onlyState {\\n        require(msg.sender == address(state), \\\"ERC20: caller must be MorpherState contract.\\\");\\n        _;\\n    }\\n\\n    modifier canTransfer {\\n        require(state.getCanTransfer(msg.sender), \\\"ERC20: token transfers disabled on sidechain.\\\");\\n        _;\\n    }\\n    \\n    event LinkState(address _address);\\n\\n    // ------------------------------------------------------------------------\\n    // Constructor\\n    // ------------------------------------------------------------------------\\n    constructor(address _stateAddress, address _coldStorageOwnerAddress) public {\\n        setMorpherState(_stateAddress);\\n        transferOwnership(_coldStorageOwnerAddress);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Links Token Contract with State\\n    // ------------------------------------------------------------------------\\n    function setMorpherState(address _stateAddress) public onlyOwner {\\n        state = MorpherState(_stateAddress);\\n        emit LinkState(_stateAddress);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return state.totalSupply();\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address _account) public view returns (uint256) {\\n        return state.balanceOf(_account);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     * \\n     * Emits a {Transfer} event via emitTransfer called by MorpherState\\n     */\\n    function transfer(address _recipient, uint256 _amount) public returns (bool) {\\n        _transfer(msg.sender, _recipient, _amount);\\n        return true;\\n    }\\n\\n   /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address _owner, address _spender) public view returns (uint256) {\\n        return state.getAllowance(_owner, _spender);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address _spender, uint256 _amount) public returns (bool) {\\n        _approve(msg.sender, _spender, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `_sender` and `_recipient` cannot be the zero address.\\n     * - `_sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `_sender`\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address _sender, address _recipient, uint256 amount) public returns (bool) {\\n        _transfer(_sender, _recipient, amount);\\n        _approve(_sender, msg.sender, state.getAllowance(_sender, msg.sender).sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `_spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\\n        _approve(msg.sender, _spender, state.getAllowance(msg.sender, _spender).add(_addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\\n        _approve(msg.sender, _spender,  state.getAllowance(msg.sender, _spender).sub(_subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Caller destroys `_amount` tokens permanently\\n     *\\n     * Emits a {Transfer} event to zero address called by MorpherState via emitTransfer.\\n     *\\n     * Requirements:\\n     *\\n     * - Caller must have token balance of at least `_amount`\\n     * \\n     */\\n     function burn(uint256 _amount) public returns (bool) {\\n        state.burn(msg.sender, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Emits a {Transfer} event\\n     *\\n     * MorpherState emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - Caller must be MorpherState\\n     * \\n     */\\n     function emitTransfer(address _from, address _to, uint256 _amount) public onlyState {\\n        emit Transfer(_from, _to, _amount);\\n    }\\n\\n     /**\\n     * @dev Moves tokens `_amount` from `sender` to `_recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event via emitTransfer called by MorpherState\\n     *\\n     * Requirements:\\n     *\\n     * - `_sender` cannot be the zero address.\\n     * - `_recipient` cannot be the zero address.\\n     * - `_sender` must have a balance of at least `_amount`.\\n     */\\n    function _transfer(address _sender, address _recipient, uint256 _amount) canTransfer internal {\\n        require(_sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(_recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(state.balanceOf(_sender) \\u003e= _amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        state.transfer(_sender, _recipient, _amount);\\n    }\\n\\n    /**\\n     * @dev Sets `_amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\\n        require(_owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(_spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        state.setAllowance(_owner, _spender, _amount);\\n        emit Approval(_owner, _spender, _amount);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Don\\u0027t accept ETH\\n    // ------------------------------------------------------------------------\\n    function () external payable {\\n        revert(\\\"ERC20: You can\\u0027t deposit Ether here\\\");\\n    }\\n}\\n\"},\"MorpherTradeEngine.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./MorpherState.sol\\\";\\nimport \\\"./IMorpherStaking.sol\\\";\\nimport \\\"./MorpherMintingLimiter.sol\\\";\\n\\n// ----------------------------------------------------------------------------------\\n// Tradeengine of the Morpher platform\\n// Creates and processes orders, and computes the state change of portfolio.\\n// Needs writing/reading access to/from Morpher State. Order objects are stored locally,\\n// portfolios are stored in state.\\n// ----------------------------------------------------------------------------------\\n\\ncontract MorpherTradeEngine is Ownable {\\n    MorpherState state;\\n    IMorpherStaking staking;\\n    MorpherMintingLimiter mintingLimiter;\\n    using SafeMath for uint256;\\n\\n// ----------------------------------------------------------------------------\\n// Precision of prices and leverage\\n// ----------------------------------------------------------------------------\\n    uint256 constant PRECISION = 10**8;\\n    uint256 public orderNonce;\\n    bytes32 public lastOrderId;\\n    uint256 public deployedTimeStamp;\\n\\n    address public escrowOpenOrderAddress = 0x1111111111111111111111111111111111111111;\\n    bool public escrowOpenOrderEnabled;\\n\\n\\n    //we\\u0027re locking positions in for this price at a market marketId;\\n    address public closedMarketPriceLock = 0x0000000000000000000000000000000000000001;\\n\\n\\n// ----------------------------------------------------------------------------\\n// Order struct contains all order specific varibles. Variables are completed\\n// during processing of trade. State changes are saved in the order struct as\\n// well, since local variables would lead to stack to deep errors *sigh*.\\n// ----------------------------------------------------------------------------\\n    struct order {\\n        address userId;\\n        bytes32 marketId;\\n        uint256 closeSharesAmount;\\n        uint256 openMPHTokenAmount;\\n        bool tradeDirection; // true = long, false = short\\n        uint256 liquidationTimestamp;\\n        uint256 marketPrice;\\n        uint256 marketSpread;\\n        uint256 orderLeverage;\\n        uint256 timeStamp;\\n        uint256 longSharesOrder;\\n        uint256 shortSharesOrder;\\n        uint256 balanceDown;\\n        uint256 balanceUp;\\n        uint256 newLongShares;\\n        uint256 newShortShares;\\n        uint256 newMeanEntryPrice;\\n        uint256 newMeanEntrySpread;\\n        uint256 newMeanEntryLeverage;\\n        uint256 newLiquidationPrice;\\n        uint256 orderEscrowAmount;\\n    }\\n\\n    mapping(bytes32 =\\u003e order) private orders;\\n\\n// ----------------------------------------------------------------------------\\n// Events\\n// Order created/processed events are fired by MorpherOracle.\\n// ----------------------------------------------------------------------------\\n\\n    event PositionLiquidated(\\n        address indexed _address,\\n        bytes32 indexed _marketId,\\n        bool _longPosition,\\n        uint256 _timeStamp,\\n        uint256 _marketPrice,\\n        uint256 _marketSpread\\n    );\\n\\n    event OrderCancelled(\\n        bytes32 indexed _orderId,\\n        address indexed _address\\n    );\\n\\n    event OrderIdRequested(\\n        bytes32 _orderId,\\n        address indexed _address,\\n        bytes32 indexed _marketId,\\n        uint256 _closeSharesAmount,\\n        uint256 _openMPHTokenAmount,\\n        bool _tradeDirection,\\n        uint256 _orderLeverage\\n    );\\n\\n    event OrderProcessed(\\n        bytes32 _orderId,\\n        uint256 _marketPrice,\\n        uint256 _marketSpread,\\n        uint256 _liquidationTimestamp,\\n        uint256 _timeStamp,\\n        uint256 _newLongShares,\\n        uint256 _newShortShares,\\n        uint256 _newAverageEntry,\\n        uint256 _newAverageSpread,\\n        uint256 _newAverageLeverage,\\n        uint256 _liquidationPrice\\n    );\\n\\n    event PositionUpdated(\\n        address _userId,\\n        bytes32 _marketId,\\n        uint256 _timeStamp,\\n        uint256 _newLongShares,\\n        uint256 _newShortShares,\\n        uint256 _newMeanEntryPrice,\\n        uint256 _newMeanEntrySpread,\\n        uint256 _newMeanEntryLeverage,\\n        uint256 _newLiquidationPrice,\\n        uint256 _mint,\\n        uint256 _burn\\n    );\\n\\n    event LinkState(address _address);\\n    event LinkStaking(address _stakingAddress);\\n    event LinkMintingLimiter(address _mintingLimiterAddress);\\n\\n    \\n    event LockedPriceForClosingPositions(bytes32 _marketId, uint256 _price);\\n\\n\\n    constructor(address _stateAddress, address _coldStorageOwnerAddress, address _stakingContractAddress, bool _escrowOpenOrderEnabled, uint256 _deployedTimestampOverride, address _mintingLimiterAddress) public {\\n        setMorpherState(_stateAddress);\\n        setMorpherStaking(_stakingContractAddress);\\n        setMorpherMintingLimiter(_mintingLimiterAddress);\\n        transferOwnership(_coldStorageOwnerAddress);\\n        escrowOpenOrderEnabled = _escrowOpenOrderEnabled;\\n        deployedTimeStamp = _deployedTimestampOverride \\u003e 0 ? _deployedTimestampOverride : block.timestamp;\\n    }\\n\\n    modifier onlyOracle {\\n        require(msg.sender == state.getOracleContract(), \\\"MorpherTradeEngine: function can only be called by Oracle Contract.\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdministrator {\\n        require(msg.sender == getAdministrator(), \\\"MorpherTradeEngine: function can only be called by the Administrator.\\\");\\n        _;\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// Administrative functions\\n// Set state address, get administrator address\\n// ----------------------------------------------------------------------------\\n\\n    function setMorpherState(address _stateAddress) public onlyOwner {\\n        state = MorpherState(_stateAddress);\\n        emit LinkState(_stateAddress);\\n    }\\n\\n    function setMorpherStaking(address _stakingAddress) public onlyOwner {\\n        staking = IMorpherStaking(_stakingAddress);\\n        emit LinkStaking(_stakingAddress);\\n    }\\n\\n    function setMorpherMintingLimiter(address _mintingLimiterAddress) public onlyOwner {\\n        mintingLimiter = MorpherMintingLimiter(_mintingLimiterAddress);\\n        emit LinkMintingLimiter(_mintingLimiterAddress);\\n    }\\n\\n    function getAdministrator() public view returns(address _administrator) {\\n        return state.getAdministrator();\\n    }\\n\\n    function setEscrowOpenOrderEnabled(bool _isEnabled) public onlyOwner {\\n        escrowOpenOrderEnabled = _isEnabled;\\n    }\\n    \\n    function paybackEscrow(bytes32 _orderId) private {\\n        //pay back the escrow to the user so he has it back on his balance/**\\n        if(orders[_orderId].orderEscrowAmount \\u003e 0) {\\n            //checks effects interaction\\n            uint256 paybackAmount = orders[_orderId].orderEscrowAmount;\\n            orders[_orderId].orderEscrowAmount = 0;\\n            state.transfer(escrowOpenOrderAddress, orders[_orderId].userId, paybackAmount);\\n        }\\n    }\\n\\n    function buildupEscrow(bytes32 _orderId, uint256 _amountInMPH) private {\\n        if(escrowOpenOrderEnabled \\u0026\\u0026 _amountInMPH \\u003e 0) {\\n            state.transfer(orders[_orderId].userId, escrowOpenOrderAddress, _amountInMPH);\\n            orders[_orderId].orderEscrowAmount = _amountInMPH;\\n        }\\n    }\\n\\n\\n    function validateClosedMarketOrderConditions(address _address, bytes32 _marketId, uint256 _closeSharesAmount, uint256 _openMPHTokenAmount, bool _tradeDirection ) internal view {\\n        //markets active? Still tradeable?\\n        if(_openMPHTokenAmount \\u003e 0) {\\n            require(state.getMarketActive(_marketId) == true, \\\"MorpherTradeEngine: market unknown or currently not enabled for trading.\\\");\\n        } else {\\n            //we\\u0027re just closing a position, but it needs a forever price locked in if market is not active\\n            //the user needs to close his complete position\\n            if(state.getMarketActive(_marketId) == false) {\\n                require(getDeactivatedMarketPrice(_marketId) \\u003e 0, \\\"MorpherTradeEngine: Can\\u0027t close a position, market not active and closing price not locked\\\");\\n                if(_tradeDirection) {\\n                    //long\\n                    require(_closeSharesAmount == state.getShortShares(_address, _marketId), \\\"MorpherTradeEngine: Deactivated market order needs all shares to be closed\\\");\\n                } else {\\n                    //short\\n                    require(_closeSharesAmount == state.getLongShares(_address, _marketId), \\\"MorpherTradeEngine: Deactivated market order needs all shares to be closed\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    //wrapper for stack too deep errors\\n    function validateClosedMarketOrder(bytes32 _orderId) internal view {\\n         validateClosedMarketOrderConditions(orders[_orderId].userId, orders[_orderId].marketId, orders[_orderId].closeSharesAmount, orders[_orderId].openMPHTokenAmount, orders[_orderId].tradeDirection);\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// requestOrderId(address _address, bytes32 _marketId, bool _closeSharesAmount, uint256 _openMPHTokenAmount, bool _tradeDirection, uint256 _orderLeverage)\\n// Creates a new order object with unique orderId and assigns order information.\\n// Must be called by MorpherOracle contract.\\n// ----------------------------------------------------------------------------\\n\\n    function requestOrderId(\\n        address _address,\\n        bytes32 _marketId,\\n        uint256 _closeSharesAmount,\\n        uint256 _openMPHTokenAmount,\\n        bool _tradeDirection,\\n        uint256 _orderLeverage\\n        ) public onlyOracle returns (bytes32 _orderId) {\\n            \\n        require(_orderLeverage \\u003e= PRECISION, \\\"MorpherTradeEngine: leverage too small. Leverage precision is 1e8\\\");\\n        require(_orderLeverage \\u003c= state.getMaximumLeverage(), \\\"MorpherTradeEngine: leverage exceeds maximum allowed leverage.\\\");\\n\\n        validateClosedMarketOrderConditions(_address, _marketId, _closeSharesAmount, _openMPHTokenAmount, _tradeDirection);\\n\\n        //request limits\\n        require(state.getNumberOfRequests(_address) \\u003c= state.getNumberOfRequestsLimit() ||\\n            state.getLastRequestBlock(_address) \\u003c block.number,\\n            \\\"MorpherTradeEngine: request exceeded maximum permitted requests per block.\\\"\\n        );\\n\\n        /**\\n         * The user can\\u0027t partially close a position and open another one with MPH\\n         */\\n        if(_openMPHTokenAmount \\u003e 0) {\\n            if(_tradeDirection) {\\n                //long\\n                require(_closeSharesAmount == state.getShortShares(_address, _marketId), \\\"MorpherTradeEngine: Can\\u0027t partially close a position and open another one in opposite direction\\\");\\n            } else {\\n                //short\\n                require(_closeSharesAmount == state.getLongShares(_address, _marketId), \\\"MorpherTradeEngine: Can\\u0027t partially close a position and open another one in opposite direction\\\");\\n            }\\n        }\\n\\n        state.setLastRequestBlock(_address);\\n        state.increaseNumberOfRequests(_address);\\n        orderNonce++;\\n        _orderId = keccak256(\\n            abi.encodePacked(\\n                _address,\\n                block.number,\\n                _marketId,\\n                _closeSharesAmount,\\n                _openMPHTokenAmount,\\n                _tradeDirection,\\n                _orderLeverage,\\n                orderNonce\\n                )\\n            );\\n        lastOrderId = _orderId;\\n        orders[_orderId].userId = _address;\\n        orders[_orderId].marketId = _marketId;\\n        orders[_orderId].closeSharesAmount = _closeSharesAmount;\\n        orders[_orderId].openMPHTokenAmount = _openMPHTokenAmount;\\n        orders[_orderId].tradeDirection = _tradeDirection;\\n        orders[_orderId].orderLeverage = _orderLeverage;\\n        emit OrderIdRequested(\\n            _orderId,\\n            _address,\\n            _marketId,\\n            _closeSharesAmount,\\n            _openMPHTokenAmount,\\n            _tradeDirection,\\n            _orderLeverage\\n        );\\n\\n        /**\\n         * put the money in escrow here if given MPH to open an order\\n         * - also, can only close positions if in shares, so it will\\n         * definitely trigger a mint there.\\n         * The money must be put in escrow even though we have an existing position\\n         */\\n        buildupEscrow(_orderId, _openMPHTokenAmount);\\n\\n        return _orderId;\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// Getter functions for orders, shares, and positions\\n// ----------------------------------------------------------------------------\\n\\n    function getOrder(bytes32 _orderId) public view returns (\\n        address _userId,\\n        bytes32 _marketId,\\n        uint256 _closeSharesAmount,\\n        uint256 _openMPHTokenAmount,\\n        uint256 _marketPrice,\\n        uint256 _marketSpread,\\n        uint256 _orderLeverage\\n        ) {\\n        return(\\n            orders[_orderId].userId,\\n            orders[_orderId].marketId,\\n            orders[_orderId].closeSharesAmount,\\n            orders[_orderId].openMPHTokenAmount,\\n            orders[_orderId].marketPrice,\\n            orders[_orderId].marketSpread,\\n            orders[_orderId].orderLeverage\\n            );\\n    }\\n\\n    function getPosition(address _address, bytes32 _marketId) public view returns (\\n        uint256 _positionLongShares,\\n        uint256 _positionShortShares,\\n        uint256 _positionAveragePrice,\\n        uint256 _positionAverageSpread,\\n        uint256 _positionAverageLeverage,\\n        uint256 _liquidationPrice\\n        ) {\\n        return(\\n            state.getLongShares(_address, _marketId),\\n            state.getShortShares(_address, _marketId),\\n            state.getMeanEntryPrice(_address,_marketId),\\n            state.getMeanEntrySpread(_address,_marketId),\\n            state.getMeanEntryLeverage(_address,_marketId),\\n            state.getLiquidationPrice(_address,_marketId)\\n        );\\n    }\\n\\n    function setDeactivatedMarketPrice(bytes32 _marketId, uint256 _price) public onlyOracle {\\n         state.setPosition(\\n            closedMarketPriceLock,\\n            _marketId,\\n            now.mul(1000),\\n            0,\\n            0,\\n            _price,\\n            0,\\n            0,\\n            0\\n        );\\n\\n        emit LockedPriceForClosingPositions(_marketId, _price);\\n\\n    }\\n\\n    function getDeactivatedMarketPrice(bytes32 _marketId) public view returns(uint256) {\\n        ( , , uint positionForeverClosingPrice, , ,) = state.getPosition(closedMarketPriceLock, _marketId);\\n        return positionForeverClosingPrice;\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// liquidate(bytes32 _orderId)\\n// Checks for bankruptcy of position between its last update and now\\n// Time check is necessary to avoid two consecutive / unorderded liquidations\\n// ----------------------------------------------------------------------------\\n\\n    function liquidate(bytes32 _orderId) private {\\n        address _address = orders[_orderId].userId;\\n        bytes32 _marketId = orders[_orderId].marketId;\\n        uint256 _liquidationTimestamp = orders[_orderId].liquidationTimestamp;\\n        if (_liquidationTimestamp \\u003e state.getLastUpdated(_address, _marketId)) {\\n            if (state.getLongShares(_address,_marketId) \\u003e 0) {\\n                state.setPosition(\\n                    _address,\\n                    _marketId,\\n                    orders[_orderId].timeStamp,\\n                    0,\\n                    state.getShortShares(_address, _marketId),\\n                    0,\\n                    0,\\n                    PRECISION,\\n                    0);\\n                emit PositionLiquidated(\\n                    _address,\\n                    _marketId,\\n                    true,\\n                    orders[_orderId].timeStamp,\\n                    orders[_orderId].marketPrice,\\n                    orders[_orderId].marketSpread\\n                );\\n            }\\n            if (state.getShortShares(_address,_marketId) \\u003e 0) {\\n                state.setPosition(\\n                    _address,\\n                    _marketId,\\n                    orders[_orderId].timeStamp,\\n                    state.getLongShares(_address, _marketId),\\n                    0,\\n                    0,\\n                    0,\\n                    PRECISION,\\n                    0\\n                );\\n                emit PositionLiquidated(\\n                    _address,\\n                    _marketId,\\n                    false,\\n                    orders[_orderId].timeStamp,\\n                    orders[_orderId].marketPrice,\\n                    orders[_orderId].marketSpread\\n                );\\n            }\\n        }\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// processOrder(bytes32 _orderId, uint256 _marketPrice, uint256 _marketSpread, uint256 _liquidationTimestamp, uint256 _timeStamp)\\n// ProcessOrder receives the price/spread/liqidation information from the Oracle and\\n// triggers the processing of the order. If successful, processOrder updates the portfolio state.\\n// Liquidation time check is necessary to avoid two consecutive / unorderded liquidations\\n// ----------------------------------------------------------------------------\\n\\n    function processOrder(\\n        bytes32 _orderId,\\n        uint256 _marketPrice,\\n        uint256 _marketSpread,\\n        uint256 _liquidationTimestamp,\\n        uint256 _timeStampInMS\\n        ) public onlyOracle returns (\\n            uint256 _newLongShares,\\n            uint256 _newShortShares,\\n            uint256 _newAverageEntry,\\n            uint256 _newAverageSpread,\\n            uint256 _newAverageLeverage,\\n            uint256 _liquidationPrice\\n        ) {\\n        require(orders[_orderId].userId != address(0), \\\"MorpherTradeEngine: unable to process, order has been deleted.\\\");\\n        require(_marketPrice \\u003e 0, \\\"MorpherTradeEngine: market priced at zero. Buy order cannot be processed.\\\");\\n        require(_marketPrice \\u003e= _marketSpread, \\\"MorpherTradeEngine: market price lower then market spread. Order cannot be processed.\\\");\\n        \\n        orders[_orderId].marketPrice = _marketPrice;\\n        orders[_orderId].marketSpread = _marketSpread;\\n        orders[_orderId].timeStamp = _timeStampInMS;\\n        orders[_orderId].liquidationTimestamp = _liquidationTimestamp;\\n        \\n        /**\\n        * If the market is deactivated, then override the price with the locked in market price\\n        * if the price wasn\\u0027t locked in: error out.\\n        */\\n        if(state.getMarketActive(orders[_orderId].marketId) == false) {\\n            validateClosedMarketOrder(_orderId);\\n            orders[_orderId].marketPrice = getDeactivatedMarketPrice(orders[_orderId].marketId);\\n        }\\n        \\n        // Check if previous position on that market was liquidated\\n        if (_liquidationTimestamp \\u003e state.getLastUpdated(orders[_orderId].userId, orders[_orderId].marketId)) {\\n            liquidate(_orderId);\\n        }\\n    \\n\\n        paybackEscrow(_orderId);\\n\\n        if (orders[_orderId].tradeDirection) {\\n            processBuyOrder(_orderId);\\n        } else {\\n            processSellOrder(_orderId);\\n        }\\n\\n        address _address = orders[_orderId].userId;\\n        bytes32 _marketId = orders[_orderId].marketId;\\n        delete orders[_orderId];\\n        emit OrderProcessed(\\n            _orderId,\\n            _marketPrice,\\n            _marketSpread,\\n            _liquidationTimestamp,\\n            _timeStampInMS,\\n            _newLongShares,\\n            _newShortShares,\\n            _newAverageEntry,\\n            _newAverageSpread,\\n            _newAverageLeverage,\\n            _liquidationPrice\\n        );\\n\\n        return (\\n            state.getLongShares(_address, _marketId),\\n            state.getShortShares(_address, _marketId),\\n            state.getMeanEntryPrice(_address,_marketId),\\n            state.getMeanEntrySpread(_address,_marketId),\\n            state.getMeanEntryLeverage(_address,_marketId),\\n            state.getLiquidationPrice(_address,_marketId)\\n        );\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// function cancelOrder(bytes32 _orderId, address _address)\\n// Users or Administrator can delete pending orders before the callback went through\\n// ----------------------------------------------------------------------------\\n    function cancelOrder(bytes32 _orderId, address _address) public onlyOracle {\\n        require(_address == orders[_orderId].userId || _address == getAdministrator(), \\\"MorpherTradeEngine: only Administrator or user can cancel an order.\\\");\\n        require(orders[_orderId].userId != address(0), \\\"MorpherTradeEngine: unable to process, order does not exist.\\\");\\n\\n        /**\\n         * Pay back any escrow there\\n         */\\n        paybackEscrow(_orderId);\\n\\n        delete orders[_orderId];\\n        emit OrderCancelled(_orderId, _address);\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// shortShareValue / longShareValue compute the value of a virtual future\\n// given current price/spread/leverage of the market and mean price/spread/leverage\\n// at the beginning of the trade\\n// ----------------------------------------------------------------------------\\n    function shortShareValue(\\n        uint256 _positionAveragePrice,\\n        uint256 _positionAverageLeverage,\\n        uint256 _positionTimeStampInMs,\\n        uint256 _marketPrice,\\n        uint256 _marketSpread,\\n        uint256 _orderLeverage,\\n        bool _sell\\n        ) public view returns (uint256 _shareValue) {\\n\\n        uint256 _averagePrice = _positionAveragePrice;\\n        uint256 _averageLeverage = _positionAverageLeverage;\\n\\n        if (_positionAverageLeverage \\u003c PRECISION) {\\n            // Leverage can never be less than 1. Fail safe for empty positions, i.e. undefined _positionAverageLeverage\\n            _averageLeverage = PRECISION;\\n        }\\n        if (_sell == false) {\\n            // New short position\\n            // It costs marketPrice + marketSpread to build up a new short position\\n            _averagePrice = _marketPrice;\\n\\t        // This is the average Leverage\\n\\t        _averageLeverage = _orderLeverage;\\n        }\\n        if (\\n            getLiquidationPrice(_averagePrice, _averageLeverage, false, _positionTimeStampInMs) \\u003c= _marketPrice\\n            ) {\\n\\t        // Position is worthless\\n            _shareValue = 0;\\n        } else {\\n            // The regular share value is 2x the entry price minus the current price for short positions.\\n            _shareValue = _averagePrice.mul((PRECISION.add(_averageLeverage))).div(PRECISION);\\n            _shareValue = _shareValue.sub(_marketPrice.mul(_averageLeverage).div(PRECISION));\\n            if (_sell == true) {\\n                // We have to reduce the share value by the average spread (i.e. the average expense to build up the position)\\n                // and reduce the value further by the spread for selling.\\n                _shareValue = _shareValue.sub(_marketSpread.mul(_averageLeverage).div(PRECISION));\\n                uint256 _marginInterest = calculateMarginInterest(_averagePrice, _averageLeverage, _positionTimeStampInMs);\\n                if (_marginInterest \\u003c= _shareValue) {\\n                    _shareValue = _shareValue.sub(_marginInterest);\\n                } else {\\n                    _shareValue = 0;\\n                }\\n            } else {\\n                // If a new short position is built up each share costs value + spread\\n                _shareValue = _shareValue.add(_marketSpread.mul(_orderLeverage).div(PRECISION));\\n            }\\n        }\\n      \\n        return _shareValue;\\n    }\\n\\n    function longShareValue(\\n        uint256 _positionAveragePrice,\\n        uint256 _positionAverageLeverage,\\n        uint256 _positionTimeStampInMs,\\n        uint256 _marketPrice,\\n        uint256 _marketSpread,\\n        uint256 _orderLeverage,\\n        bool _sell\\n        ) public view returns (uint256 _shareValue) {\\n\\n        uint256 _averagePrice = _positionAveragePrice;\\n        uint256 _averageLeverage = _positionAverageLeverage;\\n\\n        if (_positionAverageLeverage \\u003c PRECISION) {\\n            // Leverage can never be less than 1. Fail safe for empty positions, i.e. undefined _positionAverageLeverage\\n            _averageLeverage = PRECISION;\\n        }\\n        if (_sell == false) {\\n            // New long position\\n            // It costs marketPrice + marketSpread to build up a new long position\\n            _averagePrice = _marketPrice;\\n\\t        // This is the average Leverage\\n\\t        _averageLeverage = _orderLeverage;\\n        }\\n        if (\\n            _marketPrice \\u003c= getLiquidationPrice(_averagePrice, _averageLeverage, true, _positionTimeStampInMs)\\n            ) {\\n\\t        // Position is worthless\\n            _shareValue = 0;\\n        } else {\\n            _shareValue = _averagePrice.mul(_averageLeverage.sub(PRECISION)).div(PRECISION);\\n            // The regular share value is market price times leverage minus entry price times entry leverage minus one.\\n            _shareValue = (_marketPrice.mul(_averageLeverage).div(PRECISION)).sub(_shareValue);\\n            if (_sell == true) {\\n                // We sell a long and have to correct the shareValue with the averageSpread and the currentSpread for selling.\\n                _shareValue = _shareValue.sub(_marketSpread.mul(_averageLeverage).div(PRECISION));\\n                \\n                uint256 _marginInterest = calculateMarginInterest(_averagePrice, _averageLeverage, _positionTimeStampInMs);\\n                if (_marginInterest \\u003c= _shareValue) {\\n                    _shareValue = _shareValue.sub(_marginInterest);\\n                } else {\\n                    _shareValue = 0;\\n                }\\n            } else {\\n                // We buy a new long position and have to pay the spread\\n                _shareValue = _shareValue.add(_marketSpread.mul(_orderLeverage).div(PRECISION));\\n            }\\n        }\\n        return _shareValue;\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// calculateMarginInterest(uint256 _averagePrice, uint256 _averageLeverage, uint256 _positionTimeStamp)\\n// Calculates the interest for leveraged positions\\n// ----------------------------------------------------------------------------\\n\\n\\n    function calculateMarginInterest(uint256 _averagePrice, uint256 _averageLeverage, uint256 _positionTimeStampInMs) public view returns (uint256 _marginInterest) {\\n        if (_positionTimeStampInMs.div(1000) \\u003c deployedTimeStamp) {\\n            _positionTimeStampInMs = deployedTimeStamp.mul(1000);\\n        }\\n        _marginInterest = _averagePrice.mul(_averageLeverage.sub(PRECISION));\\n        _marginInterest = _marginInterest.mul((now.sub(_positionTimeStampInMs.div(1000)).div(86400)).add(1));\\n        _marginInterest = _marginInterest.mul(staking.interestRate()).div(PRECISION).div(PRECISION);\\n        return _marginInterest;\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// processBuyOrder(bytes32 _orderId)\\n// Converts orders specified in virtual shares to orders specified in Morpher token\\n// and computes the number of short shares that are sold and long shares that are bought.\\n// long shares are bought only if the order amount exceeds all open short positions\\n// ----------------------------------------------------------------------------\\n\\n    function processBuyOrder(bytes32 _orderId) private {\\n        if (orders[_orderId].closeSharesAmount \\u003e 0) {\\n            //calcualte the balanceUp/down first\\n            //then reopen the position with MPH amount\\n\\n             // Investment was specified in shares\\n            if (orders[_orderId].closeSharesAmount \\u003c= state.getShortShares(orders[_orderId].userId, orders[_orderId].marketId)) {\\n                // Partial closing of short position\\n                orders[_orderId].shortSharesOrder = orders[_orderId].closeSharesAmount;\\n            } else {\\n                // Closing of entire short position\\n                orders[_orderId].shortSharesOrder = state.getShortShares(orders[_orderId].userId, orders[_orderId].marketId);\\n            }\\n        }\\n\\n        //calculate the long shares, but only if the old position is completely closed out (if none exist shortSharesOrder = 0)\\n        if(\\n            orders[_orderId].shortSharesOrder == state.getShortShares(orders[_orderId].userId, orders[_orderId].marketId) \\u0026\\u0026 \\n            orders[_orderId].openMPHTokenAmount \\u003e 0\\n        ) {\\n            orders[_orderId].longSharesOrder = orders[_orderId].openMPHTokenAmount.div(\\n                longShareValue(\\n                    orders[_orderId].marketPrice,\\n                    orders[_orderId].orderLeverage,\\n                    now.mul(1000),\\n                    orders[_orderId].marketPrice,\\n                    orders[_orderId].marketSpread,\\n                    orders[_orderId].orderLeverage,\\n                    false\\n            ));\\n        }\\n\\n        // Investment equals number of shares now.\\n        if (orders[_orderId].shortSharesOrder \\u003e 0) {\\n            closeShort(_orderId);\\n        }\\n        if (orders[_orderId].longSharesOrder \\u003e 0) {\\n            openLong(_orderId);\\n        }\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// processSellOrder(bytes32 _orderId)\\n// Converts orders specified in virtual shares to orders specified in Morpher token\\n// and computes the number of long shares that are sold and short shares that are bought.\\n// short shares are bought only if the order amount exceeds all open long positions\\n// ----------------------------------------------------------------------------\\n\\n    function processSellOrder(bytes32 _orderId) private {\\n        if (orders[_orderId].closeSharesAmount \\u003e 0) {\\n            //calcualte the balanceUp/down first\\n            //then reopen the position with MPH amount\\n\\n            // Investment was specified in shares\\n            if (orders[_orderId].closeSharesAmount \\u003c= state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId)) {\\n                // Partial closing of long position\\n                orders[_orderId].longSharesOrder = orders[_orderId].closeSharesAmount;\\n            } else {\\n                // Closing of entire long position\\n                orders[_orderId].longSharesOrder = state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId);\\n            }\\n        }\\n\\n        if(\\n            orders[_orderId].longSharesOrder == state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId) \\u0026\\u0026 \\n            orders[_orderId].openMPHTokenAmount \\u003e 0\\n        ) {\\n        orders[_orderId].shortSharesOrder = orders[_orderId].openMPHTokenAmount.div(\\n                    shortShareValue(\\n                        orders[_orderId].marketPrice,\\n                        orders[_orderId].orderLeverage,\\n                        now.mul(1000),\\n                        orders[_orderId].marketPrice,\\n                        orders[_orderId].marketSpread,\\n                        orders[_orderId].orderLeverage,\\n                        false\\n                ));\\n        }\\n        // Investment equals number of shares now.\\n        if (orders[_orderId].longSharesOrder \\u003e 0) {\\n            closeLong(_orderId);\\n        }\\n        if (orders[_orderId].shortSharesOrder \\u003e 0) {\\n            openShort(_orderId);\\n        }\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// openLong(bytes32 _orderId)\\n// Opens a new long position and computes the new resulting average entry price/spread/leverage.\\n// Computation is broken down to several instructions for readability.\\n// ----------------------------------------------------------------------------\\n    function openLong(bytes32 _orderId) private {\\n        address _userId = orders[_orderId].userId;\\n        bytes32 _marketId = orders[_orderId].marketId;\\n\\n        uint256 _newMeanSpread;\\n        uint256 _newMeanLeverage;\\n\\n        // Existing position is virtually liquidated and reopened with current marketPrice\\n        // orders[_orderId].newMeanEntryPrice = orders[_orderId].marketPrice;\\n        // _factorLongShares is a factor to adjust the existing longShares via virtual liqudiation and reopening at current market price\\n\\n        uint256 _factorLongShares = state.getMeanEntryLeverage(_userId, _marketId);\\n        if (_factorLongShares \\u003c PRECISION) {\\n            _factorLongShares = PRECISION;\\n        }\\n        _factorLongShares = _factorLongShares.sub(PRECISION);\\n        _factorLongShares = _factorLongShares.mul(state.getMeanEntryPrice(_userId, _marketId)).div(orders[_orderId].marketPrice);\\n        if (state.getMeanEntryLeverage(_userId, _marketId) \\u003e _factorLongShares) {\\n            _factorLongShares = state.getMeanEntryLeverage(_userId, _marketId).sub(_factorLongShares);\\n        } else {\\n            _factorLongShares = 0;\\n        }\\n\\n        uint256 _adjustedLongShares = _factorLongShares.mul(state.getLongShares(_userId, _marketId)).div(PRECISION);\\n\\n        // _newMeanLeverage is the weighted leverage of the existing position and the new position\\n        _newMeanLeverage = state.getMeanEntryLeverage(_userId, _marketId).mul(_adjustedLongShares);\\n        _newMeanLeverage = _newMeanLeverage.add(orders[_orderId].orderLeverage.mul(orders[_orderId].longSharesOrder));\\n        _newMeanLeverage = _newMeanLeverage.div(_adjustedLongShares.add(orders[_orderId].longSharesOrder));\\n\\n        // _newMeanSpread is the weighted spread of the existing position and the new position\\n        _newMeanSpread = state.getMeanEntrySpread(_userId, _marketId).mul(state.getLongShares(_userId, _marketId));\\n        _newMeanSpread = _newMeanSpread.add(orders[_orderId].marketSpread.mul(orders[_orderId].longSharesOrder));\\n        _newMeanSpread = _newMeanSpread.div(_adjustedLongShares.add(orders[_orderId].longSharesOrder));\\n\\n        orders[_orderId].balanceDown = orders[_orderId].longSharesOrder.mul(orders[_orderId].marketPrice).add(\\n            orders[_orderId].longSharesOrder.mul(orders[_orderId].marketSpread).mul(orders[_orderId].orderLeverage).div(PRECISION)\\n        );\\n        orders[_orderId].balanceUp = 0;\\n        orders[_orderId].newLongShares = _adjustedLongShares.add(orders[_orderId].longSharesOrder);\\n        orders[_orderId].newShortShares = state.getShortShares(_userId, _marketId);\\n        orders[_orderId].newMeanEntryPrice = orders[_orderId].marketPrice;\\n        orders[_orderId].newMeanEntrySpread = _newMeanSpread;\\n        orders[_orderId].newMeanEntryLeverage = _newMeanLeverage;\\n\\n        setPositionInState(_orderId);\\n    }\\n// ----------------------------------------------------------------------------\\n// closeLong(bytes32 _orderId)\\n// Closes an existing long position. Average entry price/spread/leverage do not change.\\n// ----------------------------------------------------------------------------\\n     function closeLong(bytes32 _orderId) private {\\n        address _userId = orders[_orderId].userId;\\n        bytes32 _marketId = orders[_orderId].marketId;\\n        uint256 _newLongShares  = state.getLongShares(_userId, _marketId).sub(orders[_orderId].longSharesOrder);\\n        uint256 _balanceUp = calculateBalanceUp(_orderId);\\n        uint256 _newMeanEntry;\\n        uint256 _newMeanSpread;\\n        uint256 _newMeanLeverage;\\n\\n        if (orders[_orderId].longSharesOrder == state.getLongShares(_userId, _marketId)) {\\n            _newMeanEntry = 0;\\n            _newMeanSpread = 0;\\n            _newMeanLeverage = PRECISION;\\n        } else {\\n            _newMeanEntry = state.getMeanEntryPrice(_userId, _marketId);\\n\\t        _newMeanSpread = state.getMeanEntrySpread(_userId, _marketId);\\n\\t        _newMeanLeverage = state.getMeanEntryLeverage(_userId, _marketId);\\n            resetTimestampInOrderToLastUpdated(_orderId);\\n        }\\n\\n        orders[_orderId].balanceDown = 0;\\n        orders[_orderId].balanceUp = _balanceUp;\\n        orders[_orderId].newLongShares = _newLongShares;\\n        orders[_orderId].newShortShares = state.getShortShares(_userId, _marketId);\\n        orders[_orderId].newMeanEntryPrice = _newMeanEntry;\\n        orders[_orderId].newMeanEntrySpread = _newMeanSpread;\\n        orders[_orderId].newMeanEntryLeverage = _newMeanLeverage;\\n\\n        setPositionInState(_orderId);\\n    }\\n\\nevent ResetTimestampInOrder(bytes32 _orderId, uint oldTimestamp, uint newTimestamp);\\nfunction resetTimestampInOrderToLastUpdated(bytes32 _orderId) internal {\\n    address userId = orders[_orderId].userId;\\n    bytes32 marketId = orders[_orderId].marketId;\\n    uint lastUpdated = state.getLastUpdated(userId, marketId);\\n    emit ResetTimestampInOrder(_orderId, orders[_orderId].timeStamp, lastUpdated);\\n    orders[_orderId].timeStamp = lastUpdated;\\n}\\n\\n// ----------------------------------------------------------------------------\\n// closeShort(bytes32 _orderId)\\n// Closes an existing short position. Average entry price/spread/leverage do not change.\\n// ----------------------------------------------------------------------------\\nfunction calculateBalanceUp(bytes32 _orderId) private view returns (uint256 _balanceUp) {\\n        address _userId = orders[_orderId].userId;\\n        bytes32 _marketId = orders[_orderId].marketId;\\n        uint256 _shareValue;\\n\\n        if (orders[_orderId].tradeDirection == false) { //we are selling our long shares\\n            _balanceUp = orders[_orderId].longSharesOrder;\\n            _shareValue = longShareValue(\\n                state.getMeanEntryPrice(_userId, _marketId),\\n                state.getMeanEntryLeverage(_userId, _marketId),\\n                state.getLastUpdated(_userId, _marketId),\\n                orders[_orderId].marketPrice,\\n                orders[_orderId].marketSpread,\\n                state.getMeanEntryLeverage(_userId, _marketId),\\n                true\\n            );\\n        } else { //we are going long, we are selling our short shares\\n            _balanceUp = orders[_orderId].shortSharesOrder;\\n            _shareValue = shortShareValue(\\n                state.getMeanEntryPrice(_userId, _marketId),\\n                state.getMeanEntryLeverage(_userId, _marketId),\\n                state.getLastUpdated(_userId, _marketId),\\n                orders[_orderId].marketPrice,\\n                orders[_orderId].marketSpread,\\n                state.getMeanEntryLeverage(_userId, _marketId),\\n                true\\n            );\\n        }\\n        return _balanceUp.mul(_shareValue); \\n    }\\n\\n    function closeShort(bytes32 _orderId) private {\\n        address _userId = orders[_orderId].userId;\\n        bytes32 _marketId = orders[_orderId].marketId;\\n        uint256 _newMeanEntry;\\n        uint256 _newMeanSpread;\\n        uint256 _newMeanLeverage;\\n        uint256 _newShortShares = state.getShortShares(_userId, _marketId).sub(orders[_orderId].shortSharesOrder);\\n        uint256 _balanceUp = calculateBalanceUp(_orderId);\\n        \\n        if (orders[_orderId].shortSharesOrder == state.getShortShares(_userId, _marketId)) {\\n            _newMeanEntry = 0;\\n            _newMeanSpread = 0;\\n\\t        _newMeanLeverage = PRECISION;\\n        } else {\\n            _newMeanEntry = state.getMeanEntryPrice(_userId, _marketId);\\n\\t        _newMeanSpread = state.getMeanEntrySpread(_userId, _marketId);\\n\\t        _newMeanLeverage = state.getMeanEntryLeverage(_userId, _marketId);\\n\\n            /**\\n             * we need the timestamp of the old order for partial closes, not the new one\\n             */\\n            resetTimestampInOrderToLastUpdated(_orderId);\\n        }\\n\\n        orders[_orderId].balanceDown = 0;\\n        orders[_orderId].balanceUp = _balanceUp;\\n        orders[_orderId].newLongShares = state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId);\\n        orders[_orderId].newShortShares = _newShortShares;\\n        orders[_orderId].newMeanEntryPrice = _newMeanEntry;\\n        orders[_orderId].newMeanEntrySpread = _newMeanSpread;\\n        orders[_orderId].newMeanEntryLeverage = _newMeanLeverage;\\n\\n        setPositionInState(_orderId);\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// openShort(bytes32 _orderId)\\n// Opens a new short position and computes the new resulting average entry price/spread/leverage.\\n// Computation is broken down to several instructions for readability.\\n// ----------------------------------------------------------------------------\\n    function openShort(bytes32 _orderId) private {\\n        address _userId = orders[_orderId].userId;\\n        bytes32 _marketId = orders[_orderId].marketId;\\n\\n        uint256 _newMeanSpread;\\n        uint256 _newMeanLeverage;\\n        //\\n        // Existing position is virtually liquidated and reopened with current marketPrice\\n        // orders[_orderId].newMeanEntryPrice = orders[_orderId].marketPrice;\\n        // _factorShortShares is a factor to adjust the existing shortShares via virtual liqudiation and reopening at current market price\\n\\n        uint256 _factorShortShares = state.getMeanEntryLeverage(_userId, _marketId);\\n        if (_factorShortShares \\u003c PRECISION) {\\n            _factorShortShares = PRECISION;\\n        }\\n        _factorShortShares = _factorShortShares.add(PRECISION);\\n        _factorShortShares = _factorShortShares.mul(state.getMeanEntryPrice(_userId, _marketId)).div(orders[_orderId].marketPrice);\\n        if (state.getMeanEntryLeverage(_userId, _marketId) \\u003c _factorShortShares) {\\n            _factorShortShares = _factorShortShares.sub(state.getMeanEntryLeverage(_userId, _marketId));\\n        } else {\\n            _factorShortShares = 0;\\n        }\\n\\n        uint256 _adjustedShortShares = _factorShortShares.mul(state.getShortShares(_userId, _marketId)).div(PRECISION);\\n\\n        // _newMeanLeverage is the weighted leverage of the existing position and the new position\\n        _newMeanLeverage = state.getMeanEntryLeverage(_userId, _marketId).mul(_adjustedShortShares);\\n        _newMeanLeverage = _newMeanLeverage.add(orders[_orderId].orderLeverage.mul(orders[_orderId].shortSharesOrder));\\n        _newMeanLeverage = _newMeanLeverage.div(_adjustedShortShares.add(orders[_orderId].shortSharesOrder));\\n\\n        // _newMeanSpread is the weighted spread of the existing position and the new position\\n        _newMeanSpread = state.getMeanEntrySpread(_userId, _marketId).mul(state.getShortShares(_userId, _marketId));\\n        _newMeanSpread = _newMeanSpread.add(orders[_orderId].marketSpread.mul(orders[_orderId].shortSharesOrder));\\n        _newMeanSpread = _newMeanSpread.div(_adjustedShortShares.add(orders[_orderId].shortSharesOrder));\\n\\n        orders[_orderId].balanceDown = orders[_orderId].shortSharesOrder.mul(orders[_orderId].marketPrice).add(\\n            orders[_orderId].shortSharesOrder.mul(orders[_orderId].marketSpread).mul(orders[_orderId].orderLeverage).div(PRECISION)\\n        );\\n        orders[_orderId].balanceUp = 0;\\n        orders[_orderId].newLongShares = state.getLongShares(_userId, _marketId);\\n        orders[_orderId].newShortShares = _adjustedShortShares.add(orders[_orderId].shortSharesOrder);\\n        orders[_orderId].newMeanEntryPrice = orders[_orderId].marketPrice;\\n        orders[_orderId].newMeanEntrySpread = _newMeanSpread;\\n        orders[_orderId].newMeanEntryLeverage = _newMeanLeverage;\\n\\n        setPositionInState(_orderId);\\n    }\\n\\n    function computeLiquidationPrice(bytes32 _orderId) public returns(uint256 _liquidationPrice) {\\n        orders[_orderId].newLiquidationPrice = 0;\\n        if (orders[_orderId].newLongShares \\u003e 0) {\\n            orders[_orderId].newLiquidationPrice = getLiquidationPrice(orders[_orderId].newMeanEntryPrice, orders[_orderId].newMeanEntryLeverage, true, orders[_orderId].timeStamp);\\n        }\\n        if (orders[_orderId].newShortShares \\u003e 0) {\\n            orders[_orderId].newLiquidationPrice = getLiquidationPrice(orders[_orderId].newMeanEntryPrice, orders[_orderId].newMeanEntryLeverage, false, orders[_orderId].timeStamp);\\n        }\\n        return orders[_orderId].newLiquidationPrice;\\n    }\\n\\n    function getLiquidationPrice(uint256 _newMeanEntryPrice, uint256 _newMeanEntryLeverage, bool _long, uint _positionTimestampInMs) public view returns (uint256 _liquidationPrice) {\\n        if (_long == true) {\\n            _liquidationPrice = _newMeanEntryPrice.mul(_newMeanEntryLeverage.sub(PRECISION)).div(_newMeanEntryLeverage);\\n            _liquidationPrice = _liquidationPrice.add(calculateMarginInterest(_newMeanEntryPrice, _newMeanEntryLeverage, _positionTimestampInMs));\\n        } else {\\n            _liquidationPrice = _newMeanEntryPrice.mul(_newMeanEntryLeverage.add(PRECISION)).div(_newMeanEntryLeverage);\\n            _liquidationPrice = _liquidationPrice.sub(calculateMarginInterest(_newMeanEntryPrice, _newMeanEntryLeverage, _positionTimestampInMs));\\n        }\\n        return _liquidationPrice;\\n    }\\n\\n    \\n// ----------------------------------------------------------------------------\\n// setPositionInState(bytes32 _orderId)\\n// Updates the portfolio in Morpher State. Called by closeLong/closeShort/openLong/openShort\\n// ----------------------------------------------------------------------------\\n    function setPositionInState(bytes32 _orderId) private {\\n        require(state.balanceOf(orders[_orderId].userId).add(orders[_orderId].balanceUp) \\u003e= orders[_orderId].balanceDown, \\\"MorpherTradeEngine: insufficient funds.\\\");\\n        computeLiquidationPrice(_orderId);\\n        // Net balanceUp and balanceDown\\n        if (orders[_orderId].balanceUp \\u003e orders[_orderId].balanceDown) {\\n            orders[_orderId].balanceUp.sub(orders[_orderId].balanceDown);\\n            orders[_orderId].balanceDown = 0;\\n        } else {\\n            orders[_orderId].balanceDown.sub(orders[_orderId].balanceUp);\\n            orders[_orderId].balanceUp = 0;\\n        }\\n        if (orders[_orderId].balanceUp \\u003e 0) {\\n            mintingLimiter.mint(orders[_orderId].userId, orders[_orderId].balanceUp);\\n        }\\n        if (orders[_orderId].balanceDown \\u003e 0) {\\n            state.burn(orders[_orderId].userId, orders[_orderId].balanceDown);\\n        }\\n        state.setPosition(\\n            orders[_orderId].userId,\\n            orders[_orderId].marketId,\\n            orders[_orderId].timeStamp,\\n            orders[_orderId].newLongShares,\\n            orders[_orderId].newShortShares,\\n            orders[_orderId].newMeanEntryPrice,\\n            orders[_orderId].newMeanEntrySpread,\\n            orders[_orderId].newMeanEntryLeverage,\\n            orders[_orderId].newLiquidationPrice\\n        );\\n        emit PositionUpdated(\\n            orders[_orderId].userId,\\n            orders[_orderId].marketId,\\n            orders[_orderId].timeStamp,\\n            orders[_orderId].newLongShares,\\n            orders[_orderId].newShortShares,\\n            orders[_orderId].newMeanEntryPrice,\\n            orders[_orderId].newMeanEntrySpread,\\n            orders[_orderId].newMeanEntryLeverage,\\n            orders[_orderId].newLiquidationPrice,\\n            orders[_orderId].balanceUp,\\n            orders[_orderId].balanceDown\\n        );\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address public _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller should be owner.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     * @notice Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: use renounce ownership instead.\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    // ------------------------------------------------------------------------\\n    // Owner can transfer out any accidentally sent ERC20 tokens\\n    // ------------------------------------------------------------------------\\n    function transferAnyERC20Token(address _tokenAddress, uint256 _tokens) public onlyOwner returns (bool _success) {\\n        return IERC20(_tokenAddress).transfer(owner(), _tokens);\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tradeEngineAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_morpherState\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_callBackAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_gasCollectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasForCallback\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_coldStorageOwnerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_previousTradeEngineAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_previousOracleAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"AddressBlackListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"AddressWhiteListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_closeSharesAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_openMPHTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_tradeDirection\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_orderLeverage\",\"type\":\"uint256\"}],\"name\":\"AdminLiquidationOrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oracleAddress\",\"type\":\"address\"}],\"name\":\"AdminOrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"CallBackCollectionAddressChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"CallbackAddressDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"CallbackAddressEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"}],\"name\":\"DelistMarketComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_processedUntilIndex\",\"type\":\"uint256\"}],\"name\":\"DelistMarketIncomplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_oldFallbackOracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newFallbackOracle\",\"type\":\"address\"}],\"name\":\"FallbackOracleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_oldFallbackTradeEngine\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newFallbackTradeEngine\",\"type\":\"address\"}],\"name\":\"FallbackTradeEngineUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"LinkMorpherState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"LinkTradeEngine\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"}],\"name\":\"LiquidationOrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"LockedPriceForClosingPositions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"OraclePaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"OrderCancellationRequestedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oracleAddress\",\"type\":\"address\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_closeSharesAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_openMPHTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_tradeDirection\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_orderLeverage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_onlyIfPriceBelow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_onlyIfPriceAbove\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_goodFrom\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_goodUntil\",\"type\":\"uint256\"}],\"name\":\"OrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_closeSharesAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_openMPHTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_tradeDirection\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_orderLeverage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_onlyIfPriceBelow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_onlyIfPriceAbove\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_goodFrom\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_goodUntil\",\"type\":\"uint256\"}],\"name\":\"OrderFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_unadjustedMarketPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_spread\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_positionLiquidationTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timeStamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newLongShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newShortShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newMeanEntry\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newMeanSprad\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newMeanLeverage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_liquidationPrice\",\"type\":\"uint256\"}],\"name\":\"OrderProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gasForCallback\",\"type\":\"uint256\"}],\"name\":\"SetGasForCallback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_useWhiteList\",\"type\":\"bool\"}],\"name\":\"SetUseWhiteList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"UpdateSkipPreviousTradeEngineAddress\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unadjustedMarketPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_spread\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasForNextCallback\",\"type\":\"uint256\"}],\"name\":\"__callback\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLongShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newShortShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newMeanEntry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newMeanSpread\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newMeanLeverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"}],\"name\":\"adminCancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"}],\"name\":\"adminLiquidationOrder\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"callBackAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"callBackCollectionAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"checkOrderConditions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_conditionsMet\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"}],\"name\":\"createLiquidationOrder\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_closeSharesAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_openMPHTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_tradeDirection\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_orderLeverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_onlyIfPriceAbove\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_onlyIfPriceBelow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_goodUntil\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_goodFrom\",\"type\":\"uint256\"}],\"name\":\"createOrder\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_startFromScratch\",\"type\":\"bool\"}],\"name\":\"delistMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"disableCallbackAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_closeSharesAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_openMPHTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_tradeDirection\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_orderLeverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_onlyIfPriceBelow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_onlyIfPriceAbove\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_goodFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_goodUntil\",\"type\":\"uint256\"}],\"name\":\"emitOrderFailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"enableCallbackAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasForCallback\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdministrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_administrator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"}],\"name\":\"getGoodFrom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"}],\"name\":\"getGoodUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"}],\"name\":\"getPriceAbove\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"}],\"name\":\"getPriceBelow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"}],\"name\":\"getTradeEngineFromOrderId\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"goodFrom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"goodUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orderId\",\"type\":\"bytes32\"}],\"name\":\"initiateCancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isCallbackAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isCallBackAddress\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isWhiteListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_whiteListed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderCancellationRequested\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderIdTradeEngineAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasForCallback\",\"type\":\"uint256\"}],\"name\":\"overrideGasForCallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousOracleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousTradeEngineAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"priceAbove\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"priceBelow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_blackList\",\"type\":\"address\"}],\"name\":\"setBlackList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setCallbackCollectionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setDeactivatedMarketPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setStateAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setTradeEngineAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_useWhiteList\",\"type\":\"bool\"}],\"name\":\"setUseWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whiteList\",\"type\":\"address\"}],\"name\":\"setWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"skipPreviousTradeEngineAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_source\",\"type\":\"string\"}],\"name\":\"stringToHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_result\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpauseOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleFallbackAddress\",\"type\":\"address\"}],\"name\":\"updateFallbackOracleAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tradeEngineFallbackAddress\",\"type\":\"address\"}],\"name\":\"updateFallbackTradeEngineAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_skipTradeEngineAddress\",\"type\":\"address\"}],\"name\":\"updateSkipTradeEngineAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"useWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MorpherOracle","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000062e26ab4444e24e42e63a0857bf56ea1c70aaec80000000000000000000000001f426c51f0ef7655a6f4c3eb58017d2f1c381bff0000000000000000000000004cad8e39530f2c356bfdb1c42605a7eedc4b253f0000000000000000000000004cad8e39530f2c356bfdb1c42605a7eedc4b253f000000000000000000000000000000000000000000000000006a94d74f43000000000000000000000000000051c5ce7c4926d5ca74f4824e11a062f1ef491762000000000000000000000000b4881186b9e52f8bd6ec5f19708450ce57b243700000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://ee07e244602359a838cd221947f962b2e7c031137ae4c9f29dd19e3b090e454a"}]}