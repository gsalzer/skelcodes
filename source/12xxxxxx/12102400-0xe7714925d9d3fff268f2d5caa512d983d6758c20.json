{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interface/MarketInterfaces.sol\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract ShardsMarketAdminStorage {\r\n    /**\r\n     * @notice Administrator for this contract\r\n     */\r\n    address public admin;\r\n    /**\r\n     * @notice Governance for this contract which has the right to adjust the parameters of market\r\n     */\r\n    address public governance;\r\n\r\n    /**\r\n     * @notice Active brains of ShardsMarket\r\n     */\r\n    address public implementation;\r\n}\r\n\r\ncontract IShardsMarketStorge is ShardsMarketAdminStorage {\r\n    address public shardsFactory;\r\n\r\n    address public factory;\r\n\r\n    address public router;\r\n\r\n    address public dev;\r\n\r\n    address public platformFund;\r\n\r\n    address public shardsFarm;\r\n\r\n    address public buyoutProposals;\r\n\r\n    address public regulator;\r\n\r\n    address public shardAdditionProposal;\r\n\r\n    address public WETH;\r\n    //The totalSupply of shard in the market\r\n    uint256 public totalSupply = 10000000000000000000000;\r\n    //Stake Time limit: 60*60*24*5\r\n    uint256 public deadlineForStake = 432000;\r\n    //Redeem Time limit:60*60*24*7\r\n    uint256 public deadlineForRedeem = 604800;\r\n    //The Proportion of the shardsCreator's shards\r\n    uint256 public shardsCreatorProportion = 5;\r\n    //The Proportion of the platform's shards\r\n    uint256 public platformProportion = 5;\r\n    //The Proportion for dev of the market profit,the rest of profit is given to platformFund\r\n    uint256 public profitProportionForDev = 20;\r\n    //max\r\n    uint256 internal constant max = 100;\r\n    //shardPool count\r\n    uint256 public shardPoolIdCount;\r\n    // all of the shardpoolId\r\n    uint256[] internal allPools;\r\n    // Info of each pool.\r\n    mapping(uint256 => shardPool) public poolInfo;\r\n    //shardPool struct\r\n    struct shardPool {\r\n        address creator; //shard  creator\r\n        ShardsState state; //shard state\r\n        uint256 createTime;\r\n        uint256 deadlineForStake;\r\n        uint256 deadlineForRedeem;\r\n        uint256 balanceOfWantToken; // all the stake amount of the wantToken in this pool\r\n        uint256 minWantTokenAmount; //Minimum subscription required by the creator\r\n        bool isCreatorWithDraw; //Does the creator withdraw wantToken\r\n        address wantToken; // token address Requested by the creator for others to stake\r\n        uint256 openingPrice;\r\n    }\r\n    //shard of each pool\r\n    mapping(uint256 => shard) public shardInfo;\r\n    //shard struct\r\n    struct shard {\r\n        string shardName;\r\n        string shardSymbol;\r\n        address shardToken;\r\n        uint256 totalShardSupply;\r\n        uint256 shardForCreator;\r\n        uint256 shardForPlatform;\r\n        uint256 shardForStakers;\r\n        uint256 burnAmount;\r\n    }\r\n    //user info of each pool\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n    struct UserInfo {\r\n        uint256 amount;\r\n        bool isWithdrawShard;\r\n    }\r\n\r\n    enum ShardsState {\r\n        Live,\r\n        Listed,\r\n        ApplyForBuyout,\r\n        Buyout,\r\n        SubscriptionFailed,\r\n        Pending,\r\n        AuditFailed,\r\n        ApplyForAddition\r\n    }\r\n\r\n    struct Token721 {\r\n        address contractAddress;\r\n        uint256 tokenId;\r\n    }\r\n    struct Token1155 {\r\n        address contractAddress;\r\n        uint256 tokenId;\r\n        uint256 amount;\r\n    }\r\n    //nfts of shard creator stakes in each pool\r\n    mapping(uint256 => Token721[]) internal Token721s;\r\n    mapping(uint256 => Token1155[]) internal Token1155s;\r\n}\r\n\r\nabstract contract IShardsMarket is IShardsMarketStorge {\r\n    event ShardCreated(\r\n        uint256 shardPoolId,\r\n        address indexed creator,\r\n        string shardName,\r\n        string shardSymbol,\r\n        uint256 minWantTokenAmount,\r\n        uint256 createTime,\r\n        uint256 totalSupply,\r\n        address wantToken\r\n    );\r\n    event Stake(address indexed sender, uint256 shardPoolId, uint256 amount);\r\n    event Redeem(address indexed sender, uint256 shardPoolId, uint256 amount);\r\n    event SettleSuccess(\r\n        uint256 indexed shardPoolId,\r\n        uint256 platformAmount,\r\n        uint256 shardForStakers,\r\n        uint256 balanceOfWantToken,\r\n        uint256 fee,\r\n        address shardToken\r\n    );\r\n    event SettleFail(uint256 indexed shardPoolId);\r\n    event ApplyForBuyout(\r\n        address indexed sender,\r\n        uint256 indexed proposalId,\r\n        uint256 indexed _shardPoolId,\r\n        uint256 shardAmount,\r\n        uint256 wantTokenAmount,\r\n        uint256 voteDeadline,\r\n        uint256 buyoutTimes,\r\n        uint256 price,\r\n        uint256 blockHeight\r\n    );\r\n    event Vote(\r\n        address indexed sender,\r\n        uint256 indexed proposalId,\r\n        uint256 indexed _shardPoolId,\r\n        bool isAgree,\r\n        uint256 voteAmount\r\n    );\r\n    event VoteResultConfirm(\r\n        uint256 indexed proposalId,\r\n        uint256 indexed _shardPoolId,\r\n        bool isPassed\r\n    );\r\n\r\n    // user operation\r\n    function createShard(\r\n        Token721[] calldata Token721s,\r\n        Token1155[] calldata Token1155s,\r\n        string memory shardName,\r\n        string memory shardSymbol,\r\n        uint256 minWantTokenAmount,\r\n        address wantToken\r\n    ) external virtual returns (uint256 shardPoolId);\r\n\r\n    function stakeETH(uint256 _shardPoolId) external payable virtual;\r\n\r\n    function stake(uint256 _shardPoolId, uint256 amount) external virtual;\r\n\r\n    function redeem(uint256 _shardPoolId, uint256 amount) external virtual;\r\n\r\n    function redeemETH(uint256 _shardPoolId, uint256 amount) external virtual;\r\n\r\n    function settle(uint256 _shardPoolId) external virtual;\r\n\r\n    function redeemInSubscriptionFailed(uint256 _shardPoolId) external virtual;\r\n\r\n    function usersWithdrawShardToken(uint256 _shardPoolId) external virtual;\r\n\r\n    function creatorWithdrawWantToken(uint256 _shardPoolId) external virtual;\r\n\r\n    function applyForBuyout(uint256 _shardPoolId, uint256 wantTokenAmount)\r\n        external\r\n        virtual\r\n        returns (uint256 proposalId);\r\n\r\n    function applyForBuyoutETH(uint256 _shardPoolId)\r\n        external\r\n        payable\r\n        virtual\r\n        returns (uint256 proposalId);\r\n\r\n    function vote(uint256 _shardPoolId, bool isAgree) external virtual;\r\n\r\n    function voteResultConfirm(uint256 _shardPoolId)\r\n        external\r\n        virtual\r\n        returns (bool result);\r\n\r\n    function exchangeForWantToken(uint256 _shardPoolId, uint256 shardAmount)\r\n        external\r\n        virtual\r\n        returns (uint256 wantTokenAmount);\r\n\r\n    function redeemForBuyoutFailed(uint256 _proposalId)\r\n        external\r\n        virtual\r\n        returns (uint256 shardTokenAmount, uint256 wantTokenAmount);\r\n\r\n    //governance operation\r\n    function setShardsCreatorProportion(uint256 _shardsCreatorProportion)\r\n        external\r\n        virtual;\r\n\r\n    function setPlatformProportion(uint256 _platformProportion)\r\n        external\r\n        virtual;\r\n\r\n    function setTotalSupply(uint256 _totalSupply) external virtual;\r\n\r\n    function setDeadlineForRedeem(uint256 _deadlineForRedeem) external virtual;\r\n\r\n    function setDeadlineForStake(uint256 _deadlineForStake) external virtual;\r\n\r\n    function setProfitProportionForDev(uint256 _profitProportionForDev)\r\n        external\r\n        virtual;\r\n\r\n    function setShardsFarm(address _shardsFarm) external virtual;\r\n\r\n    function setRegulator(address _regulator) external virtual;\r\n\r\n    function setFactory(address _factory) external virtual;\r\n\r\n    function setShardsFactory(address _shardsFactory) external virtual;\r\n\r\n    function setRouter(address _router) external virtual;\r\n\r\n    //admin operation\r\n    function setPlatformFund(address _platformFund) external virtual;\r\n\r\n    function setDev(address _dev) external virtual;\r\n\r\n    //function shardAudit(uint256 _shardPoolId, bool isPassed) external virtual;\r\n\r\n    //view function\r\n    function getPrice(uint256 _shardPoolId)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 currentPrice);\r\n\r\n    function getAllPools()\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256[] memory _pools);\r\n\r\n    function getTokens(uint256 shardPoolId)\r\n        external\r\n        view\r\n        virtual\r\n        returns (Token721[] memory _token721s, Token1155[] memory _token1155s);\r\n}\r\n\r\n// File: contracts/interface/IWETH.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function withdraw(uint256) external;\r\n\r\n    function approve(address guy, uint256 wad) external returns (bool);\r\n}\r\n\r\n// File: contracts/interface/IShardToken.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IShardToken {\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function burn(uint256 value) external;\r\n\r\n    function mint(address to, uint256 value) external;\r\n\r\n    function initialize(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address market\r\n    ) external;\r\n\r\n    function getPriorVotes(address account, uint256 blockNumber)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/interface/IShardsFactory.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IShardsFactory {\r\n    event ShardTokenCreated(address shardToken);\r\n\r\n    function createShardToken(\r\n        uint256 poolId,\r\n        string memory name,\r\n        string memory symbol\r\n    ) external returns (address shardToken);\r\n}\r\n\r\n// File: contracts/interface/IShardsFarm.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IShardsFarm {\r\n    function add(\r\n        uint256 poolId,\r\n        address lpToken,\r\n        address ethLpToken\r\n    ) external;\r\n}\r\n\r\n// File: contracts/interface/IMarketRegulator.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IMarketRegulator {\r\n    function IsInWhiteList(address wantToken)\r\n        external\r\n        view\r\n        returns (bool inTheList);\r\n\r\n    function IsInBlackList(uint256 _shardPoolId)\r\n        external\r\n        view\r\n        returns (bool inTheList);\r\n}\r\n\r\n// File: contracts/interface/IBuyoutProposals.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ncontract DelegationStorage {\r\n    address public governance;\r\n    /**\r\n     * @notice Implementation address for this contract\r\n     */\r\n    address public implementation;\r\n}\r\n\r\ncontract IBuyoutProposalsStorge is DelegationStorage {\r\n    address public regulator;\r\n    address public market;\r\n\r\n    uint256 public proposolIdCount;\r\n\r\n    uint256 public voteLenth = 259200;\r\n\r\n    mapping(uint256 => uint256) public proposalIds;\r\n\r\n    mapping(uint256 => uint256[]) internal proposalsHistory;\r\n\r\n    mapping(uint256 => Proposal) public proposals;\r\n\r\n    mapping(uint256 => mapping(address => bool)) public voted;\r\n\r\n    uint256 public passNeeded = 75;\r\n\r\n    // n times higher than the market price to buyout\r\n    uint256 public buyoutTimes = 100;\r\n\r\n    uint256 internal constant max = 100;\r\n\r\n    uint256 public buyoutProportion = 15;\r\n\r\n    mapping(uint256 => uint256) allVotes;\r\n\r\n    struct Proposal {\r\n        uint256 votesReceived;\r\n        uint256 voteTotal;\r\n        bool passed;\r\n        address submitter;\r\n        uint256 voteDeadline;\r\n        uint256 shardAmount;\r\n        uint256 wantTokenAmount;\r\n        uint256 buyoutTimes;\r\n        uint256 price;\r\n        bool isSubmitterWithDraw;\r\n        uint256 shardPoolId;\r\n        bool isFailedConfirmed;\r\n        uint256 blockHeight;\r\n        uint256 createTime;\r\n    }\r\n}\r\n\r\nabstract contract IBuyoutProposals is IBuyoutProposalsStorge {\r\n    function createProposal(\r\n        uint256 _shardPoolId,\r\n        uint256 shardBalance,\r\n        uint256 wantTokenAmount,\r\n        uint256 currentPrice,\r\n        uint256 totalShardSupply,\r\n        address submitter\r\n    ) external virtual returns (uint256 proposalId, uint256 buyoutTimes);\r\n\r\n    function vote(\r\n        uint256 _shardPoolId,\r\n        bool isAgree,\r\n        address shard,\r\n        address voter\r\n    ) external virtual returns (uint256 proposalId, uint256 balance);\r\n\r\n    function voteResultConfirm(uint256 _shardPoolId)\r\n        external\r\n        virtual\r\n        returns (\r\n            uint256 proposalId,\r\n            bool result,\r\n            address submitter,\r\n            uint256 shardAmount,\r\n            uint256 wantTokenAmount\r\n        );\r\n\r\n    function exchangeForWantToken(uint256 _shardPoolId, uint256 shardAmount)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 wantTokenAmount);\r\n\r\n    function redeemForBuyoutFailed(uint256 _proposalId, address submitter)\r\n        external\r\n        virtual\r\n        returns (\r\n            uint256 _shardPoolId,\r\n            uint256 shardTokenAmount,\r\n            uint256 wantTokenAmount\r\n        );\r\n\r\n    function setBuyoutTimes(uint256 _buyoutTimes) external virtual;\r\n\r\n    function setVoteLenth(uint256 _voteLenth) external virtual;\r\n\r\n    function setPassNeeded(uint256 _passNeeded) external virtual;\r\n\r\n    function setBuyoutProportion(uint256 _buyoutProportion) external virtual;\r\n\r\n    function setMarket(address _market) external virtual;\r\n\r\n    function setRegulator(address _regulator) external virtual;\r\n\r\n    function getProposalsForExactPool(uint256 _shardPoolId)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256[] memory _proposalsHistory);\r\n}\r\n\r\n// File: contracts/libraries/TransferHelper.sol\r\n\r\npragma solidity >=0.6.0;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x095ea7b3, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: APPROVE_FAILED\"\r\n        );\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0xa9059cbb, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: TRANSFER_FAILED\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\r\n    }\r\n}\r\n\r\n// File: contracts/interface/IUniswapV2Pair.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n}\r\n\r\n// File: contracts/interface/IUniswapV2Factory.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB)\r\n        external\r\n        view\r\n        returns (address pair);\r\n\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/NFTLibrary.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\nlibrary NFTLibrary {\r\n    using SafeMath for uint256;\r\n\r\n    function getPrice(\r\n        address tokenA,\r\n        address tokenB,\r\n        address factory\r\n    ) internal view returns (uint256 currentPrice) {\r\n        address lPTokenAddress =\r\n            IUniswapV2Factory(factory).getPair(tokenA, tokenB);\r\n\r\n        if (lPTokenAddress == address(0)) {\r\n            return currentPrice;\r\n        }\r\n\r\n        (uint112 _reserve0, uint112 _reserve1, ) =\r\n            IUniswapV2Pair(lPTokenAddress).getReserves();\r\n\r\n        address token0 = IUniswapV2Pair(lPTokenAddress).token0();\r\n\r\n        (uint112 reserve0, uint112 reserve1) =\r\n            token0 == tokenA ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\r\n        currentPrice = quote(1e18, reserve0, reserve1);\r\n    }\r\n\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) internal pure returns (uint256 amountB) {\r\n        require(amountA > 0, \"INSUFFICIENT_AMOUNT\");\r\n        require(reserveA > 0 && reserveB > 0, \"INSUFFICIENT_LIQUIDITY\");\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    function balanceOf(address user, address lPTokenAddress)\r\n        internal\r\n        view\r\n        returns (uint256 balance)\r\n    {\r\n        balance = IUniswapV2Pair(lPTokenAddress).balanceOf(user);\r\n    }\r\n\r\n    function getPair(\r\n        address tokenA,\r\n        address tokenB,\r\n        address factory\r\n    ) internal view returns (address pair) {\r\n        pair = IUniswapV2Factory(factory).getPair(tokenA, tokenB);\r\n    }\r\n\r\n    function tokenVerify(string memory tokenName, uint256 lenthLimit)\r\n        internal\r\n        pure\r\n        returns (bool success)\r\n    {\r\n        bytes memory nameBytes = bytes(tokenName);\r\n        uint256 nameLength = nameBytes.length;\r\n        require(0 < nameLength && nameLength <= lenthLimit, \"INVALID INPUT\");\r\n        success = true;\r\n        bool n7;\r\n        for (uint256 i = 0; i <= nameLength - 1; i++) {\r\n            n7 = (nameBytes[i] & 0x80) == 0x80 ? true : false;\r\n            if (n7) {\r\n                success = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n      *\r\n      * Requirements:\r\n      *\r\n      * - `from` cannot be the zero address.\r\n      * - `to` cannot be the zero address.\r\n      * - `tokenId` token must exist and be owned by `from`.\r\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n      *\r\n      * Emits a {Transfer} event.\r\n      */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Holder.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n  /**\r\n   * @dev Implementation of the {IERC721Receiver} interface.\r\n   *\r\n   * Accepts all token transfers. \r\n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\r\n   */\r\ncontract ERC721Holder is IERC721Receiver {\r\n\r\n    /**\r\n     * @dev See {IERC721Receiver-onERC721Received}.\r\n     *\r\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC1155/IERC1155.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC1155/IERC1155Receiver.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n/**\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n\r\n    /**\r\n        @dev Handles the receipt of a single ERC1155 token type. This function is\r\n        called at the end of a `safeTransferFrom` after the balance has been updated.\r\n        To accept the transfer, this must return\r\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n        (i.e. 0xf23a6e61, or its own function selector).\r\n        @param operator The address which initiated the transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param id The ID of the token being transferred\r\n        @param value The amount of tokens being transferred\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n\r\n    /**\r\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n        is called at the end of a `safeBatchTransferFrom` after the balances have\r\n        been updated. To accept the transfer(s), this must return\r\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n        (i.e. 0xbc197c81, or its own function selector).\r\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterface} to declare\r\n * their support of an interface.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC1155/ERC1155Receiver.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\r\n    constructor() internal {\r\n        _registerInterface(\r\n            ERC1155Receiver(address(0)).onERC1155Received.selector ^\r\n            ERC1155Receiver(address(0)).onERC1155BatchReceived.selector\r\n        );\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC1155/ERC1155Holder.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ncontract ERC1155Holder is ERC1155Receiver {\r\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n\r\n// File: contracts/interface/IUniswapV2Router01.sol\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) external pure returns (uint256 amountB);\r\n}\r\n\r\n// File: contracts/interface/IUniswapV2Router02.sol\r\n\r\npragma solidity >=0.6.2;\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {}\r\n\r\n// File: contracts/ShardsMarketDelegateV0.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ShardsMarketDelegateV0 is IShardsMarket, ERC721Holder, ERC1155Holder {\r\n    using SafeMath for uint256;\r\n\r\n    constructor() public {}\r\n\r\n    function initialize(\r\n        address _WETH,\r\n        address _factory,\r\n        address _governance,\r\n        address _router,\r\n        address _dev,\r\n        address _platformFund,\r\n        address _shardsFactory,\r\n        address _regulator,\r\n        address _buyoutProposals\r\n    ) public {\r\n        require(admin == msg.sender, \"UNAUTHORIZED\");\r\n        require(WETH == address(0), \"ALREADY INITIALIZED\");\r\n        WETH = _WETH;\r\n        factory = _factory;\r\n        governance = _governance;\r\n        router = _router;\r\n        dev = _dev;\r\n        platformFund = _platformFund;\r\n        shardsFactory = _shardsFactory;\r\n        regulator = _regulator;\r\n        buyoutProposals = _buyoutProposals;\r\n    }\r\n\r\n    function createShard(\r\n        Token721[] calldata token721s,\r\n        Token1155[] calldata token1155s,\r\n        string memory shardName,\r\n        string memory shardSymbol,\r\n        uint256 minWantTokenAmount,\r\n        address wantToken\r\n    ) external override returns (uint256 shardPoolId) {\r\n        require(\r\n            NFTLibrary.tokenVerify(shardName, 30) &&\r\n                NFTLibrary.tokenVerify(shardSymbol, 30),\r\n            \"INVALID NAME/SYMBOL\"\r\n        );\r\n\r\n        require(minWantTokenAmount > 0, \"INVALID MINAMOUNT INPUT\");\r\n        require(\r\n            IMarketRegulator(regulator).IsInWhiteList(wantToken),\r\n            \"WANTTOKEN IS NOT ON THE LIST\"\r\n        );\r\n        shardPoolId = shardPoolIdCount.add(1);\r\n        poolInfo[shardPoolId] = shardPool({\r\n            creator: msg.sender,\r\n            state: ShardsState.Live,\r\n            createTime: block.timestamp,\r\n            deadlineForStake: block.timestamp.add(deadlineForStake),\r\n            deadlineForRedeem: block.timestamp.add(deadlineForRedeem),\r\n            balanceOfWantToken: 0,\r\n            minWantTokenAmount: minWantTokenAmount,\r\n            isCreatorWithDraw: false,\r\n            wantToken: wantToken,\r\n            openingPrice: 0\r\n        });\r\n\r\n        _transferIn(shardPoolId, token721s, token1155s, msg.sender);\r\n\r\n        uint256 creatorAmount =\r\n            totalSupply.mul(shardsCreatorProportion).div(max);\r\n        uint256 platformAmount = totalSupply.mul(platformProportion).div(max);\r\n        uint256 stakersAmount =\r\n            totalSupply.sub(creatorAmount).sub(platformAmount);\r\n        shardInfo[shardPoolId] = shard({\r\n            shardName: shardName,\r\n            shardSymbol: shardSymbol,\r\n            shardToken: address(0),\r\n            totalShardSupply: totalSupply,\r\n            shardForCreator: creatorAmount,\r\n            shardForPlatform: platformAmount,\r\n            shardForStakers: stakersAmount,\r\n            burnAmount: 0\r\n        });\r\n        allPools.push(shardPoolId);\r\n        shardPoolIdCount = shardPoolId;\r\n        emit ShardCreated(\r\n            shardPoolId,\r\n            msg.sender,\r\n            shardName,\r\n            shardSymbol,\r\n            minWantTokenAmount,\r\n            block.timestamp,\r\n            totalSupply,\r\n            wantToken\r\n        );\r\n    }\r\n\r\n    function stake(uint256 _shardPoolId, uint256 amount) external override {\r\n        require(\r\n            block.timestamp <= poolInfo[_shardPoolId].deadlineForStake,\r\n            \"EXPIRED\"\r\n        );\r\n        address wantToken = poolInfo[_shardPoolId].wantToken;\r\n        TransferHelper.safeTransferFrom(\r\n            wantToken,\r\n            msg.sender,\r\n            address(this),\r\n            amount\r\n        );\r\n        _stake(_shardPoolId, amount);\r\n    }\r\n\r\n    function stakeETH(uint256 _shardPoolId) external payable override {\r\n        require(\r\n            block.timestamp <= poolInfo[_shardPoolId].deadlineForStake,\r\n            \"EXPIRED\"\r\n        );\r\n        require(poolInfo[_shardPoolId].wantToken == WETH, \"UNWANTED\");\r\n        IWETH(WETH).deposit{value: msg.value}();\r\n        _stake(_shardPoolId, msg.value);\r\n    }\r\n\r\n    function _stake(uint256 _shardPoolId, uint256 amount) private {\r\n        require(amount > 0, \"INSUFFIENT INPUT\");\r\n        userInfo[_shardPoolId][msg.sender].amount = userInfo[_shardPoolId][\r\n            msg.sender\r\n        ]\r\n            .amount\r\n            .add(amount);\r\n        poolInfo[_shardPoolId].balanceOfWantToken = poolInfo[_shardPoolId]\r\n            .balanceOfWantToken\r\n            .add(amount);\r\n        emit Stake(msg.sender, _shardPoolId, amount);\r\n    }\r\n\r\n    function redeem(uint256 _shardPoolId, uint256 amount) external override {\r\n        _redeem(_shardPoolId, amount);\r\n        TransferHelper.safeTransfer(\r\n            poolInfo[_shardPoolId].wantToken,\r\n            msg.sender,\r\n            amount\r\n        );\r\n        emit Redeem(msg.sender, _shardPoolId, amount);\r\n    }\r\n\r\n    function redeemETH(uint256 _shardPoolId, uint256 amount) external override {\r\n        require(poolInfo[_shardPoolId].wantToken == WETH, \"UNWANTED\");\r\n        _redeem(_shardPoolId, amount);\r\n        IWETH(WETH).withdraw(amount);\r\n        TransferHelper.safeTransferETH(msg.sender, amount);\r\n        emit Redeem(msg.sender, _shardPoolId, amount);\r\n    }\r\n\r\n    function _redeem(uint256 _shardPoolId, uint256 amount) private {\r\n        require(\r\n            block.timestamp <= poolInfo[_shardPoolId].deadlineForRedeem,\r\n            \"EXPIRED\"\r\n        );\r\n        require(amount > 0, \"INSUFFIENT INPUT\");\r\n        userInfo[_shardPoolId][msg.sender].amount = userInfo[_shardPoolId][\r\n            msg.sender\r\n        ]\r\n            .amount\r\n            .sub(amount);\r\n        poolInfo[_shardPoolId].balanceOfWantToken = poolInfo[_shardPoolId]\r\n            .balanceOfWantToken\r\n            .sub(amount);\r\n    }\r\n\r\n    function settle(uint256 _shardPoolId) external override {\r\n        require(\r\n            block.timestamp > poolInfo[_shardPoolId].deadlineForRedeem,\r\n            \"NOT READY\"\r\n        );\r\n        require(\r\n            poolInfo[_shardPoolId].state == ShardsState.Live,\r\n            \"LIVE STATE IS REQUIRED\"\r\n        );\r\n        if (\r\n            poolInfo[_shardPoolId].balanceOfWantToken <\r\n            poolInfo[_shardPoolId].minWantTokenAmount ||\r\n            IMarketRegulator(regulator).IsInBlackList(_shardPoolId)\r\n        ) {\r\n            poolInfo[_shardPoolId].state = ShardsState.SubscriptionFailed;\r\n\r\n            address shardCreator = poolInfo[_shardPoolId].creator;\r\n            _transferOut(_shardPoolId, shardCreator);\r\n            emit SettleFail(_shardPoolId);\r\n        } else {\r\n            _successToSetPrice(_shardPoolId);\r\n        }\r\n    }\r\n\r\n    function redeemInSubscriptionFailed(uint256 _shardPoolId)\r\n        external\r\n        override\r\n    {\r\n        require(\r\n            poolInfo[_shardPoolId].state == ShardsState.SubscriptionFailed,\r\n            \"WRONG STATE\"\r\n        );\r\n        uint256 balance = userInfo[_shardPoolId][msg.sender].amount;\r\n        require(balance > 0, \"INSUFFIENT BALANCE\");\r\n        userInfo[_shardPoolId][msg.sender].amount = 0;\r\n        poolInfo[_shardPoolId].balanceOfWantToken = poolInfo[_shardPoolId]\r\n            .balanceOfWantToken\r\n            .sub(balance);\r\n        if (poolInfo[_shardPoolId].wantToken == WETH) {\r\n            IWETH(WETH).withdraw(balance);\r\n            TransferHelper.safeTransferETH(msg.sender, balance);\r\n        } else {\r\n            TransferHelper.safeTransfer(\r\n                poolInfo[_shardPoolId].wantToken,\r\n                msg.sender,\r\n                balance\r\n            );\r\n        }\r\n\r\n        emit Redeem(msg.sender, _shardPoolId, balance);\r\n    }\r\n\r\n    function usersWithdrawShardToken(uint256 _shardPoolId) external override {\r\n        require(\r\n            poolInfo[_shardPoolId].state == ShardsState.Listed ||\r\n                poolInfo[_shardPoolId].state == ShardsState.Buyout ||\r\n                poolInfo[_shardPoolId].state == ShardsState.ApplyForBuyout,\r\n            \"WRONG_STATE\"\r\n        );\r\n        uint256 userBanlance = userInfo[_shardPoolId][msg.sender].amount;\r\n        bool isWithdrawShard =\r\n            userInfo[_shardPoolId][msg.sender].isWithdrawShard;\r\n        require(userBanlance > 0 && !isWithdrawShard, \"INSUFFIENT BALANCE\");\r\n        uint256 shardsForUsers = shardInfo[_shardPoolId].shardForStakers;\r\n        uint256 totalBalance = poolInfo[_shardPoolId].balanceOfWantToken;\r\n        // formula:\r\n        // shardAmount/shardsForUsers= userBanlance/totalBalance\r\n        //\r\n        uint256 shardAmount =\r\n            userBanlance.mul(shardsForUsers).div(totalBalance);\r\n        userInfo[_shardPoolId][msg.sender].isWithdrawShard = true;\r\n        IShardToken(shardInfo[_shardPoolId].shardToken).mint(\r\n            msg.sender,\r\n            shardAmount\r\n        );\r\n    }\r\n\r\n    function creatorWithdrawWantToken(uint256 _shardPoolId) external override {\r\n        require(msg.sender == poolInfo[_shardPoolId].creator, \"UNAUTHORIZED\");\r\n        require(\r\n            poolInfo[_shardPoolId].state == ShardsState.Listed ||\r\n                poolInfo[_shardPoolId].state == ShardsState.Buyout ||\r\n                poolInfo[_shardPoolId].state == ShardsState.ApplyForBuyout,\r\n            \"WRONG_STATE\"\r\n        );\r\n\r\n        require(!poolInfo[_shardPoolId].isCreatorWithDraw, \"ALREADY WITHDRAW\");\r\n        uint256 totalBalance = poolInfo[_shardPoolId].balanceOfWantToken;\r\n        uint256 platformAmount = shardInfo[_shardPoolId].shardForPlatform;\r\n        uint256 fee =\r\n            poolInfo[_shardPoolId].balanceOfWantToken.mul(platformAmount).div(\r\n                shardInfo[_shardPoolId].shardForStakers\r\n            );\r\n        uint256 amount = totalBalance.sub(fee);\r\n        poolInfo[_shardPoolId].isCreatorWithDraw = true;\r\n        if (poolInfo[_shardPoolId].wantToken == WETH) {\r\n            IWETH(WETH).withdraw(amount);\r\n            TransferHelper.safeTransferETH(msg.sender, amount);\r\n        } else {\r\n            TransferHelper.safeTransfer(\r\n                poolInfo[_shardPoolId].wantToken,\r\n                msg.sender,\r\n                amount\r\n            );\r\n        }\r\n        uint256 creatorAmount = shardInfo[_shardPoolId].shardForCreator;\r\n        address shardToken = shardInfo[_shardPoolId].shardToken;\r\n        IShardToken(shardToken).mint(\r\n            poolInfo[_shardPoolId].creator,\r\n            creatorAmount\r\n        );\r\n    }\r\n\r\n    function applyForBuyout(uint256 _shardPoolId, uint256 wantTokenAmount)\r\n        external\r\n        override\r\n        returns (uint256 proposalId)\r\n    {\r\n        proposalId = _applyForBuyout(_shardPoolId, wantTokenAmount);\r\n    }\r\n\r\n    function applyForBuyoutETH(uint256 _shardPoolId)\r\n        external\r\n        payable\r\n        override\r\n        returns (uint256 proposalId)\r\n    {\r\n        require(poolInfo[_shardPoolId].wantToken == WETH, \"UNWANTED\");\r\n        proposalId = _applyForBuyout(_shardPoolId, msg.value);\r\n    }\r\n\r\n    function _applyForBuyout(uint256 _shardPoolId, uint256 wantTokenAmount)\r\n        private\r\n        returns (uint256 proposalId)\r\n    {\r\n        require(msg.sender == tx.origin, \"INVALID SENDER\");\r\n        require(\r\n            poolInfo[_shardPoolId].state == ShardsState.Listed,\r\n            \"LISTED STATE IS REQUIRED\"\r\n        );\r\n        uint256 shardBalance =\r\n            IShardToken(shardInfo[_shardPoolId].shardToken).balanceOf(\r\n                msg.sender\r\n            );\r\n        uint256 totalShardSupply = shardInfo[_shardPoolId].totalShardSupply;\r\n\r\n        uint256 currentPrice = getPrice(_shardPoolId);\r\n        uint256 buyoutTimes;\r\n        (proposalId, buyoutTimes) = IBuyoutProposals(buyoutProposals)\r\n            .createProposal(\r\n            _shardPoolId,\r\n            shardBalance,\r\n            wantTokenAmount,\r\n            currentPrice,\r\n            totalShardSupply,\r\n            msg.sender\r\n        );\r\n        if (\r\n            poolInfo[_shardPoolId].wantToken == WETH &&\r\n            msg.value == wantTokenAmount\r\n        ) {\r\n            IWETH(WETH).deposit{value: wantTokenAmount}();\r\n        } else {\r\n            TransferHelper.safeTransferFrom(\r\n                poolInfo[_shardPoolId].wantToken,\r\n                msg.sender,\r\n                address(this),\r\n                wantTokenAmount\r\n            );\r\n        }\r\n        TransferHelper.safeTransferFrom(\r\n            shardInfo[_shardPoolId].shardToken,\r\n            msg.sender,\r\n            address(this),\r\n            shardBalance\r\n        );\r\n\r\n        poolInfo[_shardPoolId].state = ShardsState.ApplyForBuyout;\r\n\r\n        emit ApplyForBuyout(\r\n            msg.sender,\r\n            proposalId,\r\n            _shardPoolId,\r\n            shardBalance,\r\n            wantTokenAmount,\r\n            block.timestamp,\r\n            buyoutTimes,\r\n            currentPrice,\r\n            block.number\r\n        );\r\n    }\r\n\r\n    function vote(uint256 _shardPoolId, bool isAgree) external override {\r\n        require(\r\n            poolInfo[_shardPoolId].state == ShardsState.ApplyForBuyout,\r\n            \"WRONG STATE\"\r\n        );\r\n        address shard = shardInfo[_shardPoolId].shardToken;\r\n\r\n        (uint256 proposalId, uint256 balance) =\r\n            IBuyoutProposals(buyoutProposals).vote(\r\n                _shardPoolId,\r\n                isAgree,\r\n                shard,\r\n                msg.sender\r\n            );\r\n        emit Vote(msg.sender, proposalId, _shardPoolId, isAgree, balance);\r\n    }\r\n\r\n    function voteResultConfirm(uint256 _shardPoolId)\r\n        external\r\n        override\r\n        returns (bool)\r\n    {\r\n        require(\r\n            poolInfo[_shardPoolId].state == ShardsState.ApplyForBuyout,\r\n            \"WRONG STATE\"\r\n        );\r\n        (\r\n            uint256 proposalId,\r\n            bool result,\r\n            address submitter,\r\n            uint256 shardAmount,\r\n            uint256 wantTokenAmount\r\n        ) = IBuyoutProposals(buyoutProposals).voteResultConfirm(_shardPoolId);\r\n\r\n        if (result) {\r\n            poolInfo[_shardPoolId].state = ShardsState.Buyout;\r\n            IShardToken(shardInfo[_shardPoolId].shardToken).burn(shardAmount);\r\n            shardInfo[_shardPoolId].burnAmount = shardInfo[_shardPoolId]\r\n                .burnAmount\r\n                .add(shardAmount);\r\n\r\n            _transferOut(_shardPoolId, submitter);\r\n\r\n            _getProfit(_shardPoolId, wantTokenAmount, shardAmount);\r\n        } else {\r\n            poolInfo[_shardPoolId].state = ShardsState.Listed;\r\n        }\r\n\r\n        emit VoteResultConfirm(proposalId, _shardPoolId, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    function exchangeForWantToken(uint256 _shardPoolId, uint256 shardAmount)\r\n        external\r\n        override\r\n        returns (uint256 wantTokenAmount)\r\n    {\r\n        require(\r\n            poolInfo[_shardPoolId].state == ShardsState.Buyout,\r\n            \"WRONG STATE\"\r\n        );\r\n        TransferHelper.safeTransferFrom(\r\n            shardInfo[_shardPoolId].shardToken,\r\n            msg.sender,\r\n            address(this),\r\n            shardAmount\r\n        );\r\n        IShardToken(shardInfo[_shardPoolId].shardToken).burn(shardAmount);\r\n        shardInfo[_shardPoolId].burnAmount = shardInfo[_shardPoolId]\r\n            .burnAmount\r\n            .add(shardAmount);\r\n\r\n        wantTokenAmount = IBuyoutProposals(buyoutProposals)\r\n            .exchangeForWantToken(_shardPoolId, shardAmount);\r\n        require(wantTokenAmount > 0, \"LESS THAN 1 WEI\");\r\n        if (poolInfo[_shardPoolId].wantToken == WETH) {\r\n            IWETH(WETH).withdraw(wantTokenAmount);\r\n            TransferHelper.safeTransferETH(msg.sender, wantTokenAmount);\r\n        } else {\r\n            TransferHelper.safeTransfer(\r\n                poolInfo[_shardPoolId].wantToken,\r\n                msg.sender,\r\n                wantTokenAmount\r\n            );\r\n        }\r\n    }\r\n\r\n    function redeemForBuyoutFailed(uint256 _proposalId)\r\n        external\r\n        override\r\n        returns (uint256 shardTokenAmount, uint256 wantTokenAmount)\r\n    {\r\n        uint256 shardPoolId;\r\n        (shardPoolId, shardTokenAmount, wantTokenAmount) = IBuyoutProposals(\r\n            buyoutProposals\r\n        )\r\n            .redeemForBuyoutFailed(_proposalId, msg.sender);\r\n        TransferHelper.safeTransfer(\r\n            shardInfo[shardPoolId].shardToken,\r\n            msg.sender,\r\n            shardTokenAmount\r\n        );\r\n        if (poolInfo[shardPoolId].wantToken == WETH) {\r\n            IWETH(WETH).withdraw(wantTokenAmount);\r\n            TransferHelper.safeTransferETH(msg.sender, wantTokenAmount);\r\n        } else {\r\n            TransferHelper.safeTransfer(\r\n                poolInfo[shardPoolId].wantToken,\r\n                msg.sender,\r\n                wantTokenAmount\r\n            );\r\n        }\r\n    }\r\n\r\n    function _successToSetPrice(uint256 _shardPoolId) private {\r\n        address shardToken = _deployShardsToken(_shardPoolId);\r\n        poolInfo[_shardPoolId].state = ShardsState.Listed;\r\n        shardInfo[_shardPoolId].shardToken = shardToken;\r\n        address wantToken = poolInfo[_shardPoolId].wantToken;\r\n        uint256 platformAmount = shardInfo[_shardPoolId].shardForPlatform;\r\n        IShardToken(shardToken).mint(address(this), platformAmount);\r\n        uint256 shardPrice =\r\n            poolInfo[_shardPoolId].balanceOfWantToken.mul(1e18).div(\r\n                shardInfo[_shardPoolId].shardForStakers\r\n            );\r\n        //fee= shardPrice * platformAmount =balanceOfWantToken * platformAmount / shardForStakers\r\n        uint256 fee =\r\n            poolInfo[_shardPoolId].balanceOfWantToken.mul(platformAmount).div(\r\n                shardInfo[_shardPoolId].shardForStakers\r\n            );\r\n        poolInfo[_shardPoolId].openingPrice = shardPrice;\r\n        //addLiquidity\r\n        TransferHelper.safeApprove(shardToken, router, platformAmount);\r\n        TransferHelper.safeApprove(wantToken, router, fee);\r\n        IUniswapV2Router02(router).addLiquidity(\r\n            shardToken,\r\n            wantToken,\r\n            platformAmount,\r\n            fee,\r\n            0,\r\n            0,\r\n            address(this),\r\n            now.add(60)\r\n        );\r\n\r\n        _addFarmPool(_shardPoolId);\r\n\r\n        emit SettleSuccess(\r\n            _shardPoolId,\r\n            platformAmount,\r\n            shardInfo[_shardPoolId].shardForStakers,\r\n            poolInfo[_shardPoolId].balanceOfWantToken,\r\n            fee,\r\n            shardToken\r\n        );\r\n    }\r\n\r\n    function _getProfit(\r\n        uint256 _shardPoolId,\r\n        uint256 wantTokenAmount,\r\n        uint256 shardAmount\r\n    ) private {\r\n        address shardToken = shardInfo[_shardPoolId].shardToken;\r\n        address wantToken = poolInfo[_shardPoolId].wantToken;\r\n\r\n        address lPTokenAddress =\r\n            NFTLibrary.getPair(shardToken, wantToken, factory);\r\n        uint256 LPTokenBalance =\r\n            NFTLibrary.balanceOf(address(this), lPTokenAddress);\r\n        TransferHelper.safeApprove(lPTokenAddress, router, LPTokenBalance);\r\n        (uint256 amountShardToken, uint256 amountWantToken) =\r\n            IUniswapV2Router02(router).removeLiquidity(\r\n                shardToken,\r\n                wantToken,\r\n                LPTokenBalance,\r\n                0,\r\n                0,\r\n                address(this),\r\n                now.add(60)\r\n            );\r\n        IShardToken(shardInfo[_shardPoolId].shardToken).burn(amountShardToken);\r\n        shardInfo[_shardPoolId].burnAmount = shardInfo[_shardPoolId]\r\n            .burnAmount\r\n            .add(amountShardToken);\r\n        uint256 supply = shardInfo[_shardPoolId].totalShardSupply;\r\n        uint256 wantTokenAmountForExchange =\r\n            amountShardToken.mul(wantTokenAmount).div(supply.sub(shardAmount));\r\n        uint256 totalProfit = amountWantToken.add(wantTokenAmountForExchange);\r\n        uint256 profitForDev = totalProfit.mul(profitProportionForDev).div(max);\r\n        uint256 profitForPlatformFund = totalProfit.sub(profitForDev);\r\n        TransferHelper.safeTransfer(wantToken, dev, profitForDev);\r\n        TransferHelper.safeTransfer(\r\n            wantToken,\r\n            platformFund,\r\n            profitForPlatformFund\r\n        );\r\n    }\r\n\r\n    function _transferIn(\r\n        uint256 shardPoolId,\r\n        Token721[] calldata token721s,\r\n        Token1155[] calldata token1155s,\r\n        address from\r\n    ) private {\r\n        require(\r\n            token721s.length.add(token1155s.length) > 0,\r\n            \"INSUFFIENT TOKEN\"\r\n        );\r\n        for (uint256 i = 0; i < token721s.length; i++) {\r\n            Token721 memory token = token721s[i];\r\n            Token721s[shardPoolId].push(token);\r\n\r\n            IERC721(token.contractAddress).safeTransferFrom(\r\n                from,\r\n                address(this),\r\n                token.tokenId\r\n            );\r\n        }\r\n        for (uint256 i = 0; i < token1155s.length; i++) {\r\n            Token1155 memory token = token1155s[i];\r\n            require(token.amount > 0, \"INSUFFIENT TOKEN\");\r\n            Token1155s[shardPoolId].push(token);\r\n            IERC1155(token.contractAddress).safeTransferFrom(\r\n                from,\r\n                address(this),\r\n                token.tokenId,\r\n                token.amount,\r\n                \"\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function _transferOut(uint256 shardPoolId, address to) private {\r\n        Token721[] memory token721s = Token721s[shardPoolId];\r\n        Token1155[] memory token1155s = Token1155s[shardPoolId];\r\n        for (uint256 i = 0; i < token721s.length; i++) {\r\n            Token721 memory token = token721s[i];\r\n            IERC721(token.contractAddress).safeTransferFrom(\r\n                address(this),\r\n                to,\r\n                token.tokenId\r\n            );\r\n        }\r\n        for (uint256 i = 0; i < token1155s.length; i++) {\r\n            Token1155 memory token = token1155s[i];\r\n            IERC1155(token.contractAddress).safeTransferFrom(\r\n                address(this),\r\n                to,\r\n                token.tokenId,\r\n                token.amount,\r\n                \"\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function _deployShardsToken(uint256 _shardPoolId)\r\n        private\r\n        returns (address token)\r\n    {\r\n        string memory name = shardInfo[_shardPoolId].shardName;\r\n        string memory symbol = shardInfo[_shardPoolId].shardSymbol;\r\n        token = IShardsFactory(shardsFactory).createShardToken(\r\n            _shardPoolId,\r\n            name,\r\n            symbol\r\n        );\r\n    }\r\n\r\n    function _addFarmPool(uint256 _shardPoolId) private {\r\n        address shardToken = shardInfo[_shardPoolId].shardToken;\r\n        address wantToken = poolInfo[_shardPoolId].wantToken;\r\n        address lPTokenSwap =\r\n            NFTLibrary.getPair(shardToken, wantToken, factory);\r\n\r\n        address TokenToEthSwap =\r\n            wantToken == WETH\r\n                ? address(0)\r\n                : NFTLibrary.getPair(wantToken, WETH, factory);\r\n\r\n        IShardsFarm(shardsFarm).add(_shardPoolId, lPTokenSwap, TokenToEthSwap);\r\n    }\r\n\r\n    //governance operation\r\n    function setDeadlineForStake(uint256 _deadlineForStake) external override {\r\n        require(msg.sender == governance, \"UNAUTHORIZED\");\r\n        deadlineForStake = _deadlineForStake;\r\n    }\r\n\r\n    function setDeadlineForRedeem(uint256 _deadlineForRedeem)\r\n        external\r\n        override\r\n    {\r\n        require(msg.sender == governance, \"UNAUTHORIZED\");\r\n        deadlineForRedeem = _deadlineForRedeem;\r\n    }\r\n\r\n    function setShardsCreatorProportion(uint256 _shardsCreatorProportion)\r\n        external\r\n        override\r\n    {\r\n        require(msg.sender == governance, \"UNAUTHORIZED\");\r\n        require(_shardsCreatorProportion < max, \"INVALID\");\r\n        shardsCreatorProportion = _shardsCreatorProportion;\r\n    }\r\n\r\n    function setPlatformProportion(uint256 _platformProportion)\r\n        external\r\n        override\r\n    {\r\n        require(msg.sender == governance, \"UNAUTHORIZED\");\r\n        require(_platformProportion < max, \"INVALID\");\r\n        platformProportion = _platformProportion;\r\n    }\r\n\r\n    function setTotalSupply(uint256 _totalSupply) external override {\r\n        require(msg.sender == governance, \"UNAUTHORIZED\");\r\n        totalSupply = _totalSupply;\r\n    }\r\n\r\n    function setProfitProportionForDev(uint256 _profitProportionForDev)\r\n        external\r\n        override\r\n    {\r\n        require(msg.sender == governance, \"UNAUTHORIZED\");\r\n        profitProportionForDev = _profitProportionForDev;\r\n    }\r\n\r\n    function setShardsFarm(address _shardsFarm) external override {\r\n        require(msg.sender == governance, \"UNAUTHORIZED\");\r\n        shardsFarm = _shardsFarm;\r\n    }\r\n\r\n    function setRegulator(address _regulator) external override {\r\n        require(msg.sender == governance, \"UNAUTHORIZED\");\r\n        regulator = _regulator;\r\n    }\r\n\r\n    function setFactory(address _factory) external override {\r\n        require(msg.sender == governance, \"UNAUTHORIZED\");\r\n        factory = _factory;\r\n    }\r\n\r\n    function setShardsFactory(address _shardsFactory) external override {\r\n        require(msg.sender == governance, \"UNAUTHORIZED\");\r\n        shardsFactory = _shardsFactory;\r\n    }\r\n\r\n    function setRouter(address _router) external override {\r\n        require(msg.sender == governance, \"UNAUTHORIZED\");\r\n        router = _router;\r\n    }\r\n\r\n    //admin operation\r\n    function setPlatformFund(address _platformFund) external override {\r\n        require(msg.sender == admin, \"UNAUTHORIZED\");\r\n        platformFund = _platformFund;\r\n    }\r\n\r\n    function setDev(address _dev) external override {\r\n        require(msg.sender == admin, \"UNAUTHORIZED\");\r\n        dev = _dev;\r\n    }\r\n\r\n    //pending function  not use right now\r\n\r\n    // function shardAudit(uint256 _shardPoolId, bool isPassed) external override {\r\n    //     require(msg.sender == admin, \"UNAUTHORIZED\");\r\n    //     require(\r\n    //         poolInfo[_shardPoolId].state == ShardsState.Pending,\r\n    //         \"WRONG STATE\"\r\n    //     );\r\n    //     if (isPassed) {\r\n    //         poolInfo[_shardPoolId].state = ShardsState.Live;\r\n    //     } else {\r\n    //         poolInfo[_shardPoolId].state = ShardsState.AuditFailed;\r\n    //         address shardCreator = poolInfo[_shardPoolId].creator;\r\n    //         _transferOut(_shardPoolId, shardCreator);\r\n    //     }\r\n    // }\r\n\r\n    //view function\r\n    function getPrice(uint256 _shardPoolId)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256 currentPrice)\r\n    {\r\n        address tokenA = shardInfo[_shardPoolId].shardToken;\r\n        address tokenB = poolInfo[_shardPoolId].wantToken;\r\n        currentPrice = NFTLibrary.getPrice(tokenA, tokenB, factory);\r\n    }\r\n\r\n    function getAllPools()\r\n        external\r\n        view\r\n        override\r\n        returns (uint256[] memory _pools)\r\n    {\r\n        _pools = allPools;\r\n    }\r\n\r\n    function getTokens(uint256 shardPoolId)\r\n        external\r\n        view\r\n        override\r\n        returns (Token721[] memory _token721s, Token1155[] memory _token1155s)\r\n    {\r\n        _token721s = Token721s[shardPoolId];\r\n        _token1155s = Token1155s[shardPoolId];\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wantTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voteDeadline\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyoutTimes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockHeight\",\"type\":\"uint256\"}],\"name\":\"ApplyForBuyout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shardPoolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"shardPoolId\",\"type\":\"uint256\"}],\"name\":\"SettleFail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"shardPoolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"platformAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shardForStakers\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balanceOfWantToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"shardToken\",\"type\":\"address\"}],\"name\":\"SettleSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shardPoolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"shardName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"shardSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minWantTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"createTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wantToken\",\"type\":\"address\"}],\"name\":\"ShardCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shardPoolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAgree\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voteAmount\",\"type\":\"uint256\"}],\"name\":\"Vote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPassed\",\"type\":\"bool\"}],\"name\":\"VoteResultConfirm\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wantTokenAmount\",\"type\":\"uint256\"}],\"name\":\"applyForBuyout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"}],\"name\":\"applyForBuyoutETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyoutProposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct IShardsMarketStorge.Token721[]\",\"name\":\"token721s\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IShardsMarketStorge.Token1155[]\",\"name\":\"token1155s\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"shardName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"shardSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minWantTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wantToken\",\"type\":\"address\"}],\"name\":\"createShard\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shardPoolId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"}],\"name\":\"creatorWithdrawWantToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadlineForRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadlineForStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shardAmount\",\"type\":\"uint256\"}],\"name\":\"exchangeForWantToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wantTokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPools\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_pools\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shardPoolId\",\"type\":\"uint256\"}],\"name\":\"getTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct IShardsMarketStorge.Token721[]\",\"name\":\"_token721s\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IShardsMarketStorge.Token1155[]\",\"name\":\"_token1155s\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dev\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_platformFund\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_shardsFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_regulator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyoutProposals\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformProportion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"enum IShardsMarketStorge.ShardsState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"createTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadlineForStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadlineForRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceOfWantToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minWantTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCreatorWithDraw\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"wantToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"openingPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitProportionForDev\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeemETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"redeemForBuyoutFailed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shardTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wantTokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"}],\"name\":\"redeemInSubscriptionFailed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"regulator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_deadlineForRedeem\",\"type\":\"uint256\"}],\"name\":\"setDeadlineForRedeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_deadlineForStake\",\"type\":\"uint256\"}],\"name\":\"setDeadlineForStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dev\",\"type\":\"address\"}],\"name\":\"setDev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"setFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_platformFund\",\"type\":\"address\"}],\"name\":\"setPlatformFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_platformProportion\",\"type\":\"uint256\"}],\"name\":\"setPlatformProportion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_profitProportionForDev\",\"type\":\"uint256\"}],\"name\":\"setProfitProportionForDev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_regulator\",\"type\":\"address\"}],\"name\":\"setRegulator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardsCreatorProportion\",\"type\":\"uint256\"}],\"name\":\"setShardsCreatorProportion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_shardsFactory\",\"type\":\"address\"}],\"name\":\"setShardsFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_shardsFarm\",\"type\":\"address\"}],\"name\":\"setShardsFarm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"setTotalSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"}],\"name\":\"settle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shardAdditionProposal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shardInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"shardName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"shardSymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"shardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalShardSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shardForCreator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shardForPlatform\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shardForStakers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shardPoolIdCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shardsCreatorProportion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shardsFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shardsFarm\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"}],\"name\":\"stakeETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isWithdrawShard\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"}],\"name\":\"usersWithdrawShardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isAgree\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardPoolId\",\"type\":\"uint256\"}],\"name\":\"voteResultConfirm\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ShardsMarketDelegateV0","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c30b6761c7a0cc46639b242c88e7df3e576e2cf8ba2046fd882f073bb7ee922d"}]}