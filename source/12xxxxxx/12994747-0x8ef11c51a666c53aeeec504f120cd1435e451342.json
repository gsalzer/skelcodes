{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.12\r\n\r\n\"\"\"\r\n@title Unagii EthVault V2 0.1.1\r\n@author stakewith.us\r\n@license AGPL-3.0-or-later\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface UnagiiToken:\r\n    def minter() -> address: view\r\n    def token() -> address: view\r\n    def decimals() -> uint256: view\r\n    def totalSupply() -> uint256: view\r\n    def balanceOf(owner: address) -> uint256: view\r\n    def mint(receiver: address, amount: uint256): nonpayable\r\n    def burn(spender: address, amount: uint256): nonpayable\r\n    def lastBlock(owner: address) -> uint256: view\r\n\r\n\r\n# used for migrating to new Vault contract\r\ninterface Vault:\r\n    def oldVault() -> address: view\r\n    def token() -> address: view\r\n    def uToken() -> address: view\r\n    def fundManager() -> address: view\r\n    def initialize(): payable\r\n    def balanceOfVault() -> uint256: view\r\n    def debt() -> uint256: view\r\n    def lockedProfit() -> uint256: view\r\n    def lastReport() -> uint256: view\r\n\r\n\r\ninterface FundManager:\r\n    def vault() -> address: view\r\n    def token() -> address: view\r\n    # returns loss = debt - total assets in fund manager\r\n    def withdraw(amount: uint256) -> uint256: nonpayable\r\n\r\n\r\nevent Migrate:\r\n    vault: address\r\n    balanceOfVault: uint256\r\n    debt: uint256\r\n    lockedProfit: uint256\r\n\r\n\r\nevent SetNextTimeLock:\r\n    nextTimeLock: address\r\n\r\n\r\nevent AcceptTimeLock:\r\n    timeLock: address\r\n\r\n\r\nevent SetGuardian:\r\n    guardian: address\r\n\r\n\r\nevent SetAdmin:\r\n    admin: address\r\n\r\n\r\nevent SetFundManager:\r\n    fundManager: address\r\n\r\n\r\nevent SetPause:\r\n    paused: bool\r\n\r\n\r\nevent SetWhitelist:\r\n    addr: indexed(address)\r\n    approved: bool\r\n\r\n\r\nevent ReceiveEth:\r\n    sender: indexed(address)\r\n    amount: uint256\r\n\r\n\r\nevent Deposit:\r\n    sender: indexed(address)\r\n    amount: uint256\r\n    shares: uint256\r\n\r\n\r\nevent Withdraw:\r\n    owner: indexed(address)\r\n    shares: uint256\r\n    amount: uint256\r\n\r\n\r\nevent Borrow:\r\n    fundManager: indexed(address)\r\n    amount: uint256\r\n    borrowed: uint256\r\n\r\n\r\nevent Repay:\r\n    fundManager: indexed(address)\r\n    amount: uint256\r\n    repaid: uint256\r\n\r\n\r\nevent Report:\r\n    fundManager: indexed(address)\r\n    balanceOfVault: uint256\r\n    debt: uint256\r\n    gain: uint256\r\n    loss: uint256\r\n    diff: uint256\r\n    lockedProfit: uint256\r\n\r\n\r\nevent ForceUpdateBalanceOfVault:\r\n    balanceOfVault: uint256\r\n\r\n\r\ninitialized: public(bool)\r\npaused: public(bool)\r\n\r\nETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\nuToken: public(UnagiiToken)\r\nfundManager: public(FundManager)\r\n# privileges: time lock >= admin >= guardian\r\ntimeLock: public(address)\r\nnextTimeLock: public(address)\r\nguardian: public(address)\r\nadmin: public(address)\r\n\r\ndepositLimit: public(uint256)\r\n# ETH balance of vault tracked internally to protect against share dilution\r\n# from sending ETH directly to this contract\r\nbalanceOfVault: public(uint256)\r\ndebt: public(uint256)  # debt to users (amount borrowed by fund manager)\r\n# minimum amount of ETH to be kept in this vault for cheap withdraw\r\nminReserve: public(uint256)\r\nMAX_MIN_RESERVE: constant(uint256) = 10000\r\n# timestamp of last report\r\nlastReport: public(uint256)\r\n# profit locked from report, released over time at a rate set by lockedProfitDegradation\r\nlockedProfit: public(uint256)\r\nMAX_DEGRADATION: constant(uint256) = 10 ** 18\r\n# rate at which locked profit is released\r\n# 0 = forever, MAX_DEGREDATION = 100% of profit is released 1 block after report\r\nlockedProfitDegradation: public(uint256)\r\n# minimum number of block to wait before deposit / withdraw\r\n# used to protect agains flash attacks\r\nblockDelay: public(uint256)\r\n# whitelisted address can bypass block delay check\r\nwhitelist: public(HashMap[address, bool])\r\n\r\n# address of old Vault contract, used for migration\r\noldVault: public(Vault)\r\n\r\n\r\n@external\r\ndef __init__(uToken: address, guardian: address, oldVault: address):\r\n    self.timeLock = msg.sender\r\n    self.admin = msg.sender\r\n    self.guardian = guardian\r\n    self.uToken = UnagiiToken(uToken)\r\n\r\n    assert self.uToken.token() == ETH, \"uToken token != ETH\"\r\n\r\n    self.paused = True\r\n    self.blockDelay = 1\r\n    self.minReserve = 500  # 5% of free funds\r\n    # 6 hours\r\n    self.lockedProfitDegradation = convert(MAX_DEGRADATION / 21600, uint256)\r\n\r\n    if oldVault != ZERO_ADDRESS:\r\n        self.oldVault = Vault(oldVault)\r\n        assert self.oldVault.token() == ETH, \"old vault token != ETH\"\r\n        assert self.oldVault.uToken() == uToken, \"old vault uToken != uToken\"\r\n\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    \"\"\"\r\n    @dev Prevent users from accidentally sending ETH to this vault\r\n    \"\"\"\r\n    assert msg.sender == self.fundManager.address, \"!fund manager\"\r\n    log ReceiveEth(msg.sender, msg.value)\r\n\r\n\r\n@external\r\n@view\r\ndef token() -> address:\r\n    return ETH\r\n\r\n\r\n@internal\r\ndef _sendEth(to: address, amount: uint256):\r\n    assert to != ZERO_ADDRESS, \"to = 0 address\"\r\n    raw_call(to, b\"\", value=amount)\r\n\r\n\r\n@internal\r\ndef _safeTransfer(token: address, receiver: address, amount: uint256):\r\n    res: Bytes[32] = raw_call(\r\n        token,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(receiver, bytes32),\r\n            convert(amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(res) > 0:\r\n        assert convert(res, bool), \"transfer failed\"\r\n\r\n\r\n@external\r\n@payable\r\ndef initialize():\r\n    \"\"\"\r\n    @notice Initialize vault. Transfer ETH and copy states if old vault is set.\r\n    \"\"\"\r\n    assert not self.initialized, \"initialized\"\r\n\r\n    if self.oldVault.address == ZERO_ADDRESS:\r\n        assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n        self.lastReport = block.timestamp\r\n    else:\r\n        assert msg.sender == self.oldVault.address, \"!old vault\"\r\n\r\n        assert self.uToken.minter() == self, \"minter != self\"\r\n\r\n        assert (\r\n            self.fundManager.address == self.oldVault.fundManager()\r\n        ), \"fund manager != old vault fund manager\"\r\n        if self.fundManager.address != ZERO_ADDRESS:\r\n            assert self.fundManager.vault() == self, \"fund manager vault != self\"\r\n\r\n        # check ETH sent from old vault >= old balanceOfVault\r\n        balOfVault: uint256 = self.oldVault.balanceOfVault()\r\n        assert msg.value >= balOfVault, \"value < vault\"\r\n\r\n        self.balanceOfVault = min(balOfVault, msg.value)\r\n        self.debt = self.oldVault.debt()\r\n        self.lockedProfit = self.oldVault.lockedProfit()\r\n        self.lastReport = self.oldVault.lastReport()\r\n\r\n    self.initialized = True\r\n\r\n\r\n# Migration steps from this vault to new vault\r\n#\r\n# ut = unagi token\r\n# v1 = vault 1\r\n# v2 = vault 2\r\n# f = fund manager\r\n#\r\n# action                         | caller\r\n# ----------------------------------------\r\n# 1. v2.setPause(true)           | admin\r\n# 2. v1.setPause(true)           | admin\r\n# 3. ut.setMinter(v2)            | time lock\r\n# 4. f.setVault(v2)              | time lock\r\n# 5. v2.setFundManager(f)        | time lock\r\n# 6. transfer ETH                | v1\r\n# 7. v2 copy states from v1      | v2\r\n#    - balanceOfVault            |\r\n#    - debt                      |\r\n#    - locked profit             |\r\n#    - last report               |\r\n# 8. v1 set state = 0            | v1\r\n#    - balanceOfVault            |\r\n#    - debt                      |\r\n#    - locked profit             |\r\n\r\n\r\n@external\r\ndef migrate(vault: address):\r\n    \"\"\"\r\n    @notice Migrate to new vault\r\n    @param vault Address of new vault\r\n    \"\"\"\r\n    assert msg.sender == self.timeLock, \"!time lock\"\r\n    assert self.initialized, \"!initialized\"\r\n    assert self.paused, \"!paused\"\r\n\r\n    assert Vault(vault).token() == ETH, \"new vault token != ETH\"\r\n    assert Vault(vault).uToken() == self.uToken.address, \"new vault uToken != uToken\"\r\n    # minter is set to new vault\r\n    assert self.uToken.minter() == vault, \"minter != new vault\"\r\n    # new vault's fund manager is set to current fund manager\r\n    assert (\r\n        Vault(vault).fundManager() == self.fundManager.address\r\n    ), \"new vault fund manager != fund manager\"\r\n    if self.fundManager.address != ZERO_ADDRESS:\r\n        # fund manager's vault is set to new vault\r\n        assert self.fundManager.vault() == vault, \"fund manager vault != new vault\"\r\n\r\n    # check balance of vault >= balanceOfVault\r\n    bal: uint256 = self.balance\r\n    assert bal >= self.balanceOfVault, \"bal < vault\"\r\n\r\n    assert Vault(vault).oldVault() == self, \"old vault != self\"\r\n\r\n    Vault(vault).initialize(value=bal)\r\n\r\n    log Migrate(vault, self.balanceOfVault, self.debt, self.lockedProfit)\r\n\r\n    # reset state\r\n    self.balanceOfVault = 0\r\n    self.debt = 0\r\n    self.lockedProfit = 0\r\n\r\n\r\n@external\r\ndef setNextTimeLock(nextTimeLock: address):\r\n    \"\"\"\r\n    @notice Set next time lock\r\n    @param nextTimeLock Address of next time lock\r\n    \"\"\"\r\n    assert msg.sender == self.timeLock, \"!time lock\"\r\n    self.nextTimeLock = nextTimeLock\r\n    log SetNextTimeLock(nextTimeLock)\r\n\r\n\r\n@external\r\ndef acceptTimeLock():\r\n    \"\"\"\r\n    @notice Accept time lock\r\n    @dev Only `nextTimeLock` can claim time lock\r\n    \"\"\"\r\n    assert msg.sender == self.nextTimeLock, \"!next time lock\"\r\n    self.timeLock = msg.sender\r\n    self.nextTimeLock = ZERO_ADDRESS\r\n    log AcceptTimeLock(msg.sender)\r\n\r\n\r\n@external\r\ndef setAdmin(admin: address):\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    self.admin = admin\r\n    log SetAdmin(admin)\r\n\r\n\r\n@external\r\ndef setGuardian(guardian: address):\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    self.guardian = guardian\r\n    log SetGuardian(guardian)\r\n\r\n\r\n@external\r\ndef setFundManager(fundManager: address):\r\n    \"\"\"\r\n    @notice Set fund manager\r\n    @param fundManager Address of new fund manager\r\n    \"\"\"\r\n    assert msg.sender == self.timeLock, \"!time lock\"\r\n\r\n    assert FundManager(fundManager).vault() == self, \"fund manager vault != self\"\r\n    assert FundManager(fundManager).token() == ETH, \"fund manager token != ETH\"\r\n\r\n    self.fundManager = FundManager(fundManager)\r\n    log SetFundManager(fundManager)\r\n\r\n\r\n@external\r\ndef setPause(paused: bool):\r\n    assert msg.sender in [self.timeLock, self.admin, self.guardian], \"!auth\"\r\n    self.paused = paused\r\n    log SetPause(paused)\r\n\r\n\r\n@external\r\ndef setMinReserve(minReserve: uint256):\r\n    \"\"\"\r\n    @notice Set minimum amount of ETH reserved in this vault for cheap\r\n            withdrawn by user\r\n    @param minReserve Numerator to calculate min reserve\r\n           0 = all funds can be transferred to fund manager\r\n           MAX_MIN_RESERVE = 0 ETH can be transferred to fund manager\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    assert minReserve <= MAX_MIN_RESERVE, \"min reserve > max\"\r\n    self.minReserve = minReserve\r\n\r\n\r\n@external\r\ndef setLockedProfitDegradation(degradation: uint256):\r\n    \"\"\"\r\n    @notice Set locked profit degradation (rate locked profit is released)\r\n    @param degradation Rate of degradation\r\n                 0 = profit is locked forever\r\n                 MAX_DEGRADATION = 100% of profit is released 1 block after report\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    assert degradation <= MAX_DEGRADATION, \"degradation > max\"\r\n    self.lockedProfitDegradation = degradation\r\n\r\n\r\n@external\r\ndef setDepositLimit(limit: uint256):\r\n    \"\"\"\r\n    @notice Set limit to total deposit\r\n    @param limit Limit for total deposit\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    self.depositLimit = limit\r\n\r\n\r\n@external\r\ndef setBlockDelay(delay: uint256):\r\n    \"\"\"\r\n    @notice Set block delay, used to protect against flash attacks\r\n    @param delay Number of blocks to delay before user can deposit / withdraw\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    assert delay >= 1, \"delay = 0\"\r\n    self.blockDelay = delay\r\n\r\n\r\n@external\r\ndef setWhitelist(addr: address, approved: bool):\r\n    \"\"\"\r\n    @notice Approve or disapprove address to skip check on block delay.\r\n            Approved address can deposit, withdraw and transfer uToken in\r\n            a single transaction\r\n    @param approved Boolean True = approve\r\n                             False = disapprove\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    self.whitelist[addr] = approved\r\n    log SetWhitelist(addr, approved)\r\n\r\n\r\n@internal\r\n@view\r\ndef _totalAssets() -> uint256:\r\n    \"\"\"\r\n    @notice Total amount of ETH in this vault + amount in fund manager\r\n    @dev State variable `balanceOfVault` is used to track balance of ETH in\r\n         this contract instead of `self.balance`. This is done to\r\n         protect against uToken shares being diluted by directly sending ETH\r\n         to this contract.\r\n    @dev Returns total amount of ETH in this contract\r\n    \"\"\"\r\n    return self.balanceOfVault + self.debt\r\n\r\n\r\n@external\r\n@view\r\ndef totalAssets() -> uint256:\r\n    return self._totalAssets()\r\n\r\n\r\n@internal\r\n@view\r\ndef _calcLockedProfit() -> uint256:\r\n    \"\"\"\r\n    @notice Calculated locked profit\r\n    @dev Returns amount of profit locked from last report. Profit is released\r\n         over time, depending on the release rate `lockedProfitDegradation`.\r\n         Profit is locked after `report` to protect against sandwich attack.\r\n    \"\"\"\r\n    lockedFundsRatio: uint256 = (\r\n        block.timestamp - self.lastReport\r\n    ) * self.lockedProfitDegradation\r\n\r\n    if lockedFundsRatio < MAX_DEGRADATION:\r\n        lockedProfit: uint256 = self.lockedProfit\r\n        return lockedProfit - lockedFundsRatio * lockedProfit / MAX_DEGRADATION\r\n    else:\r\n        return 0\r\n\r\n\r\n@external\r\n@view\r\ndef calcLockedProfit() -> uint256:\r\n    return self._calcLockedProfit()\r\n\r\n\r\n@internal\r\n@view\r\ndef _calcFreeFunds() -> uint256:\r\n    \"\"\"\r\n    @notice Calculate free funds (total assets - locked profit)\r\n    @dev Returns total amount of ETH that can be withdrawn\r\n    \"\"\"\r\n    return self._totalAssets() - self._calcLockedProfit()\r\n\r\n\r\n@external\r\n@view\r\ndef calcFreeFunds() -> uint256:\r\n    return self._calcFreeFunds()\r\n\r\n\r\n@internal\r\n@pure\r\ndef _calcSharesToMint(\r\n    amount: uint256, totalSupply: uint256, freeFunds: uint256\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate uToken shares to mint\r\n    @param amount Amount of ETH to deposit\r\n    @param totalSupply Total amount of shares\r\n    @param freeFunds Free funds before deposit\r\n    @dev Returns amount of uToken to mint. Input must be numbers before deposit\r\n    @dev Calculated with `freeFunds`, not `totalAssets`\r\n    \"\"\"\r\n    # s = shares to mint\r\n    # T = total shares before mint\r\n    # a = deposit amount\r\n    # P = total amount of ETH in vault + fund manager before deposit\r\n    # s / (T + s) = a / (P + a)\r\n    # sP = aT\r\n    # a = 0               | mint s = 0\r\n    # a > 0, T = 0, P = 0 | mint s = a\r\n    # a > 0, T = 0, P > 0 | mint s = a as if P = 0\r\n    # a > 0, T > 0, P = 0 | invalid, equation cannot be true for any s\r\n    # a > 0, T > 0, P > 0 | mint s = aT / P\r\n    if amount == 0:\r\n        return 0\r\n    if totalSupply == 0:\r\n        return amount\r\n    # reverts if free funds = 0\r\n    return amount * totalSupply / freeFunds\r\n\r\n\r\n@external\r\n@view\r\ndef calcSharesToMint(amount: uint256) -> uint256:\r\n    return self._calcSharesToMint(\r\n        amount, self.uToken.totalSupply(), self._calcFreeFunds()\r\n    )\r\n\r\n\r\n@internal\r\n@pure\r\ndef _calcWithdraw(shares: uint256, totalSupply: uint256, freeFunds: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate amount of ETH to withdraw\r\n    @param shares Amount of uToken shares to burn\r\n    @param totalSupply Total amount of shares before burn\r\n    @param freeFunds Free funds\r\n    @dev Returns amount of ETH to withdraw\r\n    @dev Calculated with `freeFunds`, not `totalAssets`\r\n    \"\"\"\r\n    # s = shares\r\n    # T = total supply of shares\r\n    # a = amount to withdraw\r\n    # P = total amount of ETH in vault + fund manager\r\n    # s / T = a / P (constraints T >= s, P >= a)\r\n    # sP = aT\r\n    # s = 0               | a = 0\r\n    # s > 0, T = 0, P = 0 | invalid (violates constraint T >= s)\r\n    # s > 0, T = 0, P > 0 | invalid (violates constraint T >= s)\r\n    # s > 0, T > 0, P = 0 | a = 0\r\n    # s > 0, T > 0, P > 0 | a = sP / T\r\n    if shares == 0:\r\n        return 0\r\n    # invalid if total supply = 0\r\n    return shares * freeFunds / totalSupply\r\n\r\n\r\n@external\r\n@view\r\ndef calcWithdraw(shares: uint256) -> uint256:\r\n    return self._calcWithdraw(shares, self.uToken.totalSupply(), self._calcFreeFunds())\r\n\r\n\r\n@external\r\n@payable\r\n@nonreentrant(\"lock\")\r\ndef deposit(amount: uint256, _min: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Deposit ETH into vault\r\n    @param amount Amount of ETH to deposit\r\n    @param _min Minimum amount of uToken to be minted\r\n    @dev Returns actual amount of uToken minted\r\n    \"\"\"\r\n    assert self.initialized, \"!initialized\"\r\n    assert not self.paused, \"paused\"\r\n    # check block delay or whitelisted\r\n    assert (\r\n        block.number >= self.uToken.lastBlock(msg.sender) + self.blockDelay\r\n        or self.whitelist[msg.sender]\r\n    ), \"block < delay\"\r\n\r\n    assert amount == msg.value, \"amount != msg.value\"\r\n    assert amount > 0, \"deposit = 0\"\r\n\r\n    # check deposit limit\r\n    assert self._totalAssets() + amount <= self.depositLimit, \"deposit limit\"\r\n\r\n    # calculate with free funds before deposit (msg.value is not included in freeFunds)\r\n    shares: uint256 = self._calcSharesToMint(\r\n        amount, self.uToken.totalSupply(), self._calcFreeFunds()\r\n    )\r\n    assert shares >= _min, \"shares < min\"\r\n\r\n    self.balanceOfVault += amount\r\n    self.uToken.mint(msg.sender, shares)\r\n\r\n    # check ETH balance >= balanceOfVault\r\n    assert self.balance >= self.balanceOfVault, \"bal < vault\"\r\n\r\n    log Deposit(msg.sender, amount, shares)\r\n\r\n    return shares\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef withdraw(shares: uint256, _min: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw ETH from vault\r\n    @param shares Amount of uToken to burn\r\n    @param _min Minimum amount of ETH that msg.sender will receive\r\n    @dev Returns actual amount of ETH transferred to msg.sender\r\n    \"\"\"\r\n    assert self.initialized, \"!initialized\"\r\n    # check block delay or whitelisted\r\n    assert (\r\n        block.number >= self.uToken.lastBlock(msg.sender) + self.blockDelay\r\n        or self.whitelist[msg.sender]\r\n    ), \"block < delay\"\r\n\r\n    _shares: uint256 = min(shares, self.uToken.balanceOf(msg.sender))\r\n    assert _shares > 0, \"shares = 0\"\r\n\r\n    amount: uint256 = self._calcWithdraw(\r\n        _shares, self.uToken.totalSupply(), self._calcFreeFunds()\r\n    )\r\n\r\n    # withdraw from fund manager if amount to withdraw > balance of vault\r\n    if amount > self.balanceOfVault:\r\n        diff: uint256 = self.balance\r\n        # loss = debt - total assets in fund manager + any loss from strategies\r\n        # ETH received by __default__\r\n        loss: uint256 = self.fundManager.withdraw(amount - self.balanceOfVault)\r\n        diff = self.balance - diff\r\n\r\n        # diff + loss may be >= amount\r\n        if loss > 0:\r\n            # msg.sender must cover all of loss\r\n            amount -= loss\r\n            self.debt -= loss\r\n\r\n        self.debt -= diff\r\n        self.balanceOfVault += diff\r\n\r\n        if amount > self.balanceOfVault:\r\n            amount = self.balanceOfVault\r\n\r\n    self.uToken.burn(msg.sender, _shares)\r\n\r\n    assert amount >= _min, \"amount < min\"\r\n    self.balanceOfVault -= amount\r\n\r\n    self._sendEth(msg.sender, amount)\r\n\r\n    # check ETH balance >= balanceOfVault\r\n    assert self.balance >= self.balanceOfVault, \"bal < vault\"\r\n\r\n    log Withdraw(msg.sender, _shares, amount)\r\n\r\n    return amount\r\n\r\n\r\n@internal\r\n@view\r\ndef _calcMinReserve() -> uint256:\r\n    \"\"\"\r\n    @notice Calculate minimum amount of ETH that is reserved in vault for\r\n            cheap withdraw by users\r\n    @dev Returns min reserve\r\n    \"\"\"\r\n    freeFunds: uint256 = self._calcFreeFunds()\r\n    return freeFunds * self.minReserve / MAX_MIN_RESERVE\r\n\r\n\r\n@external\r\ndef calcMinReserve() -> uint256:\r\n    return self._calcMinReserve()\r\n\r\n\r\n@internal\r\n@view\r\ndef _calcMaxBorrow() -> uint256:\r\n    \"\"\"\r\n    @notice Calculate amount of ETH available for fund manager to borrow\r\n    @dev Returns amount of ETH fund manager can borrow\r\n    \"\"\"\r\n    if (\r\n        (not self.initialized)\r\n        or self.paused\r\n        or self.fundManager.address == ZERO_ADDRESS\r\n    ):\r\n        return 0\r\n\r\n    minBal: uint256 = self._calcMinReserve()\r\n\r\n    if self.balanceOfVault > minBal:\r\n        return self.balanceOfVault - minBal\r\n    return 0\r\n\r\n\r\n@external\r\n@view\r\ndef calcMaxBorrow() -> uint256:\r\n    return self._calcMaxBorrow()\r\n\r\n\r\n@external\r\ndef borrow(amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Borrow ETH from vault\r\n    @dev Only fund manager can borrow\r\n    @dev Returns actual amount that was given to fund manager\r\n    \"\"\"\r\n    assert self.initialized, \"!initialized\"\r\n    assert not self.paused, \"paused\"\r\n    assert msg.sender == self.fundManager.address, \"!fund manager\"\r\n\r\n    available: uint256 = self._calcMaxBorrow()\r\n    _amount: uint256 = min(amount, available)\r\n    assert _amount > 0, \"borrow = 0\"\r\n\r\n    self._sendEth(msg.sender, _amount)\r\n\r\n    self.balanceOfVault -= _amount\r\n    self.debt += _amount\r\n\r\n    # check ETH balance >= balanceOfVault\r\n    assert self.balance >= self.balanceOfVault, \"bal < vault\"\r\n\r\n    log Borrow(msg.sender, amount, _amount)\r\n\r\n    return _amount\r\n\r\n\r\n@external\r\n@payable\r\ndef repay(amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Repay ETH to vault\r\n    @dev Only fund manager can borrow\r\n    @dev Returns actual amount that was repaid by fund manager\r\n    \"\"\"\r\n    assert self.initialized, \"!initialized\"\r\n    assert msg.sender == self.fundManager.address, \"!fund manager\"\r\n\r\n    assert amount == msg.value, \"amount != msg.value\"\r\n    assert amount > 0, \"repay = 0\"\r\n\r\n    self.balanceOfVault += amount\r\n    self.debt -= amount\r\n\r\n    # check ETH balance >= balanceOfVault\r\n    assert self.balance >= self.balanceOfVault, \"bal < vault\"\r\n\r\n    log Repay(msg.sender, amount, amount)\r\n\r\n    return amount\r\n\r\n\r\n@external\r\n@payable\r\ndef report(gain: uint256, loss: uint256):\r\n    \"\"\"\r\n    @notice Report profit or loss\r\n    @param gain Profit since last report\r\n    @param loss Loss since last report\r\n    @dev Only fund manager can call\r\n    @dev Locks profit to be release over time\r\n    \"\"\"\r\n    assert self.initialized, \"!initialized\"\r\n    assert msg.sender == self.fundManager.address, \"!fund manager\"\r\n    # can't have both gain and loss > 0\r\n    assert (gain >= 0 and loss == 0) or (gain == 0 and loss >= 0), \"gain and loss > 0\"\r\n    assert gain == msg.value, \"gain != msg.value\"\r\n\r\n    # calculate current locked profit\r\n    lockedProfit: uint256 = self._calcLockedProfit()\r\n    diff: uint256 = msg.value  # actual amount transferred if gain > 0\r\n\r\n    if gain > 0:\r\n        # free funds = bal + diff + debt - (locked profit + diff)\r\n        self.balanceOfVault += diff\r\n        self.lockedProfit = lockedProfit + diff\r\n    elif loss > 0:\r\n        # free funds = bal + debt - loss - (locked profit - loss)\r\n        self.debt -= loss\r\n        # deduct locked profit\r\n        if lockedProfit > loss:\r\n            self.lockedProfit -= loss\r\n        else:\r\n            # no locked profit to be released\r\n            self.lockedProfit = 0\r\n\r\n    self.lastReport = block.timestamp\r\n\r\n    # check ETH balance >= balanceOfVault\r\n    assert self.balance >= self.balanceOfVault, \"bal < vault\"\r\n\r\n    # log updated debt and lockedProfit\r\n    log Report(\r\n        msg.sender, self.balanceOfVault, self.debt, gain, loss, diff, self.lockedProfit\r\n    )\r\n\r\n\r\n@external\r\ndef forceUpdateBalanceOfVault():\r\n    \"\"\"\r\n    @notice Force `balanceOfVault` to equal `self.balance`\r\n    @dev Only use in case of emergency if `balanceOfVault` is > actual balance\r\n    \"\"\"\r\n    assert self.initialized, \"!initialized\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n\r\n    bal: uint256 = self.balance\r\n    assert bal < self.balanceOfVault, \"bal >= vault\"\r\n\r\n    self.balanceOfVault = bal\r\n    log ForceUpdateBalanceOfVault(bal)\r\n\r\n\r\n@external\r\ndef skim():\r\n    \"\"\"\r\n    @notice Transfer excess ETH sent to this contract to admin or time lock\r\n    @dev actual ETH balance must be >= `balanceOfVault`\r\n    \"\"\"\r\n    assert msg.sender == self.timeLock, \"!time lock\"\r\n    self._sendEth(msg.sender, self.balance - self.balanceOfVault)\r\n\r\n\r\n@external\r\ndef sweep(token: address):\r\n    \"\"\"\r\n    @notice Transfer any token accidentally sent to this contract\r\n            to admin or time lock\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    self._safeTransfer(token, msg.sender, ERC20(token).balanceOf(self))","ABI":"[{\"name\":\"Migrate\",\"inputs\":[{\"name\":\"vault\",\"type\":\"address\",\"indexed\":false},{\"name\":\"balanceOfVault\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"debt\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"lockedProfit\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetNextTimeLock\",\"inputs\":[{\"name\":\"nextTimeLock\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AcceptTimeLock\",\"inputs\":[{\"name\":\"timeLock\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetGuardian\",\"inputs\":[{\"name\":\"guardian\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetAdmin\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetFundManager\",\"inputs\":[{\"name\":\"fundManager\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetPause\",\"inputs\":[{\"name\":\"paused\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetWhitelist\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\",\"indexed\":true},{\"name\":\"approved\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ReceiveEth\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Deposit\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"shares\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"shares\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Borrow\",\"inputs\":[{\"name\":\"fundManager\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"borrowed\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Repay\",\"inputs\":[{\"name\":\"fundManager\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"repaid\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Report\",\"inputs\":[{\"name\":\"fundManager\",\"type\":\"address\",\"indexed\":true},{\"name\":\"balanceOfVault\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"debt\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"gain\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"loss\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"diff\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"lockedProfit\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ForceUpdateBalanceOfVault\",\"inputs\":[{\"name\":\"balanceOfVault\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"uToken\",\"type\":\"address\"},{\"name\":\"guardian\",\"type\":\"address\"},{\"name\":\"oldVault\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":378},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[],\"outputs\":[],\"gas\":217951},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"migrate\",\"inputs\":[{\"name\":\"vault\",\"type\":\"address\"}],\"outputs\":[],\"gas\":143188},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setNextTimeLock\",\"inputs\":[{\"name\":\"nextTimeLock\",\"type\":\"address\"}],\"outputs\":[],\"gas\":39101},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"acceptTimeLock\",\"inputs\":[],\"outputs\":[],\"gas\":59029},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setAdmin\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"outputs\":[],\"gas\":41682},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setGuardian\",\"inputs\":[{\"name\":\"guardian\",\"type\":\"address\"}],\"outputs\":[],\"gas\":41712},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setFundManager\",\"inputs\":[{\"name\":\"fundManager\",\"type\":\"address\"}],\"outputs\":[],\"gas\":44198},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setPause\",\"inputs\":[{\"name\":\"paused\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":44040},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setMinReserve\",\"inputs\":[{\"name\":\"minReserve\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":40473},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setLockedProfitDegradation\",\"inputs\":[{\"name\":\"degradation\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":40503},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setDepositLimit\",\"inputs\":[{\"name\":\"limit\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":40415},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setBlockDelay\",\"inputs\":[{\"name\":\"delay\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":40563},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setWhitelist\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":42518},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalAssets\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":5973},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calcLockedProfit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":8919},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calcFreeFunds\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":28343},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calcSharesToMint\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":34671},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calcWithdraw\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":34576},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_min\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":184302},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"},{\"name\":\"_min\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":343643},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"calcMinReserve\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":59332},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calcMaxBorrow\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":129729},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"borrow\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":254849},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"repay\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":84773},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"report\",\"inputs\":[{\"name\":\"gain\",\"type\":\"uint256\"},{\"name\":\"loss\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":136768},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"forceUpdateBalanceOfVault\",\"inputs\":[],\"outputs\":[],\"gas\":46636},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"skim\",\"inputs\":[],\"outputs\":[],\"gas\":44754},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"sweep\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"outputs\":[],\"gas\":18697},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initialized\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3348},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"paused\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3378},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"uToken\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3408},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fundManager\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3438},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"timeLock\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3468},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nextTimeLock\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3498},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"guardian\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3528},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3558},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"depositLimit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3588},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOfVault\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3618},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"debt\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3648},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"minReserve\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3678},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lastReport\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3708},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lockedProfit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3738},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lockedProfitDegradation\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3768},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"blockDelay\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3798},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"whitelist\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":4043},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"oldVault\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3858}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.12","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000de07f45688cb6cfaac398c1485860e186d55996d00000000000000000000000086d10751b18f3fe331c146546868a07224a8598b0000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":""}]}