{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.4;\r\n// pragma experimental SMTChecker;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    constructor (string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = accountBalance - amount;\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\ncontract DiamondHandsToken is ERC20(\"DiamondHands\", unicode\"ðŸ’ŽðŸ™Œ\") {\r\n    //// constants\r\n\r\n    // balance has to be 100 tokens to become a diamond member who can:\r\n    // - invite people and get bonus from their purchases\r\n    // - buy extra tokens cheaper\r\n    uint256 constant MINIMUM_DIAMOND_MEMBER_BALANCE = 100 * 1e18;\r\n    // diamond members get 20% discount on purchases above 100 tokens\r\n    uint256 constant DIAMOND_MEMBER_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND = 200;\r\n    // diamond members get 10% extra bonus tokens from people they invited, \r\n    // until those become diamond members themselves\r\n    uint256 constant DIAMOND_MEMBER_INTRODUCER_BONUS_TOKENS_PER_THOUSAND = 100;\r\n    // invited people get 10% discount on purchases,\r\n    // until they become diamond members and get 20% diamond discount\r\n    uint256 constant INVITED_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND = 100;\r\n\r\n    // Price growth\r\n    // - the price grows 5% upon every iteration\r\n    // - new iteration lasts 30-90 minutes and starts:\r\n    //   * either after 100 tokens were bought in the current iteration (fast growth due to popularity),\r\n    //   * or, if somebody buys or sells tokens after 90 minutes of no growth (slow growth)\r\n\r\n    // initial token price is 0.001 ETH per token\r\n    uint256 constant INITIAL_PRICE_ETH_WEI = 1e15;\r\n    // for non-diamond and non-invited members the purchase price is sell price + 80%\r\n    uint256 constant PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND = 1800;\r\n    // price grows 5% each iteration\r\n    uint256 constant PRICE_GROWTH_MULTIPLIER_PER_THOUSAND = 1050;\r\n    // maximum speed that the price can grow is once per 30 minutes\r\n    uint256 constant MINIMUM_GROWTH_ITERATION_PERIOD = 30 minutes;\r\n    // after 90 minutes of no growth (low activity), the price will still grow\r\n    uint256 constant SLOW_GROWTH_ITERATION_PERIOD = 90 minutes;\r\n    // at least 100 tokens have to be sold for fast growth\r\n    uint256 constant FAST_GROWTH_THRESHOLD = 100 * 1e18;\r\n    \r\n    //// events\r\n    event NewPrice(uint256 timestamp, uint256 newPrice);\r\n\r\n    //// state\r\n    mapping (address => address) private _introducers;\r\n    uint256 private _sellPriceEthWei;\r\n    uint256 private _lastPriceGrowthTimestamp;\r\n    uint256 private _purchasedTokensForFastGrowthSoFar = 0;\r\n    \r\n    //// private\r\n    constructor() payable {\r\n        emit NewPrice(\r\n            _lastPriceGrowthTimestamp = block.timestamp,\r\n            _sellPriceEthWei = INITIAL_PRICE_ETH_WEI\r\n            );\r\n        // no pre-mine\r\n    }\r\n\r\n    function _isDiamondMember(address member) private view returns(bool) {\r\n        return balanceOf(member) >= MINIMUM_DIAMOND_MEMBER_BALANCE;\r\n    }\r\n    function _registerUnderIntroducer(address introducer) private {\r\n        require(msg.sender != introducer,\r\n            \"Members cannot introduce themselves\");\r\n        require(_introducers[msg.sender] == address(0) || _introducers[msg.sender] == introducer, \r\n            \"Introducer cannot be changed later\");\r\n        require(_isDiamondMember(introducer), \r\n            \"Provided introducer address is not a Diamond member at this moment\");\r\n        _introducers[msg.sender] = introducer;\r\n    }\r\n    function _growIfAccumulatedEnough(uint256 amountBought) private {\r\n        // check if we should make the price grow\r\n        uint256 accumulated = _purchasedTokensForFastGrowthSoFar + amountBought;\r\n        uint256 lastPriceGrowthTimestamp = _lastPriceGrowthTimestamp;\r\n        uint256 blockTimestamp = block.timestamp;\r\n        if (\r\n            // fast growth condition\r\n            (accumulated > FAST_GROWTH_THRESHOLD\r\n            && (lastPriceGrowthTimestamp + MINIMUM_GROWTH_ITERATION_PERIOD) <= blockTimestamp)\r\n            ||\r\n            // slow growth condition\r\n            (lastPriceGrowthTimestamp + SLOW_GROWTH_ITERATION_PERIOD) <= blockTimestamp\r\n            ) {\r\n            // start new iteration with new price\r\n            _purchasedTokensForFastGrowthSoFar = 0;\r\n            emit NewPrice(\r\n                _lastPriceGrowthTimestamp = blockTimestamp,\r\n                _sellPriceEthWei = _sellPriceEthWei * PRICE_GROWTH_MULTIPLIER_PER_THOUSAND / 1000\r\n                );\r\n        }\r\n        else {\r\n            _purchasedTokensForFastGrowthSoFar = accumulated;\r\n        }\r\n    }\r\n    function _sell(uint256 amount) private {\r\n        uint256 sellPriceEthWei = _sellPriceEthWei;\r\n        _growIfAccumulatedEnough(0);\r\n        _burn(msg.sender, amount);\r\n        payable(msg.sender).transfer(amount * sellPriceEthWei / 1e18);\r\n    }\r\n    function _buy(uint256 ethWeiAmount) private {\r\n        uint256 sellPriceEthWei = _sellPriceEthWei;\r\n        uint256 amountBought = 0;\r\n        uint256 myBalance = balanceOf(msg.sender);\r\n        address introducer = _introducers[msg.sender];\r\n\r\n        // if not a diamond member yet, buy at non-diamond price\r\n        if (myBalance < MINIMUM_DIAMOND_MEMBER_BALANCE) {\r\n            uint256 nonDiamondBuyPriceInEthWei = \r\n                introducer != address(0) \r\n                    // if we have an introducer, get a discounted price\r\n                    ? (sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND * (1000 - INVITED_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND) \r\n                        / (1000 * 1000))\r\n                    // else get a normal price\r\n                    : (sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND / 1000);\r\n            uint256 amountAtThisPrice = ethWeiAmount * 1e18 / nonDiamondBuyPriceInEthWei;\r\n\r\n            // if didn't become a diamond member while buying\r\n            if (myBalance + amountAtThisPrice <= MINIMUM_DIAMOND_MEMBER_BALANCE) {\r\n                // buy the whole amount\r\n                amountBought = amountAtThisPrice;\r\n                ethWeiAmount = 0;\r\n            }\r\n            else {\r\n                // buy just enough to become a diamond member, and buy the rest at diamond price\r\n                amountBought = MINIMUM_DIAMOND_MEMBER_BALANCE - myBalance;\r\n                ethWeiAmount -= amountBought * nonDiamondBuyPriceInEthWei / 1e18;\r\n            }\r\n        }\r\n\r\n        // if still have money at this point, buy at diamond price\r\n        if (ethWeiAmount > 0) {\r\n            uint256 diamondBuyPriceInEthWei = \r\n                (sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND * (1000 - DIAMOND_MEMBER_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND) \r\n                        / (1000 * 1000));\r\n            amountBought += ethWeiAmount * 1e18 / diamondBuyPriceInEthWei;\r\n        }\r\n\r\n        // grow the price\r\n        _growIfAccumulatedEnough(amountBought);\r\n        // mint the tokens\r\n        _mint(msg.sender, amountBought);\r\n        // mint tokens for the introducer\r\n        if (introducer != address(0)) {\r\n            _mint(introducer, amountBought * DIAMOND_MEMBER_INTRODUCER_BONUS_TOKENS_PER_THOUSAND / 1000);\r\n        }\r\n    }\r\n\r\n    //// view\r\n    function haveIntroducer() public view returns(bool) { return _introducers[msg.sender] != address(0); }\r\n    function amDiamondMember() public view returns(bool) { return _isDiamondMember(msg.sender); }\r\n    function getSellPrice() public view returns(uint256) { return _sellPriceEthWei; }\r\n    function getBasicBuyPrice() public view returns(uint256) {\r\n        return _sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND / 1000;\r\n    }\r\n    function getBuyPriceWithMyDiscounts() public view returns(uint256) {\r\n        if (_isDiamondMember(msg.sender)) {\r\n            return \r\n                _sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND * (1000 - DIAMOND_MEMBER_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND) \r\n                / (1000 * 1000);\r\n        }\r\n        else if (_introducers[msg.sender] != address(0)) {\r\n            return\r\n                _sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND * (1000 - INVITED_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND) \r\n                / (1000 * 1000);\r\n        }\r\n        else {\r\n            return _sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND / 1000;\r\n        }\r\n    }\r\n    function getTokensBoughtAfterLastGrowth() public view returns(uint256) { return _purchasedTokensForFastGrowthSoFar; }\r\n    function getUiState() public view returns(\r\n        uint256 secondsElapsed, \r\n        uint256 tokensSold, \r\n        uint256 sellPrice, \r\n        uint256 buyPriceBasic, \r\n        uint256 buyPricePersonal, \r\n        uint256 balance, \r\n        bool invited, \r\n        bool diamond) {\r\n        return (\r\n            block.timestamp - _lastPriceGrowthTimestamp,\r\n            _purchasedTokensForFastGrowthSoFar,\r\n            _sellPriceEthWei,\r\n            getBasicBuyPrice(),\r\n            getBuyPriceWithMyDiscounts(),\r\n            balanceOf(msg.sender),\r\n            haveIntroducer(),\r\n            amDiamondMember()\r\n            );\r\n    }\r\n\r\n    //// callable from outside\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return address(this).balance * 1e18 / _sellPriceEthWei;\r\n    }\r\n    function buy() external payable {\r\n        require(msg.value > 0,\r\n            \"Please send ETH to purchase tokens\");\r\n        _buy(msg.value);\r\n    }\r\n    function buyAndRegisterUnderIntroducer(address introducer) external payable {\r\n        require(msg.value > 0,\r\n            \"Please send ETH to purchase tokens\");\r\n        require(introducer != address(0),\r\n            \"Please specify an introducer to register under\");\r\n        _registerUnderIntroducer(introducer);\r\n        _buy(msg.value);\r\n    }\r\n    function sell(uint256 amount) external {\r\n        require(amount > 0,\r\n            \"Please provide the amount of tokens to sell\");\r\n        _sell(amount);\r\n    }\r\n    function sellAll() external {\r\n        uint256 balance = balanceOf(msg.sender);\r\n        require(balance > 0,\r\n            \"You don't have any tokens to sell\");\r\n        _sell(balance);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"NewPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amDiamondMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"introducer\",\"type\":\"address\"}],\"name\":\"buyAndRegisterUnderIntroducer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBasicBuyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBuyPriceWithMyDiscounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokensBoughtAfterLastGrowth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUiState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"secondsElapsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyPriceBasic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyPricePersonal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"invited\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"diamond\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"haveIntroducer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DiamondHandsToken","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://cc9e6b867deb84b2d6004ad2aede3e13cff0a842cd8a2a751cef17ea0b3d53e6"}]}