{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract Manageable is Ownable {\r\n    event ManagerAdded(address indexed manager);\r\n    event ManagerRemoved(address indexed manager);\r\n    event ManagementRenounced(address indexed manager);\r\n    event ManagementTransferred(address indexed previousManager, address indexed newManager);\r\n\r\n    mapping (address => bool) private _managers;\r\n\r\n    function addManager(address manager) public onlyOwner {\r\n        if (!isManager(manager)) {\r\n            _managers[manager] = true;\r\n            emit ManagerAdded(manager);\r\n        }\r\n    }\r\n\r\n    function removeManager(address manager) public onlyOwner {\r\n        if (isManager(manager)) {\r\n            _managers[manager] = false;\r\n            emit ManagerRemoved(manager);\r\n        }\r\n    }\r\n\r\n    function transferManagement(address manager) public onlyManager {\r\n        if (!isManager(manager)) {\r\n            _managers[manager] = true;\r\n            _managers[msg.sender] = false;\r\n            emit ManagementTransferred(msg.sender, manager);\r\n        }\r\n    }\r\n\r\n    function renounceManagement() public onlyManager {\r\n        _managers[msg.sender] = false;\r\n        emit ManagementRenounced(msg.sender);\r\n    }\r\n\r\n    function isManager(address client) public view returns (bool) {\r\n        return _managers[client];\r\n    }\r\n\r\n    modifier onlyManager() {\r\n        require(isManager(msg.sender));\r\n        _;\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.2;\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\npragma solidity ^0.5.2;\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // benefit is lost if 'b' is also tested.\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.2;\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // than to check the size of the code at that address.\r\n        // for more details about how this works.\r\n        // contracts then.\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.2;\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // we're implementing it ourselves.\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n\r\n        require(address(token).isContract());\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success);\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            require(abi.decode(returndata, (bool)));\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract Vault is Ownable, Manageable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    event Deposit(address indexed token, address indexed client, uint256 amount, uint256 fee, uint256 balance);\r\n    event Withdrawal(address indexed token, address indexed client, uint256 amount, uint256 fee, uint256 balance);\r\n    event Transfer(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 fromFee, uint256 toFee);\r\n    event BankChanged(address indexed bank);\r\n    event PermissionChanged(address indexed token, bool depositPermission, bool withdrawalPermission);\r\n    event FeeRateChanged(address indexed token, uint256 depositFeeRate, uint256 withdrawalFeeRate);\r\n    event BlacklistChanged(address indexed client, bool depositBlacklist, bool withdrawalBlacklist);\r\n\r\n    address private _bank;\r\n    mapping (address => mapping (address => uint256)) private _balances;\r\n    mapping (address => bool) private _depositPermissions;\r\n    mapping (address => bool) private _withdrawalPermissions;\r\n    mapping (address => bool) private _depositBlacklist;\r\n    mapping (address => bool) private _withdrawalBlacklist;\r\n    mapping (address => uint256) private _depositFeeRates;\r\n    mapping (address => uint256) private _withdrawalFeeRates;\r\n\r\n    constructor () public {\r\n        addManager(msg.sender);\r\n    } \r\n    \r\n    function renounceOwnership() public onlyOwner {\r\n        revert();\r\n    }\r\n\r\n    function bank() public view returns (address) {\r\n        return _bank;\r\n    }\r\n\r\n    function setBank(address account) public onlyManager {\r\n        if (bank() != account) {\r\n            _bank = account;\r\n            emit BankChanged(bank());\r\n        }\r\n    }\r\n\r\n    function balanceOf(address token, address client) public view returns (uint256) {\r\n        return _balances[token][client];\r\n    }\r\n\r\n    function _setBalance(address token, address client, uint256 amount) private {\r\n        _balances[token][client] = amount;\r\n    }\r\n\r\n    function isDepositPermitted(address token) public view returns (bool) {\r\n        return _depositPermissions[token];\r\n    }\r\n\r\n    function isWithdrawalPermitted(address token) public view returns (bool) {\r\n        return _withdrawalPermissions[token];\r\n    }\r\n\r\n    function setPermission(address token, bool depositPermission, bool withdrawalPermission) public onlyManager {\r\n        if (isDepositPermitted(token) != depositPermission || isWithdrawalPermitted(token) != withdrawalPermission) {\r\n            _depositPermissions[token] = depositPermission;\r\n            _withdrawalPermissions[token] = withdrawalPermission;\r\n            emit PermissionChanged(token, isDepositPermitted(token), isWithdrawalPermitted(token));\r\n        }\r\n    }\r\n\r\n    function multiSetPermission(address[] memory tokens, bool[] memory depositPermissions, bool[] memory withdrawalPermissions) public onlyManager {\r\n        require(tokens.length == depositPermissions.length && tokens.length == withdrawalPermissions.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            setPermission(tokens[i], depositPermissions[i], withdrawalPermissions[i]);\r\n        }\r\n    }\r\n\r\n    function isDepositBlacklisted(address client) public view returns (bool) {\r\n        return _depositBlacklist[client];\r\n    }\r\n\r\n    function isWithdrawalBlacklisted(address client) public view returns (bool) {\r\n        return _withdrawalBlacklist[client];\r\n    }\r\n\r\n    function setBlacklist(address client, bool depositBlacklist, bool withdrawalBlacklist) public onlyManager {\r\n        if (isDepositBlacklisted(client) != depositBlacklist || isWithdrawalBlacklisted(client) != withdrawalBlacklist) {\r\n            _depositBlacklist[client] = depositBlacklist;\r\n            _withdrawalBlacklist[client] = withdrawalBlacklist;\r\n            emit BlacklistChanged(client, isDepositBlacklisted(client), isWithdrawalBlacklisted(client));\r\n        }\r\n    }\r\n    \r\n    function multiSetBlacklist(address[] memory clients, bool[] memory depositBlacklists, bool[] memory withdrawalBlacklists) public onlyManager {\r\n        require(clients.length == depositBlacklists.length && clients.length == withdrawalBlacklists.length);\r\n        for (uint256 i = 0; i < clients.length; i++) {\r\n            setBlacklist(clients[i], depositBlacklists[i], withdrawalBlacklists[i]);\r\n        }\r\n    }\r\n\r\n    function depositFeeRateOf(address token) public view returns (uint256) {\r\n        return _depositFeeRates[token];\r\n    }    \r\n\r\n    function withdrawalFeeRateOf(address token) public view returns (uint256) {\r\n        return _withdrawalFeeRates[token];\r\n    }    \r\n\r\n    function setFeeRate(address token, uint256 depositFeeRate, uint256 withdrawalFeeRate) public onlyManager {\r\n        if (depositFeeRateOf(token) != depositFeeRate || withdrawalFeeRateOf(token) != withdrawalFeeRate) {\r\n            _depositFeeRates[token] = depositFeeRate;\r\n            _withdrawalFeeRates[token] = withdrawalFeeRate;\r\n            emit FeeRateChanged(token, depositFeeRateOf(token), withdrawalFeeRateOf(token));\r\n        }\r\n    }\r\n    \r\n    function multiSetFeeRate(address[] memory tokens, uint256[] memory depositFees, uint256[] memory withdrawalFees) public onlyManager {\r\n        require(tokens.length == depositFees.length && tokens.length == withdrawalFees.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            setFeeRate(tokens[i], depositFees[i], withdrawalFees[i]);\r\n        }\r\n    }\r\n\r\n    function () payable external {\r\n        deposit(address(0x0), msg.value);\r\n    }\r\n\r\n    function deposit(address token, uint256 amount) payable public {\r\n        if (token == address(0x0)) {\r\n            require(amount == msg.value);\r\n        }\r\n        else {\r\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\r\n        }\r\n        require(amount > 0 && isDepositPermitted(token) && !isDepositBlacklisted(msg.sender));\r\n        uint256 fee = calculateFee(amount, depositFeeRateOf(token));\r\n        _setBalance(token, msg.sender, balanceOf(token, msg.sender).add(amount.sub(fee)));\r\n        _setBalance(token, bank(), balanceOf(token, bank()).add(fee));\r\n        emit Deposit(token, msg.sender, amount, fee, balanceOf(token, msg.sender));\r\n    }\r\n\r\n    function multiDeposit(address[] memory tokens, uint256[] memory amounts) payable public {\r\n        require(tokens.length == amounts.length);\r\n        bool etherProcessed = false;\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            bool isEther = tokens[i] == address(0x0);\r\n            require(!isEther || !etherProcessed);\r\n            deposit(tokens[i], amounts[i]);\r\n            if (isEther) {\r\n                etherProcessed = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdraw(address token, uint256 amount) public {\r\n        require(amount > 0 && isWithdrawalPermitted(token) && !isWithdrawalBlacklisted(msg.sender) && balanceOf(token, msg.sender) >= amount);\r\n        uint256 fee = calculateFee(amount, withdrawalFeeRateOf(token));\r\n        if (token == address(0x0)) {    \r\n            msg.sender.transfer(amount - fee);\r\n        }\r\n        else {\r\n            IERC20(token).safeTransfer(msg.sender, amount - fee);\r\n        }\r\n        _setBalance(token, msg.sender, balanceOf(token, msg.sender).sub(amount));\r\n        _setBalance(token, bank(), balanceOf(token, bank()).add(fee));\r\n        emit Withdrawal(token, msg.sender, amount, fee, balanceOf(token, msg.sender));\r\n    }\r\n\r\n    function multiWithdraw(address[] memory tokens, uint256[] memory amounts) public {\r\n        require(tokens.length == amounts.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            withdraw(tokens[i], amounts[i]);\r\n        }\r\n    }\r\n\r\n    function transfer(address token, address from, address to, uint256 amount, uint256 fromFeeRate, uint256 toFeeRate) public onlyManager {\r\n        uint256 fromFee = calculateFee(amount, fromFeeRate);\r\n        uint256 toFee = calculateFee(amount, toFeeRate);\r\n        require (amount > 0 && balanceOf(token, from) >= amount.add(fromFee));\r\n        _setBalance(token, from, balanceOf(token, from).sub(amount.add(fromFee)));\r\n        _setBalance(token, to, balanceOf(token, to).add(amount.sub(toFee)));\r\n        _setBalance(token, bank(), balanceOf(token, bank()).add(fromFee).add(toFee));\r\n        emit Transfer(token, from, to, amount, fromFee, toFee);\r\n    }\r\n\r\n    function multiTransfer(address[] memory tokens, address[] memory froms, address[] memory tos, uint256[] memory amounts, uint256[] memory fromFeeRates, uint256[] memory toFeeRates) public onlyManager {\r\n        require (tokens.length == froms.length && tokens.length == tos.length && tokens.length == amounts.length && tokens.length == fromFeeRates.length && tokens.length == toFeeRates.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            transfer(tokens[i], froms[i], tos[i], amounts[i], fromFeeRates[i], toFeeRates[i]);\r\n        }\r\n    }\r\n\r\n    function calculateFee(uint256 amount, uint256 feeRate) public pure returns (uint256) {\r\n        return amount.mul(feeRate).div(1 ether);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"multiDeposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceManagement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setBank\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"depositFeeRateOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"feeRate\",\"type\":\"uint256\"}],\"name\":\"calculateFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"fromFeeRate\",\"type\":\"uint256\"},{\"name\":\"toFeeRate\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"client\",\"type\":\"address\"}],\"name\":\"isWithdrawalBlacklisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"depositFees\",\"type\":\"uint256[]\"},{\"name\":\"withdrawalFees\",\"type\":\"uint256[]\"}],\"name\":\"multiSetFeeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bank\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"multiWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"client\",\"type\":\"address\"}],\"name\":\"isDepositBlacklisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"depositPermissions\",\"type\":\"bool[]\"},{\"name\":\"withdrawalPermissions\",\"type\":\"bool[]\"}],\"name\":\"multiSetPermission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isWithdrawalPermitted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"froms\",\"type\":\"address[]\"},{\"name\":\"tos\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"fromFeeRates\",\"type\":\"uint256[]\"},{\"name\":\"toFeeRates\",\"type\":\"uint256[]\"}],\"name\":\"multiTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isDepositPermitted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"depositPermission\",\"type\":\"bool\"},{\"name\":\"withdrawalPermission\",\"type\":\"bool\"}],\"name\":\"setPermission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"clients\",\"type\":\"address[]\"},{\"name\":\"depositBlacklists\",\"type\":\"bool[]\"},{\"name\":\"withdrawalBlacklists\",\"type\":\"bool[]\"}],\"name\":\"multiSetBlacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"transferManagement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"depositFeeRate\",\"type\":\"uint256\"},{\"name\":\"withdrawalFeeRate\",\"type\":\"uint256\"}],\"name\":\"setFeeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"client\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"client\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"client\",\"type\":\"address\"},{\"name\":\"depositBlacklist\",\"type\":\"bool\"},{\"name\":\"withdrawalBlacklist\",\"type\":\"bool\"}],\"name\":\"setBlacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawalFeeRateOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fromFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"toFee\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bank\",\"type\":\"address\"}],\"name\":\"BankChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"depositPermission\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"withdrawalPermission\",\"type\":\"bool\"}],\"name\":\"PermissionChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"depositFeeRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"withdrawalFeeRate\",\"type\":\"uint256\"}],\"name\":\"FeeRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"depositBlacklist\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"withdrawalBlacklist\",\"type\":\"bool\"}],\"name\":\"BlacklistChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ManagerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ManagementRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Vault","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://3935bff0354c79693632a8cae04c4d2ee01b6d9fac9e7b75b7b8ed9dcd82f312"}]}