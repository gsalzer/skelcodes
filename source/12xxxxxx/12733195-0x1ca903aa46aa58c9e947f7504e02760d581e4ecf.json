{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Migration_Alnitak.sol\": {\r\n      \"content\": \"/*\\n   ____            __   __        __   _\\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\\n _\\\\ \\\\ / // // _ \\\\/ __// _ \\\\/ -_)/ __// / \\\\ \\\\ /\\n/___/ \\\\_, //_//_/\\\\__//_//_/\\\\__/ \\\\__//_/ /_\\\\_\\\\\\n     /___/\\n\\n* Synthetix: migrations/Migration_Alnitak.sol\\n*\\n* Latest source (may be newer): https://github.com/Synthetixio/synthetix/blob/master/contracts/migrations/Migration_Alnitak.sol\\n* Docs: https://docs.synthetix.io/contracts/migrations/Migration_Alnitak\\n*\\n* Contract Dependencies: \\n*\\t- BaseMigration\\n*\\t- IAddressResolver\\n*\\t- IERC20\\n*\\t- IExchangeState\\n*\\t- IRewardEscrow\\n*\\t- IRewardsDistribution\\n*\\t- ISystemStatus\\n*\\t- LegacyOwned\\n*\\t- Owned\\n*\\t- Proxy\\n*\\t- State\\n* Libraries: \\n*\\t- SafeDecimalMath\\n*\\t- SafeMath\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 Synthetix\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n*/\\n\\n\\n\\npragma solidity ^0.5.16;\\n\\n// https://docs.synthetix.io/contracts/source/contracts/owned\\ncontract Owned {\\n    address public owner;\\n    address public nominatedOwner;\\n\\n    constructor(address _owner) public {\\n        require(_owner != address(0), \\\"Owner address cannot be 0\\\");\\n        owner = _owner;\\n        emit OwnerChanged(address(0), _owner);\\n    }\\n\\n    function nominateNewOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOwner, \\\"You must be nominated before you can accept ownership\\\");\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    function _onlyOwner() private view {\\n        require(msg.sender == owner, \\\"Only the contract owner may perform this action\\\");\\n    }\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n}\\n\\n\\ncontract BaseMigration is Owned {\\n    address public deployer;\\n\\n    constructor(address _owner) internal Owned(_owner) {\\n        deployer = msg.sender;\\n    }\\n\\n    // safety value to return ownership (anyone can invoke)\\n    function returnOwnership(address forContract) external {\\n        bytes memory payload = abi.encodeWithSignature(\\\"nominateNewOwner(address)\\\", owner);\\n\\n        // solhint-disable avoid-low-level-calls\\n        (bool success, ) = forContract.call(payload);\\n\\n        if (!success) {\\n            // then try legacy way\\n            bytes memory legacyPayload = abi.encodeWithSignature(\\\"nominateOwner(address)\\\", owner);\\n\\n            // solhint-disable avoid-low-level-calls\\n            (bool legacySuccess, ) = forContract.call(legacyPayload);\\n\\n            require(legacySuccess, \\\"Legacy nomination failed\\\");\\n        }\\n    }\\n\\n    function _requireDeployer() private view {\\n        require(msg.sender == deployer, \\\"Only the deployer can invoke this\\\");\\n    }\\n\\n    modifier onlyDeployer() {\\n        _requireDeployer();\\n        _;\\n    }\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\\ninterface IAddressResolver {\\n    function getAddress(bytes32 name) external view returns (address);\\n\\n    function getSynth(bytes32 key) external view returns (address);\\n\\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\\ninterface ISynth {\\n    // Views\\n    function currencyKey() external view returns (bytes32);\\n\\n    function transferableSynths(address account) external view returns (uint);\\n\\n    // Mutative functions\\n    function transferAndSettle(address to, uint value) external returns (bool);\\n\\n    function transferFromAndSettle(\\n        address from,\\n        address to,\\n        uint value\\n    ) external returns (bool);\\n\\n    // Restricted: used internally to Synthetix\\n    function burn(address account, uint amount) external;\\n\\n    function issue(address account, uint amount) external;\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iissuer\\ninterface IIssuer {\\n    // Views\\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\\n\\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\\n\\n    function availableSynthCount() external view returns (uint);\\n\\n    function availableSynths(uint index) external view returns (ISynth);\\n\\n    function canBurnSynths(address account) external view returns (bool);\\n\\n    function collateral(address account) external view returns (uint);\\n\\n    function collateralisationRatio(address issuer) external view returns (uint);\\n\\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\\n        external\\n        view\\n        returns (uint cratio, bool anyRateIsInvalid);\\n\\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\\n\\n    function issuanceRatio() external view returns (uint);\\n\\n    function lastIssueEvent(address account) external view returns (uint);\\n\\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\\n\\n    function minimumStakeTime() external view returns (uint);\\n\\n    function remainingIssuableSynths(address issuer)\\n        external\\n        view\\n        returns (\\n            uint maxIssuable,\\n            uint alreadyIssued,\\n            uint totalSystemDebt\\n        );\\n\\n    function synths(bytes32 currencyKey) external view returns (ISynth);\\n\\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory);\\n\\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\\n\\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeEtherCollateral) external view returns (uint);\\n\\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\\n        external\\n        view\\n        returns (uint transferable, bool anyRateIsInvalid);\\n\\n    // Restricted: used internally to Synthetix\\n    function issueSynths(address from, uint amount) external;\\n\\n    function issueSynthsOnBehalf(\\n        address issueFor,\\n        address from,\\n        uint amount\\n    ) external;\\n\\n    function issueMaxSynths(address from) external;\\n\\n    function issueMaxSynthsOnBehalf(address issueFor, address from) external;\\n\\n    function burnSynths(address from, uint amount) external;\\n\\n    function burnSynthsOnBehalf(\\n        address burnForAddress,\\n        address from,\\n        uint amount\\n    ) external;\\n\\n    function burnSynthsToTarget(address from) external;\\n\\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external;\\n\\n    function liquidateDelinquentAccount(\\n        address account,\\n        uint susdAmount,\\n        address liquidator\\n    ) external returns (uint totalRedeemed, uint amountToLiquidate);\\n}\\n\\n\\n// solhint-disable payable-fallback\\n\\n// https://docs.synthetix.io/contracts/source/contracts/readproxy\\ncontract ReadProxy is Owned {\\n    address public target;\\n\\n    constructor(address _owner) public Owned(_owner) {}\\n\\n    function setTarget(address _target) external onlyOwner {\\n        target = _target;\\n        emit TargetUpdated(target);\\n    }\\n\\n    function() external {\\n        // The basics of a proxy read call\\n        // Note that msg.sender in the underlying will always be the address of this contract.\\n        assembly {\\n            calldatacopy(0, 0, calldatasize)\\n\\n            // Use of staticcall - this will revert if the underlying function mutates state\\n            let result := staticcall(gas, sload(target_slot), 0, calldatasize, 0, 0)\\n            returndatacopy(0, 0, returndatasize)\\n\\n            if iszero(result) {\\n                revert(0, returndatasize)\\n            }\\n            return(0, returndatasize)\\n        }\\n    }\\n\\n    event TargetUpdated(address newTarget);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/mixinresolver\\ncontract MixinResolver {\\n    AddressResolver public resolver;\\n\\n    mapping(bytes32 => address) private addressCache;\\n\\n    constructor(address _resolver) internal {\\n        resolver = AddressResolver(_resolver);\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\\n        internal\\n        pure\\n        returns (bytes32[] memory combination)\\n    {\\n        combination = new bytes32[](first.length + second.length);\\n\\n        for (uint i = 0; i < first.length; i++) {\\n            combination[i] = first[i];\\n        }\\n\\n        for (uint j = 0; j < second.length; j++) {\\n            combination[first.length + j] = second[j];\\n        }\\n    }\\n\\n    /* ========== PUBLIC FUNCTIONS ========== */\\n\\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {}\\n\\n    function rebuildCache() public {\\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\\n        // The resolver must call this function whenver it updates its state\\n        for (uint i = 0; i < requiredAddresses.length; i++) {\\n            bytes32 name = requiredAddresses[i];\\n            // Note: can only be invoked once the resolver has all the targets needed added\\n            address destination =\\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\\\"Resolver missing target: \\\", name)));\\n            addressCache[name] = destination;\\n            emit CacheUpdated(name, destination);\\n        }\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function isResolverCached() external view returns (bool) {\\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\\n        for (uint i = 0; i < requiredAddresses.length; i++) {\\n            bytes32 name = requiredAddresses[i];\\n            // false if our cache is invalid or if the resolver doesn't have the required address\\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\\n        address _foundAddress = addressCache[name];\\n        require(_foundAddress != address(0), string(abi.encodePacked(\\\"Missing address: \\\", name)));\\n        return _foundAddress;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event CacheUpdated(bytes32 name, address destination);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/addressresolver\\ncontract AddressResolver is Owned, IAddressResolver {\\n    mapping(bytes32 => address) public repository;\\n\\n    constructor(address _owner) public Owned(_owner) {}\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\\n        require(names.length == destinations.length, \\\"Input lengths must match\\\");\\n\\n        for (uint i = 0; i < names.length; i++) {\\n            bytes32 name = names[i];\\n            address destination = destinations[i];\\n            repository[name] = destination;\\n            emit AddressImported(name, destination);\\n        }\\n    }\\n\\n    /* ========= PUBLIC FUNCTIONS ========== */\\n\\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\\n        for (uint i = 0; i < destinations.length; i++) {\\n            destinations[i].rebuildCache();\\n        }\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\\n        for (uint i = 0; i < names.length; i++) {\\n            if (repository[names[i]] != destinations[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function getAddress(bytes32 name) external view returns (address) {\\n        return repository[name];\\n    }\\n\\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\\n        address _foundAddress = repository[name];\\n        require(_foundAddress != address(0), reason);\\n        return _foundAddress;\\n    }\\n\\n    function getSynth(bytes32 key) external view returns (address) {\\n        IIssuer issuer = IIssuer(repository[\\\"Issuer\\\"]);\\n        require(address(issuer) != address(0), \\\"Cannot find Issuer address\\\");\\n        return address(issuer.synths(key));\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event AddressImported(bytes32 name, address destination);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/proxyable\\ncontract Proxyable is Owned {\\n    // This contract should be treated like an abstract contract\\n\\n    /* The proxy this contract exists behind. */\\n    Proxy public proxy;\\n    Proxy public integrationProxy;\\n\\n    /* The caller of the proxy, passed through to this contract.\\n     * Note that every function using this member must apply the onlyProxy or\\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\\n    address public messageSender;\\n\\n    constructor(address payable _proxy) internal {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), \\\"Owner must be set\\\");\\n\\n        proxy = Proxy(_proxy);\\n        emit ProxyUpdated(_proxy);\\n    }\\n\\n    function setProxy(address payable _proxy) external onlyOwner {\\n        proxy = Proxy(_proxy);\\n        emit ProxyUpdated(_proxy);\\n    }\\n\\n    function setIntegrationProxy(address payable _integrationProxy) external onlyOwner {\\n        integrationProxy = Proxy(_integrationProxy);\\n    }\\n\\n    function setMessageSender(address sender) external onlyProxy {\\n        messageSender = sender;\\n    }\\n\\n    modifier onlyProxy {\\n        _onlyProxy();\\n        _;\\n    }\\n\\n    function _onlyProxy() private view {\\n        require(Proxy(msg.sender) == proxy || Proxy(msg.sender) == integrationProxy, \\\"Only the proxy can call\\\");\\n    }\\n\\n    modifier optionalProxy {\\n        _optionalProxy();\\n        _;\\n    }\\n\\n    function _optionalProxy() private {\\n        if (Proxy(msg.sender) != proxy && Proxy(msg.sender) != integrationProxy && messageSender != msg.sender) {\\n            messageSender = msg.sender;\\n        }\\n    }\\n\\n    modifier optionalProxy_onlyOwner {\\n        _optionalProxy_onlyOwner();\\n        _;\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function _optionalProxy_onlyOwner() private {\\n        if (Proxy(msg.sender) != proxy && Proxy(msg.sender) != integrationProxy && messageSender != msg.sender) {\\n            messageSender = msg.sender;\\n        }\\n        require(messageSender == owner, \\\"Owner only function\\\");\\n    }\\n\\n    event ProxyUpdated(address proxyAddress);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/proxy\\ncontract Proxy is Owned {\\n    Proxyable public target;\\n\\n    constructor(address _owner) public Owned(_owner) {}\\n\\n    function setTarget(Proxyable _target) external onlyOwner {\\n        target = _target;\\n        emit TargetUpdated(_target);\\n    }\\n\\n    function _emit(\\n        bytes calldata callData,\\n        uint numTopics,\\n        bytes32 topic1,\\n        bytes32 topic2,\\n        bytes32 topic3,\\n        bytes32 topic4\\n    ) external onlyTarget {\\n        uint size = callData.length;\\n        bytes memory _callData = callData;\\n\\n        assembly {\\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\\n             * This means moving call_data across 32 bytes guarantees we correctly access\\n             * the data itself. */\\n            switch numTopics\\n                case 0 {\\n                    log0(add(_callData, 32), size)\\n                }\\n                case 1 {\\n                    log1(add(_callData, 32), size, topic1)\\n                }\\n                case 2 {\\n                    log2(add(_callData, 32), size, topic1, topic2)\\n                }\\n                case 3 {\\n                    log3(add(_callData, 32), size, topic1, topic2, topic3)\\n                }\\n                case 4 {\\n                    log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\\n                }\\n        }\\n    }\\n\\n    // solhint-disable no-complex-fallback\\n    function() external payable {\\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\\n        target.setMessageSender(msg.sender);\\n\\n        assembly {\\n            let free_ptr := mload(0x40)\\n            calldatacopy(free_ptr, 0, calldatasize)\\n\\n            /* We must explicitly forward ether to the underlying contract as well. */\\n            let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\\n            returndatacopy(free_ptr, 0, returndatasize)\\n\\n            if iszero(result) {\\n                revert(free_ptr, returndatasize)\\n            }\\n            return(free_ptr, returndatasize)\\n        }\\n    }\\n\\n    modifier onlyTarget {\\n        require(Proxyable(msg.sender) == target, \\\"Must be proxy target\\\");\\n        _;\\n    }\\n\\n    event TargetUpdated(Proxyable newTarget);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/ierc20\\ninterface IERC20 {\\n    // ERC20 Optional Views\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    // Views\\n    function totalSupply() external view returns (uint);\\n\\n    function balanceOf(address owner) external view returns (uint);\\n\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    // Mutative functions\\n    function transfer(address to, uint value) external returns (bool);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint value\\n    ) external returns (bool);\\n\\n    // Events\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/proxyerc20\\ncontract ProxyERC20 is Proxy, IERC20 {\\n    constructor(address _owner) public Proxy(_owner) {}\\n\\n    // ------------- ERC20 Details ------------- //\\n\\n    function name() public view returns (string memory) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).name();\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).symbol();\\n    }\\n\\n    function decimals() public view returns (uint8) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).decimals();\\n    }\\n\\n    // ------------- ERC20 Interface ------------- //\\n\\n    /**\\n     * @dev Total number of tokens in existence\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).totalSupply();\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address.\\n     * @param account The address to query the balance of.\\n     * @return An uint256 representing the amount owned by the passed address.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).balanceOf(account);\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param owner address The address which owns the funds.\\n     * @param spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).allowance(owner, spender);\\n    }\\n\\n    /**\\n     * @dev Transfer token for a specified address\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function transfer(address to, uint256 value) public returns (bool) {\\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\\n        target.setMessageSender(msg.sender);\\n\\n        // Forward the ERC20 call to the target contract\\n        IERC20(address(target)).transfer(to, value);\\n\\n        // Event emitting will occur via Synthetix.Proxy._emit()\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\\n        target.setMessageSender(msg.sender);\\n\\n        // Forward the ERC20 call to the target contract\\n        IERC20(address(target)).approve(spender, value);\\n\\n        // Event emitting will occur via Synthetix.Proxy._emit()\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one address to another\\n     * @param from address The address which you want to send tokens from\\n     * @param to address The address which you want to transfer to\\n     * @param value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) public returns (bool) {\\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\\n        target.setMessageSender(msg.sender);\\n\\n        // Forward the ERC20 call to the target contract\\n        IERC20(address(target)).transferFrom(from, to, value);\\n\\n        // Event emitting will occur via Synthetix.Proxy._emit()\\n        return true;\\n    }\\n}\\n\\n\\n// Inheritance\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/state\\ncontract State is Owned {\\n    // the address of the contract that can modify variables\\n    // this can only be changed by the owner of this contract\\n    address public associatedContract;\\n\\n    constructor(address _associatedContract) internal {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), \\\"Owner must be set\\\");\\n\\n        associatedContract = _associatedContract;\\n        emit AssociatedContractUpdated(_associatedContract);\\n    }\\n\\n    /* ========== SETTERS ========== */\\n\\n    // Change the associated contract to a new address\\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\\n        associatedContract = _associatedContract;\\n        emit AssociatedContractUpdated(_associatedContract);\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyAssociatedContract {\\n        require(msg.sender == associatedContract, \\\"Only the associated contract can perform this action\\\");\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event AssociatedContractUpdated(address associatedContract);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangestate\\ninterface IExchangeState {\\n    // Views\\n    struct ExchangeEntry {\\n        bytes32 src;\\n        uint amount;\\n        bytes32 dest;\\n        uint amountReceived;\\n        uint exchangeFeeRate;\\n        uint timestamp;\\n        uint roundIdForSrc;\\n        uint roundIdForDest;\\n    }\\n\\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint);\\n\\n    function getEntryAt(\\n        address account,\\n        bytes32 currencyKey,\\n        uint index\\n    )\\n        external\\n        view\\n        returns (\\n            bytes32 src,\\n            uint amount,\\n            bytes32 dest,\\n            uint amountReceived,\\n            uint exchangeFeeRate,\\n            uint timestamp,\\n            uint roundIdForSrc,\\n            uint roundIdForDest\\n        );\\n\\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint);\\n\\n    // Mutative functions\\n    function appendExchangeEntry(\\n        address account,\\n        bytes32 src,\\n        uint amount,\\n        bytes32 dest,\\n        uint amountReceived,\\n        uint exchangeFeeRate,\\n        uint timestamp,\\n        uint roundIdForSrc,\\n        uint roundIdForDest\\n    ) external;\\n\\n    function removeEntries(address account, bytes32 currencyKey) external;\\n}\\n\\n\\n// Inheritance\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/exchangestate\\ncontract ExchangeState is Owned, State, IExchangeState {\\n    mapping(address => mapping(bytes32 => IExchangeState.ExchangeEntry[])) public exchanges;\\n\\n    uint public maxEntriesInQueue = 12;\\n\\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\\n\\n    /* ========== SETTERS ========== */\\n\\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\\n        maxEntriesInQueue = _maxEntriesInQueue;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function appendExchangeEntry(\\n        address account,\\n        bytes32 src,\\n        uint amount,\\n        bytes32 dest,\\n        uint amountReceived,\\n        uint exchangeFeeRate,\\n        uint timestamp,\\n        uint roundIdForSrc,\\n        uint roundIdForDest\\n    ) external onlyAssociatedContract {\\n        require(exchanges[account][dest].length < maxEntriesInQueue, \\\"Max queue length reached\\\");\\n\\n        exchanges[account][dest].push(\\n            ExchangeEntry({\\n                src: src,\\n                amount: amount,\\n                dest: dest,\\n                amountReceived: amountReceived,\\n                exchangeFeeRate: exchangeFeeRate,\\n                timestamp: timestamp,\\n                roundIdForSrc: roundIdForSrc,\\n                roundIdForDest: roundIdForDest\\n            })\\n        );\\n    }\\n\\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\\n        delete exchanges[account][currencyKey];\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\\n        return exchanges[account][currencyKey].length;\\n    }\\n\\n    function getEntryAt(\\n        address account,\\n        bytes32 currencyKey,\\n        uint index\\n    )\\n        external\\n        view\\n        returns (\\n            bytes32 src,\\n            uint amount,\\n            bytes32 dest,\\n            uint amountReceived,\\n            uint exchangeFeeRate,\\n            uint timestamp,\\n            uint roundIdForSrc,\\n            uint roundIdForDest\\n        )\\n    {\\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\\n        return (\\n            entry.src,\\n            entry.amount,\\n            entry.dest,\\n            entry.amountReceived,\\n            entry.exchangeFeeRate,\\n            entry.timestamp,\\n            entry.roundIdForSrc,\\n            entry.roundIdForDest\\n        );\\n    }\\n\\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\\n        uint timestamp = 0;\\n        for (uint i = 0; i < userEntries.length; i++) {\\n            if (userEntries[i].timestamp > timestamp) {\\n                timestamp = userEntries[i].timestamp;\\n            }\\n        }\\n        return timestamp;\\n    }\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isystemstatus\\ninterface ISystemStatus {\\n    struct Status {\\n        bool canSuspend;\\n        bool canResume;\\n    }\\n\\n    struct Suspension {\\n        bool suspended;\\n        // reason is an integer code,\\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\\n        uint248 reason;\\n    }\\n\\n    // Views\\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\\n\\n    function requireSystemActive() external view;\\n\\n    function requireIssuanceActive() external view;\\n\\n    function requireExchangeActive() external view;\\n\\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\\n\\n    function requireSynthActive(bytes32 currencyKey) external view;\\n\\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\\n\\n    function systemSuspension() external view returns (bool suspended, uint248 reason);\\n\\n    function issuanceSuspension() external view returns (bool suspended, uint248 reason);\\n\\n    function exchangeSuspension() external view returns (bool suspended, uint248 reason);\\n\\n    function synthExchangeSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\\n\\n    function synthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\\n\\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\\n        external\\n        view\\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons);\\n\\n    function getSynthSuspensions(bytes32[] calldata synths)\\n        external\\n        view\\n        returns (bool[] memory suspensions, uint256[] memory reasons);\\n\\n    // Restricted functions\\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external;\\n\\n    function updateAccessControl(\\n        bytes32 section,\\n        address account,\\n        bool canSuspend,\\n        bool canResume\\n    ) external;\\n}\\n\\n\\n// Inheritance\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/systemstatus\\ncontract SystemStatus is Owned, ISystemStatus {\\n    mapping(bytes32 => mapping(address => Status)) public accessControl;\\n\\n    uint248 public constant SUSPENSION_REASON_UPGRADE = 1;\\n\\n    bytes32 public constant SECTION_SYSTEM = \\\"System\\\";\\n    bytes32 public constant SECTION_ISSUANCE = \\\"Issuance\\\";\\n    bytes32 public constant SECTION_EXCHANGE = \\\"Exchange\\\";\\n    bytes32 public constant SECTION_SYNTH_EXCHANGE = \\\"SynthExchange\\\";\\n    bytes32 public constant SECTION_SYNTH = \\\"Synth\\\";\\n\\n    Suspension public systemSuspension;\\n\\n    Suspension public issuanceSuspension;\\n\\n    Suspension public exchangeSuspension;\\n\\n    mapping(bytes32 => Suspension) public synthExchangeSuspension;\\n\\n    mapping(bytes32 => Suspension) public synthSuspension;\\n\\n    constructor(address _owner) public Owned(_owner) {}\\n\\n    /* ========== VIEWS ========== */\\n    function requireSystemActive() external view {\\n        _internalRequireSystemActive();\\n    }\\n\\n    function requireIssuanceActive() external view {\\n        // Issuance requires the system be active\\n        _internalRequireSystemActive();\\n\\n        // and issuance itself of course\\n        _internalRequireIssuanceActive();\\n    }\\n\\n    function requireExchangeActive() external view {\\n        // Exchanging requires the system be active\\n        _internalRequireSystemActive();\\n\\n        // and exchanging itself of course\\n        _internalRequireExchangeActive();\\n    }\\n\\n    function requireSynthExchangeActive(bytes32 currencyKey) external view {\\n        // Synth exchange and transfer requires the system be active\\n        _internalRequireSystemActive();\\n        _internalRequireSynthExchangeActive(currencyKey);\\n    }\\n\\n    function requireSynthActive(bytes32 currencyKey) external view {\\n        // Synth exchange and transfer requires the system be active\\n        _internalRequireSystemActive();\\n        _internalRequireSynthActive(currencyKey);\\n    }\\n\\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view {\\n        // Synth exchange and transfer requires the system be active\\n        _internalRequireSystemActive();\\n        _internalRequireSynthActive(sourceCurrencyKey);\\n        _internalRequireSynthActive(destinationCurrencyKey);\\n    }\\n\\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view {\\n        // Synth exchange and transfer requires the system be active\\n        _internalRequireSystemActive();\\n\\n        // and exchanging must be active\\n        _internalRequireExchangeActive();\\n\\n        // and the synth exchanging between the synths must be active\\n        _internalRequireSynthExchangeActive(sourceCurrencyKey);\\n        _internalRequireSynthExchangeActive(destinationCurrencyKey);\\n\\n        // and finally, the synths cannot be suspended\\n        _internalRequireSynthActive(sourceCurrencyKey);\\n        _internalRequireSynthActive(destinationCurrencyKey);\\n    }\\n\\n    function isSystemUpgrading() external view returns (bool) {\\n        return systemSuspension.suspended && systemSuspension.reason == SUSPENSION_REASON_UPGRADE;\\n    }\\n\\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\\n        external\\n        view\\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons)\\n    {\\n        exchangeSuspensions = new bool[](synths.length);\\n        reasons = new uint256[](synths.length);\\n\\n        for (uint i = 0; i < synths.length; i++) {\\n            exchangeSuspensions[i] = synthExchangeSuspension[synths[i]].suspended;\\n            reasons[i] = synthExchangeSuspension[synths[i]].reason;\\n        }\\n    }\\n\\n    function getSynthSuspensions(bytes32[] calldata synths)\\n        external\\n        view\\n        returns (bool[] memory suspensions, uint256[] memory reasons)\\n    {\\n        suspensions = new bool[](synths.length);\\n        reasons = new uint256[](synths.length);\\n\\n        for (uint i = 0; i < synths.length; i++) {\\n            suspensions[i] = synthSuspension[synths[i]].suspended;\\n            reasons[i] = synthSuspension[synths[i]].reason;\\n        }\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n    function updateAccessControl(\\n        bytes32 section,\\n        address account,\\n        bool canSuspend,\\n        bool canResume\\n    ) external onlyOwner {\\n        _internalUpdateAccessControl(section, account, canSuspend, canResume);\\n    }\\n\\n    function updateAccessControls(\\n        bytes32[] calldata sections,\\n        address[] calldata accounts,\\n        bool[] calldata canSuspends,\\n        bool[] calldata canResumes\\n    ) external onlyOwner {\\n        require(\\n            sections.length == accounts.length &&\\n                accounts.length == canSuspends.length &&\\n                canSuspends.length == canResumes.length,\\n            \\\"Input array lengths must match\\\"\\n        );\\n        for (uint i = 0; i < sections.length; i++) {\\n            _internalUpdateAccessControl(sections[i], accounts[i], canSuspends[i], canResumes[i]);\\n        }\\n    }\\n\\n    function suspendSystem(uint256 reason) external {\\n        _requireAccessToSuspend(SECTION_SYSTEM);\\n        systemSuspension.suspended = true;\\n        systemSuspension.reason = uint248(reason);\\n        emit SystemSuspended(systemSuspension.reason);\\n    }\\n\\n    function resumeSystem() external {\\n        _requireAccessToResume(SECTION_SYSTEM);\\n        systemSuspension.suspended = false;\\n        emit SystemResumed(uint256(systemSuspension.reason));\\n        systemSuspension.reason = 0;\\n    }\\n\\n    function suspendIssuance(uint256 reason) external {\\n        _requireAccessToSuspend(SECTION_ISSUANCE);\\n        issuanceSuspension.suspended = true;\\n        issuanceSuspension.reason = uint248(reason);\\n        emit IssuanceSuspended(reason);\\n    }\\n\\n    function resumeIssuance() external {\\n        _requireAccessToResume(SECTION_ISSUANCE);\\n        issuanceSuspension.suspended = false;\\n        emit IssuanceResumed(uint256(issuanceSuspension.reason));\\n        issuanceSuspension.reason = 0;\\n    }\\n\\n    function suspendExchange(uint256 reason) external {\\n        _requireAccessToSuspend(SECTION_EXCHANGE);\\n        exchangeSuspension.suspended = true;\\n        exchangeSuspension.reason = uint248(reason);\\n        emit ExchangeSuspended(reason);\\n    }\\n\\n    function resumeExchange() external {\\n        _requireAccessToResume(SECTION_EXCHANGE);\\n        exchangeSuspension.suspended = false;\\n        emit ExchangeResumed(uint256(exchangeSuspension.reason));\\n        exchangeSuspension.reason = 0;\\n    }\\n\\n    function suspendSynthExchange(bytes32 currencyKey, uint256 reason) external {\\n        bytes32[] memory currencyKeys = new bytes32[](1);\\n        currencyKeys[0] = currencyKey;\\n        _internalSuspendSynthExchange(currencyKeys, reason);\\n    }\\n\\n    function suspendSynthsExchange(bytes32[] calldata currencyKeys, uint256 reason) external {\\n        _internalSuspendSynthExchange(currencyKeys, reason);\\n    }\\n\\n    function resumeSynthExchange(bytes32 currencyKey) external {\\n        bytes32[] memory currencyKeys = new bytes32[](1);\\n        currencyKeys[0] = currencyKey;\\n        _internalResumeSynthsExchange(currencyKeys);\\n    }\\n\\n    function resumeSynthsExchange(bytes32[] calldata currencyKeys) external {\\n        _internalResumeSynthsExchange(currencyKeys);\\n    }\\n\\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external {\\n        bytes32[] memory currencyKeys = new bytes32[](1);\\n        currencyKeys[0] = currencyKey;\\n        _internalSuspendSynths(currencyKeys, reason);\\n    }\\n\\n    function suspendSynths(bytes32[] calldata currencyKeys, uint256 reason) external {\\n        _internalSuspendSynths(currencyKeys, reason);\\n    }\\n\\n    function resumeSynth(bytes32 currencyKey) external {\\n        bytes32[] memory currencyKeys = new bytes32[](1);\\n        currencyKeys[0] = currencyKey;\\n        _internalResumeSynths(currencyKeys);\\n    }\\n\\n    function resumeSynths(bytes32[] calldata currencyKeys) external {\\n        _internalResumeSynths(currencyKeys);\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    function _requireAccessToSuspend(bytes32 section) internal view {\\n        require(accessControl[section][msg.sender].canSuspend, \\\"Restricted to access control list\\\");\\n    }\\n\\n    function _requireAccessToResume(bytes32 section) internal view {\\n        require(accessControl[section][msg.sender].canResume, \\\"Restricted to access control list\\\");\\n    }\\n\\n    function _internalRequireSystemActive() internal view {\\n        require(\\n            !systemSuspension.suspended,\\n            systemSuspension.reason == SUSPENSION_REASON_UPGRADE\\n                ? \\\"Synthetix is suspended, upgrade in progress... please stand by\\\"\\n                : \\\"Synthetix is suspended. Operation prohibited\\\"\\n        );\\n    }\\n\\n    function _internalRequireIssuanceActive() internal view {\\n        require(!issuanceSuspension.suspended, \\\"Issuance is suspended. Operation prohibited\\\");\\n    }\\n\\n    function _internalRequireExchangeActive() internal view {\\n        require(!exchangeSuspension.suspended, \\\"Exchange is suspended. Operation prohibited\\\");\\n    }\\n\\n    function _internalRequireSynthExchangeActive(bytes32 currencyKey) internal view {\\n        require(!synthExchangeSuspension[currencyKey].suspended, \\\"Synth exchange suspended. Operation prohibited\\\");\\n    }\\n\\n    function _internalRequireSynthActive(bytes32 currencyKey) internal view {\\n        require(!synthSuspension[currencyKey].suspended, \\\"Synth is suspended. Operation prohibited\\\");\\n    }\\n\\n    function _internalSuspendSynths(bytes32[] memory currencyKeys, uint256 reason) internal {\\n        _requireAccessToSuspend(SECTION_SYNTH);\\n        for (uint i = 0; i < currencyKeys.length; i++) {\\n            bytes32 currencyKey = currencyKeys[i];\\n            synthSuspension[currencyKey].suspended = true;\\n            synthSuspension[currencyKey].reason = uint248(reason);\\n            emit SynthSuspended(currencyKey, reason);\\n        }\\n    }\\n\\n    function _internalResumeSynths(bytes32[] memory currencyKeys) internal {\\n        _requireAccessToResume(SECTION_SYNTH);\\n        for (uint i = 0; i < currencyKeys.length; i++) {\\n            bytes32 currencyKey = currencyKeys[i];\\n            emit SynthResumed(currencyKey, uint256(synthSuspension[currencyKey].reason));\\n            delete synthSuspension[currencyKey];\\n        }\\n    }\\n\\n    function _internalSuspendSynthExchange(bytes32[] memory currencyKeys, uint256 reason) internal {\\n        _requireAccessToSuspend(SECTION_SYNTH_EXCHANGE);\\n        for (uint i = 0; i < currencyKeys.length; i++) {\\n            bytes32 currencyKey = currencyKeys[i];\\n            synthExchangeSuspension[currencyKey].suspended = true;\\n            synthExchangeSuspension[currencyKey].reason = uint248(reason);\\n            emit SynthExchangeSuspended(currencyKey, reason);\\n        }\\n    }\\n\\n    function _internalResumeSynthsExchange(bytes32[] memory currencyKeys) internal {\\n        _requireAccessToResume(SECTION_SYNTH_EXCHANGE);\\n        for (uint i = 0; i < currencyKeys.length; i++) {\\n            bytes32 currencyKey = currencyKeys[i];\\n            emit SynthExchangeResumed(currencyKey, uint256(synthExchangeSuspension[currencyKey].reason));\\n            delete synthExchangeSuspension[currencyKey];\\n        }\\n    }\\n\\n    function _internalUpdateAccessControl(\\n        bytes32 section,\\n        address account,\\n        bool canSuspend,\\n        bool canResume\\n    ) internal {\\n        require(\\n            section == SECTION_SYSTEM ||\\n                section == SECTION_ISSUANCE ||\\n                section == SECTION_EXCHANGE ||\\n                section == SECTION_SYNTH_EXCHANGE ||\\n                section == SECTION_SYNTH,\\n            \\\"Invalid section supplied\\\"\\n        );\\n        accessControl[section][account].canSuspend = canSuspend;\\n        accessControl[section][account].canResume = canResume;\\n        emit AccessControlUpdated(section, account, canSuspend, canResume);\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event SystemSuspended(uint256 reason);\\n    event SystemResumed(uint256 reason);\\n\\n    event IssuanceSuspended(uint256 reason);\\n    event IssuanceResumed(uint256 reason);\\n\\n    event ExchangeSuspended(uint256 reason);\\n    event ExchangeResumed(uint256 reason);\\n\\n    event SynthExchangeSuspended(bytes32 currencyKey, uint256 reason);\\n    event SynthExchangeResumed(bytes32 currencyKey, uint256 reason);\\n\\n    event SynthSuspended(bytes32 currencyKey, uint256 reason);\\n    event SynthResumed(bytes32 currencyKey, uint256 reason);\\n\\n    event AccessControlUpdated(bytes32 indexed section, address indexed account, bool canSuspend, bool canResume);\\n}\\n\\n\\ncontract LegacyOwned {\\n    address public owner;\\n    address public nominatedOwner;\\n\\n    constructor(address _owner) public {\\n        owner = _owner;\\n    }\\n\\n    function nominateOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOwner);\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n}\\n\\n\\ncontract LegacyTokenState is LegacyOwned {\\n    // the address of the contract that can modify balances and allowances\\n    // this can only be changed by the owner of this contract\\n    address public associatedContract;\\n\\n    // ERC20 fields.\\n    mapping(address => uint) public balanceOf;\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    constructor(address _owner, address _associatedContract) public LegacyOwned(_owner) {\\n        associatedContract = _associatedContract;\\n        emit AssociatedContractUpdated(_associatedContract);\\n    }\\n\\n    /* ========== SETTERS ========== */\\n\\n    // Change the associated contract to a new address\\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\\n        associatedContract = _associatedContract;\\n        emit AssociatedContractUpdated(_associatedContract);\\n    }\\n\\n    function setAllowance(\\n        address tokenOwner,\\n        address spender,\\n        uint value\\n    ) external onlyAssociatedContract {\\n        allowance[tokenOwner][spender] = value;\\n    }\\n\\n    function setBalanceOf(address account, uint value) external onlyAssociatedContract {\\n        balanceOf[account] = value;\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyAssociatedContract {\\n        require(msg.sender == associatedContract);\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event AssociatedContractUpdated(address _associatedContract);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/irewardescrow\\ninterface IRewardEscrow {\\n    // Views\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function numVestingEntries(address account) external view returns (uint);\\n\\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\\n\\n    function totalVestedAccountBalance(address account) external view returns (uint);\\n\\n    function getVestingScheduleEntry(address account, uint index) external view returns (uint[2] memory);\\n\\n    function getNextVestingIndex(address account) external view returns (uint);\\n\\n    // Mutative functions\\n    function appendVestingEntry(address account, uint quantity) external;\\n\\n    function vest() external;\\n}\\n\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\\n\\n// Libraries\\n\\n\\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\\nlibrary SafeDecimalMath {\\n    using SafeMath for uint;\\n\\n    /* Number of decimal places in the representations. */\\n    uint8 public constant decimals = 18;\\n    uint8 public constant highPrecisionDecimals = 27;\\n\\n    /* The number representing 1.0. */\\n    uint public constant UNIT = 10**uint(decimals);\\n\\n    /* The number representing 1.0 for higher fidelity numbers. */\\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\\n\\n    /**\\n     * @return Provides an interface to UNIT.\\n     */\\n    function unit() external pure returns (uint) {\\n        return UNIT;\\n    }\\n\\n    /**\\n     * @return Provides an interface to PRECISE_UNIT.\\n     */\\n    function preciseUnit() external pure returns (uint) {\\n        return PRECISE_UNIT;\\n    }\\n\\n    /**\\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\\n     * decimals.\\n     *\\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\\n     * so that product must be less than 2**256. As this is an integer division,\\n     * the internal division always rounds down. This helps save on gas. Rounding\\n     * is more expensive on gas.\\n     */\\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        return x.mul(y) / UNIT;\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of the specified precision unit.\\n     *\\n     * @dev The operands should be in the form of a the specified unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function _multiplyDecimalRound(\\n        uint x,\\n        uint y,\\n        uint precisionUnit\\n    ) private pure returns (uint) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\\n\\n        if (quotientTimesTen % 10 >= 5) {\\n            quotientTimesTen += 10;\\n        }\\n\\n        return quotientTimesTen / 10;\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of a precise unit.\\n     *\\n     * @dev The operands should be in the precise unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of a standard unit.\\n     *\\n     * @dev The operands should be in the standard unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\\n        return _multiplyDecimalRound(x, y, UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is a high\\n     * precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the standard precision unit\\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\\n     * this is an integer division, the result is always rounded down.\\n     * This helps save on gas. Rounding is more expensive on gas.\\n     */\\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\\n        /* Reintroduce the UNIT factor that will be divided out by y. */\\n        return x.mul(UNIT).div(y);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * decimal in the precision unit specified in the parameter.\\n     *\\n     * @dev y is divided after the product of x and the specified precision unit\\n     * is evaluated, so the product of x and the specified precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function _divideDecimalRound(\\n        uint x,\\n        uint y,\\n        uint precisionUnit\\n    ) private pure returns (uint) {\\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\\n\\n        if (resultTimesTen % 10 >= 5) {\\n            resultTimesTen += 10;\\n        }\\n\\n        return resultTimesTen / 10;\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * standard precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the standard precision unit\\n     * is evaluated, so the product of x and the standard precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\\n        return _divideDecimalRound(x, y, UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * high precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the high precision unit\\n     * is evaluated, so the product of x and the high precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\\n    }\\n\\n    /**\\n     * @dev Convert a standard decimal representation to a high precision one.\\n     */\\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\\n    }\\n\\n    /**\\n     * @dev Convert a high precision decimal to a standard decimal representation.\\n     */\\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\\n\\n        if (quotientTimesTen % 10 >= 5) {\\n            quotientTimesTen += 10;\\n        }\\n\\n        return quotientTimesTen / 10;\\n    }\\n\\n    // Computes `a - b`, setting the value to 0 if b > a.\\n    function floorsub(uint a, uint b) internal pure returns (uint) {\\n        return b >= a ? 0 : a - b;\\n    }\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/ifeepool\\ninterface IFeePool {\\n    // Views\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function FEE_ADDRESS() external view returns (address);\\n\\n    function feesAvailable(address account) external view returns (uint, uint);\\n\\n    function feePeriodDuration() external view returns (uint);\\n\\n    function isFeesClaimable(address account) external view returns (bool);\\n\\n    function targetThreshold() external view returns (uint);\\n\\n    function totalFeesAvailable() external view returns (uint);\\n\\n    function totalRewardsAvailable() external view returns (uint);\\n\\n    // Mutative Functions\\n    function claimFees() external returns (bool);\\n\\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\\n\\n    function closeCurrentFeePeriod() external;\\n\\n    // Restricted: used internally to Synthetix\\n    function appendAccountIssuanceRecord(\\n        address account,\\n        uint lockedAmount,\\n        uint debtEntryIndex\\n    ) external;\\n\\n    function recordFeePaid(uint sUSDAmount) external;\\n\\n    function setRewardsToDistribute(uint amount) external;\\n}\\n\\n\\ninterface IVirtualSynth {\\n    // Views\\n    function balanceOfUnderlying(address account) external view returns (uint);\\n\\n    function rate() external view returns (uint);\\n\\n    function readyToSettle() external view returns (bool);\\n\\n    function secsLeftInWaitingPeriod() external view returns (uint);\\n\\n    function settled() external view returns (bool);\\n\\n    function synth() external view returns (ISynth);\\n\\n    // Mutative functions\\n    function settle(address account) external;\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetix\\ninterface ISynthetix {\\n    // Views\\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\\n\\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\\n\\n    function availableSynthCount() external view returns (uint);\\n\\n    function availableSynths(uint index) external view returns (ISynth);\\n\\n    function collateral(address account) external view returns (uint);\\n\\n    function collateralisationRatio(address issuer) external view returns (uint);\\n\\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\\n\\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\\n\\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\\n\\n    function remainingIssuableSynths(address issuer)\\n        external\\n        view\\n        returns (\\n            uint maxIssuable,\\n            uint alreadyIssued,\\n            uint totalSystemDebt\\n        );\\n\\n    function synths(bytes32 currencyKey) external view returns (ISynth);\\n\\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\\n\\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);\\n\\n    function totalIssuedSynthsExcludeEtherCollateral(bytes32 currencyKey) external view returns (uint);\\n\\n    function transferableSynthetix(address account) external view returns (uint transferable);\\n\\n    // Mutative Functions\\n    function burnSynths(uint amount) external;\\n\\n    function burnSynthsOnBehalf(address burnForAddress, uint amount) external;\\n\\n    function burnSynthsToTarget() external;\\n\\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\\n\\n    function exchange(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeOnBehalf(\\n        address exchangeForAddress,\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeWithTracking(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        address rewardAddress,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeWithTrackingForInitiator(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        address rewardAddress,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeOnBehalfWithTracking(\\n        address exchangeForAddress,\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        address rewardAddress,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeWithVirtual(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\\n\\n    function issueMaxSynths() external;\\n\\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\\n\\n    function issueSynths(uint amount) external;\\n\\n    function issueSynthsOnBehalf(address issueForAddress, uint amount) external;\\n\\n    function mint() external returns (bool);\\n\\n    function settle(bytes32 currencyKey)\\n        external\\n        returns (\\n            uint reclaimed,\\n            uint refunded,\\n            uint numEntries\\n        );\\n\\n    // Liquidations\\n    function liquidateDelinquentAccount(address account, uint susdAmount) external returns (bool);\\n\\n    // Restricted Functions\\n\\n    function mintSecondary(address account, uint amount) external;\\n\\n    function mintSecondaryRewards(uint amount) external;\\n\\n    function burnSecondary(address account, uint amount) external;\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Libraries\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/rewardescrow\\ncontract RewardEscrow is Owned, IRewardEscrow {\\n    using SafeMath for uint;\\n\\n    /* The corresponding Synthetix contract. */\\n    ISynthetix public synthetix;\\n\\n    IFeePool public feePool;\\n\\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\\n     * These are the times at which each given quantity of SNX vests. */\\n    mapping(address => uint[2][]) public vestingSchedules;\\n\\n    /* An account's total escrowed synthetix balance to save recomputing this for fee extraction purposes. */\\n    mapping(address => uint) public totalEscrowedAccountBalance;\\n\\n    /* An account's total vested reward synthetix. */\\n    mapping(address => uint) public totalVestedAccountBalance;\\n\\n    /* The total remaining escrowed balance, for verifying the actual synthetix balance of this contract against. */\\n    uint public totalEscrowedBalance;\\n\\n    uint internal constant TIME_INDEX = 0;\\n    uint internal constant QUANTITY_INDEX = 1;\\n\\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules.\\n     * There are 5 years of the supply schedule */\\n    uint public constant MAX_VESTING_ENTRIES = 52 * 5;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        address _owner,\\n        ISynthetix _synthetix,\\n        IFeePool _feePool\\n    ) public Owned(_owner) {\\n        synthetix = _synthetix;\\n        feePool = _feePool;\\n    }\\n\\n    /* ========== SETTERS ========== */\\n\\n    /**\\n     * @notice set the synthetix contract address as we need to transfer SNX when the user vests\\n     */\\n    function setSynthetix(ISynthetix _synthetix) external onlyOwner {\\n        synthetix = _synthetix;\\n        emit SynthetixUpdated(address(_synthetix));\\n    }\\n\\n    /**\\n     * @notice set the FeePool contract as it is the only authority to be able to call\\n     * appendVestingEntry with the onlyFeePool modifer\\n     */\\n    function setFeePool(IFeePool _feePool) external onlyOwner {\\n        feePool = _feePool;\\n        emit FeePoolUpdated(address(_feePool));\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\\n     */\\n    function balanceOf(address account) public view returns (uint) {\\n        return totalEscrowedAccountBalance[account];\\n    }\\n\\n    function _numVestingEntries(address account) internal view returns (uint) {\\n        return vestingSchedules[account].length;\\n    }\\n\\n    /**\\n     * @notice The number of vesting dates in an account's schedule.\\n     */\\n    function numVestingEntries(address account) external view returns (uint) {\\n        return vestingSchedules[account].length;\\n    }\\n\\n    /**\\n     * @notice Get a particular schedule entry for an account.\\n     * @return A pair of uints: (timestamp, synthetix quantity).\\n     */\\n    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {\\n        return vestingSchedules[account][index];\\n    }\\n\\n    /**\\n     * @notice Get the time at which a given schedule entry will vest.\\n     */\\n    function getVestingTime(address account, uint index) public view returns (uint) {\\n        return getVestingScheduleEntry(account, index)[TIME_INDEX];\\n    }\\n\\n    /**\\n     * @notice Get the quantity of SNX associated with a given schedule entry.\\n     */\\n    function getVestingQuantity(address account, uint index) public view returns (uint) {\\n        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];\\n    }\\n\\n    /**\\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\\n     */\\n    function getNextVestingIndex(address account) public view returns (uint) {\\n        uint len = _numVestingEntries(account);\\n        for (uint i = 0; i < len; i++) {\\n            if (getVestingTime(account, i) != 0) {\\n                return i;\\n            }\\n        }\\n        return len;\\n    }\\n\\n    /**\\n     * @notice Obtain the next schedule entry that will vest for a given user.\\n     * @return A pair of uints: (timestamp, synthetix quantity). */\\n    function getNextVestingEntry(address account) public view returns (uint[2] memory) {\\n        uint index = getNextVestingIndex(account);\\n        if (index == _numVestingEntries(account)) {\\n            return [uint(0), 0];\\n        }\\n        return getVestingScheduleEntry(account, index);\\n    }\\n\\n    /**\\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\\n     */\\n    function getNextVestingTime(address account) external view returns (uint) {\\n        return getNextVestingEntry(account)[TIME_INDEX];\\n    }\\n\\n    /**\\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\\n     */\\n    function getNextVestingQuantity(address account) external view returns (uint) {\\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\\n    }\\n\\n    /**\\n     * @notice return the full vesting schedule entries vest for a given user.\\n     * @dev For DApps to display the vesting schedule for the\\n     * inflationary supply over 5 years. Solidity cant return variable length arrays\\n     * so this is returning pairs of data. Vesting Time at [0] and quantity at [1] and so on\\n     */\\n    function checkAccountSchedule(address account) public view returns (uint[520] memory) {\\n        uint[520] memory _result;\\n        uint schedules = _numVestingEntries(account);\\n        for (uint i = 0; i < schedules; i++) {\\n            uint[2] memory pair = getVestingScheduleEntry(account, i);\\n            _result[i * 2] = pair[0];\\n            _result[i * 2 + 1] = pair[1];\\n        }\\n        return _result;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function _appendVestingEntry(address account, uint quantity) internal {\\n        /* No empty or already-passed vesting entries allowed. */\\n        require(quantity != 0, \\\"Quantity cannot be zero\\\");\\n\\n        /* There must be enough balance in the contract to provide for the vesting entry. */\\n        totalEscrowedBalance = totalEscrowedBalance.add(quantity);\\n        require(\\n            totalEscrowedBalance <= IERC20(address(synthetix)).balanceOf(address(this)),\\n            \\\"Must be enough balance in the contract to provide for the vesting entry\\\"\\n        );\\n\\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\\n        uint scheduleLength = vestingSchedules[account].length;\\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \\\"Vesting schedule is too long\\\");\\n\\n        /* Escrow the tokens for 1 year. */\\n        uint time = now + 52 weeks;\\n\\n        if (scheduleLength == 0) {\\n            totalEscrowedAccountBalance[account] = quantity;\\n        } else {\\n            /* Disallow adding new vested SNX earlier than the last one.\\n             * Since entries are only appended, this means that no vesting date can be repeated. */\\n            require(\\n                getVestingTime(account, scheduleLength - 1) < time,\\n                \\\"Cannot add new vested entries earlier than the last one\\\"\\n            );\\n            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(quantity);\\n        }\\n\\n        vestingSchedules[account].push([time, quantity]);\\n\\n        emit VestingEntryCreated(account, now, quantity);\\n    }\\n\\n    /**\\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\\n     * @dev A call to this should accompany a previous successful call to synthetix.transfer(rewardEscrow, amount),\\n     * to ensure that when the funds are withdrawn, there is enough balance.\\n     * Note; although this function could technically be used to produce unbounded\\n     * arrays, it's only withinn the 4 year period of the weekly inflation schedule.\\n     * @param account The account to append a new vesting entry to.\\n     * @param quantity The quantity of SNX that will be escrowed.\\n     */\\n    function appendVestingEntry(address account, uint quantity) external onlyFeePool {\\n        _appendVestingEntry(account, quantity);\\n    }\\n\\n    /**\\n     * @notice Allow a user to withdraw any SNX in their schedule that have vested.\\n     */\\n    function vest() external {\\n        uint numEntries = _numVestingEntries(msg.sender);\\n        uint total;\\n        for (uint i = 0; i < numEntries; i++) {\\n            uint time = getVestingTime(msg.sender, i);\\n            /* The list is sorted; when we reach the first future time, bail out. */\\n            if (time > now) {\\n                break;\\n            }\\n            uint qty = getVestingQuantity(msg.sender, i);\\n            if (qty > 0) {\\n                vestingSchedules[msg.sender][i] = [0, 0];\\n                total = total.add(qty);\\n            }\\n        }\\n\\n        if (total != 0) {\\n            totalEscrowedBalance = totalEscrowedBalance.sub(total);\\n            totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].sub(total);\\n            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].add(total);\\n            IERC20(address(synthetix)).transfer(msg.sender, total);\\n            emit Vested(msg.sender, now, total);\\n        }\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyFeePool() {\\n        bool isFeePool = msg.sender == address(feePool);\\n\\n        require(isFeePool, \\\"Only the FeePool contracts can perform this action\\\");\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event SynthetixUpdated(address newSynthetix);\\n\\n    event FeePoolUpdated(address newFeePool);\\n\\n    event Vested(address indexed beneficiary, uint time, uint value);\\n\\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/irewardsdistribution\\ninterface IRewardsDistribution {\\n    // Structs\\n    struct DistributionData {\\n        address destination;\\n        uint amount;\\n    }\\n\\n    // Views\\n    function authority() external view returns (address);\\n\\n    function distributions(uint index) external view returns (address destination, uint amount); // DistributionData\\n\\n    function distributionsLength() external view returns (uint);\\n\\n    // Mutative Functions\\n    function distributeRewards(uint amount) external returns (bool);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Libraires\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/rewardsdistribution\\ncontract RewardsDistribution is Owned, IRewardsDistribution {\\n    using SafeMath for uint;\\n    using SafeDecimalMath for uint;\\n\\n    /**\\n     * @notice Authorised address able to call distributeRewards\\n     */\\n    address public authority;\\n\\n    /**\\n     * @notice Address of the Synthetix ProxyERC20\\n     */\\n    address public synthetixProxy;\\n\\n    /**\\n     * @notice Address of the RewardEscrow contract\\n     */\\n    address public rewardEscrow;\\n\\n    /**\\n     * @notice Address of the FeePoolProxy\\n     */\\n    address public feePoolProxy;\\n\\n    /**\\n     * @notice An array of addresses and amounts to send\\n     */\\n    DistributionData[] public distributions;\\n\\n    /**\\n     * @dev _authority maybe the underlying synthetix contract.\\n     * Remember to set the authority on a synthetix upgrade\\n     */\\n    constructor(\\n        address _owner,\\n        address _authority,\\n        address _synthetixProxy,\\n        address _rewardEscrow,\\n        address _feePoolProxy\\n    ) public Owned(_owner) {\\n        authority = _authority;\\n        synthetixProxy = _synthetixProxy;\\n        rewardEscrow = _rewardEscrow;\\n        feePoolProxy = _feePoolProxy;\\n    }\\n\\n    // ========== EXTERNAL SETTERS ==========\\n\\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\\n        synthetixProxy = _synthetixProxy;\\n    }\\n\\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\\n        rewardEscrow = _rewardEscrow;\\n    }\\n\\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\\n        feePoolProxy = _feePoolProxy;\\n    }\\n\\n    /**\\n     * @notice Set the address of the contract authorised to call distributeRewards()\\n     * @param _authority Address of the authorised calling contract.\\n     */\\n    function setAuthority(address _authority) external onlyOwner {\\n        authority = _authority;\\n    }\\n\\n    // ========== EXTERNAL FUNCTIONS ==========\\n\\n    /**\\n     * @notice Adds a Rewards DistributionData struct to the distributions\\n     * array. Any entries here will be iterated and rewards distributed to\\n     * each address when tokens are sent to this contract and distributeRewards()\\n     * is called by the autority.\\n     * @param destination An address to send rewards tokens too\\n     * @param amount The amount of rewards tokens to send\\n     */\\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\\n        require(destination != address(0), \\\"Cant add a zero address\\\");\\n        require(amount != 0, \\\"Cant add a zero amount\\\");\\n\\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\\n        distributions.push(rewardsDistribution);\\n\\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Deletes a RewardDistribution from the distributions\\n     * so it will no longer be included in the call to distributeRewards()\\n     * @param index The index of the DistributionData to delete\\n     */\\n    function removeRewardDistribution(uint index) external onlyOwner {\\n        require(index <= distributions.length - 1, \\\"index out of bounds\\\");\\n\\n        // shift distributions indexes across\\n        for (uint i = index; i < distributions.length - 1; i++) {\\n            distributions[i] = distributions[i + 1];\\n        }\\n        distributions.length--;\\n\\n        // Since this function must shift all later entries down to fill the\\n        // gap from the one it removed, it could in principle consume an\\n        // unbounded amount of gas. However, the number of entries will\\n        // presumably always be very low.\\n    }\\n\\n    /**\\n     * @notice Edits a RewardDistribution in the distributions array.\\n     * @param index The index of the DistributionData to edit\\n     * @param destination The destination address. Send the same address to keep or different address to change it.\\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\\n     */\\n    function editRewardDistribution(\\n        uint index,\\n        address destination,\\n        uint amount\\n    ) external onlyOwner returns (bool) {\\n        require(index <= distributions.length - 1, \\\"index out of bounds\\\");\\n\\n        distributions[index].destination = destination;\\n        distributions[index].amount = amount;\\n\\n        return true;\\n    }\\n\\n    function distributeRewards(uint amount) external returns (bool) {\\n        require(amount > 0, \\\"Nothing to distribute\\\");\\n        require(msg.sender == authority, \\\"Caller is not authorised\\\");\\n        require(rewardEscrow != address(0), \\\"RewardEscrow is not set\\\");\\n        require(synthetixProxy != address(0), \\\"SynthetixProxy is not set\\\");\\n        require(feePoolProxy != address(0), \\\"FeePoolProxy is not set\\\");\\n        require(\\n            IERC20(synthetixProxy).balanceOf(address(this)) >= amount,\\n            \\\"RewardsDistribution contract does not have enough tokens to distribute\\\"\\n        );\\n\\n        uint remainder = amount;\\n\\n        // Iterate the array of distributions sending the configured amounts\\n        for (uint i = 0; i < distributions.length; i++) {\\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\\n                remainder = remainder.sub(distributions[i].amount);\\n\\n                // Transfer the SNX\\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\\n\\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\\n                bytes memory payload = abi.encodeWithSignature(\\\"notifyRewardAmount(uint256)\\\", distributions[i].amount);\\n\\n                // solhint-disable avoid-low-level-calls\\n                (bool success, ) = distributions[i].destination.call(payload);\\n\\n                if (!success) {\\n                    // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\\n                }\\n            }\\n        }\\n\\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\\n\\n        // Tell the FeePool how much it has to distribute to the stakers\\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\\n\\n        emit RewardsDistributed(amount);\\n        return true;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    /**\\n     * @notice Retrieve the length of the distributions array\\n     */\\n    function distributionsLength() external view returns (uint) {\\n        return distributions.length;\\n    }\\n\\n    /* ========== Events ========== */\\n\\n    event RewardDistributionAdded(uint index, address destination, uint amount);\\n    event RewardsDistributed(uint amount);\\n}\\n\\n\\ninterface ISynthetixNamedContract {\\n    // solhint-disable func-name-mixedcase\\n    function CONTRACT_NAME() external view returns (bytes32);\\n}\\n\\n// solhint-disable contract-name-camelcase\\ncontract Migration_Alnitak is BaseMigration {\\n    // https://etherscan.io/address/0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\\n    address public constant OWNER = 0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\\n\\n    // https://etherscan.io/address/0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83\\n    AddressResolver public constant addressresolver_i = AddressResolver(0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83);\\n    // https://etherscan.io/address/0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F\\n    ProxyERC20 public constant proxyerc20_i = ProxyERC20(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F);\\n    // https://etherscan.io/address/0xC011A72400E58ecD99Ee497CF89E3775d4bd732F\\n    Proxy public constant proxysynthetix_i = Proxy(0xC011A72400E58ecD99Ee497CF89E3775d4bd732F);\\n    // https://etherscan.io/address/0x545973f28950f50fc6c7F52AAb4Ad214A27C0564\\n    ExchangeState public constant exchangestate_i = ExchangeState(0x545973f28950f50fc6c7F52AAb4Ad214A27C0564);\\n    // https://etherscan.io/address/0x1c86B3CDF2a60Ae3a574f7f71d44E2C50BDdB87E\\n    SystemStatus public constant systemstatus_i = SystemStatus(0x1c86B3CDF2a60Ae3a574f7f71d44E2C50BDdB87E);\\n    // https://etherscan.io/address/0x5b1b5fEa1b99D83aD479dF0C222F0492385381dD\\n    LegacyTokenState public constant tokenstatesynthetix_i = LegacyTokenState(0x5b1b5fEa1b99D83aD479dF0C222F0492385381dD);\\n    // https://etherscan.io/address/0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F\\n    RewardEscrow public constant rewardescrow_i = RewardEscrow(0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F);\\n    // https://etherscan.io/address/0x29C295B046a73Cde593f21f63091B072d407e3F2\\n    RewardsDistribution public constant rewardsdistribution_i =\\n        RewardsDistribution(0x29C295B046a73Cde593f21f63091B072d407e3F2);\\n\\n    constructor() public BaseMigration(OWNER) {}\\n\\n    function contractsRequiringOwnership() external pure returns (address[] memory contracts) {\\n        contracts = new address[](8);\\n        contracts[0] = address(addressresolver_i);\\n        contracts[1] = address(proxyerc20_i);\\n        contracts[2] = address(proxysynthetix_i);\\n        contracts[3] = address(exchangestate_i);\\n        contracts[4] = address(systemstatus_i);\\n        contracts[5] = address(tokenstatesynthetix_i);\\n        contracts[6] = address(rewardescrow_i);\\n        contracts[7] = address(rewardsdistribution_i);\\n    }\\n\\n    function migrate(address currentOwner) external onlyDeployer {\\n        require(owner == currentOwner, \\\"Only the assigned owner can be re-assigned when complete\\\");\\n\\n        // NEW CONTRACTS DEPLOYED TO BE ADDED TO PROTOCOL\\n        // https://etherscan.io/address/0x43AE8037179a5746D618DA077A38DdeEa9640cBa\\n        address new_Synthetix_contract = 0x43AE8037179a5746D618DA077A38DdeEa9640cBa;\\n        // https://etherscan.io/address/0x5c296E9dCa708B5722257D775Cf92052f99Da63f\\n        address new_DebtCache_contract = 0x5c296E9dCa708B5722257D775Cf92052f99Da63f;\\n        // https://etherscan.io/address/0x613c773c7a1D85D2F1DCC051B0573D33470762Eb\\n        address new_Exchanger_contract = 0x613c773c7a1D85D2F1DCC051B0573D33470762Eb;\\n\\n        require(\\n            ISynthetixNamedContract(new_Synthetix_contract).CONTRACT_NAME() == \\\"Synthetix\\\",\\n            \\\"Invalid contract supplied for Synthetix\\\"\\n        );\\n        require(\\n            ISynthetixNamedContract(new_DebtCache_contract).CONTRACT_NAME() == \\\"DebtCache\\\",\\n            \\\"Invalid contract supplied for DebtCache\\\"\\n        );\\n        require(\\n            ISynthetixNamedContract(new_Exchanger_contract).CONTRACT_NAME() == \\\"Exchanger\\\",\\n            \\\"Invalid contract supplied for Exchanger\\\"\\n        );\\n\\n        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes\\n        addressresolver_i.acceptOwnership();\\n        proxyerc20_i.acceptOwnership();\\n        proxysynthetix_i.acceptOwnership();\\n        exchangestate_i.acceptOwnership();\\n        systemstatus_i.acceptOwnership();\\n        tokenstatesynthetix_i.acceptOwnership();\\n        rewardescrow_i.acceptOwnership();\\n        rewardsdistribution_i.acceptOwnership();\\n\\n        // MIGRATION\\n        // Import all new contracts into the address resolver;\\n        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](3);\\n        addressresolver_importAddresses_names_0_0[0] = bytes32(\\\"Synthetix\\\");\\n        addressresolver_importAddresses_names_0_0[1] = bytes32(\\\"DebtCache\\\");\\n        addressresolver_importAddresses_names_0_0[2] = bytes32(\\\"Exchanger\\\");\\n        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](3);\\n        addressresolver_importAddresses_destinations_0_1[0] = address(new_Synthetix_contract);\\n        addressresolver_importAddresses_destinations_0_1[1] = address(new_DebtCache_contract);\\n        addressresolver_importAddresses_destinations_0_1[2] = address(new_Exchanger_contract);\\n        addressresolver_i.importAddresses(\\n            addressresolver_importAddresses_names_0_0,\\n            addressresolver_importAddresses_destinations_0_1\\n        );\\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;\\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_1_0 = new MixinResolver[](20);\\n        addressresolver_rebuildCaches_destinations_1_0[0] = MixinResolver(0xDA4eF8520b1A57D7d63f1E249606D1A459698876);\\n        addressresolver_rebuildCaches_destinations_1_0[1] = MixinResolver(0xAD95C918af576c82Df740878C3E983CBD175daB6);\\n        addressresolver_rebuildCaches_destinations_1_0[2] = MixinResolver(0xcf9E60005C9aca983caf65d3669a24fDd0775fc0);\\n        addressresolver_rebuildCaches_destinations_1_0[3] = MixinResolver(new_Exchanger_contract);\\n        addressresolver_rebuildCaches_destinations_1_0[4] = MixinResolver(0xB774711F0BC1306ce892ef8C02D0476dCccB46B7);\\n        addressresolver_rebuildCaches_destinations_1_0[5] = MixinResolver(0x62922670313bf6b41C580143d1f6C173C5C20019);\\n        addressresolver_rebuildCaches_destinations_1_0[6] = MixinResolver(0xCd9D4988C0AE61887B075bA77f08cbFAd2b65068);\\n        addressresolver_rebuildCaches_destinations_1_0[7] = MixinResolver(0xd69b189020EF614796578AfE4d10378c5e7e1138);\\n        addressresolver_rebuildCaches_destinations_1_0[8] = MixinResolver(new_Synthetix_contract);\\n        addressresolver_rebuildCaches_destinations_1_0[9] = MixinResolver(new_DebtCache_contract);\\n        addressresolver_rebuildCaches_destinations_1_0[10] = MixinResolver(0x4D8dBD193d89b7B506BE5dC9Db75B91dA00D6a1d);\\n        addressresolver_rebuildCaches_destinations_1_0[11] = MixinResolver(0xC61b352fCc311Ae6B0301459A970150005e74b3E);\\n        addressresolver_rebuildCaches_destinations_1_0[12] = MixinResolver(0x388fD1A8a7d36e03eFA1ab100a1c5159a3A3d427);\\n        addressresolver_rebuildCaches_destinations_1_0[13] = MixinResolver(0x37B648a07476F4941D3D647f81118AFd55fa8a04);\\n        addressresolver_rebuildCaches_destinations_1_0[14] = MixinResolver(0xEF285D339c91aDf1dD7DE0aEAa6250805FD68258);\\n        addressresolver_rebuildCaches_destinations_1_0[15] = MixinResolver(0xcf9bB94b5d65589039607BA66e3DAC686d3eFf01);\\n        addressresolver_rebuildCaches_destinations_1_0[16] = MixinResolver(0xCeC4e038371d32212C6Dcdf36Fdbcb6F8a34C6d8);\\n        addressresolver_rebuildCaches_destinations_1_0[17] = MixinResolver(0x5eDf7dd83fE2889D264fa9D3b93d0a6e6A45D6C6);\\n        addressresolver_rebuildCaches_destinations_1_0[18] = MixinResolver(0x9745606DA6e162866DAD7bF80f2AbF145EDD7571);\\n        addressresolver_rebuildCaches_destinations_1_0[19] = MixinResolver(0x2962EA4E749e54b10CFA557770D597027BA67cB3);\\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_1_0);\\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;\\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_2_0 = new MixinResolver[](20);\\n        addressresolver_rebuildCaches_destinations_2_0[0] = MixinResolver(0xDB91E4B3b6E19bF22E810C43273eae48C9037e74);\\n        addressresolver_rebuildCaches_destinations_2_0[1] = MixinResolver(0xab4e760fEEe20C5c2509061b995e06b542D3112B);\\n        addressresolver_rebuildCaches_destinations_2_0[2] = MixinResolver(0xda3c83750b1FA31Fda838136ef3f853b41cb7a5a);\\n        addressresolver_rebuildCaches_destinations_2_0[3] = MixinResolver(0x47bD14817d7684082E04934878EE2Dd3576Ae19d);\\n        addressresolver_rebuildCaches_destinations_2_0[4] = MixinResolver(0x6F927644d55E32318629198081923894FbFe5c07);\\n        addressresolver_rebuildCaches_destinations_2_0[5] = MixinResolver(0xe3D5E1c1bA874C0fF3BA31b999967F24d5ca04e5);\\n        addressresolver_rebuildCaches_destinations_2_0[6] = MixinResolver(0xA962208CDC8588F9238fae169d0F63306c353F4F);\\n        addressresolver_rebuildCaches_destinations_2_0[7] = MixinResolver(0xcd980Fc5CcdAe62B18A52b83eC64200121A929db);\\n        addressresolver_rebuildCaches_destinations_2_0[8] = MixinResolver(0xAf090d6E583C082f2011908cf95c2518BE7A53ac);\\n        addressresolver_rebuildCaches_destinations_2_0[9] = MixinResolver(0x21ee4afBd6c151fD9A69c1389598170B1d45E0e3);\\n        addressresolver_rebuildCaches_destinations_2_0[10] = MixinResolver(0xcb6Cb218D558ae7fF6415f95BDA6616FCFF669Cb);\\n        addressresolver_rebuildCaches_destinations_2_0[11] = MixinResolver(0x7B29C9e188De18563B19d162374ce6836F31415a);\\n        addressresolver_rebuildCaches_destinations_2_0[12] = MixinResolver(0xC22e51FA362654ea453B4018B616ef6f6ab3b779);\\n        addressresolver_rebuildCaches_destinations_2_0[13] = MixinResolver(0xaB38249f4f56Ef868F6b5E01D9cFa26B952c1270);\\n        addressresolver_rebuildCaches_destinations_2_0[14] = MixinResolver(0xAa1b12E3e5F70aBCcd1714F4260A74ca21e7B17b);\\n        addressresolver_rebuildCaches_destinations_2_0[15] = MixinResolver(0x0F393ce493d8FB0b83915248a21a3104932ed97c);\\n        addressresolver_rebuildCaches_destinations_2_0[16] = MixinResolver(0xfD0435A588BF5c5a6974BA19Fa627b772833d4eb);\\n        addressresolver_rebuildCaches_destinations_2_0[17] = MixinResolver(0x4287dac1cC7434991119Eba7413189A66fFE65cF);\\n        addressresolver_rebuildCaches_destinations_2_0[18] = MixinResolver(0x34c76BC146b759E58886e821D62548AC1e0BA7Bc);\\n        addressresolver_rebuildCaches_destinations_2_0[19] = MixinResolver(0x0E8Fa2339314AB7E164818F26207897bBe29C3af);\\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_2_0);\\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 3;\\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_3_0 = new MixinResolver[](20);\\n        addressresolver_rebuildCaches_destinations_3_0[0] = MixinResolver(0xe615Df79AC987193561f37E77465bEC2aEfe9aDb);\\n        addressresolver_rebuildCaches_destinations_3_0[1] = MixinResolver(0x3E2dA260B4A85782A629320EB027A3B7c28eA9f1);\\n        addressresolver_rebuildCaches_destinations_3_0[2] = MixinResolver(0xc02DD182Ce029E6d7f78F37492DFd39E4FEB1f8b);\\n        addressresolver_rebuildCaches_destinations_3_0[3] = MixinResolver(0x0d1c4e5C07B071aa4E6A14A604D4F6478cAAC7B4);\\n        addressresolver_rebuildCaches_destinations_3_0[4] = MixinResolver(0x13D0F5B8630520eA04f694F17A001fb95eaFD30E);\\n        addressresolver_rebuildCaches_destinations_3_0[5] = MixinResolver(0x815CeF3b7773f35428B4353073B086ecB658f73C);\\n        addressresolver_rebuildCaches_destinations_3_0[6] = MixinResolver(0xb0e0BA880775B7F2ba813b3800b3979d719F0379);\\n        addressresolver_rebuildCaches_destinations_3_0[7] = MixinResolver(0x8e082925e78538955bC0e2F363FC5d1Ab3be739b);\\n        addressresolver_rebuildCaches_destinations_3_0[8] = MixinResolver(0x399BA516a6d68d6Ad4D5f3999902D0DeAcaACDdd);\\n        addressresolver_rebuildCaches_destinations_3_0[9] = MixinResolver(0x9530FA32a3059114AC20A5812870Da12D97d1174);\\n        addressresolver_rebuildCaches_destinations_3_0[10] = MixinResolver(0x249612F641111022f2f48769f3Df5D85cb3E26a2);\\n        addressresolver_rebuildCaches_destinations_3_0[11] = MixinResolver(0x04720DbBD4599aD26811545595d97fB813E84964);\\n        addressresolver_rebuildCaches_destinations_3_0[12] = MixinResolver(0x2acfe6265D358d982cB1c3B521199973CD443C71);\\n        addressresolver_rebuildCaches_destinations_3_0[13] = MixinResolver(0x46A7Af405093B27DA6DeF193C508Bd9240A255FA);\\n        addressresolver_rebuildCaches_destinations_3_0[14] = MixinResolver(0x8350d1b2d6EF5289179fe49E5b0F208165B4e32e);\\n        addressresolver_rebuildCaches_destinations_3_0[15] = MixinResolver(0x29DD4A59F4D339226867e77aF211724eaBb45c02);\\n        addressresolver_rebuildCaches_destinations_3_0[16] = MixinResolver(0xf7B8dF8b16dA302d85603B8e7F95111a768458Cc);\\n        addressresolver_rebuildCaches_destinations_3_0[17] = MixinResolver(0x0517A56da8A517e3b2D484Cc5F1Da4BDCfE68ec3);\\n        addressresolver_rebuildCaches_destinations_3_0[18] = MixinResolver(0x099CfAd1640fc7EA686ab1D83F0A285Ba0470882);\\n        addressresolver_rebuildCaches_destinations_3_0[19] = MixinResolver(0x19cC1f63e344D74A87D955E3F3E95B28DDDc61d8);\\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_3_0);\\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 4;\\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_4_0 = new MixinResolver[](19);\\n        addressresolver_rebuildCaches_destinations_4_0[0] = MixinResolver(0x4D50A0e5f068ACdC80A1da2dd1f0Ad48845df2F8);\\n        addressresolver_rebuildCaches_destinations_4_0[1] = MixinResolver(0xb73c665825dAa926D6ef09417FbE5654473c1b49);\\n        addressresolver_rebuildCaches_destinations_4_0[2] = MixinResolver(0x806A599d60B2FdBda379D5890287D2fba1026cC0);\\n        addressresolver_rebuildCaches_destinations_4_0[3] = MixinResolver(0xCea42504874586a718954746A564B72bc7eba3E3);\\n        addressresolver_rebuildCaches_destinations_4_0[4] = MixinResolver(0x947d5656725fB9A8f9c826A91b6082b07E2745B7);\\n        addressresolver_rebuildCaches_destinations_4_0[5] = MixinResolver(0x186E56A62E7caCE1308f1A1B0dbb27f33F80f16f);\\n        addressresolver_rebuildCaches_destinations_4_0[6] = MixinResolver(0x931c5516EE121a177bD2B60e0122Da5B27630ABc);\\n        addressresolver_rebuildCaches_destinations_4_0[7] = MixinResolver(0x6Dc6a64724399524184C2c44a526A2cff1BaA507);\\n        addressresolver_rebuildCaches_destinations_4_0[8] = MixinResolver(0x87eb6e935e3C7E3E3A0E31a5658498bC87dE646E);\\n        addressresolver_rebuildCaches_destinations_4_0[9] = MixinResolver(0x53869BDa4b8d85aEDCC9C6cAcf015AF9447Cade7);\\n        addressresolver_rebuildCaches_destinations_4_0[10] = MixinResolver(0x1cB27Ac646afAE192dF9928A2808C0f7f586Af7d);\\n        addressresolver_rebuildCaches_destinations_4_0[11] = MixinResolver(0x3dD7b893c25025CabFBd290A5E06BaFF3DE335b8);\\n        addressresolver_rebuildCaches_destinations_4_0[12] = MixinResolver(0x1A4505543C92084bE57ED80113eaB7241171e7a8);\\n        addressresolver_rebuildCaches_destinations_4_0[13] = MixinResolver(0xF6ce55E09De0F9F97210aAf6DB88Ed6b6792Ca1f);\\n        addressresolver_rebuildCaches_destinations_4_0[14] = MixinResolver(0xacAAB69C2BA65A2DB415605F309007e18D4F5E8C);\\n        addressresolver_rebuildCaches_destinations_4_0[15] = MixinResolver(0x9A5Ea0D8786B8d17a70410A905Aed1443fae5A38);\\n        addressresolver_rebuildCaches_destinations_4_0[16] = MixinResolver(0x5c8344bcdC38F1aB5EB5C1d4a35DdEeA522B5DfA);\\n        addressresolver_rebuildCaches_destinations_4_0[17] = MixinResolver(0xaa03aB31b55DceEeF845C8d17890CC61cD98eD04);\\n        addressresolver_rebuildCaches_destinations_4_0[18] = MixinResolver(0x1F2c3a1046c32729862fcB038369696e3273a516);\\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_4_0);\\n        // Ensure the SNX proxy has the correct Synthetix target set;\\n        proxyerc20_i.setTarget(Proxyable(new_Synthetix_contract));\\n        // Ensure the legacy SNX proxy has the correct Synthetix target set;\\n        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));\\n        // Ensure the Exchanger contract can write to its State;\\n        exchangestate_i.setAssociatedContract(new_Exchanger_contract);\\n        // Ensure the Exchanger contract can suspend synths - see SIP-65;\\n        systemstatus_i.updateAccessControl(\\\"Synth\\\", new_Exchanger_contract, true, false);\\n        // Ensure the Synthetix contract can write to its TokenState contract;\\n        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);\\n        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;\\n        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));\\n        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;\\n        rewardsdistribution_i.setAuthority(new_Synthetix_contract);\\n\\n        // NOMINATE OWNERSHIP back to owner for aforementioned contracts\\n        addressresolver_i.nominateNewOwner(owner);\\n        proxyerc20_i.nominateNewOwner(owner);\\n        proxysynthetix_i.nominateNewOwner(owner);\\n        exchangestate_i.nominateNewOwner(owner);\\n        systemstatus_i.nominateNewOwner(owner);\\n        tokenstatesynthetix_i.nominateOwner(owner);\\n        rewardescrow_i.nominateNewOwner(owner);\\n        rewardsdistribution_i.nominateNewOwner(owner);\\n    }\\n}\\n\\n    \"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"OWNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressresolver_i\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractsRequiringOwnership\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangestate_i\",\"outputs\":[{\"internalType\":\"contract ExchangeState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyerc20_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysynthetix_i\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"forContract\",\"type\":\"address\"}],\"name\":\"returnOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardescrow_i\",\"outputs\":[{\"internalType\":\"contract RewardEscrow\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsdistribution_i\",\"outputs\":[{\"internalType\":\"contract RewardsDistribution\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemstatus_i\",\"outputs\":[{\"internalType\":\"contract SystemStatus\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesynthetix_i\",\"outputs\":[{\"internalType\":\"contract LegacyTokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Migration_Alnitak","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}