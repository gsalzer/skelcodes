{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Airdrop.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n/*\\n\\n      |>(|)<|\\n      .-'^'-.\\n     '/\\\"'\\\"^\\\"\\\\'\\n    :( *   * ):\\n    ::)  ,| (::\\n    '(       )'          _.\\n     '\\\\ --- /'          / /\\n   .-'       '-.      .__D\\n ,\\\"      |      \\\\    / : (=|\\n:   Y    |    \\\\  \\\\  /  : (=|\\n|   |o__/ \\\\__o:   \\\\/  \\\" \\\\ \\\\\\n|   |          \\\\     '   \\\"-.\\n|    `.    ___ \\\\:._.'\\n \\\".__  \\\"-\\\" __ \\\\ \\\\\\n  .|''---''------|               _\\n  / -.          _\\\"\\\"-.--.        C )\\n '    '/.___.--'        '._    : |\\n|     --_   ^\\\"--...__      ''-.' |\\n|        ''---.o)    \\\"\\\"._        |\\n ^'--.._      |o)        '`-..._./\\n        '--.._|o)\\n              'O)\\n\\n*/\\n\\n/* proof is:\\n\\n0x63b8398f3ebcf782015a0019a4300bc20e74cf94e6626e4b18f93dd85d150f34\\n\\n*/\\ninterface IERC20 {\\n    function mint(address to, uint256 amount) external;\\n}\\n\\nlibrary MerkleProof {\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                computedHash = keccak256(\\n                    abi.encodePacked(computedHash, proofElement)\\n                );\\n            } else {\\n                computedHash = keccak256(\\n                    abi.encodePacked(proofElement, computedHash)\\n                );\\n            }\\n        }\\n        return computedHash == root;\\n    }\\n}\\n\\ncontract Airdrop {\\n    IERC20 public immutable token;\\n    bytes32 public immutable merkleRoot;\\n    mapping(uint256 => uint256) private claimedBitMap;\\n\\n    constructor(IERC20 token_, bytes32 merkleRoot_) {\\n        token = token_;\\n        merkleRoot = merkleRoot_;\\n    }\\n\\n    function isClaimed(uint256 index) public view returns (bool) {\\n        uint256 claimedWordIndex = index / 256;\\n        uint256 claimedBitIndex = index % 256;\\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\\n        uint256 mask = (1 << claimedBitIndex);\\n        return claimedWord & mask == mask;\\n    }\\n\\n    function _setClaimed(uint256 index) private {\\n        uint256 claimedWordIndex = index / 256;\\n        uint256 claimedBitIndex = index % 256;\\n        claimedBitMap[claimedWordIndex] =\\n            claimedBitMap[claimedWordIndex] |\\n            (1 << claimedBitIndex);\\n    }\\n\\n    function claim(bytes calldata node, bytes32[] calldata merkleProof)\\n        external\\n    {\\n        uint256 index;\\n        uint256 amount;\\n        address recipient;\\n        (index, recipient, amount) = abi.decode(\\n            node,\\n            (uint256, address, uint256)\\n        );\\n\\n        require(recipient == msg.sender);\\n        require(!isClaimed(index), \\\"MerkleDistributor: Drop already claimed.\\\");\\n\\n        require(\\n            MerkleProof.verify(merkleProof, merkleRoot, keccak256(node)),\\n            \\\"MerkleDistributor: Invalid proof.\\\"\\n        );\\n\\n        _setClaimed(index);\\n        token.mint(msg.sender, amount * 10 * 1 ether);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot_\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"node\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Airdrop","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c0844fdf1bcbde59a3af0859455d964d350a2cb663b8398f3ebcf782015a0019a4300bc20e74cf94e6626e4b18f93dd85d150f34","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}