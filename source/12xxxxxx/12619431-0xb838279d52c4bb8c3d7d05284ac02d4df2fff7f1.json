{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ninterface ENS {\r\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n  event Transfer(bytes32 indexed node, address owner);\r\n  event NewResolver(bytes32 indexed node, address resolver);\r\n  event NewTTL(bytes32 indexed node, uint64 ttl);\r\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n  function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\r\n  function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\r\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);\r\n  function setResolver(bytes32 node, address resolver) external;\r\n  function setOwner(bytes32 node, address owner) external;\r\n  function setTTL(bytes32 node, uint64 ttl) external;\r\n  function setApprovalForAll(address operator, bool approved) external;\r\n  function owner(bytes32 node) external view returns (address);\r\n  function resolver(bytes32 node) external view returns (address);\r\n  function ttl(bytes32 node) external view returns (uint64);\r\n  function recordExists(bytes32 node) external view returns (bool);\r\n  function isApprovedForAll(address ensowner, address operator) external view returns (bool);\r\n}\r\n\r\ncontract AbstractENS {\r\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n  event Transfer(bytes32 indexed node, address owner);\r\n  event NewResolver(bytes32 indexed node, address resolver);\r\n  event NewTTL(bytes32 indexed node, uint64 ttl);\r\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n  function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\r\n  function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\r\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);\r\n  function setResolver(bytes32 node, address resolver) external;\r\n  function setOwner(bytes32 node, address owner) external;\r\n  function setApprovalForAll(address operator, bool approved) external;\r\n  function owner(bytes32 node) public view returns (address);\r\n  function recordExists(bytes32 node) external view returns (bool);\r\n  function isApprovedForAll(address ensowner, address operator) external view returns (bool);\r\n}\r\n\r\ncontract AbstractBaseRegistrar {\r\n  event NameMigrated(uint256 indexed id, address indexed owner, uint expires);\r\n  event NameRegistered(uint256 indexed id, address indexed owner, uint expires);\r\n  event NameRenewed(uint256 indexed id, uint expires);\r\n\r\n  bytes32 public baseNode;   // The namehash of the TLD this registrar owns (eg, .eth)\r\n  ENS public ens;\r\n}\r\n\r\ncontract AbstractGroupWalletProxy {\r\n  function getIsOwner(address _owner) external view returns (bool);\r\n  function getOwners()                external view returns (address[] memory);\r\n}\r\n\r\ncontract AbstractETHRegistrarController {\r\n  mapping(bytes32=>uint) public commitments;\r\n\r\n  uint public minCommitmentAge;\r\n  uint public maxCommitmentAge;\r\n\r\n  event NameRegistered(string name, bytes32 indexed label, address indexed owner, uint cost, uint expires);\r\n  event NameRenewed(string name, bytes32 indexed label, uint cost, uint expires);\r\n  event NewPriceOracle(address indexed oracle);\r\n\r\n  function rentPrice(string memory name, uint duration) view public returns(uint);\r\n  function makeCommitmentWithConfig(string memory name, address owner, bytes32 secret, address resolver, address addr) pure public returns(bytes32);\r\n  function commit(bytes32 commitment) public;\r\n  function register(string calldata name, address owner, uint duration, bytes32 secret) external payable;\r\n  function registerWithConfig(string memory name, address owner, uint duration, bytes32 secret, address resolver, address addr) public payable;\r\n  function available(string memory name) public view returns(bool);\r\n}\r\n\r\ncontract AbstractResolver {\r\n  mapping(bytes32=>bytes) hashes;\r\n\r\n  event AddrChanged(bytes32 indexed node, address a);\r\n  event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\r\n  event NameChanged(bytes32 indexed node, string name);\r\n  event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n  event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n  event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\r\n  event ContenthashChanged(bytes32 indexed node, bytes hash);\r\n  \r\n  function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);\r\n  function addr(bytes32 node) external view returns (address);\r\n  function addr(bytes32 node, uint coinType) external view returns(bytes memory);\r\n  function contenthash(bytes32 node) external view returns (bytes memory);\r\n  function dnsrr(bytes32 node) external view returns (bytes memory);\r\n  function name(bytes32 node) external view returns (string memory);\r\n  function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\r\n  function text(bytes32 node, string calldata key) external view returns (string memory);\r\n  function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\r\n\r\n  function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\r\n  function setAddr(bytes32 node, address r_addr) external;\r\n  function setAddr(bytes32 node, uint coinType, bytes calldata a) external;\r\n  function setContenthash(bytes32 node, bytes calldata hash) external;\r\n  function setDnsrr(bytes32 node, bytes calldata data) external;\r\n  function setName(bytes32 node, string calldata _name) external;\r\n  function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\r\n  function setText(bytes32 node, string calldata key, string calldata value) external;\r\n  function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external;\r\n\r\n  function supportsInterface(bytes4 interfaceID) external pure returns (bool);\r\n  \r\n  function setAuthorisation(bytes32 node, address target, bool isAuthorised) external;\r\n}\r\n\r\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.pm> /// ProxyToken adapted and applied for token by pepihasenfuss.eth\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ProxyToken {\r\n    address internal masterCopy;\r\n\r\n    bytes32 internal name32;\r\n    uint256 private ownerPrices;\r\n\r\n    mapping (address => uint256) private balances;\r\n    mapping (address => mapping  (address => uint256)) private allowed;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event FrozenFunds(address target, bool frozen);\r\n    event Deposit(address from, uint256 value);\r\n    event Deployment(address owner, address theContract);\r\n    event Approval(address indexed owner,address indexed spender,uint256 value);\r\n\r\n    constructor(address _masterCopy) public payable\r\n    {\r\n      masterCopy = _masterCopy;\r\n    }\r\n    \r\n    function () external payable\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\r\n                mstore(0, masterCopy)\r\n                return(0, 0x20)\r\n            }\r\n\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if eq(success, 0) { revert(0, returndatasize()) }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.pm> /// ProxyGroupWallet adapted and applied for GroupWallet by pepihasenfuss.eth\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ProxyGroupWallet {\r\n    address internal masterCopy;\r\n\r\n    mapping(uint256 => uint256) private tArr;\r\n    address[]                   private owners;\r\n    \r\n    address internal GWF;                                                       // GWF - GroupWalletFactory contract\r\n    mapping(uint256 => bytes)   private structures;\r\n\r\n    event TestReturnData(address sender, bytes returnData);\r\n    event TestReturnLength(address sender, uint256 value);\r\n    event GroupWalletDeployed(address sender, uint256 members, uint256 timeStamp);\r\n    event GroupWalletMessage(bytes32 msg);\r\n    event Deposit(address from, uint256 value);\r\n    event ColorTableSaved(bytes32 domainHash);\r\n    event EtherScriptSaved(bytes32 domainHash,string key);\r\n\r\n    constructor(address _masterCopy) public payable\r\n    {\r\n      masterCopy = _masterCopy;\r\n    }\r\n    \r\n    function () external payable\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\r\n                mstore(0, masterCopy)\r\n                return(0, 0x20)\r\n            }\r\n\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if eq(success, 0) { revert(0, returndatasize()) }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n}\r\n\r\ncontract GroupWalletFactory {\r\n\r\n    event Deposit(address from, uint256 value);\r\n    event StructureDeployed(bytes32 domainHash);\r\n    event ColorTableSaved(bytes32 domainHash);\r\n    event EtherScriptSaved(bytes32 domainHash,string key);\r\n    event ProxyTokenCreation(ProxyToken proxy);\r\n    event ProxyGroupWalletCreation(ProxyGroupWallet proxy);\r\n    event SetPrices(bytes32 domainHash);\r\n    event TransferOwner(bytes32 domainHash);\r\n    event FreezeToken(bytes32 domainHash);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    uint256 constant k_KEY          = 0xdada1234dada;\r\n    uint256 constant k_aMask        = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;\r\n    uint256 constant k_commitMask   = 0xffffffffffffffffffffffff0000000000000000000000000000000000000000;\r\n    uint256 constant k_commit2Mask  = 0x0000000000000000000000000000000000000000ffffffffffffffffffffffff;\r\n    uint256 constant k_lockedMask   = 0x0000000000000000000000010000000000000000000000000000000000000000;\r\n    uint256 constant k_timeMask     = 0xffffffffffffffffffffffff0000000000000000000000000000000000000000;\r\n    uint256 constant k_time2Mask    = 0x0000000000000000000000000000000000000000ffffffffffffffffffffffff;\r\n    \r\n    bytes32 constant k_offset20     = 0x0000000000000000000000000000000000000000000000000000000000000020;\r\n    bytes28 constant k_padding28    = bytes28(0x00000000000000000000000000000000000000000000000000000000);\r\n    bytes32 constant k_abi80        = 0x0000000000000000000000000000000000000000000000000000000000000080;\r\n    uint256 constant k_rentMask     = 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\r\n\r\n    address constant k_add00        = address(0x0);\r\n\r\n\r\n    AbstractResolver                public  resolverContract;\r\n    AbstractETHRegistrarController  public  controllerContract;\r\n    AbstractBaseRegistrar           public  base;\r\n    AbstractENS                     public  ens;\r\n    address                         private GWFowner;\r\n        \r\n    mapping(uint64=>uint256)        private installations;                      // installTime +  proxyTokenAddr\r\n    mapping(bytes32=>uint256)       private commitments;                        // commitment  +  ownerAddr\r\n    \r\n  \r\n    function getCommitment(bytes32 _domainHash) private view returns (uint64 comm) {\r\n      return uint64( (uint256( commitments[_domainHash] & k_commitMask )>>160) & k_commit2Mask );\r\n    }\r\n    \r\n    function getOwner(bytes32 _domainHash) external view returns (address) {\r\n      return address( uint160( commitments[_domainHash] & k_aMask ) );\r\n    }\r\n    \r\n    function saveOwner(address _iToken, bytes32 _domainHash) private {\r\n      commitments[ _domainHash ] = uint256(uint160(_iToken)) + uint256( commitments[_domainHash] & k_commitMask);\r\n    }\r\n\r\n    function saveCommitment(bytes32 input, bytes32 _domainHash) private {\r\n      commitments[_domainHash] = uint256( (uint256(input)<<160) & k_commitMask ) + uint256( commitments[_domainHash] & k_aMask);\r\n    }\r\n\r\n    function getInstallTime(bytes32 _domainHash) public view returns (uint256 iTime) {\r\n      uint256 i = uint256(installations[ getCommitment(_domainHash) ]);\r\n      iTime = uint256( (uint256( uint256(i) & k_commitMask )>>160) & k_commit2Mask );\r\n      return iTime;\r\n    }\r\n\r\n    function getProxyToken(bytes32 _domainHash) public view returns (address p) {\r\n      return address( uint160( uint256( uint256(installations[ getCommitment(_domainHash) ]) ) & k_aMask ) );\r\n    }\r\n\r\n    function saveProxyToken(address _iOwner, bytes32 _domainHash) private {\r\n      uint64 hsh  = getCommitment(_domainHash);\r\n      uint256 i = uint256(installations[ hsh ]);\r\n      installations[ hsh ] = uint256(uint160(_iOwner)) + uint256(i & k_commitMask);\r\n    }\r\n\r\n    function saveInstallTime(uint256 input, bytes32 _domainHash) private {\r\n      uint64 hsh  = getCommitment(_domainHash);\r\n      uint256 i = uint256(installations[ hsh ]);\r\n      installations[ hsh ] = uint256( (uint256(input)<<160) & k_commitMask ) + uint256(i & k_aMask);\r\n    }\r\n\r\n    // -------------------  owners ---------------------------------------------\r\n    \r\n    function getGWProxy(bytes32 _dHash) public view returns (address) {\r\n      return address( uint160( commitments[_dHash] & k_aMask ) );\r\n    }\r\n    \r\n    function getGWPcontract(bytes32 _dHash) public view returns (AbstractGroupWalletProxy) {\r\n      return AbstractGroupWalletProxy( address( uint160( commitments[_dHash] & k_aMask ) ) );\r\n    }\r\n    \r\n    function getIsOwner(bytes32 _dHash,address _owner) external view returns (bool)\r\n    {\r\n      uint256 c = commitments[_dHash];\r\n      address theGWPcontract = address( uint160( c&k_aMask ) );\r\n      if (theGWPcontract==msg.sender) return false;                             // is initiator calling, no owners list yet\r\n      return AbstractGroupWalletProxy( theGWPcontract ).getIsOwner(_owner);     // run getGWPcontract(_dHash).getIsOwner(_owner);\r\n    }\r\n\r\n    function getOwners(bytes32 _dHash) external view returns (address[] memory)\r\n    {\r\n      uint256 c = commitments[_dHash];\r\n      if (address( uint160( c&k_aMask ) )!=msg.sender) return AbstractGroupWalletProxy( address( uint160( c&k_aMask ) ) ).getOwners(); // run getGWPcontract(_dHash).getOwners();\r\n\r\n      address[] memory empty;\r\n      return empty;\r\n    }\r\n    function getOwners_internal(uint256 c) private view returns (address[] memory)\r\n    {\r\n      if (address( uint160( c&k_aMask ) )!=msg.sender) return AbstractGroupWalletProxy( address( uint160( c&k_aMask ) ) ).getOwners();\r\n      address[] memory empty;\r\n      return empty;\r\n    }\r\n  \r\n    function char(byte b) private pure returns (byte c) {\r\n        if (uint8(b) < uint8(10)) return byte(uint8(b) + 0x30);\r\n        else return byte(uint8(b) + 0x57);\r\n    }\r\n\r\n    function b_String(bytes32 _bytes32, uint len, bool isHex) private pure returns (string memory) {\r\n        uint8 off = 0;\r\n        if (isHex) off = 2;\r\n        bytes memory s = new bytes((len*2)+off);\r\n\r\n        if (isHex) {\r\n          s[0] = 0x30;\r\n          s[1] = 0x78;\r\n        }\r\n      \r\n        for (uint i = 0; i < len; i++) {\r\n            byte b = byte(uint8(uint(_bytes32) / (2 ** (8 * ((len-1) - i)))));\r\n            byte hi = byte(uint8(b) / 16);\r\n            byte lo = byte(uint8(b) - 16 * uint8(hi));\r\n            s[off+(2 * i)] = char(hi);\r\n            s[off+(2 * i) + 1] = char(lo);\r\n        }\r\n        return string(s);\r\n    }\r\n    \r\n    function strlen(string memory s) internal pure returns (uint) {\r\n        uint len;\r\n        uint i = 0;\r\n        uint bytelength = bytes(s).length;\r\n        for(len = 0; i < bytelength; len++) {\r\n            byte b = bytes(s)[i];\r\n            if(b < 0x80) {\r\n                i += 1;\r\n            } else if (b < 0xE0) {\r\n                i += 2;\r\n            } else if (b < 0xF0) {\r\n                i += 3;\r\n            } else if (b < 0xF8) {\r\n                i += 4;\r\n            } else if (b < 0xFC) {\r\n                i += 5;\r\n            } else {\r\n                i += 6;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n    \r\n    function bytesToStr(bytes32 _b, uint len) internal pure returns (string memory)\r\n    {\r\n      bytes memory bArr = new bytes(len);\r\n      uint256 i;\r\n      \r\n      do\r\n       { \r\n        bArr[i] = _b[i];\r\n        i++;\r\n      } while(i<len);\r\n      \r\n      return string(bArr); \r\n    }\r\n\r\n    function stringMemoryTobytes32(string memory _data) private pure returns(bytes32 a) {\r\n      assembly {\r\n          a := mload(add(_data, 32))\r\n      }\r\n    }\r\n    \r\n    function mb32(bytes memory _data) private pure returns(bytes32 a) {\r\n      assembly {\r\n          a := mload(add(_data, 32))\r\n      }\r\n    }\r\n    \r\n    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {\r\n        require(offset + len <= self.length,\"keccak offset!!!\");\r\n        assembly {\r\n            ret := keccak256(add(add(self, 32), offset), len)\r\n        }\r\n    }\r\n  \r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n        \r\n        if (len==0) return;\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {\r\n        require(offset + len <= self.length,\"substring!!!\");\r\n\r\n        bytes memory ret = new bytes(len);\r\n        uint dest;\r\n        uint src;\r\n\r\n        assembly {\r\n            dest := add(ret, 32)\r\n            src  := add(add(self, 32), offset)\r\n        }\r\n        memcpy(dest, src, len);\r\n\r\n        return ret;\r\n    }\r\n    \r\n    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {\r\n        require(idx + 32 <= self.length);\r\n        assembly {\r\n            ret := mload(add(add(self, 32), idx))\r\n        }\r\n    }\r\n    \r\n    function getAddress(bytes memory d, uint off) internal pure returns(address addr) {\r\n      return address( uint256( uint256(mb32(substring(d,off,32))) & uint256(k_aMask) ));\r\n    }\r\n    \r\n    function getAmount(bytes memory d, uint off) internal pure returns(uint256 amt) {\r\n      return uint256( mb32(substring(d,off,32)) );\r\n    }\r\n    \r\n    function reserve_ogn(bytes32 _domainHash,bytes32 _commitment,bytes calldata data) external payable\r\n    {\r\n      (bool success, bytes memory returnData) = address(0xDadaDadadadadadaDaDadAdaDADAdadAdADaDADA).call.value(0)(data);\r\n      \r\n      require(data.length>0 && success && returnData.length==0 && _commitment!=0x0,\" - reserve/commit failed!\");\r\n      emit StructureDeployed(_domainHash);\r\n      \r\n      controllerContract.commit(_commitment);\r\n      commitments[ _domainHash ] = uint256( (uint256(_commitment)<<160) & k_commitMask ) + uint256( uint160(msg.sender) & k_aMask ); // save initiator = owner\r\n    }\r\n\r\n    function register_QgM(bytes32[] calldata _m) external payable\r\n    { \r\n      uint256   _dur        = uint256(_m[2])>>128;\r\n      uint256   _rent       = uint256(_m[2])&k_rentMask;\r\n      string memory _name   = bytesToStr(_m[3],uint(_m[3])&0xff);               // domainName, length\r\n      \r\n      require(address( uint160( commitments[_m[0]] & k_aMask ) )==msg.sender, \"- only by initiator.\"); // _domainHash = _m[0]\r\n      require(controllerContract.available(_name),\"NOT available!\");\r\n      require(_m[1]!=0 && _dur!=0,\"Bad duration/bad secret!\");                  //  _secret   = _m[1];\r\n\r\n      controllerContract.registerWithConfig.value(_rent)(_name,address(this),_dur,_m[1],address(resolverContract),address(this));\r\n      resolverContract.setName(_m[0],string(abi.encodePacked(_name,\".eth\")));\r\n    }\r\n    \r\n    function update_P5q(bytes32 _domainHash,bytes calldata data32) external payable\r\n    {\r\n      isInitiatorOrMember2(_domainHash);\r\n      resolverContract.setABI(_domainHash,32,abi.encodePacked(data32));         // structure\r\n      emit StructureDeployed(_domainHash);\r\n    }\r\n\r\n    function lock_dfs(bytes32 _dHash,bytes calldata data32) external payable\r\n    {\r\n      uint256 c = commitments[_dHash];\r\n      require(address( uint160(c & k_aMask) )==msg.sender,\"- only by initiator.\");                      // owner  getOwner(_dHash)\r\n      \r\n      require( installations[ uint64( (uint256(c & k_commitMask)>>160) & k_commit2Mask ) ] ==0x0,\" - Deployment cannot be locked!\");  // NOT locked getInstallTime(_dHash), getCommitment(_dHash) \r\n      \r\n      uint64 hsh  = uint64( (uint256(c & k_commitMask)>>160) & k_commit2Mask );\r\n      installations[hsh] = uint256( installations[hsh] & k_aMask ) + k_lockedMask;                      // saveInstallTime(1,_dHash)\r\n\r\n      resolverContract.setABI(_dHash,32,abi.encodePacked(data32));                                      // structure\r\n      emit StructureDeployed(_dHash);\r\n    }\r\n    \r\n    function domainReport(string calldata _dom,uint command) external payable returns (uint256 report, bytes memory structure) { \r\n      uint256 nb = 32;\r\n      uint256 stamp = 0;\r\n      uint256 colTable = 0;\r\n      uint256 abi32len = 0;\r\n      address owner;\r\n      bytes memory abi32;\r\n      \r\n      bytes32 dHash = keccak256(abi.encodePacked(base.baseNode(), keccak256(bytes(_dom))));\r\n\r\n      bool hasCommitment = uint64(getCommitment(dHash))>0x0;\r\n      \r\n      uint256 inst = getInstallTime(dHash);\r\n      \r\n      owner = base.ens().owner(dHash);\r\n       \r\n      report = uint256(inst & 0x1);                                                                   // locked group\r\n      if (!base.ens().recordExists(dHash)) report = uint256(uint(report)+2);                          // domain available - NOT existing\r\n      if (owner == address(getGWProxy(dHash)) || owner == address(this)) report = uint256(uint(report)+4); // domain contracted, GroupWalletProxy or this GWF contract is OWNER of domain\r\n      \r\n      if (base.ens().resolver(dHash) == address(resolverContract)) report = uint256(uint(report)+8);  // resolverContract resolving domain is valid\r\n      \r\n      if (hasCommitment) report = uint256(uint(report) + 16);                                         // domain with commitment\r\n      if (resolverContract.addr(dHash) == address(this)) report = uint256(uint(report) + 64);         // domain ENS points to this GWF contract\r\n      \r\n      if (hasCommitment) {\r\n        (abi32len, abi32) = resolverContract.ABI(dHash,32);                                           // isABIstructure\r\n        if ((abi32len == 32) && (uint256(abi32.length)>32) && (uint256(abi32.length)<0x1000)) report = uint256(uint(report)+32);\r\n\r\n        (uint256 abi128len, bytes memory abi128) = resolverContract.ABI(dHash,128);                   // isABI128\r\n        if ((abi128len == 128) && (uint256(abi128.length)>=224) && ((abi128.length%32) == 0)) report = uint256(uint(report)+128);\r\n\r\n        if (abi128.length>0) nb = uint256(uint256((uint256(abi128.length)-uint256(0x80))>>5)-1);      // nb of members derived from ABI128 // abi128len = 0x80 + (nbOfMem+1)*32\r\n        nb = getOwners_internal( commitments[ dHash] ).length;\r\n\r\n        stamp = uint256(stringMemoryTobytes32(resolverContract.text(dHash,\"use_timeStamp\")));\r\n        if (stamp==0x0000000d7573655f74696d655374616d70000000000000000000000000000000) stamp = 0;\r\n      }\r\n      \r\n      colTable = uint256(stringMemoryTobytes32(resolverContract.text(dHash,\"use_color_table\")));\r\n      if (colTable!=0x0000000f7573655f636f6c6f725f7461626c6500000000000000000000000000) report = uint256(uint(report)+2048);\r\n      \r\n      if (getProxyToken(dHash) != 0x0000000000000000000000000000000000000000) report = uint256(uint(report)+4096);\r\n      \r\n      if (owner == k_add00) report = uint256(uint(report)+256);                                       // domain NOT owned owner = 0x000000000000000000000000000\r\n      \r\n      if (controllerContract.available(_dom)) report = uint256(uint(report)+512);                     // domain is available\r\n      if (owner == address(msg.sender)) report = uint256(uint(report)+1024);                          // domain owned by default account\r\n\r\n      report = uint256(stamp) + uint256(uint256(report)<<128) + uint256(nb<<64) + uint256(inst);      // 4 words each is 8bytes\r\n    \r\n      if (command == 0) return (report,abi32);\r\n      if (command == 1) return (stamp,abi32);\r\n      if (command == 2) return (colTable,abi32);\r\n      if (command == 3) return (abi32len,abi32);\r\n    }\r\n    \r\n    function inviteInstallToken_q31n(bytes32[] calldata _mem) external payable {      \r\n      bytes32 _dHash = _mem[0];                                                 // domain hash identifying project/group\r\n      uint l         = _mem.length-5;                                           // 5 words\r\n      uint64 time    = uint64(now*1000) & uint64(0xffffffffffff0000);           // time % 0x1000\r\n      uint256 amount = uint256(msg.value / uint256((l/5) + 2));                 // ether transferred to each member, 1 for GWF, 1 for PGW\r\n      uint256 c      = commitments[_dHash];\r\n      \r\n      {\r\n       require(l>=10 && l<160, \" - Nb owners >= 2 and <= 31!\");                 // l = l*5\r\n       require(address( uint160(c & k_aMask) )==msg.sender, \"- only by initiator.\");\r\n       \r\n       require(address(uint160(uint256(_mem[1]))) != k_add00, \"MasterCopy != 0x0\"); // masterCopy\r\n       require(msg.value > 0, \"ProxyToken installation needs ether!\");\r\n      }\r\n    \r\n\r\n      bytes memory proxyCommand;                                                // call(proxy) \r\n      bytes memory theAbiCommand;                                               // resolverContract.setABI\r\n\r\n      {\r\n        address o;\r\n        bytes32 d;\r\n        \r\n        uint i=5;\r\n        do {\r\n          o = address(uint160(uint256( _mem[i] )));\r\n          d = _mem[i+2];\r\n          \r\n          require(o != k_add00,     \" - illegal owner.\");\r\n          require(_mem[i+1] != 0x0, \" - illegal label.\");\r\n          require(d != 0x0,         \" - illegal domainLabel.\");\r\n          \r\n          proxyCommand  = abi.encodePacked(proxyCommand ,_mem[i+3]);            // 8, 13, 18 + domainName\r\n          theAbiCommand = abi.encodePacked(theAbiCommand,_mem[i+4]);            // 9, 14, 19 + 1 abi extra word\r\n\r\n          require(address(uint160(o)).send(amount),\"Sending ether failed.\");\r\n          emit Deposit(address(uint160(o)), amount);\r\n          \r\n          base.ens().setSubnodeRecord(_dHash, _mem[i+1], address(this), address(resolverContract), time); // vitalik.ethereum.eth\r\n          resolverContract.setAddr(d,o);          \r\n          base.ens().setOwner(d,o);\r\n          \r\n          i = i+5;\r\n        } while (i<=l&&i<=165);\r\n      }\r\n      \r\n      \r\n      {\r\n        ProxyToken proxy = new ProxyToken( address(uint160(uint256(_mem[1]))) );  // install ProxyToken contract and call the Token contract immediately, masterCopy\r\n      \r\n        installations[ uint64( (uint256(c & k_timeMask)>>160) & k_time2Mask ) ] = uint256( uint160(address(proxy)) ) + uint256( (uint256(time+1)<<160) & k_timeMask ); // saveProxyToken(address(proxy),_dHash) && saveInstallTime(time+1,_dHash)\r\n        \r\n        bytes memory commandLoad = abi.encodePacked(bytes4(0x5de5cbe4),k_offset20,bytes32(uint256((l/5)+1)),proxyCommand,_mem[3],k_padding28);  // call(proxy)                   \r\n        \r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n          if eq(call(gas, proxy, amount, add(commandLoad, 0x20), mload(commandLoad), 0, 0), 0) { revert(0, 0) }\r\n        }\r\n        \r\n        theAbiCommand = abi.encodePacked(k_abi80,k_abi80,k_abi80,bytes32(uint256((l/5)+1)<<5),theAbiCommand,_mem[2]);\r\n        resolverContract.setABI(_dHash,128,theAbiCommand);                      // member addresses to ABI, one extra ABI 128 word      \r\n\r\n        emit ProxyTokenCreation(proxy);     \r\n      }\r\n      \r\n      \r\n      {\r\n        ProxyGroupWallet proxyGW = new ProxyGroupWallet( address(uint160(uint256(_mem[4]))) );    // _mem[4] = masterCopy, GroupWalletMaster\r\n        \r\n        proxyCommand = abi.encodePacked(bytes4(0x0000efe4),k_offset20,bytes32(uint256((l/5))),proxyCommand,k_padding28);  // call(proxy).newProxyGroupWallet_j5O()    \r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n          if eq(call(gas, proxyGW, amount, add(proxyCommand, 0x20), mload(proxyCommand), 0, 0), 0) { revert(0, 0) }\r\n        }\r\n        \r\n        resolverContract.setAddr(_dHash,address(proxyGW));\r\n        base.ens().setOwner(_dHash,address(proxyGW));\r\n\r\n        commitments[_dHash] = uint256(uint160(address(proxyGW)) & k_aMask) + uint256(c&k_commitMask); // save initiator = GWP-GroupWalletProxy owner\r\n\r\n        emit ProxyGroupWalletCreation(proxyGW);\r\n      }\r\n    }\r\n    \r\n    function createProxyToken(bytes32 _domainHash, address masterCopy, bytes memory data) public payable returns (ProxyToken proxy)\r\n    {\r\n        uint256 c = commitments[_domainHash];\r\n        \r\n        require(address(uint160(c & k_aMask))==msg.sender, \"- only by initiator.\");\r\n        require(masterCopy != k_add00, \"MasterCopy != 0x0\");\r\n\r\n        proxy = new ProxyToken(masterCopy);\r\n        \r\n        uint64 hsh = uint64( (uint256(c & k_commitMask)>>160) & k_commit2Mask );\r\n        installations[hsh] = uint256( uint160(address(proxy)) ) + uint256( uint256(installations[hsh]) & k_commitMask ); // saveProxyToken\r\n        \r\n        uint256 val = msg.value;\r\n        \r\n        if (data.length > 0)\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n              if eq(call(gas, proxy, val, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\r\n            }\r\n    \r\n        emit ProxyTokenCreation(proxy);\r\n    }\r\n    \r\n    function createProxyGroupWallet(bytes32 _domainHash, address masterCopy, bytes memory data) public payable returns (ProxyGroupWallet proxy)\r\n    {\r\n      uint256 c = commitments[_domainHash];\r\n      \r\n      require(address(uint160(c & k_aMask))==msg.sender, \"- only by initiator.\");\r\n      require(masterCopy != k_add00, \"MasterCopy != 0x0\");\r\n\r\n      proxy = new ProxyGroupWallet(masterCopy);\r\n      uint256 val = msg.value;\r\n      \r\n      if (data.length > 0)\r\n          // solium-disable-next-line security/no-inline-assembly\r\n          assembly {\r\n            if eq(call(gas, proxy, val, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\r\n          }\r\n  \r\n      emit ProxyGroupWalletCreation(proxy);\r\n    }\r\n\r\n    function isInitiatorOrMember2(bytes32 _dHash) private view {                // update(), saveColors(), saveScript()\r\n      uint256 c = commitments[_dHash];\r\n      if (address(uint160(c & k_aMask))==msg.sender) return;\r\n      \r\n      address[] memory memArr = getOwners_internal(c);                          // might be optimized in GW2\r\n      uint    l = memArr.length;\r\n\r\n      uint index = 32;\r\n      uint i=0;\r\n      \r\n      do {\r\n        if (memArr[i] == msg.sender) return;\r\n        i++;\r\n      } while(i<l);\r\n      \r\n      require(index>=0 && index<32, \" - unknown initiator or owner.\");\r\n    }\r\n\r\n    function isInitiatorOrMember(bytes32 _dHash) private view returns (address tProxy) {  // setTokenPrices(), transferOwner(), freezeToken(), transferToken(), transferTokenFrom()\r\n      \r\n      uint256 c = commitments[_dHash];\r\n      if (address(uint160(c & k_aMask))==msg.sender) return address( uint160( uint256( installations[  uint64( (uint256( c & k_commitMask )>>160) & k_commit2Mask ) ] ) & k_aMask ) );\r\n\r\n      address[] memory memArr = getOwners_internal(c);                          // might be optimized in GW2\r\n      uint    l = memArr.length;\r\n  \r\n      uint index = 32;\r\n      uint i=0;\r\n      \r\n      do {\r\n        if (memArr[i] == msg.sender) index = i;\r\n        i++;\r\n      } while(i<l&&index==32);\r\n      \r\n      require(index>=0 && index<32, \" - illegal/unknown initiator or owner.\");\r\n      \r\n      return address( uint160( uint256( installations[  uint64( (uint256( c & k_commitMask )>>160) & k_commit2Mask ) ] ) & k_aMask ) );\r\n    }\r\n    \r\n    function transferOwner_v3m(bytes32 _dHash, bytes memory data) public payable\r\n    { \r\n      address tProxy = isInitiatorOrMember(_dHash);\r\n      \r\n      // solium-disable-next-line security/no-inline-assembly\r\n      assembly {\r\n        if eq(call(gas, tProxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\r\n      }\r\n      emit TransferOwner(_dHash); \r\n    }\r\n\r\n    function setTokenPrices_dgw(bytes32 _dHash, bytes memory data) public payable\r\n    { \r\n      address tProxy = isInitiatorOrMember(_dHash);\r\n      \r\n      // solium-disable-next-line security/no-inline-assembly\r\n      assembly {\r\n        if eq(call(gas, tProxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\r\n      }\r\n      emit SetPrices(_dHash);\r\n    }\r\n  \r\n    function freezeToken_LGS(bytes32 _dHash, bytes memory data) public payable\r\n    { \r\n      address tProxy = isInitiatorOrMember(_dHash);\r\n      \r\n      // solium-disable-next-line security/no-inline-assembly\r\n      assembly {\r\n        if eq(call(gas, tProxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\r\n      }\r\n      emit FreezeToken(_dHash);\r\n    }\r\n    \r\n    function TransferToken_8uf(bytes32 _dHash, bytes memory data) public payable\r\n    { \r\n      address tProxy = isInitiatorOrMember(_dHash);\r\n      \r\n      // solium-disable-next-line security/no-inline-assembly\r\n      assembly {\r\n        if eq(call(gas, tProxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\r\n      }\r\n      emit Transfer(address(this), address( uint256( uint256(mb32(substring(data,4,32))) & k_aMask )), uint256( mb32(substring(data,36,32)) ) / 100);\r\n    }\r\n\r\n    function TransferTokenFrom_VCv(bytes32 _dHash, bytes memory data) public payable\r\n    { \r\n      address tProxy = isInitiatorOrMember(_dHash);\r\n      \r\n      // solium-disable-next-line security/no-inline-assembly\r\n      assembly {\r\n        if eq(call(gas, tProxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\r\n      }\r\n      emit Transfer(address( uint256( uint256(mb32(substring(data,4,32))) & k_aMask )), address( uint256( uint256(mb32(substring(data,36,32))) & k_aMask )), uint256( mb32(substring(data,68,32)) ) / 100);\r\n    }\r\n    \r\n    function withdraw() external {\r\n      require(GWFowner==msg.sender,\"Only owner of GroupWalletFactory\");\r\n      require(address(uint160(msg.sender)).send(address(this).balance-1),\"Withdrawing ETH failed.\");\r\n    }\r\n    \r\n    function() external payable\r\n    {\r\n      require(false,\"GroupWalletFactory fallback!\");\r\n    }\r\n\r\n    constructor (AbstractETHRegistrarController _controller, AbstractResolver _resolver, AbstractBaseRegistrar _base, AbstractENS _ens) public {\r\n      require(address(_controller)!=k_add00,\"Bad RegController!\");\r\n      require(address(_resolver)!=k_add00,\"Bad Resolver!\");\r\n      require(address(_base)!=k_add00,\"Bad base!\");\r\n      require(address(_ens)!=k_add00,\"Bad ens!\");\r\n      \r\n      GWFowner           = msg.sender;\r\n      \r\n      controllerContract = _controller;\r\n      resolverContract   = _resolver;\r\n      base               = _base;\r\n      ens                = _ens;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract AbstractETHRegistrarController\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"contract AbstractResolver\",\"name\":\"_resolver\",\"type\":\"address\"},{\"internalType\":\"contract AbstractBaseRegistrar\",\"name\":\"_base\",\"type\":\"address\"},{\"internalType\":\"contract AbstractENS\",\"name\":\"_ens\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"}],\"name\":\"ColorTableSaved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"EtherScriptSaved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"}],\"name\":\"FreezeToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ProxyGroupWallet\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"ProxyGroupWalletCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ProxyToken\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"ProxyTokenCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"}],\"name\":\"SetPrices\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"}],\"name\":\"StructureDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"}],\"name\":\"TransferOwner\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"TransferTokenFrom_VCv\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"TransferToken_8uf\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"base\",\"outputs\":[{\"internalType\":\"contract AbstractBaseRegistrar\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controllerContract\",\"outputs\":[{\"internalType\":\"contract AbstractETHRegistrarController\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_domainHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"masterCopy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"createProxyGroupWallet\",\"outputs\":[{\"internalType\":\"contract ProxyGroupWallet\",\"name\":\"proxy\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_domainHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"masterCopy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"createProxyToken\",\"outputs\":[{\"internalType\":\"contract ProxyToken\",\"name\":\"proxy\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_dom\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"command\",\"type\":\"uint256\"}],\"name\":\"domainReport\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"report\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"structure\",\"type\":\"bytes\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"internalType\":\"contract AbstractENS\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"freezeToken_LGS\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"}],\"name\":\"getGWPcontract\",\"outputs\":[{\"internalType\":\"contract AbstractGroupWalletProxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"}],\"name\":\"getGWProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_domainHash\",\"type\":\"bytes32\"}],\"name\":\"getInstallTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"iTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getIsOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_domainHash\",\"type\":\"bytes32\"}],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"}],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_domainHash\",\"type\":\"bytes32\"}],\"name\":\"getProxyToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"p\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_mem\",\"type\":\"bytes32[]\"}],\"name\":\"inviteInstallToken_q31n\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data32\",\"type\":\"bytes\"}],\"name\":\"lock_dfs\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_m\",\"type\":\"bytes32[]\"}],\"name\":\"register_QgM\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_domainHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_commitment\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"reserve_ogn\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolverContract\",\"outputs\":[{\"internalType\":\"contract AbstractResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setTokenPrices_dgw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_dHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferOwner_v3m\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_domainHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data32\",\"type\":\"bytes\"}],\"name\":\"update_P5q\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GroupWalletFactory","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"800000","ConstructorArguments":"000000000000000000000000283af0b28c62c092c9727f1ee09c02ca627eb7f50000000000000000000000004976fb03c32e5b8cfe2b6ccb31c09ba78ebaba4100000000000000000000000057f1887a8bf19b14fc0df6fd9b2acc9af147ea8500000000000000000000000000000000000c2e074ec69a0dfb2997ba6c7d2e1e","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0f6331de41bca7c7d18a75acc5e6dfce7368e30e4a37fcdbc8a3a2072da90f95"}]}