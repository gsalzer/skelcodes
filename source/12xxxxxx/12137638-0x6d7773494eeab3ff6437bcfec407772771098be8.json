{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n\r\n   ▄▄▄▄▄   ██   █▄▄▄▄ ▄█▄    ████▄ █ ▄▄   ▄  █ ██     ▄▀    ▄      ▄▄▄▄▄   \r\n  █     ▀▄ █ █  █  ▄▀ █▀ ▀▄  █   █ █   █ █   █ █ █  ▄▀       █    █     ▀▄ \r\n▄  ▀▀▀▀▄   █▄▄█ █▀▀▌  █   ▀  █   █ █▀▀▀  ██▀▀█ █▄▄█ █ ▀▄  █   █ ▄  ▀▀▀▀▄   \r\n ▀▄▄▄▄▀    █  █ █  █  █▄  ▄▀ ▀████ █     █   █ █  █ █   █ █   █  ▀▄▄▄▄▀    \r\n              █   █   ▀███▀         █       █     █  ███  █▄ ▄█            \r\n             █   ▀                   ▀     ▀     █         ▀▀▀             \r\n            ▀                                   ▀                          \r\n\r\n */\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\r\n\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/libraries/Events.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title A collection of Events\r\n * @notice This library defines all of the Events that the Sarcophagus system\r\n * emits\r\n */\r\nlibrary Events {\r\n    event Creation(address sarcophagusContract);\r\n\r\n    event RegisterArchaeologist(\r\n        address indexed archaeologist,\r\n        bytes currentPublicKey,\r\n        string endpoint,\r\n        address paymentAddress,\r\n        uint256 feePerByte,\r\n        uint256 minimumBounty,\r\n        uint256 minimumDiggingFee,\r\n        uint256 maximumResurrectionTime,\r\n        uint256 bond\r\n    );\r\n\r\n    event UpdateArchaeologist(\r\n        address indexed archaeologist,\r\n        string endpoint,\r\n        address paymentAddress,\r\n        uint256 feePerByte,\r\n        uint256 minimumBounty,\r\n        uint256 minimumDiggingFee,\r\n        uint256 maximumResurrectionTime,\r\n        uint256 addedBond\r\n    );\r\n\r\n    event UpdateArchaeologistPublicKey(\r\n        address indexed archaeologist,\r\n        bytes currentPublicKey\r\n    );\r\n\r\n    event WithdrawalFreeBond(\r\n        address indexed archaeologist,\r\n        uint256 withdrawnBond\r\n    );\r\n\r\n    event CreateSarcophagus(\r\n        bytes32 indexed identifier,\r\n        address indexed archaeologist,\r\n        bytes archaeologistPublicKey,\r\n        address embalmer,\r\n        string name,\r\n        uint256 resurrectionTime,\r\n        uint256 resurrectionWindow,\r\n        uint256 storageFee,\r\n        uint256 diggingFee,\r\n        uint256 bounty,\r\n        bytes recipientPublicKey,\r\n        uint256 cursedBond\r\n    );\r\n\r\n    event UpdateSarcophagus(bytes32 indexed identifier, string assetId);\r\n\r\n    event CancelSarcophagus(bytes32 indexed identifier);\r\n\r\n    event RewrapSarcophagus(\r\n        string assetId,\r\n        bytes32 indexed identifier,\r\n        uint256 resurrectionTime,\r\n        uint256 resurrectionWindow,\r\n        uint256 diggingFee,\r\n        uint256 bounty,\r\n        uint256 cursedBond\r\n    );\r\n\r\n    event UnwrapSarcophagus(\r\n        string assetId,\r\n        bytes32 indexed identifier,\r\n        bytes32 privatekey\r\n    );\r\n\r\n    event AccuseArchaeologist(\r\n        bytes32 indexed identifier,\r\n        address indexed accuser,\r\n        uint256 accuserBondReward,\r\n        uint256 embalmerBondReward\r\n    );\r\n\r\n    event BurySarcophagus(bytes32 indexed identifier);\r\n\r\n    event CleanUpSarcophagus(\r\n        bytes32 indexed identifier,\r\n        address indexed cleaner,\r\n        uint256 cleanerBondReward,\r\n        uint256 embalmerBondReward\r\n    );\r\n}\r\n\r\n// File: contracts/libraries/Types.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title A collection of defined structs\r\n * @notice This library defines the various data models that the Sarcophagus\r\n * system uses\r\n */\r\nlibrary Types {\r\n    struct Archaeologist {\r\n        bool exists;\r\n        bytes currentPublicKey;\r\n        string endpoint;\r\n        address paymentAddress;\r\n        uint256 feePerByte;\r\n        uint256 minimumBounty;\r\n        uint256 minimumDiggingFee;\r\n        uint256 maximumResurrectionTime;\r\n        uint256 freeBond;\r\n        uint256 cursedBond;\r\n    }\r\n\r\n    enum SarcophagusStates {DoesNotExist, Exists, Done}\r\n\r\n    struct Sarcophagus {\r\n        SarcophagusStates state;\r\n        address archaeologist;\r\n        bytes archaeologistPublicKey;\r\n        address embalmer;\r\n        string name;\r\n        uint256 resurrectionTime;\r\n        uint256 resurrectionWindow;\r\n        string assetId;\r\n        bytes recipientPublicKey;\r\n        uint256 storageFee;\r\n        uint256 diggingFee;\r\n        uint256 bounty;\r\n        uint256 currentCursedBond;\r\n        bytes32 privateKey;\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/Datas.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title A library implementing data structures for the Sarcophagus system\r\n * @notice This library defines a Data struct, which defines all of the state\r\n * that the Sarcophagus system needs to operate. It's expected that a single\r\n * instance of this state will exist.\r\n */\r\nlibrary Datas {\r\n    struct Data {\r\n        // archaeologists\r\n        address[] archaeologistAddresses;\r\n        mapping(address => Types.Archaeologist) archaeologists;\r\n        // archaeologist stats\r\n        mapping(address => bytes32[]) archaeologistSuccesses;\r\n        mapping(address => bytes32[]) archaeologistCancels;\r\n        mapping(address => bytes32[]) archaeologistAccusals;\r\n        mapping(address => bytes32[]) archaeologistCleanups;\r\n        // archaeologist key control\r\n        mapping(bytes => bool) archaeologistUsedKeys;\r\n        // sarcophaguses\r\n        bytes32[] sarcophagusIdentifiers;\r\n        mapping(bytes32 => Types.Sarcophagus) sarcophaguses;\r\n        // sarcophagus ownerships\r\n        mapping(address => bytes32[]) embalmerSarcophaguses;\r\n        mapping(address => bytes32[]) archaeologistSarcophaguses;\r\n        mapping(address => bytes32[]) recipientSarcophaguses;\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/Utils.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Utility functions used within the Sarcophagus system\r\n * @notice This library implements various functions that are used throughout\r\n * Sarcophagus, mainly to DRY up the codebase\r\n * @dev these functions are all stateless, public, pure/view\r\n */\r\nlibrary Utils {\r\n    /**\r\n     * @notice Reverts if the public key length is not exactly 64 bytes long\r\n     * @param publicKey the key to check length of\r\n     */\r\n    function publicKeyLength(bytes memory publicKey) public pure {\r\n        require(publicKey.length == 64, \"public key must be 64 bytes\");\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if the hash of singleHash does not equal doubleHash\r\n     * @param doubleHash the hash to compare hash of singleHash to\r\n     * @param singleHash the value to hash and compare against doubleHash\r\n     */\r\n    function hashCheck(bytes32 doubleHash, bytes memory singleHash)\r\n        public\r\n        pure\r\n    {\r\n        require(doubleHash == keccak256(singleHash), \"hashes do not match\");\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if the input string is not empty\r\n     * @param assetId the string to check\r\n     */\r\n    function confirmAssetIdNotSet(string memory assetId) public pure {\r\n        require(bytes(assetId).length == 0, \"assetId has already been set\");\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if existing assetId is not empty, or if new assetId is\r\n     * @param existingAssetId the orignal assetId to check, make sure is empty\r\n     * @param newAssetId the new assetId, which must not be empty\r\n     */\r\n    function assetIdsCheck(\r\n        string memory existingAssetId,\r\n        string memory newAssetId\r\n    ) public pure {\r\n        // verify that the existingAssetId is currently empty\r\n        confirmAssetIdNotSet(existingAssetId);\r\n\r\n        require(bytes(newAssetId).length > 0, \"assetId must not have 0 length\");\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if the given data and signature did not come from the\r\n     * given address\r\n     * @param data the payload which has been signed\r\n     * @param v signature element\r\n     * @param r signature element\r\n     * @param s signature element\r\n     * @param account address to confirm data and signature came from\r\n     */\r\n    function signatureCheck(\r\n        bytes memory data,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        address account\r\n    ) public pure {\r\n        // generate the address for a given data and signature\r\n        address hopefulAddress = ecrecover(keccak256(data), v, r, s);\r\n\r\n        require(\r\n            hopefulAddress == account,\r\n            \"signature did not come from correct account\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if the given resurrection time is not in the future\r\n     * @param resurrectionTime the time to check against block.timestamp\r\n     */\r\n    function resurrectionInFuture(uint256 resurrectionTime) public view {\r\n        require(\r\n            resurrectionTime > block.timestamp,\r\n            \"resurrection time must be in the future\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the grace period that an archaeologist has after a\r\n     * sarcophagus has reached its resurrection time\r\n     * @param resurrectionTime the resurrection timestamp of a sarcophagus\r\n     * @return the grace period\r\n     * @dev The grace period is dependent on how far out the resurrection time\r\n     * is. The longer out the resurrection time, the longer the grace period.\r\n     * There is a minimum grace period of 30 minutes, otherwise, it's\r\n     * calculated as 1% of the time between now and resurrection time.\r\n     */\r\n    function getGracePeriod(uint256 resurrectionTime)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // set a minimum window of 30 minutes\r\n        uint16 minimumResurrectionWindow = 30 minutes;\r\n\r\n        // calculate 1% of the relative time between now and the resurrection\r\n        // time\r\n        uint256 gracePeriod = (resurrectionTime - block.timestamp) / 100;\r\n\r\n        // if our calculated grace period is less than the minimum time, we'll\r\n        // use the minimum time instead\r\n        if (gracePeriod < minimumResurrectionWindow) {\r\n            gracePeriod = minimumResurrectionWindow;\r\n        }\r\n\r\n        // return that grace period\r\n        return gracePeriod;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if we're not within the resurrection window (on either\r\n     * side)\r\n     * @param resurrectionTime the resurrection time of the sarcophagus\r\n     * (absolute, i.e. a date time stamp)\r\n     * @param resurrectionWindow the resurrection window of the sarcophagus\r\n     * (relative, i.e. \"30 minutes\")\r\n     */\r\n    function unwrapTime(uint256 resurrectionTime, uint256 resurrectionWindow)\r\n        public\r\n        view\r\n    {\r\n        // revert if too early\r\n        require(\r\n            resurrectionTime <= block.timestamp,\r\n            \"it's not time to unwrap the sarcophagus\"\r\n        );\r\n\r\n        // revert if too late\r\n        require(\r\n            resurrectionTime + resurrectionWindow >= block.timestamp,\r\n            \"the resurrection window has expired\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if msg.sender is not equal to passed-in address\r\n     * @param account the account to verify is msg.sender\r\n     */\r\n    function sarcophagusUpdater(address account) public view {\r\n        require(\r\n            account == msg.sender,\r\n            \"sarcophagus cannot be updated by account\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if the input resurrection time, digging fee, or bounty\r\n     * don't fit within the other given maximum and minimum values\r\n     * @param resurrectionTime the resurrection time to check\r\n     * @param diggingFee the digging fee to check\r\n     * @param bounty the bounty to check\r\n     * @param maximumResurrectionTime the maximum resurrection time to check\r\n     * against, in relative terms (i.e. \"1 year\" is 31536000 (seconds))\r\n     * @param minimumDiggingFee the minimum digging fee to check against\r\n     * @param minimumBounty the minimum bounty to check against\r\n     */\r\n    function withinArchaeologistLimits(\r\n        uint256 resurrectionTime,\r\n        uint256 diggingFee,\r\n        uint256 bounty,\r\n        uint256 maximumResurrectionTime,\r\n        uint256 minimumDiggingFee,\r\n        uint256 minimumBounty\r\n    ) public view {\r\n        // revert if the given resurrection time is too far in the future\r\n        require(\r\n            resurrectionTime <= block.timestamp + maximumResurrectionTime,\r\n            \"resurrection time too far in the future\"\r\n        );\r\n\r\n        // revert if the given digging fee is too low\r\n        require(diggingFee >= minimumDiggingFee, \"digging fee is too low\");\r\n\r\n        // revert if the given bounty is too low\r\n        require(bounty >= minimumBounty, \"bounty is too low\");\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/Archaeologists.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title A library implementing Archaeologist-specific logic in the\r\n * Sarcophagus system\r\n * @notice This library includes public functions for manipulating\r\n * archaeologists in the Sarcophagus system\r\n */\r\nlibrary Archaeologists {\r\n    /**\r\n     * @notice Checks that an archaeologist exists, or doesn't exist, and\r\n     * and reverts if necessary\r\n     * @param data the system's data struct instance\r\n     * @param account the archaeologist address to check existence of\r\n     * @param exists bool which flips whether function reverts if archaeologist\r\n     * exists or not\r\n     */\r\n    function archaeologistExists(\r\n        Datas.Data storage data,\r\n        address account,\r\n        bool exists\r\n    ) public view {\r\n        // set the error message\r\n        string memory err = \"archaeologist has not been registered yet\";\r\n        if (!exists) err = \"archaeologist has already been registered\";\r\n\r\n        // revert if necessary\r\n        require(data.archaeologists[account].exists == exists, err);\r\n    }\r\n\r\n    /**\r\n     * @notice Increases internal data structure which tracks free bond per\r\n     * archaeologist\r\n     * @param data the system's data struct instance\r\n     * @param archAddress the archaeologist's address to operate on\r\n     * @param amount the amount to increase free bond by\r\n     */\r\n    function increaseFreeBond(\r\n        Datas.Data storage data,\r\n        address archAddress,\r\n        uint256 amount\r\n    ) private {\r\n        // load up the archaeologist\r\n        Types.Archaeologist storage arch = data.archaeologists[archAddress];\r\n\r\n        // increase the freeBond variable by amount\r\n        arch.freeBond = arch.freeBond + amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Decreases internal data structure which tracks free bond per\r\n     * archaeologist\r\n     * @param data the system's data struct instance\r\n     * @param archAddress the archaeologist's address to operate on\r\n     * @param amount the amount to decrease free bond by\r\n     */\r\n    function decreaseFreeBond(\r\n        Datas.Data storage data,\r\n        address archAddress,\r\n        uint256 amount\r\n    ) private {\r\n        // load up the archaeologist\r\n        Types.Archaeologist storage arch = data.archaeologists[archAddress];\r\n\r\n        // decrease the free bond variable by amount, reverting if necessary\r\n        require(\r\n            arch.freeBond >= amount,\r\n            \"archaeologist does not have enough free bond\"\r\n        );\r\n        arch.freeBond = arch.freeBond - amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Increases internal data structure which tracks cursed bond per\r\n     * archaeologist\r\n     * @param data the system's data struct instance\r\n     * @param archAddress the archaeologist's address to operate on\r\n     * @param amount the amount to increase cursed bond by\r\n     */\r\n    function increaseCursedBond(\r\n        Datas.Data storage data,\r\n        address archAddress,\r\n        uint256 amount\r\n    ) private {\r\n        // load up the archaeologist\r\n        Types.Archaeologist storage arch = data.archaeologists[archAddress];\r\n\r\n        // increase the freeBond variable by amount\r\n        arch.cursedBond = arch.cursedBond + amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Decreases internal data structure which tracks cursed bond per\r\n     * archaeologist\r\n     * @param data the system's data struct instance\r\n     * @param archAddress the archaeologist's address to operate on\r\n     * @param amount the amount to decrease cursed bond by\r\n     */\r\n    function decreaseCursedBond(\r\n        Datas.Data storage data,\r\n        address archAddress,\r\n        uint256 amount\r\n    ) public {\r\n        // load up the archaeologist\r\n        Types.Archaeologist storage arch = data.archaeologists[archAddress];\r\n\r\n        // decrease the free bond variable by amount\r\n        arch.cursedBond = arch.cursedBond - amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Given an archaeologist and amount, decrease free bond and\r\n     * increase cursed bond\r\n     * @param data the system's data struct instance\r\n     * @param archAddress the archaeologist's address to operate on\r\n     * @param amount the amount to decrease free bond and increase cursed bond\r\n     */\r\n    function lockUpBond(\r\n        Datas.Data storage data,\r\n        address archAddress,\r\n        uint256 amount\r\n    ) public {\r\n        decreaseFreeBond(data, archAddress, amount);\r\n        increaseCursedBond(data, archAddress, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Given an archaeologist and amount, increase free bond and\r\n     * decrease cursed bond\r\n     * @param data the system's data struct instance\r\n     * @param archAddress the archaeologist's address to operate on\r\n     * @param amount the amount to increase free bond and decrease cursed bond\r\n     */\r\n    function freeUpBond(\r\n        Datas.Data storage data,\r\n        address archAddress,\r\n        uint256 amount\r\n    ) public {\r\n        increaseFreeBond(data, archAddress, amount);\r\n        decreaseCursedBond(data, archAddress, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates and returns the curse for any sarcophagus\r\n     * @param diggingFee the digging fee of a sarcophagus\r\n     * @param bounty the bounty of a sarcophagus\r\n     * @return amount of the curse\r\n     * @dev Current implementation simply adds the two inputs together. Future\r\n     * strategies should use historical data to build a curve to change this\r\n     * amount over time.\r\n     */\r\n    function getCursedBond(uint256 diggingFee, uint256 bounty)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // TODO: implment a better algorithm, using some concept of past state\r\n        return diggingFee + bounty;\r\n    }\r\n\r\n    /**\r\n     * @notice Registers a new archaeologist in the system\r\n     * @param data the system's data struct instance\r\n     * @param currentPublicKey the public key to be used in the first\r\n     * sarcophagus\r\n     * @param endpoint where to contact this archaeologist on the internet\r\n     * @param paymentAddress all collected payments for the archaeologist will\r\n     * be sent here\r\n     * @param feePerByte amount of SARCO tokens charged per byte of storage\r\n     * being sent to Arweave\r\n     * @param minimumBounty the minimum bounty for a sarcophagus that the\r\n     * archaeologist will accept\r\n     * @param minimumDiggingFee the minimum digging fee for a sarcophagus that\r\n     * the archaeologist will accept\r\n     * @param maximumResurrectionTime the maximum resurrection time for a\r\n     * sarcophagus that the archaeologist will accept, in relative terms (i.e.\r\n     * \"1 year\" is 31536000 (seconds))\r\n     * @param freeBond the amount of SARCO bond that the archaeologist wants\r\n     * to start with\r\n     * @param sarcoToken the SARCO token used for payment handling\r\n     * @return index of the new archaeologist\r\n     */\r\n    function registerArchaeologist(\r\n        Datas.Data storage data,\r\n        bytes memory currentPublicKey,\r\n        string memory endpoint,\r\n        address paymentAddress,\r\n        uint256 feePerByte,\r\n        uint256 minimumBounty,\r\n        uint256 minimumDiggingFee,\r\n        uint256 maximumResurrectionTime,\r\n        uint256 freeBond,\r\n        IERC20 sarcoToken\r\n    ) public returns (uint256) {\r\n        // verify that the archaeologist does not already exist\r\n        archaeologistExists(data, msg.sender, false);\r\n\r\n        // verify that the public key length is accurate\r\n        Utils.publicKeyLength(currentPublicKey);\r\n\r\n        // transfer SARCO tokens from the archaeologist to this contract, to be\r\n        // used as their free bond. can be 0, which indicates that the\r\n        // archaeologist is not eligible for any new jobs\r\n        if (freeBond > 0) {\r\n            sarcoToken.transferFrom(msg.sender, address(this), freeBond);\r\n        }\r\n\r\n        // create a new archaeologist\r\n        Types.Archaeologist memory newArch =\r\n            Types.Archaeologist({\r\n                exists: true,\r\n                currentPublicKey: currentPublicKey,\r\n                endpoint: endpoint,\r\n                paymentAddress: paymentAddress,\r\n                feePerByte: feePerByte,\r\n                minimumBounty: minimumBounty,\r\n                minimumDiggingFee: minimumDiggingFee,\r\n                maximumResurrectionTime: maximumResurrectionTime,\r\n                freeBond: freeBond,\r\n                cursedBond: 0\r\n            });\r\n\r\n        // save the new archaeologist into relevant data structures\r\n        data.archaeologists[msg.sender] = newArch;\r\n        data.archaeologistAddresses.push(msg.sender);\r\n\r\n        // emit an event\r\n        emit Events.RegisterArchaeologist(\r\n            msg.sender,\r\n            newArch.currentPublicKey,\r\n            newArch.endpoint,\r\n            newArch.paymentAddress,\r\n            newArch.feePerByte,\r\n            newArch.minimumBounty,\r\n            newArch.minimumDiggingFee,\r\n            newArch.maximumResurrectionTime,\r\n            newArch.freeBond\r\n        );\r\n\r\n        // return index of the new archaeologist\r\n        return data.archaeologistAddresses.length - 1;\r\n    }\r\n\r\n    /**\r\n     * @notice An archaeologist may update their profile\r\n     * @param data the system's data struct instance\r\n     * @param endpoint where to contact this archaeologist on the internet\r\n     * @param newPublicKey the public key to be used in the next\r\n     * sarcophagus\r\n     * @param paymentAddress all collected payments for the archaeologist will\r\n     * be sent here\r\n     * @param feePerByte amount of SARCO tokens charged per byte of storage\r\n     * being sent to Arweave\r\n     * @param minimumBounty the minimum bounty for a sarcophagus that the\r\n     * archaeologist will accept\r\n     * @param minimumDiggingFee the minimum digging fee for a sarcophagus that\r\n     * the archaeologist will accept\r\n     * @param maximumResurrectionTime the maximum resurrection time for a\r\n     * sarcophagus that the archaeologist will accept, in relative terms (i.e.\r\n     * \"1 year\" is 31536000 (seconds))\r\n     * @param freeBond the amount of SARCO bond that the archaeologist wants\r\n     * to add to their profile\r\n     * @param sarcoToken the SARCO token used for payment handling\r\n     * @return bool indicating that the update was successful\r\n     */\r\n    function updateArchaeologist(\r\n        Datas.Data storage data,\r\n        bytes memory newPublicKey,\r\n        string memory endpoint,\r\n        address paymentAddress,\r\n        uint256 feePerByte,\r\n        uint256 minimumBounty,\r\n        uint256 minimumDiggingFee,\r\n        uint256 maximumResurrectionTime,\r\n        uint256 freeBond,\r\n        IERC20 sarcoToken\r\n    ) public returns (bool) {\r\n        // verify that the archaeologist exists, and is the sender of this\r\n        // transaction\r\n        archaeologistExists(data, msg.sender, true);\r\n\r\n        // load up the archaeologist\r\n        Types.Archaeologist storage arch = data.archaeologists[msg.sender];\r\n\r\n        // if archaeologist is updating their active public key, emit an event\r\n        if (keccak256(arch.currentPublicKey) != keccak256(newPublicKey)) {\r\n            emit Events.UpdateArchaeologistPublicKey(msg.sender, newPublicKey);\r\n            arch.currentPublicKey = newPublicKey;\r\n        }\r\n\r\n        // update the rest of the archaeologist profile\r\n        arch.endpoint = endpoint;\r\n        arch.paymentAddress = paymentAddress;\r\n        arch.feePerByte = feePerByte;\r\n        arch.minimumBounty = minimumBounty;\r\n        arch.minimumDiggingFee = minimumDiggingFee;\r\n        arch.maximumResurrectionTime = maximumResurrectionTime;\r\n\r\n        // the freeBond variable acts as an incrementer, so only if it's above\r\n        // zero will we update their profile variable and transfer the tokens\r\n        if (freeBond > 0) {\r\n            increaseFreeBond(data, msg.sender, freeBond);\r\n            sarcoToken.transferFrom(msg.sender, address(this), freeBond);\r\n        }\r\n\r\n        // emit an event\r\n        emit Events.UpdateArchaeologist(\r\n            msg.sender,\r\n            arch.endpoint,\r\n            arch.paymentAddress,\r\n            arch.feePerByte,\r\n            arch.minimumBounty,\r\n            arch.minimumDiggingFee,\r\n            arch.maximumResurrectionTime,\r\n            freeBond\r\n        );\r\n\r\n        // return true\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Archaeologist can withdraw any of their free bond\r\n     * @param data the system's data struct instance\r\n     * @param amount the amount of the archaeologist's free bond that they're\r\n     * withdrawing\r\n     * @param sarcoToken the SARCO token used for payment handling\r\n     * @return bool indicating that the withdrawal was successful\r\n     */\r\n    function withdrawBond(\r\n        Datas.Data storage data,\r\n        uint256 amount,\r\n        IERC20 sarcoToken\r\n    ) public returns (bool) {\r\n        // verify that the archaeologist exists, and is the sender of this\r\n        // transaction\r\n        archaeologistExists(data, msg.sender, true);\r\n\r\n        // move free bond out of the archaeologist\r\n        decreaseFreeBond(data, msg.sender, amount);\r\n\r\n        // transfer the freed SARCOs back to the archaeologist\r\n        sarcoToken.transfer(msg.sender, amount);\r\n\r\n        // emit event\r\n        emit Events.WithdrawalFreeBond(msg.sender, amount);\r\n\r\n        // return true\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/PrivateKeys.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Private key verification\r\n * @notice Implements a private key -> public key checking function\r\n * @dev modified from https://github.com/1Address/ecsol, removes extra code\r\n * which isn't necessary for our Sarcophagus implementation\r\n */\r\nlibrary PrivateKeys {\r\n    uint256 public constant gx =\r\n        0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\r\n    uint256 public constant gy =\r\n        0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\r\n\r\n    //\r\n    // Based on the original idea of Vitalik Buterin:\r\n    // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\r\n    //\r\n\r\n    function ecmulVerify(\r\n        uint256 x1,\r\n        uint256 y1,\r\n        bytes32 scalar,\r\n        bytes memory pubKey\r\n    ) private pure returns (bool) {\r\n        uint256 m =\r\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\r\n        address signer =\r\n            ecrecover(\r\n                0,\r\n                y1 % 2 != 0 ? 28 : 27,\r\n                bytes32(x1),\r\n                bytes32(mulmod(uint256(scalar), x1, m))\r\n            );\r\n\r\n        address xyAddress =\r\n            address(\r\n                uint160(\r\n                    uint256(keccak256(pubKey)) &\r\n                        0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\r\n                )\r\n            );\r\n        return xyAddress == signer;\r\n    }\r\n\r\n    /**\r\n     * @notice Given a private key and a public key, determines if that public\r\n     * key was derived from the private key\r\n     * @param privKey an secp256k1 private key\r\n     * @param pubKey an secp256k1 public key\r\n     * @return bool indicating whether the public key is derived from the\r\n     * private key\r\n     */\r\n    function keyVerification(bytes32 privKey, bytes memory pubKey)\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return ecmulVerify(gx, gy, privKey, pubKey);\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/Sarcophaguses.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title A library implementing Sarcophagus-specific logic in the\r\n * Sarcophagus system\r\n * @notice This library includes public functions for manipulating\r\n * sarcophagi in the Sarcophagus system\r\n */\r\nlibrary Sarcophaguses {\r\n    /**\r\n     * @notice Reverts if the given sarcState does not equal the comparison\r\n     * state\r\n     * @param sarcState the state of a sarcophagus\r\n     * @param state the state to compare to\r\n     */\r\n    function sarcophagusState(\r\n        Types.SarcophagusStates sarcState,\r\n        Types.SarcophagusStates state\r\n    ) internal pure {\r\n        // set the error message\r\n        string memory error = \"sarcophagus already exists\";\r\n        if (state == Types.SarcophagusStates.Exists)\r\n            error = \"sarcophagus does not exist or is not active\";\r\n\r\n        // revert if states are not equal\r\n        require(sarcState == state, error);\r\n    }\r\n\r\n    /**\r\n     * @notice Takes a sarcophagus's cursed bond, splits it in half, and sends\r\n     * to the transaction caller and embalmer\r\n     * @param data the system's data struct instance\r\n     * @param paymentAddress payment address for the transaction caller\r\n     * @param sarc the sarcophagus to operate on\r\n     * @param sarcoToken the SARCO token used for payment handling\r\n     * @return halfToSender the amount of SARCO token going to transaction\r\n     * sender\r\n     * @return halfToEmbalmer the amount of SARCO token going to embalmer\r\n     */\r\n    function splitSend(\r\n        Datas.Data storage data,\r\n        address paymentAddress,\r\n        Types.Sarcophagus storage sarc,\r\n        IERC20 sarcoToken\r\n    ) private returns (uint256, uint256) {\r\n        // split the sarcophagus's cursed bond into two halves, taking into\r\n        // account solidity math\r\n        uint256 halfToEmbalmer = sarc.currentCursedBond / 2;\r\n        uint256 halfToSender = sarc.currentCursedBond - halfToEmbalmer;\r\n\r\n        // transfer the cursed half, plus bounty, plus digging fee to the\r\n        // embalmer\r\n        sarcoToken.transfer(\r\n            sarc.embalmer,\r\n            sarc.bounty + sarc.diggingFee + halfToEmbalmer\r\n        );\r\n\r\n        // transfer the other half of the cursed bond to the transaction caller\r\n        sarcoToken.transfer(paymentAddress, halfToSender);\r\n\r\n        // update (decrease) the archaeologist's cursed bond, because this\r\n        // sarcophagus is over\r\n        Archaeologists.decreaseCursedBond(\r\n            data,\r\n            sarc.archaeologist,\r\n            sarc.currentCursedBond\r\n        );\r\n\r\n        // return data\r\n        return (halfToSender, halfToEmbalmer);\r\n    }\r\n\r\n    /**\r\n     * @notice Embalmer creates the skeleton for a new sarcopahgus\r\n     * @param data the system's data struct instance\r\n     * @param name the name of the sarcophagus\r\n     * @param archaeologist the address of a registered archaeologist to\r\n     * assign this sarcophagus to\r\n     * @param resurrectionTime the resurrection time of the sarcophagus\r\n     * @param storageFee the storage fee that the archaeologist will receive,\r\n     * for saving this sarcophagus on Arweave\r\n     * @param diggingFee the digging fee that the archaeologist will receive at\r\n     * the first rewrap\r\n     * @param bounty the bounty that the archaeologist will receive when the\r\n     * sarcophagus is unwrapped\r\n     * @param identifier the identifier of the sarcophagus, which is the hash\r\n     * of the hash of the inner encrypted layer of the sarcophagus\r\n     * @param recipientPublicKey the public key of the recipient\r\n     * @param sarcoToken the SARCO token used for payment handling\r\n     * @return index of the new sarcophagus\r\n     */\r\n    function createSarcophagus(\r\n        Datas.Data storage data,\r\n        string memory name,\r\n        address archaeologist,\r\n        uint256 resurrectionTime,\r\n        uint256 storageFee,\r\n        uint256 diggingFee,\r\n        uint256 bounty,\r\n        bytes32 identifier,\r\n        bytes memory recipientPublicKey,\r\n        IERC20 sarcoToken\r\n    ) public returns (uint256) {\r\n        // confirm that the archaeologist exists\r\n        Archaeologists.archaeologistExists(data, archaeologist, true);\r\n\r\n        // confirm that the public key length is correct\r\n        Utils.publicKeyLength(recipientPublicKey);\r\n\r\n        // confirm that this exact sarcophagus does not yet exist\r\n        sarcophagusState(\r\n            data.sarcophaguses[identifier].state,\r\n            Types.SarcophagusStates.DoesNotExist\r\n        );\r\n\r\n        // confirm that the resurrection time is in the future\r\n        Utils.resurrectionInFuture(resurrectionTime);\r\n\r\n        // load the archaeologist\r\n        Types.Archaeologist memory arch = data.archaeologists[archaeologist];\r\n\r\n        // check that the new sarcophagus parameters fit within the selected\r\n        // archaeologist's parameters\r\n        Utils.withinArchaeologistLimits(\r\n            resurrectionTime,\r\n            diggingFee,\r\n            bounty,\r\n            arch.maximumResurrectionTime,\r\n            arch.minimumDiggingFee,\r\n            arch.minimumBounty\r\n        );\r\n\r\n        // calculate the amount of archaeologist's bond to lock up\r\n        uint256 cursedBondAmount =\r\n            Archaeologists.getCursedBond(diggingFee, bounty);\r\n\r\n        // lock up that bond\r\n        Archaeologists.lockUpBond(data, archaeologist, cursedBondAmount);\r\n\r\n        // create a new sarcophagus\r\n        Types.Sarcophagus memory sarc =\r\n            Types.Sarcophagus({\r\n                state: Types.SarcophagusStates.Exists,\r\n                archaeologist: archaeologist,\r\n                archaeologistPublicKey: arch.currentPublicKey,\r\n                embalmer: msg.sender,\r\n                name: name,\r\n                resurrectionTime: resurrectionTime,\r\n                resurrectionWindow: Utils.getGracePeriod(resurrectionTime),\r\n                assetId: \"\",\r\n                recipientPublicKey: recipientPublicKey,\r\n                storageFee: storageFee,\r\n                diggingFee: diggingFee,\r\n                bounty: bounty,\r\n                currentCursedBond: cursedBondAmount,\r\n                privateKey: 0\r\n            });\r\n\r\n        // derive the recipient's address from their public key\r\n        address recipientAddress =\r\n            address(uint160(uint256(keccak256(recipientPublicKey))));\r\n\r\n        // save the sarcophagus into necessary data structures\r\n        data.sarcophaguses[identifier] = sarc;\r\n        data.sarcophagusIdentifiers.push(identifier);\r\n        data.embalmerSarcophaguses[msg.sender].push(identifier);\r\n        data.archaeologistSarcophaguses[archaeologist].push(identifier);\r\n        data.recipientSarcophaguses[recipientAddress].push(identifier);\r\n\r\n        // transfer digging fee + bounty + storage fee from embalmer to this\r\n        // contract\r\n        sarcoToken.transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            diggingFee + bounty + storageFee\r\n        );\r\n\r\n        // emit event with all the data\r\n        emit Events.CreateSarcophagus(\r\n            identifier,\r\n            sarc.archaeologist,\r\n            sarc.archaeologistPublicKey,\r\n            sarc.embalmer,\r\n            sarc.name,\r\n            sarc.resurrectionTime,\r\n            sarc.resurrectionWindow,\r\n            sarc.storageFee,\r\n            sarc.diggingFee,\r\n            sarc.bounty,\r\n            sarc.recipientPublicKey,\r\n            sarc.currentCursedBond\r\n        );\r\n\r\n        // return index of the new sarcophagus\r\n        return data.sarcophagusIdentifiers.length - 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Embalmer updates a sarcophagus given it's identifier, after\r\n     * the archaeologist has uploaded the encrypted payload onto Arweave\r\n     * @param data the system's data struct instance\r\n     * @param newPublicKey the archaeologist's new public key, to use for\r\n     * encrypting the next sarcophagus that they're assigned to\r\n     * @param identifier the identifier of the sarcophagus\r\n     * @param assetId the identifier of the encrypted asset on Arweave\r\n     * @param v signature element\r\n     * @param r signature element\r\n     * @param s signature element\r\n     * @param sarcoToken the SARCO token used for payment handling\r\n     * @return bool indicating that the update was successful\r\n     */\r\n    function updateSarcophagus(\r\n        Datas.Data storage data,\r\n        bytes memory newPublicKey,\r\n        bytes32 identifier,\r\n        string memory assetId,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        IERC20 sarcoToken\r\n    ) public returns (bool) {\r\n        // load the sarcophagus, and make sure it exists\r\n        Types.Sarcophagus storage sarc = data.sarcophaguses[identifier];\r\n        sarcophagusState(sarc.state, Types.SarcophagusStates.Exists);\r\n\r\n        // verify that the embalmer is making this transaction\r\n        Utils.sarcophagusUpdater(sarc.embalmer);\r\n\r\n        // verify that the sarcophagus does not currently have an assetId, and\r\n        // that we are setting an actual assetId\r\n        Utils.assetIdsCheck(sarc.assetId, assetId);\r\n\r\n        // verify that the archaeologist's new public key, and the assetId,\r\n        // actually came from the archaeologist and were not tampered\r\n        Utils.signatureCheck(\r\n            abi.encodePacked(newPublicKey, assetId),\r\n            v,\r\n            r,\r\n            s,\r\n            sarc.archaeologist\r\n        );\r\n\r\n        // revert if the new public key coming from the archaeologist has\r\n        // already been used\r\n        require(\r\n            !data.archaeologistUsedKeys[sarc.archaeologistPublicKey],\r\n            \"public key already used\"\r\n        );\r\n\r\n        // make sure that the new public key can't be used again in the future\r\n        data.archaeologistUsedKeys[sarc.archaeologistPublicKey] = true;\r\n\r\n        // set the assetId on the sarcophagus\r\n        sarc.assetId = assetId;\r\n\r\n        // load up the archaeologist\r\n        Types.Archaeologist storage arch =\r\n            data.archaeologists[sarc.archaeologist];\r\n\r\n        // set the new public key on the archaeologist\r\n        arch.currentPublicKey = newPublicKey;\r\n\r\n        // transfer the storage fee to the archaeologist\r\n        sarcoToken.transfer(arch.paymentAddress, sarc.storageFee);\r\n        sarc.storageFee = 0;\r\n\r\n        // emit some events\r\n        emit Events.UpdateSarcophagus(identifier, assetId);\r\n        emit Events.UpdateArchaeologistPublicKey(\r\n            sarc.archaeologist,\r\n            arch.currentPublicKey\r\n        );\r\n\r\n        // return true\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice An embalmer may cancel a sarcophagus if it hasn't been\r\n     * completely created\r\n     * @param data the system's data struct instance\r\n     * @param identifier the identifier of the sarcophagus\r\n     * @param sarcoToken the SARCO token used for payment handling\r\n     * @return bool indicating that the cancel was successful\r\n     */\r\n    function cancelSarcophagus(\r\n        Datas.Data storage data,\r\n        bytes32 identifier,\r\n        IERC20 sarcoToken\r\n    ) public returns (bool) {\r\n        // load the sarcophagus, and make sure it exists\r\n        Types.Sarcophagus storage sarc = data.sarcophaguses[identifier];\r\n        sarcophagusState(sarc.state, Types.SarcophagusStates.Exists);\r\n\r\n        // verify that the asset id has not yet been set\r\n        Utils.confirmAssetIdNotSet(sarc.assetId);\r\n\r\n        // verify that the embalmer is making this transaction\r\n        Utils.sarcophagusUpdater(sarc.embalmer);\r\n\r\n        // transfer the bounty and storage fee back to the embalmer\r\n        sarcoToken.transfer(sarc.embalmer, sarc.bounty + sarc.storageFee);\r\n\r\n        // load the archaeologist\r\n        Types.Archaeologist memory arch =\r\n            data.archaeologists[sarc.archaeologist];\r\n\r\n        // transfer the digging fee over to the archaeologist\r\n        sarcoToken.transfer(arch.paymentAddress, sarc.diggingFee);\r\n\r\n        // free up the cursed bond on the archaeologist, because this\r\n        // sarcophagus is over\r\n        Archaeologists.freeUpBond(\r\n            data,\r\n            sarc.archaeologist,\r\n            sarc.currentCursedBond\r\n        );\r\n\r\n        // set the sarcophagus state to Done\r\n        sarc.state = Types.SarcophagusStates.Done;\r\n\r\n        // save the fact that this sarcophagus has been cancelled, against the\r\n        // archaeologist\r\n        data.archaeologistCancels[sarc.archaeologist].push(identifier);\r\n\r\n        // emit an event\r\n        emit Events.CancelSarcophagus(identifier);\r\n\r\n        // return true\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Embalmer can extend the resurrection time of the sarcophagus,\r\n     * as long as the previous resurrection time is in the future\r\n     * @param data the system's data struct instance\r\n     * @param identifier the identifier of the sarcophagus\r\n     * @param resurrectionTime new resurrection time for the rewrapped\r\n     * sarcophagus\r\n     * @param diggingFee new digging fee for the rewrapped sarcophagus\r\n     * @param bounty new bounty for the rewrapped sarcophagus\r\n     * @param sarcoToken the SARCO token used for payment handling\r\n     * @return bool indicating that the rewrap was successful\r\n     */\r\n    function rewrapSarcophagus(\r\n        Datas.Data storage data,\r\n        bytes32 identifier,\r\n        uint256 resurrectionTime,\r\n        uint256 diggingFee,\r\n        uint256 bounty,\r\n        IERC20 sarcoToken\r\n    ) public returns (bool) {\r\n        // load the sarcophagus, and make sure it exists\r\n        Types.Sarcophagus storage sarc = data.sarcophaguses[identifier];\r\n        sarcophagusState(sarc.state, Types.SarcophagusStates.Exists);\r\n\r\n        // verify that the embalmer is making this transaction\r\n        Utils.sarcophagusUpdater(sarc.embalmer);\r\n\r\n        // verify that both the current resurrection time, and the new\r\n        // resurrection time, are in the future\r\n        Utils.resurrectionInFuture(sarc.resurrectionTime);\r\n        Utils.resurrectionInFuture(resurrectionTime);\r\n\r\n        // load the archaeologist\r\n        Types.Archaeologist storage arch =\r\n            data.archaeologists[sarc.archaeologist];\r\n\r\n        // check that the sarcophagus updated parameters fit within the\r\n        // archaeologist's parameters\r\n        Utils.withinArchaeologistLimits(\r\n            resurrectionTime,\r\n            diggingFee,\r\n            bounty,\r\n            arch.maximumResurrectionTime,\r\n            arch.minimumDiggingFee,\r\n            arch.minimumBounty\r\n        );\r\n\r\n        // transfer the new digging fee from embalmer to this contract\r\n        sarcoToken.transferFrom(msg.sender, address(this), diggingFee);\r\n\r\n        // transfer the old digging fee to the archaeologist\r\n        sarcoToken.transfer(arch.paymentAddress, sarc.diggingFee);\r\n\r\n        // calculate the amount of archaeologist's bond to lock up\r\n        uint256 cursedBondAmount =\r\n            Archaeologists.getCursedBond(diggingFee, bounty);\r\n\r\n        // if new cursed bond amount is greater than current cursed bond\r\n        // amount, calculate difference and lock it up. if it's less than,\r\n        // calculate difference and free it up.\r\n        if (cursedBondAmount > sarc.currentCursedBond) {\r\n            uint256 diff = cursedBondAmount - sarc.currentCursedBond;\r\n            Archaeologists.lockUpBond(data, sarc.archaeologist, diff);\r\n        } else if (cursedBondAmount < sarc.currentCursedBond) {\r\n            uint256 diff = sarc.currentCursedBond - cursedBondAmount;\r\n            Archaeologists.freeUpBond(data, sarc.archaeologist, diff);\r\n        }\r\n\r\n        // determine the new grace period for the archaeologist's final proof\r\n        uint256 gracePeriod = Utils.getGracePeriod(resurrectionTime);\r\n\r\n        // set variarbles on the sarcopahgus\r\n        sarc.resurrectionTime = resurrectionTime;\r\n        sarc.diggingFee = diggingFee;\r\n        sarc.bounty = bounty;\r\n        sarc.currentCursedBond = cursedBondAmount;\r\n        sarc.resurrectionWindow = gracePeriod;\r\n\r\n        // emit an event\r\n        emit Events.RewrapSarcophagus(\r\n            sarc.assetId,\r\n            identifier,\r\n            resurrectionTime,\r\n            gracePeriod,\r\n            diggingFee,\r\n            bounty,\r\n            cursedBondAmount\r\n        );\r\n\r\n        // return true\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Given a sarcophagus identifier, preimage, and private key,\r\n     * verify that the data is valid and close out that sarcophagus\r\n     * @param data the system's data struct instance\r\n     * @param identifier the identifier of the sarcophagus\r\n     * @param privateKey the archaeologist's private key which will decrypt the\r\n     * @param sarcoToken the SARCO token used for payment handling\r\n     * outer layer of the encrypted payload on Arweave\r\n     * @return bool indicating that the unwrap was successful\r\n     */\r\n    function unwrapSarcophagus(\r\n        Datas.Data storage data,\r\n        bytes32 identifier,\r\n        bytes32 privateKey,\r\n        IERC20 sarcoToken\r\n    ) public returns (bool) {\r\n        // load the sarcophagus, and make sure it exists\r\n        Types.Sarcophagus storage sarc = data.sarcophaguses[identifier];\r\n        sarcophagusState(sarc.state, Types.SarcophagusStates.Exists);\r\n\r\n        // verify that we're in the resurrection window\r\n        Utils.unwrapTime(sarc.resurrectionTime, sarc.resurrectionWindow);\r\n\r\n        // verify that the given private key derives the public key on the\r\n        // sarcophagus\r\n        require(\r\n            PrivateKeys.keyVerification(\r\n                privateKey,\r\n                sarc.archaeologistPublicKey\r\n            ),\r\n            \"!privateKey\"\r\n        );\r\n\r\n        // save that private key onto the sarcophagus model\r\n        sarc.privateKey = privateKey;\r\n\r\n        // load up the archaeologist\r\n        Types.Archaeologist memory arch =\r\n            data.archaeologists[sarc.archaeologist];\r\n\r\n        // transfer the Digging fee and bounty over to the archaeologist\r\n        sarcoToken.transfer(arch.paymentAddress, sarc.diggingFee + sarc.bounty);\r\n\r\n        // free up the archaeologist's cursed bond, because this sarcophagus is\r\n        // done\r\n        Archaeologists.freeUpBond(\r\n            data,\r\n            sarc.archaeologist,\r\n            sarc.currentCursedBond\r\n        );\r\n\r\n        // set the sarcophagus to Done\r\n        sarc.state = Types.SarcophagusStates.Done;\r\n\r\n        // save this successful sarcophagus against the archaeologist\r\n        data.archaeologistSuccesses[sarc.archaeologist].push(identifier);\r\n\r\n        // emit an event\r\n        emit Events.UnwrapSarcophagus(sarc.assetId, identifier, privateKey);\r\n\r\n        // return true\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Given a sarcophagus, accuse the archaeologist for unwrapping the\r\n     * sarcophagus early\r\n     * @param data the system's data struct instance\r\n     * @param identifier the identifier of the sarcophagus\r\n     * @param singleHash the preimage of the sarcophagus identifier\r\n     * @param paymentAddress the address to receive payment for accusing the\r\n     * archaeologist\r\n     * @param sarcoToken the SARCO token used for payment handling\r\n     * @return bool indicating that the accusal was successful\r\n     */\r\n    function accuseArchaeologist(\r\n        Datas.Data storage data,\r\n        bytes32 identifier,\r\n        bytes memory singleHash,\r\n        address paymentAddress,\r\n        IERC20 sarcoToken\r\n    ) public returns (bool) {\r\n        // load the sarcophagus, and make sure it exists\r\n        Types.Sarcophagus storage sarc = data.sarcophaguses[identifier];\r\n        sarcophagusState(sarc.state, Types.SarcophagusStates.Exists);\r\n\r\n        // verify that the resurrection time is in the future\r\n        Utils.resurrectionInFuture(sarc.resurrectionTime);\r\n\r\n        // verify that the accuser has data which proves that the archaeologist\r\n        // released the payload too early\r\n        Utils.hashCheck(identifier, singleHash);\r\n\r\n        // reward this transaction's caller, and the embalmer, with the cursed\r\n        // bond, and refund the rest of the payment (bounty and digging fees)\r\n        // back to the embalmer\r\n        (uint256 halfToSender, uint256 halfToEmbalmer) =\r\n            splitSend(data, paymentAddress, sarc, sarcoToken);\r\n\r\n        // save the accusal against the archaeologist\r\n        data.archaeologistAccusals[sarc.archaeologist].push(identifier);\r\n\r\n        // update sarcophagus state to Done\r\n        sarc.state = Types.SarcophagusStates.Done;\r\n\r\n        // emit an event\r\n        emit Events.AccuseArchaeologist(\r\n            identifier,\r\n            msg.sender,\r\n            halfToSender,\r\n            halfToEmbalmer\r\n        );\r\n\r\n        // return true\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Extends a sarcophagus resurrection time into infinity\r\n     * effectively signaling that the sarcophagus is over and should never be\r\n     * resurrected\r\n     * @param data the system's data struct instance\r\n     * @param identifier the identifier of the sarcophagus\r\n     * @param sarcoToken the SARCO token used for payment handling\r\n     * @return bool indicating that the bury was successful\r\n     */\r\n    function burySarcophagus(\r\n        Datas.Data storage data,\r\n        bytes32 identifier,\r\n        IERC20 sarcoToken\r\n    ) public returns (bool) {\r\n        // load the sarcophagus, and make sure it exists\r\n        Types.Sarcophagus storage sarc = data.sarcophaguses[identifier];\r\n        sarcophagusState(sarc.state, Types.SarcophagusStates.Exists);\r\n\r\n        // verify that the embalmer made this transaction\r\n        Utils.sarcophagusUpdater(sarc.embalmer);\r\n\r\n        // verify that the existing resurrection time is in the future\r\n        Utils.resurrectionInFuture(sarc.resurrectionTime);\r\n\r\n        // load the archaeologist\r\n        Types.Archaeologist storage arch =\r\n            data.archaeologists[sarc.archaeologist];\r\n\r\n        // free the archaeologist's bond, because this sarcophagus is over\r\n        Archaeologists.freeUpBond(\r\n            data,\r\n            sarc.archaeologist,\r\n            sarc.currentCursedBond\r\n        );\r\n\r\n        // transfer the digging fee to the archae\r\n        sarcoToken.transfer(arch.paymentAddress, sarc.diggingFee);\r\n\r\n        // set the resurrection time of this sarcopahgus at maxint\r\n        sarc.resurrectionTime = 2**256 - 1;\r\n\r\n        // update sarcophagus state to Done\r\n        sarc.state = Types.SarcophagusStates.Done;\r\n\r\n        // emit an event\r\n        emit Events.BurySarcophagus(identifier);\r\n\r\n        // return true\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Clean up a sarcophagus whose resurrection time and window have\r\n     * passed. Callable by anyone.\r\n     * @param data the system's data struct instance\r\n     * @param identifier the identifier of the sarcophagus\r\n     * @param paymentAddress the address to receive payment for cleaning up the\r\n     * sarcophagus\r\n     * @param sarcoToken the SARCO token used for payment handling\r\n     * @return bool indicating that the clean up was successful\r\n     */\r\n    function cleanUpSarcophagus(\r\n        Datas.Data storage data,\r\n        bytes32 identifier,\r\n        address paymentAddress,\r\n        IERC20 sarcoToken\r\n    ) public returns (bool) {\r\n        // load the sarcophagus, and make sure it exists\r\n        Types.Sarcophagus storage sarc = data.sarcophaguses[identifier];\r\n        sarcophagusState(sarc.state, Types.SarcophagusStates.Exists);\r\n\r\n        // verify that the resurrection window has expired\r\n        require(\r\n            sarc.resurrectionTime + sarc.resurrectionWindow < block.timestamp,\r\n            \"sarcophagus resurrection period must be in the past\"\r\n        );\r\n\r\n        // reward this transaction's caller, and the embalmer, with the cursed\r\n        // bond, and refund the rest of the payment (bounty and digging fees)\r\n        // back to the embalmer\r\n        (uint256 halfToSender, uint256 halfToEmbalmer) =\r\n            splitSend(data, paymentAddress, sarc, sarcoToken);\r\n\r\n        // save the cleanup against the archaeologist\r\n        data.archaeologistCleanups[sarc.archaeologist].push(identifier);\r\n\r\n        // update sarcophagus state to Done\r\n        sarc.state = Types.SarcophagusStates.Done;\r\n\r\n        // emit an event\r\n        emit Events.CleanUpSarcophagus(\r\n            identifier,\r\n            msg.sender,\r\n            halfToSender,\r\n            halfToEmbalmer\r\n        );\r\n\r\n        // return true\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/Sarcophagus.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title The main Sarcophagus system contract\r\n * @notice This contract implements the entire public interface for the\r\n * Sarcophagus system\r\n *\r\n * Sarcophagus implements a Dead Man's Switch using the Ethereum network as\r\n * the official source of truth for the switch (the \"sarcophagus\"), the Arweave\r\n * blockchain as the data storage layer for the encrypted payload, and a\r\n * decentralized network of secret-holders (the \"archaeologists\") who are\r\n * responsible for keeping a private key secret until the dead man's switch is\r\n * activated (via inaction by the \"embalmer\", the creator of the sarcophagus).\r\n *\r\n * @dev All function calls \"proxy\" down to functions implemented in one of\r\n * many libraries\r\n */\r\ncontract Sarcophagus is Initializable {\r\n    // keep a reference to the SARCO token, which is used for payments\r\n    // throughout the system\r\n    IERC20 public sarcoToken;\r\n\r\n    // all system data is stored within this single instance (_data) of the\r\n    // Data struct\r\n    Datas.Data private _data;\r\n\r\n    /**\r\n     * @notice Contract initializer\r\n     * @param _sarcoToken The address of the SARCO token\r\n     */\r\n    function initialize(address _sarcoToken) public initializer {\r\n        sarcoToken = IERC20(_sarcoToken);\r\n        emit Events.Creation(_sarcoToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the number of archaeologists that have been registered\r\n     * @return total registered archaeologist count\r\n     */\r\n    function archaeologistCount() public view virtual returns (uint256) {\r\n        return _data.archaeologistAddresses.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Given an index (of the full archaeologist array), return the\r\n     * archaeologist address at that index\r\n     * @param index The index of the registered archaeologist\r\n     * @return address of the archaeologist\r\n     */\r\n    function archaeologistAddresses(uint256 index)\r\n        public\r\n        view\r\n        virtual\r\n        returns (address)\r\n    {\r\n        return _data.archaeologistAddresses[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Given an archaeologist address, return that archaeologist's\r\n     * profile\r\n     * @param account The archaeologist account's address\r\n     * @return the Archaeologist object\r\n     */\r\n    function archaeologists(address account)\r\n        public\r\n        view\r\n        virtual\r\n        returns (Types.Archaeologist memory)\r\n    {\r\n        return _data.archaeologists[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Return the total number of sarcophagi that have been created\r\n     * @return the number of sarcophagi that have ever been created\r\n     */\r\n    function sarcophagusCount() public view virtual returns (uint256) {\r\n        return _data.sarcophagusIdentifiers.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the unique identifier of a sarcophagus, given it's index\r\n     * @param index The index of the sarcophagus\r\n     * @return the unique identifier of the given sarcophagus\r\n     */\r\n    function sarcophagusIdentifier(uint256 index)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bytes32)\r\n    {\r\n        return _data.sarcophagusIdentifiers[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the count of sarcophagi created by a specific embalmer\r\n     * @param embalmer The address of the given embalmer\r\n     * @return the number of sarcophagi which have been created by an embalmer\r\n     */\r\n    function embalmerSarcophagusCount(address embalmer)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return _data.embalmerSarcophaguses[embalmer].length;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the sarcophagus unique identifier for a given embalmer\r\n     * and index\r\n     * @param embalmer The address of an embalmer\r\n     * @param index The index of the embalmer's list of sarcophagi\r\n     * @return the double hash associated with the index of the embalmer's\r\n     * sarcophagi\r\n     */\r\n    function embalmerSarcophagusIdentifier(address embalmer, uint256 index)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bytes32)\r\n    {\r\n        return _data.embalmerSarcophaguses[embalmer][index];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the count of sarcophagi created for a specific\r\n     * archaeologist\r\n     * @param archaeologist The address of the given archaeologist\r\n     * @return the number of sarcophagi which have been created for an\r\n     * archaeologist\r\n     */\r\n    function archaeologistSarcophagusCount(address archaeologist)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return _data.archaeologistSarcophaguses[archaeologist].length;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the sarcophagus unique identifier for a given\r\n     * archaeologist and index\r\n     * @param archaeologist The address of an archaeologist\r\n     * @param index The index of the archaeologist's list of sarcophagi\r\n     * @return the identifier associated with the index of the archaeologist's\r\n     * sarcophagi\r\n     */\r\n    function archaeologistSarcophagusIdentifier(\r\n        address archaeologist,\r\n        uint256 index\r\n    ) public view virtual returns (bytes32) {\r\n        return _data.archaeologistSarcophaguses[archaeologist][index];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the count of sarcophagi created for a specific recipient\r\n     * @param recipient The address of the given recipient\r\n     * @return the number of sarcophagi which have been created for a recipient\r\n     */\r\n    function recipientSarcophagusCount(address recipient)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return _data.recipientSarcophaguses[recipient].length;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the sarcophagus unique identifier for a given recipient\r\n     * and index\r\n     * @param recipient The address of a recipient\r\n     * @param index The index of the recipient's list of sarcophagi\r\n     * @return the identifier associated with the index of the recipient's\r\n     * sarcophagi\r\n     */\r\n    function recipientSarcophagusIdentifier(address recipient, uint256 index)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bytes32)\r\n    {\r\n        return _data.recipientSarcophaguses[recipient][index];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the count of successful sarcophagi completed by the\r\n     * archaeologist\r\n     * @param archaeologist The address of the given archaeologist\r\n     * @return the number of sarcophagi which have been successfully completed\r\n     * by the archaeologist\r\n     */\r\n    function archaeologistSuccessesCount(address archaeologist)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return _data.archaeologistSuccesses[archaeologist].length;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the sarcophagus unique identifier for a given archaeologist\r\n     * and index of successful sarcophagi\r\n     * @param archaeologist The address of an archaeologist\r\n     * @param index The index of the archaeologist's list of successfully\r\n     * completed sarcophagi\r\n     * @return the identifier associated with the index of the archaeologist's\r\n     * successfully completed sarcophagi\r\n     */\r\n    function archaeologistSuccessesIdentifier(\r\n        address archaeologist,\r\n        uint256 index\r\n    ) public view returns (bytes32) {\r\n        return _data.archaeologistSuccesses[archaeologist][index];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the count of cancelled sarcophagi from the archaeologist\r\n     * @param archaeologist The address of the given archaeologist\r\n     * @return the number of cancelled sarcophagi from the archaeologist\r\n     */\r\n    function archaeologistCancelsCount(address archaeologist)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return _data.archaeologistCancels[archaeologist].length;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the sarcophagus unique identifier for a given archaeologist\r\n     * and index of the cancelled sarcophagi\r\n     * @param archaeologist The address of an archaeologist\r\n     * @param index The index of the archaeologist's cancelled sarcophagi\r\n     * @return the identifier associated with the index of the archaeologist's\r\n     * cancelled sarcophagi\r\n     */\r\n    function archaeologistCancelsIdentifier(\r\n        address archaeologist,\r\n        uint256 index\r\n    ) public view virtual returns (bytes32) {\r\n        return _data.archaeologistCancels[archaeologist][index];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the count of accused sarcophagi from the archaeologist\r\n     * @param archaeologist The address of the given archaeologist\r\n     * @return the number of accused sarcophagi from the archaeologist\r\n     */\r\n    function archaeologistAccusalsCount(address archaeologist)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return _data.archaeologistAccusals[archaeologist].length;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the sarcophagus unique identifier for a given\r\n     * archaeologist and index of the accused sarcophagi\r\n     * @param archaeologist The address of an archaeologist\r\n     * @param index The index of the archaeologist's accused sarcophagi\r\n     * @return the identifier associated with the index of the archaeologist's\r\n     * accused sarcophagi\r\n     */\r\n    function archaeologistAccusalsIdentifier(\r\n        address archaeologist,\r\n        uint256 index\r\n    ) public view virtual returns (bytes32) {\r\n        return _data.archaeologistAccusals[archaeologist][index];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the count of cleaned-up sarcophagi from the\r\n     * archaeologist\r\n     * @param archaeologist The address of the given archaeologist\r\n     * @return the number of cleaned-up sarcophagi from the archaeologist\r\n     */\r\n    function archaeologistCleanupsCount(address archaeologist)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return _data.archaeologistCleanups[archaeologist].length;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the sarcophagus unique identifier for a given\r\n     * archaeologist and index of the cleaned-up sarcophagi\r\n     * @param archaeologist The address of an archaeologist\r\n     * @param index The index of the archaeologist's accused sarcophagi\r\n     * @return the identifier associated with the index of the archaeologist's\r\n     * leaned-up sarcophagi\r\n     */\r\n    function archaeologistCleanupsIdentifier(\r\n        address archaeologist,\r\n        uint256 index\r\n    ) public view virtual returns (bytes32) {\r\n        return _data.archaeologistCleanups[archaeologist][index];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns sarcophagus data given an indentifier\r\n     * @param identifier the unique identifier a sarcophagus\r\n     * @return sarc the Sarcophagus object\r\n     */\r\n    function sarcophagus(bytes32 identifier)\r\n        public\r\n        view\r\n        virtual\r\n        returns (Types.Sarcophagus memory)\r\n    {\r\n        return _data.sarcophaguses[identifier];\r\n    }\r\n\r\n    /**\r\n     * @notice Registers a new archaeologist in the system\r\n     * @param currentPublicKey the public key to be used in the first\r\n     * sarcophagus\r\n     * @param endpoint where to contact this archaeologist on the internet\r\n     * @param paymentAddress all collected payments for the archaeologist will\r\n     * be sent here\r\n     * @param feePerByte amount of SARCO tokens charged per byte of storage\r\n     * being sent to Arweave\r\n     * @param minimumBounty the minimum bounty for a sarcophagus that the\r\n     * archaeologist will accept\r\n     * @param minimumDiggingFee the minimum digging fee for a sarcophagus that\r\n     * the archaeologist will accept\r\n     * @param maximumResurrectionTime the maximum resurrection time for a\r\n     * sarcophagus that the archaeologist will accept, in relative terms (i.e.\r\n     * \"1 year\" is 31536000 (seconds))\r\n     * @param freeBond the amount of SARCO bond that the archaeologist wants\r\n     * to start with\r\n     * @return index of the new archaeologist\r\n     */\r\n    function registerArchaeologist(\r\n        bytes memory currentPublicKey,\r\n        string memory endpoint,\r\n        address paymentAddress,\r\n        uint256 feePerByte,\r\n        uint256 minimumBounty,\r\n        uint256 minimumDiggingFee,\r\n        uint256 maximumResurrectionTime,\r\n        uint256 freeBond\r\n    ) public virtual returns (uint256) {\r\n        return\r\n            Archaeologists.registerArchaeologist(\r\n                _data,\r\n                currentPublicKey,\r\n                endpoint,\r\n                paymentAddress,\r\n                feePerByte,\r\n                minimumBounty,\r\n                minimumDiggingFee,\r\n                maximumResurrectionTime,\r\n                freeBond,\r\n                sarcoToken\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice An archaeologist may update their profile\r\n     * @param endpoint where to contact this archaeologist on the internet\r\n     * @param newPublicKey the public key to be used in the next\r\n     * sarcophagus\r\n     * @param paymentAddress all collected payments for the archaeologist will\r\n     * be sent here\r\n     * @param feePerByte amount of SARCO tokens charged per byte of storage\r\n     * being sent to Arweave\r\n     * @param minimumBounty the minimum bounty for a sarcophagus that the\r\n     * archaeologist will accept\r\n     * @param minimumDiggingFee the minimum digging fee for a sarcophagus that\r\n     * the archaeologist will accept\r\n     * @param maximumResurrectionTime the maximum resurrection time for a\r\n     * sarcophagus that the archaeologist will accept, in relative terms (i.e.\r\n     * \"1 year\" is 31536000 (seconds))\r\n     * @param freeBond the amount of SARCO bond that the archaeologist wants\r\n     * to add to their profile\r\n     * @return bool indicating that the update was successful\r\n     */\r\n    function updateArchaeologist(\r\n        string memory endpoint,\r\n        bytes memory newPublicKey,\r\n        address paymentAddress,\r\n        uint256 feePerByte,\r\n        uint256 minimumBounty,\r\n        uint256 minimumDiggingFee,\r\n        uint256 maximumResurrectionTime,\r\n        uint256 freeBond\r\n    ) public virtual returns (bool) {\r\n        return\r\n            Archaeologists.updateArchaeologist(\r\n                _data,\r\n                newPublicKey,\r\n                endpoint,\r\n                paymentAddress,\r\n                feePerByte,\r\n                minimumBounty,\r\n                minimumDiggingFee,\r\n                maximumResurrectionTime,\r\n                freeBond,\r\n                sarcoToken\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Archaeologist can withdraw any of their free bond\r\n     * @param amount the amount of the archaeologist's free bond that they're\r\n     * withdrawing\r\n     * @return bool indicating that the withdrawal was successful\r\n     */\r\n    function withdrawBond(uint256 amount) public virtual returns (bool) {\r\n        return Archaeologists.withdrawBond(_data, amount, sarcoToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Embalmer creates the skeleton for a new sarcopahgus\r\n     * @param name the name of the sarcophagus\r\n     * @param archaeologist the address of a registered archaeologist to\r\n     * assign this sarcophagus to\r\n     * @param resurrectionTime the resurrection time of the sarcophagus\r\n     * @param storageFee the storage fee that the archaeologist will receive,\r\n     * for saving this sarcophagus on Arweave\r\n     * @param diggingFee the digging fee that the archaeologist will receive at\r\n     * the first rewrap\r\n     * @param bounty the bounty that the archaeologist will receive when the\r\n     * sarcophagus is unwrapped\r\n     * @param identifier the identifier of the sarcophagus, which is the hash\r\n     * of the hash of the inner encrypted layer of the sarcophagus\r\n     * @param recipientPublicKey the public key of the recipient\r\n     * @return index of the new sarcophagus\r\n     */\r\n    function createSarcophagus(\r\n        string memory name,\r\n        address archaeologist,\r\n        uint256 resurrectionTime,\r\n        uint256 storageFee,\r\n        uint256 diggingFee,\r\n        uint256 bounty,\r\n        bytes32 identifier,\r\n        bytes memory recipientPublicKey\r\n    ) public virtual returns (uint256) {\r\n        return\r\n            Sarcophaguses.createSarcophagus(\r\n                _data,\r\n                name,\r\n                archaeologist,\r\n                resurrectionTime,\r\n                storageFee,\r\n                diggingFee,\r\n                bounty,\r\n                identifier,\r\n                recipientPublicKey,\r\n                sarcoToken\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Embalmer updates a sarcophagus given it's identifier, after\r\n     * the archaeologist has uploaded the encrypted payload onto Arweave\r\n     * @param newPublicKey the archaeologist's new public key, to use for\r\n     * encrypting the next sarcophagus that they're assigned to\r\n     * @param identifier the identifier of the sarcophagus\r\n     * @param assetId the identifier of the encrypted asset on Arweave\r\n     * @param v signature element\r\n     * @param r signature element\r\n     * @param s signature element\r\n     * @return bool indicating that the update was successful\r\n     */\r\n    function updateSarcophagus(\r\n        bytes memory newPublicKey,\r\n        bytes32 identifier,\r\n        string memory assetId,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual returns (bool) {\r\n        return\r\n            Sarcophaguses.updateSarcophagus(\r\n                _data,\r\n                newPublicKey,\r\n                identifier,\r\n                assetId,\r\n                v,\r\n                r,\r\n                s,\r\n                sarcoToken\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice An embalmer may cancel a sarcophagus if it hasn't been\r\n     * completely created\r\n     * @param identifier the identifier of the sarcophagus\r\n     * @return bool indicating that the cancel was successful\r\n     */\r\n    function cancelSarcophagus(bytes32 identifier)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        return Sarcophaguses.cancelSarcophagus(_data, identifier, sarcoToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Embalmer can extend the resurrection time of the sarcophagus,\r\n     * as long as the previous resurrection time is in the future\r\n     * @param identifier the identifier of the sarcophagus\r\n     * @param resurrectionTime new resurrection time for the rewrapped\r\n     * sarcophagus\r\n     * @param diggingFee new digging fee for the rewrapped sarcophagus\r\n     * @param bounty new bounty for the rewrapped sarcophagus\r\n     * @return bool indicating that the rewrap was successful\r\n     */\r\n    function rewrapSarcophagus(\r\n        bytes32 identifier,\r\n        uint256 resurrectionTime,\r\n        uint256 diggingFee,\r\n        uint256 bounty\r\n    ) public virtual returns (bool) {\r\n        return\r\n            Sarcophaguses.rewrapSarcophagus(\r\n                _data,\r\n                identifier,\r\n                resurrectionTime,\r\n                diggingFee,\r\n                bounty,\r\n                sarcoToken\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Given a sarcophagus identifier, preimage, and private key,\r\n     * verify that the data is valid and close out that sarcophagus\r\n     * @param identifier the identifier of the sarcophagus\r\n     * @param privateKey the archaeologist's private key which will decrypt the\r\n     * outer layer of the encrypted payload on Arweave\r\n     * @return bool indicating that the unwrap was successful\r\n     */\r\n    function unwrapSarcophagus(bytes32 identifier, bytes32 privateKey)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        return\r\n            Sarcophaguses.unwrapSarcophagus(\r\n                _data,\r\n                identifier,\r\n                privateKey,\r\n                sarcoToken\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Given a sarcophagus, accuse the archaeologist for unwrapping the\r\n     * sarcophagus early\r\n     * @param identifier the identifier of the sarcophagus\r\n     * @param singleHash the preimage of the sarcophagus identifier\r\n     * @param paymentAddress the address to receive payment for accusing the\r\n     * archaeologist\r\n     * @return bool indicating that the accusal was successful\r\n     */\r\n    function accuseArchaeologist(\r\n        bytes32 identifier,\r\n        bytes memory singleHash,\r\n        address paymentAddress\r\n    ) public virtual returns (bool) {\r\n        return\r\n            Sarcophaguses.accuseArchaeologist(\r\n                _data,\r\n                identifier,\r\n                singleHash,\r\n                paymentAddress,\r\n                sarcoToken\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Extends a sarcophagus resurrection time into infinity\r\n     * effectively signaling that the sarcophagus is over and should never be\r\n     * resurrected\r\n     * @param identifier the identifier of the sarcophagus\r\n     * @return bool indicating that the bury was successful\r\n     */\r\n    function burySarcophagus(bytes32 identifier) public virtual returns (bool) {\r\n        return Sarcophaguses.burySarcophagus(_data, identifier, sarcoToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Clean up a sarcophagus whose resurrection time and window have\r\n     * passed. Callable by anyone.\r\n     * @param identifier the identifier of the sarcophagus\r\n     * @param paymentAddress the address to receive payment for cleaning up the\r\n     * sarcophagus\r\n     * @return bool indicating that the clean up was successful\r\n     */\r\n    function cleanUpSarcophagus(bytes32 identifier, address paymentAddress)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        return\r\n            Sarcophaguses.cleanUpSarcophagus(\r\n                _data,\r\n                identifier,\r\n                paymentAddress,\r\n                sarcoToken\r\n            );\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"singleHash\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"paymentAddress\",\"type\":\"address\"}],\"name\":\"accuseArchaeologist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"archaeologistAccusalsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"archaeologistAccusalsIdentifier\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"archaeologistAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"archaeologistCancelsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"archaeologistCancelsIdentifier\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"archaeologistCleanupsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"archaeologistCleanupsIdentifier\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"archaeologistCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"archaeologistSarcophagusCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"archaeologistSarcophagusIdentifier\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"}],\"name\":\"archaeologistSuccessesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"archaeologistSuccessesIdentifier\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"archaeologists\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"currentPublicKey\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"endpoint\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"paymentAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feePerByte\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumBounty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDiggingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumResurrectionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cursedBond\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Archaeologist\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"}],\"name\":\"burySarcophagus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"}],\"name\":\"cancelSarcophagus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"paymentAddress\",\"type\":\"address\"}],\"name\":\"cleanUpSarcophagus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"resurrectionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"storageFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"diggingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bounty\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"recipientPublicKey\",\"type\":\"bytes\"}],\"name\":\"createSarcophagus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"embalmer\",\"type\":\"address\"}],\"name\":\"embalmerSarcophagusCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"embalmer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"embalmerSarcophagusIdentifier\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sarcoToken\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"recipientSarcophagusCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"recipientSarcophagusIdentifier\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"currentPublicKey\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"endpoint\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"paymentAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feePerByte\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumBounty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDiggingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumResurrectionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"}],\"name\":\"registerArchaeologist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"resurrectionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"diggingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bounty\",\"type\":\"uint256\"}],\"name\":\"rewrapSarcophagus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sarcoToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"}],\"name\":\"sarcophagus\",\"outputs\":[{\"components\":[{\"internalType\":\"enum Types.SarcophagusStates\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"archaeologist\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"archaeologistPublicKey\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"embalmer\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"resurrectionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resurrectionWindow\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"assetId\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"recipientPublicKey\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"storageFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"diggingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bounty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentCursedBond\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"privateKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Types.Sarcophagus\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sarcophagusCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"sarcophagusIdentifier\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"privateKey\",\"type\":\"bytes32\"}],\"name\":\"unwrapSarcophagus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"endpoint\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"newPublicKey\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"paymentAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feePerByte\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumBounty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDiggingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumResurrectionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeBond\",\"type\":\"uint256\"}],\"name\":\"updateArchaeologist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"newPublicKey\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"assetId\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"updateSarcophagus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBond\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Sarcophagus","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"Archaeologists:ca7353f0486f7e52813acfd39060683f981fc4ed;Sarcophaguses:621b1710d64e27e143f332c79ce45b92daf3fec6","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://444df424a01ff75b2492a1d898975cee632e16532cfc053f77ec8004fa71bee7"}]}