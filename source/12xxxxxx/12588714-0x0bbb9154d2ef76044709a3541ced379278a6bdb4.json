{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MomentumSale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./utils/Context.sol\\\";\\nimport \\\"./security/ReentrancyGuard.sol\\\";\\nimport \\\"./interfaces/IMomentumSale.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IWhitelist.sol\\\";\\nimport \\\"./interfaces/AggregatorV3Interface.sol\\\";\\n\\n/**\\n * Implementation of the {IGenesisSale} Interface.\\n *\\n * Used for the daily sale of EDGEX tokens.\\n *\\n * Token Price is stored as 8 precision variables.\\n */\\n\\ncontract MomentumSale is ReentrancyGuard, Context, IMomentumSale {\\n    mapping(address => uint256) public totalPurchases;\\n    mapping(address => mapping(uint256 => Sale)) public sale;\\n    mapping(uint256 => SaleInfo) public info;\\n    mapping(uint256 => address) public oracle;\\n\\n    address public admin;\\n    address public ethWallet;\\n    address public organisation;\\n    address public governor;\\n    address public whitelistOracle;\\n\\n    uint256 public totalSaleContracts;\\n    uint256 public pricePerToken;\\n    address public ethPriceSource;\\n    address public edgexTokenContract;\\n    uint256 public lastCreated;\\n    uint256 public totalOracles = 15;\\n\\n    /**\\n     * @dev stores the instance of every purchase.\\n     *\\n     * whenever an user purchases new EDGEX tokens we create a\\n     * new sale instance and stores it.\\n     */\\n    struct Sale {\\n        uint256 usdPurchase;\\n        uint256 pricePurchase;\\n        uint256 amountPurchased;\\n        uint256 timestamp;\\n        bool isAllocated;\\n        uint256 bonus;\\n        uint256 saleId;\\n    }\\n\\n    /**\\n     * @dev stores the history of every sale instances.\\n     *\\n     * Every 24 hours, a new sale is created with a fixed amount\\n     * of tokens.\\n     */\\n    struct SaleInfo {\\n        uint256 start;\\n        uint256 end;\\n        uint256 allocated;\\n        uint256 totalPurchased;\\n        uint8 priceSource;\\n    }\\n\\n    /**\\n     * @dev Emittee when the ownership of the contract changes.\\n     */\\n    event RevokeOwnership(address indexed _owner);\\n\\n    /**\\n     * @dev Emitted when the governor role state changes.\\n     *\\n     * Based on the event we can predict the role of governor.\\n     */\\n    event UpdateGovernor(address indexed _governor);\\n\\n    /**\\n     * @dev sets the initial params.\\n     *\\n     * {_ethWallet} - Address to which the funds are directed to.\\n     * {_organisation} - Address to which % of sale tokens are sent to.\\n     * {_governor} - Address to be configured in the server for off-chain settlement.\\n     * {_admin} - Owner of this contract.\\n     * {_ethPriceSource} - Chainlink ETH/USD price source.\\n     * {_whitelistOracle} - Oracle to fetch whitelisting info from.\\n     * {_edgexContract} - Address of the EDGEX token.\\n     * {_pricePerToken} - Price of Each EDGEX token (8 precision).\\n     */\\n    constructor(\\n        address _admin,\\n        address _organisation,\\n        address _ethWallet,\\n        address _governor,\\n        uint256 _pricePerToken,\\n        address _ethPriceSource,\\n        address _whitelistOracle,\\n        address _edgexTokenContract\\n    ) {\\n        admin = _admin;\\n        organisation = _organisation;\\n        ethWallet = _ethWallet;\\n        governor = _governor;\\n        pricePerToken = _pricePerToken;\\n        whitelistOracle = _whitelistOracle;\\n        ethPriceSource = _ethPriceSource;\\n        edgexTokenContract = _edgexTokenContract;\\n    }\\n\\n    /**\\n     * @dev sanity checks the caller.\\n     * If the caller is not admin, the transaction is reverted.\\n     *\\n     * keeps the security of the platform and prevents bad actors\\n     * from executing sensitive functions / state changes.\\n     */\\n    modifier onlyAdmin() {\\n        require(_msgSender() == admin, \\\"Error: caller not admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev sanity checks the caller.\\n     * If the caller is not governor, the transaction is reverted.\\n     *\\n     * keeps the security of the platform and prevents bad actors\\n     * from executing sensitive functions / state changes.\\n     */\\n    modifier onlyGovernor() {\\n        require(_msgSender() == governor, \\\"Error: caller not governor\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev checks whether the address is a valid one.\\n     *\\n     * If it's a zero address returns an error.\\n     */\\n    modifier isZero(address _address) {\\n        require(_address != address(0), \\\"Error: zero address\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev checks whether the `_user` is whitelisted and verified his KYC.\\n     *\\n     * Requirements:\\n     * `_user` cannot be a zero address,\\n     *\\n     * Proxies calls to the whitelist contract address.\\n     */\\n    function isWhitelisted(address _user) public view virtual returns (bool) {\\n        bool status = IWhiteList(whitelistOracle).whitelisted(_user);\\n        return status;\\n    }\\n\\n    /**\\n     * @dev allocates the `_allocated` amount of tokens for the current 24 hour sale.\\n     *\\n     * `_source` should be the specified as the external oracle source or the\\n     * internal fallback price.\\n     *\\n     * Requirements:\\n     * `caller` should be governor.\\n     */\\n    function createSaleContract(uint256 _allocated, uint8 _source)\\n        public\\n        virtual\\n        override\\n        onlyGovernor\\n        returns (bool)\\n    {\\n        uint256 cooldownPeriod = lastCreated + 24 hours;\\n        SaleInfo storage a = info[totalSaleContracts];\\n        require(\\n            block.timestamp >= cooldownPeriod\\n            || \\n            a.allocated <= a.totalPurchased,\\n            \\\"Error: sale cannot be created.\\\"\\n        );\\n\\n        SaleInfo storage i = info[totalSaleContracts + 1];\\n        i.start = block.timestamp;\\n        i.end = block.timestamp + 24 hours;\\n        i.allocated = _allocated * 10**18;\\n        i.priceSource = _source;\\n\\n        lastCreated = block.timestamp;\\n        totalSaleContracts += 1;\\n        return true;\\n    }\\n\\n    /**\\n     * @dev increases the number of tokens allocated for each saleId.\\n     *\\n     * Requirements:\\n     * `_saleId` should have an active ongoing sale.\\n     * Allocated cannot be increased for ended sales.\\n     *\\n     * Requirements:\\n     * `caller` should be governor.\\n     */\\n    function increaseAllocation(uint256 _amount, uint256 _saleId)\\n        public\\n        virtual\\n        override\\n        onlyGovernor\\n        returns (bool)\\n    {\\n        SaleInfo storage i = info[_saleId];\\n        require(block.timestamp < i.end, \\\"Error: sale already ended\\\");\\n\\n        uint256 amount = _amount * 10**18;\\n        i.allocated = i.allocated + amount;\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev purchases edgex tokens by calling this function with ethers.\\n     *\\n     * Requirements:\\n     * `caller` should've to be whitelisted.\\n     * there should be an active sale ongoing.\\n     * allocated tokens should be available.\\n     */\\n    function purchaseWithEth()\\n        public\\n        payable\\n        virtual\\n        override\\n        nonReentrant\\n        returns (bool)\\n    {\\n        SaleInfo storage i = info[totalSaleContracts];\\n\\n        require(i.totalPurchased <= i.allocated, \\\"Error: sold out\\\");\\n        require(block.timestamp < i.end, \\\"Error: sale Ended\\\");\\n        require(isWhitelisted(_msgSender()), \\\"Error: address not verified\\\");\\n\\n        (uint256 _amountToken, uint256 _pricePurchase, uint256 _usdPurchase) =\\n            resolverEther(msg.value);\\n\\n        Sale storage s = sale[_msgSender()][totalPurchases[_msgSender()] + 1];\\n        s.usdPurchase = _usdPurchase;\\n        s.amountPurchased = _amountToken;\\n        s.pricePurchase = _pricePurchase;\\n        s.timestamp = block.timestamp;\\n        s.saleId = totalSaleContracts;\\n\\n        i.totalPurchased += _amountToken;\\n        totalPurchases[_msgSender()] += 1;\\n\\n        payable(ethWallet).transfer(msg.value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev allocated EDGEX tokens to users on behalf of them.\\n     * used for off-chain purchases.\\n     *\\n     * Requirements:\\n     * `_user` should be whitelisted for sale.\\n     * current sale should be live and not sold out.\\n     * `caller` should be governor.\\n     */\\n    function adminPurchase(\\n        address _user,\\n        uint256 _amountToken,\\n        uint256 _usdPurchase,\\n        uint256 _pricePurchase\\n    ) public virtual override onlyGovernor returns (bool) {\\n        SaleInfo storage i = info[totalSaleContracts];\\n        require(i.totalPurchased <= i.allocated, \\\"Error: sold out\\\");\\n        require(block.timestamp < i.end, \\\"Error: purchase ended\\\");\\n\\n        Sale storage s = sale[_user][totalPurchases[_msgSender()] + 1];\\n        s.usdPurchase = _usdPurchase;\\n        s.amountPurchased = _amountToken;\\n        s.pricePurchase = _pricePurchase;\\n        s.timestamp = block.timestamp;\\n        s.saleId = totalSaleContracts;\\n\\n        i.totalPurchased += _amountToken;\\n        totalPurchases[_user] += 1;\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev returns the amount of EDGEX tokens for `_amountEther`\\n     * in the current sale scenario.\\n     *\\n     * Used for off-chain calculation of tokens for eq.ether value.\\n     */\\n    function resolverEther(uint256 _amountEther)\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 ethPrice = uint256(fetchEthPrice());\\n        ethPrice = _amountEther * ethPrice;\\n        uint256 price = fetchTokenPrice();\\n        uint256 _tokenAmount = ethPrice / price;\\n        return (_tokenAmount, price, ethPrice);\\n    }\\n\\n    /**\\n     * @dev returns the EDGEX token price.\\n     *\\n     * Based on the current business logic, EDGEX price can be an internal source\\n     * or from an external oracle.\\n     */\\n    function fetchTokenPrice() public view virtual override returns (uint256) {\\n        SaleInfo storage i = info[totalSaleContracts];\\n        if (i.priceSource == 0) {\\n            return pricePerToken;\\n        } else {\\n            return uint256(fetchEdgexPrice());\\n        }\\n    }\\n\\n    /**\\n     * @dev fetches the price of Ethereum from chainlink oracle\\n     *\\n     * Real-time onchain price is fetched.\\n     */\\n    function fetchEthPrice() public view returns (int256) {\\n        (, int256 price, , , ) =\\n            AggregatorV3Interface(ethPriceSource).latestRoundData();\\n        return price;\\n    }\\n\\n    /**\\n     * @dev fetches the price of EDGEX token from chainlink oracle\\n     *\\n     * Real-time onchain price is fetched.\\n     */\\n    function fetchEdgexPrice() public view returns (uint256) {\\n        uint256 totalPrice;\\n        uint256 validOracles;\\n        for (uint256 i = 0; i < totalOracles; i++) {\\n            if (oracle[i] != address(0)) {\\n                (, int256 price, , , ) =\\n                    AggregatorV3Interface(oracle[i]).latestRoundData();\\n                totalPrice += uint256(price);\\n                validOracles += 1;\\n            }\\n        }\\n        return totalPrice / validOracles;\\n    }\\n\\n    function claim(uint256 _saleId)\\n        public\\n        virtual\\n        override\\n        nonReentrant\\n        returns (bool)\\n    {\\n        Sale storage s = sale[_msgSender()][_saleId];\\n        SaleInfo storage i = info[s.saleId];\\n\\n        require(!s.isAllocated, \\\"Error: account settlement completed\\\");\\n        require(block.timestamp > i.end, \\\"Error: sale not ended\\\");\\n\\n        uint256 _bonusTokens = resolveBonus(_saleId, _msgSender());\\n        s.bonus = _bonusTokens;\\n        s.isAllocated = true;\\n\\n        uint256 totalTokens = s.amountPurchased + _bonusTokens;\\n        uint256 orgTokens = s.amountPurchased / 100;\\n\\n        bool status = IERC20(edgexTokenContract).transfer(_msgSender(), totalTokens);\\n        bool status2 = IERC20(edgexTokenContract).transfer(organisation, orgTokens);\\n\\n        return (status && status2);\\n    }\\n\\n    /**\\n     * @dev calculates the bonus tokens for each purchase by an user.\\n     */\\n    function resolveBonus(uint256 _saleId, address _user)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        Sale storage s = sale[_user][_saleId];\\n        uint256 _bonusPercent = resolveBonusPercent(s.saleId);\\n        uint256 _bonusTokens = s.amountPurchased * _bonusPercent;\\n        _bonusTokens = _bonusTokens / 10 ** 6;\\n        return _bonusTokens;\\n    }\\n\\n    /**\\n     * @dev maps the amount of sold tokens to the bonus percent.\\n     */\\n    function resolveBonusPercent(uint256 _saleId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        SaleInfo storage i = info[_saleId];\\n        uint256 sold = i.totalPurchased * 10**6;\\n        uint256 _salePercent = sold / i.allocated;\\n\\n        if (_salePercent < 25 * 10 ** 4) {\\n            return 0;\\n        } else if (_salePercent >= 25 * 10 ** 4 && _salePercent < 50 * 10 ** 4) {\\n            return 10000;\\n        } else if (_salePercent >= 50 * 10 ** 4 && _salePercent < 75 * 10 ** 4) {\\n            return 20000;\\n        } else if (_salePercent >= 75 * 10 ** 4 && _salePercent < 100 * 10 ** 4) {\\n            return 30000;\\n        } else {\\n            return 50000;\\n        }\\n    }\\n\\n    /**\\n     * @dev can change the Chainlink EDGEX Source.\\n     *\\n     * Requirements:\\n     * `_newSource` cannot be a zero address.\\n     * `_index` should be less than 15\\n     */\\n    function updateNewEdgexSource(address _newSource, uint8 index)\\n        public\\n        virtual\\n        override\\n        onlyAdmin\\n        isZero(_newSource)\\n        returns (bool)\\n    {\\n        oracle[index] = _newSource;\\n        return true;\\n    }\\n\\n    /**\\n     * @dev transfer the control of genesis sale to another account.\\n     *\\n     * Onwers can add governors.\\n     *\\n     * Requirements:\\n     * `_newOwner` cannot be a zero address.\\n     *\\n     * CAUTION: EXECUTE THIS FUNCTION WITH CARE.\\n     */\\n    function revokeOwnership(address _newOwner)\\n        public\\n        virtual\\n        override\\n        onlyAdmin\\n        isZero(_newOwner)\\n        returns (bool)\\n    {\\n        admin = payable(_newOwner);\\n        emit RevokeOwnership(_newOwner);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev can change the Chainlink ETH Source.\\n     *\\n     * Requirements:\\n     * `_ethSource` cannot be a zero address.\\n     */\\n    function updateEthSource(address _newSource)\\n        public\\n        virtual\\n        override\\n        onlyAdmin\\n        isZero(_newSource)\\n        returns (bool)\\n    {\\n        ethPriceSource = _newSource;\\n        return true;\\n    }\\n\\n    /**\\n     * @dev can change the contract address of EDGEX tokens.\\n     *\\n     * Requirements:\\n     * `_contract` cannot be a zero address.\\n     */\\n\\n    function updateEdgexTokenContract(address _newSource)\\n        public\\n        virtual\\n        override\\n        onlyAdmin\\n        isZero(_newSource)\\n        returns (bool)\\n    {\\n        edgexTokenContract = _newSource;\\n        return true;\\n    }\\n\\n    /**\\n     * @dev can allows admin to take out the unsold tokens from the smart contract.\\n     *\\n     * Requirements:\\n     * `_caller` should be admin.\\n     * `_to` cannot be a zero address.\\n     * `_amount` should be less than the current EDGEX token balance.\\n     *\\n     * Prevents the tokens from getting locked within the smart contract.\\n     */\\n    function drain(address _to, uint256 _amount)\\n        public\\n        virtual\\n        onlyAdmin\\n        isZero(_to)\\n        returns (bool)\\n    {\\n        return IERC20(edgexTokenContract).transfer(_to, _amount);\\n    }\\n\\n    /**\\n     * @dev add an account with governor level previlages.\\n     *\\n     * Requirements:\\n     * `caller` should have admin role.\\n     * `_newGovernor` should not be a zero wallet.\\n     */\\n    function updateGovernor(address _newGovernor)\\n        public\\n        virtual\\n        onlyGovernor\\n        isZero(_newGovernor)\\n        returns (bool)\\n    {\\n        governor = _newGovernor;\\n        emit UpdateGovernor(_newGovernor);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: NO-LICENSE\\n\\npragma solidity ^0.8.4;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this;\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: NO-LICENSE\\n\\npragma solidity ^0.8.4;\\n\\nabstract contract ReentrancyGuard {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrant() {\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        _status = _ENTERED;\\n        _;\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMomentumSale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: NO-LICENSE\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of the Momentum Sale Smart Contract.\\n *\\n * Selling EDGEX tokens at a fixed price\\n * with a 1-day lock period. Users can claim their purchase after\\n * the end of 1 day or 24 hours.\\n */\\n\\ninterface IMomentumSale {\\n    /**\\n     * @dev allocates the `_allocated` amount of tokens for the current 24 hour sale.\\n     *\\n     * `_source` should be the specified as the external oracle source or the\\n     * internal fallback price.\\n     *\\n     * Requirements:\\n     * `caller` should be governor.\\n     */\\n    function createSaleContract(uint256 _allocated, uint8 _source)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev increases the number of tokens allocated for each saleId.\\n     *\\n     * Requirements:\\n     * `_saleId` should have an active ongoing sale.\\n     * Allocated cannot be increased for ended sales.\\n     *\\n     * Requirements:\\n     * `caller` should be governor.\\n     */\\n    function increaseAllocation(uint256 _amount, uint256 _saleId)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev purchases edgex tokens by calling this function with ethers.\\n     *\\n     * Requirements:\\n     * `caller` should've to be whitelisted.\\n     * there should be an active sale ongoing.\\n     * allocated tokens should be available.\\n     */\\n    function purchaseWithEth() external payable returns (bool);\\n\\n    /**\\n     * @dev allocated EDGEX tokens to users on behalf of them.\\n     * used for off-chain purchases.\\n     *\\n     * Requirements:\\n     * `_user` should be whitelisted for sale.\\n     * current sale should be live and not sold out.\\n     * `caller` should be governor.\\n     */\\n    function adminPurchase(\\n        address _user,\\n        uint256 _amountToken,\\n        uint256 _usdPurchase,\\n        uint256 _pricePurchase\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev returns the EDGEX token price.\\n     *\\n     * Based on the current business logic, EDGEX price can be an internal source\\n     * or from an external oracle.\\n     */\\n    function fetchTokenPrice() external returns (uint256);\\n\\n    function claim(uint256 _saleId) external returns (bool);\\n\\n    /**\\n     * @dev calculates the bonus tokens for each purchase by an user.\\n     */\\n    function resolveBonus(uint256 _saleId, address _user)\\n        external\\n        returns (uint256);\\n\\n    /**\\n     * @dev maps the amount of sold tokens to the bonus percent.\\n     */\\n    function resolveBonusPercent(uint256 _saleId) external returns (uint256);\\n\\n    /**\\n     * @dev can change the Chainlink EDGEX Source.\\n     *\\n     * Requirements:\\n     * `_newSource` cannot be a zero address.\\n     * `_index` should be less than 15\\n     */\\n    function updateNewEdgexSource(address _newSource, uint8 _index)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev transfer the control of genesis sale to another account.\\n     *\\n     * Onwers can add governors.\\n     *\\n     * Requirements:\\n     * `_newOwner` cannot be a zero address.\\n     *\\n     * CAUTION: EXECUTE THIS FUNCTION WITH CARE.\\n     */\\n    function revokeOwnership(address _newOwner) external returns (bool);\\n\\n    /**\\n     * @dev can change the Chainlink ETH Source.\\n     *\\n     * Requirements:\\n     * `_ethSource` cannot be a zero address.\\n     */\\n    function updateEthSource(address _newSource) external returns (bool);\\n\\n    /**\\n     * @dev can change the contract address of EDGEX tokens.\\n     *\\n     * Requirements:\\n     * `_contract` cannot be a zero address.\\n     */\\n    function updateEdgexTokenContract(address _newSource)\\n        external\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: NO-LICENSE\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev interface of Whitelist Contract.\\n */\\n\\ninterface IWhiteList {\\n    /**\\n     * @dev whitelist the `_user` for purchase.\\n     *\\n     * Requirements:\\n     * `_user` should not be a zero address.\\n     * `_user` should not be already whitelisted.\\n     *\\n     * returns a bool to represent the status of the transaction.\\n     */\\n    function whitelist(address _user) external returns (bool);\\n\\n    /**\\n     * @dev blacklists the `user` from sale.\\n     *\\n     * Requirements:\\n     * `_user` should be whitelisted before.\\n     * `_user` cannot be a zero address.\\n     *\\n     * returns a bool to represent the status of the transaction.\\n     */\\n    function blacklist(address _user) external returns (bool);\\n\\n    /**\\n     * @dev transfers the control of whitelisting to another wallet.\\n     *\\n     * Requirements:\\n     * `_newGovernor` should not be a zero address.\\n     * `caller` should be the current governor.\\n     *\\n     * returns a bool to represent the status of the transaction.\\n     */\\n    function transferGovernor(address _newGovernor) external returns (bool);\\n\\n    /**\\n     * @dev returns a bool to represent the whitelisting status of a wallet.\\n     *\\n     * true - address is whitelisted and can purchase tokens.\\n     * false - prevented from sale.\\n     */\\n    function whitelisted(address _user) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: NO-LICENSE\\n\\npragma solidity ^0.8.4;\\n\\ninterface AggregatorV3Interface {\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint256);\\n\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_organisation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ethWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pricePerToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_ethPriceSource\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whitelistOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_edgexTokenContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"RevokeOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"}],\"name\":\"UpdateGovernor\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_usdPurchase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pricePurchase\",\"type\":\"uint256\"}],\"name\":\"adminPurchase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_saleId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_allocated\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_source\",\"type\":\"uint8\"}],\"name\":\"createSaleContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"drain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"edgexTokenContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethPriceSource\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchEdgexPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchEthPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_saleId\",\"type\":\"uint256\"}],\"name\":\"increaseAllocation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"info\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPurchased\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"priceSource\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastCreated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"organisation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pricePerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purchaseWithEth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_saleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"resolveBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_saleId\",\"type\":\"uint256\"}],\"name\":\"resolveBonusPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountEther\",\"type\":\"uint256\"}],\"name\":\"resolverEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"revokeOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usdPurchase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pricePurchase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPurchased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isAllocated\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalOracles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalPurchases\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSaleContracts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newSource\",\"type\":\"address\"}],\"name\":\"updateEdgexTokenContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newSource\",\"type\":\"address\"}],\"name\":\"updateEthSource\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernor\",\"type\":\"address\"}],\"name\":\"updateGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newSource\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"updateNewEdgexSource\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MomentumSale","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000de56e66b40eee93f65daecba3eb1df93d63e9a930000000000000000000000003d749c4be39a38658e36719925b6a791f5dee9df00000000000000000000000080ca65b74d1b9fad4ff796565d78ca1da558d193000000000000000000000000cd57634625e89af44ae43222f823fb62efcd098e0000000000000000000000000000000000000000000000000000000002faf0800000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b84190000000000000000000000007adbe9c5dc7165c1418b3a6b91adc30b947b0839000000000000000000000000d61f493d18ed4c5aad0b2763d9a9b421c8da006a","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}