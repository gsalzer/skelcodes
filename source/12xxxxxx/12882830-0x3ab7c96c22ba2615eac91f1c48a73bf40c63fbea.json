{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.4.1 https://hardhat.org\r\n\r\n// File deps/@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\r\n * (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSetUpgradeable {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n\r\n// File deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\r\n\r\n\r\npragma solidity >=0.4.24 <0.7.0;\r\n\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n * \r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\r\n * \r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function _isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        address self = address(this);\r\n        uint256 cs;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { cs := extcodesize(self) }\r\n        return cs == 0;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/badger-core/BadgerRegistry.sol\r\n\r\npragma solidity >=0.6.0 <0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n// Data from Vault\r\nstruct StrategyParams {\r\n  uint256 performanceFee;\r\n  uint256 activation;\r\n  uint256 debtRatio;\r\n  uint256 minDebtPerHarvest;\r\n  uint256 maxDebtPerHarvest;\r\n  uint256 lastReport;\r\n  uint256 totalDebt;\r\n  uint256 totalGain;\r\n  uint256 totalLoss;\r\n}\r\n\r\ninterface VaultView {\r\n  function name() external view returns (string memory);\r\n  function symbol() external view returns (string memory);\r\n\r\n  function token() external view returns (address);\r\n\r\n  function strategies(address _strategy) external view returns (StrategyParams memory);\r\n\r\n\r\n  function pendingGovernance() external view returns (address);\r\n  function governance() external view returns (address);\r\n  function management() external view returns (address);\r\n  function guardian() external view returns (address);\r\n\r\n  function rewards() external view returns (address);\r\n\r\n  function withdrawalQueue(uint256 index) external view returns (address);\r\n}\r\n\r\ninterface StratView {\r\n    function name() external view returns (string memory);\r\n\r\n    function strategist() external view returns (address);\r\n    function rewards() external view returns (address);\r\n    function keeper() external view returns (address);\r\n\r\n}\r\n\r\n\r\ncontract BadgerRegistryV1 is Initializable {\r\n  using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\r\n\r\n\r\n  //@dev Multisig. Vaults from here are considered Production ready\r\n  address public governance;\r\n\r\n  //@dev Given an Author Address, and Token, Return the Vault\r\n  mapping(address => EnumerableSetUpgradeable.AddressSet) private vaults;\r\n\r\n  event NewVault(address author, address vault);\r\n  event RemoveVault(address author, address vault);\r\n  event PromoteVault(address author, address vault);\r\n\r\n  //@dev View Data for each strat we will return\r\n  struct StratInfo {\r\n    address at;\r\n    string name;\r\n\r\n    address strategist;\r\n    address rewards;\r\n    address keeper;\r\n\r\n    uint256 performanceFee;\r\n    uint256 activation;\r\n    uint256 debtRatio;\r\n    uint256 minDebtPerHarvest;\r\n    uint256 maxDebtPerHarvest;\r\n    uint256 lastReport;\r\n    uint256 totalDebt;\r\n    uint256 totalGain;\r\n    uint256 totalLoss;\r\n  }\r\n\r\n  /// Vault data we will return for each Vault\r\n  struct VaultInfo {\r\n    address at;\r\n    string name;\r\n    string symbol;\r\n    address token;\r\n    address pendingGovernance; // If this is non zero, this is an attack from the deployer\r\n    address governance;\r\n    address rewards;\r\n    address guardian;\r\n    address management;\r\n\r\n    StratInfo[] strategies;\r\n  }\r\n\r\n  function initialize(address _governance) public initializer {\r\n    governance = _governance;\r\n  }\r\n\r\n  function setGovernance(address _newGov) public {\r\n    require(msg.sender == governance, \"!gov\");\r\n    governance = _newGov;\r\n  }\r\n\r\n  /// Anyone can add a vault to here, it will be indexed by their address\r\n  function add(address vault) public {\r\n    bool added = vaults[msg.sender].add(vault);\r\n    if (added) { \r\n      emit NewVault(msg.sender, vault);\r\n    }\r\n  }\r\n\r\n  /// Remove the vault from your index\r\n  function remove(address vault) public {\r\n    bool removed = vaults[msg.sender].remove(vault);\r\n    if (removed) { \r\n      emit RemoveVault(msg.sender, vault); \r\n     }\r\n  }\r\n\r\n  //@dev Retrieve a list of all Vault Addresses from the given author\r\n  function fromAuthor(address author) public view returns (address[] memory) {\r\n    uint256 length = vaults[author].length();\r\n    address[] memory list = new address[](length);\r\n    for (uint256 i = 0; i < length; i++) {\r\n      list[i] = vaults[author].at(i);\r\n    }\r\n    return list;\r\n  }\r\n\r\n  //@dev Retrieve a list of all Vaults and the basic Vault info\r\n  function fromAuthorVaults(address author) public view returns (VaultInfo[] memory) {\r\n    uint256 length = vaults[author].length();\r\n\r\n    VaultInfo[] memory vaultData = new VaultInfo[](length);\r\n    for(uint x = 0; x < length; x++){\r\n      VaultView vault = VaultView(vaults[author].at(x));\r\n      StratInfo[] memory allStrats = new StratInfo[](0);\r\n\r\n      VaultInfo memory data = VaultInfo({\r\n        at: vaults[author].at(x),\r\n        name: vault.name(),\r\n        symbol: vault.symbol(),\r\n        token: vault.token(),\r\n        pendingGovernance: vault.pendingGovernance(),\r\n        governance: vault.governance(),\r\n        rewards: vault.rewards(),\r\n        guardian: vault.guardian(),\r\n        management: vault.management(),\r\n        strategies: allStrats\r\n      });\r\n\r\n      vaultData[x] = data;\r\n    }\r\n    return vaultData;\r\n  }\r\n\r\n\r\n  //@dev Given the Vault, retrieve all the data as well as all data related to the strategies\r\n  function fromAuthorWithDetails(address author) public view returns (VaultInfo[] memory) {\r\n    uint256 length = vaults[author].length();\r\n    VaultInfo[] memory vaultData = new VaultInfo[](length);\r\n    \r\n    for(uint x = 0; x < length; x++){\r\n      VaultView vault = VaultView(vaults[author].at(x));\r\n\r\n      // TODO: Strat Info with real data\r\n      uint stratCount = 0;\r\n      for(uint y = 0; y < 20; y++){\r\n        if(vault.withdrawalQueue(y) != address(0)){\r\n          stratCount++;\r\n        }\r\n      }\r\n      StratInfo[] memory allStrats = new StratInfo[](stratCount);\r\n\r\n      for(uint z = 0; z < stratCount; z++){\r\n        StratView strat = StratView(vault.withdrawalQueue(z));\r\n        StrategyParams memory params = vault.strategies(vault.withdrawalQueue(z));\r\n        StratInfo memory stratData = StratInfo({\r\n          at: vault.withdrawalQueue(z),\r\n          name: strat.name(),\r\n          strategist: strat.strategist(),\r\n          rewards: strat.rewards(),\r\n          keeper: strat.keeper(),\r\n\r\n          performanceFee: params.performanceFee,\r\n          activation: params.activation,\r\n          debtRatio: params.debtRatio,\r\n          minDebtPerHarvest: params.minDebtPerHarvest,\r\n          maxDebtPerHarvest: params.maxDebtPerHarvest,\r\n          lastReport: params.lastReport,\r\n          totalDebt: params.totalDebt,\r\n          totalGain: params.totalGain,\r\n          totalLoss: params.totalLoss\r\n        });\r\n        allStrats[z] = stratData;\r\n      }\r\n\r\n      VaultInfo memory data = VaultInfo({\r\n        at: vaults[author].at(x),\r\n        name: vault.name(),\r\n        symbol: vault.symbol(),\r\n        token: vault.token(),\r\n        pendingGovernance: vault.pendingGovernance(),\r\n        governance: vault.governance(),\r\n        rewards: vault.rewards(),\r\n        guardian: vault.guardian(),\r\n        management: vault.management(),\r\n        strategies: allStrats\r\n      });\r\n\r\n      vaultData[x] = data;\r\n    }\r\n\r\n    return vaultData;\r\n  }\r\n\r\n  //@dev Promote a vault to Production\r\n  //@dev Promote just means indexed by the Governance Address\r\n  function promote(address vault) public {\r\n    require(msg.sender == governance, \"!gov\");\r\n    bool promoted = vaults[msg.sender].add(vault);\r\n\r\n    if (promoted) { \r\n      emit PromoteVault(msg.sender, vault);\r\n    }\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"NewVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"PromoteVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"RemoveVault\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"}],\"name\":\"fromAuthor\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"}],\"name\":\"fromAuthorVaults\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"at\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pendingGovernance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"management\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"at\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"strategist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"performanceFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDebtPerHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDebtPerHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastReport\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalGain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLoss\",\"type\":\"uint256\"}],\"internalType\":\"struct BadgerRegistryV1.StratInfo[]\",\"name\":\"strategies\",\"type\":\"tuple[]\"}],\"internalType\":\"struct BadgerRegistryV1.VaultInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"}],\"name\":\"fromAuthorWithDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"at\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pendingGovernance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"management\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"at\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"strategist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"performanceFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDebtPerHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDebtPerHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastReport\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalGain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLoss\",\"type\":\"uint256\"}],\"internalType\":\"struct BadgerRegistryV1.StratInfo[]\",\"name\":\"strategies\",\"type\":\"tuple[]\"}],\"internalType\":\"struct BadgerRegistryV1.VaultInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"promote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGov\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BadgerRegistryV1","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://eca12b81c4ee328cefc0276d83bb6f4de7ea7a621bc3cb295b2a74bcc11a7636"}]}