{"status":"1","message":"OK","result":[{"SourceCode":"{\"Invoice.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface IERC20 {\\n    function transfer(address, uint256) external;\\n    function balanceOf(address) external view returns(uint256);\\n}\\n\\n/// @title The Invoice contract sends all tokens to the receiver and destructs himself\\n/// @author davy42\\n/// @dev The rest of ETH on the wallet will be sent to the receiver even if it\\u0027s a contract without receive function\\ncontract Invoice {\\n\\n    /// @notice Constructor\\n    /// @dev The Invoice contract has only constructor.\\n    /// @param token The address of the erc20 token contract\\n    /// @param receiver The address to which tokens will be sent\\n    /// @param amount amount of tokens\\n    constructor(IERC20 token, address payable receiver, uint256 amount) {\\n        token.transfer(receiver, amount);\\n        selfdestruct(receiver);\\n    }\\n}\\n\\n/// @title The Invoice contract sends all tokens to the receiver and destructs himself\\n/// @author davy42\\n/// @dev The rest of ETH on the wallet will be sent to the receiver even if it\\u0027s a contract without receive function\\ncontract SimpleInvoice {\\n\\n    /// @notice Constructor\\n    /// @dev The Invoice contract has only constructor.\\n    /// @param token The address of the erc20 token contract\\n    /// @param receiver The address to which tokens will be sent\\n    constructor(IERC20 token, address payable receiver) {\\n        token.transfer(receiver, token.balanceOf(address(this)));\\n        selfdestruct(receiver);\\n    }\\n}\"},\"InvoiceFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport {SimpleInvoice} from \\\"./Invoice.sol\\\";\\n\\n/// @title The InvoiceFactory allows withdrawing ERC20 tokens from a temporary Invoice\\n/// @author davy42\\n/// @notice The InvoiceFactory can compute the address for deposit and withdraw funds\\n/// @dev The InvoiceFactory use the bytecode of the Invoice contract with dynamic token and receiver addresses\\ncontract InvoiceFactory  {\\n\\n    bytes constant private invoiceCreationCode = type(SimpleInvoice).creationCode;\\n\\n    /// @notice Witdraws erc20 tokens from the deposit wallet and send to the receiver\\n    /// @param salt The unique salt\\n    /// @param token The address of the erc20 token which will be withdrawed\\n    /// @param receiver The address which will get tokens\\n    /// @return wallet the address of the wallet\\n    function withdraw(uint256 salt, address token, address receiver) external returns (address wallet) {\\n        bytes memory bytecode = getByteCode(token, receiver);\\n        assembly {\\n            wallet := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(wallet != address(0), \\\"Create2: Failed on deploy\\\");\\n    }\\n\\n    /// @notice  Returns the address of the wallet\\n    /// @dev Compute address for depositing funds using salt, token and receivers\\n    /// @param salt The unique salt\\n    /// @param token The address of the erc20 token which will be deposited\\n    /// @param receiver The address which will get tokens when withdraw\\n    /// @return wallet the address of the wallet\\n    function computeAddress(uint256 salt, address token, address receiver) public view returns (address) {\\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(getByteCode(token, receiver))));\\n        return address(uint160(uint256(_data)));\\n    }\\n\\n    /// @notice Generate the bytecode of wallet contract with token and receiver\\n    /// @dev Explain to a developer any extra details\\n    /// @param token The address of the erc20 token which will be deposited\\n    /// @param receiver The address which will get tokens when withdraw\\n    /// @return bytecode the bytecode of the wallet contract\\n    function getByteCode(address token, address receiver) private pure returns (bytes memory bytecode) {\\n        bytecode = abi.encodePacked(invoiceCreationCode, abi.encode(token, receiver));\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"computeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"InvoiceFactory","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://812457fe577ed5e153b47ee3ae307a37972734b20d1409350c59bcc6d1d19369"}]}