{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/dependencies/open-zeppelin/AccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport './Context.sol';\\nimport './Strings.sol';\\nimport './ERC165.sol';\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n  function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n  function grantRole(bytes32 role, address account) external;\\n\\n  function revokeRole(bytes32 role, address account) external;\\n\\n  function renounceRole(bytes32 role, address account) external;\\n}\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControlUpgradeable is Context, IAccessControlUpgradeable, ERC165 {\\n  struct RoleData {\\n    mapping(address => bool) members;\\n    bytes32 adminRole;\\n  }\\n\\n  mapping(bytes32 => RoleData) private _roles;\\n\\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n  /**\\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n   *\\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n   * {RoleAdminChanged} not being emitted signaling this.\\n   *\\n   * _Available since v3.1._\\n   */\\n  event RoleAdminChanged(\\n    bytes32 indexed role,\\n    bytes32 indexed previousAdminRole,\\n    bytes32 indexed newAdminRole\\n  );\\n\\n  /**\\n   * @dev Emitted when `account` is granted `role`.\\n   *\\n   * `sender` is the account that originated the contract call, an admin role\\n   * bearer except when using {_setupRole}.\\n   */\\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n  /**\\n   * @dev Emitted when `account` is revoked `role`.\\n   *\\n   * `sender` is the account that originated the contract call:\\n   *   - if using `revokeRole`, it is the admin role bearer\\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n   */\\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n  /**\\n   * @dev Modifier that checks that an account has a specific role. Reverts\\n   * with a standardized message including the required role.\\n   *\\n   * The format of the revert reason is given by the following regular expression:\\n   *\\n   *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n   *\\n   * _Available since v4.1._\\n   */\\n  modifier onlyRole(bytes32 role) {\\n    _checkRole(role, _msgSender());\\n    _;\\n  }\\n\\n  /**\\n   * @dev See {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return\\n      interfaceId == type(IAccessControlUpgradeable).interfaceId ||\\n      super.supportsInterface(interfaceId);\\n  }\\n\\n  /**\\n   * @dev Returns `true` if `account` has been granted `role`.\\n   */\\n  function hasRole(bytes32 role, address account) public view override returns (bool) {\\n    return _roles[role].members[account];\\n  }\\n\\n  /**\\n   * @dev Revert with a standard message if `account` is missing `role`.\\n   *\\n   * The format of the revert reason is given by the following regular expression:\\n   *\\n   *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n   */\\n  function _checkRole(bytes32 role, address account) internal view {\\n    if (!hasRole(role, account)) {\\n      revert(\\n        string(\\n          abi.encodePacked(\\n            'AccessControl: account ',\\n            Strings.toHexString(uint160(account), 20),\\n            ' is missing role ',\\n            Strings.toHexString(uint256(role), 32)\\n          )\\n        )\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\\n   * {revokeRole}.\\n   *\\n   * To change a role's admin, use {_setRoleAdmin}.\\n   */\\n  function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n    return _roles[role].adminRole;\\n  }\\n\\n  /**\\n   * @dev Grants `role` to `account`.\\n   *\\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\\n   * event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have ``role``'s admin role.\\n   */\\n  function grantRole(bytes32 role, address account)\\n    public\\n    virtual\\n    override\\n    onlyRole(getRoleAdmin(role))\\n  {\\n    _grantRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Revokes `role` from `account`.\\n   *\\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have ``role``'s admin role.\\n   */\\n  function revokeRole(bytes32 role, address account)\\n    public\\n    virtual\\n    override\\n    onlyRole(getRoleAdmin(role))\\n  {\\n    _revokeRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Revokes `role` from the calling account.\\n   *\\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n   * purpose is to provide a mechanism for accounts to lose their privileges\\n   * if they are compromised (such as when a trusted device is misplaced).\\n   *\\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\\n   * event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must be `account`.\\n   */\\n  function renounceRole(bytes32 role, address account) public virtual override {\\n    require(account == _msgSender(), 'AccessControl: can only renounce roles for self');\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Grants `role` to `account`.\\n   *\\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\\n   * event. Note that unlike {grantRole}, this function doesn't perform any\\n   * checks on the calling account.\\n   *\\n   * [WARNING]\\n   * ====\\n   * This function should only be called from the constructor when setting\\n   * up the initial roles for the system.\\n   *\\n   * Using this function in any other way is effectively circumventing the admin\\n   * system imposed by {AccessControl}.\\n   * ====\\n   */\\n  function _setupRole(bytes32 role, address account) internal virtual {\\n    _grantRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Sets `adminRole` as ``role``'s admin role.\\n   *\\n   * Emits a {RoleAdminChanged} event.\\n   */\\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n    emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n    _roles[role].adminRole = adminRole;\\n  }\\n\\n  function _grantRole(bytes32 role, address account) private {\\n    if (!hasRole(role, account)) {\\n      _roles[role].members[account] = true;\\n      emit RoleGranted(role, account, _msgSender());\\n    }\\n  }\\n\\n  function _revokeRole(bytes32 role, address account) private {\\n    if (hasRole(role, account)) {\\n      _roles[role].members[account] = false;\\n      emit RoleRevoked(role, account, _msgSender());\\n    }\\n  }\\n\\n  uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n  bytes16 private constant alphabet = '0123456789abcdef';\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n   */\\n  function toString(uint256 value) internal pure returns (string memory) {\\n    // Inspired by OraclizeAPI's implementation - MIT licence\\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n    if (value == 0) {\\n      return '0';\\n    }\\n    uint256 temp = value;\\n    uint256 digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n      digits -= 1;\\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n      value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n   */\\n  function toHexString(uint256 value) internal pure returns (string memory) {\\n    if (value == 0) {\\n      return '0x00';\\n    }\\n    uint256 temp = value;\\n    uint256 length = 0;\\n    while (temp != 0) {\\n      length++;\\n      temp >>= 8;\\n    }\\n    return toHexString(value, length);\\n  }\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n   */\\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n    bytes memory buffer = new bytes(2 * length + 2);\\n    buffer[0] = '0';\\n    buffer[1] = 'x';\\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\\n      buffer[i] = alphabet[value & 0xf];\\n      value >>= 4;\\n    }\\n    require(value == 0, 'Strings: hex length insufficient');\\n    return string(buffer);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport './IERC165.sol';\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n  /**\\n   * @dev See {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return interfaceId == type(IERC165).interfaceId;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/impl/LS1Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {\\n  AccessControlUpgradeable\\n} from '../../../dependencies/open-zeppelin/AccessControlUpgradeable.sol';\\nimport { ReentrancyGuard } from '../../../utils/ReentrancyGuard.sol';\\nimport { VersionedInitializable } from '../../../utils/VersionedInitializable.sol';\\nimport { LS1Types } from '../lib/LS1Types.sol';\\n\\n/**\\n * @title LS1Storage\\n * @author dYdX\\n *\\n * @dev Storage contract. Contains or inherits from all contract with storage.\\n */\\nabstract contract LS1Storage is\\n  AccessControlUpgradeable,\\n  ReentrancyGuard,\\n  VersionedInitializable\\n{\\n  // ============ Epoch Schedule ============\\n\\n  /// @dev The parameters specifying the function from timestamp to epoch number.\\n  LS1Types.EpochParameters internal _EPOCH_PARAMETERS_;\\n\\n  /// @dev The period of time at the end of each epoch in which withdrawals cannot be requested.\\n  ///  We also restrict other changes which could affect borrowers' repayment plans, such as\\n  ///  modifications to the epoch schedule, or to borrower allocations.\\n  uint256 internal _BLACKOUT_WINDOW_;\\n\\n  // ============ Staked Token ERC20 ============\\n\\n  mapping(address => mapping(address => uint256)) internal _ALLOWANCES_;\\n\\n  // ============ Rewards Accounting ============\\n\\n  /// @dev The emission rate of rewards.\\n  uint256 internal _REWARDS_PER_SECOND_;\\n\\n  /// @dev The cumulative rewards earned per staked token. (Shared storage slot.)\\n  uint224 internal _GLOBAL_INDEX_;\\n\\n  /// @dev The timestamp at which the global index was last updated. (Shared storage slot.)\\n  uint32 internal _GLOBAL_INDEX_TIMESTAMP_;\\n\\n  /// @dev The value of the global index when the user's staked balance was last updated.\\n  mapping(address => uint256) internal _USER_INDEXES_;\\n\\n  /// @dev The user's accrued, unclaimed rewards (as of the last update to the user index).\\n  mapping(address => uint256) internal _USER_REWARDS_BALANCES_;\\n\\n  /// @dev The value of the global index at the end of a given epoch.\\n  mapping(uint256 => uint256) internal _EPOCH_INDEXES_;\\n\\n  // ============ Staker Accounting ============\\n\\n  /// @dev The active balance by staker.\\n  mapping(address => LS1Types.StoredBalance) internal _ACTIVE_BALANCES_;\\n\\n  /// @dev The total active balance of stakers.\\n  LS1Types.StoredBalance internal _TOTAL_ACTIVE_BALANCE_;\\n\\n  /// @dev The inactive balance by staker.\\n  mapping(address => LS1Types.StoredBalance) internal _INACTIVE_BALANCES_;\\n\\n  /// @dev The total inactive balance of stakers. Note: The shortfallCounter field is unused.\\n  LS1Types.StoredBalance internal _TOTAL_INACTIVE_BALANCE_;\\n\\n  /// @dev Information about shortfalls that have occurred.\\n  LS1Types.Shortfall[] internal _SHORTFALLS_;\\n\\n  // ============ Borrower Accounting ============\\n\\n  /// @dev The units allocated to each borrower.\\n  /// @dev Values are represented relative to total allocation, i.e. as hundredeths of a percent.\\n  ///  Also, the total of the values contained in the mapping must always equal the total\\n  ///  allocation (i.e. must sum to 10,000).\\n  mapping(address => LS1Types.StoredAllocation) internal _BORROWER_ALLOCATIONS_;\\n\\n  /// @dev The token balance currently borrowed by the borrower.\\n  mapping(address => uint256) internal _BORROWED_BALANCES_;\\n\\n  /// @dev The total token balance currently borrowed by borrowers.\\n  uint256 internal _TOTAL_BORROWED_BALANCE_;\\n\\n  /// @dev Indicates whether a borrower is restricted from new borrowing.\\n  mapping(address => bool) internal _BORROWER_RESTRICTIONS_;\\n\\n  // ============ Debt Accounting ============\\n\\n  /// @dev The debt balance owed to each staker.\\n  mapping(address => uint256) internal _STAKER_DEBT_BALANCES_;\\n\\n  /// @dev The debt balance by borrower.\\n  mapping(address => uint256) internal _BORROWER_DEBT_BALANCES_;\\n\\n  /// @dev The total debt balance of borrowers.\\n  uint256 internal _TOTAL_BORROWER_DEBT_BALANCE_;\\n\\n  /// @dev The total debt amount repaid and not yet withdrawn.\\n  uint256 internal _TOTAL_DEBT_AVAILABLE_TO_WITHDRAW_;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\n/**\\n * @title ReentrancyGuard\\n * @author dYdX\\n *\\n * @dev Updated ReentrancyGuard library designed to be used with Proxy Contracts.\\n */\\nabstract contract ReentrancyGuard {\\n  uint256 private constant NOT_ENTERED = 1;\\n  uint256 private constant ENTERED = uint256(int256(-1));\\n\\n  uint256 private _STATUS_;\\n\\n  constructor()\\n    internal\\n  {\\n    _STATUS_ = NOT_ENTERED;\\n  }\\n\\n  modifier nonReentrant() {\\n    require(_STATUS_ != ENTERED, 'ReentrancyGuard: reentrant call');\\n    _STATUS_ = ENTERED;\\n    _;\\n    _STATUS_ = NOT_ENTERED;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/VersionedInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\n\\n/**\\n * @title VersionedInitializable\\n * @author Aave, inspired by the OpenZeppelin Initializable contract\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n *\\n */\\nabstract contract VersionedInitializable {\\n    /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n    uint256 internal lastInitializedRevision = 0;\\n\\n   /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n    modifier initializer() {\\n        uint256 revision = getRevision();\\n        require(revision > lastInitializedRevision, \\\"Contract instance has already been initialized\\\");\\n\\n        lastInitializedRevision = revision;\\n\\n        _;\\n\\n    }\\n\\n    /// @dev returns the revision number of the contract.\\n    /// Needs to be defined in the inherited class as a constant.\\n    function getRevision() internal pure virtual returns(uint256);\\n\\n\\n    // Reserved storage space to allow for layout changes in the future.\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/lib/LS1Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\n/**\\n * @title LS1Types\\n * @author dYdX\\n *\\n * @dev Structs used by the LiquidityStaking contract.\\n */\\nlibrary LS1Types {\\n  /**\\n   * @dev The parameters used to convert a timestamp to an epoch number.\\n   */\\n  struct EpochParameters {\\n    uint128 interval;\\n    uint128 offset;\\n  }\\n\\n  /**\\n   * @dev The parameters representing a shortfall event.\\n   *\\n   * @param  index  Fraction of inactive funds converted into debt, scaled by SHORTFALL_INDEX_BASE.\\n   * @param  epoch  The epoch in which the shortfall occurred.\\n   */\\n  struct Shortfall {\\n    uint16 epoch; // Note: Supports at least 1000 years given min epoch length of 6 days.\\n    uint224 index; // Note: Save on contract bytecode size by reusing uint224 instead of uint240.\\n  }\\n\\n  /**\\n   * @dev A balance, possibly with a change scheduled for the next epoch.\\n   *  Also includes cached index information for inactive balances.\\n   *\\n   * @param  currentEpoch         The epoch in which the balance was last updated.\\n   * @param  currentEpochBalance  The balance at epoch `currentEpoch`.\\n   * @param  nextEpochBalance     The balance at epoch `currentEpoch + 1`.\\n   * @param  shortfallCounter     Incrementing counter of the next shortfall index to be applied.\\n   */\\n  struct StoredBalance {\\n    uint16 currentEpoch; // Supports at least 1000 years given min epoch length of 6 days.\\n    uint112 currentEpochBalance;\\n    uint112 nextEpochBalance;\\n    uint16 shortfallCounter; // Only for staker inactive balances. At most one shortfall per epoch.\\n  }\\n\\n  /**\\n   * @dev A borrower allocation, possibly with a change scheduled for the next epoch.\\n   */\\n  struct StoredAllocation {\\n    uint16 currentEpoch; // Note: Supports at least 1000 years given min epoch length of 6 days.\\n    uint120 currentEpochAllocation;\\n    uint120 nextEpochAllocation;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/impl/LS1Getters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { Math } from '../../../utils/Math.sol';\\nimport { LS1Types } from '../lib/LS1Types.sol';\\nimport { LS1Storage } from './LS1Storage.sol';\\n\\n/**\\n * @title LS1Getters\\n * @author dYdX\\n *\\n * @dev Some external getter functions.\\n */\\nabstract contract LS1Getters is\\n  LS1Storage\\n{\\n  using SafeMath for uint256;\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice The token balance currently borrowed by the borrower.\\n   *\\n   * @param  borrower  The borrower whose balance to query.\\n   *\\n   * @return The number of tokens borrowed.\\n   */\\n  function getBorrowedBalance(\\n    address borrower\\n  )\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _BORROWED_BALANCES_[borrower];\\n  }\\n\\n  /**\\n   * @notice The total token balance borrowed by borrowers.\\n   *\\n   * @return The number of tokens borrowed.\\n   */\\n  function getTotalBorrowedBalance()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _TOTAL_BORROWED_BALANCE_;\\n  }\\n\\n  /**\\n   * @notice The debt balance owed by the borrower.\\n   *\\n   * @param  borrower  The borrower whose balance to query.\\n   *\\n   * @return The number of tokens owed.\\n   */\\n  function getBorrowerDebtBalance(\\n    address borrower\\n  )\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _BORROWER_DEBT_BALANCES_[borrower];\\n  }\\n\\n  /**\\n   * @notice The total debt balance owed by borrowers.\\n   *\\n   * @return The number of tokens owed.\\n   */\\n  function getTotalBorrowerDebtBalance()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _TOTAL_BORROWER_DEBT_BALANCE_;\\n  }\\n\\n  /**\\n   * @notice The total debt repaid by borrowers and available for stakers to withdraw.\\n   *\\n   * @return The number of tokens available.\\n   */\\n  function getTotalDebtAvailableToWithdraw()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _TOTAL_DEBT_AVAILABLE_TO_WITHDRAW_;\\n  }\\n\\n  /**\\n   * @notice Check whether a borrower is restricted from new borrowing.\\n   *\\n   * @param  borrower  The borrower to check.\\n   *\\n   * @return Boolean `true` if the borrower is restricted, otherwise `false`.\\n   */\\n  function isBorrowingRestrictedForBorrower(\\n    address borrower\\n  )\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return _BORROWER_RESTRICTIONS_[borrower];\\n  }\\n\\n  /**\\n   * @notice The parameters specifying the function from timestamp to epoch number.\\n   *\\n   * @return The parameters struct with `interval` and `offset` fields.\\n   */\\n  function getEpochParameters()\\n    external\\n    view\\n    returns (LS1Types.EpochParameters memory)\\n  {\\n    return _EPOCH_PARAMETERS_;\\n  }\\n\\n  /**\\n   * @notice The period of time at the end of each epoch in which withdrawals cannot be requested.\\n   *\\n   *  Other changes which could affect borrowers' repayment plans are also restricted during\\n   *  this period.\\n   */\\n  function getBlackoutWindow()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _BLACKOUT_WINDOW_;\\n  }\\n\\n  /**\\n   * @notice Get information about a shortfall that occurred.\\n   *\\n   * @param  shortfallCounter  The array index for the shortfall event to look up.\\n   *\\n   * @return Struct containing the epoch and shortfall index value.\\n   */\\n  function getShortfall(\\n    uint256 shortfallCounter\\n  )\\n    external\\n    view\\n    returns (LS1Types.Shortfall memory)\\n  {\\n    return _SHORTFALLS_[shortfallCounter];\\n  }\\n\\n  /**\\n   * @notice Get the number of shortfalls that have occurred.\\n   *\\n   * @return The number of shortfalls that have occurred.\\n   */\\n  function getShortfallCount()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _SHORTFALLS_.length;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts with custom message when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../dependencies/open-zeppelin/SafeMath.sol';\\n\\n/**\\n * @title Math\\n * @author dYdX\\n *\\n * @dev Library for non-standard Math functions.\\n */\\nlibrary Math {\\n  using SafeMath for uint256;\\n\\n  // ============ Library Functions ============\\n\\n  /**\\n   * @dev Return `ceil(numerator / denominator)`.\\n   */\\n  function divRoundUp(\\n    uint256 numerator,\\n    uint256 denominator\\n  )\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    if (numerator == 0) {\\n      // SafeMath will check for zero denominator\\n      return SafeMath.div(0, denominator);\\n    }\\n    return numerator.sub(1).div(denominator).add(1);\\n  }\\n\\n  /**\\n   * @dev Returns the minimum between a and b.\\n   */\\n  function min(\\n    uint256 a,\\n    uint256 b\\n  )\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the maximum between a and b.\\n   */\\n  function max(\\n    uint256 a,\\n    uint256 b\\n  )\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return a > b ? a : b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/LiquidityStakingV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n//\\n// Contracts by dYdX Foundation. Individual files are released under different licenses.\\n//\\n// https://dydx.community\\n// https://github.com/dydxfoundation/governance-contracts\\n\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { IERC20 } from '../../interfaces/IERC20.sol';\\nimport { LS1Admin } from './impl/LS1Admin.sol';\\nimport { LS1Borrowing } from './impl/LS1Borrowing.sol';\\nimport { LS1DebtAccounting } from './impl/LS1DebtAccounting.sol';\\nimport { LS1ERC20 } from './impl/LS1ERC20.sol';\\nimport { LS1Failsafe } from './impl/LS1Failsafe.sol';\\nimport { LS1Getters } from './impl/LS1Getters.sol';\\nimport { LS1Operators } from './impl/LS1Operators.sol';\\n\\n/**\\n * @title LiquidityStakingV1\\n * @author dYdX\\n *\\n * @notice Contract for staking tokens, which may then be borrowed by pre-approved borrowers.\\n *\\n *  NOTE: Most functions will revert if epoch zero has not started.\\n */\\ncontract LiquidityStakingV1 is\\n  LS1Borrowing,\\n  LS1DebtAccounting,\\n  LS1Admin,\\n  LS1Operators,\\n  LS1Getters,\\n  LS1Failsafe\\n{\\n  // ============ Constructor ============\\n\\n  constructor(\\n    IERC20 stakedToken,\\n    IERC20 rewardsToken,\\n    address rewardsTreasury,\\n    uint256 distributionStart,\\n    uint256 distributionEnd\\n  )\\n    LS1Borrowing(stakedToken, rewardsToken, rewardsTreasury, distributionStart, distributionEnd)\\n  {}\\n\\n  // ============ External Functions ============\\n\\n  function initialize(\\n    uint256 interval,\\n    uint256 offset,\\n    uint256 blackoutWindow\\n  )\\n    external\\n    initializer\\n  {\\n    __LS1Roles_init();\\n    __LS1EpochSchedule_init(interval, offset, blackoutWindow);\\n    __LS1Rewards_init();\\n    __LS1BorrowerAllocations_init();\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  /**\\n   * @dev Returns the revision of the implementation contract.\\n   *\\n   * @return The revision number.\\n   */\\n  function getRevision()\\n    internal\\n    pure\\n    override\\n    returns (uint256)\\n  {\\n    return 1;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\n\\n/**\\n* @dev Interface of the ERC20 standard as defined in the EIP.\\n*/\\ninterface IERC20 {\\n  /**\\n    * @dev Returns the amount of tokens in existence.\\n    */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n    * @dev Returns the amount of tokens owned by `account`.\\n    */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n    *\\n    * Returns a boolean value indicating whether the operation succeeded.\\n    *\\n    * Emits a {Transfer} event.\\n    */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n    * @dev Returns the remaining number of tokens that `spender` will be\\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n    * zero by default.\\n    *\\n    * This value changes when {approve} or {transferFrom} are called.\\n    */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n    * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    *\\n    * Returns a boolean value indicating whether the operation succeeded.\\n    *\\n    * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n    * that someone may use both the old and the new allowance by unfortunate\\n    * transaction ordering. One possible solution to mitigate this race\\n    * condition is to first reduce the spender's allowance to 0 and set the\\n    * desired value afterwards:\\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    *\\n    * Emits an {Approval} event.\\n    */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n    * allowance mechanism. `amount` is then deducted from the caller's\\n    * allowance.\\n    *\\n    * Returns a boolean value indicating whether the operation succeeded.\\n    *\\n    * Emits a {Transfer} event.\\n    */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n    * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n    * another (`to`).\\n    *\\n    * Note that `value` may be zero.\\n    */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n    * a call to {approve}. `value` is the new allowance.\\n    */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/impl/LS1Admin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { LS1Types } from '../lib/LS1Types.sol';\\nimport { SafeCast } from '../lib/SafeCast.sol';\\nimport { LS1Borrowing } from './LS1Borrowing.sol';\\n\\n/**\\n * @title LS1Admin\\n * @author dYdX\\n *\\n * @dev Admin-only functions.\\n */\\nabstract contract LS1Admin is\\n  LS1Borrowing\\n{\\n  using SafeCast for uint256;\\n  using SafeMath for uint256;\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Set the parameters defining the function from timestamp to epoch number.\\n   *\\n   *  The formula used is `n = floor((t - b) / a)` where:\\n   *    - `n` is the epoch number\\n   *    - `t` is the timestamp (in seconds)\\n   *    - `b` is a non-negative offset, indicating the start of epoch zero (in seconds)\\n   *    - `a` is the length of an epoch, a.k.a. the interval (in seconds)\\n   *\\n   *  Reverts if epoch zero already started, and the new parameters would change the current epoch.\\n   *  Reverts if epoch zero has not started, but would have had started under the new parameters.\\n   *  Reverts if the new interval is less than twice the blackout window.\\n   *\\n   * @param  interval  The length `a` of an epoch, in seconds.\\n   * @param  offset    The offset `b`, i.e. the start of epoch zero, in seconds.\\n   */\\n  function setEpochParameters(\\n    uint256 interval,\\n    uint256 offset\\n  )\\n    external\\n    onlyRole(EPOCH_PARAMETERS_ROLE)\\n    nonReentrant\\n  {\\n    if (!hasEpochZeroStarted()) {\\n      require(block.timestamp < offset, 'LS1Admin: Started epoch zero');\\n      _setEpochParameters(interval, offset);\\n      return;\\n    }\\n\\n    // Require that we are not currently in a blackout window.\\n    require(\\n      !inBlackoutWindow(),\\n      'LS1Admin: Blackout window'\\n    );\\n\\n    // We must settle the total active balance to ensure the index is recorded at the epoch\\n    // boundary as needed, before we make any changes to the epoch formula.\\n    _settleTotalActiveBalance();\\n\\n    // Update the epoch parameters. Require that the current epoch number is unchanged.\\n    uint256 originalCurrentEpoch = getCurrentEpoch();\\n    _setEpochParameters(interval, offset);\\n    uint256 newCurrentEpoch = getCurrentEpoch();\\n    require(originalCurrentEpoch == newCurrentEpoch, 'LS1Admin: Changed epochs');\\n\\n    // Require that the new parameters don't put us in a blackout window.\\n    require(!inBlackoutWindow(), 'LS1Admin: End in blackout window');\\n  }\\n\\n  /**\\n   * @notice Set the blackout window, during which one cannot request withdrawals of staked funds.\\n   */\\n  function setBlackoutWindow(\\n    uint256 blackoutWindow\\n  )\\n    external\\n    onlyRole(EPOCH_PARAMETERS_ROLE)\\n    nonReentrant\\n  {\\n    require(\\n      !inBlackoutWindow(),\\n      'LS1Admin: Blackout window'\\n    );\\n    _setBlackoutWindow(blackoutWindow);\\n\\n    // Require that the new parameters don't put us in a blackout window.\\n    require(!inBlackoutWindow(), 'LS1Admin: End in blackout window');\\n  }\\n\\n  /**\\n   * @notice Set the emission rate of rewards.\\n   *\\n   * @param  emissionPerSecond  The new number of rewards tokens given out per second.\\n   */\\n  function setRewardsPerSecond(\\n    uint256 emissionPerSecond\\n  )\\n    external\\n    onlyRole(REWARDS_RATE_ROLE)\\n    nonReentrant\\n  {\\n    uint256 totalStaked = 0;\\n    if (hasEpochZeroStarted()) {\\n      // We must settle the total active balance to ensure the index is recorded at the epoch\\n      // boundary as needed, before we make any changes to the emission rate.\\n      totalStaked = _settleTotalActiveBalance();\\n    }\\n    _setRewardsPerSecond(emissionPerSecond, totalStaked);\\n  }\\n\\n  /**\\n   * @notice Change the allocations of certain borrowers. Can be used to add and remove borrowers.\\n   *  Increases take effect in the next epoch, but decreases will restrict borrowing immediately.\\n   *  This function cannot be called during the blackout window.\\n   *\\n   * @param  borrowers       Array of borrower addresses.\\n   * @param  newAllocations  Array of new allocations per borrower, as hundredths of a percent.\\n   */\\n  function setBorrowerAllocations(\\n    address[] calldata borrowers,\\n    uint256[] calldata newAllocations\\n  )\\n    external\\n    onlyRole(BORROWER_ADMIN_ROLE)\\n    nonReentrant\\n  {\\n    require(borrowers.length == newAllocations.length, 'LS1Admin: Params length mismatch');\\n    require(\\n      !inBlackoutWindow(),\\n      'LS1Admin: Blackout window'\\n    );\\n    _setBorrowerAllocations(borrowers, newAllocations);\\n  }\\n\\n  function setBorrowingRestriction(\\n    address borrower,\\n    bool isBorrowingRestricted\\n  )\\n    external\\n    onlyRole(BORROWER_ADMIN_ROLE)\\n    nonReentrant\\n  {\\n    _setBorrowingRestriction(borrower, isBorrowingRestricted);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/impl/LS1Borrowing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeERC20 } from '../../../dependencies/open-zeppelin/SafeERC20.sol';\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { Math } from '../../../utils/Math.sol';\\nimport { LS1Types } from '../lib/LS1Types.sol';\\nimport { SafeCast } from '../lib/SafeCast.sol';\\nimport { LS1BorrowerAllocations } from './LS1BorrowerAllocations.sol';\\nimport { LS1Staking } from './LS1Staking.sol';\\n\\n/**\\n * @title LS1Borrowing\\n * @author dYdX\\n *\\n * @dev External functions for borrowers. See LS1BorrowerAllocations for details on\\n *  borrower accounting.\\n */\\nabstract contract LS1Borrowing is\\n  LS1Staking,\\n  LS1BorrowerAllocations\\n{\\n  using SafeCast for uint256;\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint256;\\n\\n  // ============ Events ============\\n\\n  event Borrowed(\\n    address indexed borrower,\\n    uint256 amount,\\n    uint256 newBorrowedBalance\\n  );\\n\\n  event RepaidBorrow(\\n    address indexed borrower,\\n    address sender,\\n    uint256 amount,\\n    uint256 newBorrowedBalance\\n  );\\n\\n  event RepaidDebt(\\n    address indexed borrower,\\n    address sender,\\n    uint256 amount,\\n    uint256 newDebtBalance\\n  );\\n\\n  // ============ Constructor ============\\n\\n  constructor(\\n    IERC20 stakedToken,\\n    IERC20 rewardsToken,\\n    address rewardsTreasury,\\n    uint256 distributionStart,\\n    uint256 distributionEnd\\n  )\\n    LS1Staking(stakedToken, rewardsToken, rewardsTreasury, distributionStart, distributionEnd)\\n  {}\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Borrow staked funds.\\n   *\\n   * @param  amount  The token amount to borrow.\\n   */\\n  function borrow(\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n  {\\n    require(amount > 0, 'LS1Borrowing: Cannot borrow zero');\\n\\n    address borrower = msg.sender;\\n\\n    // Revert if the borrower is restricted.\\n    require(!_BORROWER_RESTRICTIONS_[borrower], 'LS1Borrowing: Restricted');\\n\\n    // Get contract available amount and revert if there is not enough to withdraw.\\n    uint256 totalAvailableForBorrow = getContractBalanceAvailableToBorrow();\\n    require(\\n      amount <= totalAvailableForBorrow,\\n      'LS1Borrowing: Amount > available'\\n    );\\n\\n    // Get new net borrow and revert if it is greater than the allocated balance for new borrowing.\\n    uint256 newBorrowedBalance = _BORROWED_BALANCES_[borrower].add(amount);\\n    require(\\n      newBorrowedBalance <= _getAllocatedBalanceForNewBorrowing(borrower),\\n      'LS1Borrowing: Amount > allocated'\\n    );\\n\\n    // Update storage.\\n    _BORROWED_BALANCES_[borrower] = newBorrowedBalance;\\n    _TOTAL_BORROWED_BALANCE_ = _TOTAL_BORROWED_BALANCE_.add(amount);\\n\\n    // Transfer token to the borrower.\\n    STAKED_TOKEN.safeTransfer(borrower, amount);\\n\\n    emit Borrowed(borrower, amount, newBorrowedBalance);\\n  }\\n\\n  /**\\n   * @notice Repay borrowed funds for the specified borrower. Reverts if repay amount exceeds\\n   *  borrowed amount.\\n   *\\n   * @param  borrower  The borrower on whose behalf to make a repayment.\\n   * @param  amount    The amount to repay.\\n   */\\n  function repayBorrow(\\n    address borrower,\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n  {\\n    require(amount > 0, 'LS1Borrowing: Cannot repay zero');\\n\\n    uint256 oldBorrowedBalance = _BORROWED_BALANCES_[borrower];\\n    require(amount <= oldBorrowedBalance, 'LS1Borrowing: Repay > borrowed');\\n    uint256 newBorrowedBalance = oldBorrowedBalance.sub(amount);\\n\\n    // Update storage.\\n    _BORROWED_BALANCES_[borrower] = newBorrowedBalance;\\n    _TOTAL_BORROWED_BALANCE_ = _TOTAL_BORROWED_BALANCE_.sub(amount);\\n\\n    // Transfer token from the sender.\\n    STAKED_TOKEN.safeTransferFrom(msg.sender, address(this), amount);\\n\\n    emit RepaidBorrow(borrower, msg.sender, amount, newBorrowedBalance);\\n  }\\n\\n  /**\\n   * @notice Repay a debt amount owed by a borrower.\\n   *\\n   * @param  borrower  The borrower whose debt to repay.\\n   * @param  amount    The amount to repay.\\n   */\\n  function repayDebt(\\n    address borrower,\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n  {\\n    require(amount > 0, 'LS1Borrowing: Cannot repay zero');\\n\\n    uint256 oldDebtAmount = _BORROWER_DEBT_BALANCES_[borrower];\\n    require(amount <= oldDebtAmount, 'LS1Borrowing: Repay > debt');\\n    uint256 newDebtBalance = oldDebtAmount.sub(amount);\\n\\n    // Update storage.\\n    _BORROWER_DEBT_BALANCES_[borrower] = newDebtBalance;\\n    _TOTAL_BORROWER_DEBT_BALANCE_ = _TOTAL_BORROWER_DEBT_BALANCE_.sub(amount);\\n    _TOTAL_DEBT_AVAILABLE_TO_WITHDRAW_ = _TOTAL_DEBT_AVAILABLE_TO_WITHDRAW_.add(amount);\\n\\n    // Transfer token from the sender.\\n    STAKED_TOKEN.safeTransferFrom(msg.sender, address(this), amount);\\n\\n    emit RepaidDebt(borrower, msg.sender, amount, newDebtBalance);\\n  }\\n\\n  /**\\n   * @notice Get the max additional amount that the borrower can borrow.\\n   *\\n   * @return The max additional amount that the borrower can borrow right now.\\n   */\\n  function getBorrowableAmount(\\n    address borrower\\n  )\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    if (_BORROWER_RESTRICTIONS_[borrower]) {\\n      return 0;\\n    }\\n\\n    // Get the remaining unused allocation for the borrower.\\n    uint256 oldBorrowedBalance = _BORROWED_BALANCES_[borrower];\\n    uint256 borrowerAllocatedBalance = _getAllocatedBalanceForNewBorrowing(borrower);\\n    if (borrowerAllocatedBalance <= oldBorrowedBalance) {\\n      return 0;\\n    }\\n    uint256 borrowerRemainingAllocatedBalance = borrowerAllocatedBalance.sub(oldBorrowedBalance);\\n\\n    // Don't allow new borrowing to take out funds that are reserved for debt or inactive balances.\\n    // Typically, this will not be the limiting factor, but it can be.\\n    uint256 totalAvailableForBorrow = getContractBalanceAvailableToBorrow();\\n\\n    return Math.min(borrowerRemainingAllocatedBalance, totalAvailableForBorrow);\\n  }\\n\\n  // ============ Public Functions ============\\n\\n  /**\\n   * @notice Get the funds currently available in the contract for borrowing.\\n   *\\n   * @return The amount of non-debt, non-inactive funds in the contract.\\n   */\\n  function getContractBalanceAvailableToBorrow()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    uint256 availableStake = getContractBalanceAvailableToWithdraw();\\n    uint256 inactiveBalance = getTotalInactiveBalanceCurrentEpoch();\\n    // Note: The funds available to withdraw may be less than the inactive balance.\\n    if (availableStake <= inactiveBalance) {\\n      return 0;\\n    }\\n    return availableStake.sub(inactiveBalance);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/impl/LS1DebtAccounting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeERC20 } from '../../../dependencies/open-zeppelin/SafeERC20.sol';\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { Math } from '../../../utils/Math.sol';\\nimport { LS1Types } from '../lib/LS1Types.sol';\\nimport { LS1BorrowerAllocations } from './LS1BorrowerAllocations.sol';\\n\\n/**\\n * @title LS1DebtAccounting\\n * @author dYdX\\n *\\n * @dev Allows converting an overdue balance into \\\"debt\\\", which is accounted for separately from\\n *  the staked and borrowed balances. This allows the system to rebalance/restabilize itself in the\\n *  case where a borrower fails to return borrowed funds on time.\\n *\\n *  The shortfall debt calculation is as follows:\\n *\\n *    - Let A be the total active balance.\\n *    - Let B be the total borrowed balance.\\n *    - Let X be the total inactive balance.\\n *    - Then, a shortfall occurs if at any point B > A.\\n *    - The shortfall debt amount is `D = B - A`\\n *    - The borrowed balances are decreased by `B_new = B - D`\\n *    - The inactive balances are decreased by `X_new = X - D`\\n *    - The shortfall index is recorded as `Y = X_new / X`\\n *    - The borrower and staker debt balances are increased by `D`\\n *\\n *  Note that `A + X >= B` (The active and inactive balances are at least the borrowed balance.)\\n *  This implies that `X >= D` (The inactive balance is always at least the shortfall debt.)\\n */\\nabstract contract LS1DebtAccounting is\\n  LS1BorrowerAllocations\\n{\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint256;\\n  using Math for uint256;\\n\\n  // ============ Events ============\\n\\n  event ConvertedInactiveBalancesToDebt(\\n    uint256 shortfallAmount,\\n    uint256 shortfallIndex,\\n    uint256 newInactiveBalance\\n  );\\n\\n  event DebtMarked(\\n    address indexed borrower,\\n    uint256 amount,\\n    uint256 newBorrowedBalance,\\n    uint256 newDebtBalance\\n  );\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Restrict a borrower from borrowing. The borrower must have exceeded their borrowing\\n   *  allocation. Can be called by anyone.\\n   *\\n   *  Unlike markDebt(), this function can be called even if the contract in TOTAL is not insolvent.\\n   */\\n  function restrictBorrower(\\n    address borrower\\n  )\\n    external\\n    nonReentrant\\n  {\\n    require(\\n      isBorrowerOverdue(borrower),\\n      'LS1DebtAccounting: Borrower not overdue'\\n    );\\n    _setBorrowingRestriction(borrower, true);\\n  }\\n\\n  /**\\n   * @notice Convert the shortfall amount between the active and borrowed balances into “debt.”\\n   *\\n   *  The function determines the size of the debt, and then does the following:\\n   *   - Assign the debt to borrowers, taking the same amount out of their borrowed balance.\\n   *   - Impose borrow restrictions on borrowers to whom the debt was assigned.\\n   *   - Socialize the loss pro-rata across inactive balances. Each balance with a loss receives\\n   *     an equal amount of debt balance that can be withdrawn as debts are repaid.\\n   *\\n   * @param  borrowers  A list of borrowers who are responsible for the full shortfall amount.\\n   *\\n   * @return The shortfall debt amount.\\n   */\\n  function markDebt(\\n    address[] calldata borrowers\\n  )\\n    external\\n    nonReentrant\\n    returns (uint256)\\n  {\\n    // The debt is equal to the difference between the total active and total borrowed balances.\\n    uint256 totalActiveCurrent = getTotalActiveBalanceCurrentEpoch();\\n    uint256 totalBorrowed = _TOTAL_BORROWED_BALANCE_;\\n    require(totalBorrowed > totalActiveCurrent, 'LS1DebtAccounting: No shortfall');\\n    uint256 shortfallDebt = totalBorrowed.sub(totalActiveCurrent);\\n\\n    // Attribute debt to borrowers.\\n    _attributeDebtToBorrowers(shortfallDebt, totalActiveCurrent, borrowers);\\n\\n    // Apply the debt to inactive balances, moving the same amount into users debt balances.\\n    _convertInactiveBalanceToDebt(shortfallDebt);\\n\\n    return shortfallDebt;\\n  }\\n\\n  // ============ Public Functions ============\\n\\n  /**\\n   * @notice Whether the borrower is overdue on a payment, and is currently subject to having their\\n   *  borrowing rights revoked.\\n   *\\n   * @param  borrower  The borrower to check.\\n   */\\n  function isBorrowerOverdue(\\n    address borrower\\n  )\\n    public\\n    view\\n    returns (bool)\\n  {\\n    uint256 allocatedBalance = getAllocatedBalanceCurrentEpoch(borrower);\\n    uint256 borrowedBalance = _BORROWED_BALANCES_[borrower];\\n    return borrowedBalance > allocatedBalance;\\n  }\\n\\n  // ============ Private Functions ============\\n\\n  /**\\n   * @dev Helper function to partially or fully convert inactive balances to debt.\\n   *\\n   * @param  shortfallDebt  The shortfall amount: borrowed balances less active balances.\\n   */\\n  function _convertInactiveBalanceToDebt(\\n    uint256 shortfallDebt\\n  )\\n    private\\n  {\\n    // Get the total inactive balance.\\n    uint256 oldInactiveBalance = getTotalInactiveBalanceCurrentEpoch();\\n\\n    // Calculate the index factor for the shortfall.\\n    uint256 newInactiveBalance = 0;\\n    uint256 shortfallIndex = 0;\\n    if (oldInactiveBalance > shortfallDebt) {\\n      newInactiveBalance = oldInactiveBalance.sub(shortfallDebt);\\n      shortfallIndex = SHORTFALL_INDEX_BASE.mul(newInactiveBalance).div(oldInactiveBalance);\\n    }\\n\\n    // Get the shortfall amount applied to inactive balances.\\n    uint256 shortfallAmount = oldInactiveBalance.sub(newInactiveBalance);\\n\\n    // Apply the loss. This moves the debt from stakers' inactive balances to their debt balances.\\n    _applyShortfall(shortfallAmount, shortfallIndex);\\n    emit ConvertedInactiveBalancesToDebt(shortfallAmount, shortfallIndex, newInactiveBalance);\\n  }\\n\\n  /**\\n   * @dev Helper function to attribute debt to borrowers, adding it to their debt balances.\\n   *\\n   * @param  shortfallDebt       The shortfall amount: borrowed balances less active balances.\\n   * @param  totalActiveCurrent  The total active balance for the current epoch.\\n   * @param  borrowers           A list of borrowers responsible for the full shortfall amount.\\n   */\\n  function _attributeDebtToBorrowers(\\n    uint256 shortfallDebt,\\n    uint256 totalActiveCurrent,\\n    address[] calldata borrowers\\n  ) private {\\n    // Find borrowers to attribute the total debt amount to. The sum of all borrower shortfalls is\\n    // always at least equal to the overall shortfall, so it is always possible to specify a list\\n    // of borrowers whose excess borrows cover the full shortfall amount.\\n    //\\n    // Denominate values in “points” scaled by TOTAL_ALLOCATION to avoid rounding.\\n    uint256 debtToBeAttributedPoints = shortfallDebt.mul(TOTAL_ALLOCATION);\\n    uint256 shortfallDebtAfterRounding = 0;\\n    for (uint256 i = 0; i < borrowers.length; i++) {\\n      address borrower = borrowers[i];\\n      uint256 borrowedBalanceTokenAmount = _BORROWED_BALANCES_[borrower];\\n      uint256 borrowedBalancePoints = borrowedBalanceTokenAmount.mul(TOTAL_ALLOCATION);\\n      uint256 allocationPoints = getAllocationFractionCurrentEpoch(borrower);\\n      uint256 allocatedBalancePoints = totalActiveCurrent.mul(allocationPoints);\\n\\n      // Skip this borrower if they have not exceeded their allocation.\\n      if (borrowedBalancePoints <= allocatedBalancePoints) {\\n        continue;\\n      }\\n\\n      // Calculate the borrower's debt, and limit to the remaining amount to be allocated.\\n      uint256 borrowerDebtPoints = borrowedBalancePoints.sub(allocatedBalancePoints);\\n      borrowerDebtPoints = Math.min(borrowerDebtPoints, debtToBeAttributedPoints);\\n\\n      // Move the debt from the borrowers' borrowed balance to the debt balance. Rounding may occur\\n      // when converting from “points” to tokens. We round up to ensure the final borrowed balance\\n      // is not greater than the allocated balance.\\n      uint256 borrowerDebtTokenAmount = borrowerDebtPoints.divRoundUp(TOTAL_ALLOCATION);\\n      uint256 newDebtBalance = _BORROWER_DEBT_BALANCES_[borrower].add(borrowerDebtTokenAmount);\\n      uint256 newBorrowedBalance = borrowedBalanceTokenAmount.sub(borrowerDebtTokenAmount);\\n      _BORROWER_DEBT_BALANCES_[borrower] = newDebtBalance;\\n      _BORROWED_BALANCES_[borrower] = newBorrowedBalance;\\n      emit DebtMarked(borrower, borrowerDebtTokenAmount, newBorrowedBalance, newDebtBalance);\\n      shortfallDebtAfterRounding = shortfallDebtAfterRounding.add(borrowerDebtTokenAmount);\\n\\n      // Restrict the borrower from further borrowing.\\n      _setBorrowingRestriction(borrower, true);\\n\\n      // Update the remaining amount to allocate.\\n      debtToBeAttributedPoints = debtToBeAttributedPoints.sub(borrowerDebtPoints);\\n\\n      // Exit early if all debt was allocated.\\n      if (debtToBeAttributedPoints == 0) {\\n        break;\\n      }\\n    }\\n\\n    // Require the borrowers to cover the full debt amount. This should always be possible.\\n    require(\\n      debtToBeAttributedPoints == 0,\\n      'LS1DebtAccounting: Borrowers do not cover the shortfall'\\n    );\\n\\n    // Move the debt from the total borrowed balance to the total debt balance.\\n    _TOTAL_BORROWED_BALANCE_ = _TOTAL_BORROWED_BALANCE_.sub(shortfallDebtAfterRounding);\\n    _TOTAL_BORROWER_DEBT_BALANCE_ = _TOTAL_BORROWER_DEBT_BALANCE_.add(shortfallDebtAfterRounding);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/impl/LS1ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IERC20Detailed } from '../../../interfaces/IERC20Detailed.sol';\\nimport { LS1Types } from '../lib/LS1Types.sol';\\nimport { LS1StakedBalances } from './LS1StakedBalances.sol';\\n\\n/**\\n * @title LS1ERC20\\n * @author dYdX\\n *\\n * @dev ERC20 interface for staked tokens. Allows a user with an active stake to transfer their\\n *  staked tokens to another user, even if they would otherwise be restricted from withdrawing.\\n */\\nabstract contract LS1ERC20 is\\n  LS1StakedBalances,\\n  IERC20Detailed\\n{\\n  using SafeMath for uint256;\\n\\n  // ============ External Functions ============\\n\\n  function name()\\n    external\\n    pure\\n    override\\n    returns (string memory)\\n  {\\n    return 'dYdX Staked USDC';\\n  }\\n\\n  function symbol()\\n    external\\n    pure\\n    override\\n    returns (string memory)\\n  {\\n    return 'stkUSDC';\\n  }\\n\\n  function decimals()\\n    external\\n    pure\\n    override\\n    returns (uint8)\\n  {\\n    return 6;\\n  }\\n\\n  /**\\n   * @notice Get the total supply of `STAKED_TOKEN` staked to the contract.\\n   *  This value is calculated from adding the active + inactive balances of\\n   *  this current epoch.\\n   *\\n   * @return The total staked balance of this contract.\\n   */\\n  function totalSupply()\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return getTotalActiveBalanceCurrentEpoch() + getTotalInactiveBalanceCurrentEpoch();\\n  }\\n\\n  /**\\n   * @notice Get the current balance of `STAKED_TOKEN` the user has staked to the contract.\\n   *  This value includes the users active + inactive balances, but note that only\\n   *  their active balance in the next epoch is transferable.\\n   *\\n   * @param  account  The account to get the balance of.\\n   *\\n   * @return The user's balance.\\n   */\\n  function balanceOf(\\n    address account\\n  )\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return getActiveBalanceCurrentEpoch(account) + getInactiveBalanceCurrentEpoch(account);\\n  }\\n\\n  function transfer(\\n    address recipient,\\n    uint256 amount\\n  )\\n    external\\n    override\\n    nonReentrant\\n    returns (bool)\\n  {\\n    _transfer(msg.sender, recipient, amount);\\n    return true;\\n  }\\n\\n  function allowance(\\n    address owner,\\n    address spender\\n  )\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return _ALLOWANCES_[owner][spender];\\n  }\\n\\n  function approve(\\n    address spender,\\n    uint256 amount\\n  )\\n    external\\n    override\\n    returns (bool)\\n  {\\n    _approve(msg.sender, spender, amount);\\n    return true;\\n  }\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  )\\n    external\\n    override\\n    nonReentrant\\n    returns (bool)\\n  {\\n    _transfer(sender, recipient, amount);\\n    _approve(\\n      sender,\\n      msg.sender,\\n      _ALLOWANCES_[sender][msg.sender].sub(amount, 'LS1ERC20: transfer amount exceeds allowance')\\n    );\\n    return true;\\n  }\\n\\n  function increaseAllowance(\\n    address spender,\\n    uint256 addedValue\\n  )\\n    external\\n    returns (bool)\\n  {\\n    _approve(msg.sender, spender, _ALLOWANCES_[msg.sender][spender].add(addedValue));\\n    return true;\\n  }\\n\\n  function decreaseAllowance(\\n    address spender,\\n    uint256 subtractedValue\\n  )\\n    external\\n    returns (bool)\\n  {\\n    _approve(\\n      msg.sender,\\n      spender,\\n      _ALLOWANCES_[msg.sender][spender].sub(\\n        subtractedValue,\\n        'LS1ERC20: Decreased allowance below zero'\\n      )\\n    );\\n    return true;\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  function _transfer(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  )\\n    internal\\n  {\\n    require(sender != address(0), 'LS1ERC20: Transfer from address(0)');\\n    require(recipient != address(0), 'LS1ERC20: Transfer to address(0)');\\n    require(\\n      getTransferableBalance(sender) >= amount,\\n      'LS1ERC20: Transfer exceeds next epoch active balance'\\n    );\\n\\n    _transferCurrentAndNextActiveBalance(sender, recipient, amount);\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  function _approve(\\n    address owner,\\n    address spender,\\n    uint256 amount\\n  )\\n    internal\\n  {\\n    require(owner != address(0), 'LS1ERC20: Approve from address(0)');\\n    require(spender != address(0), 'LS1ERC20: Approve to address(0)');\\n\\n    _ALLOWANCES_[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/impl/LS1Failsafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { LS1Types } from '../lib/LS1Types.sol';\\nimport { SafeCast } from '../lib/SafeCast.sol';\\nimport { LS1StakedBalances } from './LS1StakedBalances.sol';\\n\\n/**\\n * @title LS1Failsafe\\n * @author dYdX\\n *\\n * @dev Functions for recovering from very unlikely edge cases.\\n */\\nabstract contract LS1Failsafe is\\n  LS1StakedBalances\\n{\\n  using SafeCast for uint256;\\n  using SafeMath for uint256;\\n\\n  /**\\n   * @notice Settle the sender's inactive balance up to the specified epoch. This allows the\\n   *  balance to be settled while putting an upper bound on the gas expenditure per function call.\\n   *  This is unlikely to be needed in practice.\\n   *\\n   * @param  maxEpoch  The epoch to settle the sender's inactive balance up to.\\n   */\\n  function failsafeSettleUserInactiveBalanceToEpoch(\\n    uint256 maxEpoch\\n  )\\n    external\\n    nonReentrant\\n  {\\n    address staker = msg.sender;\\n    _failsafeSettleUserInactiveBalance(staker, maxEpoch);\\n  }\\n\\n  /**\\n   * @notice Sets the sender's inactive balance to zero. This allows for recovery from a situation\\n   *  where the gas cost to settle the balance is higher than the value of the balance itself.\\n   *  We provide this function as an alternative to settlement, since the gas cost for settling an\\n   *  inactive balance is unbounded (except in that it may grow at most linearly with the number of\\n   *  epochs that have passed).\\n   */\\n  function failsafeDeleteUserInactiveBalance()\\n    external\\n    nonReentrant\\n  {\\n    address staker = msg.sender;\\n    _failsafeDeleteUserInactiveBalance(staker);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/impl/LS1Operators.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { LS1Staking } from './LS1Staking.sol';\\n\\n/**\\n * @title LS1Operators\\n * @author dYdX\\n *\\n * @dev Actions which may be called by authorized operators, nominated by the contract owner.\\n *\\n *  There are three types of operators. These should be smart contracts, which can be used to\\n *  provide additional functionality to users:\\n *\\n *  STAKE_OPERATOR_ROLE:\\n *\\n *    This operator is allowed to request withdrawals and withdraw funds on behalf of stakers. This\\n *    role could be used by a smart contract to provide a staking interface with additional\\n *    features, for example, optional lock-up periods that pay out additional rewards (from a\\n *    separate rewards pool).\\n *\\n *  CLAIM_OPERATOR_ROLE:\\n *\\n *    This operator is allowed to claim rewards on behalf of stakers. This role could be used by a\\n *    smart contract to provide an interface for claiming rewards from multiple incentive programs\\n *    at once.\\n *\\n *  DEBT_OPERATOR_ROLE:\\n *\\n *    This operator is allowed to decrease staker and borrower debt balances. Typically, each change\\n *    to a staker debt balance should be offset by a corresponding change in a borrower debt\\n *    balance, but this is not strictly required. This role could used by a smart contract to\\n *    tokenize debt balances or to provide a pro-rata distribution to debt holders, for example.\\n */\\nabstract contract LS1Operators is\\n  LS1Staking\\n{\\n  using SafeMath for uint256;\\n\\n  // ============ Events ============\\n\\n  event OperatorStakedFor(\\n    address indexed staker,\\n    uint256 amount,\\n    address operator\\n  );\\n\\n  event OperatorWithdrawalRequestedFor(\\n    address indexed staker,\\n    uint256 amount,\\n    address operator\\n  );\\n\\n  event OperatorWithdrewStakeFor(\\n    address indexed staker,\\n    address recipient,\\n    uint256 amount,\\n    address operator\\n  );\\n\\n  event OperatorClaimedRewardsFor(\\n    address indexed staker,\\n    address recipient,\\n    uint256 claimedRewards,\\n    address operator\\n  );\\n\\n  event OperatorDecreasedStakerDebt(\\n    address indexed staker,\\n    uint256 amount,\\n    uint256 newDebtBalance,\\n    address operator\\n  );\\n\\n  event OperatorDecreasedBorrowerDebt(\\n    address indexed borrower,\\n    uint256 amount,\\n    uint256 newDebtBalance,\\n    address operator\\n  );\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Request a withdrawal on behalf of a staker.\\n   *\\n   *  Reverts if we are currently in the blackout window.\\n   *\\n   * @param  staker  The staker whose stake to request a withdrawal for.\\n   * @param  amount  The amount to move from the active to the inactive balance.\\n   */\\n  function requestWithdrawalFor(\\n    address staker,\\n    uint256 amount\\n  )\\n    external\\n    onlyRole(STAKE_OPERATOR_ROLE)\\n    nonReentrant\\n  {\\n    _requestWithdrawal(staker, amount);\\n    emit OperatorWithdrawalRequestedFor(staker, amount, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Withdraw a staker's stake, and send to the specified recipient.\\n   *\\n   * @param  staker     The staker whose stake to withdraw.\\n   * @param  recipient  The address that should receive the funds.\\n   * @param  amount     The amount to withdraw from the staker's inactive balance.\\n   */\\n  function withdrawStakeFor(\\n    address staker,\\n    address recipient,\\n    uint256 amount\\n  )\\n    external\\n    onlyRole(STAKE_OPERATOR_ROLE)\\n    nonReentrant\\n  {\\n    _withdrawStake(staker, recipient, amount);\\n    emit OperatorWithdrewStakeFor(staker, recipient, amount, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Claim rewards on behalf of a staker, and send them to the specified recipient.\\n   *\\n   * @param  staker     The staker whose rewards to claim.\\n   * @param  recipient  The address that should receive the funds.\\n   *\\n   * @return The number of rewards tokens claimed.\\n   */\\n  function claimRewardsFor(\\n    address staker,\\n    address recipient\\n  )\\n    external\\n    onlyRole(CLAIM_OPERATOR_ROLE)\\n    nonReentrant\\n    returns (uint256)\\n  {\\n    uint256 rewards = _settleAndClaimRewards(staker, recipient); // Emits an event internally.\\n    emit OperatorClaimedRewardsFor(staker, recipient, rewards, msg.sender);\\n    return rewards;\\n  }\\n\\n  /**\\n   * @notice Decreased the balance recording debt owed to a staker.\\n   *\\n   * @param  staker  The staker whose balance to decrease.\\n   * @param  amount  The amount to decrease the balance by.\\n   *\\n   * @return The new debt balance.\\n   */\\n  function decreaseStakerDebt(\\n    address staker,\\n    uint256 amount\\n  )\\n    external\\n    onlyRole(DEBT_OPERATOR_ROLE)\\n    nonReentrant\\n    returns (uint256)\\n  {\\n    uint256 oldDebtBalance = _settleStakerDebtBalance(staker);\\n    uint256 newDebtBalance = oldDebtBalance.sub(amount);\\n    _STAKER_DEBT_BALANCES_[staker] = newDebtBalance;\\n    emit OperatorDecreasedStakerDebt(staker, amount, newDebtBalance, msg.sender);\\n    return newDebtBalance;\\n  }\\n\\n  /**\\n   * @notice Decreased the balance recording debt owed by a borrower.\\n   *\\n   * @param  borrower  The borrower whose balance to decrease.\\n   * @param  amount    The amount to decrease the balance by.\\n   *\\n   * @return The new debt balance.\\n   */\\n  function decreaseBorrowerDebt(\\n    address borrower,\\n    uint256 amount\\n  )\\n    external\\n    onlyRole(DEBT_OPERATOR_ROLE)\\n    nonReentrant\\n    returns (uint256)\\n  {\\n    uint256 newDebtBalance = _BORROWER_DEBT_BALANCES_[borrower].sub(amount);\\n    _BORROWER_DEBT_BALANCES_[borrower] = newDebtBalance;\\n    _TOTAL_BORROWER_DEBT_BALANCE_ = _TOTAL_BORROWER_DEBT_BALANCE_.sub(amount);\\n    emit OperatorDecreasedBorrowerDebt(borrower, amount, newDebtBalance, msg.sender);\\n    return newDebtBalance;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/lib/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\n/**\\n * @title SafeCast\\n * @author dYdX\\n *\\n * @dev Methods for downcasting unsigned integers, reverting on overflow.\\n */\\nlibrary SafeCast {\\n\\n  /**\\n   * @dev Downcast to a uint16, reverting on overflow.\\n   */\\n  function toUint16(\\n    uint256 a\\n  )\\n    internal\\n    pure\\n    returns (uint16)\\n  {\\n    uint16 b = uint16(a);\\n    require(uint256(b) == a, 'SafeCast: toUint16 overflow');\\n    return b;\\n  }\\n\\n  /**\\n   * @dev Downcast to a uint32, reverting on overflow.\\n   */\\n  function toUint32(\\n    uint256 a\\n  )\\n    internal\\n    pure\\n    returns (uint32)\\n  {\\n    uint32 b = uint32(a);\\n    require(uint256(b) == a, 'SafeCast: toUint32 overflow');\\n    return b;\\n  }\\n\\n  /**\\n   * @dev Downcast to a uint112, reverting on overflow.\\n   */\\n  function toUint112(\\n    uint256 a\\n  )\\n    internal\\n    pure\\n    returns (uint112)\\n  {\\n    uint112 b = uint112(a);\\n    require(uint256(b) == a, 'SafeCast: toUint112 overflow');\\n    return b;\\n  }\\n\\n  /**\\n   * @dev Downcast to a uint120, reverting on overflow.\\n   */\\n  function toUint120(\\n    uint256 a\\n  )\\n    internal\\n    pure\\n    returns (uint120)\\n  {\\n    uint120 b = uint120(a);\\n    require(uint256(b) == a, 'SafeCast: toUint120 overflow');\\n    return b;\\n  }\\n\\n  /**\\n   * @dev Downcast to a uint128, reverting on overflow.\\n   */\\n  function toUint128(\\n    uint256 a\\n  )\\n    internal\\n    pure\\n    returns (uint128)\\n  {\\n    uint128 b = uint128(a);\\n    require(uint256(b) == a, 'SafeCast: toUint128 overflow');\\n    return b;\\n  }\\n\\n  /**\\n   * @dev Downcast to a uint224, reverting on overflow.\\n   */\\n  function toUint224(\\n    uint256 a\\n  )\\n    internal\\n    pure\\n    returns (uint224)\\n  {\\n    uint224 b = uint224(a);\\n    require(uint256(b) == a, 'SafeCast: toUint224 overflow');\\n    return b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport { IERC20 } from '../../interfaces/IERC20.sol';\\nimport { SafeMath } from './SafeMath.sol';\\nimport { Address } from './Address.sol';\\n\\n/**\\n * @title SafeERC20\\n * @dev From https://github.com/OpenZeppelin/openzeppelin-contracts\\n * Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\n    );\\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = address(token).call(data);\\n    require(success, 'SafeERC20: low-level call failed');\\n\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      // solhint-disable-next-line max-line-length\\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/impl/LS1BorrowerAllocations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeERC20 } from '../../../dependencies/open-zeppelin/SafeERC20.sol';\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { Math } from '../../../utils/Math.sol';\\nimport { LS1Types } from '../lib/LS1Types.sol';\\nimport { SafeCast } from '../lib/SafeCast.sol';\\nimport { LS1StakedBalances } from './LS1StakedBalances.sol';\\n\\n/**\\n * @title LS1BorrowerAllocations\\n * @author dYdX\\n *\\n * @dev Gives a set of addresses permission to withdraw staked funds.\\n *\\n *  The amount that can be withdrawn depends on a borrower's allocation percentage and the total\\n *  available funds. Both the allocated percentage and total available funds can change, at\\n *  predefined times specified by LS1EpochSchedule.\\n *\\n *  If a borrower's borrowed balance is greater than their allocation at the start of the next epoch\\n *  then they are expected and trusted to return the difference before the start of that epoch.\\n */\\nabstract contract LS1BorrowerAllocations is\\n  LS1StakedBalances\\n{\\n  using SafeCast for uint256;\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint256;\\n\\n  // ============ Constants ============\\n\\n  /// @notice The total units to be allocated.\\n  uint256 public constant TOTAL_ALLOCATION = 1e4;\\n\\n  // ============ Events ============\\n\\n  event ScheduledBorrowerAllocationChange(\\n    address indexed borrower,\\n    uint256 oldAllocation,\\n    uint256 newAllocation,\\n    uint256 epochNumber\\n  );\\n\\n  event BorrowingRestrictionChanged(\\n    address indexed borrower,\\n    bool isBorrowingRestricted\\n  );\\n\\n  // ============ Initializer ============\\n\\n  function __LS1BorrowerAllocations_init()\\n    internal\\n  {\\n    _BORROWER_ALLOCATIONS_[address(0)] = LS1Types.StoredAllocation({\\n      currentEpoch: 0,\\n      currentEpochAllocation: TOTAL_ALLOCATION.toUint120(),\\n      nextEpochAllocation: TOTAL_ALLOCATION.toUint120()\\n    });\\n  }\\n\\n  // ============ Public Functions ============\\n\\n  /**\\n   * @notice Get the borrower allocation for the current epoch.\\n   *\\n   * @param  borrower  The borrower to get the allocation for.\\n   *\\n   * @return The borrower's current allocation in hundreds of a percent.\\n   */\\n  function getAllocationFractionCurrentEpoch(\\n    address borrower\\n  )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return uint256(_loadBorrowerAllocation(borrower).currentEpochAllocation);\\n  }\\n\\n  /**\\n   * @notice Get the borrower allocation for the next epoch.\\n   *\\n   * @param  borrower  The borrower to get the allocation for.\\n   *\\n   * @return The borrower's next allocation in hundreds of a percent.\\n   */\\n  function getAllocationFractionNextEpoch(\\n    address borrower\\n  )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return uint256(_loadBorrowerAllocation(borrower).nextEpochAllocation);\\n  }\\n\\n  /**\\n   * @notice Get the allocated borrowable token balance of a borrower for the current epoch.\\n   *\\n   *  This is the amount which a borrower can be penalized for exceeding.\\n   *\\n   * @param  borrower  The borrower to get the allocation for.\\n   *\\n   * @return The token amount allocated to the borrower for the current epoch.\\n   */\\n  function getAllocatedBalanceCurrentEpoch(\\n    address borrower\\n  )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    uint256 allocation = getAllocationFractionCurrentEpoch(borrower);\\n    uint256 availableTokens = getTotalActiveBalanceCurrentEpoch();\\n    return availableTokens.mul(allocation).div(TOTAL_ALLOCATION);\\n  }\\n\\n  /**\\n   * @notice Preview the allocated balance of a borrower for the next epoch.\\n   *\\n   * @param  borrower  The borrower to get the allocation for.\\n   *\\n   * @return The anticipated token amount allocated to the borrower for the next epoch.\\n   */\\n  function getAllocatedBalanceNextEpoch(\\n    address borrower\\n  )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    uint256 allocation = getAllocationFractionNextEpoch(borrower);\\n    uint256 availableTokens = getTotalActiveBalanceNextEpoch();\\n    return availableTokens.mul(allocation).div(TOTAL_ALLOCATION);\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  /**\\n   * @dev Change the allocations of certain borrowers.\\n   */\\n  function _setBorrowerAllocations(\\n    address[] calldata borrowers,\\n    uint256[] calldata newAllocations\\n  )\\n    internal\\n  {\\n    // These must net out so that the total allocation is unchanged.\\n    uint256 oldAllocationSum = 0;\\n    uint256 newAllocationSum = 0;\\n\\n    for (uint256 i = 0; i < borrowers.length; i++) {\\n      address borrower = borrowers[i];\\n      uint256 newAllocation = newAllocations[i];\\n\\n      // Get the old allocation.\\n      LS1Types.StoredAllocation memory allocationStruct = _loadBorrowerAllocation(borrower);\\n      uint256 oldAllocation = uint256(allocationStruct.currentEpochAllocation);\\n\\n      // Update the borrower's next allocation.\\n      allocationStruct.nextEpochAllocation = newAllocation.toUint120();\\n\\n      // If epoch zero hasn't started, update current allocation as well.\\n      uint256 epochNumber = 0;\\n      if (hasEpochZeroStarted()) {\\n        epochNumber = uint256(allocationStruct.currentEpoch).add(1);\\n      } else {\\n        allocationStruct.currentEpochAllocation = newAllocation.toUint120();\\n      }\\n\\n      // Commit the new allocation.\\n      _BORROWER_ALLOCATIONS_[borrower] = allocationStruct;\\n      emit ScheduledBorrowerAllocationChange(borrower, oldAllocation, newAllocation, epochNumber);\\n\\n      // Record totals.\\n      oldAllocationSum = oldAllocationSum.add(oldAllocation);\\n      newAllocationSum = newAllocationSum.add(newAllocation);\\n    }\\n\\n    // Require the total allocated units to be unchanged.\\n    require(\\n      oldAllocationSum == newAllocationSum,\\n      'LS1BorrowerAllocations: Invalid'\\n    );\\n  }\\n\\n  /**\\n   * @dev Restrict a borrower from further borrowing.\\n   */\\n  function _setBorrowingRestriction(\\n    address borrower,\\n    bool isBorrowingRestricted\\n  )\\n    internal\\n  {\\n    bool oldIsBorrowingRestricted = _BORROWER_RESTRICTIONS_[borrower];\\n    if (oldIsBorrowingRestricted != isBorrowingRestricted) {\\n      _BORROWER_RESTRICTIONS_[borrower] = isBorrowingRestricted;\\n      emit BorrowingRestrictionChanged(borrower, isBorrowingRestricted);\\n    }\\n  }\\n\\n  /**\\n   * @dev Get the allocated balance that the borrower can make use of for new borrowing.\\n   *\\n   * @return The amount that the borrower can borrow up to.\\n   */\\n  function _getAllocatedBalanceForNewBorrowing(\\n    address borrower\\n  )\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    // Use the smaller of the current and next allocation fractions, since if a borrower's\\n    // allocation was just decreased, we should take that into account in limiting new borrows.\\n    uint256 currentAllocation = getAllocationFractionCurrentEpoch(borrower);\\n    uint256 nextAllocation = getAllocationFractionNextEpoch(borrower);\\n    uint256 allocation = Math.min(currentAllocation, nextAllocation);\\n\\n    // If we are in the blackout window, use the next active balance. Otherwise, use current.\\n    // Note that the next active balance is never greater than the current active balance.\\n    uint256 availableTokens;\\n    if (inBlackoutWindow()) {\\n      availableTokens = getTotalActiveBalanceNextEpoch();\\n    } else {\\n      availableTokens = getTotalActiveBalanceCurrentEpoch();\\n    }\\n    return availableTokens.mul(allocation).div(TOTAL_ALLOCATION);\\n  }\\n\\n  // ============ Private Functions ============\\n\\n  function _loadBorrowerAllocation(\\n    address borrower\\n  )\\n    private\\n    view\\n    returns (LS1Types.StoredAllocation memory)\\n  {\\n    LS1Types.StoredAllocation memory allocation = _BORROWER_ALLOCATIONS_[borrower];\\n\\n    // Ignore rollover logic before epoch zero.\\n    if (hasEpochZeroStarted()) {\\n      uint256 currentEpoch = getCurrentEpoch();\\n      if (currentEpoch > uint256(allocation.currentEpoch)) {\\n        // Roll the allocation forward.\\n        allocation.currentEpoch = currentEpoch.toUint16();\\n        allocation.currentEpochAllocation = allocation.nextEpochAllocation;\\n      }\\n    }\\n\\n    return allocation;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/impl/LS1Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeERC20 } from '../../../dependencies/open-zeppelin/SafeERC20.sol';\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { Math } from '../../../utils/Math.sol';\\nimport { LS1Types } from '../lib/LS1Types.sol';\\nimport { LS1ERC20 } from './LS1ERC20.sol';\\nimport { LS1StakedBalances } from './LS1StakedBalances.sol';\\n\\n/**\\n * @title LS1Staking\\n * @author dYdX\\n *\\n * @dev External functions for stakers. See LS1StakedBalances for details on staker accounting.\\n */\\nabstract contract LS1Staking is\\n  LS1StakedBalances,\\n  LS1ERC20\\n{\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint256;\\n\\n  // ============ Events ============\\n\\n  event Staked(\\n    address indexed staker,\\n    address spender,\\n    uint256 amount\\n  );\\n\\n  event WithdrawalRequested(\\n    address indexed staker,\\n    uint256 amount\\n  );\\n\\n  event WithdrewStake(\\n    address indexed staker,\\n    address recipient,\\n    uint256 amount\\n  );\\n\\n  event WithdrewDebt(\\n    address indexed staker,\\n    address recipient,\\n    uint256 amount,\\n    uint256 newDebtBalance\\n  );\\n\\n  // ============ Constants ============\\n\\n  IERC20 public immutable STAKED_TOKEN;\\n\\n  // ============ Constructor ============\\n\\n  constructor(\\n    IERC20 stakedToken,\\n    IERC20 rewardsToken,\\n    address rewardsTreasury,\\n    uint256 distributionStart,\\n    uint256 distributionEnd\\n  )\\n    LS1StakedBalances(rewardsToken, rewardsTreasury, distributionStart, distributionEnd)\\n  {\\n    STAKED_TOKEN = stakedToken;\\n  }\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Deposit and stake funds. These funds are active and start earning rewards immediately.\\n   *\\n   * @param  amount  The amount to stake.\\n   */\\n  function stake(\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n  {\\n    _stake(msg.sender, amount);\\n  }\\n\\n  /**\\n   * @notice Deposit and stake on behalf of another address.\\n   *\\n   * @param  staker  The staker who will receive the stake.\\n   * @param  amount  The amount to stake.\\n   */\\n  function stakeFor(\\n    address staker,\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n  {\\n    _stake(staker, amount);\\n  }\\n\\n  /**\\n   * @notice Request to withdraw funds. Starting in the next epoch, the funds will be “inactive”\\n   *  and available for withdrawal. Inactive funds do not earn rewards.\\n   *\\n   *  Reverts if we are currently in the blackout window.\\n   *\\n   * @param  amount  The amount to move from the active to the inactive balance.\\n   */\\n  function requestWithdrawal(\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n  {\\n    _requestWithdrawal(msg.sender, amount);\\n  }\\n\\n  /**\\n   * @notice Withdraw the sender's inactive funds, and send to the specified recipient.\\n   *\\n   * @param  recipient  The address that should receive the funds.\\n   * @param  amount     The amount to withdraw from the sender's inactive balance.\\n   */\\n  function withdrawStake(\\n    address recipient,\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n  {\\n    _withdrawStake(msg.sender, recipient, amount);\\n  }\\n\\n  /**\\n   * @notice Withdraw the max available inactive funds, and send to the specified recipient.\\n   *\\n   *  This is less gas-efficient than querying the max via eth_call and calling withdrawStake().\\n   *\\n   * @param  recipient  The address that should receive the funds.\\n   *\\n   * @return The withdrawn amount.\\n   */\\n  function withdrawMaxStake(\\n    address recipient\\n  )\\n    external\\n    nonReentrant\\n    returns (uint256)\\n  {\\n    uint256 amount = getStakeAvailableToWithdraw(msg.sender);\\n    _withdrawStake(msg.sender, recipient, amount);\\n    return amount;\\n  }\\n\\n  /**\\n   * @notice Withdraw a debt amount owed to the sender, and send to the specified recipient.\\n   *\\n   * @param  recipient  The address that should receive the funds.\\n   * @param  amount     The token amount to withdraw from the sender's debt balance.\\n   */\\n  function withdrawDebt(\\n    address recipient,\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n  {\\n    _withdrawDebt(msg.sender, recipient, amount);\\n  }\\n\\n  /**\\n   * @notice Withdraw the max available debt amount.\\n   *\\n   *  This is less gas-efficient than querying the max via eth_call and calling withdrawDebt().\\n   *\\n   * @param  recipient  The address that should receive the funds.\\n   *\\n   * @return The withdrawn amount.\\n   */\\n  function withdrawMaxDebt(\\n    address recipient\\n  )\\n    external\\n    nonReentrant\\n    returns (uint256)\\n  {\\n    uint256 amount = getDebtAvailableToWithdraw(msg.sender);\\n    _withdrawDebt(msg.sender, recipient, amount);\\n    return amount;\\n  }\\n\\n  /**\\n   * @notice Settle and claim all rewards, and send them to the specified recipient.\\n   *\\n   *  Call this function with eth_call to query the claimable rewards balance.\\n   *\\n   * @param  recipient  The address that should receive the funds.\\n   *\\n   * @return The number of rewards tokens claimed.\\n   */\\n  function claimRewards(\\n    address recipient\\n  )\\n    external\\n    nonReentrant\\n    returns (uint256)\\n  {\\n    return _settleAndClaimRewards(msg.sender, recipient); // Emits an event internally.\\n  }\\n\\n  // ============ Public Functions ============\\n\\n  /**\\n   * @notice Get the amount of stake available to withdraw taking into account the contract balance.\\n   *\\n   * @param  staker  The address whose balance to check.\\n   *\\n   * @return The staker's stake amount that is inactive and available to withdraw.\\n   */\\n  function getStakeAvailableToWithdraw(\\n    address staker\\n  )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    // Note that the next epoch inactive balance is always at least that of the current epoch.\\n    uint256 stakerBalance = getInactiveBalanceCurrentEpoch(staker);\\n    uint256 totalStakeAvailable = getContractBalanceAvailableToWithdraw();\\n    return Math.min(stakerBalance, totalStakeAvailable);\\n  }\\n\\n  /**\\n   * @notice Get the funds currently available in the contract for staker withdrawals.\\n   *\\n   * @return The amount of non-debt funds in the contract.\\n   */\\n  function getContractBalanceAvailableToWithdraw()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    uint256 contractBalance = STAKED_TOKEN.balanceOf(address(this));\\n    uint256 availableDebtBalance = _TOTAL_DEBT_AVAILABLE_TO_WITHDRAW_;\\n    return contractBalance.sub(availableDebtBalance); // Should never underflow.\\n  }\\n\\n  /**\\n   * @notice Get the amount of debt available to withdraw.\\n   *\\n   * @param  staker  The address whose balance to check.\\n   *\\n   * @return The debt amount that can be withdrawn.\\n   */\\n  function getDebtAvailableToWithdraw(\\n    address staker\\n  )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    // Note that `totalDebtAvailable` should never be less than the contract token balance.\\n    uint256 stakerDebtBalance = getStakerDebtBalance(staker);\\n    uint256 totalDebtAvailable = _TOTAL_DEBT_AVAILABLE_TO_WITHDRAW_;\\n    return Math.min(stakerDebtBalance, totalDebtAvailable);\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  function _stake(\\n    address staker,\\n    uint256 amount\\n  )\\n    internal\\n  {\\n    // Increase current and next active balance.\\n    _increaseCurrentAndNextActiveBalance(staker, amount);\\n\\n    // Transfer token from the sender.\\n    STAKED_TOKEN.safeTransferFrom(msg.sender, address(this), amount);\\n\\n    emit Staked(staker, msg.sender, amount);\\n    emit Transfer(address(0), msg.sender, amount);\\n  }\\n\\n  function _requestWithdrawal(\\n    address staker,\\n    uint256 amount\\n  )\\n    internal\\n  {\\n    require(\\n      !inBlackoutWindow(),\\n      'LS1Staking: Withdraw requests restricted in the blackout window'\\n    );\\n\\n    // Get the staker's requestable amount and revert if there is not enough to request withdrawal.\\n    uint256 requestableBalance = getActiveBalanceNextEpoch(staker);\\n    require(\\n      amount <= requestableBalance,\\n      'LS1Staking: Withdraw request exceeds next active balance'\\n    );\\n\\n    // Move amount from active to inactive in the next epoch.\\n    _moveNextBalanceActiveToInactive(staker, amount);\\n\\n    emit WithdrawalRequested(staker, amount);\\n  }\\n\\n  function _withdrawStake(\\n    address staker,\\n    address recipient,\\n    uint256 amount\\n  )\\n    internal\\n  {\\n    // Get contract available amount and revert if there is not enough to withdraw.\\n    uint256 totalStakeAvailable = getContractBalanceAvailableToWithdraw();\\n    require(\\n      amount <= totalStakeAvailable,\\n      'LS1Staking: Withdraw exceeds amount available in the contract'\\n    );\\n\\n    // Get staker withdrawable balance and revert if there is not enough to withdraw.\\n    uint256 withdrawableBalance = getInactiveBalanceCurrentEpoch(staker);\\n    require(\\n      amount <= withdrawableBalance,\\n      'LS1Staking: Withdraw exceeds inactive balance'\\n    );\\n\\n    // Decrease the staker's current and next inactive balance. Reverts if balance is insufficient.\\n    _decreaseCurrentAndNextInactiveBalance(staker, amount);\\n\\n    // Transfer token to the recipient.\\n    STAKED_TOKEN.safeTransfer(recipient, amount);\\n\\n    emit Transfer(msg.sender, address(0), amount);\\n    emit WithdrewStake(staker, recipient, amount);\\n  }\\n\\n  // ============ Private Functions ============\\n\\n  function _withdrawDebt(\\n    address staker,\\n    address recipient,\\n    uint256 amount\\n  )\\n    private\\n  {\\n    // Get old amounts and revert if there is not enough to withdraw.\\n    uint256 oldDebtBalance = _settleStakerDebtBalance(staker);\\n    require(\\n      amount <= oldDebtBalance,\\n      'LS1Staking: Withdraw debt exceeds debt owed'\\n    );\\n    uint256 oldDebtAvailable = _TOTAL_DEBT_AVAILABLE_TO_WITHDRAW_;\\n    require(\\n      amount <= oldDebtAvailable,\\n      'LS1Staking: Withdraw debt exceeds amount available'\\n    );\\n\\n    // Caculate updated amounts and update storage.\\n    uint256 newDebtBalance = oldDebtBalance.sub(amount);\\n    uint256 newDebtAvailable = oldDebtAvailable.sub(amount);\\n    _STAKER_DEBT_BALANCES_[staker] = newDebtBalance;\\n    _TOTAL_DEBT_AVAILABLE_TO_WITHDRAW_ = newDebtAvailable;\\n\\n    // Transfer token to the recipient.\\n    STAKED_TOKEN.safeTransfer(recipient, amount);\\n\\n    emit WithdrewDebt(staker, recipient, amount, newDebtBalance);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256('')`\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      codehash := extcodehash(account)\\n    }\\n    return (codehash != accountHash && codehash != 0x0);\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(success, 'Address: unable to send value, recipient may have reverted');\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/impl/LS1StakedBalances.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { LS1Types } from '../lib/LS1Types.sol';\\nimport { SafeCast } from '../lib/SafeCast.sol';\\nimport { LS1Rewards } from './LS1Rewards.sol';\\n\\n/**\\n * @title LS1StakedBalances\\n * @author dYdX\\n *\\n * @dev Accounting of staked balances.\\n *\\n *  NOTE: Internal functions may revert if epoch zero has not started.\\n *\\n *  STAKED BALANCE ACCOUNTING:\\n *\\n *   A staked balance is in one of two states:\\n *     - active: Available for borrowing; earning staking rewards; cannot be withdrawn by staker.\\n *     - inactive: Unavailable for borrowing; does not earn rewards; can be withdrawn by the staker.\\n *\\n *   A staker may have a combination of active and inactive balances. The following operations\\n *   affect staked balances as follows:\\n *     - deposit:            Increase active balance.\\n *     - request withdrawal: At the end of the current epoch, move some active funds to inactive.\\n *     - withdraw:           Decrease inactive balance.\\n *     - transfer:           Move some active funds to another staker.\\n *\\n *   To encode the fact that a balance may be scheduled to change at the end of a certain epoch, we\\n *   store each balance as a struct of three fields: currentEpoch, currentEpochBalance, and\\n *   nextEpochBalance. Also, inactive user balances make use of the shortfallCounter field as\\n *   described below.\\n *\\n *  INACTIVE BALANCE ACCOUNTING:\\n *\\n *   Inactive funds may be subject to pro-rata socialized losses in the event of a shortfall where\\n *   a borrower is late to pay back funds that have been requested for withdrawal. We track losses\\n *   via indexes. Each index represents the fraction of inactive funds that were converted into\\n *   debt during a given shortfall event. Each staker inactive balance stores a cached shortfall\\n *   counter, representing the number of shortfalls that occurred in the past relative to when the\\n *   balance was last updated.\\n *\\n *   Any losses incurred by an inactive balance translate into an equal credit to that staker's\\n *   debt balance. See LS1DebtAccounting for more info about how the index is calculated.\\n *\\n *  REWARDS ACCOUNTING:\\n *\\n *   Active funds earn rewards for the period of time that they remain active. This means, after\\n *   requesting a withdrawal of some funds, those funds will continue to earn rewards until the end\\n *   of the epoch. For example:\\n *\\n *     epoch: n        n + 1      n + 2      n + 3\\n *            |          |          |          |\\n *            +----------+----------+----------+-----...\\n *               ^ t_0: User makes a deposit.\\n *                          ^ t_1: User requests a withdrawal of all funds.\\n *                                  ^ t_2: The funds change state from active to inactive.\\n *\\n *   In the above scenario, the user would earn rewards for the period from t_0 to t_2, varying\\n *   with the total staked balance in that period. If the user only request a withdrawal for a part\\n *   of their balance, then the remaining balance would continue earning rewards beyond t_2.\\n *\\n *   User rewards must be settled via LS1Rewards any time a user's active balance changes. Special\\n *   attention is paid to the the epoch boundaries, where funds may have transitioned from active\\n *   to inactive.\\n *\\n *  SETTLEMENT DETAILS:\\n *\\n *   Internally, this module uses the following types of operations on stored balances:\\n *     - Load:            Loads a balance, while applying settlement logic internally to get the\\n *                        up-to-date result. Returns settlement results without updating state.\\n *     - Store:           Stores a balance.\\n *     - Load-for-update: Performs a load and applies updates as needed to rewards or debt balances.\\n *                        Since this is state-changing, it must be followed by a store operation.\\n *     - Settle:          Performs load-for-update and store operations.\\n *\\n *   This module is responsible for maintaining the following invariants to ensure rewards are\\n *   calculated correctly:\\n *     - When an active balance is loaded for update, if a rollover occurs from one epoch to the\\n *       next, the rewards index must be settled up to the boundary at which the rollover occurs.\\n *     - Because the global rewards index is needed to update the user rewards index, the total\\n *       active balance must be settled before any staker balances are settled or loaded for update.\\n *     - A staker's balance must be settled before their rewards are settled.\\n */\\nabstract contract LS1StakedBalances is\\n  LS1Rewards\\n{\\n  using SafeCast for uint256;\\n  using SafeMath for uint256;\\n\\n  // ============ Constants ============\\n\\n  uint256 internal constant SHORTFALL_INDEX_BASE = 1e36;\\n\\n  // ============ Events ============\\n\\n  event ReceivedDebt(\\n    address indexed staker,\\n    uint256 amount,\\n    uint256 newDebtBalance\\n  );\\n\\n  // ============ Constructor ============\\n\\n  constructor(\\n    IERC20 rewardsToken,\\n    address rewardsTreasury,\\n    uint256 distributionStart,\\n    uint256 distributionEnd\\n  )\\n    LS1Rewards(rewardsToken, rewardsTreasury, distributionStart, distributionEnd)\\n  {}\\n\\n  // ============ Public Functions ============\\n\\n  /**\\n   * @notice Get the current active balance of a staker.\\n   */\\n  function getActiveBalanceCurrentEpoch(\\n    address staker\\n  )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    if (!hasEpochZeroStarted()) {\\n      return 0;\\n    }\\n    (LS1Types.StoredBalance memory balance, , , ) = _loadActiveBalance(_ACTIVE_BALANCES_[staker]);\\n    return uint256(balance.currentEpochBalance);\\n  }\\n\\n  /**\\n   * @notice Get the next epoch active balance of a staker.\\n   */\\n  function getActiveBalanceNextEpoch(\\n    address staker\\n  )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    if (!hasEpochZeroStarted()) {\\n      return 0;\\n    }\\n    (LS1Types.StoredBalance memory balance, , , ) = _loadActiveBalance(_ACTIVE_BALANCES_[staker]);\\n    return uint256(balance.nextEpochBalance);\\n  }\\n\\n  /**\\n   * @notice Get the current total active balance.\\n   */\\n  function getTotalActiveBalanceCurrentEpoch()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    if (!hasEpochZeroStarted()) {\\n      return 0;\\n    }\\n    (LS1Types.StoredBalance memory balance, , , ) = _loadActiveBalance(_TOTAL_ACTIVE_BALANCE_);\\n    return uint256(balance.currentEpochBalance);\\n  }\\n\\n  /**\\n   * @notice Get the next epoch total active balance.\\n   */\\n  function getTotalActiveBalanceNextEpoch()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    if (!hasEpochZeroStarted()) {\\n      return 0;\\n    }\\n    (LS1Types.StoredBalance memory balance, , , ) = _loadActiveBalance(_TOTAL_ACTIVE_BALANCE_);\\n    return uint256(balance.nextEpochBalance);\\n  }\\n\\n  /**\\n   * @notice Get the current inactive balance of a staker.\\n   * @dev The balance is converted via the index to token units.\\n   */\\n  function getInactiveBalanceCurrentEpoch(\\n    address staker\\n  )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    if (!hasEpochZeroStarted()) {\\n      return 0;\\n    }\\n    (LS1Types.StoredBalance memory balance, ) =\\n      _loadUserInactiveBalance(_INACTIVE_BALANCES_[staker]);\\n    return uint256(balance.currentEpochBalance);\\n  }\\n\\n  /**\\n   * @notice Get the next epoch inactive balance of a staker.\\n   * @dev The balance is converted via the index to token units.\\n   */\\n  function getInactiveBalanceNextEpoch(\\n    address staker\\n  )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    if (!hasEpochZeroStarted()) {\\n      return 0;\\n    }\\n    (LS1Types.StoredBalance memory balance, ) =\\n      _loadUserInactiveBalance(_INACTIVE_BALANCES_[staker]);\\n    return uint256(balance.nextEpochBalance);\\n  }\\n\\n  /**\\n   * @notice Get the current total inactive balance.\\n   */\\n  function getTotalInactiveBalanceCurrentEpoch()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    if (!hasEpochZeroStarted()) {\\n      return 0;\\n    }\\n    LS1Types.StoredBalance memory balance = _loadTotalInactiveBalance(_TOTAL_INACTIVE_BALANCE_);\\n    return uint256(balance.currentEpochBalance);\\n  }\\n\\n  /**\\n   * @notice Get the next epoch total inactive balance.\\n   */\\n  function getTotalInactiveBalanceNextEpoch()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    if (!hasEpochZeroStarted()) {\\n      return 0;\\n    }\\n    LS1Types.StoredBalance memory balance = _loadTotalInactiveBalance(_TOTAL_INACTIVE_BALANCE_);\\n    return uint256(balance.nextEpochBalance);\\n  }\\n\\n  /**\\n   * @notice Get a staker's debt balance, after accounting for unsettled shortfalls.\\n   *  Note that this does not modify _STAKER_DEBT_BALANCES_, so the debt balance must still be\\n   *  settled before it can be withdrawn.\\n   *\\n   * @param  staker  The staker to get the balance of.\\n   *\\n   * @return The settled debt balance.\\n   */\\n  function getStakerDebtBalance(\\n    address staker\\n  )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    if (!hasEpochZeroStarted()) {\\n      return 0;\\n    }\\n    (, uint256 newDebtAmount) = _loadUserInactiveBalance(_INACTIVE_BALANCES_[staker]);\\n    return _STAKER_DEBT_BALANCES_[staker].add(newDebtAmount);\\n  }\\n\\n  /**\\n   * @notice Get the current transferable balance for a user. The user can\\n   *  only transfer their balance that is not currently inactive or going to be\\n   *  inactive in the next epoch. Note that this means the user's transferable funds\\n   *  are their active balance of the next epoch.\\n   *\\n   * @param  account  The account to get the transferable balance of.\\n   *\\n   * @return The user's transferable balance.\\n   */\\n  function getTransferableBalance(\\n    address account\\n  )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return getActiveBalanceNextEpoch(account);\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  function _increaseCurrentAndNextActiveBalance(\\n    address staker,\\n    uint256 amount\\n  )\\n    internal\\n  {\\n    // Always settle total active balance before settling a staker active balance.\\n    uint256 oldTotalBalance = _increaseCurrentAndNextBalances(address(0), true, amount);\\n    uint256 oldUserBalance = _increaseCurrentAndNextBalances(staker, true, amount);\\n\\n    // When an active balance changes at current timestamp, settle rewards to the current timestamp.\\n    _settleUserRewardsUpToNow(staker, oldUserBalance, oldTotalBalance);\\n  }\\n\\n  function _moveNextBalanceActiveToInactive(\\n    address staker,\\n    uint256 amount\\n  )\\n    internal\\n  {\\n    // Decrease the active balance for the next epoch.\\n    // Always settle total active balance before settling a staker active balance.\\n    _decreaseNextBalance(address(0), true, amount);\\n    _decreaseNextBalance(staker, true, amount);\\n\\n    // Increase the inactive balance for the next epoch.\\n    _increaseNextBalance(address(0), false, amount);\\n    _increaseNextBalance(staker, false, amount);\\n\\n    // Note that we don't need to settle rewards since the current active balance did not change.\\n  }\\n\\n  function _transferCurrentAndNextActiveBalance(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  )\\n    internal\\n  {\\n    // Always settle total active balance before settling a staker active balance.\\n    uint256 totalBalance = _settleTotalActiveBalance();\\n\\n    // Move current and next active balances from sender to recipient.\\n    uint256 oldSenderBalance = _decreaseCurrentAndNextBalances(sender, true, amount);\\n    uint256 oldRecipientBalance = _increaseCurrentAndNextBalances(recipient, true, amount);\\n\\n    // When an active balance changes at current timestamp, settle rewards to the current timestamp.\\n    _settleUserRewardsUpToNow(sender, oldSenderBalance, totalBalance);\\n    _settleUserRewardsUpToNow(recipient, oldRecipientBalance, totalBalance);\\n  }\\n\\n  function _decreaseCurrentAndNextInactiveBalance(\\n    address staker,\\n    uint256 amount\\n  )\\n    internal\\n  {\\n    // Decrease the inactive balance for the next epoch.\\n    _decreaseCurrentAndNextBalances(address(0), false, amount);\\n    _decreaseCurrentAndNextBalances(staker, false, amount);\\n\\n    // Note that we don't settle rewards since active balances are not affected.\\n  }\\n\\n  function _settleTotalActiveBalance()\\n    internal\\n    returns (uint256)\\n  {\\n    return _settleBalance(address(0), true);\\n  }\\n\\n  function _settleStakerDebtBalance(\\n    address staker\\n  )\\n    internal\\n    returns (uint256)\\n  {\\n    // Settle the inactive balance to settle any new debt.\\n    _settleBalance(staker, false);\\n\\n    // Return the settled debt balance.\\n    return _STAKER_DEBT_BALANCES_[staker];\\n  }\\n\\n  function _settleAndClaimRewards(\\n    address staker,\\n    address recipient\\n  )\\n    internal\\n    returns (uint256)\\n  {\\n    // Always settle total active balance before settling a staker active balance.\\n    uint256 totalBalance = _settleTotalActiveBalance();\\n\\n    // Always settle staker active balance before settling staker rewards.\\n    uint256 userBalance = _settleBalance(staker, true);\\n\\n    // Settle rewards balance since we want to claim the full accrued amount.\\n    _settleUserRewardsUpToNow(staker, userBalance, totalBalance);\\n\\n    // Claim rewards balance.\\n    return _claimRewards(staker, recipient);\\n  }\\n\\n  function _applyShortfall(\\n    uint256 shortfallAmount,\\n    uint256 shortfallIndex\\n  )\\n    internal\\n  {\\n    // Decrease the total inactive balance.\\n    _decreaseCurrentAndNextBalances(address(0), false, shortfallAmount);\\n\\n    _SHORTFALLS_.push(LS1Types.Shortfall({\\n      epoch: getCurrentEpoch().toUint16(),\\n      index: shortfallIndex.toUint224()\\n    }));\\n  }\\n\\n  /**\\n   * @dev Does the same thing as _settleBalance() for a user inactive balance, but limits\\n   *  the epoch we progress to, in order that we can put an upper bound on the gas expenditure of\\n   *  the function. See LS1Failsafe.\\n   */\\n  function _failsafeSettleUserInactiveBalance(\\n    address staker,\\n    uint256 maxEpoch\\n  )\\n    internal\\n  {\\n    LS1Types.StoredBalance storage balancePtr = _getBalancePtr(staker, false);\\n    LS1Types.StoredBalance memory balance =\\n      _failsafeLoadUserInactiveBalanceForUpdate(balancePtr, staker, maxEpoch);\\n    _storeBalance(balancePtr, balance);\\n  }\\n\\n  /**\\n   * @dev Sets the user inactive balance to zero. See LS1Failsafe.\\n   *\\n   *  Since the balance will never be settled, the staker loses any debt balance that they would\\n   *  have otherwise been entitled to from shortfall losses.\\n   *\\n   *  Also note that we don't update the total inactive balance, but this is fine.\\n   */\\n  function _failsafeDeleteUserInactiveBalance(\\n    address staker\\n  )\\n    internal\\n  {\\n    LS1Types.StoredBalance storage balancePtr = _getBalancePtr(staker, false);\\n    LS1Types.StoredBalance memory balance =\\n      LS1Types.StoredBalance({\\n        currentEpoch: 0,\\n        currentEpochBalance: 0,\\n        nextEpochBalance: 0,\\n        shortfallCounter: 0\\n      });\\n    _storeBalance(balancePtr, balance);\\n  }\\n\\n  // ============ Private Functions ============\\n\\n  /**\\n   * @dev Load a balance for update and then store it.\\n   */\\n  function _settleBalance(\\n    address maybeStaker,\\n    bool isActiveBalance\\n  )\\n    private\\n    returns (uint256)\\n  {\\n    LS1Types.StoredBalance storage balancePtr = _getBalancePtr(maybeStaker, isActiveBalance);\\n    LS1Types.StoredBalance memory balance =\\n      _loadBalanceForUpdate(balancePtr, maybeStaker, isActiveBalance);\\n\\n    uint256 currentBalance = uint256(balance.currentEpochBalance);\\n\\n    _storeBalance(balancePtr, balance);\\n    return currentBalance;\\n  }\\n\\n  /**\\n   * @dev Settle a balance while applying an increase.\\n   */\\n  function _increaseCurrentAndNextBalances(\\n    address maybeStaker,\\n    bool isActiveBalance,\\n    uint256 amount\\n  )\\n    private\\n    returns (uint256)\\n  {\\n    LS1Types.StoredBalance storage balancePtr = _getBalancePtr(maybeStaker, isActiveBalance);\\n    LS1Types.StoredBalance memory balance =\\n      _loadBalanceForUpdate(balancePtr, maybeStaker, isActiveBalance);\\n\\n    uint256 originalCurrentBalance = uint256(balance.currentEpochBalance);\\n    balance.currentEpochBalance = originalCurrentBalance.add(amount).toUint112();\\n    balance.nextEpochBalance = uint256(balance.nextEpochBalance).add(amount).toUint112();\\n\\n    _storeBalance(balancePtr, balance);\\n    return originalCurrentBalance;\\n  }\\n\\n  /**\\n   * @dev Settle a balance while applying a decrease.\\n   */\\n  function _decreaseCurrentAndNextBalances(\\n    address maybeStaker,\\n    bool isActiveBalance,\\n    uint256 amount\\n  )\\n    private\\n    returns (uint256)\\n  {\\n    LS1Types.StoredBalance storage balancePtr = _getBalancePtr(maybeStaker, isActiveBalance);\\n    LS1Types.StoredBalance memory balance =\\n      _loadBalanceForUpdate(balancePtr, maybeStaker, isActiveBalance);\\n\\n    uint256 originalCurrentBalance = uint256(balance.currentEpochBalance);\\n    balance.currentEpochBalance = originalCurrentBalance.sub(amount).toUint112();\\n    balance.nextEpochBalance = uint256(balance.nextEpochBalance).sub(amount).toUint112();\\n\\n    _storeBalance(balancePtr, balance);\\n    return originalCurrentBalance;\\n  }\\n\\n  /**\\n   * @dev Settle a balance while applying an increase.\\n   */\\n  function _increaseNextBalance(\\n    address maybeStaker,\\n    bool isActiveBalance,\\n    uint256 amount\\n  )\\n    private\\n  {\\n    LS1Types.StoredBalance storage balancePtr = _getBalancePtr(maybeStaker, isActiveBalance);\\n    LS1Types.StoredBalance memory balance =\\n      _loadBalanceForUpdate(balancePtr, maybeStaker, isActiveBalance);\\n\\n    balance.nextEpochBalance = uint256(balance.nextEpochBalance).add(amount).toUint112();\\n\\n    _storeBalance(balancePtr, balance);\\n  }\\n\\n  /**\\n   * @dev Settle a balance while applying a decrease.\\n   */\\n  function _decreaseNextBalance(\\n    address maybeStaker,\\n    bool isActiveBalance,\\n    uint256 amount\\n  )\\n    private\\n  {\\n    LS1Types.StoredBalance storage balancePtr = _getBalancePtr(maybeStaker, isActiveBalance);\\n    LS1Types.StoredBalance memory balance =\\n      _loadBalanceForUpdate(balancePtr, maybeStaker, isActiveBalance);\\n\\n    balance.nextEpochBalance = uint256(balance.nextEpochBalance).sub(amount).toUint112();\\n\\n    _storeBalance(balancePtr, balance);\\n  }\\n\\n  function _getBalancePtr(\\n    address maybeStaker,\\n    bool isActiveBalance\\n  )\\n    private\\n    view\\n    returns (LS1Types.StoredBalance storage)\\n  {\\n    // Active.\\n    if (isActiveBalance) {\\n      if (maybeStaker != address(0)) {\\n        return _ACTIVE_BALANCES_[maybeStaker];\\n      }\\n      return _TOTAL_ACTIVE_BALANCE_;\\n    }\\n\\n    // Inactive.\\n    if (maybeStaker != address(0)) {\\n      return _INACTIVE_BALANCES_[maybeStaker];\\n    }\\n    return _TOTAL_INACTIVE_BALANCE_;\\n  }\\n\\n  /**\\n   * @dev Load a balance for updating.\\n   *\\n   *  IMPORTANT: This function modifies state, and so the balance MUST be stored afterwards.\\n   *    - For active balances: if a rollover occurs, rewards are settled to the epoch boundary.\\n   *    - For inactive user balances: if a shortfall occurs, the user's debt balance is increased.\\n   *\\n   * @param  balancePtr       A storage pointer to the balance.\\n   * @param  maybeStaker      The user address, or address(0) to update total balance.\\n   * @param  isActiveBalance  Whether the balance is an active balance.\\n   */\\n  function _loadBalanceForUpdate(\\n    LS1Types.StoredBalance storage balancePtr,\\n    address maybeStaker,\\n    bool isActiveBalance\\n  )\\n    private\\n    returns (LS1Types.StoredBalance memory)\\n  {\\n    // Active balance.\\n    if (isActiveBalance) {\\n      (\\n        LS1Types.StoredBalance memory balance,\\n        uint256 beforeRolloverEpoch,\\n        uint256 beforeRolloverBalance,\\n        bool didRolloverOccur\\n      ) = _loadActiveBalance(balancePtr);\\n      if (didRolloverOccur) {\\n        // Handle the effect of the balance rollover on rewards. We must partially settle the index\\n        // up to the epoch boundary where the change in balance occurred. We pass in the balance\\n        // from before the boundary.\\n        if (maybeStaker == address(0)) {\\n          // If it's the total active balance...\\n          _settleGlobalIndexUpToEpoch(beforeRolloverBalance, beforeRolloverEpoch);\\n        } else {\\n          // If it's a user active balance...\\n          _settleUserRewardsUpToEpoch(maybeStaker, beforeRolloverBalance, beforeRolloverEpoch);\\n        }\\n      }\\n      return balance;\\n    }\\n\\n    // Total inactive balance.\\n    if (maybeStaker == address(0)) {\\n      return _loadTotalInactiveBalance(balancePtr);\\n    }\\n\\n    // User inactive balance.\\n    (LS1Types.StoredBalance memory balance, uint256 newStakerDebt) =\\n      _loadUserInactiveBalance(balancePtr);\\n    if (newStakerDebt != 0) {\\n      uint256 newDebtBalance = _STAKER_DEBT_BALANCES_[maybeStaker].add(newStakerDebt);\\n      _STAKER_DEBT_BALANCES_[maybeStaker] = newDebtBalance;\\n      emit ReceivedDebt(maybeStaker, newStakerDebt, newDebtBalance);\\n    }\\n    return balance;\\n  }\\n\\n  function _loadActiveBalance(\\n    LS1Types.StoredBalance storage balancePtr\\n  )\\n    private\\n    view\\n    returns (\\n      LS1Types.StoredBalance memory,\\n      uint256,\\n      uint256,\\n      bool\\n    )\\n  {\\n    LS1Types.StoredBalance memory balance = balancePtr;\\n\\n    // Return these as they may be needed for rewards settlement.\\n    uint256 beforeRolloverEpoch = uint256(balance.currentEpoch);\\n    uint256 beforeRolloverBalance = uint256(balance.currentEpochBalance);\\n    bool didRolloverOccur = false;\\n\\n    // Roll the balance forward if needed.\\n    uint256 currentEpoch = getCurrentEpoch();\\n    if (currentEpoch > uint256(balance.currentEpoch)) {\\n      didRolloverOccur = balance.currentEpochBalance != balance.nextEpochBalance;\\n\\n      balance.currentEpoch = currentEpoch.toUint16();\\n      balance.currentEpochBalance = balance.nextEpochBalance;\\n    }\\n\\n    return (balance, beforeRolloverEpoch, beforeRolloverBalance, didRolloverOccur);\\n  }\\n\\n  function _loadTotalInactiveBalance(\\n    LS1Types.StoredBalance storage balancePtr\\n  )\\n    private\\n    view\\n    returns (LS1Types.StoredBalance memory)\\n  {\\n    LS1Types.StoredBalance memory balance = balancePtr;\\n\\n    // Roll the balance forward if needed.\\n    uint256 currentEpoch = getCurrentEpoch();\\n    if (currentEpoch > uint256(balance.currentEpoch)) {\\n      balance.currentEpoch = currentEpoch.toUint16();\\n      balance.currentEpochBalance = balance.nextEpochBalance;\\n    }\\n\\n    return balance;\\n  }\\n\\n  function _loadUserInactiveBalance(\\n    LS1Types.StoredBalance storage balancePtr\\n  )\\n    private\\n    view\\n    returns (LS1Types.StoredBalance memory, uint256)\\n  {\\n    LS1Types.StoredBalance memory balance = balancePtr;\\n    uint256 currentEpoch = getCurrentEpoch();\\n\\n    // If there is no non-zero balance, sync the epoch number and shortfall counter and exit.\\n    // Note: Next inactive balance is always >= current, so we only need to check next.\\n    if (balance.nextEpochBalance == 0) {\\n      balance.currentEpoch = currentEpoch.toUint16();\\n      balance.shortfallCounter = _SHORTFALLS_.length.toUint16();\\n      return (balance, 0);\\n    }\\n\\n    // Apply any pending shortfalls that don't affect the “next epoch” balance.\\n    uint256 newStakerDebt;\\n    (balance, newStakerDebt) = _applyShortfallsToBalance(balance);\\n\\n    // Roll the balance forward if needed.\\n    if (currentEpoch > uint256(balance.currentEpoch)) {\\n      balance.currentEpoch = currentEpoch.toUint16();\\n      balance.currentEpochBalance = balance.nextEpochBalance;\\n\\n      // Check for more shortfalls affecting the “next epoch” and beyond.\\n      uint256 moreNewStakerDebt;\\n      (balance, moreNewStakerDebt) = _applyShortfallsToBalance(balance);\\n      newStakerDebt = newStakerDebt.add(moreNewStakerDebt);\\n    }\\n\\n    return (balance, newStakerDebt);\\n  }\\n\\n  function _applyShortfallsToBalance(\\n    LS1Types.StoredBalance memory balance\\n  )\\n    private\\n    view\\n    returns (LS1Types.StoredBalance memory, uint256)\\n  {\\n    // Get the cached and global shortfall counters.\\n    uint256 shortfallCounter = uint256(balance.shortfallCounter);\\n    uint256 globalShortfallCounter = _SHORTFALLS_.length;\\n\\n    // If the counters are in sync, then there is nothing to do.\\n    if (shortfallCounter == globalShortfallCounter) {\\n      return (balance, 0);\\n    }\\n\\n    // Get the balance params.\\n    uint16 cachedEpoch = balance.currentEpoch;\\n    uint256 oldCurrentBalance = uint256(balance.currentEpochBalance);\\n\\n    // Calculate the new balance after applying shortfalls.\\n    //\\n    // Note: In theory, this while-loop may render an account's funds inaccessible if there are\\n    // too many shortfalls, and too much gas is required to apply them all. This is very unlikely\\n    // to occur in practice, but we provide _failsafeLoadUserInactiveBalance() just in case to\\n    // ensure recovery is possible.\\n    uint256 newCurrentBalance = oldCurrentBalance;\\n    while (shortfallCounter < globalShortfallCounter) {\\n      LS1Types.Shortfall memory shortfall = _SHORTFALLS_[shortfallCounter];\\n\\n      // Stop applying shortfalls if they are in the future relative to the balance current epoch.\\n      if (shortfall.epoch > cachedEpoch) {\\n        break;\\n      }\\n\\n      // Update the current balance to reflect the shortfall.\\n      uint256 shortfallIndex = uint256(shortfall.index);\\n      newCurrentBalance = newCurrentBalance.mul(shortfallIndex).div(SHORTFALL_INDEX_BASE);\\n\\n      // Increment the staker's shortfall counter.\\n      shortfallCounter = shortfallCounter.add(1);\\n    }\\n\\n    // Calculate the loss.\\n    // If the loaded balance is stored, this amount must be added to the staker's debt balance.\\n    uint256 newStakerDebt = oldCurrentBalance.sub(newCurrentBalance);\\n\\n    // Update the balance.\\n    balance.currentEpochBalance = newCurrentBalance.toUint112();\\n    balance.nextEpochBalance = uint256(balance.nextEpochBalance).sub(newStakerDebt).toUint112();\\n    balance.shortfallCounter = shortfallCounter.toUint16();\\n    return (balance, newStakerDebt);\\n  }\\n\\n  /**\\n   * @dev Store a balance.\\n   */\\n  function _storeBalance(\\n    LS1Types.StoredBalance storage balancePtr,\\n    LS1Types.StoredBalance memory balance\\n  )\\n    private\\n  {\\n    // Note: This should use a single `sstore` when compiler optimizations are enabled.\\n    balancePtr.currentEpoch = balance.currentEpoch;\\n    balancePtr.currentEpochBalance = balance.currentEpochBalance;\\n    balancePtr.nextEpochBalance = balance.nextEpochBalance;\\n    balancePtr.shortfallCounter = balance.shortfallCounter;\\n  }\\n\\n  /**\\n   * @dev Does the same thing as _loadBalanceForUpdate() for a user inactive balance, but limits\\n   *  the epoch we progress to, in order that we can put an upper bound on the gas expenditure of\\n   *  the function. See LS1Failsafe.\\n   */\\n  function _failsafeLoadUserInactiveBalanceForUpdate(\\n    LS1Types.StoredBalance storage balancePtr,\\n    address staker,\\n    uint256 maxEpoch\\n  )\\n    private\\n    returns (LS1Types.StoredBalance memory)\\n  {\\n    LS1Types.StoredBalance memory balance = balancePtr;\\n\\n    // Validate maxEpoch.\\n    uint256 currentEpoch = getCurrentEpoch();\\n    uint256 cachedEpoch = uint256(balance.currentEpoch);\\n    require(\\n      maxEpoch >= cachedEpoch && maxEpoch <= currentEpoch,\\n      'LS1StakedBalances: maxEpoch'\\n    );\\n\\n    // Apply any pending shortfalls that don't affect the “next epoch” balance.\\n    uint256 newStakerDebt;\\n    (balance, newStakerDebt) = _applyShortfallsToBalance(balance);\\n\\n    // Roll the balance forward if needed.\\n    if (maxEpoch > cachedEpoch) {\\n      balance.currentEpoch = maxEpoch.toUint16(); // Use maxEpoch instead of currentEpoch.\\n      balance.currentEpochBalance = balance.nextEpochBalance;\\n\\n      // Check for more shortfalls affecting the “next epoch” and beyond.\\n      uint256 moreNewStakerDebt;\\n      (balance, moreNewStakerDebt) = _applyShortfallsToBalance(balance);\\n      newStakerDebt = newStakerDebt.add(moreNewStakerDebt);\\n    }\\n\\n    // Apply debt if needed.\\n    if (newStakerDebt != 0) {\\n      uint256 newDebtBalance = _STAKER_DEBT_BALANCES_[staker].add(newStakerDebt);\\n      _STAKER_DEBT_BALANCES_[staker] = newDebtBalance;\\n      emit ReceivedDebt(staker, newStakerDebt, newDebtBalance);\\n    }\\n    return balance;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/impl/LS1Rewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeERC20 } from '../../../dependencies/open-zeppelin/SafeERC20.sol';\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { Math } from '../../../utils/Math.sol';\\nimport { SafeCast } from '../lib/SafeCast.sol';\\nimport { LS1EpochSchedule } from './LS1EpochSchedule.sol';\\n\\n/**\\n * @title LS1Rewards\\n * @author dYdX\\n *\\n * @dev Manages the distribution of token rewards.\\n *\\n *  Rewards are distributed continuously. After each second, an account earns rewards `r` according\\n *  to the following formula:\\n *\\n *      r = R * s / S\\n *\\n *  Where:\\n *    - `R` is the rewards distributed globally each second, also called the “emission rate.”\\n *    - `s` is the account's staked balance in that second (technically, it is measured at the\\n *      end of the second)\\n *    - `S` is the sum total of all staked balances in that second (again, measured at the end of\\n *      the second)\\n *\\n *  The parameter `R` can be configured by the contract owner. For every second that elapses,\\n *  exactly `R` tokens will accrue to users, save for rounding errors, and with the exception that\\n *  while the total staked balance is zero, no tokens will accrue to anyone.\\n *\\n *  The accounting works as follows: A global index is stored which represents the cumulative\\n *  number of rewards tokens earned per staked token since the start of the distribution.\\n *  The value of this index increases over time, and there are two factors affecting the rate of\\n *  increase:\\n *    1) The emission rate (in the numerator)\\n *    2) The total number of staked tokens (in the denominator)\\n *\\n *  Whenever either factor changes, in some timestamp T, we settle the global index up to T by\\n *  calculating the increase in the index since the last update using the OLD values of the factors:\\n *\\n *    indexDelta = timeDelta * emissionPerSecond * INDEX_BASE / totalStaked\\n *\\n *  Where `INDEX_BASE` is a scaling factor used to allow more precision in the storage of the index.\\n *\\n *  For each user we store an accrued rewards balance, as well as a user index, which is a cache of\\n *  the global index at the time that the user's accrued rewards balance was last updated. Then at\\n *  any point in time, a user's claimable rewards are represented by the following:\\n *\\n *    rewards = _USER_REWARDS_BALANCES_[user] + userStaked * (\\n *                settledGlobalIndex - _USER_INDEXES_[user]\\n *              ) / INDEX_BASE\\n */\\nabstract contract LS1Rewards is\\n  LS1EpochSchedule\\n{\\n  using SafeERC20 for IERC20;\\n  using SafeCast for uint256;\\n  using SafeMath for uint256;\\n\\n  // ============ Constants ============\\n\\n  /// @dev Additional precision used to represent the global and user index values.\\n  uint256 private constant INDEX_BASE = 10**18;\\n\\n  /// @notice The rewards token.\\n  IERC20 public immutable REWARDS_TOKEN;\\n\\n  /// @notice Address to pull rewards from. Must have provided an allowance to this contract.\\n  address public immutable REWARDS_TREASURY;\\n\\n  /// @notice Start timestamp (inclusive) of the period in which rewards can be earned.\\n  uint256 public immutable DISTRIBUTION_START;\\n\\n  /// @notice End timestamp (exclusive) of the period in which rewards can be earned.\\n  uint256 public immutable DISTRIBUTION_END;\\n\\n  // ============ Events ============\\n\\n  event RewardsPerSecondUpdated(\\n    uint256 emissionPerSecond\\n  );\\n\\n  event GlobalIndexUpdated(\\n    uint256 index\\n  );\\n\\n  event UserIndexUpdated(\\n    address indexed user,\\n    uint256 index,\\n    uint256 unclaimedRewards\\n  );\\n\\n  event ClaimedRewards(\\n    address indexed user,\\n    address recipient,\\n    uint256 claimedRewards\\n  );\\n\\n  // ============ Constructor ============\\n\\n  constructor(\\n    IERC20 rewardsToken,\\n    address rewardsTreasury,\\n    uint256 distributionStart,\\n    uint256 distributionEnd\\n  ) {\\n    require(distributionEnd >= distributionStart, 'LS1Rewards: Invalid parameters');\\n    REWARDS_TOKEN = rewardsToken;\\n    REWARDS_TREASURY = rewardsTreasury;\\n    DISTRIBUTION_START = distributionStart;\\n    DISTRIBUTION_END = distributionEnd;\\n  }\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice The current emission rate of rewards.\\n   *\\n   * @return The number of rewards tokens issued globally each second.\\n   */\\n  function getRewardsPerSecond()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _REWARDS_PER_SECOND_;\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  /**\\n   * @dev Initialize the contract.\\n   */\\n  function __LS1Rewards_init()\\n    internal\\n  {\\n    _GLOBAL_INDEX_TIMESTAMP_ = Math.max(block.timestamp, DISTRIBUTION_START).toUint32();\\n  }\\n\\n  /**\\n   * @dev Set the emission rate of rewards.\\n   *\\n   *  IMPORTANT: Do not call this function without settling the total staked balance first, to\\n   *  ensure that the index is settled up to the epoch boundaries.\\n   *\\n   * @param  emissionPerSecond  The new number of rewards tokens to give out each second.\\n   * @param  totalStaked        The total staked balance.\\n   */\\n  function _setRewardsPerSecond(\\n    uint256 emissionPerSecond,\\n    uint256 totalStaked\\n  )\\n    internal\\n  {\\n    _settleGlobalIndexUpToNow(totalStaked);\\n    _REWARDS_PER_SECOND_ = emissionPerSecond;\\n    emit RewardsPerSecondUpdated(emissionPerSecond);\\n  }\\n\\n  /**\\n   * @dev Claim tokens, sending them to the specified recipient.\\n   *\\n   *  Note: In order to claim all accrued rewards, the total and user staked balances must first be\\n   *  settled before calling this function.\\n   *\\n   * @param  user       The user's address.\\n   * @param  recipient  The address to send rewards to.\\n   *\\n   * @return The number of rewards tokens claimed.\\n   */\\n  function _claimRewards(\\n    address user,\\n    address recipient\\n  )\\n    internal\\n    returns (uint256)\\n  {\\n    uint256 accruedRewards = _USER_REWARDS_BALANCES_[user];\\n    _USER_REWARDS_BALANCES_[user] = 0;\\n    REWARDS_TOKEN.safeTransferFrom(REWARDS_TREASURY, recipient, accruedRewards);\\n    emit ClaimedRewards(user, recipient, accruedRewards);\\n    return accruedRewards;\\n  }\\n\\n  /**\\n   * @dev Settle a user's rewards up to the latest global index as of `block.timestamp`. Triggers a\\n   *  settlement of the global index up to `block.timestamp`. Should be called with the OLD user\\n   *  and total balances.\\n   *\\n   * @param  user         The user's address.\\n   * @param  userStaked   Tokens staked by the user during the period since the last user index\\n   *                      update.\\n   * @param  totalStaked  Total tokens staked by all users during the period since the last global\\n   *                      index update.\\n   *\\n   * @return The user's accrued rewards, including past unclaimed rewards.\\n   */\\n  function _settleUserRewardsUpToNow(\\n    address user,\\n    uint256 userStaked,\\n    uint256 totalStaked\\n  )\\n    internal\\n    returns (uint256)\\n  {\\n    uint256 globalIndex = _settleGlobalIndexUpToNow(totalStaked);\\n    return _settleUserRewardsUpToIndex(user, userStaked, globalIndex);\\n  }\\n\\n  /**\\n   * @dev Settle a user's rewards up to an epoch boundary. Should be used to partially settle a\\n   *  user's rewards if their balance was known to have changed on that epoch boundary.\\n   *\\n   * @param  user         The user's address.\\n   * @param  userStaked   Tokens staked by the user. Should be accurate for the time period\\n   *                      since the last update to this user and up to the end of the\\n   *                      specified epoch.\\n   * @param  epochNumber  Settle the user's rewards up to the end of this epoch.\\n   *\\n   * @return The user's accrued rewards, including past unclaimed rewards, up to the end of the\\n   *  specified epoch.\\n   */\\n  function _settleUserRewardsUpToEpoch(\\n    address user,\\n    uint256 userStaked,\\n    uint256 epochNumber\\n  )\\n    internal\\n    returns (uint256)\\n  {\\n    uint256 globalIndex = _EPOCH_INDEXES_[epochNumber];\\n    return _settleUserRewardsUpToIndex(user, userStaked, globalIndex);\\n  }\\n\\n  /**\\n   * @dev Settle the global index up to the end of the given epoch.\\n   *\\n   *  IMPORTANT: This function should only be called under conditions which ensure the following:\\n   *    - `epochNumber` < the current epoch number\\n   *    - `_GLOBAL_INDEX_TIMESTAMP_ < settleUpToTimestamp`\\n   *    - `_EPOCH_INDEXES_[epochNumber] = 0`\\n   */\\n  function _settleGlobalIndexUpToEpoch(\\n    uint256 totalStaked,\\n    uint256 epochNumber\\n  )\\n    internal\\n    returns (uint256)\\n  {\\n    uint256 settleUpToTimestamp = getStartOfEpoch(epochNumber.add(1));\\n\\n    uint256 globalIndex = _settleGlobalIndexUpToTimestamp(totalStaked, settleUpToTimestamp);\\n    _EPOCH_INDEXES_[epochNumber] = globalIndex;\\n    return globalIndex;\\n  }\\n\\n  // ============ Private Functions ============\\n\\n  function _settleGlobalIndexUpToNow(\\n    uint256 totalStaked\\n  )\\n    private\\n    returns (uint256)\\n  {\\n    return _settleGlobalIndexUpToTimestamp(totalStaked, block.timestamp);\\n  }\\n\\n  /**\\n   * @dev Helper function which settles a user's rewards up to a global index. Should be called\\n   *  any time a user's staked balance changes, with the OLD user and total balances.\\n   *\\n   * @param  user            The user's address.\\n   * @param  userStaked      Tokens staked by the user during the period since the last user index\\n   *                         update.\\n   * @param  newGlobalIndex  The new index value to bring the user index up to.\\n   *\\n   * @return The user's accrued rewards, including past unclaimed rewards.\\n   */\\n  function _settleUserRewardsUpToIndex(\\n    address user,\\n    uint256 userStaked,\\n    uint256 newGlobalIndex\\n  )\\n    private\\n    returns (uint256)\\n  {\\n    uint256 oldAccruedRewards = _USER_REWARDS_BALANCES_[user];\\n    uint256 oldUserIndex = _USER_INDEXES_[user];\\n\\n    if (oldUserIndex == newGlobalIndex) {\\n      return oldAccruedRewards;\\n    }\\n\\n    uint256 newAccruedRewards;\\n    if (userStaked == 0) {\\n      // Note: Even if the user's staked balance is zero, we still need to update the user index.\\n      newAccruedRewards = oldAccruedRewards;\\n    } else {\\n      // Calculate newly accrued rewards since the last update to the user's index.\\n      uint256 indexDelta = newGlobalIndex.sub(oldUserIndex);\\n      uint256 accruedRewardsDelta = userStaked.mul(indexDelta).div(INDEX_BASE);\\n      newAccruedRewards = oldAccruedRewards.add(accruedRewardsDelta);\\n\\n      // Update the user's rewards.\\n      _USER_REWARDS_BALANCES_[user] = newAccruedRewards;\\n    }\\n\\n    // Update the user's index.\\n    _USER_INDEXES_[user] = newGlobalIndex;\\n    emit UserIndexUpdated(user, newGlobalIndex, newAccruedRewards);\\n    return newAccruedRewards;\\n  }\\n\\n  /**\\n   * @dev Updates the global index, reflecting cumulative rewards given out per staked token.\\n   *\\n   * @param  totalStaked          The total staked balance, which should be constant in the interval\\n   *                              (_GLOBAL_INDEX_TIMESTAMP_, settleUpToTimestamp).\\n   * @param  settleUpToTimestamp  The timestamp up to which to settle rewards. It MUST satisfy\\n   *                              `settleUpToTimestamp <= block.timestamp`.\\n   *\\n   * @return The new global index.\\n   */\\n  function _settleGlobalIndexUpToTimestamp(\\n    uint256 totalStaked,\\n    uint256 settleUpToTimestamp\\n  )\\n    private\\n    returns (uint256)\\n  {\\n    uint256 oldGlobalIndex = uint256(_GLOBAL_INDEX_);\\n\\n    // The goal of this function is to calculate rewards earned since the last global index update.\\n    // These rewards are earned over the time interval which is the intersection of the intervals\\n    // [_GLOBAL_INDEX_TIMESTAMP_, settleUpToTimestamp] and [DISTRIBUTION_START, DISTRIBUTION_END].\\n    //\\n    // We can simplify a bit based on the assumption:\\n    //   `_GLOBAL_INDEX_TIMESTAMP_ >= DISTRIBUTION_START`\\n    //\\n    // Get the start and end of the time interval under consideration.\\n    uint256 intervalStart = uint256(_GLOBAL_INDEX_TIMESTAMP_);\\n    uint256 intervalEnd = Math.min(settleUpToTimestamp, DISTRIBUTION_END);\\n\\n    // Return early if the interval has length zero (incl. case where intervalEnd < intervalStart).\\n    if (intervalEnd <= intervalStart) {\\n      return oldGlobalIndex;\\n    }\\n\\n    // Note: If we reach this point, we must update _GLOBAL_INDEX_TIMESTAMP_.\\n\\n    uint256 emissionPerSecond = _REWARDS_PER_SECOND_;\\n\\n    if (emissionPerSecond == 0 || totalStaked == 0) {\\n      // Ensure a log is emitted if the timestamp changed, even if the index does not change.\\n      _GLOBAL_INDEX_TIMESTAMP_ = intervalEnd.toUint32();\\n      emit GlobalIndexUpdated(oldGlobalIndex);\\n      return oldGlobalIndex;\\n    }\\n\\n    // Calculate the change in index over the interval.\\n    uint256 timeDelta = intervalEnd.sub(intervalStart);\\n    uint256 indexDelta = timeDelta.mul(emissionPerSecond).mul(INDEX_BASE).div(totalStaked);\\n\\n    // Calculate, update, and return the new global index.\\n    uint256 newGlobalIndex = oldGlobalIndex.add(indexDelta);\\n\\n    // Update storage. (Shared storage slot.)\\n    _GLOBAL_INDEX_TIMESTAMP_ = intervalEnd.toUint32();\\n    _GLOBAL_INDEX_ = newGlobalIndex.toUint224();\\n\\n    emit GlobalIndexUpdated(newGlobalIndex);\\n    return newGlobalIndex;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/impl/LS1EpochSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { LS1Types } from '../lib/LS1Types.sol';\\nimport { SafeCast } from '../lib/SafeCast.sol';\\nimport { LS1Roles } from './LS1Roles.sol';\\n\\n/**\\n * @title LS1EpochSchedule\\n * @author dYdX\\n *\\n * @dev Defines a function from block timestamp to epoch number.\\n *\\n *  The formula used is `n = floor((t - b) / a)` where:\\n *    - `n` is the epoch number\\n *    - `t` is the timestamp (in seconds)\\n *    - `b` is a non-negative offset, indicating the start of epoch zero (in seconds)\\n *    - `a` is the length of an epoch, a.k.a. the interval (in seconds)\\n *\\n *  Note that by restricting `b` to be non-negative, we limit ourselves to functions in which epoch\\n *  zero starts at a non-negative timestamp.\\n *\\n *  The recommended epoch length and blackout window are 28 and 7 days respectively; however, these\\n *  are modifiable by the admin, within the specified bounds.\\n */\\nabstract contract LS1EpochSchedule is\\n  LS1Roles\\n{\\n  using SafeCast for uint256;\\n  using SafeMath for uint256;\\n\\n  // ============ Constants ============\\n\\n  /// @dev Minimum blackout window. Note: The min epoch length is twice the current blackout window.\\n  uint256 private constant MIN_BLACKOUT_WINDOW = 3 days;\\n\\n  /// @dev Maximum epoch length. Note: The max blackout window is half the current epoch length.\\n  uint256 private constant MAX_EPOCH_LENGTH = 92 days; // Approximately one quarter year.\\n\\n  // ============ Events ============\\n\\n  event EpochParametersChanged(\\n    LS1Types.EpochParameters epochParameters\\n  );\\n\\n  event BlackoutWindowChanged(\\n    uint256 blackoutWindow\\n  );\\n\\n  // ============ Initializer ============\\n\\n  function __LS1EpochSchedule_init(\\n    uint256 interval,\\n    uint256 offset,\\n    uint256 blackoutWindow\\n  )\\n    internal\\n  {\\n    require(\\n      block.timestamp < offset,\\n      'LS1EpochSchedule: Epoch zero must be in future'\\n    );\\n\\n    // Don't use _setBlackoutWindow() since the interval is not set yet and validation would fail.\\n    _BLACKOUT_WINDOW_ = blackoutWindow;\\n    emit BlackoutWindowChanged(blackoutWindow);\\n\\n    _setEpochParameters(interval, offset);\\n  }\\n\\n  // ============ Public Functions ============\\n\\n  /**\\n   * @notice Get the epoch at the current block timestamp.\\n   *\\n   *  NOTE: Reverts if epoch zero has not started.\\n   *\\n   * @return The current epoch number.\\n   */\\n  function getCurrentEpoch()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    (uint256 interval, uint256 offsetTimestamp) = _getIntervalAndOffsetTimestamp();\\n    return offsetTimestamp.div(interval);\\n  }\\n\\n  /**\\n   * @notice Get the time remaining in the current epoch.\\n   *\\n   *  NOTE: Reverts if epoch zero has not started.\\n   *\\n   * @return The number of seconds until the next epoch.\\n   */\\n  function getTimeRemainingInCurrentEpoch()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    (uint256 interval, uint256 offsetTimestamp) = _getIntervalAndOffsetTimestamp();\\n    uint256 timeElapsedInEpoch = offsetTimestamp.mod(interval);\\n    return interval.sub(timeElapsedInEpoch);\\n  }\\n\\n  /**\\n   * @notice Given an epoch number, get the start of that epoch. Calculated as `t = (n * a) + b`.\\n   *\\n   * @return The timestamp in seconds representing the start of that epoch.\\n   */\\n  function getStartOfEpoch(\\n    uint256 epochNumber\\n  )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    LS1Types.EpochParameters memory epochParameters = _EPOCH_PARAMETERS_;\\n    uint256 interval = uint256(epochParameters.interval);\\n    uint256 offset = uint256(epochParameters.offset);\\n    return epochNumber.mul(interval).add(offset);\\n  }\\n\\n  /**\\n   * @notice Check whether we are at or past the start of epoch zero.\\n   *\\n   * @return Boolean `true` if the current timestamp is at least the start of epoch zero,\\n   *  otherwise `false`.\\n   */\\n  function hasEpochZeroStarted()\\n    public\\n    view\\n    returns (bool)\\n  {\\n    LS1Types.EpochParameters memory epochParameters = _EPOCH_PARAMETERS_;\\n    uint256 offset = uint256(epochParameters.offset);\\n    return block.timestamp >= offset;\\n  }\\n\\n  /**\\n   * @notice Check whether we are in a blackout window, where withdrawal requests are restricted.\\n   *  Note that before epoch zero has started, there are no blackout windows.\\n   *\\n   * @return Boolean `true` if we are in a blackout window, otherwise `false`.\\n   */\\n  function inBlackoutWindow()\\n    public\\n    view\\n    returns (bool)\\n  {\\n    return hasEpochZeroStarted() && getTimeRemainingInCurrentEpoch() <= _BLACKOUT_WINDOW_;\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  function _setEpochParameters(\\n    uint256 interval,\\n    uint256 offset\\n  )\\n    internal\\n  {\\n    _validateParamLengths(interval, _BLACKOUT_WINDOW_);\\n    LS1Types.EpochParameters memory epochParameters =\\n      LS1Types.EpochParameters({interval: interval.toUint128(), offset: offset.toUint128()});\\n    _EPOCH_PARAMETERS_ = epochParameters;\\n    emit EpochParametersChanged(epochParameters);\\n  }\\n\\n  function _setBlackoutWindow(\\n    uint256 blackoutWindow\\n  )\\n    internal\\n  {\\n    _validateParamLengths(uint256(_EPOCH_PARAMETERS_.interval), blackoutWindow);\\n    _BLACKOUT_WINDOW_ = blackoutWindow;\\n    emit BlackoutWindowChanged(blackoutWindow);\\n  }\\n\\n  // ============ Private Functions ============\\n\\n  /**\\n   * @dev Helper function to read params from storage and apply offset to the given timestamp.\\n   *\\n   *  NOTE: Reverts if epoch zero has not started.\\n   *\\n   * @return The length of an epoch, in seconds.\\n   * @return The start of epoch zero, in seconds.\\n   */\\n  function _getIntervalAndOffsetTimestamp()\\n    private\\n    view\\n    returns (uint256, uint256)\\n  {\\n    LS1Types.EpochParameters memory epochParameters = _EPOCH_PARAMETERS_;\\n    uint256 interval = uint256(epochParameters.interval);\\n    uint256 offset = uint256(epochParameters.offset);\\n\\n    require(block.timestamp >= offset, 'LS1EpochSchedule: Epoch zero has not started');\\n\\n    uint256 offsetTimestamp = block.timestamp.sub(offset);\\n    return (interval, offsetTimestamp);\\n  }\\n\\n  /**\\n   * @dev Helper for common validation: verify that the interval and window lengths are valid.\\n   */\\n  function _validateParamLengths(\\n    uint256 interval,\\n    uint256 blackoutWindow\\n  )\\n    private\\n    pure\\n  {\\n    require(\\n      blackoutWindow.mul(2) <= interval,\\n      'LS1EpochSchedule: Blackout window can be at most half the epoch length'\\n    );\\n    require(\\n      blackoutWindow >= MIN_BLACKOUT_WINDOW,\\n      'LS1EpochSchedule: Blackout window too large'\\n    );\\n    require(\\n      interval <= MAX_EPOCH_LENGTH,\\n      'LS1EpochSchedule: Epoch length too small'\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidity/v1/impl/LS1Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { LS1Storage } from './LS1Storage.sol';\\n\\n/**\\n * @title LS1Roles\\n * @author dYdX\\n *\\n * @dev Defines roles used in the LiquidityStakingV1 contract. The hierarchy of roles and powers\\n *  of each role are described below.\\n *\\n *  Roles:\\n *\\n *    OWNER_ROLE\\n *      | -> May add or remove users from any of the below roles it manages.\\n *      |\\n *      +-- EPOCH_PARAMETERS_ROLE\\n *      |     -> May set epoch parameters such as the interval, offset, and blackout window.\\n *      |\\n *      +-- REWARDS_RATE_ROLE\\n *      |     -> May set the emission rate of rewards.\\n *      |\\n *      +-- BORROWER_ADMIN_ROLE\\n *      |     -> May set borrower allocations and allow/restrict borrowers from borrowing.\\n *      |\\n *      +-- CLAIM_OPERATOR_ROLE\\n *      |     -> May claim rewards on behalf of a user.\\n *      |\\n *      +-- STAKE_OPERATOR_ROLE\\n *      |     -> May manipulate user's staked funds (e.g. perform withdrawals on behalf of a user).\\n *      |\\n *      +-- DEBT_OPERATOR_ROLE\\n *           -> May decrease borrow debt and decrease staker debt.\\n */\\nabstract contract LS1Roles is\\n  LS1Storage\\n{\\n  bytes32 public constant OWNER_ROLE = keccak256('OWNER_ROLE');\\n  bytes32 public constant EPOCH_PARAMETERS_ROLE = keccak256('EPOCH_PARAMETERS_ROLE');\\n  bytes32 public constant REWARDS_RATE_ROLE = keccak256('REWARDS_RATE_ROLE');\\n  bytes32 public constant BORROWER_ADMIN_ROLE = keccak256('BORROWER_ADMIN_ROLE');\\n  bytes32 public constant CLAIM_OPERATOR_ROLE = keccak256('CLAIM_OPERATOR_ROLE');\\n  bytes32 public constant STAKE_OPERATOR_ROLE = keccak256('STAKE_OPERATOR_ROLE');\\n  bytes32 public constant DEBT_OPERATOR_ROLE = keccak256('DEBT_OPERATOR_ROLE');\\n\\n  function __LS1Roles_init() internal {\\n    // Assign roles to the sender.\\n    //\\n    // The DEBT_OPERATOR_ROLE, STAKE_OPERATOR_ROLE, and CLAIM_OPERATOR_ROLE roles are not\\n    // initially assigned. These can be assigned to other smart contracts to provide additional\\n    // functionality for users.\\n    _setupRole(OWNER_ROLE, msg.sender);\\n    _setupRole(EPOCH_PARAMETERS_ROLE, msg.sender);\\n    _setupRole(REWARDS_RATE_ROLE, msg.sender);\\n    _setupRole(BORROWER_ADMIN_ROLE, msg.sender);\\n\\n    // Set OWNER_ROLE as the admin of all roles.\\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(EPOCH_PARAMETERS_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(REWARDS_RATE_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(BORROWER_ADMIN_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(CLAIM_OPERATOR_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(STAKE_OPERATOR_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(DEBT_OPERATOR_ROLE, OWNER_ROLE);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Detailed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\n\\nimport { IERC20 } from './IERC20.sol';\\n\\n/**\\n * @dev Interface for ERC20 including metadata\\n **/\\ninterface IERC20Detailed is IERC20 {\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"stakedToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"rewardsToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardsTreasury\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"distributionStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"distributionEnd\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blackoutWindow\",\"type\":\"uint256\"}],\"name\":\"BlackoutWindowChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBorrowedBalance\",\"type\":\"uint256\"}],\"name\":\"Borrowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBorrowingRestricted\",\"type\":\"bool\"}],\"name\":\"BorrowingRestrictionChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimedRewards\",\"type\":\"uint256\"}],\"name\":\"ClaimedRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shortfallAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shortfallIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newInactiveBalance\",\"type\":\"uint256\"}],\"name\":\"ConvertedInactiveBalancesToDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBorrowedBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDebtBalance\",\"type\":\"uint256\"}],\"name\":\"DebtMarked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"interval\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"offset\",\"type\":\"uint128\"}],\"indexed\":false,\"internalType\":\"struct LS1Types.EpochParameters\",\"name\":\"epochParameters\",\"type\":\"tuple\"}],\"name\":\"EpochParametersChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"GlobalIndexUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimedRewards\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorClaimedRewardsFor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDebtBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorDecreasedBorrowerDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDebtBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorDecreasedStakerDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorStakedFor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorWithdrawalRequestedFor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorWithdrewStakeFor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDebtBalance\",\"type\":\"uint256\"}],\"name\":\"ReceivedDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBorrowedBalance\",\"type\":\"uint256\"}],\"name\":\"RepaidBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDebtBalance\",\"type\":\"uint256\"}],\"name\":\"RepaidDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"emissionPerSecond\",\"type\":\"uint256\"}],\"name\":\"RewardsPerSecondUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAllocation\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAllocation\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"}],\"name\":\"ScheduledBorrowerAllocationChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unclaimedRewards\",\"type\":\"uint256\"}],\"name\":\"UserIndexUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawalRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDebtBalance\",\"type\":\"uint256\"}],\"name\":\"WithdrewDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrewStake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BORROWER_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CLAIM_OPERATOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEBT_OPERATOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DISTRIBUTION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DISTRIBUTION_START\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EPOCH_PARAMETERS_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OWNER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARDS_RATE_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARDS_TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARDS_TREASURY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKED_TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKE_OPERATOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_ALLOCATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"claimRewardsFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseBorrowerDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseStakerDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failsafeDeleteUserInactiveBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxEpoch\",\"type\":\"uint256\"}],\"name\":\"failsafeSettleUserInactiveBalanceToEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getActiveBalanceCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getActiveBalanceNextEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"getAllocatedBalanceCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"getAllocatedBalanceNextEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"getAllocationFractionCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"getAllocationFractionNextEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlackoutWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"getBorrowableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"getBorrowedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"getBorrowerDebtBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalanceAvailableToBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalanceAvailableToWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getDebtAvailableToWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEpochParameters\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"interval\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"offset\",\"type\":\"uint128\"}],\"internalType\":\"struct LS1Types.EpochParameters\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getInactiveBalanceCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getInactiveBalanceNextEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardsPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shortfallCounter\",\"type\":\"uint256\"}],\"name\":\"getShortfall\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"epoch\",\"type\":\"uint16\"},{\"internalType\":\"uint224\",\"name\":\"index\",\"type\":\"uint224\"}],\"internalType\":\"struct LS1Types.Shortfall\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getShortfallCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getStakeAvailableToWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getStakerDebtBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"}],\"name\":\"getStartOfEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimeRemainingInCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalActiveBalanceCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalActiveBalanceNextEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBorrowedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBorrowerDebtBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDebtAvailableToWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalInactiveBalanceCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalInactiveBalanceNextEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTransferableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasEpochZeroStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inBlackoutWindow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blackoutWindow\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"isBorrowerOverdue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"isBorrowingRestrictedForBorrower\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"borrowers\",\"type\":\"address[]\"}],\"name\":\"markDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"repayBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"repayDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"requestWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"requestWithdrawalFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"restrictBorrower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blackoutWindow\",\"type\":\"uint256\"}],\"name\":\"setBlackoutWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"borrowers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newAllocations\",\"type\":\"uint256[]\"}],\"name\":\"setBorrowerAllocations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBorrowingRestricted\",\"type\":\"bool\"}],\"name\":\"setBorrowingRestriction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"setEpochParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"emissionPerSecond\",\"type\":\"uint256\"}],\"name\":\"setRewardsPerSecond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawMaxDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawMaxStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStakeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LiquidityStakingV1","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000092d6c1e31e14520e676a687f0a93788b716beff5000000000000000000000000639192d54431f8c816368d3fb4107bc168d0e87100000000000000000000000000000000000000000000000000000000610959f0000000000000000000000000000000000000000000000000000000006a6f5b6e","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}