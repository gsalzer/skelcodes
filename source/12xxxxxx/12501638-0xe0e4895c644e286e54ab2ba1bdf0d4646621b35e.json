{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/_base/ZapBaseV1.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.7;\\n\\nimport \\\"../oz/ownership/Ownable.sol\\\";\\nimport \\\"../oz/token/ERC20/SafeERC20.sol\\\";\\n\\ncontract ZapBaseV1 is Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n    bool public stopped = false;\\n\\n    // if true, goodwill is not deducted\\n    mapping(address => bool) public feeWhitelist;\\n\\n    uint256 public goodwill;\\n    // % share of goodwill (0-100 %)\\n    uint256 affiliateSplit;\\n    // restrict affiliates\\n    mapping(address => bool) public affiliates;\\n    // affiliate => token => amount\\n    mapping(address => mapping(address => uint256)) public affiliateBalance;\\n    // token => amount\\n    mapping(address => uint256) public totalAffiliateBalance;\\n\\n    address internal constant ETHAddress =\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    constructor(uint256 _goodwill, uint256 _affiliateSplit) public {\\n        goodwill = _goodwill;\\n        affiliateSplit = _affiliateSplit;\\n    }\\n\\n    // circuit breaker modifiers\\n    modifier stopInEmergency {\\n        if (stopped) {\\n            revert(\\\"Temporarily Paused\\\");\\n        } else {\\n            _;\\n        }\\n    }\\n\\n    function _getBalance(address token)\\n        internal\\n        view\\n        returns (uint256 balance)\\n    {\\n        if (token == address(0)) {\\n            balance = address(this).balance;\\n        } else {\\n            balance = IERC20(token).balanceOf(address(this));\\n        }\\n    }\\n\\n    function _approveToken(address token, address spender) internal {\\n        IERC20 _token = IERC20(token);\\n        if (_token.allowance(address(this), spender) > 0) return;\\n        else {\\n            _token.safeApprove(spender, uint256(-1));\\n        }\\n    }\\n\\n    function _approveToken(\\n        address token,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        IERC20 _token = IERC20(token);\\n        _token.safeApprove(spender, 0);\\n        _token.safeApprove(spender, amount);\\n    }\\n\\n    // - to Pause the contract\\n    function toggleContractActive() public onlyOwner {\\n        stopped = !stopped;\\n    }\\n\\n    function set_feeWhitelist(address zapAddress, bool status)\\n        external\\n        onlyOwner\\n    {\\n        feeWhitelist[zapAddress] = status;\\n    }\\n\\n    function set_new_goodwill(uint256 _new_goodwill) public onlyOwner {\\n        require(\\n            _new_goodwill >= 0 && _new_goodwill <= 100,\\n            \\\"GoodWill Value not allowed\\\"\\n        );\\n        goodwill = _new_goodwill;\\n    }\\n\\n    function set_new_affiliateSplit(uint256 _new_affiliateSplit)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            _new_affiliateSplit <= 100,\\n            \\\"Affiliate Split Value not allowed\\\"\\n        );\\n        affiliateSplit = _new_affiliateSplit;\\n    }\\n\\n    function set_affiliate(address _affiliate, bool _status)\\n        external\\n        onlyOwner\\n    {\\n        affiliates[_affiliate] = _status;\\n    }\\n\\n    ///@notice Withdraw goodwill share, retaining affilliate share\\n    function withdrawTokens(address[] calldata tokens) external onlyOwner {\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 qty;\\n\\n            if (tokens[i] == ETHAddress) {\\n                qty = address(this).balance.sub(\\n                    totalAffiliateBalance[tokens[i]]\\n                );\\n                Address.sendValue(Address.toPayable(owner()), qty);\\n            } else {\\n                qty = IERC20(tokens[i]).balanceOf(address(this)).sub(\\n                    totalAffiliateBalance[tokens[i]]\\n                );\\n                IERC20(tokens[i]).safeTransfer(owner(), qty);\\n            }\\n        }\\n    }\\n\\n    ///@notice Withdraw affilliate share, retaining goodwill share\\n    function affilliateWithdraw(address[] calldata tokens) external {\\n        uint256 tokenBal;\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            tokenBal = affiliateBalance[msg.sender][tokens[i]];\\n            affiliateBalance[msg.sender][tokens[i]] = 0;\\n            totalAffiliateBalance[tokens[i]] = totalAffiliateBalance[tokens[i]]\\n                .sub(tokenBal);\\n\\n            if (tokens[i] == ETHAddress) {\\n                Address.sendValue(msg.sender, tokenBal);\\n            } else {\\n                IERC20(tokens[i]).safeTransfer(msg.sender, tokenBal);\\n            }\\n        }\\n    }\\n\\n    function() external payable {\\n        require(msg.sender != tx.origin, \\\"Do not send ETH directly\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oz/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oz/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance =\\n            token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance =\\n            token.allowance(address(this), spender).sub(\\n                value,\\n                \\\"SafeERC20: decreased allowance below zero\\\"\\n            );\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(\\n                abi.decode(returndata, (bool)),\\n                \\\"SafeERC20: ERC20 operation did not succeed\\\"\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oz/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor() internal {}\\n\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oz/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/oz/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oz/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n\\n        bytes32 accountHash =\\n            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            codehash := extcodehash(account)\\n        }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account)\\n        internal\\n        pure\\n        returns (address payable)\\n    {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance >= amount,\\n            \\\"Address: insufficient balance\\\"\\n        );\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(\\n            success,\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MaticBridge/Zapper_Matic_Bridge_V1.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice This contract swaps and bridges ETH/Tokens to Matic/Polygon\\n// SPDX-License-Identifier: GPLv2\\n\\npragma solidity ^0.5.7;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../_base/ZapBaseV1.sol\\\";\\n\\n// PoS Bridge\\ninterface IRootChainManager {\\n    function depositEtherFor(address user) external payable;\\n\\n    function depositFor(\\n        address user,\\n        address rootToken,\\n        bytes calldata depositData\\n    ) external;\\n\\n    function tokenToType(address) external returns (bytes32);\\n\\n    function typeToPredicate(bytes32) external returns (address);\\n}\\n\\n// Plasma Bridge\\ninterface IDepositManager {\\n    function depositERC20ForUser(\\n        address _token,\\n        address _user,\\n        uint256 _amount\\n    ) external;\\n}\\n\\ncontract Zapper_Matic_Bridge_V1_2 is ZapBaseV1 {\\n    IRootChainManager public rootChainManager;\\n    IDepositManager public depositManager;\\n\\n    address private constant maticAddress =\\n        0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0;\\n\\n    constructor(uint256 _goodwill, uint256 _affiliateSplit)\\n        public\\n        ZapBaseV1(_goodwill, _affiliateSplit)\\n    {\\n        rootChainManager = IRootChainManager(\\n            0xA0c68C638235ee32657e8f720a23ceC1bFc77C77\\n        );\\n        depositManager = IDepositManager(\\n            0x401F6c983eA34274ec46f84D70b31C151321188b\\n        );\\n        IERC20(maticAddress).approve(address(depositManager), uint256(-1));\\n    }\\n\\n    /**\\n    @notice Bridge from Ethereum to Matic\\n    @notice Use index 0 for primary swap and index 1 for matic swap\\n    @param fromToken Address of the token to swap from\\n    @param toToken Address of the token to bridge\\n    @param swapAmounts Quantites of fromToken to swap to toToken and matic\\n    @param minTokensRec Minimum acceptable quantity of swapped tokens and/or matic\\n    @param swapTargets Execution targets for swaps\\n    @param swapData DEX swap data\\n    @param affiliate Affiliate address\\n    */\\n    function ZapBridge(\\n        address fromToken,\\n        address toToken,\\n        uint256[2] calldata swapAmounts,\\n        uint256[2] calldata minTokensRec,\\n        address[2] calldata swapTargets,\\n        bytes[2] calldata swapData,\\n        address affiliate\\n    ) external payable {\\n        uint256[2] memory toInvest =\\n            _pullTokens(fromToken, swapAmounts, affiliate);\\n\\n        if (swapAmounts[0] > 0) {\\n            // Token swap\\n            uint256 toTokenAmt =\\n                _fillQuote(\\n                    fromToken,\\n                    toInvest[0],\\n                    toToken,\\n                    swapTargets[0],\\n                    swapData[0]\\n                );\\n            require(toTokenAmt >= minTokensRec[0], \\\"ERR: High Slippage 1\\\");\\n\\n            _bridgeToken(toToken, toTokenAmt);\\n        }\\n\\n        // Matic swap\\n        if (swapAmounts[1] > 0) {\\n            uint256 maticAmount =\\n                _fillQuote(\\n                    fromToken,\\n                    toInvest[1],\\n                    maticAddress,\\n                    swapTargets[1],\\n                    swapData[1]\\n                );\\n            require(maticAmount >= minTokensRec[1], \\\"ERR: High Slippage 2\\\");\\n\\n            _bridgeMatic(maticAmount);\\n        }\\n    }\\n\\n    function _bridgeToken(address toToken, uint256 toTokenAmt) internal {\\n        if (toToken == address(0)) {\\n            rootChainManager.depositEtherFor.value(toTokenAmt)(msg.sender);\\n        } else {\\n            bytes32 tokenType = rootChainManager.tokenToType(toToken);\\n            address predicate = rootChainManager.typeToPredicate(tokenType);\\n            _approveToken(toToken, predicate);\\n            rootChainManager.depositFor(\\n                msg.sender,\\n                toToken,\\n                abi.encode(toTokenAmt)\\n            );\\n        }\\n    }\\n\\n    function _bridgeMatic(uint256 maticAmount) internal {\\n        depositManager.depositERC20ForUser(\\n            maticAddress,\\n            msg.sender,\\n            maticAmount\\n        );\\n    }\\n\\n    // 0x Swap\\n    function _fillQuote(\\n        address fromToken,\\n        uint256 amount,\\n        address toToken,\\n        address swapTarget,\\n        bytes memory swapCallData\\n    ) internal returns (uint256 amtBought) {\\n        uint256 valueToSend;\\n\\n        if (fromToken == toToken) {\\n            return amount;\\n        }\\n\\n        if (fromToken == address(0)) {\\n            valueToSend = amount;\\n        } else {\\n            _approveToken(fromToken, swapTarget);\\n        }\\n\\n        uint256 iniBal = _getBalance(toToken);\\n        (bool success, ) = swapTarget.call.value(valueToSend)(swapCallData);\\n        require(success, \\\"Error Swapping Tokens\\\");\\n        uint256 finalBal = _getBalance(toToken);\\n\\n        amtBought = finalBal.sub(iniBal);\\n    }\\n\\n    function _pullTokens(\\n        address fromToken,\\n        uint256[2] memory swapAmounts,\\n        address affiliate\\n    ) internal returns (uint256[2] memory toInvest) {\\n        if (fromToken == address(0)) {\\n            require(msg.value > 0, \\\"No eth sent\\\");\\n            require(\\n                swapAmounts[0].add(swapAmounts[1]) == msg.value,\\n                \\\"msg.value != fromTokenAmounts\\\"\\n            );\\n        } else {\\n            require(msg.value == 0, \\\"Eth sent with token\\\");\\n\\n            // transfer token\\n            IERC20(fromToken).safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                swapAmounts[0].add(swapAmounts[1])\\n            );\\n        }\\n\\n        if (swapAmounts[0] > 0) {\\n            toInvest[0] = swapAmounts[0].sub(\\n                _subtractGoodwill(fromToken, swapAmounts[0], affiliate)\\n            );\\n        }\\n\\n        if (swapAmounts[1] > 0) {\\n            toInvest[1] = swapAmounts[1].sub(\\n                _subtractGoodwill(fromToken, swapAmounts[1], affiliate)\\n            );\\n        }\\n    }\\n\\n    function _subtractGoodwill(\\n        address token,\\n        uint256 amount,\\n        address affiliate\\n    ) internal returns (uint256 totalGoodwillPortion) {\\n        bool whitelisted = feeWhitelist[msg.sender];\\n        if (!whitelisted && goodwill > 0) {\\n            totalGoodwillPortion = SafeMath.div(\\n                SafeMath.mul(amount, goodwill),\\n                10000\\n            );\\n\\n            if (affiliates[affiliate]) {\\n                if (token == address(0)) {\\n                    token = ETHAddress;\\n                }\\n\\n                uint256 affiliatePortion =\\n                    totalGoodwillPortion.mul(affiliateSplit).div(100);\\n                affiliateBalance[affiliate][token] = affiliateBalance[\\n                    affiliate\\n                ][token]\\n                    .add(affiliatePortion);\\n                totalAffiliateBalance[token] = totalAffiliateBalance[token].add(\\n                    affiliatePortion\\n                );\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/1inch/Mooniswap_ZapIn_V1.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice This contract adds liquidity to 1inch mooniswap pools using any token\\n// SPDX-License-Identifier: GPLv2\\n\\npragma solidity ^0.5.7;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../_base/ZapBaseV1.sol\\\";\\n\\ninterface IMooniswap {\\n    function getTokens() external view returns (address[] memory tokens);\\n\\n    function tokens(uint256 i) external view returns (IERC20);\\n\\n    function deposit(\\n        uint256[2] calldata maxAmounts,\\n        uint256[2] calldata minAmounts\\n    )\\n        external\\n        payable\\n        returns (uint256 fairSupply, uint256[2] memory receivedAmounts);\\n\\n    function depositFor(\\n        uint256[2] calldata maxAmounts,\\n        uint256[2] calldata minAmounts,\\n        address target\\n    )\\n        external\\n        payable\\n        returns (uint256 fairSupply, uint256[2] memory receivedAmounts);\\n}\\n\\ncontract Mooniswap_ZapIn_V1 is ZapBaseV1 {\\n    constructor(uint256 _goodwill, uint256 _affiliateSplit)\\n        public\\n        ZapBaseV1(_goodwill, _affiliateSplit)\\n    {}\\n\\n    event zapIn(address sender, address pool, uint256 tokensRec);\\n\\n    /**\\n    @notice Adds liquidity to 1inch pools with an any token\\n    @param fromToken The ERC20 token used for investment (address(0x00) if ether)\\n    @param toPool The 1inch pool to add liquidity to\\n    @param minPoolTokens Minimum acceptable quantity of LP tokens to receive\\n    @param fromTokenAmounts Quantities of fromToken to invest into each poolToken\\n    @param swapTargets Excecution targets for both swaps\\n    @param swapData DEX swap data\\n    @param affiliate Affiliate address\\n    @return Quantitiy of LP received\\n     */\\n\\n    function ZapIn(\\n        address fromToken,\\n        address toPool,\\n        uint256 minPoolTokens,\\n        uint256[] calldata fromTokenAmounts,\\n        address[] calldata swapTargets,\\n        bytes[] calldata swapData,\\n        address affiliate\\n    ) external payable stopInEmergency returns (uint256 lpReceived) {\\n        // get incoming tokens\\n        uint256[2] memory toInvest =\\n            _pullTokens(fromToken, fromTokenAmounts, affiliate);\\n\\n        uint256[] memory amounts = new uint256[](2);\\n\\n        // get underlying tokens\\n        address[] memory tokens = IMooniswap(toPool).getTokens();\\n\\n        // No swap if fromToken is underlying\\n        if (fromToken == tokens[0]) {\\n            amounts[0] = toInvest[0];\\n        } else {\\n            // swap 50% fromToken to token 0\\n            amounts[0] = _fillQuote(\\n                fromToken,\\n                tokens[0],\\n                toInvest[0],\\n                swapTargets[0],\\n                swapData[0]\\n            );\\n        }\\n        // No swap if fromToken is underlying\\n        if (fromToken == tokens[1]) {\\n            amounts[1] = toInvest[1];\\n        } else {\\n            // swap 50% fromToken to token 1\\n            amounts[1] = _fillQuote(\\n                fromToken,\\n                tokens[1],\\n                toInvest[1],\\n                swapTargets[1],\\n                swapData[1]\\n            );\\n        }\\n\\n        lpReceived = _inchDeposit(tokens, amounts, toPool);\\n\\n        require(lpReceived >= minPoolTokens, \\\"ERR: High Slippage\\\");\\n    }\\n\\n    function _inchDeposit(\\n        address[] memory tokens,\\n        uint256[] memory amounts,\\n        address toPool\\n    ) internal returns (uint256 lpReceived) {\\n        // minToken amounts = 90% of token amounts\\n        uint256[2] memory minAmounts =\\n            [amounts[0].mul(90).div(100), amounts[1].mul(90).div(100)];\\n        uint256[2] memory receivedAmounts;\\n\\n        // tokens[1] is never ETH, approving for both cases\\n        IERC20(tokens[1]).safeApprove(toPool, 0);\\n        IERC20(tokens[1]).safeApprove(toPool, amounts[1]);\\n\\n        if (tokens[0] == address(0)) {\\n            (lpReceived, receivedAmounts) = IMooniswap(toPool).depositFor.value(\\n                amounts[0]\\n            )([amounts[0], amounts[1]], minAmounts, msg.sender);\\n        } else {\\n            IERC20(tokens[0]).safeApprove(toPool, 0);\\n            IERC20(tokens[0]).safeApprove(toPool, amounts[0]);\\n            (lpReceived, receivedAmounts) = IMooniswap(toPool).depositFor(\\n                [amounts[0], amounts[1]],\\n                minAmounts,\\n                msg.sender\\n            );\\n        }\\n\\n        emit zapIn(msg.sender, toPool, lpReceived);\\n\\n        // transfer any residue\\n        for (uint8 i = 0; i < 2; i++) {\\n            if (amounts[i] > receivedAmounts[i] + 1) {\\n                _transferTokens(tokens[i], amounts[i].sub(receivedAmounts[i]));\\n            }\\n        }\\n    }\\n\\n    function _fillQuote(\\n        address fromTokenAddress,\\n        address toToken,\\n        uint256 amount,\\n        address swapTarget,\\n        bytes memory swapCallData\\n    ) internal returns (uint256 amtBought) {\\n        uint256 valueToSend;\\n        if (fromTokenAddress == address(0)) {\\n            valueToSend = amount;\\n        } else {\\n            IERC20 fromToken = IERC20(fromTokenAddress);\\n            fromToken.safeApprove(address(swapTarget), 0);\\n            fromToken.safeApprove(address(swapTarget), amount);\\n        }\\n\\n        uint256 iniBal = _getBalance(toToken);\\n        (bool success, ) = swapTarget.call.value(valueToSend)(swapCallData);\\n        require(success, \\\"Error Swapping Tokens\\\");\\n        uint256 finalBal = _getBalance(toToken);\\n\\n        amtBought = finalBal.sub(iniBal);\\n    }\\n\\n    function _transferTokens(address token, uint256 amt) internal {\\n        if (token == address(0)) {\\n            Address.sendValue(msg.sender, amt);\\n        } else {\\n            IERC20(token).safeTransfer(msg.sender, amt);\\n        }\\n    }\\n\\n    function _pullTokens(\\n        address fromToken,\\n        uint256[] memory fromTokenAmounts,\\n        address affiliate\\n    ) internal returns (uint256[2] memory toInvest) {\\n        if (fromToken == address(0)) {\\n            require(msg.value > 0, \\\"No eth sent\\\");\\n            require(\\n                fromTokenAmounts[0].add(fromTokenAmounts[1]) == msg.value,\\n                \\\"msg.value != fromTokenAmounts\\\"\\n            );\\n        } else {\\n            require(msg.value == 0, \\\"Eth sent with token\\\");\\n\\n            // transfer token\\n            IERC20(fromToken).safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                fromTokenAmounts[0].add(fromTokenAmounts[1])\\n            );\\n        }\\n\\n        toInvest[0] = fromTokenAmounts[0].sub(\\n            _subtractGoodwill(fromToken, fromTokenAmounts[0], affiliate)\\n        );\\n        toInvest[1] = fromTokenAmounts[1].sub(\\n            _subtractGoodwill(fromToken, fromTokenAmounts[1], affiliate)\\n        );\\n    }\\n\\n    function _subtractGoodwill(\\n        address token,\\n        uint256 amount,\\n        address affiliate\\n    ) internal returns (uint256 totalGoodwillPortion) {\\n        bool whitelisted = feeWhitelist[msg.sender];\\n        if (!whitelisted && goodwill > 0) {\\n            totalGoodwillPortion = SafeMath.div(\\n                SafeMath.mul(amount, goodwill),\\n                10000\\n            );\\n\\n            if (affiliates[affiliate]) {\\n                if (token == address(0)) {\\n                    token = ETHAddress;\\n                }\\n\\n                uint256 affiliatePortion =\\n                    totalGoodwillPortion.mul(affiliateSplit).div(100);\\n                affiliateBalance[affiliate][token] = affiliateBalance[\\n                    affiliate\\n                ][token]\\n                    .add(affiliatePortion);\\n                totalAffiliateBalance[token] = totalAffiliateBalance[token].add(\\n                    affiliatePortion\\n                );\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/_base/ZapOutBaseV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.7;\\n\\nimport \\\"./ZapBaseV1.sol\\\";\\n\\ncontract ZapOutBaseV2_1 is ZapBaseV1 {\\n    /**\\n    @dev Transfer tokens from msg.sender to this contract\\n    @param token The ERC20 token to transfer to this contract\\n    @param shouldSellEntireBalance If True transfers entrire allowable amount from another contract\\n    @return Quantity of tokens transferred to this contract\\n     */\\n    function _pullTokens(\\n        address token,\\n        uint256 amount,\\n        bool shouldSellEntireBalance\\n    ) internal returns (uint256) {\\n        if (shouldSellEntireBalance) {\\n            require(\\n                Address.isContract(msg.sender),\\n                \\\"ERR: shouldSellEntireBalance is true for EOA\\\"\\n            );\\n\\n            IERC20 _token = IERC20(token);\\n            uint256 allowance = _token.allowance(msg.sender, address(this));\\n            _token.safeTransferFrom(msg.sender, address(this), allowance);\\n\\n            return allowance;\\n        } else {\\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n\\n            return amount;\\n        }\\n    }\\n\\n    function _subtractGoodwill(\\n        address token,\\n        uint256 amount,\\n        address affiliate,\\n        bool enableGoodwill\\n    ) internal returns (uint256 totalGoodwillPortion) {\\n        bool whitelisted = feeWhitelist[msg.sender];\\n        if (enableGoodwill && !whitelisted && goodwill > 0) {\\n            totalGoodwillPortion = SafeMath.div(\\n                SafeMath.mul(amount, goodwill),\\n                10000\\n            );\\n\\n            if (affiliates[affiliate]) {\\n                if (token == address(0)) {\\n                    token = ETHAddress;\\n                }\\n\\n                uint256 affiliatePortion =\\n                    totalGoodwillPortion.mul(affiliateSplit).div(100);\\n                affiliateBalance[affiliate][token] = affiliateBalance[\\n                    affiliate\\n                ][token]\\n                    .add(affiliatePortion);\\n                totalAffiliateBalance[token] = totalAffiliateBalance[token].add(\\n                    affiliatePortion\\n                );\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Polygon/Sushiswap/Sushiswap_ZapOut_Polygon_V1.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// Visit <https://www.gnu.org/licenses/>for a copy of the GNU Affero General Public License\\n\\n///@author Zapper\\n///@notice this contract implements one click removal of liquidity from Sushiswap pools, receiving ETH, ERC tokens or both.\\n// SPDX-License-Identifier: GPLv2\\n\\npragma solidity ^0.5.7;\\npragma experimental ABIEncoderV2;\\nimport \\\"../../_base/ZapOutBaseV2.sol\\\";\\n\\ninterface IUniswapV2Router02 {\\n    function WETH() external pure returns (address);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n}\\n\\ninterface IUniswapV2Pair {\\n    function token0() external pure returns (address);\\n\\n    function token1() external pure returns (address);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n            uint32 _blockTimestampLast\\n        );\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\\ninterface IWETH {\\n    function withdraw(uint256 wad) external;\\n}\\n\\ncontract Sushiswap_ZapOut_Polygon_V1 is ZapOutBaseV2_1 {\\n    uint256 private constant deadline =\\n        0xf000000000000000000000000000000000000000000000000000000000000000;\\n\\n    // sushiSwap\\n    IUniswapV2Router02 private constant sushiSwapRouter =\\n        IUniswapV2Router02(0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506);\\n\\n    address private constant wmaticTokenAddress =\\n        address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\\n\\n    constructor(uint256 _goodwill, uint256 _affiliateSplit)\\n        public\\n        ZapBaseV1(_goodwill, _affiliateSplit)\\n    {}\\n\\n    event zapOut(\\n        address sender,\\n        address pool,\\n        address token,\\n        uint256 tokensRec\\n    );\\n\\n    /**\\n    @notice Zap out in both tokens with permit\\n    @param fromSushiPool Pool from which to remove liquidity\\n    @param incomingLP Quantity of LP to remove from pool\\n    @param affiliate Affiliate address to share fees\\n    @return  amountA, amountB - Quantity of tokens received \\n    */\\n    function ZapOut2PairToken(\\n        address fromSushiPool,\\n        uint256 incomingLP,\\n        address affiliate,\\n        bool shouldSellEntireBalance\\n    ) public stopInEmergency returns (uint256 amountA, uint256 amountB) {\\n        IUniswapV2Pair pair = IUniswapV2Pair(fromSushiPool);\\n\\n        require(\\n            address(pair) != address(0),\\n            \\\"Error: Invalid Sushipool Address\\\"\\n        );\\n\\n        //get reserves\\n        address token0 = pair.token0();\\n        address token1 = pair.token1();\\n\\n        incomingLP = _pullTokens(\\n            fromSushiPool,\\n            incomingLP,\\n            shouldSellEntireBalance\\n        );\\n\\n        _approveToken(fromSushiPool, address(sushiSwapRouter), incomingLP);\\n\\n        if (token0 == wmaticTokenAddress || token1 == wmaticTokenAddress) {\\n            address _token = token0 == wmaticTokenAddress ? token1 : token0;\\n            (amountA, amountB) = sushiSwapRouter.removeLiquidityETH(\\n                _token,\\n                incomingLP,\\n                1,\\n                1,\\n                address(this),\\n                deadline\\n            );\\n\\n            // subtract goodwill\\n            uint256 tokenGoodwill =\\n                _subtractGoodwill(_token, amountA, affiliate, true);\\n            uint256 ethGoodwill =\\n                _subtractGoodwill(ETHAddress, amountB, affiliate, true);\\n\\n            // send tokens\\n            IERC20(_token).safeTransfer(msg.sender, amountA.sub(tokenGoodwill));\\n            Address.sendValue(msg.sender, amountB.sub(ethGoodwill));\\n        } else {\\n            (amountA, amountB) = sushiSwapRouter.removeLiquidity(\\n                token0,\\n                token1,\\n                incomingLP,\\n                1,\\n                1,\\n                address(this),\\n                deadline\\n            );\\n\\n            // subtract goodwill\\n            uint256 tokenAGoodwill =\\n                _subtractGoodwill(token0, amountA, affiliate, true);\\n            uint256 tokenBGoodwill =\\n                _subtractGoodwill(token1, amountB, affiliate, true);\\n\\n            // send tokens\\n            IERC20(token0).safeTransfer(\\n                msg.sender,\\n                amountA.sub(tokenAGoodwill)\\n            );\\n            IERC20(token1).safeTransfer(\\n                msg.sender,\\n                amountB.sub(tokenBGoodwill)\\n            );\\n        }\\n        emit zapOut(msg.sender, fromSushiPool, token0, amountA);\\n        emit zapOut(msg.sender, fromSushiPool, token1, amountB);\\n    }\\n\\n    /**\\n    @notice Zap out in a single token\\n    @param toToken Address of desired token\\n    @param fromSushiPool Pool from which to remove liquidity\\n    @param incomingLP Quantity of LP to remove from pool\\n    @param minTokensRec Minimum quantity of tokens to receive\\n    @param swapTargets Execution targets for swaps\\n    @param allowanceTargets Targets to approve for swaps\\n    @param swapData DEX swap data\\n    @param affiliate Affiliate address\\n    @param shouldSellEntireBalance True if amountIn is determined at execution time (i.e. contract is caller)\\n    */\\n    function ZapOut(\\n        address toToken,\\n        address fromSushiPool,\\n        uint256 incomingLP,\\n        uint256 minTokensRec,\\n        address[] memory swapTargets,\\n        address[] memory allowanceTargets,\\n        bytes[] memory swapData,\\n        address affiliate,\\n        bool shouldSellEntireBalance\\n    ) public stopInEmergency returns (uint256 tokenBought) {\\n        incomingLP = _pullTokens(\\n            fromSushiPool,\\n            incomingLP,\\n            shouldSellEntireBalance\\n        );\\n\\n        (uint256 amountA, uint256 amountB) =\\n            _removeLiquidity(fromSushiPool, incomingLP);\\n\\n        tokenBought = _swapTokens(\\n            fromSushiPool,\\n            amountA,\\n            amountB,\\n            toToken,\\n            swapTargets,\\n            allowanceTargets,\\n            swapData\\n        );\\n\\n        require(tokenBought >= minTokensRec, \\\"High slippage\\\");\\n\\n        uint256 tokensRec = _transfer(toToken, tokenBought, affiliate);\\n\\n        emit zapOut(msg.sender, fromSushiPool, toToken, tokensRec);\\n\\n        return tokensRec;\\n    }\\n\\n    function _transfer(\\n        address token,\\n        uint256 amount,\\n        address affiliate\\n    ) internal returns (uint256 tokensTransferred) {\\n        uint256 totalGoodwillPortion;\\n\\n        if (token == address(0)) {\\n            totalGoodwillPortion = _subtractGoodwill(\\n                ETHAddress,\\n                amount,\\n                affiliate,\\n                true\\n            );\\n\\n            msg.sender.transfer(amount.sub(totalGoodwillPortion));\\n        } else {\\n            totalGoodwillPortion = _subtractGoodwill(\\n                token,\\n                amount,\\n                affiliate,\\n                true\\n            );\\n\\n            IERC20(token).safeTransfer(\\n                msg.sender,\\n                amount.sub(totalGoodwillPortion)\\n            );\\n        }\\n        tokensTransferred = amount.sub(totalGoodwillPortion);\\n    }\\n\\n    function _removeLiquidity(address fromSushiPool, uint256 incomingLP)\\n        internal\\n        returns (uint256 amountA, uint256 amountB)\\n    {\\n        IUniswapV2Pair pair = IUniswapV2Pair(fromSushiPool);\\n\\n        require(\\n            address(pair) != address(0),\\n            \\\"Error: Invalid Sushipool Address\\\"\\n        );\\n\\n        address token0 = pair.token0();\\n        address token1 = pair.token1();\\n\\n        _approveToken(fromSushiPool, address(sushiSwapRouter), incomingLP);\\n\\n        (amountA, amountB) = sushiSwapRouter.removeLiquidity(\\n            token0,\\n            token1,\\n            incomingLP,\\n            1,\\n            1,\\n            address(this),\\n            deadline\\n        );\\n        require(amountA > 0 && amountB > 0, \\\"Removed insufficient liquidity\\\");\\n    }\\n\\n    function _swapTokens(\\n        address fromSushiPool,\\n        uint256 amountA,\\n        uint256 amountB,\\n        address toToken,\\n        address[] memory swapTargets,\\n        address[] memory allowanceTargets,\\n        bytes[] memory swapData\\n    ) internal returns (uint256 tokensBought) {\\n        IUniswapV2Pair pair = IUniswapV2Pair(fromSushiPool);\\n        address token0 = pair.token0();\\n        address token1 = pair.token1();\\n\\n        //swap token0 to toToken\\n        if (token0 == toToken) {\\n            tokensBought = tokensBought.add(amountA);\\n        } else {\\n            tokensBought = tokensBought.add(\\n                _fillQuote(\\n                    token0,\\n                    toToken,\\n                    amountA,\\n                    swapTargets[0],\\n                    allowanceTargets[0],\\n                    swapData[0]\\n                )\\n            );\\n        }\\n\\n        //swap token1 to toToken\\n        if (token1 == toToken) {\\n            tokensBought = tokensBought.add(amountB);\\n        } else {\\n            //swap token using 0x swap\\n            tokensBought = tokensBought.add(\\n                _fillQuote(\\n                    token1,\\n                    toToken,\\n                    amountB,\\n                    swapTargets[1],\\n                    allowanceTargets[1],\\n                    swapData[1]\\n                )\\n            );\\n        }\\n    }\\n\\n    function _fillQuote(\\n        address fromTokenAddress,\\n        address toToken,\\n        uint256 amount,\\n        address swapTarget,\\n        address allowanceTarget,\\n        bytes memory swapData\\n    ) internal returns (uint256) {\\n        uint256 valueToSend;\\n\\n        if (fromTokenAddress == wmaticTokenAddress && toToken == address(0)) {\\n            IWETH(wmaticTokenAddress).withdraw(amount);\\n            return amount;\\n        }\\n\\n        if (fromTokenAddress == address(0)) {\\n            valueToSend = amount;\\n        } else {\\n            _approveToken(fromTokenAddress, allowanceTarget, amount);\\n        }\\n\\n        uint256 initialBalance = _getBalance(toToken);\\n\\n        (bool success, ) = swapTarget.call.value(valueToSend)(swapData);\\n        require(success, \\\"Error Swapping Tokens\\\");\\n\\n        uint256 finalBalance = _getBalance(toToken).sub(initialBalance);\\n\\n        require(finalBalance > 0, \\\"Swapped to Invalid Intermediate\\\");\\n\\n        return finalBalance;\\n    }\\n\\n    /**\\n    @notice Utility function to determine quantity and addresses of tokens being removed\\n    @param fromSushiPool Pool from which to remove liquidity\\n    @param liquidity Quantity of LP tokens to remove.\\n    @return  amountA- amountB- Quantity of token0 and token1 removed\\n    @return  token0- token1- Addresses of the underlying tokens to be removed\\n    */\\n    function removeLiquidityReturn(address fromSushiPool, uint256 liquidity)\\n        external\\n        view\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            address token0,\\n            address token1\\n        )\\n    {\\n        IUniswapV2Pair pair = IUniswapV2Pair(fromSushiPool);\\n        token0 = pair.token0();\\n        token1 = pair.token1();\\n\\n        uint256 balance0 = IERC20(token0).balanceOf(fromSushiPool);\\n        uint256 balance1 = IERC20(token1).balanceOf(fromSushiPool);\\n\\n        uint256 _totalSupply = pair.totalSupply();\\n\\n        amountA = liquidity.mul(balance0) / _totalSupply;\\n        amountB = liquidity.mul(balance1) / _totalSupply;\\n    }\\n\\n    function() external payable {\\n        require(msg.sender != tx.origin, \\\"Do not send ETH directly\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Curve/Curve_ZapOut_General_V4_1.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice This contract removes liquidity from Curve pools\\n\\npragma solidity ^0.5.7;\\nimport \\\"../_base/ZapOutBaseV2.sol\\\";\\nimport \\\"./Curve_Registry_V2.sol\\\";\\n\\ninterface ICurveSwap {\\n    function remove_liquidity_one_coin(\\n        uint256 _token_amount,\\n        int128 i,\\n        uint256 min_amount\\n    ) external;\\n\\n    function remove_liquidity_one_coin(\\n        uint256 _token_amount,\\n        int128 i,\\n        uint256 min_amount,\\n        bool removeUnderlying\\n    ) external;\\n\\n    function calc_withdraw_one_coin(uint256 tokenAmount, int128 index)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\\ninterface IWETH {\\n    function withdraw(uint256 wad) external;\\n}\\n\\ncontract Curve_ZapOut_General_V4_1 is ZapOutBaseV2_1 {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    address private constant wethTokenAddress =\\n        address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n\\n    Curve_Registry_V2 public curveReg;\\n\\n    mapping(address => bool) public approvedTargets;\\n\\n    constructor(\\n        Curve_Registry_V2 _curveRegistry,\\n        uint256 _goodwill,\\n        uint256 _affiliateSplit\\n    ) public ZapBaseV1(_goodwill, _affiliateSplit) {\\n        approvedTargets[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;\\n        curveReg = _curveRegistry;\\n    }\\n\\n    event zapOut(\\n        address sender,\\n        address pool,\\n        address token,\\n        uint256 tokensRec\\n    );\\n\\n    /**\\n    @notice This method removes the liquidity from curve pools to ETH/ERC tokens\\n    @param swapAddress indicates Curve swap address for the pool\\n    @param incomingCrv indicates the amount of lp tokens to remove\\n    @param intermediateToken specifies in which token to exit the curve pool\\n    @param toToken indicates the ETH/ERC token to which tokens to convert\\n    @param minToTokens indicates the minimum amount of toTokens to receive\\n    @param _swapTarget Excecution target for the first swap\\n    @param _swapCallData DEX quote data\\n    @param affiliate Affiliate address to share fees\\n    @param shouldSellEntireBalance True if incomingCrv is determined at execution time (i.e. contract is caller)\\n    @return ToTokensBought- indicates the amount of toTokens received\\n     */\\n    function ZapOut(\\n        address swapAddress,\\n        uint256 incomingCrv,\\n        address intermediateToken,\\n        address toToken,\\n        uint256 minToTokens,\\n        address _swapTarget,\\n        bytes calldata _swapCallData,\\n        address affiliate,\\n        bool shouldSellEntireBalance\\n    ) external stopInEmergency returns (uint256 ToTokensBought) {\\n        address poolTokenAddress = curveReg.getTokenAddress(swapAddress);\\n\\n        // get lp tokens\\n        incomingCrv = _pullTokens(\\n            poolTokenAddress,\\n            incomingCrv,\\n            shouldSellEntireBalance\\n        );\\n\\n        if (intermediateToken == address(0)) {\\n            intermediateToken = ETHAddress;\\n        }\\n\\n        // perform zapOut\\n        ToTokensBought = _zapOut(\\n            swapAddress,\\n            incomingCrv,\\n            intermediateToken,\\n            toToken,\\n            _swapTarget,\\n            _swapCallData\\n        );\\n        require(ToTokensBought >= minToTokens, \\\"High Slippage\\\");\\n\\n        uint256 totalGoodwillPortion;\\n\\n        // Transfer tokens\\n        if (toToken == address(0)) {\\n            totalGoodwillPortion = _subtractGoodwill(\\n                ETHAddress,\\n                ToTokensBought,\\n                affiliate,\\n                true\\n            );\\n            Address.sendValue(\\n                msg.sender,\\n                ToTokensBought.sub(totalGoodwillPortion)\\n            );\\n        } else {\\n            totalGoodwillPortion = _subtractGoodwill(\\n                toToken,\\n                ToTokensBought,\\n                affiliate,\\n                true\\n            );\\n\\n            IERC20(toToken).safeTransfer(\\n                msg.sender,\\n                ToTokensBought.sub(totalGoodwillPortion)\\n            );\\n        }\\n\\n        emit zapOut(msg.sender, swapAddress, toToken, ToTokensBought);\\n\\n        return ToTokensBought.sub(totalGoodwillPortion);\\n    }\\n\\n    function _zapOut(\\n        address swapAddress,\\n        uint256 incomingCrv,\\n        address intermediateToken,\\n        address toToken,\\n        address _swapTarget,\\n        bytes memory _swapCallData\\n    ) internal returns (uint256 ToTokensBought) {\\n        (bool isUnderlying, uint256 underlyingIndex) =\\n            curveReg.isUnderlyingToken(swapAddress, intermediateToken);\\n\\n        // not metapool\\n        if (isUnderlying) {\\n            uint256 intermediateBought =\\n                _exitCurve(\\n                    swapAddress,\\n                    incomingCrv,\\n                    underlyingIndex,\\n                    intermediateToken\\n                );\\n\\n            if (intermediateToken == ETHAddress) intermediateToken = address(0);\\n\\n            ToTokensBought = _fillQuote(\\n                intermediateToken,\\n                toToken,\\n                intermediateBought,\\n                _swapTarget,\\n                _swapCallData\\n            );\\n        } else {\\n            // from metapool\\n            address[4] memory poolTokens = curveReg.getPoolTokens(swapAddress);\\n            address intermediateSwapAddress;\\n            uint8 i;\\n            for (; i < 4; i++) {\\n                if (curveReg.getSwapAddress(poolTokens[i]) != address(0)) {\\n                    intermediateSwapAddress = curveReg.getSwapAddress(\\n                        poolTokens[i]\\n                    );\\n                    break;\\n                }\\n            }\\n            // _exitCurve to intermediateSwapAddress Token\\n            uint256 intermediateCrvBought =\\n                _exitMetaCurve(swapAddress, incomingCrv, i, poolTokens[i]);\\n            // _performZapOut: fromPool = intermediateSwapAddress\\n            ToTokensBought = _zapOut(\\n                intermediateSwapAddress,\\n                intermediateCrvBought,\\n                intermediateToken,\\n                toToken,\\n                _swapTarget,\\n                _swapCallData\\n            );\\n        }\\n    }\\n\\n    /**\\n    @notice This method removes the liquidity from meta curve pools\\n    @param swapAddress indicates the curve pool address from which liquidity to be removed.\\n    @param incomingCrv indicates the amount of liquidity to be removed from the pool\\n    @param index indicates the index of underlying token of the pool in which liquidity will be removed. \\n    @return tokensReceived- indicates the amount of reserve tokens received \\n    */\\n    function _exitMetaCurve(\\n        address swapAddress,\\n        uint256 incomingCrv,\\n        uint256 index,\\n        address exitTokenAddress\\n    ) internal returns (uint256 tokensReceived) {\\n        require(incomingCrv > 0, \\\"Insufficient lp tokens\\\");\\n\\n        address tokenAddress = curveReg.getTokenAddress(swapAddress);\\n        _approveToken(tokenAddress, swapAddress);\\n\\n        uint256 iniTokenBal = IERC20(exitTokenAddress).balanceOf(address(this));\\n        ICurveSwap(swapAddress).remove_liquidity_one_coin(\\n            incomingCrv,\\n            int128(index),\\n            0\\n        );\\n        tokensReceived = (IERC20(exitTokenAddress).balanceOf(address(this)))\\n            .sub(iniTokenBal);\\n\\n        require(tokensReceived > 0, \\\"Could not receive reserve tokens\\\");\\n    }\\n\\n    /**\\n    @notice This method removes the liquidity from given curve pool\\n    @param swapAddress indicates the curve pool address from which liquidity to be removed.\\n    @param incomingCrv indicates the amount of liquidity to be removed from the pool\\n    @param index indicates the index of underlying token of the pool in which liquidity will be removed. \\n    @return tokensReceived- indicates the amount of reserve tokens received \\n    */\\n    function _exitCurve(\\n        address swapAddress,\\n        uint256 incomingCrv,\\n        uint256 index,\\n        address exitTokenAddress\\n    ) internal returns (uint256 tokensReceived) {\\n        require(incomingCrv > 0, \\\"Insufficient lp tokens\\\");\\n\\n        address depositAddress = curveReg.getDepositAddress(swapAddress);\\n\\n        address tokenAddress = curveReg.getTokenAddress(swapAddress);\\n        _approveToken(tokenAddress, depositAddress);\\n\\n        address balanceToken =\\n            exitTokenAddress == ETHAddress ? address(0) : exitTokenAddress;\\n\\n        uint256 iniTokenBal = _getBalance(balanceToken);\\n\\n        if (curveReg.shouldAddUnderlying(swapAddress)) {\\n            // aave\\n            ICurveSwap(depositAddress).remove_liquidity_one_coin(\\n                incomingCrv,\\n                int128(index),\\n                0,\\n                true\\n            );\\n        } else {\\n            ICurveSwap(depositAddress).remove_liquidity_one_coin(\\n                incomingCrv,\\n                int128(index),\\n                0\\n            );\\n        }\\n\\n        tokensReceived = _getBalance(balanceToken).sub(iniTokenBal);\\n\\n        require(tokensReceived > 0, \\\"Could not receive reserve tokens\\\");\\n    }\\n\\n    /**\\n    @notice This method swaps the fromToken to toToken using the 0x swap\\n    @param _fromTokenAddress indicates the ETH/ERC20 token\\n    @param _toTokenAddress indicates the ETH/ERC20 token\\n    @param _amount indicates the amount of from tokens to swap\\n    @param _swapTarget Excecution target for the first swap\\n    @param _swapCallData DEX quote data\\n    */\\n    function _fillQuote(\\n        address _fromTokenAddress,\\n        address _toTokenAddress,\\n        uint256 _amount,\\n        address _swapTarget,\\n        bytes memory _swapCallData\\n    ) internal returns (uint256 amountBought) {\\n        if (_fromTokenAddress == _toTokenAddress) return _amount;\\n        if (_swapTarget == wethTokenAddress) {\\n            IWETH(wethTokenAddress).withdraw(_amount);\\n            return _amount;\\n        }\\n        uint256 valueToSend;\\n        if (_fromTokenAddress == ETHAddress || _fromTokenAddress == address(0))\\n            valueToSend = _amount;\\n        else _approveToken(_fromTokenAddress, _swapTarget);\\n\\n        uint256 iniBal = _getBalance(_toTokenAddress);\\n        require(approvedTargets[_swapTarget], \\\"Target not Authorized\\\");\\n        (bool success, ) = _swapTarget.call.value(valueToSend)(_swapCallData);\\n        require(success, \\\"Error Swapping Tokens\\\");\\n        uint256 finalBal = _getBalance(_toTokenAddress);\\n\\n        amountBought = finalBal.sub(iniBal);\\n\\n        require(amountBought > 0, \\\"Swapped To Invalid Intermediate\\\");\\n    }\\n\\n    /**\\n    @notice Utility function to determine the quantity and address of a token being removed\\n    @param swapAddress indicates the curve pool address from which liquidity to be removed\\n    @param tokenAddress token to be removed\\n    @param liquidity Quantity of LP tokens to remove.\\n    @return  amount Quantity of token removed\\n    */\\n    function removeLiquidityReturn(\\n        address swapAddress,\\n        address tokenAddress,\\n        uint256 liquidity\\n    ) external view returns (uint256 amount) {\\n        if (tokenAddress == address(0)) tokenAddress = ETHAddress;\\n        (bool underlying, uint256 index) =\\n            curveReg.isUnderlyingToken(swapAddress, tokenAddress);\\n        if (underlying) {\\n            return\\n                ICurveSwap(curveReg.getDepositAddress(swapAddress))\\n                    .calc_withdraw_one_coin(liquidity, int128(index));\\n        } else {\\n            address[4] memory poolTokens = curveReg.getPoolTokens(swapAddress);\\n            address intermediateSwapAddress;\\n            for (uint256 i = 0; i < 4; i++) {\\n                intermediateSwapAddress = curveReg.getSwapAddress(\\n                    poolTokens[i]\\n                );\\n                if (intermediateSwapAddress != address(0)) break;\\n            }\\n            uint256 metaTokensRec =\\n                ICurveSwap(swapAddress).calc_withdraw_one_coin(liquidity, 1);\\n\\n            (, index) = curveReg.isUnderlyingToken(\\n                intermediateSwapAddress,\\n                tokenAddress\\n            );\\n\\n            return\\n                ICurveSwap(intermediateSwapAddress).calc_withdraw_one_coin(\\n                    metaTokensRec,\\n                    int128(index)\\n                );\\n        }\\n    }\\n\\n    function updateCurveRegistry(Curve_Registry_V2 newCurveRegistry)\\n        external\\n        onlyOwner\\n    {\\n        require(newCurveRegistry != curveReg, \\\"Already using this Registry\\\");\\n        curveReg = newCurveRegistry;\\n    }\\n\\n    function setApprovedTargets(\\n        address[] calldata targets,\\n        bool[] calldata isApproved\\n    ) external onlyOwner {\\n        require(targets.length == isApproved.length, \\\"Invalid Input length\\\");\\n\\n        for (uint256 i = 0; i < targets.length; i++) {\\n            approvedTargets[targets[i]] = isApproved[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Curve/Curve_Registry_V2.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2020 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice Registry for Curve Pools with Utility functions.\\n\\npragma solidity ^0.5.7;\\n\\nimport \\\"../oz/ownership/Ownable.sol\\\";\\nimport \\\"../oz/token/ERC20/SafeERC20.sol\\\";\\n\\ninterface ICurveAddressProvider {\\n    function get_registry() external view returns (address);\\n\\n    function get_address(uint256 _id) external view returns (address);\\n}\\n\\ninterface ICurveRegistry {\\n    function get_pool_from_lp_token(address lpToken)\\n        external\\n        view\\n        returns (address);\\n\\n    function get_lp_token(address swapAddress) external view returns (address);\\n\\n    function get_n_coins(address _pool)\\n        external\\n        view\\n        returns (uint256[2] memory);\\n\\n    function get_coins(address _pool) external view returns (address[8] memory);\\n\\n    function get_underlying_coins(address _pool)\\n        external\\n        view\\n        returns (address[8] memory);\\n}\\n\\ninterface ICurveFactoryRegistry {\\n    function get_n_coins(address _pool)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    function get_coins(address _pool) external view returns (address[2] memory);\\n\\n    function get_underlying_coins(address _pool)\\n        external\\n        view\\n        returns (address[8] memory);\\n}\\n\\ncontract Curve_Registry_V2 is Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    ICurveAddressProvider private constant CurveAddressProvider =\\n        ICurveAddressProvider(0x0000000022D53366457F9d5E68Ec105046FC4383);\\n    ICurveRegistry public CurveRegistry;\\n\\n    ICurveFactoryRegistry public FactoryRegistry;\\n\\n    address private constant wbtcToken =\\n        0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\\n    address private constant sbtcCrvToken =\\n        0x075b1bb99792c9E1041bA13afEf80C91a1e70fB3;\\n    address internal constant ETHAddress =\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    mapping(address => bool) public shouldAddUnderlying;\\n    mapping(address => address) private depositAddresses;\\n\\n    constructor() public {\\n        CurveRegistry = ICurveRegistry(CurveAddressProvider.get_registry());\\n        FactoryRegistry = ICurveFactoryRegistry(\\n            CurveAddressProvider.get_address(3)\\n        );\\n    }\\n\\n    function isCurvePool(address swapAddress) public view returns (bool) {\\n        if (CurveRegistry.get_lp_token(swapAddress) != address(0)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function isFactoryPool(address swapAddress) public view returns (bool) {\\n        if (FactoryRegistry.get_coins(swapAddress)[0] != address(0)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n    @notice This function is used to get the curve pool deposit address\\n    @notice The deposit address is used for pools with wrapped (c, y) tokens\\n    @param swapAddress Curve swap address for the pool\\n    @return curve pool deposit address or the swap address not mapped\\n    */\\n    function getDepositAddress(address swapAddress)\\n        external\\n        view\\n        returns (address depositAddress)\\n    {\\n        depositAddress = depositAddresses[swapAddress];\\n        if (depositAddress == address(0)) return swapAddress;\\n    }\\n\\n    /**\\n    @notice This function is used to get the curve pool swap address\\n    @notice The token and swap address is the same for metapool factory pools\\n    @param swapAddress Curve swap address for the pool\\n    @return curve pool swap address or address(0) if pool doesnt exist\\n    */\\n    function getSwapAddress(address tokenAddress)\\n        external\\n        view\\n        returns (address swapAddress)\\n    {\\n        swapAddress = CurveRegistry.get_pool_from_lp_token(tokenAddress);\\n        if (swapAddress != address(0)) {\\n            return swapAddress;\\n        }\\n        if (isFactoryPool(swapAddress)) {\\n            return tokenAddress;\\n        }\\n        return address(0);\\n    }\\n\\n    /**\\n    @notice This function is used to check the curve pool token address\\n    @notice The token and swap address is the same for metapool factory pools\\n    @param swapAddress Curve swap address for the pool\\n    @return curve pool token address or address(0) if pool doesnt exist\\n    */\\n    function getTokenAddress(address swapAddress)\\n        external\\n        view\\n        returns (address tokenAddress)\\n    {\\n        tokenAddress = CurveRegistry.get_lp_token(swapAddress);\\n        if (tokenAddress != address(0)) {\\n            return tokenAddress;\\n        }\\n        if (isFactoryPool(swapAddress)) {\\n            return swapAddress;\\n        }\\n        return address(0);\\n    }\\n\\n    /**\\n    @notice Checks the number of non-underlying tokens in a pool\\n    @param swapAddress Curve swap address for the pool\\n    @return number of underlying tokens in the pool\\n    */\\n    function getNumTokens(address swapAddress) public view returns (uint256) {\\n        if (isCurvePool(swapAddress)) {\\n            return CurveRegistry.get_n_coins(swapAddress)[0];\\n        } else {\\n            (uint256 numTokens, ) = FactoryRegistry.get_n_coins(swapAddress);\\n            return numTokens;\\n        }\\n    }\\n\\n    /**\\n    @notice This function is used to check if the curve pool is a metapool\\n    @notice all factory pools are metapools\\n    @param swapAddress Curve swap address for the pool\\n    @return true if the pool is a metapool, false otherwise\\n    */\\n    function isMetaPool(address swapAddress) public view returns (bool) {\\n        if (isCurvePool(swapAddress)) {\\n            uint256[2] memory poolTokenCounts =\\n                CurveRegistry.get_n_coins(swapAddress);\\n            if (poolTokenCounts[0] == poolTokenCounts[1]) return false;\\n            else return true;\\n        }\\n        if (isFactoryPool(swapAddress)) return true;\\n    }\\n\\n    /**\\n    @notice This function returns an array of underlying pool token addresses\\n    @param swapAddress Curve swap address for the pool\\n    @return returns 4 element array containing the addresses of the pool tokens (0 address if pool contains < 4 tokens)\\n    */\\n    function getPoolTokens(address swapAddress)\\n        public\\n        view\\n        returns (address[4] memory poolTokens)\\n    {\\n        if (isMetaPool(swapAddress)) {\\n            if (isFactoryPool(swapAddress)) {\\n                address[2] memory poolUnderlyingCoins =\\n                    FactoryRegistry.get_coins(swapAddress);\\n                for (uint256 i = 0; i < 2; i++) {\\n                    poolTokens[i] = poolUnderlyingCoins[i];\\n                }\\n            } else {\\n                address[8] memory poolUnderlyingCoins =\\n                    CurveRegistry.get_coins(swapAddress);\\n                for (uint256 i = 0; i < 2; i++) {\\n                    poolTokens[i] = poolUnderlyingCoins[i];\\n                }\\n            }\\n\\n            return poolTokens;\\n        } else {\\n            address[8] memory poolUnderlyingCoins;\\n            if (isBtcPool(swapAddress) && !isMetaPool(swapAddress)) {\\n                poolUnderlyingCoins = CurveRegistry.get_coins(swapAddress);\\n            } else {\\n                poolUnderlyingCoins = CurveRegistry.get_underlying_coins(\\n                    swapAddress\\n                );\\n            }\\n            for (uint256 i = 0; i < 4; i++) {\\n                poolTokens[i] = poolUnderlyingCoins[i];\\n            }\\n        }\\n    }\\n\\n    /**\\n    @notice This function checks if the curve pool contains WBTC\\n    @param swapAddress Curve swap address for the pool\\n    @return true if the pool contains WBTC, false otherwise\\n    */\\n    function isBtcPool(address swapAddress) public view returns (bool) {\\n        address[8] memory poolTokens = CurveRegistry.get_coins(swapAddress);\\n        for (uint256 i = 0; i < 4; i++) {\\n            if (poolTokens[i] == wbtcToken || poolTokens[i] == sbtcCrvToken)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n    @notice This function checks if the curve pool contains ETH\\n    @param swapAddress Curve swap address for the pool\\n    @return true if the pool contains ETH, false otherwise\\n    */\\n    function isEthPool(address swapAddress) external view returns (bool) {\\n        address[8] memory poolTokens = CurveRegistry.get_coins(swapAddress);\\n        for (uint256 i = 0; i < 4; i++) {\\n            if (poolTokens[i] == ETHAddress) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n    @notice This function is used to check if the pool contains the token\\n    @param swapAddress Curve swap address for the pool\\n    @param tokenContractAddress contract address of the token\\n    @return true if the pool contains the token, false otherwise\\n    @return index of the token in the pool, 0 if pool does not contain the token\\n    */\\n    function isUnderlyingToken(\\n        address swapAddress,\\n        address tokenContractAddress\\n    ) external view returns (bool, uint256) {\\n        address[4] memory poolTokens = getPoolTokens(swapAddress);\\n        for (uint256 i = 0; i < 4; i++) {\\n            if (poolTokens[i] == address(0)) return (false, 0);\\n            if (poolTokens[i] == tokenContractAddress) return (true, i);\\n        }\\n    }\\n\\n    /**\\n    @notice Updates to the latest curve registry from the address provider\\n    */\\n    function update_curve_registry() external onlyOwner {\\n        address new_address = CurveAddressProvider.get_registry();\\n\\n        require(address(CurveRegistry) != new_address, \\\"Already updated\\\");\\n\\n        CurveRegistry = ICurveRegistry(new_address);\\n    }\\n\\n    /**\\n    @notice Updates to the latest curve registry from the address provider\\n    */\\n    function update_factory_registry() external onlyOwner {\\n        address new_address = CurveAddressProvider.get_address(3);\\n\\n        require(address(FactoryRegistry) != new_address, \\\"Already updated\\\");\\n\\n        FactoryRegistry = ICurveFactoryRegistry(new_address);\\n    }\\n\\n    /**\\n    @notice Add new pools which use the _use_underlying bool\\n    @param swapAddresses Curve swap addresses for the pool\\n    @param addUnderlying True if underlying tokens are always added\\n    */\\n    function updateShouldAddUnderlying(\\n        address[] calldata swapAddresses,\\n        bool[] calldata addUnderlying\\n    ) external onlyOwner {\\n        require(\\n            swapAddresses.length == addUnderlying.length,\\n            \\\"Mismatched arrays\\\"\\n        );\\n        for (uint256 i = 0; i < swapAddresses.length; i++) {\\n            shouldAddUnderlying[swapAddresses[i]] = addUnderlying[i];\\n        }\\n    }\\n\\n    /**\\n    @notice Add new pools which use uamounts for add_liquidity\\n    @param swapAddresses Curve swap addresses to map from\\n    @param _depositAddresses Curve deposit addresses to map to\\n    */\\n    function updateDepositAddresses(\\n        address[] calldata swapAddresses,\\n        address[] calldata _depositAddresses\\n    ) external onlyOwner {\\n        require(\\n            swapAddresses.length == _depositAddresses.length,\\n            \\\"Mismatched arrays\\\"\\n        );\\n        for (uint256 i = 0; i < swapAddresses.length; i++) {\\n            depositAddresses[swapAddresses[i]] = _depositAddresses[i];\\n        }\\n    }\\n\\n    /**\\n    //@notice Add new pools which use the _use_underlying bool\\n    */\\n    function withdrawTokens(address[] calldata tokens) external onlyOwner {\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 qty;\\n\\n            if (tokens[i] == ETHAddress) {\\n                qty = address(this).balance;\\n                Address.sendValue(Address.toPayable(owner()), qty);\\n            } else {\\n                qty = IERC20(tokens[i]).balanceOf(address(this));\\n                IERC20(tokens[i]).safeTransfer(owner(), qty);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/yEarn/yvBoost_Migrator_V1.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice This contract migrates liquidity from the Sushi yveCRV/ETH Pickle Jar to the Sushi yvBOOST/ETH Pickle Jar\\n// SPDX-License-Identifier: GPLv2\\n\\npragma solidity ^0.5.7;\\nimport \\\"../oz/ownership/Ownable.sol\\\";\\nimport \\\"../oz/token/ERC20/SafeERC20.sol\\\";\\n\\ninterface IPickleJar {\\n    function token() external view returns (address);\\n\\n    function withdraw(uint256 _shares) external;\\n\\n    function getRatio() external view returns (uint256);\\n\\n    function deposit(uint256 amount) external;\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function WETH() external pure returns (address);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n}\\n\\ninterface IUniswapV2Pair {\\n    function token0() external pure returns (address);\\n\\n    function token1() external pure returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n            uint32 _blockTimestampLast\\n        );\\n}\\n\\ninterface IYearnZapIn {\\n    function ZapIn(\\n        address fromToken,\\n        uint256 amountIn,\\n        address toVault,\\n        address superVault,\\n        bool isAaveUnderlying,\\n        uint256 minYVTokens,\\n        address intermediateToken,\\n        address swapTarget,\\n        bytes calldata swapData,\\n        address affiliate\\n    ) external payable returns (uint256 yvBoostRec);\\n}\\n\\ncontract yvBoost_Migrator_V1_0_1 is Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n    bool public stopped = false;\\n\\n    address constant yveCRV_ETH_Sushi =\\n        0x10B47177E92Ef9D5C6059055d92DdF6290848991;\\n    address constant yveCRV_ETH_pJar =\\n        0x5Eff6d166D66BacBC1BF52E2C54dD391AE6b1f48;\\n\\n    address constant yvBOOST_ETH_Sushi =\\n        0x9461173740D27311b176476FA27e94C681b1Ea6b;\\n    address constant yvBOOST_ETH_pJar =\\n        0xCeD67a187b923F0E5ebcc77C7f2F7da20099e378;\\n\\n    address constant yveCRV = 0xc5bDdf9843308380375a611c18B50Fb9341f502A;\\n\\n    address constant yvBOOST = 0x9d409a0A012CFbA9B15F6D4B36Ac57A46966Ab9a;\\n\\n    IUniswapV2Router02 private constant sushiSwapRouter =\\n        IUniswapV2Router02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\\n\\n    uint256 private constant deadline =\\n        0xf000000000000000000000000000000000000000000000000000000000000000;\\n\\n    IYearnZapIn yearnZapIn;\\n\\n    constructor(address _yearnZapIn) public {\\n        yearnZapIn = IYearnZapIn(_yearnZapIn);\\n    }\\n\\n    // circuit breaker modifiers\\n    modifier stopInEmergency {\\n        if (stopped) {\\n            revert(\\\"Temporarily Paused\\\");\\n        } else {\\n            _;\\n        }\\n    }\\n\\n    /**\\n    @notice This function migrates pTokens from pSushi yveCRV-ETH to pSushi yveBOOST-ETH \\n    @param IncomingLP Quantity of pSushi yveCRV-ETH tokens to migrate\\n    @param minPTokens The minimum acceptable quantity vault tokens to receive. Reverts otherwise\\n    @return pTokensRec- Quantity of pSushi yveBOOST-ETH tokens acquired\\n     */\\n    function Migrate(uint256 IncomingLP, uint256 minPTokens)\\n        external\\n        stopInEmergency\\n        returns (uint256 pTokensRec)\\n    {\\n        IERC20(yveCRV_ETH_pJar).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            IncomingLP\\n        );\\n\\n        uint256 underlyingReceived = _jarWithdraw(yveCRV_ETH_pJar, IncomingLP);\\n\\n        (uint256 amountA, uint256 amountB, address tokenA, ) =\\n            _sushiWithdraw(underlyingReceived);\\n\\n        uint256 wethRec = tokenA == yveCRV ? amountB : amountA;\\n\\n        uint256 yvBoostRec =\\n            _yearnDeposit(tokenA == yveCRV ? amountA : amountB);\\n\\n        IUniswapV2Pair pair = IUniswapV2Pair(yvBOOST_ETH_Sushi);\\n\\n        uint256 token0Amt = pair.token0() == yvBOOST ? yvBoostRec : wethRec;\\n        uint256 token1Amt = pair.token1() == yvBOOST ? yvBoostRec : wethRec;\\n\\n        uint256 sushiLpRec =\\n            _sushiDeposit(pair.token0(), pair.token1(), token0Amt, token1Amt);\\n\\n        pTokensRec = _jarDeposit(sushiLpRec);\\n\\n        require(pTokensRec >= minPTokens, \\\"ERR: High Slippage\\\");\\n\\n        IERC20(yvBOOST_ETH_pJar).transfer(msg.sender, pTokensRec);\\n    }\\n\\n    function _jarWithdraw(address fromJar, uint256 amount)\\n        internal\\n        returns (uint256 underlyingReceived)\\n    {\\n        uint256 iniUnderlyingBal = _getBalance(yveCRV_ETH_Sushi);\\n        IPickleJar(fromJar).withdraw(amount);\\n        underlyingReceived = _getBalance(yveCRV_ETH_Sushi).sub(\\n            iniUnderlyingBal\\n        );\\n    }\\n\\n    function _jarDeposit(uint256 amount)\\n        internal\\n        returns (uint256 pTokensReceived)\\n    {\\n        _approveToken(yvBOOST_ETH_Sushi, yvBOOST_ETH_pJar, amount);\\n\\n        uint256 iniYVaultBal = _getBalance(yvBOOST_ETH_pJar);\\n\\n        IPickleJar(yvBOOST_ETH_pJar).deposit(amount);\\n\\n        pTokensReceived = _getBalance(yvBOOST_ETH_pJar).sub(iniYVaultBal);\\n    }\\n\\n    function _yearnDeposit(uint256 amountIn)\\n        internal\\n        returns (uint256 yvBoostRec)\\n    {\\n        _approveToken(yveCRV, address(yearnZapIn), amountIn);\\n\\n        yvBoostRec = yearnZapIn.ZapIn(\\n            yveCRV,\\n            amountIn,\\n            yvBOOST,\\n            address(0),\\n            false,\\n            0,\\n            yveCRV,\\n            address(0),\\n            \\\"\\\",\\n            address(0)\\n        );\\n    }\\n\\n    function _sushiWithdraw(uint256 IncomingLP)\\n        internal\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            address tokenA,\\n            address tokenB\\n        )\\n    {\\n        _approveToken(yveCRV_ETH_Sushi, address(sushiSwapRouter), IncomingLP);\\n\\n        IUniswapV2Pair pair = IUniswapV2Pair(yveCRV_ETH_Sushi);\\n\\n        address token0 = pair.token0();\\n        address token1 = pair.token1();\\n        (amountA, amountB) = sushiSwapRouter.removeLiquidity(\\n            token0,\\n            token1,\\n            IncomingLP,\\n            1,\\n            1,\\n            address(this),\\n            deadline\\n        );\\n        return (amountA, amountB, tokenA, tokenB);\\n    }\\n\\n    function _sushiDeposit(\\n        address toUnipoolToken0,\\n        address toUnipoolToken1,\\n        uint256 token0Bought,\\n        uint256 token1Bought\\n    ) internal returns (uint256) {\\n        _approveToken(toUnipoolToken0, address(sushiSwapRouter), token0Bought);\\n        _approveToken(toUnipoolToken1, address(sushiSwapRouter), token1Bought);\\n\\n        (uint256 amountA, uint256 amountB, uint256 LP) =\\n            sushiSwapRouter.addLiquidity(\\n                toUnipoolToken0,\\n                toUnipoolToken1,\\n                token0Bought,\\n                token1Bought,\\n                1,\\n                1,\\n                address(this),\\n                deadline\\n            );\\n\\n        //Returning Residue in token0, if any\\n        if (token0Bought.sub(amountA) > 0) {\\n            IERC20(toUnipoolToken0).safeTransfer(\\n                msg.sender,\\n                token0Bought.sub(amountA)\\n            );\\n        }\\n\\n        //Returning Residue in token1, if any\\n        if (token1Bought.sub(amountB) > 0) {\\n            IERC20(toUnipoolToken1).safeTransfer(\\n                msg.sender,\\n                token1Bought.sub(amountB)\\n            );\\n        }\\n\\n        return LP;\\n    }\\n\\n    function _getBalance(address token)\\n        internal\\n        view\\n        returns (uint256 balance)\\n    {\\n        if (token == address(0)) {\\n            balance = address(this).balance;\\n        } else {\\n            balance = IERC20(token).balanceOf(address(this));\\n        }\\n    }\\n\\n    function _approveToken(\\n        address token,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        IERC20 _token = IERC20(token);\\n        _token.safeApprove(spender, 0);\\n        _token.safeApprove(spender, amount);\\n    }\\n\\n    function withdrawTokens(address[] calldata tokens) external onlyOwner {\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 qty;\\n\\n            if (tokens[i] == address(0)) {\\n                qty = address(this).balance;\\n                Address.sendValue(Address.toPayable(owner()), qty);\\n            } else {\\n                qty = IERC20(tokens[i]).balanceOf(address(this));\\n                IERC20(tokens[i]).safeTransfer(owner(), qty);\\n            }\\n        }\\n    }\\n\\n    function updateYearnZapIn(address _yearnZapIn) external onlyOwner {\\n        yearnZapIn = IYearnZapIn(_yearnZapIn);\\n    }\\n\\n    // - to Pause the contract\\n    function toggleContractActive() public onlyOwner {\\n        stopped = !stopped;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/_base/ZapOutBaseV1.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.7;\\n\\nimport \\\"./ZapBaseV1.sol\\\";\\n\\ncontract ZapOutBaseV1 is ZapBaseV1 {\\n    function _subtractGoodwill(\\n        address token,\\n        uint256 amount,\\n        address affiliate,\\n        bool enableGoodwill\\n    ) internal returns (uint256 totalGoodwillPortion) {\\n        bool whitelisted = feeWhitelist[msg.sender];\\n        if (enableGoodwill && !whitelisted && goodwill > 0) {\\n            totalGoodwillPortion = SafeMath.div(\\n                SafeMath.mul(amount, goodwill),\\n                10000\\n            );\\n\\n            if (affiliates[affiliate]) {\\n                if (token == address(0)) {\\n                    token = ETHAddress;\\n                }\\n\\n                uint256 affiliatePortion =\\n                    totalGoodwillPortion.mul(affiliateSplit).div(100);\\n                affiliateBalance[affiliate][token] = affiliateBalance[\\n                    affiliate\\n                ][token]\\n                    .add(affiliatePortion);\\n                totalAffiliateBalance[token] = totalAffiliateBalance[token].add(\\n                    affiliatePortion\\n                );\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/yEarn/yVault_ZapOut_V2.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice This contract removes liquidity from yEarn Vaults to ETH or ERC20 Tokens.\\n// SPDX-License-Identifier: GPLv2\\n\\npragma solidity ^0.5.7;\\nimport \\\"../_base/ZapOutBaseV1.sol\\\";\\n\\ninterface IYVault {\\n    function deposit(uint256) external;\\n\\n    function withdraw(uint256) external;\\n\\n    function getPricePerFullShare() external view returns (uint256);\\n\\n    function token() external view returns (address);\\n\\n    function decimals() external view returns (uint256);\\n\\n    // V2\\n    function pricePerShare() external view returns (uint256);\\n}\\n\\ninterface IYVaultV1Registry {\\n    function getVaults() external view returns (address[] memory);\\n\\n    function getVaultsLength() external view returns (uint256);\\n}\\n\\n// -- Aave --\\ninterface IAaveLendingPoolAddressesProvider {\\n    function getLendingPool() external view returns (address);\\n\\n    function getLendingPoolCore() external view returns (address payable);\\n}\\n\\ninterface IAToken {\\n    function redeem(uint256 _amount) external;\\n\\n    function underlyingAssetAddress() external returns (address);\\n}\\n\\ncontract yVault_ZapOut_V2 is ZapOutBaseV1 {\\n    // calldata only accepted for approved zap contracts\\n    mapping(address => bool) public approvedTargets;\\n\\n    IAaveLendingPoolAddressesProvider\\n        private constant lendingPoolAddressProvider =\\n        IAaveLendingPoolAddressesProvider(\\n            0x24a42fD28C976A61Df5D00D0599C34c4f90748c8\\n        );\\n\\n    IYVaultV1Registry V1Registry =\\n        IYVaultV1Registry(0x3eE41C098f9666ed2eA246f4D2558010e59d63A0);\\n\\n    event Zapout(\\n        address _toWhomToIssue,\\n        address _fromYVaultAddress,\\n        address _toTokenAddress,\\n        uint256 _tokensRecieved\\n    );\\n\\n    constructor(uint256 _goodwill, uint256 _affiliateSplit)\\n        public\\n        ZapBaseV1(_goodwill, _affiliateSplit)\\n    {}\\n\\n    /**\\n    @notice Zap out in to a single token with permit\\n    @param fromVault Vault from which to remove liquidity\\n    @param amountIn Quantity of vault tokens to remove\\n    @param toToken Address of desired token\\n    @param isAaveUnderlying True if vault contains aave token\\n    @param minToTokens Minimum quantity of tokens to receive, reverts otherwise\\n    @param permitData Encoded permit data, which contains owner, spender, value, deadline, r,s,v values\\n    @param swapTarget Execution targets for swap or Zap\\n    @param swapData DEX or Zap data\\n    @param affiliate Affiliate address\\n    @return Quantity of tokens or ETH received\\n    */\\n    function ZapOutWithPermit(\\n        address fromVault,\\n        uint256 amountIn,\\n        address toToken,\\n        bool isAaveUnderlying,\\n        uint256 minToTokens,\\n        bytes calldata permitData,\\n        address swapTarget,\\n        bytes calldata swapData,\\n        address affiliate\\n    ) external returns (uint256 tokensReceived) {\\n        // permit\\n        (bool success, ) = fromVault.call(permitData);\\n        require(success, \\\"Could Not Permit\\\");\\n\\n        return\\n            ZapOut(\\n                fromVault,\\n                amountIn,\\n                toToken,\\n                isAaveUnderlying,\\n                minToTokens,\\n                swapTarget,\\n                swapData,\\n                affiliate\\n            );\\n    }\\n\\n    /**\\n    @notice Zap out in to a single token with permit\\n    @param fromVault Vault from which to remove liquidity\\n    @param amountIn Quantity of vault tokens to remove\\n    @param toToken Address of desired token\\n    @param isAaveUnderlying True if vault contains aave token\\n    @param minToTokens Minimum quantity of tokens to receive, reverts otherwise\\n    @param swapTarget Execution targets for swap or Zap\\n    @param swapData DEX or Zap data\\n    @param affiliate Affiliate address\\n    @return Quantity of tokens or ETH received\\n    */\\n    function ZapOut(\\n        address fromVault,\\n        uint256 amountIn,\\n        address toToken,\\n        bool isAaveUnderlying,\\n        uint256 minToTokens,\\n        address swapTarget,\\n        bytes memory swapData,\\n        address affiliate\\n    ) public stopInEmergency returns (uint256 tokensReceived) {\\n        require(\\n            approvedTargets[swapTarget] || swapTarget == address(0),\\n            \\\"Target not Authorized\\\"\\n        );\\n\\n        IERC20(fromVault).safeTransferFrom(msg.sender, address(this), amountIn);\\n\\n        // get underlying token from vault\\n        address underlyingToken = IYVault(fromVault).token();\\n        uint256 underlyingTokenReceived =\\n            _vaultWithdraw(fromVault, amountIn, underlyingToken);\\n\\n        // swap to toToken\\n        uint256 toTokenAmt;\\n\\n        if (isAaveUnderlying) {\\n            address underlyingAsset =\\n                IAToken(underlyingToken).underlyingAssetAddress();\\n            // unwrap atoken\\n            IAToken(underlyingToken).redeem(underlyingTokenReceived);\\n\\n            // aTokens are 1:1\\n            if (underlyingAsset == toToken) {\\n                toTokenAmt = underlyingTokenReceived;\\n            } else {\\n                toTokenAmt = _fillQuote(\\n                    underlyingAsset,\\n                    toToken,\\n                    underlyingTokenReceived,\\n                    swapTarget,\\n                    swapData\\n                );\\n            }\\n        } else {\\n            toTokenAmt = _fillQuote(\\n                underlyingToken,\\n                toToken,\\n                underlyingTokenReceived,\\n                swapTarget,\\n                swapData\\n            );\\n        }\\n        require(toTokenAmt >= minToTokens, \\\"Err: High Slippage\\\");\\n\\n        uint256 totalGoodwillPortion =\\n            _subtractGoodwill(toToken, toTokenAmt, affiliate, true);\\n        tokensReceived = toTokenAmt.sub(totalGoodwillPortion);\\n\\n        // send toTokens\\n        if (toToken == address(0)) {\\n            Address.sendValue(msg.sender, tokensReceived);\\n        } else {\\n            IERC20(toToken).safeTransfer(msg.sender, tokensReceived);\\n        }\\n    }\\n\\n    function _vaultWithdraw(\\n        address fromVault,\\n        uint256 amount,\\n        address underlyingVaultToken\\n    ) internal returns (uint256 underlyingReceived) {\\n        uint256 iniUnderlyingBal = _getBalance(underlyingVaultToken);\\n\\n        IYVault(fromVault).withdraw(amount);\\n\\n        underlyingReceived = _getBalance(underlyingVaultToken).sub(\\n            iniUnderlyingBal\\n        );\\n    }\\n\\n    function _fillQuote(\\n        address _fromTokenAddress,\\n        address toToken,\\n        uint256 _amount,\\n        address _swapTarget,\\n        bytes memory swapCallData\\n    ) internal returns (uint256 amtBought) {\\n        uint256 valueToSend;\\n\\n        if (_fromTokenAddress == toToken) {\\n            return _amount;\\n        }\\n\\n        if (_fromTokenAddress == address(0)) {\\n            valueToSend = _amount;\\n        } else {\\n            _approveToken(_fromTokenAddress, _swapTarget, _amount);\\n        }\\n\\n        uint256 iniBal = _getBalance(toToken);\\n\\n        (bool success, ) = _swapTarget.call.value(valueToSend)(swapCallData);\\n        require(success, \\\"Error Swapping Tokens 1\\\");\\n\\n        uint256 finalBal = _getBalance(toToken);\\n\\n        require(finalBal > 0, \\\"ERR: Swapped to wrong token\\\");\\n\\n        amtBought = finalBal.sub(iniBal);\\n    }\\n\\n    /**\\n    @notice Utility function to determine the quantity of underlying tokens removed from vault\\n    @param fromVault Yearn vault from which to remove liquidity\\n    @param liquidity Quantity of vault tokens to remove\\n    @return Quantity of underlying LP or token removed\\n    */\\n    function removeLiquidityReturn(address fromVault, uint256 liquidity)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        IYVault vault = IYVault(fromVault);\\n\\n        address[] memory V1Vaults = V1Registry.getVaults();\\n\\n        for (uint256 i = 0; i < V1Registry.getVaultsLength(); i++) {\\n            if (V1Vaults[i] == fromVault)\\n                return\\n                    (liquidity.mul(vault.getPricePerFullShare())).div(10**18);\\n        }\\n        return (liquidity.mul(vault.pricePerShare())).div(10**vault.decimals());\\n    }\\n\\n    function setApprovedTargets(\\n        address[] calldata targets,\\n        bool[] calldata isApproved\\n    ) external onlyOwner {\\n        require(targets.length == isApproved.length, \\\"Invalid Input length\\\");\\n\\n        for (uint256 i = 0; i < targets.length; i++) {\\n            approvedTargets[targets[i]] = isApproved[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Pipe/Zapper_Liquidity_Pipe_V1.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// Visit <https://www.gnu.org/licenses/>for a copy of the GNU Affero General Public License\\n\\n///@author Zapper\\n///@notice this contract pipes (rebalances) liquidity among arbitrary pools/vaults\\n\\npragma solidity ^0.5.7;\\npragma experimental ABIEncoderV2;\\nimport \\\"../_base/ZapOutBaseV1.sol\\\";\\n\\ncontract Zapper_Liquidity_Pipe_V1 is ZapOutBaseV1 {\\n    // calldata only accepted for approved zap contracts\\n    mapping(address => bool) public approvedTargets;\\n\\n    modifier OnlyAuthorized(address[] memory swapTargets) {\\n        require(\\n            (approvedTargets[swapTargets[0]] || swapTargets[0] == address(0)) &&\\n                ((approvedTargets[swapTargets[1]]) ||\\n                    swapTargets[1] == address(0)),\\n            \\\"Target not Authorized\\\"\\n        );\\n        _;\\n    }\\n\\n    event zapPipe(\\n        address sender,\\n        address fromPool,\\n        address toPool,\\n        uint256 tokensRec\\n    );\\n\\n    constructor(uint256 _goodwill, uint256 _affiliateSplit)\\n        public\\n        ZapBaseV1(_goodwill, _affiliateSplit)\\n    {}\\n\\n    /**\\n    @param fromPool Pool/vault token address from which to remove liquidity\\n    @param IncomingLP Quantity of LP to remove from fromPool\\n    @param intermediateToken Token to exit fromPool into\\n    @param toPool Destination pool/vault token address\\n    @param minPoolTokens Minimum quantity of tokens to receive\\n    @param swapTargets Execution targets for Zaps\\n    @param swapData Zap data\\n    @param affiliate Affiliate address\\n    */\\n    function ZapPipe(\\n        address fromPool,\\n        uint256 IncomingLP,\\n        address intermediateToken,\\n        address toPool,\\n        uint256 minPoolTokens,\\n        address[] calldata swapTargets,\\n        bytes[] calldata swapData,\\n        address affiliate\\n    )\\n        external\\n        stopInEmergency\\n        OnlyAuthorized(swapTargets)\\n        returns (uint256 tokensRec)\\n    {\\n        IERC20(fromPool).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            IncomingLP\\n        );\\n\\n        uint256 intermediateAmt =\\n            _fillQuote(\\n                fromPool,\\n                intermediateToken,\\n                IncomingLP,\\n                swapTargets[0],\\n                swapData[0]\\n            );\\n\\n        uint256 goodwill =\\n            _subtractGoodwill(\\n                intermediateToken,\\n                intermediateAmt,\\n                affiliate,\\n                true\\n            );\\n\\n        tokensRec = _fillQuote(\\n            intermediateToken,\\n            toPool,\\n            intermediateAmt.sub(goodwill),\\n            swapTargets[1],\\n            swapData[1]\\n        );\\n\\n        require(tokensRec >= minPoolTokens, \\\"ERR: High Slippage\\\");\\n\\n        emit zapPipe(msg.sender, fromPool, toPool, tokensRec);\\n\\n        IERC20(toPool).safeTransfer(msg.sender, tokensRec.sub(goodwill));\\n    }\\n\\n    function _fillQuote(\\n        address fromToken,\\n        address toToken,\\n        uint256 amount,\\n        address swapTarget,\\n        bytes memory swapData\\n    ) internal returns (uint256 finalBalance) {\\n        uint256 valueToSend;\\n        if (fromToken == address(0)) valueToSend = amount;\\n        else _approveToken(fromToken, swapTarget);\\n\\n        uint256 initialBalance = _getBalance(toToken);\\n\\n        (bool success, ) = swapTarget.call.value(valueToSend)(swapData);\\n        require(success, \\\"Error Swapping Tokens\\\");\\n\\n        finalBalance = _getBalance(toToken).sub(initialBalance);\\n\\n        require(finalBalance > 0, \\\"Swapped to Invalid Token\\\");\\n    }\\n\\n    function setApprovedTargets(\\n        address[] calldata targets,\\n        bool[] calldata isApproved\\n    ) external onlyOwner {\\n        require(targets.length == isApproved.length, \\\"Invalid Input length\\\");\\n\\n        for (uint256 i = 0; i < targets.length; i++) {\\n            approvedTargets[targets[i]] = isApproved[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Pickle/Pickle_ZapOut_V1.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice This contract removes liquidity from Pickle Jars to ETH or ERC20 Tokens.\\n// SPDX-License-Identifier: GPLv2\\n\\npragma solidity ^0.5.7;\\nimport \\\"../_base/ZapOutBaseV1.sol\\\";\\n\\ninterface IPickleJar {\\n    function token() external view returns (address);\\n\\n    function withdraw(uint256 _shares) external;\\n\\n    function getRatio() external view returns (uint256);\\n}\\n\\ncontract Pickle_ZapOut_V1 is ZapOutBaseV1 {\\n    // calldata only accepted for approved zap contracts\\n    mapping(address => bool) public approvedTargets;\\n\\n    event Zapout(\\n        address _toWhomToIssue,\\n        address _fromPJarAddress,\\n        address _toTokenAddress,\\n        uint256 _tokensRecieved\\n    );\\n\\n    constructor(uint256 _goodwill, uint256 _affiliateSplit)\\n        public\\n        ZapBaseV1(_goodwill, _affiliateSplit)\\n    {}\\n\\n    /**\\n    @notice Zap out in to a single token or ETH\\n    @param fromJar Pickle Jar from which to remove liquidity\\n    @param amountIn Quantity of Jar tokens to remove\\n    @param toToken Address of desired token\\n    @param minToTokens Minimum quantity of tokens to receive, reverts otherwise\\n    @param swapTarget Execution targets for swap or Zap\\n    @param swapData DEX or Zap data\\n    @param affiliate Affiliate address\\n    @return Quantity of tokens or ETH received\\n    */\\n    function ZapOut(\\n        address fromJar,\\n        uint256 amountIn,\\n        address toToken,\\n        uint256 minToTokens,\\n        address swapTarget,\\n        bytes memory swapData,\\n        address affiliate\\n    ) public stopInEmergency returns (uint256 tokensReceived) {\\n        require(\\n            approvedTargets[swapTarget] || swapTarget == address(0),\\n            \\\"Target not Authorized\\\"\\n        );\\n\\n        IERC20(fromJar).safeTransferFrom(msg.sender, address(this), amountIn);\\n\\n        // withdraw underlying token from jar\\n        address underlyingToken = IPickleJar(fromJar).token();\\n        uint256 underlyingTokenReceived =\\n            _jarWithdraw(fromJar, amountIn, underlyingToken);\\n\\n        // swap to toToken\\n        uint256 toTokenAmt =\\n            _fillQuote(\\n                underlyingToken,\\n                toToken,\\n                underlyingTokenReceived,\\n                swapTarget,\\n                swapData\\n            );\\n        require(toTokenAmt >= minToTokens, \\\"Err: High Slippage\\\");\\n\\n        uint256 totalGoodwillPortion =\\n            _subtractGoodwill(toToken, toTokenAmt, affiliate, true);\\n        tokensReceived = toTokenAmt.sub(totalGoodwillPortion);\\n\\n        // send toTokens\\n        if (toToken == address(0)) {\\n            Address.sendValue(msg.sender, tokensReceived);\\n        } else {\\n            IERC20(toToken).safeTransfer(msg.sender, tokensReceived);\\n        }\\n    }\\n\\n    function _jarWithdraw(\\n        address fromJar,\\n        uint256 amount,\\n        address underlyingToken\\n    ) internal returns (uint256 underlyingReceived) {\\n        uint256 iniUnderlyingBal = _getBalance(underlyingToken);\\n\\n        IPickleJar(fromJar).withdraw(amount);\\n\\n        underlyingReceived = _getBalance(underlyingToken).sub(iniUnderlyingBal);\\n    }\\n\\n    function _fillQuote(\\n        address _fromTokenAddress,\\n        address toToken,\\n        uint256 _amount,\\n        address _swapTarget,\\n        bytes memory swapCallData\\n    ) internal returns (uint256 amtBought) {\\n        uint256 valueToSend;\\n\\n        if (_fromTokenAddress == toToken) {\\n            return _amount;\\n        }\\n\\n        if (_fromTokenAddress == address(0)) {\\n            valueToSend = _amount;\\n        } else {\\n            _approveToken(_fromTokenAddress, _swapTarget, _amount);\\n        }\\n\\n        uint256 iniBal = _getBalance(toToken);\\n\\n        (bool success, ) = _swapTarget.call.value(valueToSend)(swapCallData);\\n        require(success, \\\"Error Swapping Tokens 1\\\");\\n\\n        uint256 finalBal = _getBalance(toToken);\\n\\n        require(finalBal > 0, \\\"ERR: Swapped to wrong token\\\");\\n\\n        amtBought = finalBal.sub(iniBal);\\n    }\\n\\n    /**\\n    @notice Utility function to determine the quantity of underlying tokens removed from jar\\n    @param fromJar Pickle Jar from which to remove liquidity\\n    @param liquidity Quantity of Jar tokens to remove\\n    @return Quantity of underlying LP or token removed\\n    */\\n    function removeLiquidityReturn(IPickleJar fromJar, uint256 liquidity)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return (liquidity.mul(fromJar.getRatio())).div(1e18);\\n    }\\n\\n    function setApprovedTargets(\\n        address[] calldata targets,\\n        bool[] calldata isApproved\\n    ) external onlyOwner {\\n        require(targets.length == isApproved.length, \\\"Invalid Input length\\\");\\n\\n        for (uint256 i = 0; i < targets.length; i++) {\\n            approvedTargets[targets[i]] = isApproved[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/_base/ZapInBaseV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.7;\\n\\nimport \\\"./ZapBaseV1.sol\\\";\\n\\ncontract ZapInBaseV2 is ZapBaseV1 {\\n    function _pullTokens(\\n        address token,\\n        uint256 amount,\\n        address affiliate,\\n        bool enableGoodwill,\\n        bool shouldSellEntireBalance\\n    ) internal returns (uint256 value) {\\n        uint256 totalGoodwillPortion;\\n\\n        if (token == address(0)) {\\n            require(msg.value > 0, \\\"No eth sent\\\");\\n\\n            // subtract goodwill\\n            totalGoodwillPortion = _subtractGoodwill(\\n                ETHAddress,\\n                msg.value,\\n                affiliate,\\n                enableGoodwill\\n            );\\n\\n            return msg.value.sub(totalGoodwillPortion);\\n        }\\n        require(amount > 0, \\\"Invalid token amount\\\");\\n        require(msg.value == 0, \\\"Eth sent with token\\\");\\n\\n        //transfer token\\n        if (shouldSellEntireBalance) {\\n            require(\\n                Address.isContract(msg.sender),\\n                \\\"ERR: shouldSellEntireBalance is true for EOA\\\"\\n            );\\n            amount = IERC20(token).allowance(msg.sender, address(this));\\n        }\\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n\\n        // subtract goodwill\\n        totalGoodwillPortion = _subtractGoodwill(\\n            token,\\n            amount,\\n            affiliate,\\n            enableGoodwill\\n        );\\n\\n        return amount.sub(totalGoodwillPortion);\\n    }\\n\\n    function _subtractGoodwill(\\n        address token,\\n        uint256 amount,\\n        address affiliate,\\n        bool enableGoodwill\\n    ) internal returns (uint256 totalGoodwillPortion) {\\n        bool whitelisted = feeWhitelist[msg.sender];\\n        if (enableGoodwill && !whitelisted && goodwill > 0) {\\n            totalGoodwillPortion = SafeMath.div(\\n                SafeMath.mul(amount, goodwill),\\n                10000\\n            );\\n\\n            if (affiliates[affiliate]) {\\n                if (token == address(0)) {\\n                    token = ETHAddress;\\n                }\\n\\n                uint256 affiliatePortion =\\n                    totalGoodwillPortion.mul(affiliateSplit).div(100);\\n                affiliateBalance[affiliate][token] = affiliateBalance[\\n                    affiliate\\n                ][token]\\n                    .add(affiliatePortion);\\n                totalAffiliateBalance[token] = totalAffiliateBalance[token].add(\\n                    affiliatePortion\\n                );\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Vesper/Vesper_ZapIn_V1.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice This contract adds liquidity to Vesper Vaults using ETH or ERC20 Tokens.\\n\\n// SPDX-License-Identifier: GPLv2\\n\\npragma solidity ^0.5.7;\\nimport \\\"../_base/ZapInBaseV2.sol\\\";\\n\\ninterface IVesper {\\n    function token() external view returns (address);\\n\\n    function deposit(uint256 amount) external;\\n}\\n\\ncontract Vesper_ZapIn_V1 is ZapInBaseV2 {\\n    // calldata only accepted for approved zap contracts\\n    mapping(address => bool) public approvedTargets;\\n\\n    event zapIn(address sender, address pool, uint256 tokensRec);\\n\\n    constructor(uint256 _goodwill, uint256 _affiliateSplit)\\n        public\\n        ZapBaseV1(_goodwill, _affiliateSplit)\\n    {}\\n\\n    /**\\n    @notice This function adds liquidity to a Vesper vaults with ETH or ERC20 tokens\\n    @param fromToken The token used for entry (address(0) if ether)\\n    @param amountIn The amount of fromToken to invest\\n    @param toVault Vesper vault address\\n    @param minVaultTokens The minimum acceptable quantity vault tokens to receive. Reverts otherwise\\n    @param swapTarget Excecution target for the swap or zap\\n    @param swapData DEX or Zap data\\n    @param affiliate Affiliate address\\n    @param shouldSellEntireBalance True if amountIn is determined at execution time (i.e. contract is caller)\\n    @return tokensReceived- Quantity of Vault tokens received\\n     */\\n    function ZapIn(\\n        address fromToken,\\n        uint256 amountIn,\\n        address toVault,\\n        uint256 minVaultTokens,\\n        address swapTarget,\\n        bytes calldata swapData,\\n        address affiliate,\\n        bool shouldSellEntireBalance\\n    ) external payable stopInEmergency returns (uint256 tokensReceived) {\\n        require(\\n            approvedTargets[swapTarget] || swapTarget == address(0),\\n            \\\"Target not Authorized\\\"\\n        );\\n\\n        // get incoming tokens\\n        uint256 toInvest =\\n            _pullTokens(\\n                fromToken,\\n                amountIn,\\n                affiliate,\\n                true,\\n                shouldSellEntireBalance\\n            );\\n\\n        address underlyingVaultToken = IVesper(toVault).token();\\n\\n        // get intermediate token\\n        uint256 intermediateAmt =\\n            _fillQuote(\\n                fromToken,\\n                underlyingVaultToken,\\n                toInvest,\\n                swapTarget,\\n                swapData\\n            );\\n\\n        // Deposit to Vault\\n        tokensReceived = _vaultDeposit(\\n            intermediateAmt,\\n            toVault,\\n            minVaultTokens\\n        );\\n    }\\n\\n    function _vaultDeposit(\\n        uint256 amount,\\n        address toVault,\\n        uint256 minTokensRec\\n    ) internal returns (uint256 tokensReceived) {\\n        address underlyingVaultToken = IVesper(toVault).token();\\n\\n        _approveToken(underlyingVaultToken, toVault);\\n\\n        uint256 iniYVaultBal = IERC20(toVault).balanceOf(address(this));\\n        IVesper(toVault).deposit(amount);\\n        tokensReceived = IERC20(toVault).balanceOf(address(this)).sub(\\n            iniYVaultBal\\n        );\\n        require(tokensReceived >= minTokensRec, \\\"Err: High Slippage\\\");\\n\\n        IERC20(toVault).safeTransfer(msg.sender, tokensReceived);\\n        emit zapIn(msg.sender, toVault, tokensReceived);\\n    }\\n\\n    function _fillQuote(\\n        address _fromTokenAddress,\\n        address toToken,\\n        uint256 _amount,\\n        address _swapTarget,\\n        bytes memory swapCallData\\n    ) internal returns (uint256 amtBought) {\\n        uint256 valueToSend;\\n\\n        if (_fromTokenAddress == toToken) {\\n            return _amount;\\n        }\\n\\n        if (_fromTokenAddress == address(0)) {\\n            valueToSend = _amount;\\n        } else {\\n            _approveToken(_fromTokenAddress, _swapTarget);\\n        }\\n\\n        uint256 iniBal = _getBalance(toToken);\\n        (bool success, ) = _swapTarget.call.value(valueToSend)(swapCallData);\\n        require(success, \\\"Error Swapping Tokens 1\\\");\\n        uint256 finalBal = _getBalance(toToken);\\n\\n        amtBought = finalBal.sub(iniBal);\\n    }\\n\\n    function setApprovedTargets(\\n        address[] calldata targets,\\n        bool[] calldata isApproved\\n    ) external onlyOwner {\\n        require(targets.length == isApproved.length, \\\"Invalid Input length\\\");\\n\\n        for (uint256 i = 0; i < targets.length; i++) {\\n            approvedTargets[targets[i]] = isApproved[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Polygon/Sushiswap/Sushiswap_ZapIn_Polygon_V2.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice This contract adds liquidity to Sushiswap pools on Polygon using ETH or any ERC20 Token.\\n// SPDX-License-Identifier: GPLv2\\n\\npragma solidity ^0.5.7;\\nimport \\\"../../_base/ZapInBaseV2.sol\\\";\\n\\n// import \\\"@uniswap/lib/contracts/libraries/Babylonian.sol\\\";\\nlibrary Babylonian {\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n        // else z = 0\\n    }\\n}\\n\\ninterface IUniswapV2Factory {\\n    function getPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (address);\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n}\\n\\ninterface IUniswapV2Pair {\\n    function token0() external pure returns (address);\\n\\n    function token1() external pure returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n            uint32 _blockTimestampLast\\n        );\\n}\\n\\ncontract Sushiswap_ZapIn_Polygon_V2 is ZapInBaseV2 {\\n    // sushiSwap\\n    IUniswapV2Router02 private constant sushiSwapRouter =\\n        IUniswapV2Router02(0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506);\\n    IUniswapV2Factory private constant sushiSwapFactoryAddress =\\n        IUniswapV2Factory(0xc35DADB65012eC5796536bD9864eD8773aBc74C4);\\n\\n    uint256 private constant deadline =\\n        0xf000000000000000000000000000000000000000000000000000000000000000;\\n\\n    constructor(uint256 _goodwill, uint256 _affiliateSplit)\\n        public\\n        ZapBaseV1(_goodwill, _affiliateSplit)\\n    {}\\n\\n    event zapIn(address sender, address pool, uint256 tokensRec);\\n\\n    /**\\n    @notice This function is used to invest in given Sushiswap pair through ETH/ERC20 Tokens\\n    @param fromToken The ERC20 token used for investment (address(0x00) if ether)\\n    @param pairAddress The Sushiswap pair address\\n    @param amount The amount of fromToken to invest\\n    @param minPoolTokens Reverts if less tokens received than this\\n    @param swapTarget Excecution target for the first swap\\n    @param allowanceTarget Target to approve for swap\\n    @param swapData Dex quote data\\n    @param affiliate Affiliate address\\n    @param transferResidual Set false to save gas by donating the residual remaining after a Zap\\n    @param shouldSellEntireBalance True if amountIn is determined at execution time (i.e. contract is caller)\\n    @return Amount of LP bought\\n     */\\n    function ZapIn(\\n        address fromToken,\\n        address pairAddress,\\n        uint256 amount,\\n        uint256 minPoolTokens,\\n        address swapTarget,\\n        address allowanceTarget,\\n        bytes calldata swapData,\\n        address affiliate,\\n        bool transferResidual,\\n        bool shouldSellEntireBalance\\n    ) external payable stopInEmergency returns (uint256) {\\n        uint256 toInvest =\\n            _pullTokens(\\n                fromToken,\\n                amount,\\n                affiliate,\\n                true,\\n                shouldSellEntireBalance\\n            );\\n\\n        uint256 LPBought =\\n            _performZapIn(\\n                fromToken,\\n                pairAddress,\\n                toInvest,\\n                swapTarget,\\n                allowanceTarget,\\n                swapData,\\n                transferResidual\\n            );\\n        require(LPBought >= minPoolTokens, \\\"ERR: High Slippage\\\");\\n\\n        emit zapIn(msg.sender, pairAddress, LPBought);\\n\\n        IERC20(pairAddress).safeTransfer(msg.sender, LPBought);\\n        return LPBought;\\n    }\\n\\n    function _getPairTokens(address pairAddress)\\n        internal\\n        pure\\n        returns (address token0, address token1)\\n    {\\n        IUniswapV2Pair sushiPair = IUniswapV2Pair(pairAddress);\\n        token0 = sushiPair.token0();\\n        token1 = sushiPair.token1();\\n    }\\n\\n    function _performZapIn(\\n        address fromToken,\\n        address pairAddress,\\n        uint256 amount,\\n        address swapTarget,\\n        address allowanceTarget,\\n        bytes memory swapData,\\n        bool transferResidual\\n    ) internal returns (uint256) {\\n        uint256 intermediateAmt;\\n        address intermediateToken;\\n        (address _ToSushipoolToken0, address _ToSushipoolToken1) =\\n            _getPairTokens(pairAddress);\\n\\n        if (\\n            fromToken != _ToSushipoolToken0 && fromToken != _ToSushipoolToken1\\n        ) {\\n            // swap to intermediate\\n            (intermediateAmt, intermediateToken) = _fillQuote(\\n                fromToken,\\n                pairAddress,\\n                amount,\\n                swapTarget,\\n                allowanceTarget,\\n                swapData\\n            );\\n        } else {\\n            intermediateToken = fromToken;\\n            intermediateAmt = amount;\\n        }\\n        // divide intermediate into appropriate amount to add liquidity\\n        (uint256 token0Bought, uint256 token1Bought) =\\n            _swapIntermediate(\\n                intermediateToken,\\n                _ToSushipoolToken0,\\n                _ToSushipoolToken1,\\n                intermediateAmt\\n            );\\n\\n        return\\n            _sushiDeposit(\\n                _ToSushipoolToken0,\\n                _ToSushipoolToken1,\\n                token0Bought,\\n                token1Bought,\\n                transferResidual\\n            );\\n    }\\n\\n    function _sushiDeposit(\\n        address _ToUnipoolToken0,\\n        address _ToUnipoolToken1,\\n        uint256 token0Bought,\\n        uint256 token1Bought,\\n        bool transferResidual\\n    ) internal returns (uint256) {\\n        _approveToken(_ToUnipoolToken0, address(sushiSwapRouter), token0Bought);\\n        _approveToken(_ToUnipoolToken1, address(sushiSwapRouter), token1Bought);\\n\\n        (uint256 amountA, uint256 amountB, uint256 LP) =\\n            sushiSwapRouter.addLiquidity(\\n                _ToUnipoolToken0,\\n                _ToUnipoolToken1,\\n                token0Bought,\\n                token1Bought,\\n                1,\\n                1,\\n                address(this),\\n                deadline\\n            );\\n\\n        if (transferResidual) {\\n            //Returning Residue in token0, if any.\\n            if (token0Bought.sub(amountA) > 0) {\\n                IERC20(_ToUnipoolToken0).safeTransfer(\\n                    msg.sender,\\n                    token0Bought.sub(amountA)\\n                );\\n            }\\n\\n            //Returning Residue in token1, if any\\n            if (token1Bought.sub(amountB) > 0) {\\n                IERC20(_ToUnipoolToken1).safeTransfer(\\n                    msg.sender,\\n                    token1Bought.sub(amountB)\\n                );\\n            }\\n        }\\n\\n        return LP;\\n    }\\n\\n    function _fillQuote(\\n        address _fromTokenAddress,\\n        address pairAddress,\\n        uint256 amount,\\n        address swapTarget,\\n        address allowanceTarget,\\n        bytes memory swapCallData\\n    ) internal returns (uint256 amountBought, address intermediateToken) {\\n        uint256 valueToSend;\\n        if (_fromTokenAddress == address(0)) {\\n            valueToSend = amount;\\n        } else {\\n            _approveToken(_fromTokenAddress, allowanceTarget, amount);\\n        }\\n\\n        (address _token0, address _token1) = _getPairTokens(pairAddress);\\n        IERC20 token0 = IERC20(_token0);\\n        IERC20 token1 = IERC20(_token1);\\n        uint256 initialBalance0 = token0.balanceOf(address(this));\\n        uint256 initialBalance1 = token1.balanceOf(address(this));\\n\\n        (bool success, ) = swapTarget.call.value(valueToSend)(swapCallData);\\n        require(success, \\\"Error Swapping Tokens 1\\\");\\n\\n        uint256 finalBalance0 =\\n            token0.balanceOf(address(this)).sub(initialBalance0);\\n        uint256 finalBalance1 =\\n            token1.balanceOf(address(this)).sub(initialBalance1);\\n\\n        if (finalBalance0 > finalBalance1) {\\n            amountBought = finalBalance0;\\n            intermediateToken = _token0;\\n        } else {\\n            amountBought = finalBalance1;\\n            intermediateToken = _token1;\\n        }\\n\\n        require(amountBought > 0, \\\"Swapped to Invalid Intermediate\\\");\\n    }\\n\\n    function _swapIntermediate(\\n        address _toContractAddress,\\n        address _ToSushipoolToken0,\\n        address _ToSushipoolToken1,\\n        uint256 amount\\n    ) internal returns (uint256 token0Bought, uint256 token1Bought) {\\n        IUniswapV2Pair pair =\\n            IUniswapV2Pair(\\n                sushiSwapFactoryAddress.getPair(\\n                    _ToSushipoolToken0,\\n                    _ToSushipoolToken1\\n                )\\n            );\\n        (uint256 res0, uint256 res1, ) = pair.getReserves();\\n        if (_toContractAddress == _ToSushipoolToken0) {\\n            uint256 amountToSwap = calculateSwapInAmount(res0, amount);\\n            //if no reserve or a new pair is created\\n            if (amountToSwap <= 0) amountToSwap = amount.div(2);\\n            token1Bought = _token2Token(\\n                _toContractAddress,\\n                _ToSushipoolToken1,\\n                amountToSwap\\n            );\\n            token0Bought = amount.sub(amountToSwap);\\n        } else {\\n            uint256 amountToSwap = calculateSwapInAmount(res1, amount);\\n            //if no reserve or a new pair is created\\n            if (amountToSwap <= 0) amountToSwap = amount.div(2);\\n            token0Bought = _token2Token(\\n                _toContractAddress,\\n                _ToSushipoolToken0,\\n                amountToSwap\\n            );\\n            token1Bought = amount.sub(amountToSwap);\\n        }\\n    }\\n\\n    function calculateSwapInAmount(uint256 reserveIn, uint256 userIn)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            Babylonian\\n                .sqrt(\\n                reserveIn.mul(userIn.mul(3988000) + reserveIn.mul(3988009))\\n            )\\n                .sub(reserveIn.mul(1997)) / 1994;\\n    }\\n\\n    /**\\n    @notice This function is used to swap ERC20 <> ERC20\\n    @param fromToken The token address to swap from.\\n    @param _ToTokenContractAddress The token address to swap to. \\n    @param tokens2Trade The amount of tokens to swap\\n    @return tokenBought The quantity of tokens bought\\n    */\\n    function _token2Token(\\n        address fromToken,\\n        address _ToTokenContractAddress,\\n        uint256 tokens2Trade\\n    ) internal returns (uint256 tokenBought) {\\n        if (fromToken == _ToTokenContractAddress) {\\n            return tokens2Trade;\\n        }\\n        _approveToken(fromToken, address(sushiSwapRouter), tokens2Trade);\\n\\n        address pair =\\n            sushiSwapFactoryAddress.getPair(fromToken, _ToTokenContractAddress);\\n        require(pair != address(0), \\\"No Swap Available\\\");\\n\\n        address[] memory path = new address[](2);\\n        path[0] = fromToken;\\n        path[1] = _ToTokenContractAddress;\\n\\n        tokenBought = sushiSwapRouter.swapExactTokensForTokens(\\n            tokens2Trade,\\n            1,\\n            path,\\n            address(this),\\n            deadline\\n        )[path.length - 1];\\n\\n        require(tokenBought > 0, \\\"Error Swapping Tokens 2\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Mushroom/Mushroom_ZapIn_V1.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice This contract adds liquidity to Mushroom Vaults using ETH or ERC20 Tokens.\\n// SPDX-License-Identifier: GPLv2\\n\\npragma solidity ^0.5.7;\\nimport \\\"../_base/ZapInBaseV2.sol\\\";\\n\\ninterface IMVault {\\n    function deposit(uint256) external;\\n\\n    function token() external view returns (address);\\n}\\n\\ncontract Mushroom_ZapIn_V1 is ZapInBaseV2 {\\n    mapping(address => bool) public approvedTargets;\\n\\n    event zapIn(address sender, address pool, uint256 tokensRec);\\n\\n    constructor(uint256 _goodwill, uint256 _affiliateSplit)\\n        public\\n        ZapBaseV1(_goodwill, _affiliateSplit)\\n    {}\\n\\n    /**\\n    @notice This function adds liquidity to Mushroom vaults with ETH or ERC20 tokens\\n    @param fromToken The token used for entry (address(0) if ether)\\n    @param amountIn The amount of fromToken to invest\\n    @param toVault Harvest vault address\\n    @param minMVTokens The minimum acceptable quantity vault tokens to receive. Reverts otherwise\\n    @param intermediateToken Token to swap fromToken to before entering vault\\n    @param swapTarget Excecution target for the swap or zap\\n    @param swapData DEX or Zap data\\n    @param affiliate Affiliate address\\n    @param shouldSellEntireBalance True if amountIn is determined at execution time (i.e. contract is caller)\\n    @return tokensReceived- Quantity of Vault tokens received\\n     */\\n    function ZapIn(\\n        address fromToken,\\n        uint256 amountIn,\\n        address toVault,\\n        uint256 minMVTokens,\\n        address intermediateToken,\\n        address swapTarget,\\n        bytes calldata swapData,\\n        address affiliate,\\n        bool shouldSellEntireBalance\\n    ) external payable stopInEmergency returns (uint256 tokensReceived) {\\n        require(\\n            approvedTargets[swapTarget] || swapTarget == address(0),\\n            \\\"Target not Authorized\\\"\\n        );\\n\\n        // get incoming tokens\\n        uint256 toInvest =\\n            _pullTokens(\\n                fromToken,\\n                amountIn,\\n                affiliate,\\n                true,\\n                shouldSellEntireBalance\\n            );\\n\\n        // get intermediate token\\n        uint256 intermediateAmt =\\n            _fillQuote(\\n                fromToken,\\n                intermediateToken,\\n                toInvest,\\n                swapTarget,\\n                swapData\\n            );\\n\\n        // Deposit to Vault\\n        tokensReceived = _vaultDeposit(intermediateAmt, toVault, minMVTokens);\\n    }\\n\\n    function _vaultDeposit(\\n        uint256 amount,\\n        address toVault,\\n        uint256 minTokensRec\\n    ) internal returns (uint256 tokensReceived) {\\n        address underlyingVaultToken = IMVault(toVault).token();\\n\\n        _approveToken(underlyingVaultToken, toVault);\\n\\n        uint256 iniVaultBal = IERC20(toVault).balanceOf(address(this));\\n        IMVault(toVault).deposit(amount);\\n        tokensReceived = IERC20(toVault).balanceOf(address(this)).sub(\\n            iniVaultBal\\n        );\\n        require(tokensReceived >= minTokensRec, \\\"Err: High Slippage\\\");\\n\\n        IERC20(toVault).safeTransfer(msg.sender, tokensReceived);\\n        emit zapIn(msg.sender, toVault, tokensReceived);\\n    }\\n\\n    function _fillQuote(\\n        address _fromTokenAddress,\\n        address toToken,\\n        uint256 _amount,\\n        address _swapTarget,\\n        bytes memory swapCallData\\n    ) internal returns (uint256 amtBought) {\\n        uint256 valueToSend;\\n\\n        if (_fromTokenAddress == toToken) {\\n            return _amount;\\n        }\\n\\n        if (_fromTokenAddress == address(0)) {\\n            valueToSend = _amount;\\n        } else {\\n            _approveToken(_fromTokenAddress, _swapTarget);\\n        }\\n\\n        uint256 iniBal = _getBalance(toToken);\\n        (bool success, ) = _swapTarget.call.value(valueToSend)(swapCallData);\\n        require(success, \\\"Error Swapping Tokens 1\\\");\\n        uint256 finalBal = _getBalance(toToken);\\n\\n        amtBought = finalBal.sub(iniBal);\\n    }\\n\\n    function setApprovedTargets(\\n        address[] calldata targets,\\n        bool[] calldata isApproved\\n    ) external onlyOwner {\\n        require(targets.length == isApproved.length, \\\"Invalid Input length\\\");\\n\\n        for (uint256 i = 0; i < targets.length; i++) {\\n            approvedTargets[targets[i]] = isApproved[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Harvest/Harvest_ZapIn_V2.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice This contract deposits ETH or ERC20 tokens into Harvest Vaults\\n// SPDX-License-Identifier: GPLv2\\n\\npragma solidity ^0.5.7;\\nimport \\\"../_base/ZapInBaseV2.sol\\\";\\n\\n// -- Harvest --\\ninterface IHVault {\\n    function underlying() external view returns (address);\\n\\n    function deposit(uint256 amountWei) external;\\n}\\n\\ncontract Harvest_ZapIn_V2_0_1 is ZapInBaseV2 {\\n    // calldata only accepted for approved zap contracts\\n    mapping(address => bool) public approvedTargets;\\n\\n    event zapIn(address sender, address pool, uint256 tokensRec);\\n\\n    constructor(uint256 _goodwill, uint256 _affiliateSplit)\\n        public\\n        ZapBaseV1(_goodwill, _affiliateSplit)\\n    {}\\n\\n    /**\\n    @notice This function adds liquidity to harvest vaults with ETH or ERC20 tokens\\n    @param fromToken The token used for entry (address(0) if ether)\\n    @param amountIn The amount of fromToken to invest\\n    @param vault Harvest vault address\\n    @param minVaultTokens The minimum acceptable quantity vault tokens to receive. Reverts otherwise\\n    @param intermediateToken Token to swap fromToken to before entering vault\\n    @param swapTarget Excecution target for the swap or zap\\n    @param swapData DEX or Zap data\\n    @param affiliate Affiliate address\\n    @return tokensReceived- Quantity of Vault tokens received\\n     */\\n    function ZapIn(\\n        address fromToken,\\n        uint256 amountIn,\\n        address vault,\\n        uint256 minVaultTokens,\\n        address intermediateToken,\\n        address swapTarget,\\n        bytes calldata swapData,\\n        address affiliate,\\n        bool shouldSellEntireBalance\\n    ) external payable stopInEmergency returns (uint256 tokensReceived) {\\n        require(\\n            approvedTargets[swapTarget] || swapTarget == address(0),\\n            \\\"Target not Authorized\\\"\\n        );\\n\\n        // get incoming tokens\\n        uint256 toInvest =\\n            _pullTokens(\\n                fromToken,\\n                amountIn,\\n                affiliate,\\n                true,\\n                shouldSellEntireBalance\\n            );\\n\\n        // get intermediate token\\n        uint256 intermediateAmt =\\n            _fillQuote(\\n                fromToken,\\n                intermediateToken,\\n                toInvest,\\n                swapTarget,\\n                swapData\\n            );\\n\\n        // Deposit to Vault\\n        tokensReceived = _vaultDeposit(intermediateAmt, vault, minVaultTokens);\\n    }\\n\\n    function _vaultDeposit(\\n        uint256 amount,\\n        address toVault,\\n        uint256 minTokensRec\\n    ) internal returns (uint256 tokensReceived) {\\n        address underlyingVaultToken = IHVault(toVault).underlying();\\n\\n        _approveToken(underlyingVaultToken, toVault);\\n\\n        uint256 iniYVaultBal = IERC20(toVault).balanceOf(address(this));\\n        IHVault(toVault).deposit(amount);\\n        tokensReceived = IERC20(toVault).balanceOf(address(this)).sub(\\n            iniYVaultBal\\n        );\\n        require(tokensReceived >= minTokensRec, \\\"Err: High Slippage\\\");\\n\\n        IERC20(toVault).safeTransfer(msg.sender, tokensReceived);\\n        emit zapIn(msg.sender, toVault, tokensReceived);\\n    }\\n\\n    function _fillQuote(\\n        address _fromTokenAddress,\\n        address toToken,\\n        uint256 _amount,\\n        address _swapTarget,\\n        bytes memory swapCallData\\n    ) internal returns (uint256 amtBought) {\\n        uint256 valueToSend;\\n\\n        if (_fromTokenAddress == toToken) {\\n            return _amount;\\n        }\\n\\n        if (_fromTokenAddress == address(0)) {\\n            valueToSend = _amount;\\n        } else {\\n            _approveToken(_fromTokenAddress, _swapTarget);\\n        }\\n\\n        uint256 iniBal = _getBalance(toToken);\\n        (bool success, ) = _swapTarget.call.value(valueToSend)(swapCallData);\\n        require(success, \\\"Error Swapping Tokens 1\\\");\\n        uint256 finalBal = _getBalance(toToken);\\n\\n        amtBought = finalBal.sub(iniBal);\\n    }\\n\\n    function setApprovedTargets(\\n        address[] calldata targets,\\n        bool[] calldata isApproved\\n    ) external onlyOwner {\\n        require(targets.length == isApproved.length, \\\"Invalid Input length\\\");\\n\\n        for (uint256 i = 0; i < targets.length; i++) {\\n            approvedTargets[targets[i]] = isApproved[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/_base/ZapInBaseV1.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.7;\\n\\nimport \\\"./ZapBaseV1.sol\\\";\\n\\ncontract ZapInBaseV1 is ZapBaseV1 {\\n    function _pullTokens(\\n        address token,\\n        uint256 amount,\\n        address affiliate,\\n        bool enableGoodwill\\n    ) internal returns (uint256 value) {\\n        uint256 totalGoodwillPortion;\\n\\n        if (token == address(0)) {\\n            require(msg.value > 0, \\\"No eth sent\\\");\\n\\n            // subtract goodwill\\n            totalGoodwillPortion = _subtractGoodwill(\\n                ETHAddress,\\n                msg.value,\\n                affiliate,\\n                enableGoodwill\\n            );\\n\\n            return msg.value.sub(totalGoodwillPortion);\\n        }\\n        require(amount > 0, \\\"Invalid token amount\\\");\\n        require(msg.value == 0, \\\"Eth sent with token\\\");\\n\\n        //transfer token\\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n\\n        // subtract goodwill\\n        totalGoodwillPortion = _subtractGoodwill(\\n            token,\\n            amount,\\n            affiliate,\\n            enableGoodwill\\n        );\\n\\n        return amount.sub(totalGoodwillPortion);\\n    }\\n\\n    function _subtractGoodwill(\\n        address token,\\n        uint256 amount,\\n        address affiliate,\\n        bool enableGoodwill\\n    ) internal returns (uint256 totalGoodwillPortion) {\\n        bool whitelisted = feeWhitelist[msg.sender];\\n        if (enableGoodwill && !whitelisted && goodwill > 0) {\\n            totalGoodwillPortion = SafeMath.div(\\n                SafeMath.mul(amount, goodwill),\\n                10000\\n            );\\n\\n            if (affiliates[affiliate]) {\\n                if (token == address(0)) {\\n                    token = ETHAddress;\\n                }\\n\\n                uint256 affiliatePortion =\\n                    totalGoodwillPortion.mul(affiliateSplit).div(100);\\n                affiliateBalance[affiliate][token] = affiliateBalance[\\n                    affiliate\\n                ][token]\\n                    .add(affiliatePortion);\\n                totalAffiliateBalance[token] = totalAffiliateBalance[token].add(\\n                    affiliatePortion\\n                );\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/yEarn/yVault_ZapIn_V3.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice This contract adds liquidity to Yearn Vaults using ETH or ERC20 Tokens.\\n// SPDX-License-Identifier: GPLv2\\n\\npragma solidity ^0.5.7;\\nimport \\\"../_base/ZapInBaseV1.sol\\\";\\n\\ninterface IYVault {\\n    function deposit(uint256) external;\\n\\n    function withdraw(uint256) external;\\n\\n    function getPricePerFullShare() external view returns (uint256);\\n\\n    function token() external view returns (address);\\n\\n    // V2\\n    function pricePerShare() external view returns (uint256);\\n}\\n\\n// -- Aave --\\ninterface IAaveLendingPoolAddressesProvider {\\n    function getLendingPool() external view returns (address);\\n\\n    function getLendingPoolCore() external view returns (address payable);\\n}\\n\\ninterface IAaveLendingPoolCore {\\n    function getReserveATokenAddress(address _reserve)\\n        external\\n        view\\n        returns (address);\\n}\\n\\ninterface IAaveLendingPool {\\n    function deposit(\\n        address _reserve,\\n        uint256 _amount,\\n        uint16 _referralCode\\n    ) external payable;\\n}\\n\\ncontract yVault_ZapIn_V3 is ZapInBaseV1 {\\n    // calldata only accepted for approved zap contracts\\n    mapping(address => bool) public approvedTargets;\\n\\n    IAaveLendingPoolAddressesProvider\\n        private constant lendingPoolAddressProvider =\\n        IAaveLendingPoolAddressesProvider(\\n            0x24a42fD28C976A61Df5D00D0599C34c4f90748c8\\n        );\\n\\n    event zapIn(address sender, address pool, uint256 tokensRec);\\n\\n    constructor(\\n        address _curveZapIn,\\n        uint256 _goodwill,\\n        uint256 _affiliateSplit\\n    ) public ZapBaseV1(_goodwill, _affiliateSplit) {}\\n\\n    /**\\n    @notice This function adds liquidity to a Yearn vaults with ETH or ERC20 tokens\\n    @param fromToken The token used for entry (address(0) if ether)\\n    @param amountIn The amount of fromToken to invest\\n    @param toVault Yearn vault address\\n    @param superVault Super vault to depoist toVault tokens into (address(0) if none)\\n    @param isAaveUnderlying True if vault contains aave token\\n    @param minYVTokens The minimum acceptable quantity vault tokens to receive. Reverts otherwise\\n    @param intermediateToken Token to swap fromToken to before entering vault\\n    @param swapTarget Excecution target for the swap or Zap\\n    @param swapData DEX quote or Zap data\\n    @param affiliate Affiliate address\\n    @return tokensReceived- Quantity of Vault tokens received\\n     */\\n    function ZapIn(\\n        address fromToken,\\n        uint256 amountIn,\\n        address toVault,\\n        address superVault,\\n        bool isAaveUnderlying,\\n        uint256 minYVTokens,\\n        address intermediateToken,\\n        address swapTarget,\\n        bytes calldata swapData,\\n        address affiliate\\n    ) external payable stopInEmergency returns (uint256 tokensReceived) {\\n        require(\\n            approvedTargets[swapTarget] || swapTarget == address(0),\\n            \\\"Target not Authorized\\\"\\n        );\\n\\n        // get incoming tokens\\n        uint256 toInvest = _pullTokens(fromToken, amountIn, affiliate, true);\\n\\n        // get intermediate token\\n        uint256 intermediateAmt =\\n            _fillQuote(\\n                fromToken,\\n                intermediateToken,\\n                toInvest,\\n                swapTarget,\\n                swapData\\n            );\\n\\n        // get 'aIntermediateToken'\\n        if (isAaveUnderlying) {\\n            address aaveLendingPoolCore =\\n                lendingPoolAddressProvider.getLendingPoolCore();\\n            _approveToken(intermediateToken, aaveLendingPoolCore);\\n\\n            IAaveLendingPool(lendingPoolAddressProvider.getLendingPool())\\n                .deposit(intermediateToken, intermediateAmt, 0);\\n\\n            intermediateToken = IAaveLendingPoolCore(aaveLendingPoolCore)\\n                .getReserveATokenAddress(intermediateToken);\\n        }\\n\\n        return\\n            _zapIn(\\n                toVault,\\n                superVault,\\n                minYVTokens,\\n                intermediateToken,\\n                intermediateAmt\\n            );\\n    }\\n\\n    function _zapIn(\\n        address toVault,\\n        address superVault,\\n        uint256 minYVTokens,\\n        address intermediateToken,\\n        uint256 intermediateAmt\\n    ) internal returns (uint256 tokensReceived) {\\n        // Deposit to Vault\\n        if (superVault == address(0)) {\\n            tokensReceived = _vaultDeposit(\\n                intermediateToken,\\n                intermediateAmt,\\n                toVault,\\n                minYVTokens,\\n                true\\n            );\\n        } else {\\n            uint256 intermediateYVTokens =\\n                _vaultDeposit(\\n                    intermediateToken,\\n                    intermediateAmt,\\n                    toVault,\\n                    0,\\n                    false\\n                );\\n            // deposit to super vault\\n            tokensReceived = _vaultDeposit(\\n                IYVault(superVault).token(),\\n                intermediateYVTokens,\\n                superVault,\\n                minYVTokens,\\n                true\\n            );\\n        }\\n    }\\n\\n    function _vaultDeposit(\\n        address underlyingVaultToken,\\n        uint256 amount,\\n        address toVault,\\n        uint256 minTokensRec,\\n        bool shouldTransfer\\n    ) internal returns (uint256 tokensReceived) {\\n        _approveToken(underlyingVaultToken, toVault);\\n\\n        uint256 iniYVaultBal = IERC20(toVault).balanceOf(address(this));\\n        IYVault(toVault).deposit(amount);\\n        tokensReceived = IERC20(toVault).balanceOf(address(this)).sub(\\n            iniYVaultBal\\n        );\\n        require(tokensReceived >= minTokensRec, \\\"Err: High Slippage\\\");\\n\\n        if (shouldTransfer) {\\n            IERC20(toVault).safeTransfer(msg.sender, tokensReceived);\\n            emit zapIn(msg.sender, toVault, tokensReceived);\\n        }\\n    }\\n\\n    function _fillQuote(\\n        address _fromTokenAddress,\\n        address toToken,\\n        uint256 _amount,\\n        address _swapTarget,\\n        bytes memory swapCallData\\n    ) internal returns (uint256 amtBought) {\\n        uint256 valueToSend;\\n\\n        if (_fromTokenAddress == toToken) {\\n            return _amount;\\n        }\\n\\n        if (_fromTokenAddress == address(0)) {\\n            valueToSend = _amount;\\n        } else {\\n            _approveToken(_fromTokenAddress, _swapTarget);\\n        }\\n\\n        uint256 iniBal = _getBalance(toToken);\\n        (bool success, ) = _swapTarget.call.value(valueToSend)(swapCallData);\\n        require(success, \\\"Error Swapping Tokens 1\\\");\\n        uint256 finalBal = _getBalance(toToken);\\n\\n        amtBought = finalBal.sub(iniBal);\\n    }\\n\\n    function setApprovedTargets(\\n        address[] calldata targets,\\n        bool[] calldata isApproved\\n    ) external onlyOwner {\\n        require(targets.length == isApproved.length, \\\"Invalid Input length\\\");\\n\\n        for (uint256 i = 0; i < targets.length; i++) {\\n            approvedTargets[targets[i]] = isApproved[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/QuickSwap/QuickSwap_ZapIn_V1.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 Zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice This contract adds liquidity to QuickSwap pools using any arbitrary token\\n// SPDX-License-Identifier: GPLv2\\n\\npragma solidity ^0.5.7;\\nimport \\\"../_base/ZapInBaseV1.sol\\\";\\n\\nlibrary Babylonian {\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n        // else z = 0\\n    }\\n}\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\\ninterface IUniswapV2Factory {\\n    function getPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (address);\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n}\\n\\ninterface IUniswapV2Pair {\\n    function token0() external pure returns (address);\\n\\n    function token1() external pure returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n            uint32 _blockTimestampLast\\n        );\\n}\\n\\ncontract QuickSwap_ZapIn_V1 is ZapInBaseV1 {\\n    IUniswapV2Router02 private constant quickswapRouter =\\n        IUniswapV2Router02(0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff);\\n\\n    IUniswapV2Factory private constant quickswapFactory =\\n        IUniswapV2Factory(0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32);\\n\\n    address private constant wmaticTokenAddress =\\n        0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270;\\n\\n    uint256 private constant deadline =\\n        0xf000000000000000000000000000000000000000000000000000000000000000;\\n\\n    event zapIn(address sender, address pool, uint256 tokensRec);\\n\\n    constructor(uint256 _goodwill, uint256 _affiliateSplit)\\n        public\\n        ZapBaseV1(_goodwill, _affiliateSplit)\\n    {}\\n\\n    /**\\n    @notice Adds liquidity to QuickSwap Pools with any token\\n    @param fromTokenAddress ERC20 token address used for investment (address(0x00) if MATIC)\\n    @param pairAddress QuickSwap pair address\\n    @param amount Quantity of fromTokenAddress to invest\\n    @param minPoolTokens Minimum acceptable quantity of LP tokens to receive.\\n    @param affiliate Affiliate address\\n    @return Quantity of LP bought\\n     */\\n    function ZapIn(\\n        address fromTokenAddress,\\n        address pairAddress,\\n        uint256 amount,\\n        uint256 minPoolTokens,\\n        address affiliate\\n    ) public payable stopInEmergency returns (uint256) {\\n        uint256 toInvest =\\n            _pullTokens(fromTokenAddress, amount, affiliate, true);\\n\\n        uint256 LPBought =\\n            _performZapIn(fromTokenAddress, pairAddress, toInvest);\\n\\n        require(LPBought >= minPoolTokens, \\\"ERR: High Slippage\\\");\\n\\n        emit zapIn(msg.sender, pairAddress, LPBought);\\n\\n        IERC20(pairAddress).safeTransfer(msg.sender, LPBought);\\n\\n        return LPBought;\\n    }\\n\\n    function _getPairTokens(address pairAddress)\\n        internal\\n        pure\\n        returns (address token0, address token1)\\n    {\\n        IUniswapV2Pair uniPair = IUniswapV2Pair(pairAddress);\\n        token0 = uniPair.token0();\\n        token1 = uniPair.token1();\\n    }\\n\\n    function _performZapIn(\\n        address fromTokenAddress,\\n        address pairAddress,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        (address _token0, address _token1) = _getPairTokens(pairAddress);\\n        address intermediate =\\n            _getIntermediate(fromTokenAddress, amount, _token0, _token1);\\n\\n        // swap to intermediate\\n        uint256 interAmt = _token2Token(fromTokenAddress, intermediate, amount);\\n\\n        // divide to swap in amounts\\n        uint256 token0Bought;\\n        uint256 token1Bought;\\n\\n        IUniswapV2Pair pair =\\n            IUniswapV2Pair(quickswapFactory.getPair(_token0, _token1));\\n        (uint256 res0, uint256 res1, ) = pair.getReserves();\\n\\n        if (intermediate == _token0) {\\n            uint256 amountToSwap = calculateSwapInAmount(res0, interAmt);\\n            //if no reserve or a new pair is created\\n            if (amountToSwap <= 0) amountToSwap = interAmt.div(2);\\n            token1Bought = _token2Token(intermediate, _token1, amountToSwap);\\n            token0Bought = interAmt.sub(amountToSwap);\\n        } else {\\n            uint256 amountToSwap = calculateSwapInAmount(res1, interAmt);\\n            //if no reserve or a new pair is created\\n            if (amountToSwap <= 0) amountToSwap = interAmt.div(2);\\n            token0Bought = _token2Token(intermediate, _token0, amountToSwap);\\n            token1Bought = interAmt.sub(amountToSwap);\\n        }\\n\\n        return _quickDeposit(_token0, _token1, token0Bought, token1Bought);\\n    }\\n\\n    function _quickDeposit(\\n        address _token0,\\n        address _token1,\\n        uint256 token0Bought,\\n        uint256 token1Bought\\n    ) internal returns (uint256) {\\n        IERC20(_token0).safeApprove(address(quickswapRouter), token0Bought);\\n        IERC20(_token1).safeApprove(address(quickswapRouter), token1Bought);\\n\\n        (uint256 amountA, uint256 amountB, uint256 LP) =\\n            quickswapRouter.addLiquidity(\\n                _token0,\\n                _token1,\\n                token0Bought,\\n                token1Bought,\\n                1,\\n                1,\\n                address(this),\\n                deadline\\n            );\\n\\n        IERC20(_token0).safeApprove(address(quickswapRouter), 0);\\n        IERC20(_token1).safeApprove(address(quickswapRouter), 0);\\n\\n        //Returning Residue in token0, if any.\\n        if (token0Bought.sub(amountA) > 0) {\\n            IERC20(_token0).safeTransfer(msg.sender, token0Bought.sub(amountA));\\n        }\\n\\n        //Returning Residue in token1, if any\\n        if (token1Bought.sub(amountB) > 0) {\\n            IERC20(_token1).safeTransfer(msg.sender, token1Bought.sub(amountB));\\n        }\\n\\n        return LP;\\n    }\\n\\n    function _getIntermediate(\\n        address fromTokenAddress,\\n        uint256 amount,\\n        address _ToUnipoolToken0,\\n        address _ToUnipoolToken1\\n    ) internal view returns (address) {\\n        // set from to wmatic for matic input\\n        if (fromTokenAddress == address(0)) {\\n            fromTokenAddress = wmaticTokenAddress;\\n        }\\n\\n        if (fromTokenAddress == _ToUnipoolToken0) {\\n            return _ToUnipoolToken0;\\n        } else if (fromTokenAddress == _ToUnipoolToken1) {\\n            return _ToUnipoolToken1;\\n        } else if (\\n            _ToUnipoolToken0 == wmaticTokenAddress ||\\n            _ToUnipoolToken1 == wmaticTokenAddress\\n        ) {\\n            return wmaticTokenAddress;\\n        } else {\\n            IUniswapV2Pair pair =\\n                IUniswapV2Pair(\\n                    quickswapFactory.getPair(_ToUnipoolToken0, _ToUnipoolToken1)\\n                );\\n            (uint256 res0, uint256 res1, ) = pair.getReserves();\\n\\n            uint256 ratio;\\n            bool isToken0Numerator;\\n            if (res0 >= res1) {\\n                ratio = res0 / res1;\\n                isToken0Numerator = true;\\n            } else {\\n                ratio = res1 / res0;\\n            }\\n\\n            //find outputs on swap\\n            uint256 output0 =\\n                _calculateSwapOutput(\\n                    fromTokenAddress,\\n                    amount,\\n                    _ToUnipoolToken0\\n                );\\n            uint256 output1 =\\n                _calculateSwapOutput(\\n                    fromTokenAddress,\\n                    amount,\\n                    _ToUnipoolToken1\\n                );\\n\\n            if (isToken0Numerator) {\\n                if (output1 * ratio >= output0) return _ToUnipoolToken1;\\n                else return _ToUnipoolToken0;\\n            } else {\\n                if (output0 * ratio >= output1) return _ToUnipoolToken0;\\n                else return _ToUnipoolToken1;\\n            }\\n        }\\n    }\\n\\n    function _calculateSwapOutput(\\n        address _from,\\n        uint256 _amt,\\n        address _to\\n    ) internal view returns (uint256) {\\n        // check output via tokenA -> tokenB\\n        address pairA = quickswapFactory.getPair(_from, _to);\\n\\n        uint256 amtA;\\n        if (pairA != address(0)) {\\n            address[] memory pathA = new address[](2);\\n            pathA[0] = _from;\\n            pathA[1] = _to;\\n\\n            amtA = quickswapRouter.getAmountsOut(_amt, pathA)[1];\\n        }\\n\\n        uint256 amtB;\\n        // check output via tokenA -> wmatic -> tokenB\\n        if ((_from != wmaticTokenAddress) && _to != wmaticTokenAddress) {\\n            address[] memory pathB = new address[](3);\\n            pathB[0] = _from;\\n            pathB[1] = wmaticTokenAddress;\\n            pathB[2] = _to;\\n\\n            amtB = quickswapRouter.getAmountsOut(_amt, pathB)[2];\\n        }\\n\\n        if (amtA >= amtB) {\\n            return amtA;\\n        } else {\\n            return amtB;\\n        }\\n    }\\n\\n    function calculateSwapInAmount(uint256 reserveIn, uint256 userIn)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            Babylonian\\n                .sqrt(\\n                reserveIn.mul(userIn.mul(3988000) + reserveIn.mul(3988009))\\n            )\\n                .sub(reserveIn.mul(1997)) / 1994;\\n    }\\n\\n    /**\\n    @notice This function is used to swap ETH/ERC20 <> ETH/ERC20\\n    @param fromTokenAddress The token address to swap from. (0x00 for ETH)\\n    @param _ToTokenContractAddress The token address to swap to. (0x00 for ETH)\\n    @param tokens2Trade The amount of tokens to swap\\n    @return tokenBought The quantity of tokens bought\\n    */\\n    function _token2Token(\\n        address fromTokenAddress,\\n        address _ToTokenContractAddress,\\n        uint256 tokens2Trade\\n    ) internal returns (uint256 tokenBought) {\\n        if (fromTokenAddress == _ToTokenContractAddress) {\\n            return tokens2Trade;\\n        }\\n\\n        if (fromTokenAddress == address(0)) {\\n            if (_ToTokenContractAddress == wmaticTokenAddress) {\\n                IWETH(wmaticTokenAddress).deposit.value(tokens2Trade)();\\n                return tokens2Trade;\\n            }\\n\\n            address[] memory path = new address[](2);\\n            path[0] = wmaticTokenAddress;\\n            path[1] = _ToTokenContractAddress;\\n            tokenBought = quickswapRouter.swapExactETHForTokens.value(\\n                tokens2Trade\\n            )(1, path, address(this), deadline)[path.length - 1];\\n        } else if (_ToTokenContractAddress == address(0)) {\\n            if (fromTokenAddress == wmaticTokenAddress) {\\n                IWETH(wmaticTokenAddress).withdraw(tokens2Trade);\\n                return tokens2Trade;\\n            }\\n\\n            IERC20(fromTokenAddress).safeApprove(\\n                address(quickswapRouter),\\n                tokens2Trade\\n            );\\n\\n            address[] memory path = new address[](2);\\n            path[0] = fromTokenAddress;\\n            path[1] = wmaticTokenAddress;\\n            tokenBought = quickswapRouter.swapExactTokensForETH(\\n                tokens2Trade,\\n                1,\\n                path,\\n                address(this),\\n                deadline\\n            )[path.length - 1];\\n        } else {\\n            IERC20(fromTokenAddress).safeApprove(\\n                address(quickswapRouter),\\n                tokens2Trade\\n            );\\n\\n            if (fromTokenAddress != wmaticTokenAddress) {\\n                if (_ToTokenContractAddress != wmaticTokenAddress) {\\n                    // check output via tokenA -> tokenB\\n                    address pairA =\\n                        quickswapFactory.getPair(\\n                            fromTokenAddress,\\n                            _ToTokenContractAddress\\n                        );\\n                    address[] memory pathA = new address[](2);\\n                    pathA[0] = fromTokenAddress;\\n                    pathA[1] = _ToTokenContractAddress;\\n                    uint256 amtA;\\n                    if (pairA != address(0)) {\\n                        amtA = quickswapRouter.getAmountsOut(\\n                            tokens2Trade,\\n                            pathA\\n                        )[1];\\n                    }\\n\\n                    // check output via tokenA -> wmatic -> tokenB\\n                    address[] memory pathB = new address[](3);\\n                    pathB[0] = fromTokenAddress;\\n                    pathB[1] = wmaticTokenAddress;\\n                    pathB[2] = _ToTokenContractAddress;\\n\\n                    uint256 amtB =\\n                        quickswapRouter.getAmountsOut(tokens2Trade, pathB)[2];\\n\\n                    if (amtA >= amtB) {\\n                        tokenBought = quickswapRouter.swapExactTokensForTokens(\\n                            tokens2Trade,\\n                            1,\\n                            pathA,\\n                            address(this),\\n                            deadline\\n                        )[pathA.length - 1];\\n                    } else {\\n                        tokenBought = quickswapRouter.swapExactTokensForTokens(\\n                            tokens2Trade,\\n                            1,\\n                            pathB,\\n                            address(this),\\n                            deadline\\n                        )[pathB.length - 1];\\n                    }\\n                } else {\\n                    address[] memory path = new address[](2);\\n                    path[0] = fromTokenAddress;\\n                    path[1] = wmaticTokenAddress;\\n\\n                    tokenBought = quickswapRouter.swapExactTokensForTokens(\\n                        tokens2Trade,\\n                        1,\\n                        path,\\n                        address(this),\\n                        deadline\\n                    )[path.length - 1];\\n                }\\n            } else {\\n                address[] memory path = new address[](2);\\n                path[0] = wmaticTokenAddress;\\n                path[1] = _ToTokenContractAddress;\\n                tokenBought = quickswapRouter.swapExactTokensForTokens(\\n                    tokens2Trade,\\n                    1,\\n                    path,\\n                    address(this),\\n                    deadline\\n                )[path.length - 1];\\n            }\\n        }\\n        require(tokenBought > 0, \\\"Error Swapping Tokens\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Pickle/Pickle_ZapIn_V1.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2020 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice This contract deposits to Pickle Jars with ETH or ERC tokens\\n// SPDX-License-Identifier: GPLv2\\n\\npragma solidity ^0.5.7;\\nimport \\\"../_base/ZapInBaseV1.sol\\\";\\n\\ninterface IPickleJar {\\n    function token() external view returns (address);\\n\\n    function deposit(uint256 amount) external;\\n}\\n\\ncontract Pickle_ZapIn_V1 is ZapInBaseV1 {\\n    // calldata only accepted for approved zap contracts\\n    mapping(address => bool) public approvedTargets;\\n\\n    event zapIn(address sender, address pool, uint256 tokensRec);\\n\\n    constructor(uint256 _goodwill, uint256 _affiliateSplit)\\n        public\\n        ZapBaseV1(_goodwill, _affiliateSplit)\\n    {}\\n\\n    /**\\n    @notice This function adds liquidity to a Pickle vaults with ETH or ERC20 tokens\\n    @param fromToken The token used for entry (address(0) if ether)\\n    @param amountIn The amount of fromToken to invest\\n    @param toPJar Pickle vault address\\n    @param minPJarTokens The minimum acceptable quantity vault tokens to receive. Reverts otherwise\\n    @param intermediateToken Token to swap fromToken to before entering vault\\n    @param swapTarget Excecution target for the swap or zap\\n    @param swapData DEX or Zap data\\n    @param affiliate Affiliate address\\n    @return tokensReceived- Quantity of Vault tokens received\\n     */\\n    function ZapIn(\\n        address fromToken,\\n        uint256 amountIn,\\n        address toPJar,\\n        uint256 minPJarTokens,\\n        address intermediateToken,\\n        address swapTarget,\\n        bytes calldata swapData,\\n        address affiliate\\n    ) external payable stopInEmergency returns (uint256 tokensReceived) {\\n        require(\\n            approvedTargets[swapTarget] || swapTarget == address(0),\\n            \\\"Target not Authorized\\\"\\n        );\\n\\n        // get incoming tokens\\n        uint256 toInvest = _pullTokens(fromToken, amountIn, affiliate, true);\\n\\n        // get intermediate token\\n        uint256 intermediateAmt =\\n            _fillQuote(\\n                fromToken,\\n                intermediateToken,\\n                toInvest,\\n                swapTarget,\\n                swapData\\n            );\\n\\n        // Deposit to Vault\\n        tokensReceived = _vaultDeposit(intermediateAmt, toPJar, minPJarTokens);\\n    }\\n\\n    function _vaultDeposit(\\n        uint256 amount,\\n        address toVault,\\n        uint256 minTokensRec\\n    ) internal returns (uint256 tokensReceived) {\\n        address underlyingVaultToken = IPickleJar(toVault).token();\\n\\n        _approveToken(underlyingVaultToken, toVault);\\n\\n        uint256 iniYVaultBal = IERC20(toVault).balanceOf(address(this));\\n        IPickleJar(toVault).deposit(amount);\\n        tokensReceived = IERC20(toVault).balanceOf(address(this)).sub(\\n            iniYVaultBal\\n        );\\n        require(tokensReceived >= minTokensRec, \\\"Err: High Slippage\\\");\\n\\n        IERC20(toVault).safeTransfer(msg.sender, tokensReceived);\\n        emit zapIn(msg.sender, toVault, tokensReceived);\\n    }\\n\\n    function _fillQuote(\\n        address _fromTokenAddress,\\n        address toToken,\\n        uint256 _amount,\\n        address _swapTarget,\\n        bytes memory swapCallData\\n    ) internal returns (uint256 amtBought) {\\n        uint256 valueToSend;\\n\\n        if (_fromTokenAddress == toToken) {\\n            return _amount;\\n        }\\n\\n        if (_fromTokenAddress == address(0)) {\\n            valueToSend = _amount;\\n        } else {\\n            _approveToken(_fromTokenAddress, _swapTarget);\\n        }\\n\\n        uint256 iniBal = _getBalance(toToken);\\n        (bool success, ) = _swapTarget.call.value(valueToSend)(swapCallData);\\n        require(success, \\\"Error Swapping Tokens 1\\\");\\n        uint256 finalBal = _getBalance(toToken);\\n\\n        amtBought = finalBal.sub(iniBal);\\n    }\\n\\n    function setApprovedTargets(\\n        address[] calldata targets,\\n        bool[] calldata isApproved\\n    ) external onlyOwner {\\n        require(targets.length == isApproved.length, \\\"Invalid Input length\\\");\\n\\n        for (uint256 i = 0; i < targets.length; i++) {\\n            approvedTargets[targets[i]] = isApproved[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockZapIn.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.7;\\n\\nimport \\\"../_base/ZapInBaseV1.sol\\\";\\n\\ncontract MockZapIn is ZapInBaseV1 {\\n    constructor(uint256 goodwill, uint256 affiliateSplit)\\n        public\\n        ZapBaseV1(goodwill, affiliateSplit)\\n    {}\\n\\n    function ZapIn(\\n        address fromToken,\\n        uint256 amountIn,\\n        address affiliate\\n    ) external payable stopInEmergency {\\n        uint256 toInvest = _pullTokens(fromToken, amountIn, affiliate, true);\\n\\n        if (fromToken == address(0)) {\\n            msg.sender.transfer(toInvest);\\n        } else {\\n            IERC20(fromToken).safeTransfer(address(0), toInvest);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MaticBridge/Zapper_ETH_Bridge_V1.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice This contract swaps and bridges Matic Tokens to Ethereum mainnet\\n// SPDX-License-Identifier: GPLv2\\n\\npragma solidity ^0.5.7;\\n\\nimport \\\"../_base/ZapInBaseV1.sol\\\";\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\\ninterface IUniswapV2Factory {\\n    function getPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (address);\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n}\\n\\ninterface IChildToken {\\n    function withdraw(uint256 amount) external;\\n}\\n\\ncontract Zapper_ETH_Bridge_V1 is ZapInBaseV1 {\\n    IUniswapV2Factory private constant quickswapFactory =\\n        IUniswapV2Factory(0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32);\\n    IUniswapV2Router02 private constant quickswapRouter =\\n        IUniswapV2Router02(0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff);\\n\\n    IUniswapV2Factory private constant sushiswapFactory =\\n        IUniswapV2Factory(0xc35DADB65012eC5796536bD9864eD8773aBc74C4);\\n    IUniswapV2Router02 private constant sushiswapRouter =\\n        IUniswapV2Router02(0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506);\\n\\n    address private constant wmaticTokenAddress =\\n        0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270;\\n    uint256 private constant deadline =\\n        0xf000000000000000000000000000000000000000000000000000000000000000;\\n\\n    constructor(uint256 _goodwill, uint256 _affiliateSplit)\\n        public\\n        ZapBaseV1(_goodwill, _affiliateSplit)\\n    {}\\n\\n    function ZapBridge(\\n        address fromToken,\\n        uint256 amountIn,\\n        address toToken,\\n        bool useSushi,\\n        address affiliate\\n    ) external payable stopInEmergency {\\n        uint256 toInvest = _pullTokens(fromToken, amountIn, affiliate, true);\\n\\n        uint256 toTokenAmt;\\n        if (useSushi) {\\n            toTokenAmt = _token2TokenSushi(fromToken, toToken, toInvest);\\n        } else {\\n            toTokenAmt = _token2TokenQuick(fromToken, toToken, toInvest);\\n        }\\n\\n        IChildToken(toToken).withdraw(toTokenAmt);\\n    }\\n\\n    /**\\n    @notice This function is used to swap MATIC/ERC20 <> MATIC/ERC20 via Quickswap\\n    @param fromTokenAddress The token address to swap from. (0x00 for ETH)\\n    @param _ToTokenContractAddress The token address to swap to. (0x00 for ETH)\\n    @param tokens2Trade The amount of tokens to swap\\n    @return tokenBought The quantity of tokens bought\\n    */\\n    function _token2TokenQuick(\\n        address fromTokenAddress,\\n        address _ToTokenContractAddress,\\n        uint256 tokens2Trade\\n    ) internal returns (uint256 tokenBought) {\\n        if (fromTokenAddress == _ToTokenContractAddress) {\\n            return tokens2Trade;\\n        }\\n\\n        if (fromTokenAddress == address(0)) {\\n            if (_ToTokenContractAddress == wmaticTokenAddress) {\\n                IWETH(wmaticTokenAddress).deposit.value(tokens2Trade)();\\n                return tokens2Trade;\\n            }\\n\\n            address[] memory path = new address[](2);\\n            path[0] = wmaticTokenAddress;\\n            path[1] = _ToTokenContractAddress;\\n            tokenBought = quickswapRouter.swapExactETHForTokens.value(\\n                tokens2Trade\\n            )(1, path, address(this), deadline)[path.length - 1];\\n        } else if (_ToTokenContractAddress == address(0)) {\\n            if (fromTokenAddress == wmaticTokenAddress) {\\n                IWETH(wmaticTokenAddress).withdraw(tokens2Trade);\\n                return tokens2Trade;\\n            }\\n\\n            IERC20(fromTokenAddress).safeApprove(\\n                address(quickswapRouter),\\n                tokens2Trade\\n            );\\n\\n            address[] memory path = new address[](2);\\n            path[0] = fromTokenAddress;\\n            path[1] = wmaticTokenAddress;\\n            tokenBought = quickswapRouter.swapExactTokensForETH(\\n                tokens2Trade,\\n                1,\\n                path,\\n                address(this),\\n                deadline\\n            )[path.length - 1];\\n        } else {\\n            IERC20(fromTokenAddress).safeApprove(\\n                address(quickswapRouter),\\n                tokens2Trade\\n            );\\n\\n            if (fromTokenAddress != wmaticTokenAddress) {\\n                if (_ToTokenContractAddress != wmaticTokenAddress) {\\n                    // check output via tokenA -> tokenB\\n                    address pairA =\\n                        quickswapFactory.getPair(\\n                            fromTokenAddress,\\n                            _ToTokenContractAddress\\n                        );\\n                    address[] memory pathA = new address[](2);\\n                    pathA[0] = fromTokenAddress;\\n                    pathA[1] = _ToTokenContractAddress;\\n                    uint256 amtA;\\n                    if (pairA != address(0)) {\\n                        amtA = quickswapRouter.getAmountsOut(\\n                            tokens2Trade,\\n                            pathA\\n                        )[1];\\n                    }\\n\\n                    // check output via tokenA -> wmatic -> tokenB\\n                    address[] memory pathB = new address[](3);\\n                    pathB[0] = fromTokenAddress;\\n                    pathB[1] = wmaticTokenAddress;\\n                    pathB[2] = _ToTokenContractAddress;\\n\\n                    uint256 amtB =\\n                        quickswapRouter.getAmountsOut(tokens2Trade, pathB)[2];\\n\\n                    if (amtA >= amtB) {\\n                        tokenBought = quickswapRouter.swapExactTokensForTokens(\\n                            tokens2Trade,\\n                            1,\\n                            pathA,\\n                            address(this),\\n                            deadline\\n                        )[pathA.length - 1];\\n                    } else {\\n                        tokenBought = quickswapRouter.swapExactTokensForTokens(\\n                            tokens2Trade,\\n                            1,\\n                            pathB,\\n                            address(this),\\n                            deadline\\n                        )[pathB.length - 1];\\n                    }\\n                } else {\\n                    address[] memory path = new address[](2);\\n                    path[0] = fromTokenAddress;\\n                    path[1] = wmaticTokenAddress;\\n\\n                    tokenBought = quickswapRouter.swapExactTokensForTokens(\\n                        tokens2Trade,\\n                        1,\\n                        path,\\n                        address(this),\\n                        deadline\\n                    )[path.length - 1];\\n                }\\n            } else {\\n                address[] memory path = new address[](2);\\n                path[0] = wmaticTokenAddress;\\n                path[1] = _ToTokenContractAddress;\\n                tokenBought = quickswapRouter.swapExactTokensForTokens(\\n                    tokens2Trade,\\n                    1,\\n                    path,\\n                    address(this),\\n                    deadline\\n                )[path.length - 1];\\n            }\\n        }\\n        require(tokenBought > 0, \\\"Error Swapping Tokens\\\");\\n    }\\n\\n    /**\\n    @notice This function is used to swap MATIC/ERC20 <> MATIC/ERC20 via Sushiswap\\n    @param fromTokenAddress The token address to swap from. (0x00 for ETH)\\n    @param _ToTokenContractAddress The token address to swap to. (0x00 for ETH)\\n    @param tokens2Trade The amount of tokens to swap\\n    @return tokenBought The quantity of tokens bought\\n    */\\n    function _token2TokenSushi(\\n        address fromTokenAddress,\\n        address _ToTokenContractAddress,\\n        uint256 tokens2Trade\\n    ) internal returns (uint256 tokenBought) {\\n        if (fromTokenAddress == _ToTokenContractAddress) {\\n            return tokens2Trade;\\n        }\\n\\n        if (fromTokenAddress == address(0)) {\\n            if (_ToTokenContractAddress == wmaticTokenAddress) {\\n                IWETH(wmaticTokenAddress).deposit.value(tokens2Trade)();\\n                return tokens2Trade;\\n            }\\n\\n            address[] memory path = new address[](2);\\n            path[0] = wmaticTokenAddress;\\n            path[1] = _ToTokenContractAddress;\\n            tokenBought = sushiswapRouter.swapExactETHForTokens.value(\\n                tokens2Trade\\n            )(1, path, address(this), deadline)[path.length - 1];\\n        } else if (_ToTokenContractAddress == address(0)) {\\n            if (fromTokenAddress == wmaticTokenAddress) {\\n                IWETH(wmaticTokenAddress).withdraw(tokens2Trade);\\n                return tokens2Trade;\\n            }\\n\\n            IERC20(fromTokenAddress).safeApprove(\\n                address(sushiswapRouter),\\n                tokens2Trade\\n            );\\n\\n            address[] memory path = new address[](2);\\n            path[0] = fromTokenAddress;\\n            path[1] = wmaticTokenAddress;\\n            tokenBought = sushiswapRouter.swapExactTokensForETH(\\n                tokens2Trade,\\n                1,\\n                path,\\n                address(this),\\n                deadline\\n            )[path.length - 1];\\n        } else {\\n            IERC20(fromTokenAddress).safeApprove(\\n                address(sushiswapRouter),\\n                tokens2Trade\\n            );\\n\\n            if (fromTokenAddress != wmaticTokenAddress) {\\n                if (_ToTokenContractAddress != wmaticTokenAddress) {\\n                    // check output via tokenA -> tokenB\\n                    address pairA =\\n                        sushiswapFactory.getPair(\\n                            fromTokenAddress,\\n                            _ToTokenContractAddress\\n                        );\\n                    address[] memory pathA = new address[](2);\\n                    pathA[0] = fromTokenAddress;\\n                    pathA[1] = _ToTokenContractAddress;\\n                    uint256 amtA;\\n                    if (pairA != address(0)) {\\n                        amtA = sushiswapRouter.getAmountsOut(\\n                            tokens2Trade,\\n                            pathA\\n                        )[1];\\n                    }\\n\\n                    // check output via tokenA -> wmatic -> tokenB\\n                    address[] memory pathB = new address[](3);\\n                    pathB[0] = fromTokenAddress;\\n                    pathB[1] = wmaticTokenAddress;\\n                    pathB[2] = _ToTokenContractAddress;\\n\\n                    uint256 amtB =\\n                        sushiswapRouter.getAmountsOut(tokens2Trade, pathB)[2];\\n\\n                    if (amtA >= amtB) {\\n                        tokenBought = sushiswapRouter.swapExactTokensForTokens(\\n                            tokens2Trade,\\n                            1,\\n                            pathA,\\n                            address(this),\\n                            deadline\\n                        )[pathA.length - 1];\\n                    } else {\\n                        tokenBought = sushiswapRouter.swapExactTokensForTokens(\\n                            tokens2Trade,\\n                            1,\\n                            pathB,\\n                            address(this),\\n                            deadline\\n                        )[pathB.length - 1];\\n                    }\\n                } else {\\n                    address[] memory path = new address[](2);\\n                    path[0] = fromTokenAddress;\\n                    path[1] = wmaticTokenAddress;\\n\\n                    tokenBought = sushiswapRouter.swapExactTokensForTokens(\\n                        tokens2Trade,\\n                        1,\\n                        path,\\n                        address(this),\\n                        deadline\\n                    )[path.length - 1];\\n                }\\n            } else {\\n                address[] memory path = new address[](2);\\n                path[0] = wmaticTokenAddress;\\n                path[1] = _ToTokenContractAddress;\\n                tokenBought = sushiswapRouter.swapExactTokensForTokens(\\n                    tokens2Trade,\\n                    1,\\n                    path,\\n                    address(this),\\n                    deadline\\n                )[path.length - 1];\\n            }\\n        }\\n        require(tokenBought > 0, \\\"Error Swapping Tokens\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Curve_Registry_V2\",\"name\":\"_curveRegistry\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_goodwill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_affiliateSplit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensRec\",\"type\":\"uint256\"}],\"name\":\"zapOut\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"swapAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"incomingCrv\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"intermediateToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minToTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_swapTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_swapCallData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"shouldSellEntireBalance\",\"type\":\"bool\"}],\"name\":\"ZapOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ToTokensBought\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"affiliateBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"affiliates\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"affilliateWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedTargets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curveReg\",\"outputs\":[{\"internalType\":\"contract Curve_Registry_V2\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goodwill\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"swapAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityReturn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"isApproved\",\"type\":\"bool[]\"}],\"name\":\"setApprovedTargets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_affiliate\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"set_affiliate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"zapAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"set_feeWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_new_affiliateSplit\",\"type\":\"uint256\"}],\"name\":\"set_new_affiliateSplit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_new_goodwill\",\"type\":\"uint256\"}],\"name\":\"set_new_goodwill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"toggleContractActive\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalAffiliateBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Curve_Registry_V2\",\"name\":\"newCurveRegistry\",\"type\":\"address\"}],\"name\":\"updateCurveRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Curve_ZapOut_General_V4_1","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008aee0a8a05a319bfca41ff2e95c48f3f8638321100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":"bzzr://51c271c494e7c7feb1875c524f6c969a6ef5d3d8f142cbb521b1733bb1f2c6fe"}]}