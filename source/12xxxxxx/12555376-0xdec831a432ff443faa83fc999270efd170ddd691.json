{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/QNFT/QNFTSettings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\n\\nimport \\\"../interface/structs.sol\\\";\\nimport \\\"../interface/IQNFTSettings.sol\\\";\\nimport \\\"../interface/IQSettings.sol\\\";\\n\\n/**\\n * @author fantasy\\n */\\ncontract QNFTSettings is IQNFTSettings, ContextUpgradeable {\\n    // events\\n    event SetPriceMultipliers(\\n        uint256 tokenPriceMultiplier,\\n        uint256 nonTokenPriceMultiplier,\\n        uint256 upgradePriceMultiplier\\n    );\\n    event AddLockOption(\\n        uint256 minAmount,\\n        uint256 maxAmount,\\n        uint32 lockDuration,\\n        uint8 discount // percent\\n    );\\n    event UpdateLockOption(\\n        uint32 indexed lockOptionId,\\n        uint256 minAmount,\\n        uint256 maxAmount,\\n        uint32 lockDuration,\\n        uint8 discount // percent\\n    );\\n    event AddCharacters(uint256[] prices, uint256 maxSupply);\\n    event UpdateCharacterPrice(uint32 indexed characterId, uint256 price);\\n    event UpdateCharacterPrices(\\n        uint32 startIndex,\\n        uint32 length,\\n        uint256 price\\n    );\\n    event UpdateCharacterPricesFromArray(uint32[] indexes, uint256[] prices);\\n    event UpdateCharacterMaxSupply(\\n        uint32 indexed characterId,\\n        uint256 maxSupply\\n    );\\n    event UpdateCharacterMaxSupplies(\\n        uint32 startIndex,\\n        uint32 length,\\n        uint256 supply\\n    );\\n    event UpdateCharacterMaxSuppliesFromArray(\\n        uint32[] indexes,\\n        uint256[] supplies\\n    );\\n    event AddFavCoinPrices(uint256[] mintPrices);\\n    event UpdateFavCoinPrice(uint32 favCoinId, uint256 price);\\n    event StartMint(uint256 startedAt);\\n    event EndMint();\\n    event PauseMint(uint256 pausedAt);\\n    event UnpauseMint(uint256 unPausedAt);\\n\\n    // constants\\n    uint32 public NFT_SALE_DURATION; // default: 2 weeks\\n\\n    // mint options set\\n    uint256 public qstkPrice; // qstk price\\n    uint256 public nonTokenPriceMultiplier; // percentage - should be multiplied to non token price - image + favorite coin\\n    uint256 public tokenPriceMultiplier; // percentage - should be multiplied to token price - qstk\\n    uint256 public override upgradePriceMultiplier; // percentage - should be multiplied to coin mint price - favorite coin - used for favorite coin upgrade price calculation\\n\\n    LockOption[] public lockOptions; // array of lock options\\n    uint256[] private _characterPrices; // array of character purchase prices\\n    uint256[] private _characterMaxSupply; // limitation count for the given character\\n    uint256[] private _favCoinPrices; // array of favorite coin purchase prices\\n\\n    // mint options set\\n    uint256 public override mintStartTime;\\n    bool public override mintStarted;\\n    bool public override mintPaused;\\n    bool public override onlyAirdropUsers;\\n\\n    // By default, transfer is not allowed for redeemed NFTs to prevent spam sell. Users can transfer redeemed NFTS after this flag is enabled.\\n    bool public override transferAllowedAfterRedeem;\\n\\n    IQSettings public settings; // QSettings contract address\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyManager() {\\n        require(\\n            settings.getManager() == msg.sender,\\n            \\\"QNFTSettings: caller is not the manager\\\"\\n        );\\n        _;\\n    }\\n\\n    function initialize(\\n        address _settings,\\n        uint256 _qstkPrice,\\n        uint256 _tokenPriceMultiplier,\\n        uint256 _nonTokenPriceMultiplier,\\n        uint256 _upgradePriceMultiplier,\\n        uint32 _nftSaleDuration\\n    ) external initializer {\\n        __Context_init();\\n\\n        settings = IQSettings(_settings);\\n        qstkPrice = _qstkPrice;\\n        nonTokenPriceMultiplier = _nonTokenPriceMultiplier;\\n        tokenPriceMultiplier = _tokenPriceMultiplier;\\n        upgradePriceMultiplier = _upgradePriceMultiplier;\\n        NFT_SALE_DURATION = _nftSaleDuration;\\n\\n        onlyAirdropUsers = true;\\n    }\\n\\n    /**\\n     * @dev returns the count of lock options\\n     */\\n    function lockOptionsCount() public view override returns (uint256) {\\n        return lockOptions.length;\\n    }\\n\\n    /**\\n     * @dev returns the lock duration of given lock option id\\n     */\\n    function lockOptionLockDuration(uint32 _lockOptionId)\\n        external\\n        view\\n        override\\n        returns (uint32)\\n    {\\n        require(\\n            _lockOptionId < lockOptions.length,\\n            \\\"QNFTSettings: invalid lock option\\\"\\n        );\\n\\n        return lockOptions[_lockOptionId].lockDuration;\\n    }\\n\\n    /**\\n     * @dev adds a new lock option\\n     */\\n    function addLockOption(\\n        uint256 _minAmount,\\n        uint256 _maxAmount,\\n        uint32 _lockDuration,\\n        uint8 _discount\\n    ) external onlyManager {\\n        require(_discount <= 100, \\\"QNFTSettings: invalid discount\\\");\\n        lockOptions.push(\\n            LockOption(_minAmount, _maxAmount, _lockDuration, _discount)\\n        );\\n\\n        emit AddLockOption(_minAmount, _maxAmount, _lockDuration, _discount);\\n    }\\n\\n    /**\\n     * @dev update a lock option\\n     */\\n    function updateLockOption(\\n        uint32 _lockOptionId,\\n        uint256 _minAmount,\\n        uint256 _maxAmount,\\n        uint32 _lockDuration,\\n        uint8 _discount\\n    ) external onlyManager {\\n        require(\\n            lockOptions.length > _lockOptionId,\\n            \\\"QNFTSettings: invalid lock option id\\\"\\n        );\\n        require(_discount <= 100, \\\"QNFTSettings: invalid discount\\\");\\n\\n        lockOptions[_lockOptionId] = LockOption(\\n            _minAmount,\\n            _maxAmount,\\n            _lockDuration,\\n            _discount\\n        );\\n\\n        emit UpdateLockOption(\\n            _lockOptionId,\\n            _minAmount,\\n            _maxAmount,\\n            _lockDuration,\\n            _discount\\n        );\\n    }\\n\\n    function characterPrice(uint32 _characterId)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _characterPrices[_characterId];\\n    }\\n\\n    /**\\n     * @dev returns the count of nft characters\\n     */\\n    function characterCount() public view override returns (uint256) {\\n        return _characterPrices.length;\\n    }\\n\\n    /**\\n     * @dev adds new character mint prices/max supplies\\n     */\\n    function addCharacters(uint256[] memory _prices, uint256 _maxSupply)\\n        external\\n        onlyManager\\n    {\\n        for (uint256 i = 0; i < _prices.length; i++) {\\n            _characterPrices.push(_prices[i]);\\n            _characterMaxSupply.push(_maxSupply);\\n        }\\n\\n        emit AddCharacters(_prices, _maxSupply);\\n    }\\n\\n    /**\\n     * @dev updates a character price\\n     */\\n    function updateCharacterPrice(uint32 _characterId, uint256 _price)\\n        external\\n        onlyManager\\n    {\\n        require(\\n            _characterPrices.length > _characterId,\\n            \\\"QNFTSettings: invalid character id\\\"\\n        );\\n\\n        _characterPrices[_characterId] = _price;\\n\\n        emit UpdateCharacterPrice(_characterId, _price);\\n    }\\n\\n    /**\\n     * @dev updates multiple character prices\\n     */\\n    function updateCharacterPrices(\\n        uint32 _startIndex,\\n        uint32 _length,\\n        uint256 _price\\n    ) external onlyManager {\\n        require(\\n            _characterPrices.length >= _startIndex + _length,\\n            \\\"QNFTSettings: invalid character ids range\\\"\\n        );\\n\\n        for (uint256 i = 0; i < _length; i++) {\\n            _characterPrices[_startIndex + i] = _price;\\n        }\\n\\n        emit UpdateCharacterPrices(_startIndex, _length, _price);\\n    }\\n\\n    /**\\n     * @dev updates multiple character prices\\n     */\\n    function updateCharacterPricesFromArray(\\n        uint32[] memory _indexes,\\n        uint256[] memory _prices\\n    ) external onlyManager {\\n        require(\\n            _indexes.length == _prices.length,\\n            \\\"QNFTSettings: length doesn't match\\\"\\n        );\\n\\n        for (uint256 i = 0; i < _indexes.length; i++) {\\n            require(\\n                _indexes[i] < _characterPrices.length,\\n                \\\"QNFTSettings: invalid index\\\"\\n            );\\n            _characterPrices[_indexes[i]] = _prices[i];\\n        }\\n\\n        emit UpdateCharacterPricesFromArray(_indexes, _prices);\\n    }\\n\\n    function characterMaxSupply(uint32 _characterId)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _characterMaxSupply[_characterId];\\n    }\\n\\n    /**\\n     * @dev updates a character max supply\\n     */\\n    function updateCharacterMaxSupply(uint32 _characterId, uint256 _maxSupply)\\n        external\\n        onlyManager\\n    {\\n        require(\\n            _characterMaxSupply.length > _characterId,\\n            \\\"QNFTSettings: invalid character id\\\"\\n        );\\n\\n        _characterMaxSupply[_characterId] = _maxSupply;\\n\\n        emit UpdateCharacterMaxSupply(_characterId, _maxSupply);\\n    }\\n\\n    /**\\n     * @dev updates multiple character max supplies\\n     */\\n    function updateCharacterMaxSupplies(\\n        uint32 _startIndex,\\n        uint32 _length,\\n        uint256 _supply\\n    ) external onlyManager {\\n        require(\\n            _characterMaxSupply.length >= _startIndex + _length,\\n            \\\"QNFTSettings: invalid character ids range\\\"\\n        );\\n\\n        for (uint256 i = 0; i < _length; i++) {\\n            _characterMaxSupply[_startIndex + i] = _supply;\\n        }\\n\\n        emit UpdateCharacterMaxSupplies(_startIndex, _length, _supply);\\n    }\\n\\n    /**\\n     * @dev updates multiple character max supplies\\n     */\\n    function updateCharacterMaxSuppliesFromArray(\\n        uint32[] memory _indexes,\\n        uint256[] memory _supplies\\n    ) external onlyManager {\\n        require(\\n            _indexes.length == _supplies.length,\\n            \\\"QNFTSettings: length doesn't match\\\"\\n        );\\n\\n        for (uint256 i = 0; i < _indexes.length; i++) {\\n            require(\\n                _indexes[i] < _characterMaxSupply.length,\\n                \\\"QNFTSettings: invalid index\\\"\\n            );\\n            _characterMaxSupply[_indexes[i]] = _supplies[i];\\n        }\\n\\n        emit UpdateCharacterMaxSuppliesFromArray(_indexes, _supplies);\\n    }\\n\\n    function favCoinPrices(uint32 _favCoinId)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _favCoinPrices[_favCoinId];\\n    }\\n\\n    /**\\n     * @dev returns the count of favorite coins\\n     */\\n    function favCoinsCount() public view override returns (uint256) {\\n        return _favCoinPrices.length;\\n    }\\n\\n    /**\\n     * @dev adds new favorite coins\\n     */\\n    function addFavCoinPrices(uint256[] memory _prices) external onlyManager {\\n        for (uint16 i = 0; i < _prices.length; i++) {\\n            _favCoinPrices.push(_prices[i]);\\n        }\\n\\n        emit AddFavCoinPrices(_prices);\\n    }\\n\\n    /**\\n     * @dev updates a favorite coin\\n     */\\n    function updateFavCoinPrice(uint32 _favCoinId, uint256 _price)\\n        external\\n        onlyManager\\n    {\\n        require(_favCoinPrices.length > _favCoinId, \\\"QNFTSettings: invalid id\\\");\\n\\n        _favCoinPrices[_favCoinId] = _price;\\n\\n        emit UpdateFavCoinPrice(_favCoinId, _price);\\n    }\\n\\n    /**\\n     * @dev calculate mint price of given mint options\\n     */\\n    function calcMintPrice(\\n        uint32 _characterId,\\n        uint32 _favCoinId,\\n        uint32 _lockOptionId,\\n        uint256 _lockAmount,\\n        uint256 _freeAmount\\n    )\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 totalPrice,\\n            uint256 tokenPrice,\\n            uint256 nonTokenPrice\\n        )\\n    {\\n        require(\\n            characterCount() > _characterId,\\n            \\\"QNFTSettings: invalid character option\\\"\\n        );\\n        require(\\n            lockOptionsCount() > _lockOptionId,\\n            \\\"QNFTSettings: invalid lock option\\\"\\n        );\\n        require(favCoinsCount() > _favCoinId, \\\"QNFTSettings: invalid fav coin\\\");\\n\\n        LockOption memory lockOption = lockOptions[_lockOptionId];\\n\\n        require(\\n            lockOption.minAmount <= _lockAmount + _freeAmount &&\\n                _lockAmount <= lockOption.maxAmount,\\n            \\\"QNFTSettings: invalid mint amount\\\"\\n        );\\n\\n        // mintPrice = qstkPrice * lockAmount * discountRate * tokenPriceMultiplier + (characterMintPrice + favCoinMintPrice) * nonTokenPriceMultiplier\\n\\n        uint256 decimal =\\n            IERC20MetadataUpgradeable(settings.getQStk()).decimals();\\n        tokenPrice =\\n            (qstkPrice *\\n                _lockAmount *\\n                (100 - lockOption.discount) *\\n                tokenPriceMultiplier) /\\n            (10**decimal) /\\n            10000;\\n\\n        nonTokenPrice =\\n            ((_characterPrices[_characterId] + _favCoinPrices[_favCoinId]) *\\n                nonTokenPriceMultiplier) /\\n            100;\\n\\n        totalPrice = tokenPrice + nonTokenPrice;\\n    }\\n\\n    function setPriceMultipliers(\\n        uint256 _tokenPriceMultiplier,\\n        uint256 _nonTokenPriceMultiplier,\\n        uint256 _upgradePriceMultiplier\\n    ) external onlyManager {\\n        tokenPriceMultiplier = _tokenPriceMultiplier;\\n        nonTokenPriceMultiplier = _nonTokenPriceMultiplier;\\n        upgradePriceMultiplier = _upgradePriceMultiplier;\\n\\n        emit SetPriceMultipliers(\\n            _tokenPriceMultiplier,\\n            _nonTokenPriceMultiplier,\\n            _upgradePriceMultiplier\\n        );\\n    }\\n\\n    /**\\n     * @dev starts/restarts mint process\\n     */\\n    function startMint() external onlyManager {\\n        mintStarted = true;\\n        mintStartTime = block.timestamp;\\n        mintPaused = false;\\n\\n        emit StartMint(mintStartTime);\\n    }\\n\\n    /**\\n     * @dev ends mint process\\n     */\\n    function endMint() external onlyManager {\\n        require(\\n            mintStarted == true && !mintFinished(),\\n            \\\"QNFTSettings: mint not in progress\\\"\\n        );\\n        mintStartTime = block.timestamp - NFT_SALE_DURATION;\\n\\n        emit EndMint();\\n    }\\n\\n    /**\\n     * @dev pause mint process\\n     */\\n    function pauseMint() external onlyManager {\\n        require(\\n            mintStarted == true && !mintFinished(),\\n            \\\"QNFTSettings: mint not in progress\\\"\\n        );\\n        require(mintPaused == false, \\\"QNFTSettings: mint already paused\\\");\\n\\n        mintPaused = true;\\n\\n        emit PauseMint(block.timestamp);\\n    }\\n\\n    /**\\n     * @dev unpause mint process\\n     */\\n    function unPauseMint() external onlyManager {\\n        require(\\n            mintStarted == true && !mintFinished(),\\n            \\\"QNFTSettings: mint not in progress\\\"\\n        );\\n        require(mintPaused == true, \\\"QNFTSettings: mint not paused\\\");\\n\\n        mintPaused = false;\\n\\n        emit UnpauseMint(block.timestamp);\\n    }\\n\\n    /**\\n     * @dev returns the mint end time\\n     */\\n    function mintEndTime() public view override returns (uint256) {\\n        return mintStartTime + NFT_SALE_DURATION;\\n    }\\n\\n    /**\\n     * @dev checks if mint process is finished\\n     */\\n    function mintFinished() public view override returns (bool) {\\n        return mintStarted && mintEndTime() <= block.timestamp;\\n    }\\n\\n    function setOnlyAirdropUsers(bool _onlyAirdropUsers) external onlyManager {\\n        onlyAirdropUsers = _onlyAirdropUsers;\\n    }\\n\\n    function setTransferAllowedAfterRedeem(bool _allow) external onlyManager {\\n        transferAllowedAfterRedeem = _allow;\\n    }\\n\\n    function setSettings(IQSettings _settings) external onlyManager {\\n        settings = _settings;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\n// structs\\nstruct LockOption {\\n    uint256 minAmount; // e.g. 0QSTK, 100QSTK, 200QSTK, 300QSTK\\n    uint256 maxAmount; // e.g. 0QSTK, 100QSTK, 200QSTK, 300QSTK\\n    uint32 lockDuration; // e.g. 3 months, 6 months, 1 year\\n    uint8 discount; // percent e.g. 10%, 20%, 30%\\n}\\n\\nstruct NFTData {\\n    // NFT data\\n    uint32 characterId;\\n    uint32 favCoinId;\\n    uint32 metaId;\\n    uint32 unlockTime;\\n    uint256 lockAmount;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IQNFTSettings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\ninterface IQNFTSettings {\\n    function favCoinsCount() external view returns (uint256);\\n\\n    function lockOptionsCount() external view returns (uint256);\\n\\n    function characterCount() external view returns (uint256);\\n\\n    function characterPrice(uint32 characterId) external view returns (uint256);\\n\\n    function favCoinPrices(uint32 favCoinId) external view returns (uint256);\\n\\n    function lockOptionLockDuration(uint32 lockOptionId)\\n        external\\n        view\\n        returns (uint32);\\n\\n    function characterMaxSupply(uint32 characterId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function calcMintPrice(\\n        uint32 _characterId,\\n        uint32 _favCoinId,\\n        uint32 _lockOptionId,\\n        uint256 _lockAmount,\\n        uint256 _freeAmount\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 totalPrice,\\n            uint256 tokenPrice,\\n            uint256 nonTokenPrice\\n        );\\n\\n    function mintStarted() external view returns (bool);\\n\\n    function mintPaused() external view returns (bool);\\n\\n    function mintStartTime() external view returns (uint256);\\n\\n    function mintEndTime() external view returns (uint256);\\n\\n    function mintFinished() external view returns (bool);\\n\\n    function onlyAirdropUsers() external view returns (bool);\\n\\n    function transferAllowedAfterRedeem() external view returns (bool);\\n\\n    function upgradePriceMultiplier() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IQSettings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\ninterface IQSettings {\\n    function getManager() external view returns (address);\\n\\n    function getFoundationWallet() external view returns (address);\\n\\n    function getQStk() external view returns (address);\\n\\n    function getQAirdrop() external view returns (address);\\n\\n    function getQNftSettings() external view returns (address);\\n\\n    function getQNftGov() external view returns (address);\\n\\n    function getQNft() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"}],\"name\":\"AddCharacters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"mintPrices\",\"type\":\"uint256[]\"}],\"name\":\"AddFavCoinPrices\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"lockDuration\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"discount\",\"type\":\"uint8\"}],\"name\":\"AddLockOption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EndMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pausedAt\",\"type\":\"uint256\"}],\"name\":\"PauseMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPriceMultiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonTokenPriceMultiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"upgradePriceMultiplier\",\"type\":\"uint256\"}],\"name\":\"SetPriceMultipliers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"}],\"name\":\"StartMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unPausedAt\",\"type\":\"uint256\"}],\"name\":\"UnpauseMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startIndex\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"length\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"UpdateCharacterMaxSupplies\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"indexes\",\"type\":\"uint32[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"supplies\",\"type\":\"uint256[]\"}],\"name\":\"UpdateCharacterMaxSuppliesFromArray\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"characterId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"}],\"name\":\"UpdateCharacterMaxSupply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"characterId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"UpdateCharacterPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startIndex\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"length\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"UpdateCharacterPrices\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"indexes\",\"type\":\"uint32[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"name\":\"UpdateCharacterPricesFromArray\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"favCoinId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"UpdateFavCoinPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"lockOptionId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"lockDuration\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"discount\",\"type\":\"uint8\"}],\"name\":\"UpdateLockOption\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NFT_SALE_DURATION\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"}],\"name\":\"addCharacters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_prices\",\"type\":\"uint256[]\"}],\"name\":\"addFavCoinPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_lockDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"_discount\",\"type\":\"uint8\"}],\"name\":\"addLockOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_characterId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_favCoinId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_lockOptionId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_lockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_freeAmount\",\"type\":\"uint256\"}],\"name\":\"calcMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonTokenPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"characterCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_characterId\",\"type\":\"uint32\"}],\"name\":\"characterMaxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_characterId\",\"type\":\"uint32\"}],\"name\":\"characterPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_favCoinId\",\"type\":\"uint32\"}],\"name\":\"favCoinPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"favCoinsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_settings\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_qstkPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPriceMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonTokenPriceMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_upgradePriceMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_nftSaleDuration\",\"type\":\"uint32\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_lockOptionId\",\"type\":\"uint32\"}],\"name\":\"lockOptionLockDuration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockOptions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"lockDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"discount\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockOptionsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonTokenPriceMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onlyAirdropUsers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"qstkPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_onlyAirdropUsers\",\"type\":\"bool\"}],\"name\":\"setOnlyAirdropUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenPriceMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonTokenPriceMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_upgradePriceMultiplier\",\"type\":\"uint256\"}],\"name\":\"setPriceMultipliers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IQSettings\",\"name\":\"_settings\",\"type\":\"address\"}],\"name\":\"setSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allow\",\"type\":\"bool\"}],\"name\":\"setTransferAllowedAfterRedeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settings\",\"outputs\":[{\"internalType\":\"contract IQSettings\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPriceMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferAllowedAfterRedeem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPauseMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_startIndex\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_length\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"}],\"name\":\"updateCharacterMaxSupplies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_indexes\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_supplies\",\"type\":\"uint256[]\"}],\"name\":\"updateCharacterMaxSuppliesFromArray\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_characterId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"}],\"name\":\"updateCharacterMaxSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_characterId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"updateCharacterPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_startIndex\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_length\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"updateCharacterPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_indexes\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_prices\",\"type\":\"uint256[]\"}],\"name\":\"updateCharacterPricesFromArray\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_favCoinId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"updateFavCoinPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_lockOptionId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_lockDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"_discount\",\"type\":\"uint8\"}],\"name\":\"updateLockOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradePriceMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"QNFTSettings","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}