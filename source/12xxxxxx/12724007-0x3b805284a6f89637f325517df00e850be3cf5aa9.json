{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/PolicyBookRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"./interfaces/IPolicyBook.sol\\\";\\nimport \\\"./interfaces/IPolicyBookRegistry.sol\\\";\\nimport \\\"./interfaces/IContractsRegistry.sol\\\";\\n\\nimport \\\"./abstract/AbstractDependant.sol\\\";\\n\\ncontract PolicyBookRegistry is IPolicyBookRegistry, AbstractDependant {\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    address public policyBookFabricAddress;\\n    address public policyBookAdminAddress;\\n\\n    // insured contract address => proxy address\\n    mapping(address => address) public policyBooksByInsuredAddress;\\n\\n    EnumerableSet.AddressSet internal _policyBooks;\\n    mapping(IPolicyBookFabric.ContractType => EnumerableSet.AddressSet)\\n        internal _policyBooksByType;\\n\\n    EnumerableSet.AddressSet internal _whitelistedPolicyBooks;\\n    mapping(IPolicyBookFabric.ContractType => EnumerableSet.AddressSet)\\n        internal _whitelistedPolicyBooksByType;\\n\\n    event Added(address insured, address at);\\n\\n    modifier onlyPolicyBookFabric() {\\n        require(\\n            msg.sender == policyBookFabricAddress,\\n            \\\"PolicyBookRegistry: Not a PolicyBookFabric\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyPolicyBookAdmin() {\\n        require(msg.sender == policyBookAdminAddress, \\\"PolicyBookRegistry: Not a PolicyBookAdmin\\\");\\n        _;\\n    }\\n\\n    function setDependencies(IContractsRegistry _contractsRegistry)\\n        external\\n        override\\n        onlyInjectorOrZero\\n    {\\n        policyBookFabricAddress = _contractsRegistry.getPolicyBookFabricContract();\\n        policyBookAdminAddress = _contractsRegistry.getPolicyBookAdminContract();\\n    }\\n\\n    function add(\\n        address insuredContract,\\n        IPolicyBookFabric.ContractType contractType,\\n        address policyBook\\n    ) external override onlyPolicyBookFabric {\\n        require(\\n            policyBooksByInsuredAddress[insuredContract] == address(0),\\n            \\\"PolicyBookRegistry: PolicyBook for the contract is already created\\\"\\n        );\\n\\n        policyBooksByInsuredAddress[insuredContract] = policyBook;\\n\\n        _policyBooks.add(policyBook);\\n        _policyBooksByType[contractType].add(policyBook);\\n\\n        emit Added(insuredContract, policyBook);\\n    }\\n\\n    function whitelist(address policyBookAddress, bool whitelisted)\\n        external\\n        override\\n        onlyPolicyBookAdmin\\n    {\\n        IPolicyBookFabric.ContractType contractType =\\n            IPolicyBook(policyBookAddress).contractType();\\n\\n        if (whitelisted) {\\n            _whitelistedPolicyBooks.add(policyBookAddress);\\n            _whitelistedPolicyBooksByType[contractType].add(policyBookAddress);\\n        } else {\\n            _whitelistedPolicyBooks.remove(policyBookAddress);\\n            _whitelistedPolicyBooksByType[contractType].remove(policyBookAddress);\\n        }\\n    }\\n\\n    function getPoliciesPrices(\\n        address[] calldata policyBooks,\\n        uint256[] calldata epochsNumbers,\\n        uint256[] calldata coversTokens\\n    ) external view override returns (uint256[] memory _durations, uint256[] memory _allowances) {\\n        require(\\n            policyBooks.length == epochsNumbers.length &&\\n                policyBooks.length == coversTokens.length,\\n            \\\"PolicyBookRegistry: Lengths mismatch\\\"\\n        );\\n\\n        _durations = new uint256[](policyBooks.length);\\n        _allowances = new uint256[](policyBooks.length);\\n\\n        for (uint256 i = 0; i < policyBooks.length; i++) {\\n            require(isPolicyBook(policyBooks[i]), \\\"PolicyBookRegistry: Not a PolicyBook\\\");\\n\\n            (_durations[i], _allowances[i]) = IPolicyBook(policyBooks[i]).getPolicyPrice(\\n                epochsNumbers[i],\\n                coversTokens[i]\\n            );\\n        }\\n    }\\n\\n    function buyPolicyBatch(\\n        address[] calldata policyBooks,\\n        uint256[] calldata epochsNumbers,\\n        uint256[] calldata coversTokens\\n    ) external override {\\n        require(\\n            policyBooks.length == epochsNumbers.length &&\\n                policyBooks.length == coversTokens.length,\\n            \\\"PolicyBookRegistry: Lengths mismatch\\\"\\n        );\\n\\n        for (uint256 i = 0; i < policyBooks.length; i++) {\\n            require(isPolicyBook(policyBooks[i]), \\\"PolicyBookRegistry: Not a PolicyBook\\\");\\n\\n            IPolicyBook(policyBooks[i]).buyPolicyFor(\\n                msg.sender,\\n                epochsNumbers[i],\\n                coversTokens[i]\\n            );\\n        }\\n    }\\n\\n    function isPolicyBook(address policyBook) public view override returns (bool) {\\n        return _policyBooks.contains(policyBook);\\n    }\\n\\n    function countByType(IPolicyBookFabric.ContractType contractType)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _policyBooksByType[contractType].length();\\n    }\\n\\n    function count() external view override returns (uint256) {\\n        return _policyBooks.length();\\n    }\\n\\n    function countByTypeWhitelisted(IPolicyBookFabric.ContractType contractType)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _whitelistedPolicyBooksByType[contractType].length();\\n    }\\n\\n    function countWhitelisted() external view override returns (uint256) {\\n        return _whitelistedPolicyBooks.length();\\n    }\\n\\n    /// @notice use with countByType()\\n    function listByType(\\n        IPolicyBookFabric.ContractType contractType,\\n        uint256 offset,\\n        uint256 limit\\n    ) public view override returns (address[] memory _policyBooksArr) {\\n        return _listByType(contractType, offset, limit, _policyBooksByType);\\n    }\\n\\n    /// @notice use with count()\\n    function list(uint256 offset, uint256 limit)\\n        public\\n        view\\n        override\\n        returns (address[] memory _policyBooksArr)\\n    {\\n        return _list(offset, limit, _policyBooks);\\n    }\\n\\n    /// @notice use with countByTypeWhitelisted()\\n    function listByTypeWhitelisted(\\n        IPolicyBookFabric.ContractType contractType,\\n        uint256 offset,\\n        uint256 limit\\n    ) public view override returns (address[] memory _policyBooksArr) {\\n        return _listByType(contractType, offset, limit, _whitelistedPolicyBooksByType);\\n    }\\n\\n    /// @notice use with countWhitelisted()\\n    function listWhitelisted(uint256 offset, uint256 limit)\\n        public\\n        view\\n        override\\n        returns (address[] memory _policyBooksArr)\\n    {\\n        return _list(offset, limit, _whitelistedPolicyBooks);\\n    }\\n\\n    function listWithStatsByType(\\n        IPolicyBookFabric.ContractType contractType,\\n        uint256 offset,\\n        uint256 limit\\n    )\\n        external\\n        view\\n        override\\n        returns (address[] memory _policyBooksArr, PolicyBookStats[] memory _stats)\\n    {\\n        _policyBooksArr = listByType(contractType, offset, limit);\\n        _stats = stats(_policyBooksArr);\\n    }\\n\\n    function listWithStats(uint256 offset, uint256 limit)\\n        external\\n        view\\n        override\\n        returns (address[] memory _policyBooksArr, PolicyBookStats[] memory _stats)\\n    {\\n        _policyBooksArr = list(offset, limit);\\n        _stats = stats(_policyBooksArr);\\n    }\\n\\n    function listWithStatsByTypeWhitelisted(\\n        IPolicyBookFabric.ContractType contractType,\\n        uint256 offset,\\n        uint256 limit\\n    )\\n        external\\n        view\\n        override\\n        returns (address[] memory _policyBooksArr, PolicyBookStats[] memory _stats)\\n    {\\n        _policyBooksArr = listByTypeWhitelisted(contractType, offset, limit);\\n        _stats = stats(_policyBooksArr);\\n    }\\n\\n    function listWithStatsWhitelisted(uint256 offset, uint256 limit)\\n        external\\n        view\\n        override\\n        returns (address[] memory _policyBooksArr, PolicyBookStats[] memory _stats)\\n    {\\n        _policyBooksArr = listWhitelisted(offset, limit);\\n        _stats = stats(_policyBooksArr);\\n    }\\n\\n    function _listByType(\\n        IPolicyBookFabric.ContractType contractType,\\n        uint256 offset,\\n        uint256 limit,\\n        mapping(IPolicyBookFabric.ContractType => EnumerableSet.AddressSet) storage map\\n    ) internal view returns (address[] memory _policyBooksArr) {\\n        uint256 to = (offset.add(limit)).min(map[contractType].length()).max(offset);\\n\\n        _policyBooksArr = new address[](to - offset);\\n\\n        for (uint256 i = offset; i < to; i++) {\\n            _policyBooksArr[i - offset] = map[contractType].at(i);\\n        }\\n    }\\n\\n    function _list(\\n        uint256 offset,\\n        uint256 limit,\\n        EnumerableSet.AddressSet storage set\\n    ) internal view returns (address[] memory _policyBooksArr) {\\n        uint256 to = (offset.add(limit)).min(set.length()).max(offset);\\n\\n        _policyBooksArr = new address[](to - offset);\\n\\n        for (uint256 i = offset; i < to; i++) {\\n            _policyBooksArr[i - offset] = set.at(i);\\n        }\\n    }\\n\\n    function stats(address[] memory policyBooks)\\n        public\\n        view\\n        override\\n        returns (PolicyBookStats[] memory _stats)\\n    {\\n        _stats = new PolicyBookStats[](policyBooks.length);\\n\\n        for (uint256 i = 0; i < policyBooks.length; i++) {\\n            (\\n                _stats[i].symbol,\\n                _stats[i].insuredContract,\\n                _stats[i].contractType,\\n                _stats[i].whitelisted\\n            ) = IPolicyBook(policyBooks[i]).info();\\n\\n            (\\n                _stats[i].maxCapacity,\\n                _stats[i].totalDaiLiquidity,\\n                _stats[i].stakedDAI,\\n                _stats[i].APY,\\n                _stats[i].annualInsuranceCost,\\n                _stats[i].bmiDaiRatio\\n            ) = IPolicyBook(policyBooks[i]).numberStats();\\n        }\\n    }\\n\\n    function policyBookFor(address insuredContract) external view override returns (address) {\\n        return policyBooksByInsuredAddress[insuredContract];\\n    }\\n\\n    function statsByInsuredContracts(address[] calldata insuredContracts)\\n        external\\n        view\\n        override\\n        returns (PolicyBookStats[] memory _stats)\\n    {\\n        _stats = new PolicyBookStats[](insuredContracts.length);\\n\\n        for (uint256 i = 0; i < insuredContracts.length; i++) {\\n            (\\n                _stats[i].symbol,\\n                _stats[i].insuredContract,\\n                _stats[i].contractType,\\n                _stats[i].whitelisted\\n            ) = IPolicyBook(policyBooksByInsuredAddress[insuredContracts[i]]).info();\\n\\n            (\\n                _stats[i].maxCapacity,\\n                _stats[i].totalDaiLiquidity,\\n                _stats[i].stakedDAI,\\n                _stats[i].APY,\\n                _stats[i].annualInsuranceCost,\\n                _stats[i].bmiDaiRatio\\n            ) = IPolicyBook(policyBooksByInsuredAddress[insuredContracts[i]]).numberStats();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/abstract/AbstractDependant.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\n\\nimport \\\"../interfaces/IContractsRegistry.sol\\\";\\n\\nabstract contract AbstractDependant {\\n    /// @dev keccak256(AbstractDependant.setInjector(address)) - 1\\n    bytes32 private constant _INJECTOR_SLOT =\\n        0xd6b8f2e074594ceb05d47c27386969754b6ad0c15e5eb8f691399cd0be980e76;\\n\\n    modifier onlyInjectorOrZero() {\\n        address _injector = injector();\\n\\n        require(_injector == address(0) || _injector == msg.sender, \\\"Dependant: Not an injector\\\");\\n        _;\\n    }\\n\\n    function setInjector(address _injector) external onlyInjectorOrZero {\\n        bytes32 slot = _INJECTOR_SLOT;\\n\\n        assembly {\\n            sstore(slot, _injector)\\n        }\\n    }\\n\\n    /// @dev has to apply onlyInjectorOrZero() modifier\\n    function setDependencies(IContractsRegistry) external virtual;\\n\\n    function injector() public view returns (address _injector) {\\n        bytes32 slot = _INJECTOR_SLOT;\\n\\n        assembly {\\n            _injector := sload(slot)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/interfaces/IClaimingRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IPolicyBookFabric.sol\\\";\\n\\ninterface IClaimingRegistry {\\n    enum ClaimStatus {\\n        CAN_CLAIM,\\n        UNCLAIMABLE,\\n        PENDING,\\n        AWAITING_CALCULATION,\\n        REJECTED_CAN_APPEAL,\\n        REJECTED,\\n        ACCEPTED\\n    }\\n\\n    struct ClaimInfo {\\n        address claimer;\\n        address policyBookAddress;\\n        string evidenceURI;\\n        uint256 dateSubmitted;\\n        uint256 dateEnded;\\n        bool appeal;\\n        ClaimStatus status;\\n        uint256 claimAmount;\\n    }\\n\\n    /// @notice returns anonymous voting duration\\n    function anonymousVotingDuration(uint256 index) external view returns (uint256);\\n\\n    /// @notice returns the whole voting duration\\n    function votingDuration(uint256 index) external view returns (uint256);\\n\\n    /// @notice returns how many time should pass before anyone could calculate a claim result\\n    function anyoneCanCalculateClaimResultAfter(uint256 index) external view returns (uint256);\\n\\n    /// @notice returns true if a user can buy new policy of specified PolicyBook\\n    function canBuyNewPolicy(address buyer, address policyBookAddress)\\n        external\\n        view\\n        returns (bool);\\n\\n    /// @notice submits new PolicyBook claim for the user\\n    function submitClaim(\\n        address user,\\n        address policyBookAddress,\\n        string calldata evidenceURI,\\n        uint256 cover,\\n        bool appeal\\n    ) external returns (uint256);\\n\\n    /// @notice returns true if the claim with this index exists\\n    function claimExists(uint256 index) external view returns (bool);\\n\\n    /// @notice returns claim submition time\\n    function claimSubmittedTime(uint256 index) external view returns (uint256);\\n\\n    /// @notice returns claim end time or zero in case it is pending\\n    function claimEndTime(uint256 index) external view returns (uint256);\\n\\n    /// @notice returns true if the claim is anonymously votable\\n    function isClaimAnonymouslyVotable(uint256 index) external view returns (bool);\\n\\n    /// @notice returns true if the claim is exposably votable\\n    function isClaimExposablyVotable(uint256 index) external view returns (bool);\\n\\n    /// @notice returns true if claim is anonymously votable or exposably votable\\n    function isClaimVotable(uint256 index) external view returns (bool);\\n\\n    /// @notice returns true if a claim can be calculated by anyone\\n    function canClaimBeCalculatedByAnyone(uint256 index) external view returns (bool);\\n\\n    /// @notice returns true if this claim is pending or awaiting\\n    function isClaimPending(uint256 index) external view returns (bool);\\n\\n    /// @notice returns how many claims the holder has\\n    function countPolicyClaimerClaims(address user) external view returns (uint256);\\n\\n    /// @notice returns how many pending claims are there\\n    function countPendingClaims() external view returns (uint256);\\n\\n    /// @notice returns how many claims are there\\n    function countClaims() external view returns (uint256);\\n\\n    /// @notice returns a claim index of it's claimer and an ordinal number\\n    function claimOfOwnerIndexAt(address claimer, uint256 orderIndex)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice returns pending claim index by its ordinal index\\n    function pendingClaimIndexAt(uint256 orderIndex) external view returns (uint256);\\n\\n    /// @notice returns claim index by its ordinal index\\n    function claimIndexAt(uint256 orderIndex) external view returns (uint256);\\n\\n    /// @notice returns current active claim index by policybook and claimer\\n    function claimIndex(address claimer, address policyBookAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice returns true if the claim is appealed\\n    function isClaimAppeal(uint256 index) external view returns (bool);\\n\\n    /// @notice returns current status of a claim\\n    function policyStatus(address claimer, address policyBookAddress)\\n        external\\n        view\\n        returns (ClaimStatus);\\n\\n    /// @notice returns current status of a claim\\n    function claimStatus(uint256 index) external view returns (ClaimStatus);\\n\\n    /// @notice returns the claim owner (claimer)\\n    function claimOwner(uint256 index) external view returns (address);\\n\\n    /// @notice returns the claim PolicyBook\\n    function claimPolicyBook(uint256 index) external view returns (address);\\n\\n    /// @notice returns claim info by its index\\n    function claimInfo(uint256 index) external view returns (ClaimInfo memory _claimInfo);\\n\\n    /// @notice marks the user's claim as Accepted\\n    function acceptClaim(uint256 index) external;\\n\\n    /// @notice marks the user's claim as Rejected\\n    function rejectClaim(uint256 index) external;\\n}\\n\"\r\n    },\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/interfaces/IContractsRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\npragma experimental ABIEncoderV2;\\n\\ninterface IContractsRegistry {\\n    function getUniswapRouterContract() external view returns (address);\\n\\n    function getUniswapBMIToETHPairContract() external view returns (address);\\n\\n    function getWETHContract() external view returns (address);\\n\\n    function getDAIContract() external view returns (address);\\n\\n    function getBMIContract() external view returns (address);\\n\\n    function getPriceFeedContract() external view returns (address);\\n\\n    function getPolicyBookRegistryContract() external view returns (address);\\n\\n    function getPolicyBookFabricContract() external view returns (address);\\n\\n    function getBMIDAIStakingContract() external view returns (address);\\n\\n    function getRewardsGeneratorContract() external view returns (address);\\n\\n    function getBMIUtilityNFTContract() external view returns (address);\\n\\n    function getLiquidityMiningContract() external view returns (address);\\n\\n    function getClaimingRegistryContract() external view returns (address);\\n\\n    function getPolicyRegistryContract() external view returns (address);\\n\\n    function getLiquidityRegistryContract() external view returns (address);\\n\\n    function getClaimVotingContract() external view returns (address);\\n\\n    function getReinsurancePoolContract() external view returns (address);\\n\\n    function getPolicyBookAdminContract() external view returns (address);\\n\\n    function getPolicyQuoteContract() external view returns (address);\\n\\n    function getLegacyBMIStakingContract() external view returns (address);\\n\\n    function getBMIStakingContract() external view returns (address);\\n\\n    function getSTKBMIContract() external view returns (address);\\n\\n    function getVBMIContract() external view returns (address);\\n\\n    function getLegacyLiquidityMiningStakingContract() external view returns (address);\\n\\n    function getLiquidityMiningStakingContract() external view returns (address);\\n\\n    function getReputationSystemContract() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/interfaces/IPolicyBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IPolicyBookFabric.sol\\\";\\nimport \\\"./IClaimingRegistry.sol\\\";\\n\\ninterface IPolicyBook {\\n    enum WithdrawalStatus {NONE, PENDING, READY, EXPIRED}\\n\\n    struct PolicyHolder {\\n        uint256 coverTokens;\\n        uint256 startEpochNumber;\\n        uint256 endEpochNumber;\\n        uint256 paid;\\n    }\\n\\n    struct WithdrawalInfo {\\n        uint256 withdrawalAmount;\\n        uint256 readyToWithdrawDate;\\n        bool withdrawalAllowed;\\n    }\\n\\n    function EPOCH_DURATION() external view returns (uint256);\\n\\n    function READY_TO_WITHDRAW_PERIOD() external view returns (uint256);\\n\\n    function whitelisted() external view returns (bool);\\n\\n    function epochStartTime() external view returns (uint256);\\n\\n    // @TODO: should we let DAO to change contract address?\\n    /// @notice Returns address of contract this PolicyBook covers, access: ANY\\n    /// @return _contract is address of covered contract\\n    function insuranceContractAddress() external view returns (address _contract);\\n\\n    /// @notice Returns type of contract this PolicyBook covers, access: ANY\\n    /// @return _type is type of contract\\n    function contractType() external view returns (IPolicyBookFabric.ContractType _type);\\n\\n    function totalLiquidity() external view returns (uint256);\\n\\n    function totalCoverTokens() external view returns (uint256);\\n\\n    function withdrawalsInfo(address _userAddr)\\n        external\\n        view\\n        returns (\\n            uint256 _withdrawalAmount,\\n            uint256 _readyToWithdrawDate,\\n            bool _withdrawalAllowed\\n        );\\n\\n    function __PolicyBook_init(\\n        address _insuranceContract,\\n        IPolicyBookFabric.ContractType _contractType,\\n        string calldata _description,\\n        string calldata _projectSymbol\\n    ) external;\\n\\n    function whitelist(bool _whitelisted) external;\\n\\n    function getEpoch(uint256 time) external view returns (uint256);\\n\\n    /// @notice get DAI equivalent\\n    function convertDAIXToDAI(uint256 _amount) external view returns (uint256);\\n\\n    /// @notice get DAIx equivalent\\n    function convertDAIToDAIX(uint256 _amount) external view returns (uint256);\\n\\n    /// @notice returns how many BMI tokens needs to approve in order to submit a claim\\n    function getClaimApprovalAmount(address user) external view returns (uint256);\\n\\n    /// @notice submits new claim of the policy book\\n    function submitClaimAndInitializeVoting(string calldata evidenceURI) external;\\n\\n    /// @notice submits new appeal claim of the policy book\\n    function submitAppealAndInitializeVoting(string calldata evidenceURI) external;\\n\\n    /// @notice updates info on claim acceptance\\n    function commitClaim(\\n        address claimer,\\n        uint256 claimAmount,\\n        uint256 claimEndTime,\\n        IClaimingRegistry.ClaimStatus status\\n    ) external;\\n\\n    /// @notice function to get precise current cover and liquidity\\n    function getNewCoverAndLiquidity()\\n        external\\n        view\\n        returns (uint256 newTotalCoverTokens, uint256 newTotalLiquidity);\\n\\n    /// @notice view function to get precise policy price\\n    function getPolicyPrice(uint256 _epochsNumber, uint256 _coverTokens)\\n        external\\n        view\\n        returns (uint256 totalSeconds, uint256 totalPrice);\\n\\n    function buyPolicyFor(\\n        address _buyer,\\n        uint256 _epochsNumber,\\n        uint256 _coverTokens\\n    ) external;\\n\\n    /// @notice Let user to buy policy by supplying DAI, access: ANY\\n    /// @param _durationSeconds is number of seconds to cover\\n    /// @param _coverTokens is number of tokens to cover\\n    function buyPolicy(uint256 _durationSeconds, uint256 _coverTokens) external;\\n\\n    function updateEpochsInfo() external;\\n\\n    function secondsToEndCurrentEpoch() external view returns (uint256);\\n\\n    /// @notice Let user to add liquidity by supplying DAI, access: ANY\\n    /// @param _liqudityAmount is amount of DAI tokens to secure\\n    function addLiquidity(uint256 _liqudityAmount) external;\\n\\n    /// @notice Let eligible contracts add liqiudity for another user by supplying DAI\\n    /// @param _liquidityHolderAddr is address of address to assign cover\\n    /// @param _liqudityAmount is amount of DAI tokens to secure\\n    function addLiquidityFor(address _liquidityHolderAddr, uint256 _liqudityAmount) external;\\n\\n    function addLiquidityAndStake(uint256 _liquidityAmount, uint256 _bmiDAIxAmount) external;\\n\\n    function getAvailableDAIXWithdrawableAmount(address _userAddr) external view returns (uint256);\\n\\n    function getWithdrawalStatus(address _userAddr) external view returns (WithdrawalStatus);\\n\\n    function requestWithdrawal(uint256 _tokensToWithdraw) external;\\n\\n    function requestWithdrawalWithPermit(\\n        uint256 _tokensToWithdraw,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) external;\\n\\n    function unlockTokens() external;\\n\\n    /// @notice Let user to withdraw deposited liqiudity, access: ANY\\n    function withdrawLiquidity() external;\\n\\n    function getAPY() external view returns (uint256);\\n\\n    /// @notice Getting user stats, access: ANY\\n    function userStats(address _user) external view returns (PolicyHolder memory);\\n\\n    /// @notice Getting number stats, access: ANY\\n    /// @return _maxCapacities is a max token amount that a user can buy\\n    /// @return _totalDaiLiquidity is PolicyBook's liquidity\\n    /// @return _stakedDAI is how much DAI are staked on this PolicyBook\\n    /// @return _annualProfitYields is its APY\\n    /// @return _annualInsuranceCost is percentage of cover tokens that is required to be paid for 1 year of insurance\\n    function numberStats()\\n        external\\n        view\\n        returns (\\n            uint256 _maxCapacities,\\n            uint256 _totalDaiLiquidity,\\n            uint256 _stakedDAI,\\n            uint256 _annualProfitYields,\\n            uint256 _annualInsuranceCost,\\n            uint256 _bmiDaiRatio\\n        );\\n\\n    /// @notice Getting info, access: ANY\\n    /// @return _symbol is the symbol of PolicyBook (bmiDaiX)\\n    /// @return _insuredContract is an addres of insured contract\\n    /// @return _contractType is a type of insured contract\\n    /// @return _whitelisted is a state of whitelisting\\n    function info()\\n        external\\n        view\\n        returns (\\n            string memory _symbol,\\n            address _insuredContract,\\n            IPolicyBookFabric.ContractType _contractType,\\n            bool _whitelisted\\n        );\\n}\\n\"\r\n    },\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/interfaces/IPolicyBookFabric.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\n\\ninterface IPolicyBookFabric {\\n    enum ContractType {CONTRACT, STABLECOIN, SERVICE, EXCHANGE}\\n\\n    /// @notice Create new Policy Book contract, access: ANY\\n    /// @param _contract is Contract to create policy book for\\n    /// @param _contractType is Contract to create policy book for\\n    /// @param _description is bmiDAIx token desription for this policy book\\n    /// @param _projectSymbol replaces x in bmiDAIx token symbol\\n    /// @param _initialDeposit is an amount user deposits on creation (addLiquidity())\\n    /// @return _policyBook is address of created contract\\n    function create(\\n        address _contract,\\n        ContractType _contractType,\\n        string calldata _description,\\n        string calldata _projectSymbol,\\n        uint256 _initialDeposit\\n    ) external returns (address);\\n}\\n\"\r\n    },\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/interfaces/IPolicyBookRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IPolicyBookFabric.sol\\\";\\n\\ninterface IPolicyBookRegistry {\\n    struct PolicyBookStats {\\n        string symbol;\\n        address insuredContract;\\n        IPolicyBookFabric.ContractType contractType;\\n        uint256 maxCapacity;\\n        uint256 totalDaiLiquidity;\\n        uint256 stakedDAI;\\n        uint256 APY;\\n        uint256 annualInsuranceCost;\\n        uint256 bmiDaiRatio;\\n        bool whitelisted;\\n    }\\n\\n    /// @notice Adds PolicyBook to registry, access: PolicyFabric\\n    function add(\\n        address insuredContract,\\n        IPolicyBookFabric.ContractType contractType,\\n        address policyBook\\n    ) external;\\n\\n    function whitelist(address policyBookAddress, bool whitelisted) external;\\n\\n    /// @notice returns required allowances for the policybooks\\n    function getPoliciesPrices(\\n        address[] calldata policyBooks,\\n        uint256[] calldata epochsNumbers,\\n        uint256[] calldata coversTokens\\n    ) external view returns (uint256[] memory _durations, uint256[] memory _allowances);\\n\\n    /// @notice Buys a batch of policies\\n    function buyPolicyBatch(\\n        address[] calldata policyBooks,\\n        uint256[] calldata epochsNumbers,\\n        uint256[] calldata coversTokens\\n    ) external;\\n\\n    /// @notice Checks if provided address is a PolicyBook\\n    function isPolicyBook(address policyBook) external view returns (bool);\\n\\n    /// @notice Returns number of registered PolicyBooks with certain contract type\\n    function countByType(IPolicyBookFabric.ContractType contractType)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice Returns number of registered PolicyBooks, access: ANY\\n    function count() external view returns (uint256);\\n\\n    function countByTypeWhitelisted(IPolicyBookFabric.ContractType contractType)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function countWhitelisted() external view returns (uint256);\\n\\n    /// @notice Listing registered PolicyBooks with certain contract type, access: ANY\\n    /// @return _policyBooksArr is array of registered PolicyBook addresses with certain contract type\\n    function listByType(\\n        IPolicyBookFabric.ContractType contractType,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory _policyBooksArr);\\n\\n    /// @notice Listing registered PolicyBooks, access: ANY\\n    /// @return _policyBooksArr is array of registered PolicyBook addresses\\n    function list(uint256 offset, uint256 limit)\\n        external\\n        view\\n        returns (address[] memory _policyBooksArr);\\n\\n    function listByTypeWhitelisted(\\n        IPolicyBookFabric.ContractType contractType,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory _policyBooksArr);\\n\\n    function listWhitelisted(uint256 offset, uint256 limit)\\n        external\\n        view\\n        returns (address[] memory _policyBooksArr);\\n\\n    /// @notice Listing registered PolicyBooks with stats and certain contract type, access: ANY\\n    function listWithStatsByType(\\n        IPolicyBookFabric.ContractType contractType,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory _policyBooksArr, PolicyBookStats[] memory _stats);\\n\\n    /// @notice Listing registered PolicyBooks with stats, access: ANY\\n    function listWithStats(uint256 offset, uint256 limit)\\n        external\\n        view\\n        returns (address[] memory _policyBooksArr, PolicyBookStats[] memory _stats);\\n\\n    function listWithStatsByTypeWhitelisted(\\n        IPolicyBookFabric.ContractType contractType,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory _policyBooksArr, PolicyBookStats[] memory _stats);\\n\\n    function listWithStatsWhitelisted(uint256 offset, uint256 limit)\\n        external\\n        view\\n        returns (address[] memory _policyBooksArr, PolicyBookStats[] memory _stats);\\n\\n    /// @notice Getting stats from policy books, access: ANY\\n    /// @param policyBooks is list of PolicyBooks addresses\\n    function stats(address[] calldata policyBooks)\\n        external\\n        view\\n        returns (PolicyBookStats[] memory _stats);\\n\\n    /// @notice Return existing Policy Book contract, access: ANY\\n    /// @param insuredContract is contract address to lookup for created IPolicyBook\\n    function policyBookFor(address insuredContract) external view returns (address);\\n\\n    /// @notice Getting stats from policy books, access: ANY\\n    /// @param insuredContracts is list of insuredContracts in registry\\n    function statsByInsuredContracts(address[] calldata insuredContracts)\\n        external\\n        view\\n        returns (PolicyBookStats[] memory _stats);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"insured\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"at\",\"type\":\"address\"}],\"name\":\"Added\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"insuredContract\",\"type\":\"address\"},{\"internalType\":\"enum IPolicyBookFabric.ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"policyBook\",\"type\":\"address\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"policyBooks\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"epochsNumbers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"coversTokens\",\"type\":\"uint256[]\"}],\"name\":\"buyPolicyBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPolicyBookFabric.ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"}],\"name\":\"countByType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPolicyBookFabric.ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"}],\"name\":\"countByTypeWhitelisted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countWhitelisted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"policyBooks\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"epochsNumbers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"coversTokens\",\"type\":\"uint256[]\"}],\"name\":\"getPoliciesPrices\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_durations\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_allowances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"injector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_injector\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"policyBook\",\"type\":\"address\"}],\"name\":\"isPolicyBook\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"list\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_policyBooksArr\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPolicyBookFabric.ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"listByType\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_policyBooksArr\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPolicyBookFabric.ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"listByTypeWhitelisted\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_policyBooksArr\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"listWhitelisted\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_policyBooksArr\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"listWithStats\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_policyBooksArr\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"insuredContract\",\"type\":\"address\"},{\"internalType\":\"enum IPolicyBookFabric.ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maxCapacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDaiLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedDAI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"APY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"annualInsuranceCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bmiDaiRatio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"internalType\":\"struct IPolicyBookRegistry.PolicyBookStats[]\",\"name\":\"_stats\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPolicyBookFabric.ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"listWithStatsByType\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_policyBooksArr\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"insuredContract\",\"type\":\"address\"},{\"internalType\":\"enum IPolicyBookFabric.ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maxCapacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDaiLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedDAI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"APY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"annualInsuranceCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bmiDaiRatio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"internalType\":\"struct IPolicyBookRegistry.PolicyBookStats[]\",\"name\":\"_stats\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPolicyBookFabric.ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"listWithStatsByTypeWhitelisted\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_policyBooksArr\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"insuredContract\",\"type\":\"address\"},{\"internalType\":\"enum IPolicyBookFabric.ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maxCapacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDaiLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedDAI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"APY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"annualInsuranceCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bmiDaiRatio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"internalType\":\"struct IPolicyBookRegistry.PolicyBookStats[]\",\"name\":\"_stats\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"listWithStatsWhitelisted\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_policyBooksArr\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"insuredContract\",\"type\":\"address\"},{\"internalType\":\"enum IPolicyBookFabric.ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maxCapacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDaiLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedDAI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"APY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"annualInsuranceCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bmiDaiRatio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"internalType\":\"struct IPolicyBookRegistry.PolicyBookStats[]\",\"name\":\"_stats\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"policyBookAdminAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"policyBookFabricAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"insuredContract\",\"type\":\"address\"}],\"name\":\"policyBookFor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"policyBooksByInsuredAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IContractsRegistry\",\"name\":\"_contractsRegistry\",\"type\":\"address\"}],\"name\":\"setDependencies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_injector\",\"type\":\"address\"}],\"name\":\"setInjector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"policyBooks\",\"type\":\"address[]\"}],\"name\":\"stats\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"insuredContract\",\"type\":\"address\"},{\"internalType\":\"enum IPolicyBookFabric.ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maxCapacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDaiLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedDAI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"APY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"annualInsuranceCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bmiDaiRatio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"internalType\":\"struct IPolicyBookRegistry.PolicyBookStats[]\",\"name\":\"_stats\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"insuredContracts\",\"type\":\"address[]\"}],\"name\":\"statsByInsuredContracts\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"insuredContract\",\"type\":\"address\"},{\"internalType\":\"enum IPolicyBookFabric.ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maxCapacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDaiLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedDAI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"APY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"annualInsuranceCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bmiDaiRatio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"internalType\":\"struct IPolicyBookRegistry.PolicyBookStats[]\",\"name\":\"_stats\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"policyBookAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"name\":\"whitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PolicyBookRegistry","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}