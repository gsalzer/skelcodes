{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PerpetualProtocolReferrer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport { PerpFiOwnableUpgrade } from \\\"./PerpFiOwnableUpgrade.sol\\\";\\r\\n\\r\\ncontract PerpetualProtocolReferrer is PerpFiOwnableUpgrade {\\r\\n    enum UpsertAction{ ADD, REMOVE, UPDATE }\\r\\n\\r\\n    struct Referrer {\\r\\n        uint256 createdAt;\\r\\n        string referralCode;\\r\\n        address createdBy;\\r\\n    }\\r\\n\\r\\n    struct Referee {\\r\\n        string referralCode;\\r\\n        uint256 createdAt;\\r\\n        uint256 updatedAt;\\r\\n    }\\r\\n\\r\\n    event OnReferralCodeCreated (\\r\\n        address createdBy,\\r\\n        address createdFor,\\r\\n        uint256 timestamp,\\r\\n        string referralCode\\r\\n    );\\r\\n\\r\\n    event OnReferralCodeUpserted (\\r\\n        address addr,\\r\\n        UpsertAction action,\\r\\n        uint256 timestamp,\\r\\n        string newReferralCode,\\r\\n        string oldReferralCode\\r\\n    );\\r\\n\\r\\n    mapping(address => Referrer) public referrerStore;\\r\\n    mapping(address => Referee) public refereeStore;\\r\\n    mapping(string => address) public referralCodeToReferrerMap;\\r\\n\\r\\n    constructor() public {\\r\\n        __Ownable_init();\\r\\n    }\\r\\n\\r\\n    function createReferralCode(address createdFor, string memory referralCode) external onlyOwner {\\r\\n        address sender = msg.sender;\\r\\n        uint256 timestamp = block.timestamp;\\r\\n        // the referrer for a code that already exists, used to check against a referral code\\r\\n        // that has already been assigned\\r\\n        address existingReferralCodeReferrer = referralCodeToReferrerMap[referralCode];\\r\\n        // the referrer being assigned a new code cannot have an existing code - check using this\\r\\n        Referrer memory existingReferrer = referrerStore[createdFor];\\r\\n        require(bytes(referralCode).length > 0, \\\"Provide a referral code.\\\");\\r\\n        require(createdFor != address(0x0), \\\"Provide an address to create the code for.\\\");\\r\\n        require(existingReferralCodeReferrer == address(0x0), \\\"This referral code has already been assigned to an address.\\\");\\r\\n        require(bytes(existingReferrer.referralCode).length == 0, \\\"This address already has a referral code assigned.\\\");\\r\\n\\r\\n        referrerStore[createdFor] = Referrer(timestamp, referralCode, sender);\\r\\n        referralCodeToReferrerMap[referralCode] = createdFor;\\r\\n        emit OnReferralCodeCreated(sender, createdFor, timestamp, referralCode);\\r\\n    }\\r\\n\\r\\n    function getReferralCodeByReferrerAddress(address referralOwner) external view returns (string memory) {\\r\\n        Referrer memory referrer = referrerStore[referralOwner];\\r\\n        require(bytes(referrer.referralCode).length > 0, \\\"Referral code doesn't exist\\\");\\r\\n        return (referrer.referralCode);\\r\\n    }\\r\\n\\r\\n    function getMyRefereeCode() public view returns (string memory) {\\r\\n        Referee memory referee = refereeStore[msg.sender];\\r\\n        require(bytes(referee.referralCode).length > 0, \\\"You do not have a referral code\\\");\\r\\n        return (referee.referralCode);\\r\\n    }\\r\\n\\r\\n    function setReferralCode(string memory referralCode) public {\\r\\n        address sender = msg.sender;\\r\\n        address referrer = referralCodeToReferrerMap[referralCode];\\r\\n        uint256 timestamp = block.timestamp;\\r\\n        UpsertAction action;\\r\\n        string memory oldReferralCode = referralCode;\\r\\n\\r\\n        require(referrer != sender, \\\"You cannot be a referee of a referral code you own\\\");\\r\\n        \\r\\n        // the referee in we are performing the upserts for\\r\\n        Referee storage referee = refereeStore[sender];\\r\\n\\r\\n        // when referral code is supplied by the referee\\r\\n        if (bytes(referralCode).length > 0) {\\r\\n            // if mapping does not exist, referral code doesn't exist.\\r\\n            require(referrer != address(0x0), \\\"Referral code does not exist\\\");\\r\\n\\r\\n            // if there is a referral code already for that referee, update it with the supplied one\\r\\n            if (bytes(referee.referralCode).length > 0) {\\r\\n                oldReferralCode = referee.referralCode;\\r\\n                referee.referralCode = referralCode;\\r\\n                referee.updatedAt = timestamp;\\r\\n                action = UpsertAction.UPDATE;\\r\\n            } else {\\r\\n                // if a code doesn't exist for the referee, create the referee\\r\\n                refereeStore[sender] = Referee(referralCode, timestamp, timestamp);\\r\\n                action = UpsertAction.ADD;\\r\\n            }\\r\\n        // if the referral is not supplied and referee exists, delete referee\\r\\n        } else if (bytes(referee.referralCode).length > 0) {\\r\\n            oldReferralCode = referee.referralCode;\\r\\n            delete refereeStore[sender];\\r\\n            action = UpsertAction.REMOVE;\\r\\n        }\\r\\n\\r\\n        if (bytes(referralCode).length == 0 && bytes(referee.referralCode).length == 0) {\\r\\n            revert(\\\"No referral code was supplied or found.\\\");\\r\\n        }\\r\\n        emit OnReferralCodeUpserted(sender, action, timestamp, referralCode, oldReferralCode);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/PerpFiOwnableUpgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport { ContextUpgradeSafe } from \\\"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\\\";\\r\\n\\r\\n// copy from openzeppelin Ownable, only modify how the owner transfer\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract PerpFiOwnableUpgrade is ContextUpgradeSafe {\\r\\n    address private _owner;\\r\\n    address private _candidate;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n\\r\\n    function __Ownable_init() internal initializer {\\r\\n        __Context_init_unchained();\\r\\n        __Ownable_init_unchained();\\r\\n    }\\r\\n\\r\\n    function __Ownable_init_unchained() internal initializer {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    function candidate() public view returns (address) {\\r\\n        return _candidate;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"PerpFiOwnableUpgrade: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function setOwner(address newOwner) public onlyOwner {\\r\\n        require(newOwner != address(0), \\\"PerpFiOwnableUpgrade: zero address\\\");\\r\\n        require(newOwner != _owner, \\\"PerpFiOwnableUpgrade: same as original\\\");\\r\\n        require(newOwner != _candidate, \\\"PerpFiOwnableUpgrade: same as candidate\\\");\\r\\n        _candidate = newOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`_candidate`).\\r\\n     * Can only be called by the new owner.\\r\\n     */\\r\\n    function updateOwner() public {\\r\\n        require(_candidate != address(0), \\\"PerpFiOwnableUpgrade: candidate is zero address\\\");\\r\\n        require(_candidate == _msgSender(), \\\"PerpFiOwnableUpgrade: not the new owner\\\");\\r\\n\\r\\n        emit OwnershipTransferred(_owner, _candidate);\\r\\n        _owner = _candidate;\\r\\n        _candidate = address(0);\\r\\n    }\\r\\n\\r\\n    uint256[50] private __gap;\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\nimport \\\"../Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract ContextUpgradeSafe is Initializable {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n\\n\\n    }\\n\\n\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"createdBy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"createdFor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"referralCode\",\"type\":\"string\"}],\"name\":\"OnReferralCodeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum PerpetualProtocolReferrer.UpsertAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newReferralCode\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"oldReferralCode\",\"type\":\"string\"}],\"name\":\"OnReferralCodeUpserted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"candidate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"createdFor\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"referralCode\",\"type\":\"string\"}],\"name\":\"createReferralCode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMyRefereeCode\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referralOwner\",\"type\":\"address\"}],\"name\":\"getReferralCodeByReferrerAddress\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"refereeStore\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"referralCode\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"referralCodeToReferrerMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrerStore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"referralCode\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"createdBy\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"referralCode\",\"type\":\"string\"}],\"name\":\"setReferralCode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PerpetualProtocolReferrer","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}