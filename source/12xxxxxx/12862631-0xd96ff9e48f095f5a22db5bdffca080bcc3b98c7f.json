{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PartyBidFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\nimport {InitializedProxy} from \\\"./InitializedProxy.sol\\\";\\nimport {PartyBid} from \\\"./PartyBid.sol\\\";\\n\\n/**\\n * @title PartyBid Factory\\n * @author Anna Carroll\\n *\\n * WARNING: A malicious MarketWrapper contract could be used to steal user funds;\\n * A poorly implemented MarketWrapper contract could permanently lose access to the NFT.\\n * When deploying a PartyBid, exercise extreme caution.\\n * Only use MarketWrapper contracts that have been audited and tested.\\n */\\ncontract PartyBidFactory {\\n    //======== Events ========\\n\\n    event PartyBidDeployed(\\n        address partyBidProxy,\\n        address creator,\\n        address nftContract,\\n        uint256 tokenId,\\n        address marketWrapper,\\n        uint256 auctionId,\\n        string name,\\n        string symbol\\n    );\\n\\n    //======== Immutable storage =========\\n\\n    address public immutable logic;\\n    address public immutable partyDAOMultisig;\\n    address public immutable tokenVaultFactory;\\n    address public immutable weth;\\n\\n    //======== Constructor =========\\n\\n    constructor(\\n        address _partyDAOMultisig,\\n        address _tokenVaultFactory,\\n        address _weth\\n    ) {\\n        partyDAOMultisig = _partyDAOMultisig;\\n        tokenVaultFactory = _tokenVaultFactory;\\n        weth = _weth;\\n        // deploy logic contract\\n        logic = address(\\n            new PartyBid(_partyDAOMultisig, _tokenVaultFactory, _weth)\\n        );\\n    }\\n\\n    //======== Deploy function =========\\n\\n    function startParty(\\n        address _marketWrapper,\\n        address _nftContract,\\n        uint256 _tokenId,\\n        uint256 _auctionId,\\n        string memory _name,\\n        string memory _symbol\\n    ) external returns (address partyBidProxy) {\\n        bytes memory _initializationCalldata =\\n            abi.encodeWithSignature(\\n                \\\"initialize(address,address,uint256,uint256,string,string)\\\",\\n                _marketWrapper,\\n                _nftContract,\\n                _tokenId,\\n                _auctionId,\\n                _name,\\n                _symbol\\n            );\\n\\n        partyBidProxy = address(\\n            new InitializedProxy(\\n                logic,\\n                _initializationCalldata\\n            )\\n        );\\n\\n        emit PartyBidDeployed(\\n            partyBidProxy,\\n            msg.sender,\\n            _nftContract,\\n            _tokenId,\\n            _marketWrapper,\\n            _auctionId,\\n            _name,\\n            _symbol\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/InitializedProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\n/**\\n * @title InitializedProxy\\n * @author Anna Carroll\\n */\\ncontract InitializedProxy {\\n    // address of logic contract\\n    address public immutable logic;\\n\\n    // ======== Constructor =========\\n\\n    constructor(\\n        address _logic,\\n        bytes memory _initializationCalldata\\n    ) {\\n        logic = _logic;\\n        // Delegatecall into the logic contract, supplying initialization calldata\\n        (bool _ok, bytes memory returnData) =\\n            _logic.delegatecall(_initializationCalldata);\\n        // Revert if delegatecall to implementation reverts\\n        require(_ok, string(returnData));\\n    }\\n\\n    // ======== Fallback =========\\n\\n    fallback() external payable {\\n        address _impl = logic;\\n        assembly {\\n            let ptr := mload(0x40)\\n            calldatacopy(ptr, 0, calldatasize())\\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\\n            let size := returndatasize()\\n            returndatacopy(ptr, 0, size)\\n\\n            switch result\\n                case 0 {\\n                    revert(ptr, size)\\n                }\\n                default {\\n                    return(ptr, size)\\n                }\\n        }\\n    }\\n\\n    // ======== Receive =========\\n\\n    receive() external payable {} // solhint-disable-line no-empty-blocks\\n}\\n\"\r\n    },\r\n    \"contracts/PartyBid.sol\": {\r\n      \"content\": \"/*\\n\\n      ___           ___           ___           ___           ___           ___                       ___\\n     /\\\\  \\\\         /\\\\  \\\\         /\\\\  \\\\         /\\\\  \\\\         |\\\\__\\\\         /\\\\  \\\\          ___        /\\\\  \\\\\\n    /::\\\\  \\\\       /::\\\\  \\\\       /::\\\\  \\\\        \\\\:\\\\  \\\\        |:|  |       /::\\\\  \\\\        /\\\\  \\\\      /::\\\\  \\\\\\n   /:/\\\\:\\\\  \\\\     /:/\\\\:\\\\  \\\\     /:/\\\\:\\\\  \\\\        \\\\:\\\\  \\\\       |:|  |      /:/\\\\:\\\\  \\\\       \\\\:\\\\  \\\\    /:/\\\\:\\\\  \\\\\\n  /::\\\\~\\\\:\\\\  \\\\   /::\\\\~\\\\:\\\\  \\\\   /::\\\\~\\\\:\\\\  \\\\       /::\\\\  \\\\      |:|__|__   /::\\\\~\\\\:\\\\__\\\\      /::\\\\__\\\\  /:/  \\\\:\\\\__\\\\\\n /:/\\\\:\\\\ \\\\:\\\\__\\\\ /:/\\\\:\\\\ \\\\:\\\\__\\\\ /:/\\\\:\\\\ \\\\:\\\\__\\\\     /:/\\\\:\\\\__\\\\     /::::\\\\__\\\\ /:/\\\\:\\\\ \\\\:|__|  __/:/\\\\/__/ /:/__/ \\\\:|__|\\n \\\\/__\\\\:\\\\/:/  / \\\\/__\\\\:\\\\/:/  / \\\\/_|::\\\\/:/  /    /:/  \\\\/__/    /:/~~/~    \\\\:\\\\~\\\\:\\\\/:/  / /\\\\/:/  /    \\\\:\\\\  \\\\ /:/  /\\n      \\\\::/  /       \\\\::/  /     |:|::/  /    /:/  /        /:/  /       \\\\:\\\\ \\\\::/  /  \\\\::/__/      \\\\:\\\\  /:/  /\\n       \\\\/__/        /:/  /      |:|\\\\/__/     \\\\/__/         \\\\/__/         \\\\:\\\\/:/  /    \\\\:\\\\__\\\\       \\\\:\\\\/:/  /\\n                   /:/  /       |:|  |                                    \\\\::/__/      \\\\/__/        \\\\::/__/\\n                   \\\\/__/         \\\\|__|                                     ~~                        ~~\\n\\nPartyBid v1\\nAnna Carroll for PartyDAO\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\n// ============ External Imports: Inherited Contracts ============\\n// NOTE: we inherit from OpenZeppelin upgradeable contracts\\n// because of the proxy structure used for cheaper deploys\\n// (the proxies are NOT actually upgradeable)\\nimport {\\n    ReentrancyGuardUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport {\\n    ERC721HolderUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\\\";\\n// ============ External Imports: External Contracts & Contract Interfaces ============\\nimport {\\n    IERC721VaultFactory\\n} from \\\"./external/interfaces/IERC721VaultFactory.sol\\\";\\nimport {ITokenVault} from \\\"./external/interfaces/ITokenVault.sol\\\";\\nimport {\\n    IERC721Metadata\\n} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport {IWETH} from \\\"./external/interfaces/IWETH.sol\\\";\\n\\n// ============ Internal Imports ============\\nimport {IMarketWrapper} from \\\"./market-wrapper/IMarketWrapper.sol\\\";\\n\\ncontract PartyBid is ReentrancyGuardUpgradeable, ERC721HolderUpgradeable {\\n    // ============ Enums ============\\n\\n    // State Transitions:\\n    //   (1) AUCTION_ACTIVE on deploy\\n    //   (2) AUCTION_WON or AUCTION_LOST on finalize()\\n    enum PartyStatus {AUCTION_ACTIVE, AUCTION_WON, AUCTION_LOST}\\n\\n    // ============ Structs ============\\n\\n    struct Contribution {\\n        uint256 amount;\\n        uint256 previousTotalContributedToParty;\\n    }\\n\\n    // ============ Internal Constants ============\\n\\n    // tokens are minted at a rate of 1 ETH : 1000 tokens\\n    uint16 internal constant TOKEN_SCALE = 1000;\\n    // PartyBid pays a 5% fee to PartyDAO\\n    uint8 internal constant FEE_PERCENT = 5;\\n\\n    // ============ Immutables ============\\n\\n    address public immutable partyDAOMultisig;\\n    address public immutable tokenVaultFactory;\\n    address public immutable weth;\\n\\n    // ============ Public Not-Mutated Storage ============\\n\\n    // market wrapper contract exposing interface for\\n    // market auctioning the NFT\\n    address public marketWrapper;\\n    // NFT contract\\n    address public nftContract;\\n    // Fractionalized NFT vault responsible for post-auction value capture\\n    address public tokenVault;\\n    // ID of auction within market contract\\n    uint256 public auctionId;\\n    // ID of token within NFT contract\\n    uint256 public tokenId;\\n    // ERC-20 name and symbol for fractional tokens\\n    string public name;\\n    string public symbol;\\n\\n    // ============ Public Mutable Storage ============\\n\\n    // state of the contract\\n    PartyStatus public partyStatus;\\n    // total ETH deposited by all contributors\\n    uint256 public totalContributedToParty;\\n    // the highest bid submitted by PartyBid\\n    uint256 public highestBid;\\n    // the total spent by PartyBid on the auction;\\n    // 0 if the NFT is lost; highest bid + 5% PartyDAO fee if NFT is won\\n    uint256 public totalSpent;\\n    // contributor => array of Contributions\\n    mapping(address => Contribution[]) public contributions;\\n    // contributor => total amount contributed\\n    mapping(address => uint256) public totalContributed;\\n    // contributor => true if contribution has been claimed\\n    mapping(address => bool) public claimed;\\n\\n    // ============ Events ============\\n\\n    event Contributed(\\n        address indexed contributor,\\n        uint256 amount,\\n        uint256 previousTotalContributedToParty,\\n        uint256 totalFromContributor\\n    );\\n\\n    event Bid(uint256 amount);\\n\\n    event Finalized(PartyStatus result, uint256 totalSpent, uint256 fee, uint256 totalContributed);\\n\\n    event Claimed(\\n        address indexed contributor,\\n        uint256 totalContributed,\\n        uint256 excessContribution,\\n        uint256 tokenAmount\\n    );\\n\\n    // ======== Constructor =========\\n\\n    constructor(\\n        address _partyDAOMultisig,\\n        address _tokenVaultFactory,\\n        address _weth\\n    ) {\\n        partyDAOMultisig = _partyDAOMultisig;\\n        tokenVaultFactory = _tokenVaultFactory;\\n        weth = _weth;\\n    }\\n\\n    // ======== Initializer =========\\n\\n    function initialize(\\n        address _marketWrapper,\\n        address _nftContract,\\n        uint256 _tokenId,\\n        uint256 _auctionId,\\n        string memory _name,\\n        string memory _symbol\\n    ) external initializer {\\n        // initialize ReentrancyGuard and ERC721Holder\\n        __ReentrancyGuard_init();\\n        __ERC721Holder_init();\\n        // set storage variables\\n        marketWrapper = _marketWrapper;\\n        nftContract = _nftContract;\\n        tokenId = _tokenId;\\n        auctionId = _auctionId;\\n        name = _name;\\n        symbol = _symbol;\\n        // validate token exists (ownerOf should revert if token doesn't exist)\\n        IERC721Metadata(_nftContract).ownerOf(_tokenId);\\n        // validate auction exists\\n        require(\\n            IMarketWrapper(_marketWrapper).auctionIdMatchesToken(\\n                _auctionId,\\n                _nftContract,\\n                _tokenId\\n            ),\\n            \\\"PartyBid::initialize: auctionId doesn't match token\\\"\\n        );\\n    }\\n\\n    // ======== External: Contribute =========\\n\\n    /**\\n     * @notice Contribute to the PartyBid's treasury\\n     * while the auction is still open\\n     * @dev Emits a Contributed event upon success; callable by anyone\\n     */\\n    function contribute() external payable nonReentrant {\\n        require(\\n            partyStatus == PartyStatus.AUCTION_ACTIVE,\\n            \\\"PartyBid::contribute: auction not active\\\"\\n        );\\n        address _contributor = msg.sender;\\n        uint256 _amount = msg.value;\\n        // get the current contract balance\\n        uint256 _previousTotalContributedToParty = totalContributedToParty;\\n        // add contribution to contributor's array of contributions\\n        Contribution memory _contribution =\\n            Contribution({\\n                amount: _amount,\\n                previousTotalContributedToParty: _previousTotalContributedToParty\\n            });\\n        contributions[_contributor].push(_contribution);\\n        // add to contributor's total contribution\\n        totalContributed[_contributor] =\\n            totalContributed[_contributor] +\\n            _amount;\\n        // add to party's total contribution & emit event\\n        totalContributedToParty = totalContributedToParty + _amount;\\n        emit Contributed(\\n            _contributor,\\n            _amount,\\n            _previousTotalContributedToParty,\\n            totalContributed[_contributor]\\n        );\\n    }\\n\\n    // ======== External: Bid =========\\n\\n    /**\\n     * @notice Submit a bid to the Market\\n     * @dev Reverts if insufficient funds to place the bid and pay PartyDAO fees,\\n     * or if any external auction checks fail (including if PartyBid is current high bidder)\\n     * Emits a Bid event upon success.\\n     * Callable by any contributor\\n     */\\n    function bid() external nonReentrant {\\n        require(\\n            partyStatus == PartyStatus.AUCTION_ACTIVE,\\n            \\\"PartyBid::bid: auction not active\\\"\\n        );\\n        require(\\n            totalContributed[msg.sender] > 0,\\n            \\\"PartyBid::bid: only contributors can bid\\\"\\n        );\\n        require(\\n            address(this) !=\\n                IMarketWrapper(marketWrapper).getCurrentHighestBidder(\\n                    auctionId\\n                ),\\n            \\\"PartyBid::bid: already highest bidder\\\"\\n        );\\n        require(\\n            !IMarketWrapper(marketWrapper).isFinalized(auctionId),\\n            \\\"PartyBid::bid: auction already finalized\\\"\\n        );\\n        // get the minimum next bid for the auction\\n        uint256 _bid = IMarketWrapper(marketWrapper).getMinimumBid(auctionId);\\n        // ensure there is enough ETH to place the bid including PartyDAO fee\\n        require(\\n            _bid <= _getMaximumBid(),\\n            \\\"PartyBid::bid: insufficient funds to bid\\\"\\n        );\\n        // submit bid to Auction contract using delegatecall\\n        (bool success, bytes memory returnData) =\\n            marketWrapper.delegatecall(\\n                abi.encodeWithSignature(\\\"bid(uint256,uint256)\\\", auctionId, _bid)\\n            );\\n        require(\\n            success,\\n            string(\\n                abi.encodePacked(\\n                    \\\"PartyBid::bid: place bid failed: \\\",\\n                    returnData\\n                )\\n            )\\n        );\\n        // update highest bid submitted & emit success event\\n        highestBid = _bid;\\n        emit Bid(_bid);\\n    }\\n\\n    // ======== External: Finalize =========\\n\\n    /**\\n     * @notice Finalize the state of the auction\\n     * @dev Emits a Finalized event upon success; callable by anyone\\n     */\\n    function finalize() external nonReentrant {\\n        require(\\n            partyStatus == PartyStatus.AUCTION_ACTIVE,\\n            \\\"PartyBid::finalize: auction not active\\\"\\n        );\\n        // finalize auction if it hasn't already been done\\n        if (!IMarketWrapper(marketWrapper).isFinalized(auctionId)) {\\n            IMarketWrapper(marketWrapper).finalize(auctionId);\\n        }\\n        // after the auction has been finalized,\\n        // if the NFT is owned by the PartyBid, then the PartyBid won the auction\\n        partyStatus = IERC721Metadata(nftContract).ownerOf(tokenId) ==\\n            address(this)\\n            ? PartyStatus.AUCTION_WON\\n            : PartyStatus.AUCTION_LOST;\\n        uint256 _fee;\\n        // if the auction was won,\\n        if (partyStatus == PartyStatus.AUCTION_WON) {\\n            // transfer 5% fee to PartyDAO\\n            _fee = _getFee(highestBid);\\n            _transferETHOrWETH(partyDAOMultisig, _fee);\\n            // record total spent by auction + PartyDAO fees\\n            totalSpent = highestBid + _fee;\\n            // deploy fractionalized NFT vault\\n            // and mint fractional ERC-20 tokens\\n            _fractionalizeNFT(totalSpent);\\n        }\\n        // set the contract status & emit result\\n        emit Finalized(partyStatus, totalSpent, _fee, totalContributedToParty);\\n    }\\n\\n    // ======== External: Claim =========\\n\\n    /**\\n     * @notice Claim the tokens and excess ETH owed\\n     * to a single contributor after the auction has ended\\n     * @dev Emits a Claimed event upon success\\n     * callable by anyone (doesn't have to be the contributor)\\n     * @param _contributor the address of the contributor\\n     */\\n    function claim(address _contributor) external nonReentrant {\\n        // ensure auction has finalized\\n        require(\\n            partyStatus != PartyStatus.AUCTION_ACTIVE,\\n            \\\"PartyBid::claim: auction not finalized\\\"\\n        );\\n        // ensure contributor submitted some ETH\\n        require(\\n            totalContributed[_contributor] != 0,\\n            \\\"PartyBid::claim: not a contributor\\\"\\n        );\\n        // ensure the contributor hasn't already claimed\\n        require(\\n            !claimed[_contributor],\\n            \\\"PartyBid::claim: contribution already claimed\\\"\\n        );\\n        // mark the contribution as claimed\\n        claimed[_contributor] = true;\\n        // calculate the amount of fractional NFT tokens owed to the user\\n        // based on how much ETH they contributed towards the auction,\\n        // and the amount of excess ETH owed to the user\\n        (uint256 _tokenAmount, uint256 _ethAmount) =\\n            _calculateTokensAndETHOwed(_contributor);\\n        // transfer tokens to contributor for their portion of ETH used\\n        if (_tokenAmount > 0) {\\n            ITokenVault(tokenVault).transfer(_contributor, _tokenAmount);\\n        }\\n        // if there is excess ETH, send it back to the contributor\\n        if (_ethAmount > 0) {\\n            _transferETHOrWETH(_contributor, _ethAmount);\\n        }\\n        emit Claimed(\\n            _contributor,\\n            totalContributed[_contributor],\\n            _ethAmount,\\n            _tokenAmount\\n        );\\n    }\\n\\n    // ======== External: Recover =========\\n\\n    /**\\n     * @notice If the NFT gets stuck in the PartyBid\\n     * (e.g. because of a faulty MarketWrapper that marks the auction Lost)\\n     * the PartyDAO Multisig can transfer the NFT to the multisig\\n     */\\n    function recover() external {\\n        require(\\n            msg.sender == partyDAOMultisig,\\n            \\\"PartyBid::recover: only PartyDAO multisig can recover NFT\\\"\\n        );\\n        require(\\n            partyStatus == PartyStatus.AUCTION_LOST,\\n            \\\"PartyBid::recover: auction must be lost to recover NFT\\\"\\n        );\\n        IERC721Metadata(nftContract).transferFrom(\\n            address(this),\\n            partyDAOMultisig,\\n            tokenId\\n        );\\n    }\\n\\n    // ======== Public: Utility Calculations =========\\n\\n    /**\\n     * @notice Convert ETH value to equivalent token amount\\n     */\\n    function valueToTokens(uint256 _value)\\n        public\\n        pure\\n        returns (uint256 _tokens)\\n    {\\n        _tokens = _value * TOKEN_SCALE;\\n    }\\n\\n    // ============ Internal: Bid ============\\n\\n    /**\\n     * @notice The maximum bid that can be submitted\\n     * while leaving 5% fee for PartyDAO\\n     * @return _maxBid the maximum bid\\n     */\\n    function _getMaximumBid() internal view returns (uint256 _maxBid) {\\n        _maxBid = totalContributedToParty - _getFee(totalContributedToParty);\\n    }\\n\\n    /**\\n     * @notice Calculate 5% fee for PartyDAO\\n     * NOTE: Remove this fee causes a critical vulnerability\\n     * allowing anyone to exploit a PartyBid via price manipulation.\\n     * See Security Review in README for more info.\\n     * @return _fee 5% of the given amount\\n     */\\n    function _getFee(uint256 _amount) internal pure returns (uint256 _fee) {\\n        _fee = (_amount * FEE_PERCENT) / 100;\\n    }\\n\\n    // ============ Internal: Finalize ============\\n\\n    /**\\n     * @notice Upon winning the auction, transfer the NFT\\n     * to fractional.art vault & mint fractional ERC-20 tokens\\n     */\\n    function _fractionalizeNFT(uint256 _totalSpent) internal {\\n        // approve fractionalized NFT Factory to withdraw NFT\\n        IERC721Metadata(nftContract).approve(tokenVaultFactory, tokenId);\\n        // deploy fractionalized NFT vault\\n        uint256 vaultNumber =\\n            IERC721VaultFactory(tokenVaultFactory).mint(\\n                name,\\n                symbol,\\n                nftContract,\\n                tokenId,\\n                valueToTokens(_totalSpent),\\n                _totalSpent,\\n                0\\n            );\\n        // store token vault address to storage\\n        tokenVault = IERC721VaultFactory(tokenVaultFactory).vaults(vaultNumber);\\n        // transfer curator to null address\\n        ITokenVault(tokenVault).updateCurator(address(0));\\n    }\\n\\n    // ============ Internal: Claim ============\\n\\n    /**\\n     * @notice Calculate the amount of fractional NFT tokens owed to the contributor\\n     * based on how much ETH they contributed towards the auction,\\n     * and the amount of excess ETH owed to the contributor\\n     * based on how much ETH they contributed *not* used towards the auction\\n     * @param _contributor the address of the contributor\\n     * @return _tokenAmount the amount of fractional NFT tokens owed to the contributor\\n     * @return _ethAmount the amount of excess ETH owed to the contributor\\n     */\\n    function _calculateTokensAndETHOwed(address _contributor)\\n        internal\\n        view\\n        returns (uint256 _tokenAmount, uint256 _ethAmount)\\n    {\\n        uint256 _totalContributed = totalContributed[_contributor];\\n        if (partyStatus == PartyStatus.AUCTION_WON) {\\n            // calculate the amount of this contributor's ETH\\n            // that was used for the winning bid\\n            uint256 _totalUsedForBid = _totalEthUsedForBid(_contributor);\\n            if (_totalUsedForBid > 0) {\\n                _tokenAmount = valueToTokens(_totalUsedForBid);\\n                // guard against rounding errors;\\n                // if _tokenAmount to send is greater than contract balance,\\n                // send full contract balance\\n                uint256 _totalBalance =\\n                    ITokenVault(tokenVault).balanceOf(address(this));\\n                if (_tokenAmount > _totalBalance) {\\n                    _tokenAmount = _totalBalance;\\n                }\\n            }\\n            // the rest of the contributor's ETH should be returned\\n            _ethAmount = _totalContributed - _totalUsedForBid;\\n        } else {\\n            // if the auction was lost, no ETH was spent;\\n            // all of the contributor's ETH should be returned\\n            _ethAmount = _totalContributed;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate the total amount of a contributor's funds that were\\n     * used towards the winning auction bid\\n     * @param _contributor the address of the contributor\\n     * @return _total the sum of the contributor's funds that were\\n     * used towards the winning auction bid\\n     */\\n    function _totalEthUsedForBid(address _contributor)\\n        internal\\n        view\\n        returns (uint256 _total)\\n    {\\n        // get all of the contributor's contributions\\n        Contribution[] memory _contributions = contributions[_contributor];\\n        for (uint256 i = 0; i < _contributions.length; i++) {\\n            // calculate how much was used from this individual contribution\\n            uint256 _amount = _ethUsedForBid(_contributions[i]);\\n            // if we reach a contribution that was not used,\\n            // no subsequent contributions will have been used either,\\n            // so we can stop calculating to save some gas\\n            if (_amount == 0) break;\\n            _total = _total + _amount;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate the amount that was used towards\\n     * the winning auction bid from a single Contribution\\n     * @param _contribution the Contribution struct\\n     * @return the amount of funds from this contribution\\n     * that were used towards the winning auction bid\\n     */\\n    function _ethUsedForBid(Contribution memory _contribution)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        // load total amount spent once from storage\\n        uint256 _totalSpent = totalSpent;\\n        if (\\n            _contribution.previousTotalContributedToParty +\\n                _contribution.amount <=\\n            _totalSpent\\n        ) {\\n            // contribution was fully used\\n            return _contribution.amount;\\n        } else if (\\n            _contribution.previousTotalContributedToParty < _totalSpent\\n        ) {\\n            // contribution was partially used\\n            return _totalSpent - _contribution.previousTotalContributedToParty;\\n        }\\n        // contribution was not used\\n        return 0;\\n    }\\n\\n    // ============ Internal: TransferEthOrWeth ============\\n\\n    /**\\n     * @notice Attempt to transfer ETH to a recipient;\\n     * if transferring ETH fails, transfer WETH insteads\\n     * @param _to recipient of ETH or WETH\\n     * @param _value amount of ETH or WETH\\n     */\\n    function _transferETHOrWETH(address _to, uint256 _value) internal {\\n        // guard against rounding errors;\\n        // if ETH amount to send is greater than contract balance,\\n        // send full contract balance\\n        if (_value > address(this).balance) {\\n            _value = address(this).balance;\\n        }\\n        // Try to transfer ETH to the given recipient.\\n        if (!_attemptETHTransfer(_to, _value)) {\\n            // If the transfer fails, wrap and send as WETH\\n            IWETH(weth).deposit{value: _value}();\\n            IWETH(weth).transfer(_to, _value);\\n            // At this point, the recipient can unwrap WETH.\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempt to transfer ETH to a recipient\\n     * @dev Sending ETH is not guaranteed to succeed\\n     * this method will return false if it fails.\\n     * We will limit the gas used in transfers, and handle failure cases.\\n     * @param _to recipient of ETH\\n     * @param _value amount of ETH\\n     */\\n    function _attemptETHTransfer(address _to, uint256 _value)\\n        internal\\n        returns (bool)\\n    {\\n        // Here increase the gas limit a reasonable amount above the default, and try\\n        // to send ETH to the recipient.\\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\\n        (bool success, ) = _to.call{value: _value, gas: 30000}(\\\"\\\");\\n        return success;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal initializer {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal initializer {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n  /**\\n   * @dev Implementation of the {IERC721Receiver} interface.\\n   *\\n   * Accepts all token transfers.\\n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n   */\\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\\n    function __ERC721Holder_init() internal initializer {\\n        __ERC721Holder_init_unchained();\\n    }\\n\\n    function __ERC721Holder_init_unchained() internal initializer {\\n    }\\n\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/external/interfaces/IERC721VaultFactory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\ninterface IERC721VaultFactory {\\n    /// @notice the mapping of vault number to vault address\\n    function vaults(uint256) external returns (address);\\n\\n    /// @notice the function to mint a new vault\\n    /// @param _name the desired name of the vault\\n    /// @param _symbol the desired sumbol of the vault\\n    /// @param _token the ERC721 token address fo the NFT\\n    /// @param _id the uint256 ID of the token\\n    /// @param _listPrice the initial price of the NFT\\n    /// @return the ID of the vault\\n    function mint(string memory _name, string memory _symbol, address _token, uint256 _id, uint256 _supply, uint256 _listPrice, uint256 _fee) external returns(uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/external/interfaces/ITokenVault.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\ninterface ITokenVault {\\n    /// @notice allow curator to update the curator address\\n    /// @param _curator the new curator\\n    function updateCurator(address _curator) external;\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/external/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/market-wrapper/IMarketWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\n/**\\n * @title IMarketWrapper\\n * @author Anna Carroll\\n * @notice IMarketWrapper provides a common interface for\\n * interacting with NFT auction markets.\\n * Contracts can abstract their interactions with\\n * different NFT markets using IMarketWrapper.\\n * NFT markets can become compatible with any contract\\n * using IMarketWrapper by deploying a MarketWrapper contract\\n * that implements this interface using the logic of their Market.\\n *\\n * WARNING: MarketWrapper contracts should NEVER write to storage!\\n * When implementing a MarketWrapper, exercise caution; a poorly implemented\\n * MarketWrapper contract could permanently lose access to the NFT or user funds.\\n */\\ninterface IMarketWrapper {\\n    /**\\n     * @notice Determine whether there is an existing auction\\n     * for this token on the underlying market\\n     * @return TRUE if the auction exists\\n     */\\n    function auctionExists(uint256 auctionId) external view returns (bool);\\n\\n    /**\\n     * @notice Determine whether the given auctionId is\\n     * an auction for the tokenId + nftContract\\n     * @return TRUE if the auctionId matches the tokenId + nftContract\\n     */\\n    function auctionIdMatchesToken(\\n        uint256 auctionId,\\n        address nftContract,\\n        uint256 tokenId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Calculate the minimum next bid for this auction\\n     * @return minimum bid amount\\n     */\\n    function getMinimumBid(uint256 auctionId) external view returns (uint256);\\n\\n    /**\\n     * @notice Query the current highest bidder for this auction\\n     * @return highest bidder\\n     */\\n    function getCurrentHighestBidder(uint256 auctionId)\\n        external\\n        view\\n        returns (address);\\n\\n    /**\\n     * @notice Submit bid to Market contract\\n     */\\n    function bid(uint256 auctionId, uint256 bidAmount) external;\\n\\n    /**\\n     * @notice Determine whether the auction has been finalized\\n     * @return TRUE if the auction has been finalized\\n     */\\n    function isFinalized(uint256 auctionId) external view returns (bool);\\n\\n    /**\\n     * @notice Finalize the results of the auction\\n     */\\n    function finalize(uint256 auctionId) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partyDAOMultisig\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenVaultFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"partyBidProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketWrapper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"PartyBidDeployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"logic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partyDAOMultisig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketWrapper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_auctionId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"startParty\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"partyBidProxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenVaultFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PartyBidFactory","CompilerVersion":"v0.8.5+commit.a4f2e591","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000f7f52dd34bc21eda08c0b804c7c1dbc48375820f00000000000000000000000085aa7f78bdb2de8f3e0c0010d99ad5853ffcfc63000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}