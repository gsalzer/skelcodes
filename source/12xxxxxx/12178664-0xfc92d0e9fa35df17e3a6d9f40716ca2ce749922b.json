{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\n// File contracts/Interfaces/IPriceFeed.sol\r\n\r\npragma solidity 0.6.11;\r\n\r\ninterface IPriceFeed {\r\n\r\n    // --- Events ---\r\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\r\n   \r\n    // --- Function ---\r\n    function fetchPrice() external returns (uint);\r\n}\r\n\r\n\r\n// File contracts/Interfaces/ILiquityBase.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\ninterface ILiquityBase {\r\n    function priceFeed() external view returns (IPriceFeed);\r\n}\r\n\r\n\r\n// File contracts/Interfaces/IStabilityPool.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n/*\r\n * The Stability Pool holds LUSD tokens deposited by Stability Pool depositors.\r\n *\r\n * When a trove is liquidated, then depending on system conditions, some of its LUSD debt gets offset with\r\n * LUSD in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of LUSD tokens in the Stability Pool is burned.\r\n *\r\n * Thus, a liquidation causes each depositor to receive a LUSD loss, in proportion to their deposit as a share of total deposits.\r\n * They also receive an ETH gain, as the ETH collateral of the liquidated trove is distributed among Stability depositors,\r\n * in the same proportion.\r\n *\r\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\r\n * of the total LUSD in the Stability Pool, depletes 40% of each deposit.\r\n *\r\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\r\n * multiplying it by some factor in range ]0,1[\r\n *\r\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / ETH gain derivations:\r\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\r\n *\r\n * --- LQTY ISSUANCE TO STABILITY POOL DEPOSITORS ---\r\n *\r\n * An LQTY issuance event occurs at every deposit operation, and every liquidation.\r\n *\r\n * Each deposit is tagged with the address of the front end through which it was made.\r\n *\r\n * All deposits earn a share of the issued LQTY in proportion to the deposit as a share of total deposits. The LQTY earned\r\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\r\n *\r\n * Please see the system Readme for an overview:\r\n * https://github.com/liquity/dev/blob/main/README.md#lqty-issuance-to-stability-providers\r\n */\r\ninterface IStabilityPool {\r\n\r\n    // --- Events ---\r\n    \r\n    event StabilityPoolETHBalanceUpdated(uint _newBalance);\r\n    event StabilityPoolLUSDBalanceUpdated(uint _newBalance);\r\n\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\r\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\r\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\r\n\r\n    event P_Updated(uint _P);\r\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\r\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\r\n    event EpochUpdated(uint128 _currentEpoch);\r\n    event ScaleUpdated(uint128 _currentScale);\r\n\r\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\r\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\r\n\r\n    event DepositSnapshotUpdated(address indexed _depositor, uint _P, uint _S, uint _G);\r\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\r\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\r\n    event FrontEndStakeChanged(address indexed _frontEnd, uint _newFrontEndStake, address _depositor);\r\n\r\n    event ETHGainWithdrawn(address indexed _depositor, uint _ETH, uint _LUSDLoss);\r\n    event LQTYPaidToDepositor(address indexed _depositor, uint _LQTY);\r\n    event LQTYPaidToFrontEnd(address indexed _frontEnd, uint _LQTY);\r\n    event EtherSent(address _to, uint _amount);\r\n\r\n    // --- Functions ---\r\n\r\n    /*\r\n     * Called only once on init, to set addresses of other Liquity contracts\r\n     * Callable only by owner, renounces ownership at the end\r\n     */\r\n    function setAddresses(\r\n        address _borrowerOperationsAddress,\r\n        address _troveManagerAddress,\r\n        address _activePoolAddress,\r\n        address _lusdTokenAddress,\r\n        address _sortedTrovesAddress,\r\n        address _priceFeedAddress,\r\n        address _communityIssuanceAddress\r\n    ) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Frontend is registered or zero address\r\n     * - Sender is not a registered frontend\r\n     * - _amount is not zero\r\n     * ---\r\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\r\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\r\n     * - Sends depositor's accumulated gains (LQTY, ETH) to depositor\r\n     * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\r\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\r\n     */\r\n    function provideToSP(uint _amount, address _frontEndTag) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - _amount is zero or there are no under collateralized troves left in the system\r\n     * - User has a non zero deposit\r\n     * ---\r\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\r\n     * - Removes the deposit's front end tag if it is a full withdrawal\r\n     * - Sends all depositor's accumulated gains (LQTY, ETH) to depositor\r\n     * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\r\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\r\n     *\r\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\r\n     */\r\n    function withdrawFromSP(uint _amount) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - User has a non zero deposit\r\n     * - User has an open trove\r\n     * - User has some ETH gain\r\n     * ---\r\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\r\n     * - Sends all depositor's LQTY gain to  depositor\r\n     * - Sends all tagged front end's LQTY gain to the tagged front end\r\n     * - Transfers the depositor's entire ETH gain from the Stability Pool to the caller's trove\r\n     * - Leaves their compounded deposit in the Stability Pool\r\n     * - Updates snapshots for deposit and tagged front end stake\r\n     */\r\n    function withdrawETHGainToTrove(address _upperHint, address _lowerHint) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Frontend (sender) not already registered\r\n     * - User (sender) has no deposit\r\n     * - _kickbackRate is in the range [0, 100%]\r\n     * ---\r\n     * Front end makes a one-time selection of kickback rate upon registering\r\n     */\r\n    function registerFrontEnd(uint _kickbackRate) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Caller is TroveManager\r\n     * ---\r\n     * Cancels out the specified debt against the LUSD contained in the Stability Pool (as far as possible)\r\n     * and transfers the Trove's ETH collateral from ActivePool to StabilityPool.\r\n     * Only called by liquidation functions in the TroveManager.\r\n     */\r\n    function offset(uint _debt, uint _coll) external;\r\n\r\n    /*\r\n     * Returns the total amount of ETH held by the pool, accounted in an internal variable instead of `balance`,\r\n     * to exclude edge cases like ETH received from a self-destruct.\r\n     */\r\n    function getETH() external view returns (uint);\r\n\r\n    /*\r\n     * Returns LUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\r\n     */\r\n    function getTotalLUSDDeposits() external view returns (uint);\r\n\r\n    /*\r\n     * Calculates the ETH gain earned by the deposit since its last snapshots were taken.\r\n     */\r\n    function getDepositorETHGain(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Calculate the LQTY gain earned by a deposit since its last snapshots were taken.\r\n     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\r\n     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\r\n     * which they made their deposit.\r\n     */\r\n    function getDepositorLQTYGain(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Return the LQTY gain earned by the front end.\r\n     */\r\n    function getFrontEndLQTYGain(address _frontEnd) external view returns (uint);\r\n\r\n    /*\r\n     * Return the user's compounded deposit.\r\n     */\r\n    function getCompoundedLUSDDeposit(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Return the front end's compounded stake.\r\n     *\r\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\r\n     */\r\n    function getCompoundedFrontEndStake(address _frontEnd) external view returns (uint);\r\n\r\n    /*\r\n     * Fallback function\r\n     * Only callable by Active Pool, it just accounts for ETH received\r\n     * receive() external payable;\r\n     */\r\n}\r\n\r\n\r\n// File contracts/Dependencies/IERC20.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n/**\r\n * Based on the OpenZeppelin IER20 interface:\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\r\n *\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    \r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/Dependencies/IERC2612.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n/**\r\n * @dev Interface of the ERC2612 standard as defined in the EIP.\r\n *\r\n * Adds the {permit} method, which can be used to change one's\r\n * {IERC20-allowance} without having to send a transaction, by signing a\r\n * message. This allows users to spend tokens without having to hold Ether.\r\n *\r\n * See https://eips.ethereum.org/EIPS/eip-2612.\r\n * \r\n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\r\n */\r\ninterface IERC2612 {\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\r\n     * given `owner`'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(address owner, address spender, uint256 amount, \r\n                    uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    \r\n    /**\r\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     *\r\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to \r\n     * a value in the near future. The deadline argument can be set to uint(-1) to \r\n     * create Permits that effectively never expire.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n    \r\n    function version() external view returns (string memory);\r\n    function permitTypeHash() external view returns (bytes32);\r\n    function domainSeparator() external view returns (bytes32);\r\n}\r\n\r\n\r\n// File contracts/Interfaces/ILUSDToken.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n\r\ninterface ILUSDToken is IERC20, IERC2612 { \r\n    \r\n    // --- Events ---\r\n\r\n    event TroveManagerAddressChanged(address _troveManagerAddress);\r\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n\r\n    event LUSDTokenBalanceUpdated(address _user, uint _amount);\r\n\r\n    // --- Functions ---\r\n\r\n    function mint(address _account, uint256 _amount) external;\r\n\r\n    function burn(address _account, uint256 _amount) external;\r\n\r\n    function sendToPool(address _sender,  address poolAddress, uint256 _amount) external;\r\n\r\n    function returnFromPool(address poolAddress, address user, uint256 _amount ) external;\r\n}\r\n\r\n\r\n// File contracts/Interfaces/ILQTYToken.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n\r\ninterface ILQTYToken is IERC20, IERC2612 { \r\n   \r\n    // --- Events ---\r\n    \r\n    event CommunityIssuanceAddressSet(address _communityIssuanceAddress);\r\n    event LQTYStakingAddressSet(address _lqtyStakingAddress);\r\n    event LockupContractFactoryAddressSet(address _lockupContractFactoryAddress);\r\n\r\n    // --- Functions ---\r\n    \r\n    function sendToLQTYStaking(address _sender, uint256 _amount) external;\r\n\r\n    function getDeploymentStartTime() external view returns (uint256);\r\n\r\n    function getLpRewardsEntitlement() external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/Interfaces/ILQTYStaking.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\ninterface ILQTYStaking {\r\n\r\n    // --- Events --\r\n    \r\n    event LQTYTokenAddressSet(address _lqtyTokenAddress);\r\n    event LUSDTokenAddressSet(address _lusdTokenAddress);\r\n    event TroveManagerAddressSet(address _troveManager);\r\n    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);\r\n    event ActivePoolAddressSet(address _activePoolAddress);\r\n\r\n    event StakeChanged(address indexed staker, uint newStake);\r\n    event StakingGainsWithdrawn(address indexed staker, uint LUSDGain, uint ETHGain);\r\n    event F_ETHUpdated(uint _F_ETH);\r\n    event F_LUSDUpdated(uint _F_LUSD);\r\n    event TotalLQTYStakedUpdated(uint _totalLQTYStaked);\r\n    event EtherSent(address _account, uint _amount);\r\n    event StakerSnapshotsUpdated(address _staker, uint _F_ETH, uint _F_LUSD);\r\n\r\n    // --- Functions ---\r\n\r\n    function setAddresses\r\n    (\r\n        address _lqtyTokenAddress,\r\n        address _lusdTokenAddress,\r\n        address _troveManagerAddress, \r\n        address _borrowerOperationsAddress,\r\n        address _activePoolAddress\r\n    )  external;\r\n\r\n    function stake(uint _LQTYamount) external;\r\n\r\n    function unstake(uint _LQTYamount) external;\r\n\r\n    function increaseF_ETH(uint _ETHFee) external; \r\n\r\n    function increaseF_LUSD(uint _LQTYFee) external;  \r\n\r\n    function getPendingETHGain(address _user) external view returns (uint);\r\n\r\n    function getPendingLUSDGain(address _user) external view returns (uint);\r\n}\r\n\r\n\r\n// File contracts/Interfaces/ITroveManager.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n\r\n\r\n\r\n\r\n// Common interface for the Trove Manager.\r\ninterface ITroveManager is ILiquityBase {\r\n    \r\n    // --- Events ---\r\n\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\r\n    event ActivePoolAddressChanged(address _activePoolAddress);\r\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\r\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\r\n    event GasPoolAddressChanged(address _gasPoolAddress);\r\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\r\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\r\n    event LQTYTokenAddressChanged(address _lqtyTokenAddress);\r\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\r\n\r\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\r\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\r\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\r\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, uint8 operation);\r\n    event BaseRateUpdated(uint _baseRate);\r\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\r\n    event TotalStakesUpdated(uint _newTotalStakes);\r\n    event SystemSnapshotsUpdated(uint _totalStakesSnapshot, uint _totalCollateralSnapshot);\r\n    event LTermsUpdated(uint _L_ETH, uint _L_LUSDDebt);\r\n    event TroveSnapshotsUpdated(uint _L_ETH, uint _L_LUSDDebt);\r\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\r\n\r\n    // --- Functions ---\r\n\r\n    function setAddresses(\r\n        address _borrowerOperationsAddress,\r\n        address _activePoolAddress,\r\n        address _defaultPoolAddress,\r\n        address _stabilityPoolAddress,\r\n        address _gasPoolAddress,\r\n        address _collSurplusPoolAddress,\r\n        address _priceFeedAddress,\r\n        address _lusdTokenAddress,\r\n        address _sortedTrovesAddress,\r\n        address _lqtyTokenAddress,\r\n        address _lqtyStakingAddress\r\n    ) external;\r\n\r\n    function stabilityPool() external view returns (IStabilityPool);\r\n    function lusdToken() external view returns (ILUSDToken);\r\n    function lqtyToken() external view returns (ILQTYToken);\r\n    function lqtyStaking() external view returns (ILQTYStaking);\r\n\r\n    function getTroveOwnersCount() external view returns (uint);\r\n\r\n    function getTroveFromTroveOwnersArray(uint _index) external view returns (address);\r\n\r\n    function getNominalICR(address _borrower) external view returns (uint);\r\n    function getCurrentICR(address _borrower, uint _price) external view returns (uint);\r\n\r\n    function liquidate(address _borrower) external;\r\n\r\n    function liquidateTroves(uint _n) external;\r\n\r\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\r\n\r\n    function redeemCollateral(\r\n        uint _LUSDAmount,\r\n        address _firstRedemptionHint,\r\n        address _upperPartialRedemptionHint,\r\n        address _lowerPartialRedemptionHint,\r\n        uint _partialRedemptionHintNICR,\r\n        uint _maxIterations,\r\n        uint _maxFee\r\n    ) external; \r\n\r\n    function updateStakeAndTotalStakes(address _borrower) external returns (uint);\r\n\r\n    function updateTroveRewardSnapshots(address _borrower) external;\r\n\r\n    function addTroveOwnerToArray(address _borrower) external returns (uint index);\r\n\r\n    function applyPendingRewards(address _borrower) external;\r\n\r\n    function getPendingETHReward(address _borrower) external view returns (uint);\r\n\r\n    function getPendingLUSDDebtReward(address _borrower) external view returns (uint);\r\n\r\n     function hasPendingRewards(address _borrower) external view returns (bool);\r\n\r\n    function getEntireDebtAndColl(address _borrower) external view returns (\r\n        uint debt, \r\n        uint coll, \r\n        uint pendingLUSDDebtReward, \r\n        uint pendingETHReward\r\n    );\r\n\r\n    function closeTrove(address _borrower) external;\r\n\r\n    function removeStake(address _borrower) external;\r\n\r\n    function getRedemptionRate() external view returns (uint);\r\n    function getRedemptionRateWithDecay() external view returns (uint);\r\n\r\n    function getRedemptionFeeWithDecay(uint _ETHDrawn) external view returns (uint);\r\n\r\n    function getBorrowingRate() external view returns (uint);\r\n    function getBorrowingRateWithDecay() external view returns (uint);\r\n\r\n    function getBorrowingFee(uint LUSDDebt) external view returns (uint);\r\n    function getBorrowingFeeWithDecay(uint _LUSDDebt) external view returns (uint);\r\n\r\n    function decayBaseRateFromBorrowing() external;\r\n\r\n    function getTroveStatus(address _borrower) external view returns (uint);\r\n    \r\n    function getTroveStake(address _borrower) external view returns (uint);\r\n\r\n    function getTroveDebt(address _borrower) external view returns (uint);\r\n\r\n    function getTroveColl(address _borrower) external view returns (uint);\r\n\r\n    function setTroveStatus(address _borrower, uint num) external;\r\n\r\n    function increaseTroveColl(address _borrower, uint _collIncrease) external returns (uint);\r\n\r\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external returns (uint); \r\n\r\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external returns (uint); \r\n\r\n    function decreaseTroveDebt(address _borrower, uint _collDecrease) external returns (uint); \r\n\r\n    function getTCR(uint _price) external view returns (uint);\r\n\r\n    function checkRecoveryMode(uint _price) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/Interfaces/ICollSurplusPool.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n\r\ninterface ICollSurplusPool {\r\n\r\n    // --- Events ---\r\n    \r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n\r\n    event CollBalanceUpdated(address indexed _account, uint _newBalance);\r\n    event EtherSent(address _to, uint _amount);\r\n\r\n    // --- Contract setters ---\r\n\r\n    function setAddresses(\r\n        address _borrowerOperationsAddress,\r\n        address _troveManagerAddress,\r\n        address _activePoolAddress\r\n    ) external;\r\n\r\n    function getETH() external view returns (uint);\r\n\r\n    function getCollateral(address _account) external view returns (uint);\r\n\r\n    function accountSurplus(address _account, uint _amount) external;\r\n\r\n    function claimColl(address _account) external;\r\n}\r\n\r\n\r\n// File contracts/Interfaces/ISortedTroves.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n// Common interface for the SortedTroves Doubly Linked List.\r\ninterface ISortedTroves {\r\n\r\n    // --- Events ---\r\n    \r\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\r\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\r\n    event NodeAdded(address _id, uint _NICR);\r\n    event NodeRemoved(address _id);\r\n\r\n    // --- Functions ---\r\n    \r\n    function setParams(uint256 _size, address _TroveManagerAddress, address _borrowerOperationsAddress) external;\r\n\r\n    function insert(address _id, uint256 _ICR, address _prevId, address _nextId) external;\r\n\r\n    function remove(address _id) external;\r\n\r\n    function reInsert(address _id, uint256 _newICR, address _prevId, address _nextId) external;\r\n\r\n    function contains(address _id) external view returns (bool);\r\n\r\n    function isFull() external view returns (bool);\r\n\r\n    function isEmpty() external view returns (bool);\r\n\r\n    function getSize() external view returns (uint256);\r\n\r\n    function getMaxSize() external view returns (uint256);\r\n\r\n    function getFirst() external view returns (address);\r\n\r\n    function getLast() external view returns (address);\r\n\r\n    function getNext(address _id) external view returns (address);\r\n\r\n    function getPrev(address _id) external view returns (address);\r\n\r\n    function validInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (bool);\r\n\r\n    function findInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (address, address);\r\n}\r\n\r\n\r\n// File contracts/Dependencies/BaseMath.sol\r\n\r\npragma solidity 0.6.11;\r\n\r\n\r\ncontract BaseMath {\r\n    uint constant public DECIMAL_PRECISION = 1e18;\r\n}\r\n\r\n\r\n// File contracts/Dependencies/SafeMath.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n/**\r\n * Based on OpenZeppelin's SafeMath:\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\r\n *\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Dependencies/console.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n// Buidler's helper contract for console logging\r\nlibrary console {\r\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\r\n\r\n\tfunction log() internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log()\"));\r\n\t\tignored;\r\n\t}\tfunction logInt(int p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(int)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logUint(uint p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logString(string memory p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBool(bool p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logAddress(address p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes(bytes memory p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logByte(byte p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(byte)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes1(bytes1 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes1)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes2(bytes2 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes2)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes3(bytes3 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes3)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes4(bytes4 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes4)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes5(bytes5 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes5)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes6(bytes6 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes6)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes7(bytes7 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes7)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes8(bytes8 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes8)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes9(bytes9 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes9)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes10(bytes10 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes10)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes11(bytes11 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes11)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes12(bytes12 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes12)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes13(bytes13 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes13)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes14(bytes14 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes14)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes15(bytes15 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes15)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes16(bytes16 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes16)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes17(bytes17 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes17)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes18(bytes18 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes18)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes19(bytes19 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes19)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes20(bytes20 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes20)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes21(bytes21 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes21)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes22(bytes22 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes22)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes23(bytes23 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes23)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes24(bytes24 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes24)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes25(bytes25 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes25)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes26(bytes26 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes26)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes27(bytes27 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes27)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes28(bytes28 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes28)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes29(bytes29 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes29)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes30(bytes30 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes30)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes31(bytes31 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes31)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes32(bytes32 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes32)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n}\r\n\r\n\r\n// File contracts/Dependencies/LiquityMath.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n\r\nlibrary LiquityMath {\r\n    using SafeMath for uint;\r\n\r\n    uint internal constant DECIMAL_PRECISION = 1e18;\r\n\r\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\r\n     *\r\n     * - Making it “too high” could lead to overflows.\r\n     * - Making it “too low” could lead to an ICR equal to zero, due to truncation from Solidity floor division. \r\n     *\r\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 ETH,\r\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\r\n     *\r\n     */\r\n    uint internal constant NICR_PRECISION = 1e20;\r\n\r\n    function _min(uint _a, uint _b) internal pure returns (uint) {\r\n        return (_a < _b) ? _a : _b;\r\n    }\r\n\r\n    function _max(uint _a, uint _b) internal pure returns (uint) {\r\n        return (_a >= _b) ? _a : _b;\r\n    }\r\n\r\n    /* \r\n    * Multiply two decimal numbers and use normal rounding rules:\r\n    * -round product up if 19'th mantissa digit >= 5\r\n    * -round product down if 19'th mantissa digit < 5\r\n    *\r\n    * Used only inside the exponentiation, _decPow().\r\n    */\r\n    function decMul(uint x, uint y) internal pure returns (uint decProd) {\r\n        uint prod_xy = x.mul(y);\r\n\r\n        decProd = prod_xy.add(DECIMAL_PRECISION / 2).div(DECIMAL_PRECISION);\r\n    }\r\n\r\n    /* \r\n    * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\r\n    * \r\n    * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity. \r\n    * \r\n    * Called by two functions that represent time in units of minutes:\r\n    * 1) TroveManager._calcDecayedBaseRate\r\n    * 2) CommunityIssuance._getCumulativeIssuanceFraction \r\n    * \r\n    * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\r\n    * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\r\n    * \r\n    * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\r\n    * negligibly different from just passing the cap, since: \r\n    *\r\n    * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\r\n    * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\r\n    */\r\n    function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\r\n       \r\n        if (_minutes > 525600000) {_minutes = 525600000;}  // cap to avoid overflow\r\n    \r\n        if (_minutes == 0) {return DECIMAL_PRECISION;}\r\n\r\n        uint y = DECIMAL_PRECISION;\r\n        uint x = _base;\r\n        uint n = _minutes;\r\n\r\n        // Exponentiation-by-squaring\r\n        while (n > 1) {\r\n            if (n % 2 == 0) {\r\n                x = decMul(x, x);\r\n                n = n.div(2);\r\n            } else { // if (n % 2 != 0)\r\n                y = decMul(x, y);\r\n                x = decMul(x, x);\r\n                n = (n.sub(1)).div(2);\r\n            }\r\n        }\r\n\r\n        return decMul(x, y);\r\n  }\r\n\r\n    function _getAbsoluteDifference(uint _a, uint _b) internal pure returns (uint) {\r\n        return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\r\n    }\r\n\r\n    function _computeNominalCR(uint _coll, uint _debt) internal pure returns (uint) {\r\n        if (_debt > 0) {\r\n            return _coll.mul(NICR_PRECISION).div(_debt);\r\n        }\r\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\r\n        else { // if (_debt == 0)\r\n            return 2**256 - 1;\r\n        }\r\n    }\r\n\r\n    function _computeCR(uint _coll, uint _debt, uint _price) internal pure returns (uint) {\r\n        if (_debt > 0) {\r\n            uint newCollRatio = _coll.mul(_price).div(_debt);\r\n\r\n            return newCollRatio;\r\n        }\r\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\r\n        else { // if (_debt == 0)\r\n            return 2**256 - 1; \r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Interfaces/IPool.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n// Common interface for the Pools.\r\ninterface IPool {\r\n    \r\n    // --- Events ---\r\n    \r\n    event ETHBalanceUpdated(uint _newBalance);\r\n    event LUSDBalanceUpdated(uint _newBalance);\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\r\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\r\n    event EtherSent(address _to, uint _amount);\r\n\r\n    // --- Functions ---\r\n    \r\n    function getETH() external view returns (uint);\r\n\r\n    function getLUSDDebt() external view returns (uint);\r\n\r\n    function increaseLUSDDebt(uint _amount) external;\r\n\r\n    function decreaseLUSDDebt(uint _amount) external;\r\n}\r\n\r\n\r\n// File contracts/Interfaces/IActivePool.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\ninterface IActivePool is IPool {\r\n    // --- Events ---\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolLUSDDebtUpdated(uint _LUSDDebt);\r\n    event ActivePoolETHBalanceUpdated(uint _ETH);\r\n\r\n    // --- Functions ---\r\n    function sendETH(address _account, uint _amount) external;\r\n}\r\n\r\n\r\n// File contracts/Interfaces/IDefaultPool.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\ninterface IDefaultPool is IPool {\r\n    // --- Events ---\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event DefaultPoolLUSDDebtUpdated(uint _LUSDDebt);\r\n    event DefaultPoolETHBalanceUpdated(uint _ETH);\r\n\r\n    // --- Functions ---\r\n    function sendETHToActivePool(uint _amount) external;\r\n}\r\n\r\n\r\n// File contracts/Dependencies/LiquityBase.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* \r\n* Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\r\n* common functions. \r\n*/\r\ncontract LiquityBase is BaseMath, ILiquityBase {\r\n    using SafeMath for uint;\r\n\r\n    uint constant public _100pct = 1000000000000000000; // 1e18 == 100%\r\n\r\n    // Minimum collateral ratio for individual troves\r\n    uint constant public MCR = 1100000000000000000; // 110%\r\n\r\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\r\n    uint constant public CCR = 1500000000000000000; // 150%\r\n\r\n    // Amount of LUSD to be locked in gas pool on opening troves\r\n    uint constant public LUSD_GAS_COMPENSATION = 200e18;\r\n\r\n    // Minimum amount of net LUSD debt a trove must have\r\n    uint constant public MIN_NET_DEBT = 1800e18;\r\n    // uint constant public MIN_NET_DEBT = 0; \r\n\r\n    uint constant public PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\r\n\r\n    uint constant public BORROWING_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 5; // 0.5%\r\n\r\n    IActivePool public activePool;\r\n\r\n    IDefaultPool public defaultPool;\r\n\r\n    IPriceFeed public override priceFeed;\r\n\r\n    // --- Gas compensation functions ---\r\n\r\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\r\n    function _getCompositeDebt(uint _debt) internal pure returns (uint) {\r\n        return _debt.add(LUSD_GAS_COMPENSATION);\r\n    }\r\n\r\n    function _getNetDebt(uint _debt) internal pure returns (uint) {\r\n        return _debt.sub(LUSD_GAS_COMPENSATION);\r\n    }\r\n\r\n    // Return the amount of ETH to be drawn from a trove's collateral and sent as gas compensation.\r\n    function _getCollGasCompensation(uint _entireColl) internal pure returns (uint) {\r\n        return _entireColl / PERCENT_DIVISOR;\r\n    }\r\n\r\n    function getEntireSystemColl() public view returns (uint entireSystemColl) {\r\n        uint activeColl = activePool.getETH();\r\n        uint liquidatedColl = defaultPool.getETH();\r\n\r\n        return activeColl.add(liquidatedColl);\r\n    }\r\n\r\n    function getEntireSystemDebt() public view returns (uint entireSystemDebt) {\r\n        uint activeDebt = activePool.getLUSDDebt();\r\n        uint closedDebt = defaultPool.getLUSDDebt();\r\n\r\n        return activeDebt.add(closedDebt);\r\n    }\r\n\r\n    function _getTCR(uint _price) internal view returns (uint TCR) {\r\n        uint entireSystemColl = getEntireSystemColl();\r\n        uint entireSystemDebt = getEntireSystemDebt();\r\n\r\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, _price);\r\n\r\n        return TCR;\r\n    }\r\n\r\n    function _checkRecoveryMode(uint _price) internal view returns (bool) {\r\n        uint TCR = _getTCR(_price);\r\n\r\n        return TCR < CCR;\r\n    }\r\n\r\n    function _requireUserAcceptsFee(uint _fee, uint _amount, uint _maxFeePercentage) internal pure {\r\n        uint feePercentage = _fee.mul(DECIMAL_PRECISION).div(_amount);\r\n        require(feePercentage <= _maxFeePercentage, \"Fee exceeded provided maximum\");\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Dependencies/Ownable.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n/**\r\n * Based on OpenZeppelin's Ownable contract:\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\r\n *\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     *\r\n     * NOTE: This function is not safe, as it doesn’t check owner is calling it.\r\n     * Make sure you check it before calling it.\r\n     */\r\n    function _renounceOwnership() internal {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Dependencies/CheckContract.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n\r\ncontract CheckContract {\r\n    /**\r\n     * Check that the account is an already deployed non-destroyed contract.\r\n     * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L12\r\n     */\r\n    function checkContract(address _account) internal view {\r\n        require(_account != address(0), \"Account cannot be zero address\");\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(_account) }\r\n        require(size > 0, \"Account code size cannot be zero\");\r\n    }\r\n}\r\n\r\n\r\n// File contracts/TroveManager.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {\r\n    string constant public NAME = \"TroveManager\";\r\n\r\n    // --- Connected contract declarations ---\r\n\r\n    address public borrowerOperationsAddress;\r\n\r\n    IStabilityPool public override stabilityPool;\r\n\r\n    address gasPoolAddress;\r\n\r\n    ICollSurplusPool collSurplusPool;\r\n\r\n    ILUSDToken public override lusdToken;\r\n\r\n    ILQTYToken public override lqtyToken;\r\n\r\n    ILQTYStaking public override lqtyStaking;\r\n\r\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\r\n    ISortedTroves public sortedTroves;\r\n\r\n    // --- Data structures ---\r\n\r\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\r\n    /*\r\n     * Half-life of 12h. 12h = 720 min\r\n     * (1/2) = d^720 => d = (1/2)^(1/720)\r\n     */\r\n    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;\r\n    uint constant public REDEMPTION_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 5; // 0.5%\r\n    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\r\n\r\n    // During bootsrap period redemptions are not allowed\r\n    uint constant public BOOTSTRAP_PERIOD = 14 days;\r\n\r\n    /*\r\n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\r\n    * Corresponds to (1 / ALPHA) in the white paper.\r\n    */\r\n    uint constant public BETA = 2;\r\n\r\n    uint public baseRate;\r\n\r\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance)\r\n    uint public lastFeeOperationTime;\r\n\r\n    enum Status {\r\n        nonExistent,\r\n        active,\r\n        closedByOwner,\r\n        closedByLiquidation,\r\n        closedByRedemption\r\n    }\r\n\r\n    // Store the necessary data for a trove\r\n    struct Trove {\r\n        uint debt;\r\n        uint coll;\r\n        uint stake;\r\n        Status status;\r\n        uint128 arrayIndex;\r\n    }\r\n\r\n    mapping (address => Trove) public Troves;\r\n\r\n    uint public totalStakes;\r\n\r\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\r\n    uint public totalStakesSnapshot;\r\n\r\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\r\n    uint public totalCollateralSnapshot;\r\n\r\n    /*\r\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\r\n    *\r\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\r\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\r\n    *\r\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\r\n    */\r\n    uint public L_ETH;\r\n    uint public L_LUSDDebt;\r\n\r\n    // Map addresses with active troves to their RewardSnapshot\r\n    mapping (address => RewardSnapshot) public rewardSnapshots;\r\n\r\n    // Object containing the ETH and LUSD snapshots for a given active trove\r\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\r\n\r\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\r\n    address[] public TroveOwners;\r\n\r\n    // Error trackers for the trove redistribution calculation\r\n    uint public lastETHError_Redistribution;\r\n    uint public lastLUSDDebtError_Redistribution;\r\n\r\n    /*\r\n    * --- Variable container structs for liquidations ---\r\n    *\r\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\r\n    * in order to avoid the error: \"CompilerError: Stack too deep\".\r\n    **/\r\n\r\n    struct LocalVariables_OuterLiquidationFunction {\r\n        uint price;\r\n        uint LUSDInStabPool;\r\n        bool recoveryModeAtStart;\r\n        uint liquidatedDebt;\r\n        uint liquidatedColl;\r\n    }\r\n\r\n    struct LocalVariables_InnerSingleLiquidateFunction {\r\n        uint collToLiquidate;\r\n        uint pendingDebtReward;\r\n        uint pendingCollReward;\r\n    }\r\n\r\n    struct LocalVariables_LiquidationSequence {\r\n        uint remainingLUSDInStabPool;\r\n        uint i;\r\n        uint ICR;\r\n        address user;\r\n        bool backToNormalMode;\r\n        uint entireSystemDebt;\r\n        uint entireSystemColl;\r\n    }\r\n\r\n    struct LiquidationValues {\r\n        uint entireTroveDebt;\r\n        uint entireTroveColl;\r\n        uint collGasCompensation;\r\n        uint LUSDGasCompensation;\r\n        uint debtToOffset;\r\n        uint collToSendToSP;\r\n        uint debtToRedistribute;\r\n        uint collToRedistribute;\r\n        uint collSurplus;\r\n    }\r\n\r\n    struct LiquidationTotals {\r\n        uint totalCollInSequence;\r\n        uint totalDebtInSequence;\r\n        uint totalCollGasCompensation;\r\n        uint totalLUSDGasCompensation;\r\n        uint totalDebtToOffset;\r\n        uint totalCollToSendToSP;\r\n        uint totalDebtToRedistribute;\r\n        uint totalCollToRedistribute;\r\n        uint totalCollSurplus;\r\n    }\r\n\r\n    struct ContractsCache {\r\n        IActivePool activePool;\r\n        IDefaultPool defaultPool;\r\n        ILUSDToken lusdToken;\r\n        ILQTYStaking lqtyStaking;\r\n        ISortedTroves sortedTroves;\r\n        ICollSurplusPool collSurplusPool;\r\n        address gasPoolAddress;\r\n    }\r\n    // --- Variable container structs for redemptions ---\r\n\r\n    struct RedemptionTotals {\r\n        uint remainingLUSD;\r\n        uint totalLUSDToRedeem;\r\n        uint totalETHDrawn;\r\n        uint ETHFee;\r\n        uint ETHToSendToRedeemer;\r\n        uint decayedBaseRate;\r\n        uint price;\r\n        uint totalLUSDSupplyAtStart;\r\n    }\r\n\r\n    struct SingleRedemptionValues {\r\n        uint LUSDLot;\r\n        uint ETHLot;\r\n        bool cancelledPartial;\r\n    }\r\n\r\n    // --- Events ---\r\n\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\r\n    event ActivePoolAddressChanged(address _activePoolAddress);\r\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\r\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\r\n    event GasPoolAddressChanged(address _gasPoolAddress);\r\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\r\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\r\n    event LQTYTokenAddressChanged(address _lqtyTokenAddress);\r\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\r\n\r\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\r\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\r\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\r\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\r\n    event BaseRateUpdated(uint _baseRate);\r\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\r\n    event TotalStakesUpdated(uint _newTotalStakes);\r\n    event SystemSnapshotsUpdated(uint _totalStakesSnapshot, uint _totalCollateralSnapshot);\r\n    event LTermsUpdated(uint _L_ETH, uint _L_LUSDDebt);\r\n    event TroveSnapshotsUpdated(uint _L_ETH, uint _L_LUSDDebt);\r\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\r\n\r\n     enum TroveManagerOperation {\r\n        applyPendingRewards,\r\n        liquidateInNormalMode,\r\n        liquidateInRecoveryMode,\r\n        redeemCollateral\r\n    }\r\n\r\n\r\n    // --- Dependency setter ---\r\n\r\n    function setAddresses(\r\n        address _borrowerOperationsAddress,\r\n        address _activePoolAddress,\r\n        address _defaultPoolAddress,\r\n        address _stabilityPoolAddress,\r\n        address _gasPoolAddress,\r\n        address _collSurplusPoolAddress,\r\n        address _priceFeedAddress,\r\n        address _lusdTokenAddress,\r\n        address _sortedTrovesAddress,\r\n        address _lqtyTokenAddress,\r\n        address _lqtyStakingAddress\r\n    )\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        checkContract(_borrowerOperationsAddress);\r\n        checkContract(_activePoolAddress);\r\n        checkContract(_defaultPoolAddress);\r\n        checkContract(_stabilityPoolAddress);\r\n        checkContract(_gasPoolAddress);\r\n        checkContract(_collSurplusPoolAddress);\r\n        checkContract(_priceFeedAddress);\r\n        checkContract(_lusdTokenAddress);\r\n        checkContract(_sortedTrovesAddress);\r\n        checkContract(_lqtyTokenAddress);\r\n        checkContract(_lqtyStakingAddress);\r\n\r\n        borrowerOperationsAddress = _borrowerOperationsAddress;\r\n        activePool = IActivePool(_activePoolAddress);\r\n        defaultPool = IDefaultPool(_defaultPoolAddress);\r\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\r\n        gasPoolAddress = _gasPoolAddress;\r\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\r\n        priceFeed = IPriceFeed(_priceFeedAddress);\r\n        lusdToken = ILUSDToken(_lusdTokenAddress);\r\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\r\n        lqtyToken = ILQTYToken(_lqtyTokenAddress);\r\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\r\n\r\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\r\n        emit ActivePoolAddressChanged(_activePoolAddress);\r\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\r\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\r\n        emit GasPoolAddressChanged(_gasPoolAddress);\r\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\r\n        emit PriceFeedAddressChanged(_priceFeedAddress);\r\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\r\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\r\n        emit LQTYTokenAddressChanged(_lqtyTokenAddress);\r\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\r\n\r\n        _renounceOwnership();\r\n    }\r\n\r\n    // --- Getters ---\r\n\r\n    function getTroveOwnersCount() external view override returns (uint) {\r\n        return TroveOwners.length;\r\n    }\r\n\r\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\r\n        return TroveOwners[_index];\r\n    }\r\n\r\n    // --- Trove Liquidation functions ---\r\n\r\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\r\n    function liquidate(address _borrower) external override {\r\n        _requireTroveIsActive(_borrower);\r\n\r\n        address[] memory borrowers = new address[](1);\r\n        borrowers[0] = _borrower;\r\n        batchLiquidateTroves(borrowers);\r\n    }\r\n\r\n    // --- Inner single liquidation functions ---\r\n\r\n    // Liquidate one trove, in Normal Mode.\r\n    function _liquidateNormalMode(\r\n        IActivePool _activePool,\r\n        IDefaultPool _defaultPool,\r\n        address _borrower,\r\n        uint _LUSDInStabPool\r\n    )\r\n        internal\r\n        returns (LiquidationValues memory singleLiquidation)\r\n    {\r\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\r\n\r\n        (singleLiquidation.entireTroveDebt,\r\n        singleLiquidation.entireTroveColl,\r\n        vars.pendingDebtReward,\r\n        vars.pendingCollReward) = getEntireDebtAndColl(_borrower);\r\n\r\n        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\r\n        _removeStake(_borrower);\r\n\r\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\r\n        singleLiquidation.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\r\n        uint collToLiquidate = singleLiquidation.entireTroveColl.sub(singleLiquidation.collGasCompensation);\r\n\r\n        (singleLiquidation.debtToOffset,\r\n        singleLiquidation.collToSendToSP,\r\n        singleLiquidation.debtToRedistribute,\r\n        singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\r\n\r\n        _closeTrove(_borrower, Status.closedByLiquidation);\r\n        emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\r\n        emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInNormalMode);\r\n        return singleLiquidation;\r\n    }\r\n\r\n    // Liquidate one trove, in Recovery Mode.\r\n    function _liquidateRecoveryMode(\r\n        IActivePool _activePool,\r\n        IDefaultPool _defaultPool,\r\n        address _borrower,\r\n        uint _ICR,\r\n        uint _LUSDInStabPool,\r\n        uint _TCR,\r\n        uint _price\r\n    )\r\n        internal\r\n        returns (LiquidationValues memory singleLiquidation)\r\n    {\r\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\r\n        if (TroveOwners.length <= 1) {return singleLiquidation;} // don't liquidate if last trove\r\n        (singleLiquidation.entireTroveDebt,\r\n        singleLiquidation.entireTroveColl,\r\n        vars.pendingDebtReward,\r\n        vars.pendingCollReward) = getEntireDebtAndColl(_borrower);\r\n\r\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\r\n        singleLiquidation.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\r\n        vars.collToLiquidate = singleLiquidation.entireTroveColl.sub(singleLiquidation.collGasCompensation);\r\n\r\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\r\n        if (_ICR <= _100pct) {\r\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\r\n            _removeStake(_borrower);\r\n           \r\n            singleLiquidation.debtToOffset = 0;\r\n            singleLiquidation.collToSendToSP = 0;\r\n            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\r\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\r\n\r\n            _closeTrove(_borrower, Status.closedByLiquidation);\r\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\r\n            emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\r\n            \r\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\r\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\r\n             _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\r\n            _removeStake(_borrower);\r\n\r\n            (singleLiquidation.debtToOffset,\r\n            singleLiquidation.collToSendToSP,\r\n            singleLiquidation.debtToRedistribute,\r\n            singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, vars.collToLiquidate, _LUSDInStabPool);\r\n\r\n            _closeTrove(_borrower, Status.closedByLiquidation);\r\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\r\n            emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\r\n        /*\r\n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\r\n        * and there is LUSD in the Stability Pool, only offset, with no redistribution,\r\n        * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\r\n        * The remainder due to the capped rate will be claimable as collateral surplus.\r\n        */\r\n        } else if ((_ICR >= MCR) && (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _LUSDInStabPool)) {\r\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\r\n            assert(_LUSDInStabPool != 0);\r\n\r\n            _removeStake(_borrower);\r\n            singleLiquidation = _getCappedOffsetVals(singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, _price);\r\n\r\n            _closeTrove(_borrower, Status.closedByLiquidation);\r\n            if (singleLiquidation.collSurplus > 0) {\r\n                collSurplusPool.accountSurplus(_borrower, singleLiquidation.collSurplus);\r\n            }\r\n\r\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.collToSendToSP, TroveManagerOperation.liquidateInRecoveryMode);\r\n            emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\r\n\r\n        } else { // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _LUSDInStabPool))\r\n            LiquidationValues memory zeroVals;\r\n            return zeroVals;\r\n        }\r\n\r\n        return singleLiquidation;\r\n    }\r\n\r\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\r\n    * redistributed to active troves.\r\n    */\r\n    function _getOffsetAndRedistributionVals\r\n    (\r\n        uint _debt,\r\n        uint _coll,\r\n        uint _LUSDInStabPool\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\r\n    {\r\n        if (_LUSDInStabPool > 0) {\r\n        /*\r\n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\r\n        * between all active troves.\r\n        *\r\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\r\n        *\r\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\r\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\r\n        *\r\n        */\r\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\r\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\r\n            debtToRedistribute = _debt.sub(debtToOffset);\r\n            collToRedistribute = _coll.sub(collToSendToSP);\r\n        } else {\r\n            debtToOffset = 0;\r\n            collToSendToSP = 0;\r\n            debtToRedistribute = _debt;\r\n            collToRedistribute = _coll;\r\n        }\r\n    }\r\n\r\n    /*\r\n    *  Get its offset coll/debt and ETH gas comp, and close the trove.\r\n    */\r\n    function _getCappedOffsetVals\r\n    (\r\n        uint _entireTroveDebt,\r\n        uint _entireTroveColl,\r\n        uint _price\r\n    )\r\n        internal\r\n        pure\r\n        returns (LiquidationValues memory singleLiquidation)\r\n    {\r\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\r\n        singleLiquidation.entireTroveColl = _entireTroveColl;\r\n        uint collToOffset = _entireTroveDebt.mul(MCR).div(_price);\r\n\r\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(collToOffset);\r\n        singleLiquidation.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\r\n\r\n        singleLiquidation.debtToOffset = _entireTroveDebt;\r\n        singleLiquidation.collToSendToSP = collToOffset.sub(singleLiquidation.collGasCompensation);\r\n        singleLiquidation.collSurplus = _entireTroveColl.sub(collToOffset);\r\n        singleLiquidation.debtToRedistribute = 0;\r\n        singleLiquidation.collToRedistribute = 0;\r\n    }\r\n\r\n    /*\r\n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\r\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\r\n    */\r\n    function liquidateTroves(uint _n) external override {\r\n        ContractsCache memory contractsCache = ContractsCache(\r\n            activePool,\r\n            defaultPool,\r\n            ILUSDToken(address(0)),\r\n            ILQTYStaking(address(0)),\r\n            sortedTroves,\r\n            ICollSurplusPool(address(0)),\r\n            address(0)\r\n        );\r\n        IStabilityPool stabilityPoolCached = stabilityPool;\r\n\r\n        LocalVariables_OuterLiquidationFunction memory vars;\r\n\r\n        LiquidationTotals memory totals;\r\n\r\n        vars.price = priceFeed.fetchPrice();\r\n        vars.LUSDInStabPool = stabilityPoolCached.getTotalLUSDDeposits();\r\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\r\n\r\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\r\n        if (vars.recoveryModeAtStart) {\r\n            totals = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(contractsCache, vars.price, vars.LUSDInStabPool, _n);\r\n        } else { // if !vars.recoveryModeAtStart\r\n            totals = _getTotalsFromLiquidateTrovesSequence_NormalMode(contractsCache.activePool, contractsCache.defaultPool, vars.price, vars.LUSDInStabPool, _n);\r\n        }\r\n\r\n        require(totals.totalDebtInSequence > 0, \"TroveManager: nothing to liquidate\");\r\n\r\n        // Move liquidated ETH and LUSD to the appropriate pools\r\n        stabilityPoolCached.offset(totals.totalDebtToOffset, totals.totalCollToSendToSP);\r\n        _redistributeDebtAndColl(contractsCache.activePool, contractsCache.defaultPool, totals.totalDebtToRedistribute, totals.totalCollToRedistribute);\r\n        if (totals.totalCollSurplus > 0) {\r\n            contractsCache.activePool.sendETH(address(collSurplusPool), totals.totalCollSurplus);\r\n        }\r\n\r\n        // Update system snapshots\r\n        _updateSystemSnapshots_excludeCollRemainder(contractsCache.activePool, totals.totalCollGasCompensation);\r\n\r\n        vars.liquidatedDebt = totals.totalDebtInSequence;\r\n        vars.liquidatedColl = totals.totalCollInSequence.sub(totals.totalCollGasCompensation).sub(totals.totalCollSurplus);\r\n        emit Liquidation(vars.liquidatedDebt, vars.liquidatedColl, totals.totalCollGasCompensation, totals.totalLUSDGasCompensation);\r\n\r\n        // Send gas compensation to caller\r\n        _sendGasCompensation(contractsCache.activePool, msg.sender, totals.totalLUSDGasCompensation, totals.totalCollGasCompensation);\r\n    }\r\n\r\n    /*\r\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\r\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\r\n    */\r\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\r\n    (\r\n        ContractsCache memory _contractsCache,\r\n        uint _price,\r\n        uint _LUSDInStabPool,\r\n        uint _n\r\n    )\r\n        internal\r\n        returns(LiquidationTotals memory totals)\r\n    {\r\n        LocalVariables_LiquidationSequence memory vars;\r\n        LiquidationValues memory singleLiquidation;\r\n\r\n        vars.remainingLUSDInStabPool = _LUSDInStabPool;\r\n        vars.backToNormalMode = false;\r\n        vars.entireSystemDebt = getEntireSystemDebt();\r\n        vars.entireSystemColl = getEntireSystemColl();\r\n\r\n        vars.user = _contractsCache.sortedTroves.getLast();\r\n        address firstUser = _contractsCache.sortedTroves.getFirst();\r\n        for (vars.i = 0; vars.i < _n && vars.user != firstUser; vars.i++) {\r\n            // we need to cache it, because current user is likely going to be deleted\r\n            address nextUser = _contractsCache.sortedTroves.getPrev(vars.user);\r\n\r\n            vars.ICR = getCurrentICR(vars.user, _price);\r\n\r\n            if (!vars.backToNormalMode) {\r\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\r\n                if (vars.ICR >= MCR && vars.remainingLUSDInStabPool == 0) { break; }\r\n\r\n                uint TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, _price);\r\n\r\n                singleLiquidation = _liquidateRecoveryMode(_contractsCache.activePool, _contractsCache.defaultPool, vars.user, vars.ICR, vars.remainingLUSDInStabPool, TCR, _price);\r\n\r\n                // Update aggregate trackers\r\n                vars.remainingLUSDInStabPool = vars.remainingLUSDInStabPool.sub(singleLiquidation.debtToOffset);\r\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);\r\n                vars.entireSystemColl = vars.entireSystemColl.sub(singleLiquidation.collToSendToSP).sub(singleLiquidation.collSurplus);\r\n\r\n                // Add liquidation values to their respective running totals\r\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\r\n\r\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(vars.entireSystemColl, vars.entireSystemDebt, _price);\r\n            }\r\n            else if (vars.backToNormalMode && vars.ICR < MCR) {\r\n                singleLiquidation = _liquidateNormalMode(_contractsCache.activePool, _contractsCache.defaultPool, vars.user, vars.remainingLUSDInStabPool);\r\n\r\n                vars.remainingLUSDInStabPool = vars.remainingLUSDInStabPool.sub(singleLiquidation.debtToOffset);\r\n\r\n                // Add liquidation values to their respective running totals\r\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\r\n\r\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\r\n\r\n            vars.user = nextUser;\r\n        }\r\n    }\r\n\r\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\r\n    (\r\n        IActivePool _activePool,\r\n        IDefaultPool _defaultPool,\r\n        uint _price,\r\n        uint _LUSDInStabPool,\r\n        uint _n\r\n    )\r\n        internal\r\n        returns(LiquidationTotals memory totals)\r\n    {\r\n        LocalVariables_LiquidationSequence memory vars;\r\n        LiquidationValues memory singleLiquidation;\r\n        ISortedTroves sortedTrovesCached = sortedTroves;\r\n\r\n        vars.remainingLUSDInStabPool = _LUSDInStabPool;\r\n\r\n        for (vars.i = 0; vars.i < _n; vars.i++) {\r\n            vars.user = sortedTrovesCached.getLast();\r\n            vars.ICR = getCurrentICR(vars.user, _price);\r\n\r\n            if (vars.ICR < MCR) {\r\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingLUSDInStabPool);\r\n\r\n                vars.remainingLUSDInStabPool = vars.remainingLUSDInStabPool.sub(singleLiquidation.debtToOffset);\r\n\r\n                // Add liquidation values to their respective running totals\r\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\r\n\r\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\r\n        }\r\n    }\r\n\r\n    /*\r\n    * Attempt to liquidate a custom list of troves provided by the caller.\r\n    */\r\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\r\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\r\n\r\n        IActivePool activePoolCached = activePool;\r\n        IDefaultPool defaultPoolCached = defaultPool;\r\n        IStabilityPool stabilityPoolCached = stabilityPool;\r\n\r\n        LocalVariables_OuterLiquidationFunction memory vars;\r\n        LiquidationTotals memory totals;\r\n\r\n        vars.price = priceFeed.fetchPrice();\r\n        vars.LUSDInStabPool = stabilityPoolCached.getTotalLUSDDeposits();\r\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\r\n\r\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\r\n        if (vars.recoveryModeAtStart) {\r\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(activePoolCached, defaultPoolCached, vars.price, vars.LUSDInStabPool, _troveArray);\r\n        } else {  //  if !vars.recoveryModeAtStart\r\n            totals = _getTotalsFromBatchLiquidate_NormalMode(activePoolCached, defaultPoolCached, vars.price, vars.LUSDInStabPool, _troveArray);\r\n        }\r\n\r\n        require(totals.totalDebtInSequence > 0, \"TroveManager: nothing to liquidate\");\r\n\r\n        // Move liquidated ETH and LUSD to the appropriate pools\r\n        stabilityPoolCached.offset(totals.totalDebtToOffset, totals.totalCollToSendToSP);\r\n        _redistributeDebtAndColl(activePoolCached, defaultPoolCached, totals.totalDebtToRedistribute, totals.totalCollToRedistribute);\r\n        if (totals.totalCollSurplus > 0) {\r\n            activePoolCached.sendETH(address(collSurplusPool), totals.totalCollSurplus);\r\n        }\r\n\r\n        // Update system snapshots\r\n        _updateSystemSnapshots_excludeCollRemainder(activePoolCached, totals.totalCollGasCompensation);\r\n\r\n        vars.liquidatedDebt = totals.totalDebtInSequence;\r\n        vars.liquidatedColl = totals.totalCollInSequence.sub(totals.totalCollGasCompensation).sub(totals.totalCollSurplus);\r\n        emit Liquidation(vars.liquidatedDebt, vars.liquidatedColl, totals.totalCollGasCompensation, totals.totalLUSDGasCompensation);\r\n\r\n        // Send gas compensation to caller\r\n        _sendGasCompensation(activePoolCached, msg.sender, totals.totalLUSDGasCompensation, totals.totalCollGasCompensation);\r\n    }\r\n\r\n    /*\r\n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\r\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\r\n    */\r\n    function _getTotalFromBatchLiquidate_RecoveryMode\r\n    (\r\n        IActivePool _activePool,\r\n        IDefaultPool _defaultPool,\r\n        uint _price,\r\n        uint _LUSDInStabPool,\r\n        address[] memory _troveArray\r\n    )\r\n        internal\r\n        returns(LiquidationTotals memory totals)\r\n    {\r\n        LocalVariables_LiquidationSequence memory vars;\r\n        LiquidationValues memory singleLiquidation;\r\n\r\n        vars.remainingLUSDInStabPool = _LUSDInStabPool;\r\n        vars.backToNormalMode = false;\r\n        vars.entireSystemDebt = getEntireSystemDebt();\r\n        vars.entireSystemColl = getEntireSystemColl();\r\n\r\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\r\n            vars.user = _troveArray[vars.i];\r\n            // Skip non-active troves\r\n            if (Troves[vars.user].status != Status.active) { continue; }\r\n            vars.ICR = getCurrentICR(vars.user, _price);\r\n\r\n            if (!vars.backToNormalMode) {\r\n\r\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\r\n                if (vars.ICR >= MCR && vars.remainingLUSDInStabPool == 0) { continue; }\r\n\r\n                uint TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, _price);\r\n\r\n                singleLiquidation = _liquidateRecoveryMode(_activePool, _defaultPool, vars.user, vars.ICR, vars.remainingLUSDInStabPool, TCR, _price);\r\n\r\n                // Update aggregate trackers\r\n                vars.remainingLUSDInStabPool = vars.remainingLUSDInStabPool.sub(singleLiquidation.debtToOffset);\r\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);\r\n                vars.entireSystemColl = vars.entireSystemColl.sub(singleLiquidation.collToSendToSP);\r\n\r\n                // Add liquidation values to their respective running totals\r\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\r\n\r\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(vars.entireSystemColl, vars.entireSystemDebt, _price);\r\n            }\r\n\r\n            else if (vars.backToNormalMode && vars.ICR < MCR) {\r\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingLUSDInStabPool);\r\n                vars.remainingLUSDInStabPool = vars.remainingLUSDInStabPool.sub(singleLiquidation.debtToOffset);\r\n\r\n                // Add liquidation values to their respective running totals\r\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\r\n\r\n            } else continue; // In Normal Mode skip troves with ICR >= MCR\r\n        }\r\n    }\r\n\r\n    function _getTotalsFromBatchLiquidate_NormalMode\r\n    (\r\n        IActivePool _activePool,\r\n        IDefaultPool _defaultPool,\r\n        uint _price,\r\n        uint _LUSDInStabPool,\r\n        address[] memory _troveArray\r\n    )\r\n        internal\r\n        returns(LiquidationTotals memory totals)\r\n    {\r\n        LocalVariables_LiquidationSequence memory vars;\r\n        LiquidationValues memory singleLiquidation;\r\n\r\n        vars.remainingLUSDInStabPool = _LUSDInStabPool;\r\n\r\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\r\n            vars.user = _troveArray[vars.i];\r\n            vars.ICR = getCurrentICR(vars.user, _price);\r\n\r\n            if (vars.ICR < MCR) {\r\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingLUSDInStabPool);\r\n                vars.remainingLUSDInStabPool = vars.remainingLUSDInStabPool.sub(singleLiquidation.debtToOffset);\r\n\r\n                // Add liquidation values to their respective running totals\r\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\r\n            }\r\n        }\r\n    }\r\n\r\n    // --- Liquidation helper functions ---\r\n\r\n    function _addLiquidationValuesToTotals(LiquidationTotals memory oldTotals, LiquidationValues memory singleLiquidation)\r\n    internal pure returns(LiquidationTotals memory newTotals) {\r\n\r\n        // Tally all the values with their respective running totals\r\n        newTotals.totalCollGasCompensation = oldTotals.totalCollGasCompensation.add(singleLiquidation.collGasCompensation);\r\n        newTotals.totalLUSDGasCompensation = oldTotals.totalLUSDGasCompensation.add(singleLiquidation.LUSDGasCompensation);\r\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(singleLiquidation.entireTroveDebt);\r\n        newTotals.totalCollInSequence = oldTotals.totalCollInSequence.add(singleLiquidation.entireTroveColl);\r\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(singleLiquidation.debtToOffset);\r\n        newTotals.totalCollToSendToSP = oldTotals.totalCollToSendToSP.add(singleLiquidation.collToSendToSP);\r\n        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(singleLiquidation.debtToRedistribute);\r\n        newTotals.totalCollToRedistribute = oldTotals.totalCollToRedistribute.add(singleLiquidation.collToRedistribute);\r\n        newTotals.totalCollSurplus = oldTotals.totalCollSurplus.add(singleLiquidation.collSurplus);\r\n\r\n        return newTotals;\r\n    }\r\n\r\n    function _sendGasCompensation(IActivePool _activePool, address _liquidator, uint _LUSD, uint _ETH) internal {\r\n        if (_LUSD > 0) {\r\n            lusdToken.returnFromPool(gasPoolAddress, _liquidator, _LUSD);\r\n        }\r\n\r\n        if (_ETH > 0) {\r\n            _activePool.sendETH(_liquidator, _ETH);\r\n        }\r\n    }\r\n\r\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\r\n    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _LUSD, uint _ETH) internal {\r\n        _defaultPool.decreaseLUSDDebt(_LUSD);\r\n        _activePool.increaseLUSDDebt(_LUSD);\r\n        _defaultPool.sendETHToActivePool(_ETH);\r\n    }\r\n\r\n    // --- Redemption functions ---\r\n\r\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\r\n    function _redeemCollateralFromTrove(\r\n        ContractsCache memory _contractsCache,\r\n        address _borrower,\r\n        uint _maxLUSDamount,\r\n        uint _price,\r\n        address _upperPartialRedemptionHint,\r\n        address _lowerPartialRedemptionHint,\r\n        uint _partialRedemptionHintNICR\r\n    )\r\n        internal returns (SingleRedemptionValues memory singleRedemption)\r\n    {\r\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\r\n        singleRedemption.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\r\n\r\n        // Get the ETHLot of equivalent value in USD\r\n        singleRedemption.ETHLot = singleRedemption.LUSDLot.mul(DECIMAL_PRECISION).div(_price);\r\n\r\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\r\n        uint newDebt = (Troves[_borrower].debt).sub(singleRedemption.LUSDLot);\r\n        uint newColl = (Troves[_borrower].coll).sub(singleRedemption.ETHLot);\r\n\r\n        if (newDebt == LUSD_GAS_COMPENSATION) {\r\n            // No debt left in the Trove (except for the liquidation reserve), therefore the trove gets closed\r\n            _removeStake(_borrower);\r\n            _closeTrove(_borrower, Status.closedByRedemption);\r\n            _redeemCloseTrove(_contractsCache, _borrower, LUSD_GAS_COMPENSATION, newColl);\r\n            emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.redeemCollateral);\r\n\r\n        } else {\r\n            uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\r\n\r\n            /*\r\n            * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost\r\n            * certainly result in running out of gas. \r\n            *\r\n            * If the resultant net debt of the partial is less than the minimum, net debt we bail.\r\n            */\r\n            if (newNICR != _partialRedemptionHintNICR || _getNetDebt(newDebt) < MIN_NET_DEBT) {\r\n                singleRedemption.cancelledPartial = true;\r\n                return singleRedemption;\r\n            }\r\n\r\n            _contractsCache.sortedTroves.reInsert(_borrower, newNICR, _upperPartialRedemptionHint, _lowerPartialRedemptionHint);\r\n\r\n            Troves[_borrower].debt = newDebt;\r\n            Troves[_borrower].coll = newColl;\r\n            _updateStakeAndTotalStakes(_borrower);\r\n\r\n            emit TroveUpdated(\r\n                _borrower,\r\n                newDebt, newColl,\r\n                Troves[_borrower].stake,\r\n                TroveManagerOperation.redeemCollateral\r\n            );\r\n        }\r\n\r\n        return singleRedemption;\r\n    }\r\n\r\n    /*\r\n    * Called when a full redemption occurs, and closes the trove.\r\n    * The redeemer swaps (debt - liquidation reserve) LUSD for (debt - liquidation reserve) worth of ETH, so the LUSD liquidation reserve left corresponds to the remaining debt.\r\n    * In order to close the trove, the LUSD liquidation reserve is burned, and the corresponding debt is removed from the active pool.\r\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\r\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\r\n    */\r\n    function _redeemCloseTrove(ContractsCache memory _contractsCache, address _borrower, uint _LUSD, uint _ETH) internal {\r\n        _contractsCache.lusdToken.burn(gasPoolAddress, _LUSD);\r\n        // Update Active Pool LUSD, and send ETH to account\r\n        _contractsCache.activePool.decreaseLUSDDebt(_LUSD);\r\n\r\n        // send ETH from Active Pool to CollSurplus Pool\r\n        _contractsCache.collSurplusPool.accountSurplus(_borrower, _ETH);\r\n        _contractsCache.activePool.sendETH(address(_contractsCache.collSurplusPool), _ETH);\r\n    }\r\n\r\n    function _isValidFirstRedemptionHint(ISortedTroves _sortedTroves, address _firstRedemptionHint, uint _price) internal view returns (bool) {\r\n        if (_firstRedemptionHint == address(0) ||\r\n            !_sortedTroves.contains(_firstRedemptionHint) ||\r\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        address nextTrove = _sortedTroves.getNext(_firstRedemptionHint);\r\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\r\n    }\r\n\r\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\r\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\r\n    *\r\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\r\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\r\n    *\r\n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\r\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\r\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\r\n    * costs can vary.\r\n    *\r\n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\r\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\r\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\r\n    * in the sortedTroves list along with the ICR value that the hint was found for.\r\n    *\r\n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\r\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\r\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\r\n    * to redeem later.\r\n    */\r\n    function redeemCollateral(\r\n        uint _LUSDamount,\r\n        address _firstRedemptionHint,\r\n        address _upperPartialRedemptionHint,\r\n        address _lowerPartialRedemptionHint,\r\n        uint _partialRedemptionHintNICR,\r\n        uint _maxIterations,\r\n        uint _maxFeePercentage\r\n    )\r\n        external\r\n        override\r\n    {\r\n        ContractsCache memory contractsCache = ContractsCache(\r\n            activePool,\r\n            defaultPool,\r\n            lusdToken,\r\n            lqtyStaking,\r\n            sortedTroves,\r\n            collSurplusPool,\r\n            gasPoolAddress\r\n        );\r\n        RedemptionTotals memory totals;\r\n\r\n        _requireValidMaxFeePercentage(_maxFeePercentage);\r\n        _requireAfterBootstrapPeriod();\r\n        totals.price = priceFeed.fetchPrice();\r\n        _requireTCRoverMCR(totals.price);\r\n        _requireAmountGreaterThanZero(_LUSDamount);\r\n        _requireLUSDBalanceCoversRedemption(contractsCache.lusdToken, msg.sender, _LUSDamount);\r\n\r\n        totals.totalLUSDSupplyAtStart = getEntireSystemDebt();\r\n        // Confirm redeemer's balance is less than total LUSD supply\r\n        assert(contractsCache.lusdToken.balanceOf(msg.sender) <= totals.totalLUSDSupplyAtStart);\r\n\r\n        totals.remainingLUSD = _LUSDamount;\r\n        address currentBorrower;\r\n\r\n        if (_isValidFirstRedemptionHint(contractsCache.sortedTroves, _firstRedemptionHint, totals.price)) {\r\n            currentBorrower = _firstRedemptionHint;\r\n        } else {\r\n            currentBorrower = contractsCache.sortedTroves.getLast();\r\n            // Find the first trove with ICR >= MCR\r\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, totals.price) < MCR) {\r\n                currentBorrower = contractsCache.sortedTroves.getPrev(currentBorrower);\r\n            }\r\n        }\r\n\r\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\r\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\r\n        while (currentBorrower != address(0) && totals.remainingLUSD > 0 && _maxIterations > 0) {\r\n            _maxIterations--;\r\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\r\n            address nextUserToCheck = contractsCache.sortedTroves.getPrev(currentBorrower);\r\n\r\n            _applyPendingRewards(contractsCache.activePool, contractsCache.defaultPool, currentBorrower);\r\n\r\n            SingleRedemptionValues memory singleRedemption = _redeemCollateralFromTrove(\r\n                contractsCache,\r\n                currentBorrower,\r\n                totals.remainingLUSD,\r\n                totals.price,\r\n                _upperPartialRedemptionHint,\r\n                _lowerPartialRedemptionHint,\r\n                _partialRedemptionHintNICR\r\n            );\r\n\r\n            if (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum), therefore we could not redeem from the last Trove\r\n\r\n            totals.totalLUSDToRedeem  = totals.totalLUSDToRedeem.add(singleRedemption.LUSDLot);\r\n            totals.totalETHDrawn = totals.totalETHDrawn.add(singleRedemption.ETHLot);\r\n\r\n            totals.remainingLUSD = totals.remainingLUSD.sub(singleRedemption.LUSDLot);\r\n            currentBorrower = nextUserToCheck;\r\n        }\r\n        require(totals.totalETHDrawn > 0, \"TroveManager: Unable to redeem any amount\");\r\n\r\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\r\n        // Use the saved total LUSD supply value, from before it was reduced by the redemption.\r\n        _updateBaseRateFromRedemption(totals.totalETHDrawn, totals.price, totals.totalLUSDSupplyAtStart);\r\n\r\n        // Calculate the ETH fee\r\n        totals.ETHFee = _getRedemptionFee(totals.totalETHDrawn);\r\n\r\n        _requireUserAcceptsFee(totals.ETHFee, totals.totalETHDrawn, _maxFeePercentage);\r\n\r\n        // Send the ETH fee to the LQTY staking contract\r\n        contractsCache.activePool.sendETH(address(contractsCache.lqtyStaking), totals.ETHFee);\r\n        contractsCache.lqtyStaking.increaseF_ETH(totals.ETHFee);\r\n\r\n        totals.ETHToSendToRedeemer = totals.totalETHDrawn.sub(totals.ETHFee);\r\n\r\n        emit Redemption(_LUSDamount, totals.totalLUSDToRedeem, totals.totalETHDrawn, totals.ETHFee);\r\n\r\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\r\n        contractsCache.lusdToken.burn(msg.sender, totals.totalLUSDToRedeem);\r\n        // Update Active Pool LUSD, and send ETH to account\r\n        contractsCache.activePool.decreaseLUSDDebt(totals.totalLUSDToRedeem);\r\n        contractsCache.activePool.sendETH(msg.sender, totals.ETHToSendToRedeemer);\r\n    }\r\n\r\n    // --- Helper functions ---\r\n\r\n    // Return the nominal collateral ratio (ICR) of a given Trove, without the price. Takes a trove's pending coll and debt rewards from redistributions into account.\r\n    function getNominalICR(address _borrower) public view override returns (uint) {\r\n        (uint currentETH, uint currentLUSDDebt) = _getCurrentTroveAmounts(_borrower);\r\n\r\n        uint NICR = LiquityMath._computeNominalCR(currentETH, currentLUSDDebt);\r\n        return NICR;\r\n    }\r\n\r\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\r\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\r\n        (uint currentETH, uint currentLUSDDebt) = _getCurrentTroveAmounts(_borrower);\r\n\r\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\r\n        return ICR;\r\n    }\r\n\r\n    function _getCurrentTroveAmounts(address _borrower) internal view returns (uint, uint) {\r\n        uint pendingETHReward = getPendingETHReward(_borrower);\r\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\r\n\r\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\r\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\r\n\r\n        return (currentETH, currentLUSDDebt);\r\n    }\r\n\r\n    function applyPendingRewards(address _borrower) external override {\r\n        _requireCallerIsBorrowerOperations();\r\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\r\n    }\r\n\r\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\r\n    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {\r\n        if (hasPendingRewards(_borrower)) {\r\n            _requireTroveIsActive(_borrower);\r\n\r\n            // Compute pending rewards\r\n            uint pendingETHReward = getPendingETHReward(_borrower);\r\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\r\n\r\n            // Apply pending rewards to trove's state\r\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\r\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\r\n\r\n            _updateTroveRewardSnapshots(_borrower);\r\n\r\n            // Transfer from DefaultPool to ActivePool\r\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingLUSDDebtReward, pendingETHReward);\r\n\r\n            emit TroveUpdated(\r\n                _borrower,\r\n                Troves[_borrower].debt,\r\n                Troves[_borrower].coll,\r\n                Troves[_borrower].stake,\r\n                TroveManagerOperation.applyPendingRewards\r\n            );\r\n        }\r\n    }\r\n\r\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\r\n    function updateTroveRewardSnapshots(address _borrower) external override {\r\n        _requireCallerIsBorrowerOperations();\r\n       return _updateTroveRewardSnapshots(_borrower);\r\n    }\r\n\r\n    function _updateTroveRewardSnapshots(address _borrower) internal {\r\n        rewardSnapshots[_borrower].ETH = L_ETH;\r\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\r\n        emit TroveSnapshotsUpdated(L_ETH, L_LUSDDebt);\r\n    }\r\n\r\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\r\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\r\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\r\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\r\n\r\n        if ( rewardPerUnitStaked == 0 || Troves[_borrower].status != Status.active) { return 0; }\r\n\r\n        uint stake = Troves[_borrower].stake;\r\n\r\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);\r\n\r\n        return pendingETHReward;\r\n    }\r\n    \r\n    // Get the borrower's pending accumulated LUSD reward, earned by their stake\r\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\r\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\r\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\r\n\r\n        if ( rewardPerUnitStaked == 0 || Troves[_borrower].status != Status.active) { return 0; }\r\n\r\n        uint stake =  Troves[_borrower].stake;\r\n\r\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);\r\n\r\n        return pendingLUSDDebtReward;\r\n    }\r\n\r\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\r\n        /*\r\n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\r\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\r\n        * pending rewards\r\n        */\r\n        if (Troves[_borrower].status != Status.active) {return false;}\r\n       \r\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\r\n    }\r\n\r\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\r\n    function getEntireDebtAndColl(\r\n        address _borrower\r\n    )\r\n        public\r\n        view\r\n        override\r\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\r\n    {\r\n        debt = Troves[_borrower].debt;\r\n        coll = Troves[_borrower].coll;\r\n\r\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\r\n        pendingETHReward = getPendingETHReward(_borrower);\r\n\r\n        debt = debt.add(pendingLUSDDebtReward);\r\n        coll = coll.add(pendingETHReward);\r\n    }\r\n\r\n    function removeStake(address _borrower) external override {\r\n        _requireCallerIsBorrowerOperations();\r\n        return _removeStake(_borrower);\r\n    }\r\n\r\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\r\n    function _removeStake(address _borrower) internal {\r\n        uint stake = Troves[_borrower].stake;\r\n        totalStakes = totalStakes.sub(stake);\r\n        Troves[_borrower].stake = 0;\r\n    }\r\n\r\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\r\n        _requireCallerIsBorrowerOperations();\r\n        return _updateStakeAndTotalStakes(_borrower);\r\n    }\r\n\r\n    // Update borrower's stake based on their latest collateral value\r\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\r\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\r\n        uint oldStake = Troves[_borrower].stake;\r\n        Troves[_borrower].stake = newStake;\r\n\r\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\r\n        emit TotalStakesUpdated(totalStakes);\r\n\r\n        return newStake;\r\n    }\r\n\r\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\r\n    function _computeNewStake(uint _coll) internal view returns (uint) {\r\n        uint stake;\r\n        if (totalCollateralSnapshot == 0) {\r\n            stake = _coll;\r\n        } else {\r\n            /*\r\n            * The following assert() holds true because:\r\n            * - The system always contains >= 1 trove\r\n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\r\n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\r\n            */\r\n            assert(totalStakesSnapshot > 0);\r\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\r\n        }\r\n        return stake;\r\n    }\r\n\r\n    function _redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, uint _coll) internal {\r\n        if (_debt == 0) { return; }\r\n\r\n        /*\r\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \"feedback\"\r\n        * error correction, to keep the cumulative error low in the running totals L_ETH and L_LUSDDebt:\r\n        *\r\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\r\n        * function was called.\r\n        * 2) Calculate \"per-unit-staked\" ratios.\r\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\r\n        * 4) Store these errors for use in the next correction when this function is called.\r\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\r\n        */\r\n        uint ETHNumerator = _coll.mul(DECIMAL_PRECISION).add(lastETHError_Redistribution);\r\n        uint LUSDDebtNumerator = _debt.mul(DECIMAL_PRECISION).add(lastLUSDDebtError_Redistribution);\r\n\r\n        // Get the per-unit-staked terms\r\n        uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\r\n        uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\r\n\r\n        lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\r\n        lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\r\n\r\n        // Add per-unit-staked terms to the running totals\r\n        L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\r\n        L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\r\n\r\n        emit LTermsUpdated(L_ETH, L_LUSDDebt);\r\n\r\n        // Transfer coll and debt from ActivePool to DefaultPool\r\n        _activePool.decreaseLUSDDebt(_debt);\r\n        _defaultPool.increaseLUSDDebt(_debt);\r\n        _activePool.sendETH(address(_defaultPool), _coll);\r\n    }\r\n\r\n    function closeTrove(address _borrower) external override {\r\n        _requireCallerIsBorrowerOperations();\r\n        return _closeTrove(_borrower, Status.closedByOwner);\r\n    }\r\n\r\n    function _closeTrove(address _borrower, Status closedStatus) internal {\r\n        assert(closedStatus != Status.nonExistent && closedStatus != Status.active);\r\n\r\n        uint TroveOwnersArrayLength = TroveOwners.length;\r\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\r\n\r\n        Troves[_borrower].status = closedStatus;\r\n        Troves[_borrower].coll = 0;\r\n        Troves[_borrower].debt = 0;\r\n\r\n        rewardSnapshots[_borrower].ETH = 0;\r\n        rewardSnapshots[_borrower].LUSDDebt = 0;\r\n\r\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\r\n        sortedTroves.remove(_borrower);\r\n    }\r\n\r\n    /*\r\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\r\n    * Used in a liquidation sequence.\r\n    *\r\n    * The calculation excludes a portion of collateral that is in the ActivePool:\r\n    *\r\n    * the total ETH gas compensation from the liquidation sequence\r\n    *\r\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\r\n    */\r\n    function _updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, uint _collRemainder) internal {\r\n        totalStakesSnapshot = totalStakes;\r\n\r\n        uint activeColl = _activePool.getETH();\r\n        uint liquidatedColl = defaultPool.getETH();\r\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\r\n\r\n        emit SystemSnapshotsUpdated(totalStakesSnapshot, totalCollateralSnapshot);\r\n    }\r\n\r\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\r\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\r\n        _requireCallerIsBorrowerOperations();\r\n        return _addTroveOwnerToArray(_borrower);\r\n    }\r\n\r\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\r\n        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum LUSD\r\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 LUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */\r\n\r\n        // Push the Troveowner to the array\r\n        TroveOwners.push(_borrower);\r\n\r\n        // Record the index of the new Troveowner on their Trove struct\r\n        index = uint128(TroveOwners.length.sub(1));\r\n        Troves[_borrower].arrayIndex = index;\r\n\r\n        return index;\r\n    }\r\n\r\n    /*\r\n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\r\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\r\n    */\r\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\r\n        Status troveStatus = Troves[_borrower].status;\r\n        // It’s set in caller function `_closeTrove`\r\n        assert(troveStatus != Status.nonExistent && troveStatus != Status.active);\r\n\r\n        uint128 index = Troves[_borrower].arrayIndex;\r\n        uint length = TroveOwnersArrayLength;\r\n        uint idxLast = length.sub(1);\r\n\r\n        assert(index <= idxLast);\r\n\r\n        address addressToMove = TroveOwners[idxLast];\r\n\r\n        TroveOwners[index] = addressToMove;\r\n        Troves[addressToMove].arrayIndex = index;\r\n        emit TroveIndexUpdated(addressToMove, index);\r\n\r\n        TroveOwners.pop();\r\n    }\r\n\r\n    // --- Recovery Mode and TCR functions ---\r\n\r\n    function getTCR(uint _price) external view override returns (uint) {\r\n        return _getTCR(_price);\r\n    }\r\n\r\n    function checkRecoveryMode(uint _price) external view override returns (bool) {\r\n        return _checkRecoveryMode(_price);\r\n    }\r\n\r\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\r\n    function _checkPotentialRecoveryMode(\r\n        uint _entireSystemColl,\r\n        uint _entireSystemDebt,\r\n        uint _price\r\n    )\r\n        internal\r\n        pure\r\n    returns (bool)\r\n    {\r\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\r\n\r\n        return TCR < CCR;\r\n    }\r\n\r\n    // --- Redemption fee functions ---\r\n\r\n    /*\r\n    * This function has two impacts on the baseRate state variable:\r\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\r\n    * then,\r\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\r\n    */\r\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price, uint _totalLUSDSupply) internal returns (uint) {\r\n        uint decayedBaseRate = _calcDecayedBaseRate();\r\n\r\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\r\n        * the fraction of total supply that was redeemed at face value. */\r\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(_totalLUSDSupply);\r\n\r\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\r\n        newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\r\n        //assert(newBaseRate <= DECIMAL_PRECISION); // This is already enforced in the line above\r\n        assert(newBaseRate > 0); // Base rate is always non-zero after redemption\r\n\r\n        // Update the baseRate state variable\r\n        baseRate = newBaseRate;\r\n        emit BaseRateUpdated(newBaseRate);\r\n        \r\n        _updateLastFeeOpTime();\r\n\r\n        return newBaseRate;\r\n    }\r\n\r\n    function getRedemptionRate() public view override returns (uint) {\r\n        return _calcRedemptionRate(baseRate);\r\n    }\r\n\r\n    function getRedemptionRateWithDecay() public view override returns (uint) {\r\n        return _calcRedemptionRate(_calcDecayedBaseRate());\r\n    }\r\n\r\n    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {\r\n        return LiquityMath._min(\r\n            REDEMPTION_FEE_FLOOR.add(_baseRate),\r\n            DECIMAL_PRECISION // cap at a maximum of 100%\r\n        );\r\n    }\r\n\r\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\r\n        return _calcRedemptionFee(getRedemptionRate(), _ETHDrawn);\r\n    }\r\n\r\n    function getRedemptionFeeWithDecay(uint _ETHDrawn) external view override returns (uint) {\r\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _ETHDrawn);\r\n    }\r\n\r\n    function _calcRedemptionFee(uint _redemptionRate, uint _ETHDrawn) internal pure returns (uint) {\r\n        uint redemptionFee = _redemptionRate.mul(_ETHDrawn).div(DECIMAL_PRECISION);\r\n        require(redemptionFee < _ETHDrawn, \"TroveManager: Fee would eat up all returned collateral\");\r\n        return redemptionFee;\r\n    }\r\n\r\n    // --- Borrowing fee functions ---\r\n\r\n    function getBorrowingRate() public view override returns (uint) {\r\n        return _calcBorrowingRate(baseRate);\r\n    }\r\n\r\n    function getBorrowingRateWithDecay() public view override returns (uint) {\r\n        return _calcBorrowingRate(_calcDecayedBaseRate());\r\n    }\r\n\r\n    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {\r\n        return LiquityMath._min(\r\n            BORROWING_FEE_FLOOR.add(_baseRate),\r\n            MAX_BORROWING_FEE\r\n        );\r\n    }\r\n\r\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\r\n        return _calcBorrowingFee(getBorrowingRate(), _LUSDDebt);\r\n    }\r\n\r\n    function getBorrowingFeeWithDecay(uint _LUSDDebt) external view override returns (uint) {\r\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _LUSDDebt);\r\n    }\r\n\r\n    function _calcBorrowingFee(uint _borrowingRate, uint _LUSDDebt) internal pure returns (uint) {\r\n        return _borrowingRate.mul(_LUSDDebt).div(DECIMAL_PRECISION);\r\n    }\r\n\r\n\r\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\r\n    function decayBaseRateFromBorrowing() external override {\r\n        _requireCallerIsBorrowerOperations();\r\n\r\n        uint decayedBaseRate = _calcDecayedBaseRate();\r\n        assert(decayedBaseRate <= DECIMAL_PRECISION);  // The baseRate can decay to 0\r\n\r\n        baseRate = decayedBaseRate;\r\n        emit BaseRateUpdated(decayedBaseRate);\r\n\r\n        _updateLastFeeOpTime();\r\n    }\r\n\r\n    // --- Internal fee functions ---\r\n\r\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\r\n    function _updateLastFeeOpTime() internal {\r\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\r\n\r\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\r\n            lastFeeOperationTime = block.timestamp;\r\n            emit LastFeeOpTimeUpdated(block.timestamp);\r\n        }\r\n    }\r\n\r\n    function _calcDecayedBaseRate() internal view returns (uint) {\r\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\r\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\r\n\r\n        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);\r\n    }\r\n\r\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\r\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\r\n    }\r\n\r\n    // --- 'require' wrapper functions ---\r\n\r\n    function _requireCallerIsBorrowerOperations() internal view {\r\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\r\n    }\r\n\r\n    function _requireTroveIsActive(address _borrower) internal view {\r\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\r\n    }\r\n\r\n    function _requireLUSDBalanceCoversRedemption(ILUSDToken _lusdToken, address _redeemer, uint _amount) internal view {\r\n        require(_lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\r\n    }\r\n\r\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\r\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\r\n    }\r\n\r\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\r\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\r\n    }\r\n\r\n    function _requireTCRoverMCR(uint _price) internal view {\r\n        require(_getTCR(_price) >= MCR, \"TroveManager: Cannot redeem when TCR < MCR\");\r\n    }\r\n\r\n    function _requireAfterBootstrapPeriod() internal view {\r\n        uint systemDeploymentTime = lqtyToken.getDeploymentStartTime();\r\n        require(block.timestamp >= systemDeploymentTime.add(BOOTSTRAP_PERIOD), \"TroveManager: Redemptions are not allowed during bootstrap phase\");\r\n    }\r\n\r\n    function _requireValidMaxFeePercentage(uint _maxFeePercentage) internal pure {\r\n        require(_maxFeePercentage >= REDEMPTION_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\r\n            \"Max fee percentage must be between 0.5% and 100%\");\r\n    }\r\n\r\n    // --- Trove property getters ---\r\n\r\n    function getTroveStatus(address _borrower) external view override returns (uint) {\r\n        return uint(Troves[_borrower].status);\r\n    }\r\n\r\n    function getTroveStake(address _borrower) external view override returns (uint) {\r\n        return Troves[_borrower].stake;\r\n    }\r\n\r\n    function getTroveDebt(address _borrower) external view override returns (uint) {\r\n        return Troves[_borrower].debt;\r\n    }\r\n\r\n    function getTroveColl(address _borrower) external view override returns (uint) {\r\n        return Troves[_borrower].coll;\r\n    }\r\n\r\n    // --- Trove property setters, called by BorrowerOperations ---\r\n\r\n    function setTroveStatus(address _borrower, uint _num) external override {\r\n        _requireCallerIsBorrowerOperations();\r\n        Troves[_borrower].status = Status(_num);\r\n    }\r\n\r\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\r\n        _requireCallerIsBorrowerOperations();\r\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\r\n        Troves[_borrower].coll = newColl;\r\n        return newColl;\r\n    }\r\n\r\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\r\n        _requireCallerIsBorrowerOperations();\r\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\r\n        Troves[_borrower].coll = newColl;\r\n        return newColl;\r\n    }\r\n\r\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\r\n        _requireCallerIsBorrowerOperations();\r\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\r\n        Troves[_borrower].debt = newDebt;\r\n        return newDebt;\r\n    }\r\n\r\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\r\n        _requireCallerIsBorrowerOperations();\r\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\r\n        Troves[_borrower].debt = newDebt;\r\n        return newDebt;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Interfaces/IBorrowerOperations.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n// Common interface for the Trove Manager.\r\ninterface IBorrowerOperations {\r\n\r\n    // --- Events ---\r\n\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolAddressChanged(address _activePoolAddress);\r\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\r\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\r\n    event GasPoolAddressChanged(address _gasPoolAddress);\r\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\r\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\r\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\r\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\r\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\r\n\r\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\r\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\r\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\r\n\r\n    // --- Functions ---\r\n\r\n    function setAddresses(\r\n        address _troveManagerAddress,\r\n        address _activePoolAddress,\r\n        address _defaultPoolAddress,\r\n        address _stabilityPoolAddress,\r\n        address _gasPoolAddress,\r\n        address _collSurplusPoolAddress,\r\n        address _priceFeedAddress,\r\n        address _sortedTrovesAddress,\r\n        address _lusdTokenAddress,\r\n        address _lqtyStakingAddress\r\n    ) external;\r\n\r\n    function openTrove(uint _maxFee, uint _LUSDAmount, address _upperHint, address _lowerHint) external payable;\r\n\r\n    function addColl(address _upperHint, address _lowerHint) external payable;\r\n\r\n    function moveETHGainToTrove(address _user, address _upperHint, address _lowerHint) external payable;\r\n\r\n    function withdrawColl(uint _amount, address _upperHint, address _lowerHint) external;\r\n\r\n    function withdrawLUSD(uint _maxFee, uint _amount, address _upperHint, address _lowerHint) external;\r\n\r\n    function repayLUSD(uint _amount, address _upperHint, address _lowerHint) external;\r\n\r\n    function closeTrove() external;\r\n\r\n    function adjustTrove(uint _maxFee, uint _collWithdrawal, uint _debtChange, bool isDebtIncrease, address _upperHint, address _lowerHint) external payable;\r\n\r\n    function claimCollateral() external;\r\n\r\n    function getCompositeDebt(uint _debt) external pure returns (uint);\r\n}\r\n\r\n\r\n// File contracts/SortedTroves.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n* A sorted doubly linked list with nodes sorted in descending order.\r\n*\r\n* Nodes map to active Troves in the system - the ID property is the address of a Trove owner.\r\n* Nodes are ordered according to their current nominal individual collateral ratio (NICR),\r\n* which is like the ICR but without the price, i.e., just collateral / debt.\r\n*\r\n* The list optionally accepts insert position hints.\r\n*\r\n* NICRs are computed dynamically at runtime, and not stored on the Node. This is because NICRs of active Troves\r\n* change dynamically as liquidation events occur.\r\n*\r\n* The list relies on the fact that liquidation events preserve ordering: a liquidation decreases the NICRs of all active Troves,\r\n* but maintains their order. A node inserted based on current NICR will maintain the correct position,\r\n* relative to it's peers, as rewards accumulate, as long as it's raw collateral and debt have not changed.\r\n* Thus, Nodes remain sorted by current NICR.\r\n*\r\n* Nodes need only be re-inserted upon a Trove operation - when the owner adds or removes collateral or debt\r\n* to their position.\r\n*\r\n* The list is a modification of the following audited SortedDoublyLinkedList:\r\n* https://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol\r\n*\r\n*\r\n* Changes made in the Liquity implementation:\r\n*\r\n* - Keys have been removed from nodes\r\n*\r\n* - Ordering checks for insertion are performed by comparing an NICR argument to the current NICR, calculated at runtime.\r\n*   The list relies on the property that ordering by ICR is maintained as the ETH:USD price varies.\r\n*\r\n* - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access\r\n*/\r\ncontract SortedTroves is Ownable, CheckContract, ISortedTroves {\r\n    using SafeMath for uint256;\r\n\r\n    string constant public NAME = \"SortedTroves\";\r\n\r\n    event TroveManagerAddressChanged(address _troveManagerAddress);\r\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\r\n    event NodeAdded(address _id, uint _NICR);\r\n    event NodeRemoved(address _id);\r\n\r\n    address public borrowerOperationsAddress;\r\n\r\n    ITroveManager public troveManager;\r\n\r\n    // Information for a node in the list\r\n    struct Node {\r\n        bool exists;\r\n        address nextId;                  // Id of next node (smaller NICR) in the list\r\n        address prevId;                  // Id of previous node (larger NICR) in the list\r\n    }\r\n\r\n    // Information for the list\r\n    struct Data {\r\n        address head;                        // Head of the list. Also the node in the list with the largest NICR\r\n        address tail;                        // Tail of the list. Also the node in the list with the smallest NICR\r\n        uint256 maxSize;                     // Maximum size of the list\r\n        uint256 size;                        // Current size of the list\r\n        mapping (address => Node) nodes;     // Track the corresponding ids for each node in the list\r\n    }\r\n\r\n    Data public data;\r\n\r\n    // --- Dependency setters ---\r\n\r\n    function setParams(uint256 _size, address _troveManagerAddress, address _borrowerOperationsAddress) external override onlyOwner {\r\n        require(_size > 0, \"SortedTroves: Size can’t be zero\");\r\n        checkContract(_troveManagerAddress);\r\n        checkContract(_borrowerOperationsAddress);\r\n\r\n        data.maxSize = _size;\r\n\r\n        troveManager = ITroveManager(_troveManagerAddress);\r\n        borrowerOperationsAddress = _borrowerOperationsAddress;\r\n\r\n        emit TroveManagerAddressChanged(_troveManagerAddress);\r\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\r\n\r\n        _renounceOwnership();\r\n    }\r\n\r\n    /*\r\n     * @dev Add a node to the list\r\n     * @param _id Node's id\r\n     * @param _NICR Node's NICR\r\n     * @param _prevId Id of previous node for the insert position\r\n     * @param _nextId Id of next node for the insert position\r\n     */\r\n\r\n    function insert (address _id, uint256 _NICR, address _prevId, address _nextId) external override {\r\n        ITroveManager troveManagerCached = troveManager;\r\n\r\n        _requireCallerIsBOorTroveM(troveManagerCached);\r\n        _insert(troveManagerCached, _id, _NICR, _prevId, _nextId);\r\n    }\r\n\r\n    function _insert(ITroveManager _troveManager, address _id, uint256 _NICR, address _prevId, address _nextId) internal {\r\n        // List must not be full\r\n        require(!isFull(), \"SortedTroves: List is full\");\r\n        // List must not already contain node\r\n        require(!contains(_id), \"SortedTroves: List already contains the node\");\r\n        // Node id must not be null\r\n        require(_id != address(0), \"SortedTroves: Id cannot be zero\");\r\n        // NICR must be non-zero\r\n        require(_NICR > 0, \"SortedTroves: NICR must be positive\");\r\n\r\n        address prevId = _prevId;\r\n        address nextId = _nextId;\r\n\r\n        if (!_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\r\n            // Sender's hint was not a valid insert position\r\n            // Use sender's hint to find a valid insert position\r\n            (prevId, nextId) = _findInsertPosition(_troveManager, _NICR, prevId, nextId);\r\n        }\r\n\r\n         data.nodes[_id].exists = true;\r\n\r\n        if (prevId == address(0) && nextId == address(0)) {\r\n            // Insert as head and tail\r\n            data.head = _id;\r\n            data.tail = _id;\r\n        } else if (prevId == address(0)) {\r\n            // Insert before `prevId` as the head\r\n            data.nodes[_id].nextId = data.head;\r\n            data.nodes[data.head].prevId = _id;\r\n            data.head = _id;\r\n        } else if (nextId == address(0)) {\r\n            // Insert after `nextId` as the tail\r\n            data.nodes[_id].prevId = data.tail;\r\n            data.nodes[data.tail].nextId = _id;\r\n            data.tail = _id;\r\n        } else {\r\n            // Insert at insert position between `prevId` and `nextId`\r\n            data.nodes[_id].nextId = nextId;\r\n            data.nodes[_id].prevId = prevId;\r\n            data.nodes[prevId].nextId = _id;\r\n            data.nodes[nextId].prevId = _id;\r\n        }\r\n\r\n        data.size = data.size.add(1);\r\n        emit NodeAdded(_id, _NICR);\r\n    }\r\n\r\n    function remove(address _id) external override {\r\n        _requireCallerIsTroveManager();\r\n        _remove(_id);\r\n    }\r\n\r\n    /*\r\n     * @dev Remove a node from the list\r\n     * @param _id Node's id\r\n     */\r\n    function _remove(address _id) internal {\r\n        // List must contain the node\r\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\r\n\r\n        if (data.size > 1) {\r\n            // List contains more than a single node\r\n            if (_id == data.head) {\r\n                // The removed node is the head\r\n                // Set head to next node\r\n                data.head = data.nodes[_id].nextId;\r\n                // Set prev pointer of new head to null\r\n                data.nodes[data.head].prevId = address(0);\r\n            } else if (_id == data.tail) {\r\n                // The removed node is the tail\r\n                // Set tail to previous node\r\n                data.tail = data.nodes[_id].prevId;\r\n                // Set next pointer of new tail to null\r\n                data.nodes[data.tail].nextId = address(0);\r\n            } else {\r\n                // The removed node is neither the head nor the tail\r\n                // Set next pointer of previous node to the next node\r\n                data.nodes[data.nodes[_id].prevId].nextId = data.nodes[_id].nextId;\r\n                // Set prev pointer of next node to the previous node\r\n                data.nodes[data.nodes[_id].nextId].prevId = data.nodes[_id].prevId;\r\n            }\r\n        } else {\r\n            // List contains a single node\r\n            // Set the head and tail to null\r\n            data.head = address(0);\r\n            data.tail = address(0);\r\n        }\r\n\r\n        delete data.nodes[_id];\r\n        data.size = data.size.sub(1);\r\n        NodeRemoved(_id);\r\n    }\r\n\r\n    /*\r\n     * @dev Re-insert the node at a new position, based on its new NICR\r\n     * @param _id Node's id\r\n     * @param _newNICR Node's new NICR\r\n     * @param _prevId Id of previous node for the new insert position\r\n     * @param _nextId Id of next node for the new insert position\r\n     */\r\n    function reInsert(address _id, uint256 _newNICR, address _prevId, address _nextId) external override {\r\n        ITroveManager troveManagerCached = troveManager;\r\n\r\n        _requireCallerIsBOorTroveM(troveManagerCached);\r\n        // List must contain the node\r\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\r\n        // NICR must be non-zero\r\n        require(_newNICR > 0, \"SortedTroves: NICR must be positive\");\r\n\r\n        // Remove node from the list\r\n        _remove(_id);\r\n\r\n        _insert(troveManagerCached, _id, _newNICR, _prevId, _nextId);\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if the list contains a node\r\n     */\r\n    function contains(address _id) public view override returns (bool) {\r\n        return data.nodes[_id].exists;\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if the list is full\r\n     */\r\n    function isFull() public view override returns (bool) {\r\n        return data.size == data.maxSize;\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if the list is empty\r\n     */\r\n    function isEmpty() public view override returns (bool) {\r\n        return data.size == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the current size of the list\r\n     */\r\n    function getSize() external view override returns (uint256) {\r\n        return data.size;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the maximum size of the list\r\n     */\r\n    function getMaxSize() external view override returns (uint256) {\r\n        return data.maxSize;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the first node in the list (node with the largest NICR)\r\n     */\r\n    function getFirst() external view override returns (address) {\r\n        return data.head;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the last node in the list (node with the smallest NICR)\r\n     */\r\n    function getLast() external view override returns (address) {\r\n        return data.tail;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the next node (with a smaller NICR) in the list for a given node\r\n     * @param _id Node's id\r\n     */\r\n    function getNext(address _id) external view override returns (address) {\r\n        return data.nodes[_id].nextId;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the previous node (with a larger NICR) in the list for a given node\r\n     * @param _id Node's id\r\n     */\r\n    function getPrev(address _id) external view override returns (address) {\r\n        return data.nodes[_id].prevId;\r\n    }\r\n\r\n    /*\r\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given NICR\r\n     * @param _NICR Node's NICR\r\n     * @param _prevId Id of previous node for the insert position\r\n     * @param _nextId Id of next node for the insert position\r\n     */\r\n    function validInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view override returns (bool) {\r\n        return _validInsertPosition(troveManager, _NICR, _prevId, _nextId);\r\n    }\r\n\r\n    function _validInsertPosition(ITroveManager _troveManager, uint256 _NICR, address _prevId, address _nextId) internal view returns (bool) {\r\n        if (_prevId == address(0) && _nextId == address(0)) {\r\n            // `(null, null)` is a valid insert position if the list is empty\r\n            return isEmpty();\r\n        } else if (_prevId == address(0)) {\r\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\r\n            return data.head == _nextId && _NICR >= _troveManager.getNominalICR(_nextId);\r\n        } else if (_nextId == address(0)) {\r\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\r\n            return data.tail == _prevId && _NICR <= _troveManager.getNominalICR(_prevId);\r\n        } else {\r\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_NICR` falls between the two nodes' NICRs\r\n            return data.nodes[_prevId].nextId == _nextId &&\r\n                   _troveManager.getNominalICR(_prevId) >= _NICR &&\r\n                   _NICR >= _troveManager.getNominalICR(_nextId);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Descend the list (larger NICRs to smaller NICRs) to find a valid insert position\r\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD’s\r\n     * @param _NICR Node's NICR\r\n     * @param _startId Id of node to start descending the list from\r\n     */\r\n    function _descendList(ITroveManager _troveManager, uint256 _NICR, address _startId) internal view returns (address, address) {\r\n        // If `_startId` is the head, check if the insert position is before the head\r\n        if (data.head == _startId && _NICR >= _troveManager.getNominalICR(_startId)) {\r\n            return (address(0), _startId);\r\n        }\r\n\r\n        address prevId = _startId;\r\n        address nextId = data.nodes[prevId].nextId;\r\n\r\n        // Descend the list until we reach the end or until we find a valid insert position\r\n        while (prevId != address(0) && !_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\r\n            prevId = data.nodes[prevId].nextId;\r\n            nextId = data.nodes[prevId].nextId;\r\n        }\r\n\r\n        return (prevId, nextId);\r\n    }\r\n\r\n    /*\r\n     * @dev Ascend the list (smaller NICRs to larger NICRs) to find a valid insert position\r\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD’s\r\n     * @param _NICR Node's NICR\r\n     * @param _startId Id of node to start ascending the list from\r\n     */\r\n    function _ascendList(ITroveManager _troveManager, uint256 _NICR, address _startId) internal view returns (address, address) {\r\n        // If `_startId` is the tail, check if the insert position is after the tail\r\n        if (data.tail == _startId && _NICR <= _troveManager.getNominalICR(_startId)) {\r\n            return (_startId, address(0));\r\n        }\r\n\r\n        address nextId = _startId;\r\n        address prevId = data.nodes[nextId].prevId;\r\n\r\n        // Ascend the list until we reach the end or until we find a valid insertion point\r\n        while (nextId != address(0) && !_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\r\n            nextId = data.nodes[nextId].prevId;\r\n            prevId = data.nodes[nextId].prevId;\r\n        }\r\n\r\n        return (prevId, nextId);\r\n    }\r\n\r\n    /*\r\n     * @dev Find the insert position for a new node with the given NICR\r\n     * @param _NICR Node's NICR\r\n     * @param _prevId Id of previous node for the insert position\r\n     * @param _nextId Id of next node for the insert position\r\n     */\r\n    function findInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view override returns (address, address) {\r\n        return _findInsertPosition(troveManager, _NICR, _prevId, _nextId);\r\n    }\r\n\r\n    function _findInsertPosition(ITroveManager _troveManager, uint256 _NICR, address _prevId, address _nextId) internal view returns (address, address) {\r\n        address prevId = _prevId;\r\n        address nextId = _nextId;\r\n\r\n        if (prevId != address(0)) {\r\n            if (!contains(prevId) || _NICR > _troveManager.getNominalICR(prevId)) {\r\n                // `prevId` does not exist anymore or now has a smaller NICR than the given NICR\r\n                prevId = address(0);\r\n            }\r\n        }\r\n\r\n        if (nextId != address(0)) {\r\n            if (!contains(nextId) || _NICR < _troveManager.getNominalICR(nextId)) {\r\n                // `nextId` does not exist anymore or now has a larger NICR than the given NICR\r\n                nextId = address(0);\r\n            }\r\n        }\r\n\r\n        if (prevId == address(0) && nextId == address(0)) {\r\n            // No hint - descend list starting from head\r\n            return _descendList(_troveManager, _NICR, data.head);\r\n        } else if (prevId == address(0)) {\r\n            // No `prevId` for hint - ascend list starting from `nextId`\r\n            return _ascendList(_troveManager, _NICR, nextId);\r\n        } else if (nextId == address(0)) {\r\n            // No `nextId` for hint - descend list starting from `prevId`\r\n            return _descendList(_troveManager, _NICR, prevId);\r\n        } else {\r\n            // Descend list starting from `prevId`\r\n            return _descendList(_troveManager, _NICR, prevId);\r\n        }\r\n    }\r\n\r\n    // --- 'require' functions ---\r\n\r\n    function _requireCallerIsTroveManager() internal view {\r\n        require(msg.sender == address(troveManager), \"SortedTroves: Caller is not the TroveManager\");\r\n    }\r\n\r\n    function _requireCallerIsBOorTroveM(ITroveManager _troveManager) internal view {\r\n        require(msg.sender == borrowerOperationsAddress || msg.sender == address(_troveManager),\r\n                \"SortedTroves: Caller is neither BO nor TroveM\");\r\n    }\r\n}\r\n\r\n\r\n// File contracts/MultiTroveGetter.sol\r\n\r\n\r\npragma solidity 0.6.11;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/*  Helper contract for grabbing Trove data for the front end. Not part of the core Liquity system. */\r\ncontract MultiTroveGetter {\r\n    struct CombinedTroveData {\r\n        address owner;\r\n\r\n        uint debt;\r\n        uint coll;\r\n        uint stake;\r\n\r\n        uint snapshotETH;\r\n        uint snapshotLUSDDebt;\r\n    }\r\n\r\n    TroveManager public troveManager; // XXX Troves missing from ITroveManager?\r\n    ISortedTroves public sortedTroves;\r\n\r\n    constructor(TroveManager _troveManager, ISortedTroves _sortedTroves) public {\r\n        troveManager = _troveManager;\r\n        sortedTroves = _sortedTroves;\r\n    }\r\n\r\n    function getMultipleSortedTroves(int _startIdx, uint _count)\r\n        external view returns (CombinedTroveData[] memory _troves)\r\n    {\r\n        uint startIdx;\r\n        bool descend;\r\n\r\n        if (_startIdx >= 0) {\r\n            startIdx = uint(_startIdx);\r\n            descend = true;\r\n        } else {\r\n            startIdx = uint(-(_startIdx + 1));\r\n            descend = false;\r\n        }\r\n\r\n        uint sortedTrovesSize = sortedTroves.getSize();\r\n\r\n        if (startIdx >= sortedTrovesSize) {\r\n            _troves = new CombinedTroveData[](0);\r\n        } else {\r\n            uint maxCount = sortedTrovesSize - startIdx;\r\n\r\n            if (_count > maxCount) {\r\n                _count = maxCount;\r\n            }\r\n\r\n            if (descend) {\r\n                _troves = _getMultipleSortedTrovesFromHead(startIdx, _count);\r\n            } else {\r\n                _troves = _getMultipleSortedTrovesFromTail(startIdx, _count);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getMultipleSortedTrovesFromHead(uint _startIdx, uint _count)\r\n        internal view returns (CombinedTroveData[] memory _troves)\r\n    {\r\n        address currentTroveowner = sortedTroves.getFirst();\r\n\r\n        for (uint idx = 0; idx < _startIdx; ++idx) {\r\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\r\n        }\r\n\r\n        _troves = new CombinedTroveData[](_count);\r\n\r\n        for (uint idx = 0; idx < _count; ++idx) {\r\n            _troves[idx].owner = currentTroveowner;\r\n            (\r\n                _troves[idx].debt,\r\n                _troves[idx].coll,\r\n                _troves[idx].stake,\r\n                /* status */,\r\n                /* arrayIndex */\r\n            ) = troveManager.Troves(currentTroveowner);\r\n            (\r\n                _troves[idx].snapshotETH,\r\n                _troves[idx].snapshotLUSDDebt\r\n            ) = troveManager.rewardSnapshots(currentTroveowner);\r\n\r\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\r\n        }\r\n    }\r\n\r\n    function _getMultipleSortedTrovesFromTail(uint _startIdx, uint _count)\r\n        internal view returns (CombinedTroveData[] memory _troves)\r\n    {\r\n        address currentTroveowner = sortedTroves.getLast();\r\n\r\n        for (uint idx = 0; idx < _startIdx; ++idx) {\r\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\r\n        }\r\n\r\n        _troves = new CombinedTroveData[](_count);\r\n\r\n        for (uint idx = 0; idx < _count; ++idx) {\r\n            _troves[idx].owner = currentTroveowner;\r\n            (\r\n                _troves[idx].debt,\r\n                _troves[idx].coll,\r\n                _troves[idx].stake,\r\n                /* status */,\r\n                /* arrayIndex */\r\n            ) = troveManager.Troves(currentTroveowner);\r\n            (\r\n                _troves[idx].snapshotETH,\r\n                _troves[idx].snapshotLUSDDebt\r\n            ) = troveManager.rewardSnapshots(currentTroveowner);\r\n\r\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract TroveManager\",\"name\":\"_troveManager\",\"type\":\"address\"},{\"internalType\":\"contract ISortedTroves\",\"name\":\"_sortedTroves\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_startIdx\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"getMultipleSortedTroves\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"snapshotETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"snapshotLUSDDebt\",\"type\":\"uint256\"}],\"internalType\":\"struct MultiTroveGetter.CombinedTroveData[]\",\"name\":\"_troves\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sortedTroves\",\"outputs\":[{\"internalType\":\"contract ISortedTroves\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"troveManager\",\"outputs\":[{\"internalType\":\"contract TroveManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MultiTroveGetter","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"000000000000000000000000a39739ef8b0231dbfa0dcda07d7e29faabcf4bb20000000000000000000000008fdd3fbfeb32b28fb73555518f8b361bcea741a6","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f7a87fd7b211695e21a65b3577c3e55e1725ae3f66d9aed8cafbf4c865fffefa"}]}