{"status":"1","message":"OK","result":[{"SourceCode":"// File: lib/ReentrancyGuard.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.12;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () public {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n// File: iface/IPTokenFactory.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IPTokenFactory {\r\n    function getGovernance() external view returns(address);\r\n    function getPTokenOperator(address contractAddress) external view returns(bool);\r\n    function getPTokenAuthenticity(address pToken) external view returns(bool);\r\n}\r\n// File: iface/IParasset.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IParasset {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function destroy(uint256 amount, address account) external;\r\n    function issuance(uint256 amount, address account) external;\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n// File: PToken.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\n\r\n\r\n\r\ncontract PToken is IParasset {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n    uint256 public _totalSupply = 0;                                        \r\n    string public name = \"\";\r\n    string public symbol = \"\";\r\n    uint8 public decimals = 18;\r\n\r\n    IPTokenFactory pTokenFactory;\r\n\r\n    constructor (string memory _name, \r\n                 string memory _symbol) public {\r\n    \tname = _name;                                                               \r\n    \tsymbol = _symbol;\r\n    \tpTokenFactory = IPTokenFactory(address(msg.sender));\r\n    }\r\n\r\n    //---------modifier---------\r\n\r\n    modifier onlyGovernance() {\r\n        require(address(msg.sender) == pTokenFactory.getGovernance(), \"Log:PToken:!governance\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPool() {\r\n    \trequire(pTokenFactory.getPTokenOperator(address(msg.sender)), \"Log:PToken:!Pool\");\r\n    \t_;\r\n    }\r\n\r\n    //---------view---------\r\n\r\n    // Query factory contract address\r\n    function getPTokenFactory() public view returns(address) {\r\n        return address(pTokenFactory);\r\n    }\r\n\r\n    /// @notice The view of totalSupply\r\n    /// @return The total supply of ntoken\r\n    function totalSupply() override public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /// @dev The view of balances\r\n    /// @param owner The address of an account\r\n    /// @return The balance of the account\r\n    function balanceOf(address owner) override public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) override public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    //---------transaction---------\r\n\r\n    function changeFactory(address factory) public onlyGovernance {\r\n        pTokenFactory = IPTokenFactory(address(factory));\r\n    }\r\n\r\n    function transfer(address to, uint256 value) override public returns (bool) \r\n    {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 value) override public returns (bool) \r\n    {\r\n        require(spender != address(0));\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) override public returns (bool) \r\n    {\r\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) \r\n    {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) \r\n    {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function destroy(uint256 amount, address account) override external onlyPool{\r\n    \trequire(_balances[account] >= amount, \"Log:PToken:!destroy\");\r\n    \t_balances[account] = _balances[account].sub(amount);\r\n    \t_totalSupply = _totalSupply.sub(amount);\r\n    \temit Transfer(account, address(0x0), amount);\r\n    }\r\n\r\n    function issuance(uint256 amount, address account) override external onlyPool{\r\n    \t_balances[account] = _balances[account].add(amount);\r\n    \t_totalSupply = _totalSupply.add(amount);\r\n    \temit Transfer(address(0x0), account, amount);\r\n    }\r\n}\r\n// File: iface/IMortgagePool.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IMortgagePool {\r\n    function create(address pToken, address insurance, address underlying) external;\r\n    function getUnderlyingToPToken(address uToken) external view returns(address);\r\n    function getPTokenToUnderlying(address pToken) external view returns(address);\r\n    function getGovernance() external view returns(address);\r\n}\r\n// File: iface/IERC20.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IERC20 {\r\n\tfunction decimals() external view returns (uint8);\r\n\tfunction name() external view returns (string memory);\r\n\tfunction symbol() external view returns (string memory);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n// File: lib/Address.sol\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{value:amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n// File: lib/SafeERC20.sol\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    function callOptionalReturn(ERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n// File: lib/TransferHelper.sol\r\n\r\n\r\npragma solidity ^0.6.12;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n// File: lib/SafeMath.sol\r\n\r\n\r\npragma solidity ^0.6.12;\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n\r\n    function div(uint x, uint y) internal pure returns (uint z) {\r\n        require(y > 0, \"ds-math-div-zero\");\r\n        z = x / y;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    }\r\n}\r\n// File: InsurancePool.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\ncontract InsurancePool is ReentrancyGuard {\r\n\tusing SafeMath for uint256;\r\n\tusing SafeERC20 for ERC20;\r\n\r\n\t// Governance address\r\n\taddress public governance;\r\n\t// Underlying asset address => negative account funds\r\n\tmapping(address=>uint256) insNegative;\r\n\t// Underlying asset address => total LP\r\n\tmapping(address=>uint256) totalSupply;\r\n\t// Underlying asset address => latest redemption time\r\n    mapping(address=>uint256) latestTime;\r\n\t// Redemption cycle, 14 days\r\n\tuint256 public redemptionCycle = 15 minutes;\r\n\t// Redemption duration, 2 days\r\n\tuint256 public waitCycle = 30 minutes;\r\n    // User address => Underlying asset address => LP quantity\r\n    mapping(address=>mapping(address=>uint256)) balances;\r\n\t// User address => Underlying asset address => Freeze LP data\r\n\tmapping(address=>mapping(address=>Frozen)) frozenIns;\r\n\tstruct Frozen {\r\n\t\tuint256 amount;\t\t\t\t\t\t\t// Frozen quantity\r\n\t\tuint256 time;\t\t\t\t\t\t\t// Freezing time\r\n\t}\r\n    // Mortgage pool address\r\n    IMortgagePool mortgagePool;\r\n    // PTokenFactory address\r\n    IPTokenFactory pTokenFactory;\r\n    // Status\r\n    uint8 public flag;      // = 0: pause\r\n                            // = 1: active\r\n                            // = 2: redemption only\r\n    // Rate(2/1000)\r\n    uint256 feeRate = 2;\r\n\r\n    event Destroy(address token, uint256 amount, address account);\r\n    event Issuance(address token, uint256 amount, address account);\r\n    event Negative(address token, uint256 amount, uint256 allValue);\r\n\r\n    /// @dev Initialization method\r\n    /// @param factoryAddress PTokenFactory address\r\n\tconstructor (address factoryAddress) public {\r\n        pTokenFactory = IPTokenFactory(factoryAddress);\r\n        governance = pTokenFactory.getGovernance();\r\n        flag = 0;\r\n    }\r\n\r\n\t//---------modifier---------\r\n\r\n    modifier onlyGovernance() {\r\n        require(msg.sender == governance, \"Log:InsurancePool:!gov\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyMortgagePool() {\r\n        require(msg.sender == address(mortgagePool), \"Log:InsurancePool:!mortgagePool\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyGovOrMor() {\r\n        require(msg.sender == governance || msg.sender == address(mortgagePool), \"Log:InsurancePool:!onlyGovOrMor\");\r\n        _;\r\n    }\r\n\r\n    modifier whenActive() {\r\n        require(flag == 1, \"Log:InsurancePool:!active\");\r\n        _;\r\n    }\r\n\r\n    modifier redemptionOnly() {\r\n        require(flag != 0, \"Log:InsurancePool:!0\");\r\n        _;\r\n    }\r\n\r\n    //---------view---------\r\n\r\n    /// @dev View governance address\r\n    /// @return governance address\r\n    function getGovernance() external view returns(address) {\r\n        return governance;\r\n    }\r\n\r\n    /// @dev View negative ledger\r\n    /// @param token underlying asset address\r\n    /// @return negative ledger\r\n    function getInsNegative(address token) external view returns(uint256) {\r\n        return insNegative[token];\r\n    }\r\n\r\n    /// @dev View total LP\r\n    /// @param token underlying asset address\r\n    /// @return total LP\r\n    function getTotalSupply(address token) external view returns(uint256) {\r\n        return totalSupply[token];\r\n    }\r\n\r\n    /// @dev View personal LP\r\n    /// @param token underlying asset address\r\n    /// @param add user address\r\n    /// @return personal LP\r\n    function getBalances(address token, \r\n                         address add) external view returns(uint256) {\r\n        return balances[add][token];\r\n    }\r\n\r\n    /// @dev View rate\r\n    /// @return rate\r\n    function getFeeRate() external view returns(uint256) {\r\n        return feeRate;\r\n    }\r\n\r\n    /// @dev View mortgage pool address\r\n    /// @return mortgage pool address\r\n    function getMortgagePool() external view returns(address) {\r\n        return address(mortgagePool);\r\n    }\r\n\r\n    /// @dev View the latest redemption time\r\n    /// @param token underlying asset address\r\n    /// @return the latest redemption time\r\n    function getLatestTime(address token) external view returns(uint256) {\r\n        return latestTime[token];\r\n    }\r\n\r\n    /// @dev View redemption period, next time\r\n    /// @param token underlying asset address\r\n    /// @return startTime start time\r\n    /// @return endTime end time\r\n    function getRedemptionTime(address token) external view returns(uint256 startTime, \r\n                                                                    uint256 endTime) {\r\n        uint256 time = latestTime[token];\r\n        if (now > time) {\r\n            uint256 subTime = now.sub(time).div(waitCycle);\r\n            startTime = time.add(waitCycle.mul(uint256(1).add(subTime)));\r\n        } else {\r\n            startTime = time;\r\n        }\r\n        endTime = startTime.add(redemptionCycle);\r\n    }\r\n\r\n    /// @dev View redemption period, this period\r\n    /// @param token underlying asset address\r\n    /// @return startTime start time\r\n    /// @return endTime end time\r\n    function getRedemptionTimeFront(address token) external view returns(uint256 startTime, \r\n                                                                         uint256 endTime) {\r\n        uint256 time = latestTime[token];\r\n        if (now > time) {\r\n            uint256 subTime = now.sub(time).div(waitCycle);\r\n            startTime = time.add(waitCycle.mul(subTime));\r\n        } else {\r\n            startTime = time.sub(waitCycle);\r\n        }\r\n        endTime = startTime.add(redemptionCycle);\r\n    }\r\n\r\n    /// @dev View frozen LP and unfreeze time\r\n    /// @param token underlying asset address\r\n    /// @param add user address\r\n    /// @return frozen LP\r\n    /// @return unfreeze time\r\n    function getFrozenIns(address token, \r\n                          address add) external view returns(uint256, uint256) {\r\n        Frozen memory frozenInfo = frozenIns[add][token];\r\n        return (frozenInfo.amount, frozenInfo.time);\r\n    }\r\n\r\n    /// @dev View frozen LP and unfreeze time, real time\r\n    /// @param token underlying asset address\r\n    /// @param add user address\r\n    /// @return frozen LP\r\n    function getFrozenInsInTime(address token, \r\n                                address add) external view returns(uint256) {\r\n        Frozen memory frozenInfo = frozenIns[add][token];\r\n        if (now > frozenInfo.time) {\r\n            return 0;\r\n        }\r\n        return frozenInfo.amount;\r\n    }\r\n\r\n    /// @dev View redeemable LP, real time\r\n    /// @param token underlying asset address\r\n    /// @param add user address\r\n    /// @return redeemable LP\r\n    function getRedemptionAmount(address token, \r\n                                 address add) external view returns (uint256) {\r\n        Frozen memory frozenInfo = frozenIns[add][token];\r\n        uint256 balanceSelf = balances[add][token];\r\n        if (now > frozenInfo.time) {\r\n            return balanceSelf;\r\n        } else {\r\n            return balanceSelf.sub(frozenInfo.amount);\r\n        }\r\n    }\r\n\r\n\t/// @dev Uniform accuracy\r\n    /// @param inputToken Initial token\r\n    /// @param inputTokenAmount Amount of token\r\n    /// @param outputToken Converted token\r\n    /// @return stability Amount of outputToken\r\n    function getDecimalConversion(address inputToken, \r\n    \t                          uint256 inputTokenAmount, \r\n    \t                          address outputToken) public view returns(uint256) {\r\n    \tuint256 inputTokenDec = 18;\r\n    \tuint256 outputTokenDec = 18;\r\n    \tif (inputToken != address(0x0)) {\r\n    \t\tinputTokenDec = IERC20(inputToken).decimals();\r\n    \t}\r\n    \tif (outputToken != address(0x0)) {\r\n    \t\toutputTokenDec = IERC20(outputToken).decimals();\r\n    \t}\r\n    \treturn inputTokenAmount.mul(10**outputTokenDec).div(10**inputTokenDec);\r\n    }\r\n\r\n    //---------governance----------\r\n\r\n    /// @dev Set contract status\r\n    /// @param num 0: pause, 1: active, 2: redemption only\r\n    function setFlag(uint8 num) public onlyGovernance {\r\n        flag = num;\r\n    }\r\n\r\n    /// @dev Set mortgage pool address\r\n    function setMortgagePool(address add) public onlyGovernance {\r\n    \tmortgagePool = IMortgagePool(add);\r\n    }\r\n\r\n    /// @dev Set the latest redemption time\r\n    function setLatestTime(address token) public onlyGovOrMor {\r\n        latestTime[token] = now.add(waitCycle);\r\n    }\r\n\r\n    /// @dev Set the rate\r\n    function setFeeRate(uint256 num) public onlyGovernance {\r\n        feeRate = num;\r\n    }\r\n\r\n    /// @dev Set redemption cycle\r\n    function setRedemptionCycle(uint256 num) public onlyGovernance {\r\n        require(num > 0, \"Log:InsurancePool:!zero\");\r\n        redemptionCycle = num * 1 days;\r\n    }\r\n\r\n    /// @dev Set redemption duration\r\n    function setWaitCycle(uint256 num) public onlyGovernance {\r\n        require(num > 0, \"Log:InsurancePool:!zero\");\r\n        waitCycle = num * 1 days;\r\n    }\r\n\r\n    //---------transaction---------\r\n\r\n    /// @dev Set governance address\r\n    function setGovernance() public {\r\n        governance = pTokenFactory.getGovernance();\r\n    }\r\n\r\n    /// @dev Exchange: ptoken exchanges the underlying asset\r\n    /// @param pToken ptoken address\r\n    /// @param amount amount of ptoken\r\n    function exchangePTokenToUnderlying(address pToken, \r\n    \t                                uint256 amount) public whenActive nonReentrant {\r\n        // amount > 0\r\n        require(amount > 0, \"Log:InsurancePool:!amount\");\r\n\r\n        // Calculate the fee\r\n    \tuint256 fee = amount.mul(feeRate).div(1000);\r\n\r\n        // Transfer to the ptoken\r\n    \tERC20(pToken).safeTransferFrom(address(msg.sender), address(this), amount);\r\n\r\n        // Verify ptoken\r\n        address underlyingToken = mortgagePool.getPTokenToUnderlying(pToken);\r\n        address pToken_s = mortgagePool.getUnderlyingToPToken(underlyingToken);\r\n        require(pToken_s == pToken,\"Log:InsurancePool:!pToken\");\r\n\r\n        // Calculate the amount of transferred underlying asset\r\n        uint256 uTokenAmount = getDecimalConversion(pToken, amount.sub(fee), underlyingToken);\r\n        require(uTokenAmount > 0, \"Log:InsurancePool:!uTokenAmount\");\r\n\r\n        // Transfer out underlying asset\r\n    \tif (underlyingToken != address(0x0)) {\r\n    \t\tERC20(underlyingToken).safeTransfer(address(msg.sender), uTokenAmount);\r\n    \t} else {\r\n            TransferHelper.safeTransferETH(address(msg.sender), uTokenAmount);\r\n    \t}\r\n\r\n    \t// Eliminate negative ledger\r\n        _eliminate(pToken, underlyingToken);\r\n    }\r\n\r\n    /// @dev Exchange: underlying asset exchanges the ptoken\r\n    /// @param token underlying asset address\r\n    /// @param amount amount of underlying asset\r\n    function exchangeUnderlyingToPToken(address token, \r\n    \t                                uint256 amount) public payable whenActive nonReentrant {\r\n        // amount > 0\r\n        require(amount > 0, \"Log:InsurancePool:!amount\");\r\n\r\n        // Calculate the fee\r\n    \tuint256 fee = amount.mul(feeRate).div(1000);\r\n\r\n        // Transfer to the underlying asset\r\n    \tif (token != address(0x0)) {\r\n            // The underlying asset is ERC20\r\n    \t\trequire(msg.value == 0, \"Log:InsurancePool:msg.value!=0\");\r\n    \t\tERC20(token).safeTransferFrom(address(msg.sender), address(this), amount);\r\n    \t} else {\r\n            // The underlying asset is ETH\r\n    \t\trequire(msg.value == amount, \"Log:InsurancePool:!msg.value\");\r\n    \t}\r\n\r\n        // Calculate the amount of transferred ptokens\r\n    \taddress pToken = mortgagePool.getUnderlyingToPToken(token);\r\n        uint256 pTokenAmount = getDecimalConversion(token, amount.sub(fee), pToken);\r\n        require(pTokenAmount > 0, \"Log:InsurancePool:!pTokenAmount\");\r\n\r\n        // Transfer out ptoken\r\n        uint256 pTokenBalance = ERC20(pToken).balanceOf(address(this));\r\n        if (pTokenBalance < pTokenAmount) {\r\n            // Insufficient ptoken balance,\r\n            uint256 subNum = pTokenAmount.sub(pTokenBalance);\r\n            PToken(pToken).issuance(subNum, address(this));\r\n            insNegative[token] = insNegative[token].add(subNum);\r\n        }\r\n    \tERC20(pToken).safeTransfer(address(msg.sender), pTokenAmount);\r\n    }\r\n\r\n    /// @dev Subscribe for insurance\r\n    /// @param token underlying asset address\r\n    /// @param amount amount of underlying asset\r\n    function subscribeIns(address token, \r\n    \t                  uint256 amount) public payable whenActive nonReentrant {\r\n        // amount > 0\r\n        require(amount > 0, \"Log:InsurancePool:!amount\");\r\n\r\n        // Verify ptoken\r\n        address pToken = mortgagePool.getUnderlyingToPToken(token);\r\n        require(pToken != address(0x0), \"Log:InsurancePool:!pToken\");\r\n\r\n        // Update redemption time\r\n    \tupdateLatestTime(token);\r\n\r\n        // Thaw LP\r\n    \tFrozen storage frozenInfo = frozenIns[address(msg.sender)][token];\r\n    \tif (now > frozenInfo.time) {\r\n    \t\tfrozenInfo.amount = 0;\r\n    \t}\r\n\r\n        // ptoken balance \r\n    \tuint256 pTokenBalance = ERC20(pToken).balanceOf(address(this));\r\n        // underlying asset balance\r\n        uint256 tokenBalance;\r\n    \tif (token != address(0x0)) {\r\n            // Underlying asset conversion 18 decimals\r\n    \t\ttokenBalance = getDecimalConversion(token, ERC20(token).balanceOf(address(this)), pToken);\r\n    \t} else {\r\n            // The amount of ETH involved in the calculation does not include the transfer in this time\r\n    \t\trequire(msg.value == amount, \"Log:InsurancePool:!msg.value\");\r\n    \t\ttokenBalance = address(this).balance.sub(amount);\r\n    \t}\r\n\r\n        // Calculate LP\r\n    \tuint256 insAmount = 0;\r\n    \tuint256 insTotal = totalSupply[token];\r\n        // Insurance pool assets must be greater than 0\r\n        uint256 allBalance = tokenBalance.add(pTokenBalance);\r\n        require(allBalance > insNegative[token], \"Log:InsurancePool:allBalanceNotEnough\");\r\n    \tif (insTotal != 0) {\r\n            uint256 allValue = allBalance.sub(insNegative[token]);\r\n    \t\tinsAmount = getDecimalConversion(token, amount, pToken).mul(insTotal).div(allValue);\r\n    \t} else {\r\n            // The initial net value is 1\r\n            insAmount = getDecimalConversion(token, amount, pToken);\r\n        }\r\n\r\n    \t// Transfer to the underlying asset(ERC20)\r\n    \tif (token != address(0x0)) {\r\n    \t\trequire(msg.value == 0, \"Log:InsurancePool:msg.value!=0\");\r\n    \t\tERC20(token).safeTransferFrom(address(msg.sender), address(this), amount);\r\n    \t}\r\n\r\n    \t// Additional LP issuance\r\n    \tissuance(token, insAmount, address(msg.sender));\r\n\r\n    \t// Freeze insurance LP\r\n    \tfrozenInfo.amount = frozenInfo.amount.add(insAmount);\r\n    \tfrozenInfo.time = latestTime[token].add(waitCycle);\r\n    }\r\n\r\n    /// @dev Redemption insurance\r\n    /// @param token underlying asset address\r\n    /// @param amount redemption LP\r\n    function redemptionIns(address token, \r\n    \t                   uint256 amount) public redemptionOnly nonReentrant {\r\n        // amount > 0\r\n        require(amount > 0, \"Log:InsurancePool:!amount\");\r\n        \r\n        // Verify ptoken\r\n        address pToken = mortgagePool.getUnderlyingToPToken(token);\r\n        require(pToken != address(0x0), \"Log:InsurancePool:!pToken\");\r\n\r\n        // Update redemption time\r\n    \tupdateLatestTime(token);\r\n\r\n        // Judging the redemption time\r\n        uint256 tokenTime = latestTime[token];\r\n    \trequire(now >= tokenTime.sub(waitCycle) && now <= tokenTime.sub(waitCycle).add(redemptionCycle), \"Log:InsurancePool:!time\");\r\n\r\n        // Thaw LP\r\n    \tFrozen storage frozenInfo = frozenIns[address(msg.sender)][token];\r\n    \tif (now > frozenInfo.time) {\r\n    \t\tfrozenInfo.amount = 0;\r\n    \t}\r\n    \t\r\n        // ptoken balance\r\n    \tuint256 pTokenBalance = ERC20(pToken).balanceOf(address(this));\r\n        // underlying asset balance\r\n        uint256 tokenBalance;\r\n    \tif (token != address(0x0)) {\r\n    \t\ttokenBalance = getDecimalConversion(token, ERC20(token).balanceOf(address(this)), pToken);\r\n    \t} else {\r\n    \t\ttokenBalance = address(this).balance;\r\n    \t}\r\n\r\n        // Insurance pool assets must be greater than 0\r\n        uint256 allBalance = tokenBalance.add(pTokenBalance);\r\n        require(allBalance > insNegative[token], \"Log:InsurancePool:allBalanceNotEnough\");\r\n        // Calculated amount of assets\r\n    \tuint256 allValue = allBalance.sub(insNegative[token]);\r\n    \tuint256 insTotal = totalSupply[token];\r\n    \tuint256 underlyingAmount = amount.mul(allValue).div(insTotal);\r\n\r\n        // Destroy LP\r\n        destroy(token, amount, address(msg.sender));\r\n        // Judgment to freeze LP\r\n        require(balances[address(msg.sender)][token] >= frozenInfo.amount, \"Log:InsurancePool:frozen\");\r\n    \t\r\n    \t// Transfer out assets, priority transfer of the underlying assets, if the underlying assets are insufficient, transfer ptoken\r\n    \tif (token != address(0x0)) {\r\n            // ERC20\r\n            if (tokenBalance >= underlyingAmount) {\r\n                ERC20(token).safeTransfer(address(msg.sender), getDecimalConversion(pToken, underlyingAmount, token));\r\n            } else {\r\n                ERC20(token).safeTransfer(address(msg.sender), getDecimalConversion(pToken, tokenBalance, token));\r\n                ERC20(pToken).safeTransfer(address(msg.sender), underlyingAmount.sub(tokenBalance));\r\n            }\r\n    \t} else {\r\n            // ETH\r\n            if (tokenBalance >= underlyingAmount) {\r\n                TransferHelper.safeTransferETH(address(msg.sender), underlyingAmount);\r\n            } else {\r\n                TransferHelper.safeTransferETH(address(msg.sender), tokenBalance);\r\n                ERC20(pToken).safeTransfer(address(msg.sender), \r\n                                           underlyingAmount.sub(tokenBalance));\r\n            }\r\n    \t}\r\n    }\r\n\r\n    /// @dev Destroy ptoken, update negative ledger\r\n    /// @param pToken ptoken address\r\n    /// @param amount quantity destroyed\r\n    /// @param token underlying asset address\r\n    function destroyPToken(address pToken, \r\n    \t                   uint256 amount,\r\n                           address token) public onlyMortgagePool {\r\n    \tPToken pErc20 = PToken(pToken);\r\n    \tuint256 pTokenBalance = pErc20.balanceOf(address(this));\r\n    \tif (pTokenBalance >= amount) {\r\n    \t\tpErc20.destroy(amount, address(this));\r\n    \t} else {\r\n    \t\tpErc20.destroy(pTokenBalance, address(this));\r\n    \t\t// 记录负账户\r\n            uint256 subAmount = amount.sub(pTokenBalance);\r\n    \t\tinsNegative[token] = insNegative[token].add(subAmount);\r\n            emit Negative(pToken, subAmount, insNegative[token]);\r\n    \t}\r\n    }\r\n\r\n    /// @dev Eliminate negative ledger\r\n    /// @param pToken ptoken address\r\n    /// @param token underlying asset address\r\n    function eliminate(address pToken, \r\n                       address token) public onlyMortgagePool {\r\n    \t_eliminate(pToken, token);\r\n    }\r\n\r\n    function _eliminate(address pToken, \r\n                        address token) private {\r\n\r\n    \tPToken pErc20 = PToken(pToken);\r\n        // negative ledger\r\n    \tuint256 negative = insNegative[token];\r\n        // ptoken balance\r\n    \tuint256 pTokenBalance = pErc20.balanceOf(address(this)); \r\n    \tif (negative > 0 && pTokenBalance > 0) {\r\n    \t\tif (negative >= pTokenBalance) {\r\n                // Increase negative ledger\r\n                pErc20.destroy(pTokenBalance, address(this));\r\n    \t\t\tinsNegative[token] = insNegative[token].sub(pTokenBalance);\r\n                emit Negative(pToken, pTokenBalance, insNegative[token]);\r\n    \t\t} else {\r\n                // negative ledger = 0\r\n                pErc20.destroy(negative, address(this));\r\n    \t\t\tinsNegative[token] = 0;\r\n                emit Negative(pToken, insNegative[token], insNegative[token]);\r\n    \t\t}\r\n    \t}\r\n    }\r\n\r\n    /// @dev Update redemption time\r\n    /// @param token underlying asset address\r\n    function updateLatestTime(address token) public {\r\n        uint256 time = latestTime[token];\r\n    \tif (now > time) {\r\n    \t\tuint256 subTime = now.sub(time).div(waitCycle);\r\n    \t\tlatestTime[token] = time.add(waitCycle.mul(uint256(1).add(subTime)));\r\n    \t}\r\n    }\r\n\r\n    /// @dev Destroy LP\r\n    /// @param token underlying asset address\r\n    /// @param amount quantity destroyed\r\n    /// @param account destroy address\r\n    function destroy(address token, \r\n                     uint256 amount, \r\n                     address account) private {\r\n        require(balances[account][token] >= amount, \"Log:InsurancePool:!destroy\");\r\n        balances[account][token] = balances[account][token].sub(amount);\r\n        totalSupply[token] = totalSupply[token].sub(amount);\r\n        emit Destroy(token, amount, account);\r\n    }\r\n\r\n    /// @dev Additional LP issuance\r\n    /// @param token underlying asset address\r\n    /// @param amount additional issuance quantity\r\n    /// @param account additional issuance address\r\n    function issuance(address token, \r\n                      uint256 amount, \r\n                      address account) private {\r\n        balances[account][token] = balances[account][token].add(amount);\r\n        totalSupply[token] = totalSupply[token].add(amount);\r\n        emit Issuance(token, amount, account);\r\n    }\r\n\r\n    function takeOutERC20(address token, uint256 amount, address to) public onlyGovernance {\r\n        ERC20(token).safeTransfer(address(to), amount);\r\n    }\r\n\r\n    function takeOutETH(uint256 amount, address to) public onlyGovernance {\r\n        TransferHelper.safeTransferETH(address(to), amount);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factoryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Destroy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Issuance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allValue\",\"type\":\"uint256\"}],\"name\":\"Negative\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"destroyPToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"eliminate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"exchangePTokenToUnderlying\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"exchangeUnderlyingToPToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flag\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"getBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"}],\"name\":\"getDecimalConversion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"getFrozenIns\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"getFrozenInsInTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getInsNegative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getLatestTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMortgagePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"getRedemptionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getRedemptionTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getRedemptionTimeFront\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redemptionCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redemptionIns\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setFeeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"num\",\"type\":\"uint8\"}],\"name\":\"setFlag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setLatestTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"setMortgagePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setRedemptionCycle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setWaitCycle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"subscribeIns\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"takeOutERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"takeOutETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"updateLatestTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"waitCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"InsurancePool","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000978f0038a69a0eca925df4510e0085747744dda8","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://357bd816263ec73b22844149b8973533d9d1429d8ba2e090fa33306d028a99dc"}]}