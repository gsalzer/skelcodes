{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/sushi/APWRewarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\nimport \\\"./interfaces/IRewarder.sol\\\";\\n\\nimport \\\"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\\\";\\nimport \\\"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\\\";\\nimport \\\"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\\\";\\n\\nimport \\\"./MasterChefV2.sol\\\";\\n\\n// https://github.com/sushiswap/sushiswap/blob/master/contracts/mocks/ComplexRewarder.sol\\ncontract APWRewarder is IRewarder, BoringOwnable {\\n    using BoringMath for uint256;\\n    using BoringMath128 for uint128;\\n    using BoringERC20 for IERC20;\\n\\n    address private MASTERCHEF_V2;\\n\\n    /// @notice Info of each MCV2 user.\\n    /// `amount` LP token amount the user has provided.\\n    /// `rewardDebt` The amount of SUSHI entitled to the user.\\n    struct UserInfo {\\n        uint256 amount;\\n        uint256 rewardDebt;\\n    }\\n\\n    /// @notice Info of each MCV2 pool.\\n    /// `allocPoint` The amount of allocation points assigned to the pool.\\n    /// Also known as the amount of SUSHI to distribute per block.\\n    struct PoolInfo {\\n        uint128 accSushiPerShare;\\n        uint64 lastRewardBlock;\\n        uint64 allocPoint;\\n    }\\n\\n    /// @notice Info of each pool.\\n    mapping(uint256 => PoolInfo) public poolInfo;\\n\\n    uint256[] public poolIds;\\n\\n    /// @notice Info of each user that stakes LP tokens.\\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n    /// @dev Total allocation points. Must be the sum of all allocation points in all pools.\\n    uint256 totalAllocPoint;\\n\\n    IERC20 public rewardToken;\\n    uint256 public tokenPerBlock;\\n    uint256 private constant ACC_TOKEN_PRECISION = 1e12;\\n\\n    event TokenPerBlockSet(uint256 tokenPerBlock);\\n    event RewardClaimed(\\n        address indexed user,\\n        uint256 indexed pid,\\n        uint256 amount,\\n        address indexed to\\n    );\\n    event PoolAdded(uint256 indexed pid, uint256 allocPoint);\\n    event PoolSet(uint256 indexed pid, uint256 allocPoint);\\n    event PoolUpdated(\\n        uint256 indexed pid,\\n        uint64 lastRewardBlock,\\n        uint256 lpSupply,\\n        uint256 accSushiPerShare\\n    );\\n\\n    /* Modifiers */\\n\\n    modifier onlyMCV2 {\\n        require(msg.sender == MASTERCHEF_V2, \\\"ERR_MCV2\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice APWReward constructor\\n     * @param _MASTERCHEF_V2 Sushi MasterChefV2 address\\n     * @dev Requires further setup with setTokenPerBlock(uint256)\\n     */\\n    constructor(address _MASTERCHEF_V2, IERC20 _rewardToken) public {\\n        MASTERCHEF_V2 = _MASTERCHEF_V2;\\n        rewardToken = _rewardToken;\\n    }\\n\\n    /* Sushi IRewarder overrides */\\n\\n    function onSushiReward(\\n        uint256 _pid,\\n        address _user,\\n        address _to,\\n        uint256,\\n        uint256 _lpToken\\n    ) external override onlyMCV2 {\\n        PoolInfo memory pool = updatePool(_pid);\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 pending;\\n        if (user.amount > 0) {\\n            pending = (user.amount.mul(pool.accSushiPerShare) /\\n                ACC_TOKEN_PRECISION)\\n                .sub(user.rewardDebt);\\n            rewardToken.safeTransfer(_to, pending);\\n        }\\n        user.amount = _lpToken;\\n        user.rewardDebt =\\n            _lpToken.mul(pool.accSushiPerShare) /\\n            ACC_TOKEN_PRECISION;\\n        emit RewardClaimed(_user, _pid, pending, _to);\\n    }\\n\\n    function pendingTokens(\\n        uint256 _pid,\\n        address _user,\\n        uint256\\n    )\\n        external\\n        view\\n        override\\n        returns (IERC20[] memory rewardTokens, uint256[] memory rewardAmounts)\\n    {\\n        IERC20[] memory _rewardTokens = new IERC20[](1);\\n        _rewardTokens[0] = (rewardToken);\\n        uint256[] memory _rewardAmounts = new uint256[](1);\\n        _rewardAmounts[0] = pendingToken(_pid, _user);\\n        return (_rewardTokens, _rewardAmounts);\\n    }\\n\\n    /* Public */\\n\\n    /// @notice Returns the number of MCV2 pools.\\n    function poolLength() public view returns (uint256 pools) {\\n        pools = poolIds.length;\\n    }\\n\\n    /// @notice View function to see pending Token\\n    /// @param _pid The index of the pool. See `poolInfo`.\\n    /// @param _user Address of user.\\n    /// @return pending SUSHI reward for a given user.\\n    function pendingToken(uint256 _pid, address _user)\\n        public\\n        view\\n        returns (uint256 pending)\\n    {\\n        PoolInfo memory pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 accSushiPerShare = pool.accSushiPerShare;\\n        uint256 lpSupply =\\n            MasterChefV2(MASTERCHEF_V2).lpToken(_pid).balanceOf(MASTERCHEF_V2);\\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n            uint256 blocks = block.number.sub(pool.lastRewardBlock);\\n            uint256 sushiReward =\\n                blocks.mul(tokenPerBlock).mul(pool.allocPoint) /\\n                    totalAllocPoint;\\n            accSushiPerShare = accSushiPerShare.add(\\n                sushiReward.mul(ACC_TOKEN_PRECISION) / lpSupply\\n            );\\n        }\\n        pending = (user.amount.mul(accSushiPerShare) / ACC_TOKEN_PRECISION).sub(\\n            user.rewardDebt\\n        );\\n    }\\n\\n    /// @notice Update reward variables for all pools. Be careful of gas spending!\\n    /// @param pids Pool IDs of all to be updated. Make sure to update all active pools.\\n    function massUpdatePools(uint256[] calldata pids) external {\\n        uint256 len = pids.length;\\n        for (uint256 i = 0; i < len; ++i) {\\n            updatePool(pids[i]);\\n        }\\n    }\\n\\n    /// @notice Update reward variables for all pools registered in the contract.\\n    function updateAllPools() public {\\n        uint256 len = poolIds.length;\\n        for (uint256 i = 0; i < len; ++i) {\\n            updatePool(poolIds[i]);\\n        }\\n    }\\n\\n    /// @notice Update reward variables of the given pool.\\n    /// @param pid The index of the pool. See `poolInfo`.\\n    /// @return pool Returns the pool that was updated.\\n    function updatePool(uint256 pid) public returns (PoolInfo memory pool) {\\n        pool = poolInfo[pid];\\n        require(pool.lastRewardBlock != 0, \\\"ERR_INVALID_POOL\\\");\\n        if (block.number > pool.lastRewardBlock) {\\n            uint256 lpSupply =\\n                MasterChefV2(MASTERCHEF_V2).lpToken(pid).balanceOf(\\n                    MASTERCHEF_V2\\n                );\\n            if (lpSupply > 0) {\\n                uint256 blocks = block.number.sub(pool.lastRewardBlock);\\n                uint256 sushiReward =\\n                    blocks.mul(tokenPerBlock).mul(pool.allocPoint) /\\n                        totalAllocPoint;\\n                pool.accSushiPerShare = pool.accSushiPerShare.add(\\n                    (sushiReward.mul(ACC_TOKEN_PRECISION) / lpSupply).to128()\\n                );\\n            }\\n            pool.lastRewardBlock = block.number.to64();\\n            poolInfo[pid] = pool;\\n            emit PoolUpdated(\\n                pid,\\n                pool.lastRewardBlock,\\n                lpSupply,\\n                pool.accSushiPerShare\\n            );\\n        }\\n    }\\n\\n    /* Admin control */\\n\\n    function setTokenPerBlock(uint256 _tokenPerBlock) public onlyOwner {\\n        updateAllPools();\\n        tokenPerBlock = _tokenPerBlock;\\n        emit TokenPerBlockSet(_tokenPerBlock);\\n    }\\n\\n    function withdraw(address _token, uint256 _amount) public onlyOwner {\\n        IERC20(_token).safeTransfer(msg.sender, _amount);\\n    }\\n\\n    /// @notice Add a new LP to the pool.  Can only be called by the owner.\\n    /// DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n    /// @param allocPoint AP of the new pool.\\n    /// @param _pid Pid on MCV2\\n    function addPool(uint256 allocPoint, uint256 _pid) public onlyOwner {\\n        require(poolInfo[_pid].lastRewardBlock == 0, \\\"ERR_POOL_EXISTS\\\");\\n        uint256 lastRewardBlock = block.number;\\n        totalAllocPoint = totalAllocPoint.add(allocPoint);\\n\\n        poolInfo[_pid] = PoolInfo({\\n            allocPoint: allocPoint.to64(),\\n            lastRewardBlock: lastRewardBlock.to64(),\\n            accSushiPerShare: 0\\n        });\\n        poolIds.push(_pid);\\n        emit PoolAdded(_pid, allocPoint);\\n    }\\n\\n    /// @notice Update the given pool's SUSHI allocation point and `IRewarder` contract. Can only be called by the owner.\\n    /// @param _pid The index of the pool. See `poolInfo`.\\n    /// @param _allocPoint New AP of the pool.\\n    function setPool(uint256 _pid, uint256 _allocPoint) public onlyOwner {\\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\\n            _allocPoint\\n        );\\n        poolInfo[_pid].allocPoint = _allocPoint.to64();\\n        emit PoolSet(_pid, _allocPoint);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/sushi/interfaces/IRewarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\nimport \\\"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\\\";\\n\\ninterface IRewarder {\\n    using BoringERC20 for IERC20;\\n\\n    function onSushiReward(\\n        uint256 pid,\\n        address user,\\n        address recipient,\\n        uint256 sushiAmount,\\n        uint256 newLpAmount\\n    ) external;\\n\\n    function pendingTokens(\\n        uint256 pid,\\n        address user,\\n        uint256 sushiAmount\\n    ) external view returns (IERC20[] memory, uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\n\\r\\nlibrary BoringERC20 {\\r\\n    function safeSymbol(IERC20 token) internal view returns(string memory) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\\r\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\r\\n    }\\r\\n\\r\\n    function safeName(IERC20 token) internal view returns(string memory) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\\r\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\r\\n    }\\r\\n\\r\\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\\r\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\r\\n    }\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\\r\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BoringERC20: Transfer failed\\\");\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\\r\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, to, amount));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BoringERC20: TransferFrom failed\\\");\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n// a library for performing overflow-safe math, updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math)\\r\\nlibrary BoringMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {require(b == 0 || (c = a * b)/b == a, \\\"BoringMath: Mul Overflow\\\");}\\r\\n    function to128(uint256 a) internal pure returns (uint128 c) {\\r\\n        require(a <= uint128(-1), \\\"BoringMath: uint128 Overflow\\\");\\r\\n        c = uint128(a);\\r\\n    }\\r\\n    function to64(uint256 a) internal pure returns (uint64 c) {\\r\\n        require(a <= uint64(-1), \\\"BoringMath: uint64 Overflow\\\");\\r\\n        c = uint64(a);\\r\\n    }\\r\\n    function to32(uint256 a) internal pure returns (uint32 c) {\\r\\n        require(a <= uint32(-1), \\\"BoringMath: uint32 Overflow\\\");\\r\\n        c = uint32(a);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary BoringMath128 {\\r\\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\r\\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\r\\n}\\r\\n\\r\\nlibrary BoringMath64 {\\r\\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\r\\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\r\\n}\\r\\n\\r\\nlibrary BoringMath32 {\\r\\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\r\\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\r\\n}\"\r\n    },\r\n    \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\\r\\n\\r\\n// P1 - P3: OK\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\\r\\n// Edited by BoringCrypto\\r\\n\\r\\n// T1 - T4: OK\\r\\ncontract BoringOwnableData {\\r\\n    // V1 - V5: OK\\r\\n    address public owner;\\r\\n    // V1 - V5: OK\\r\\n    address public pendingOwner;\\r\\n}\\r\\n\\r\\n// T1 - T4: OK\\r\\ncontract BoringOwnable is BoringOwnableData {\\r\\n    // E1: OK\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor () public {\\r\\n        owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), msg.sender);\\r\\n    }\\r\\n\\r\\n    // F1 - F9: OK\\r\\n    // C1 - C21: OK\\r\\n    function transferOwnership(address newOwner, bool direct, bool renounce) public onlyOwner {\\r\\n        if (direct) {\\r\\n            // Checks\\r\\n            require(newOwner != address(0) || renounce, \\\"Ownable: zero address\\\");\\r\\n\\r\\n            // Effects\\r\\n            emit OwnershipTransferred(owner, newOwner);\\r\\n            owner = newOwner;\\r\\n            pendingOwner = address(0);\\r\\n        } else {\\r\\n            // Effects\\r\\n            pendingOwner = newOwner;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // F1 - F9: OK\\r\\n    // C1 - C21: OK\\r\\n    function claimOwnership() public {\\r\\n        address _pendingOwner = pendingOwner;\\r\\n        \\r\\n        // Checks\\r\\n        require(msg.sender == _pendingOwner, \\\"Ownable: caller != pending owner\\\");\\r\\n\\r\\n        // Effects\\r\\n        emit OwnershipTransferred(owner, _pendingOwner);\\r\\n        owner = _pendingOwner;\\r\\n        pendingOwner = address(0);\\r\\n    }\\r\\n\\r\\n    // M1 - M5: OK\\r\\n    // C1 - C21: OK\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/sushi/MasterChefV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\\\";\\nimport \\\"@boringcrypto/boring-solidity/contracts/BoringBatchable.sol\\\";\\nimport \\\"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\\\";\\nimport \\\"./libraries/SignedSafeMath.sol\\\";\\nimport \\\"./interfaces/IRewarder.sol\\\";\\nimport \\\"./interfaces/IMasterChef.sol\\\";\\n\\ninterface IMigratorChef {\\n    // Take the current LP token address and return the new LP token address.\\n    // Migrator should have full access to the caller's LP token.\\n    function migrate(IERC20 token) external returns (IERC20);\\n}\\n\\n/// @notice The (older) MasterChef contract gives out a constant number of SUSHI tokens per block.\\n/// It is the only address with minting rights for SUSHI.\\n/// The idea for this MasterChef V2 (MCV2) contract is therefore to be the owner of a dummy token\\n/// that is deposited into the MasterChef V1 (MCV1) contract.\\n/// The allocation point for this pool on MCV1 is the total allocation point for all pools that receive double incentives.\\ncontract MasterChefV2 is BoringOwnable, BoringBatchable {\\n    using BoringMath for uint256;\\n    using BoringMath128 for uint128;\\n    using BoringERC20 for IERC20;\\n    using SignedSafeMath for int256;\\n\\n    /// @notice Info of each MCV2 user.\\n    /// `amount` LP token amount the user has provided.\\n    /// `rewardDebt` The amount of SUSHI entitled to the user.\\n    struct UserInfo {\\n        uint256 amount;\\n        int256 rewardDebt;\\n    }\\n\\n    /// @notice Info of each MCV2 pool.\\n    /// `allocPoint` The amount of allocation points assigned to the pool.\\n    /// Also known as the amount of SUSHI to distribute per block.\\n    struct PoolInfo {\\n        uint128 accSushiPerShare;\\n        uint64 lastRewardBlock;\\n        uint64 allocPoint;\\n    }\\n\\n    /// @notice Address of MCV1 contract.\\n    IMasterChef public immutable MASTER_CHEF;\\n    /// @notice Address of SUSHI contract.\\n    IERC20 public immutable SUSHI;\\n    /// @notice The index of MCV2 master pool in MCV1.\\n    uint256 public immutable MASTER_PID;\\n    // @notice The migrator contract. It has a lot of power. Can only be set through governance (owner).\\n    IMigratorChef public migrator;\\n\\n    /// @notice Info of each MCV2 pool.\\n    PoolInfo[] public poolInfo;\\n    /// @notice Address of the LP token for each MCV2 pool.\\n    IERC20[] public lpToken;\\n    /// @notice Address of each `IRewarder` contract in MCV2.\\n    IRewarder[] public rewarder;\\n\\n    /// @notice Info of each user that stakes LP tokens.\\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n    /// @dev Total allocation points. Must be the sum of all allocation points in all pools.\\n    uint256 public totalAllocPoint;\\n\\n    uint256 private constant MASTERCHEF_SUSHI_PER_BLOCK = 1e20;\\n    uint256 private constant ACC_SUSHI_PRECISION = 1e12;\\n\\n    event Deposit(\\n        address indexed user,\\n        uint256 indexed pid,\\n        uint256 amount,\\n        address indexed to\\n    );\\n    event Withdraw(\\n        address indexed user,\\n        uint256 indexed pid,\\n        uint256 amount,\\n        address indexed to\\n    );\\n    event EmergencyWithdraw(\\n        address indexed user,\\n        uint256 indexed pid,\\n        uint256 amount,\\n        address indexed to\\n    );\\n    event Harvest(address indexed user, uint256 indexed pid, uint256 amount);\\n    event LogPoolAddition(\\n        uint256 indexed pid,\\n        uint256 allocPoint,\\n        IERC20 indexed lpToken,\\n        IRewarder indexed rewarder\\n    );\\n    event LogSetPool(\\n        uint256 indexed pid,\\n        uint256 allocPoint,\\n        IRewarder indexed rewarder,\\n        bool overwrite\\n    );\\n    event LogUpdatePool(\\n        uint256 indexed pid,\\n        uint64 lastRewardBlock,\\n        uint256 lpSupply,\\n        uint256 accSushiPerShare\\n    );\\n    event LogInit();\\n\\n    /// @param _MASTER_CHEF The SushiSwap MCV1 contract address.\\n    /// @param _sushi The SUSHI token contract address.\\n    /// @param _MASTER_PID The pool ID of the dummy token on the base MCV1 contract.\\n    constructor(\\n        IMasterChef _MASTER_CHEF,\\n        IERC20 _sushi,\\n        uint256 _MASTER_PID\\n    ) public {\\n        MASTER_CHEF = _MASTER_CHEF;\\n        SUSHI = _sushi;\\n        MASTER_PID = _MASTER_PID;\\n    }\\n\\n    /// @notice Deposits a dummy token to `MASTER_CHEF` MCV1. This is required because MCV1 holds the minting rights for SUSHI.\\n    /// Any balance of transaction sender in `dummyToken` is transferred.\\n    /// The allocation point for the pool on MCV1 is the total allocation point for all pools that receive double incentives.\\n    /// @param dummyToken The address of the ERC-20 token to deposit into MCV1.\\n    function init(IERC20 dummyToken) external {\\n        uint256 balance = dummyToken.balanceOf(msg.sender);\\n        require(balance != 0, \\\"MasterChefV2: Balance must exceed 0\\\");\\n        dummyToken.safeTransferFrom(msg.sender, address(this), balance);\\n        dummyToken.approve(address(MASTER_CHEF), balance);\\n        MASTER_CHEF.deposit(MASTER_PID, balance);\\n        emit LogInit();\\n    }\\n\\n    /// @notice Returns the number of MCV2 pools.\\n    function poolLength() public view returns (uint256 pools) {\\n        pools = poolInfo.length;\\n    }\\n\\n    /// @notice Add a new LP to the pool. Can only be called by the owner.\\n    /// DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n    /// @param allocPoint AP of the new pool.\\n    /// @param _lpToken Address of the LP ERC-20 token.\\n    /// @param _rewarder Address of the rewarder delegate.\\n    function add(\\n        uint256 allocPoint,\\n        IERC20 _lpToken,\\n        IRewarder _rewarder\\n    ) public onlyOwner {\\n        uint256 lastRewardBlock = block.number;\\n        totalAllocPoint = totalAllocPoint.add(allocPoint);\\n        lpToken.push(_lpToken);\\n        rewarder.push(_rewarder);\\n\\n        poolInfo.push(\\n            PoolInfo({\\n                allocPoint: allocPoint.to64(),\\n                lastRewardBlock: lastRewardBlock.to64(),\\n                accSushiPerShare: 0\\n            })\\n        );\\n        emit LogPoolAddition(\\n            lpToken.length.sub(1),\\n            allocPoint,\\n            _lpToken,\\n            _rewarder\\n        );\\n    }\\n\\n    /// @notice Update the given pool's SUSHI allocation point and `IRewarder` contract. Can only be called by the owner.\\n    /// @param _pid The index of the pool. See `poolInfo`.\\n    /// @param _allocPoint New AP of the pool.\\n    /// @param _rewarder Address of the rewarder delegate.\\n    /// @param overwrite True if _rewarder should be `set`. Otherwise `_rewarder` is ignored.\\n    function set(\\n        uint256 _pid,\\n        uint256 _allocPoint,\\n        IRewarder _rewarder,\\n        bool overwrite\\n    ) public onlyOwner {\\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\\n            _allocPoint\\n        );\\n        poolInfo[_pid].allocPoint = _allocPoint.to64();\\n        if (overwrite) {\\n            rewarder[_pid] = _rewarder;\\n        }\\n        emit LogSetPool(\\n            _pid,\\n            _allocPoint,\\n            overwrite ? _rewarder : rewarder[_pid],\\n            overwrite\\n        );\\n    }\\n\\n    /// @notice Set the `migrator` contract. Can only be called by the owner.\\n    /// @param _migrator The contract address to set.\\n    function setMigrator(IMigratorChef _migrator) public onlyOwner {\\n        migrator = _migrator;\\n    }\\n\\n    /// @notice Migrate LP token to another LP contract through the `migrator` contract.\\n    /// @param _pid The index of the pool. See `poolInfo`.\\n    function migrate(uint256 _pid) public {\\n        require(\\n            address(migrator) != address(0),\\n            \\\"MasterChefV2: no migrator set\\\"\\n        );\\n        IERC20 _lpToken = lpToken[_pid];\\n        uint256 bal = _lpToken.balanceOf(address(this));\\n        _lpToken.approve(address(migrator), bal);\\n        IERC20 newLpToken = migrator.migrate(_lpToken);\\n        require(\\n            bal == newLpToken.balanceOf(address(this)),\\n            \\\"MasterChefV2: migrated balance must match\\\"\\n        );\\n        lpToken[_pid] = newLpToken;\\n    }\\n\\n    /// @notice View function to see pending SUSHI on frontend.\\n    /// @param _pid The index of the pool. See `poolInfo`.\\n    /// @param _user Address of user.\\n    /// @return pending SUSHI reward for a given user.\\n    function pendingSushi(uint256 _pid, address _user)\\n        external\\n        view\\n        returns (uint256 pending)\\n    {\\n        PoolInfo memory pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 accSushiPerShare = pool.accSushiPerShare;\\n        uint256 lpSupply = lpToken[_pid].balanceOf(address(this));\\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n            uint256 blocks = block.number.sub(pool.lastRewardBlock);\\n            uint256 sushiReward =\\n                blocks.mul(sushiPerBlock()).mul(pool.allocPoint) /\\n                    totalAllocPoint;\\n            accSushiPerShare = accSushiPerShare.add(\\n                sushiReward.mul(ACC_SUSHI_PRECISION) / lpSupply\\n            );\\n        }\\n        pending = int256(\\n            user.amount.mul(accSushiPerShare) / ACC_SUSHI_PRECISION\\n        )\\n            .sub(user.rewardDebt)\\n            .toUInt256();\\n    }\\n\\n    /// @notice Update reward variables for all pools. Be careful of gas spending!\\n    /// @param pids Pool IDs of all to be updated. Make sure to update all active pools.\\n    function massUpdatePools(uint256[] calldata pids) external {\\n        uint256 len = pids.length;\\n        for (uint256 i = 0; i < len; ++i) {\\n            updatePool(pids[i]);\\n        }\\n    }\\n\\n    /// @notice Calculates and returns the `amount` of SUSHI per block.\\n    function sushiPerBlock() public view returns (uint256 amount) {\\n        amount =\\n            uint256(MASTERCHEF_SUSHI_PER_BLOCK).mul(\\n                MASTER_CHEF.poolInfo(MASTER_PID).allocPoint\\n            ) /\\n            MASTER_CHEF.totalAllocPoint();\\n    }\\n\\n    /// @notice Update reward variables of the given pool.\\n    /// @param pid The index of the pool. See `poolInfo`.\\n    /// @return pool Returns the pool that was updated.\\n    function updatePool(uint256 pid) public returns (PoolInfo memory pool) {\\n        pool = poolInfo[pid];\\n        if (block.number > pool.lastRewardBlock) {\\n            uint256 lpSupply = lpToken[pid].balanceOf(address(this));\\n            if (lpSupply > 0) {\\n                uint256 blocks = block.number.sub(pool.lastRewardBlock);\\n                uint256 sushiReward =\\n                    blocks.mul(sushiPerBlock()).mul(pool.allocPoint) /\\n                        totalAllocPoint;\\n                pool.accSushiPerShare = pool.accSushiPerShare.add(\\n                    (sushiReward.mul(ACC_SUSHI_PRECISION) / lpSupply).to128()\\n                );\\n            }\\n            pool.lastRewardBlock = block.number.to64();\\n            poolInfo[pid] = pool;\\n            emit LogUpdatePool(\\n                pid,\\n                pool.lastRewardBlock,\\n                lpSupply,\\n                pool.accSushiPerShare\\n            );\\n        }\\n    }\\n\\n    /// @notice Deposit LP tokens to MCV2 for SUSHI allocation.\\n    /// @param pid The index of the pool. See `poolInfo`.\\n    /// @param amount LP token amount to deposit.\\n    /// @param to The receiver of `amount` deposit benefit.\\n    function deposit(\\n        uint256 pid,\\n        uint256 amount,\\n        address to\\n    ) public {\\n        PoolInfo memory pool = updatePool(pid);\\n        UserInfo storage user = userInfo[pid][to];\\n\\n        // Effects\\n        user.amount = user.amount.add(amount);\\n        user.rewardDebt = user.rewardDebt.add(\\n            int256(amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION)\\n        );\\n\\n        // Interactions\\n        IRewarder _rewarder = rewarder[pid];\\n        if (address(_rewarder) != address(0)) {\\n            _rewarder.onSushiReward(pid, to, to, 0, user.amount);\\n        }\\n\\n        lpToken[pid].safeTransferFrom(msg.sender, address(this), amount);\\n\\n        emit Deposit(msg.sender, pid, amount, to);\\n    }\\n\\n    /// @notice Withdraw LP tokens from MCV2.\\n    /// @param pid The index of the pool. See `poolInfo`.\\n    /// @param amount LP token amount to withdraw.\\n    /// @param to Receiver of the LP tokens.\\n    function withdraw(\\n        uint256 pid,\\n        uint256 amount,\\n        address to\\n    ) public {\\n        PoolInfo memory pool = updatePool(pid);\\n        UserInfo storage user = userInfo[pid][msg.sender];\\n\\n        // Effects\\n        user.rewardDebt = user.rewardDebt.sub(\\n            int256(amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION)\\n        );\\n        user.amount = user.amount.sub(amount);\\n\\n        // Interactions\\n        IRewarder _rewarder = rewarder[pid];\\n        if (address(_rewarder) != address(0)) {\\n            _rewarder.onSushiReward(pid, msg.sender, to, 0, user.amount);\\n        }\\n\\n        lpToken[pid].safeTransfer(to, amount);\\n\\n        emit Withdraw(msg.sender, pid, amount, to);\\n    }\\n\\n    /// @notice Harvest proceeds for transaction sender to `to`.\\n    /// @param pid The index of the pool. See `poolInfo`.\\n    /// @param to Receiver of SUSHI rewards.\\n    function harvest(uint256 pid, address to) public {\\n        PoolInfo memory pool = updatePool(pid);\\n        UserInfo storage user = userInfo[pid][msg.sender];\\n        int256 accumulatedSushi =\\n            int256(\\n                user.amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION\\n            );\\n        uint256 _pendingSushi =\\n            accumulatedSushi.sub(user.rewardDebt).toUInt256();\\n\\n        // Effects\\n        user.rewardDebt = accumulatedSushi;\\n\\n        // Interactions\\n        if (_pendingSushi != 0) {\\n            SUSHI.safeTransfer(to, _pendingSushi);\\n        }\\n\\n        IRewarder _rewarder = rewarder[pid];\\n        if (address(_rewarder) != address(0)) {\\n            _rewarder.onSushiReward(\\n                pid,\\n                msg.sender,\\n                to,\\n                _pendingSushi,\\n                user.amount\\n            );\\n        }\\n\\n        emit Harvest(msg.sender, pid, _pendingSushi);\\n    }\\n\\n    /// @notice Withdraw LP tokens from MCV2 and harvest proceeds for transaction sender to `to`.\\n    /// @param pid The index of the pool. See `poolInfo`.\\n    /// @param amount LP token amount to withdraw.\\n    /// @param to Receiver of the LP tokens and SUSHI rewards.\\n    function withdrawAndHarvest(\\n        uint256 pid,\\n        uint256 amount,\\n        address to\\n    ) public {\\n        PoolInfo memory pool = updatePool(pid);\\n        UserInfo storage user = userInfo[pid][msg.sender];\\n        int256 accumulatedSushi =\\n            int256(\\n                user.amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION\\n            );\\n        uint256 _pendingSushi =\\n            accumulatedSushi.sub(user.rewardDebt).toUInt256();\\n\\n        // Effects\\n        user.rewardDebt = accumulatedSushi.sub(\\n            int256(amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION)\\n        );\\n        user.amount = user.amount.sub(amount);\\n\\n        // Interactions\\n        SUSHI.safeTransfer(to, _pendingSushi);\\n\\n        IRewarder _rewarder = rewarder[pid];\\n        if (address(_rewarder) != address(0)) {\\n            _rewarder.onSushiReward(\\n                pid,\\n                msg.sender,\\n                to,\\n                _pendingSushi,\\n                user.amount\\n            );\\n        }\\n\\n        lpToken[pid].safeTransfer(to, amount);\\n\\n        emit Withdraw(msg.sender, pid, amount, to);\\n        emit Harvest(msg.sender, pid, _pendingSushi);\\n    }\\n\\n    /// @notice Harvests SUSHI from `MASTER_CHEF` MCV1 and pool `MASTER_PID` to this MCV2 contract.\\n    function harvestFromMasterChef() public {\\n        MASTER_CHEF.deposit(MASTER_PID, 0);\\n    }\\n\\n    /// @notice Withdraw without caring about rewards. EMERGENCY ONLY.\\n    /// @param pid The index of the pool. See `poolInfo`.\\n    /// @param to Receiver of the LP tokens.\\n    function emergencyWithdraw(uint256 pid, address to) public {\\n        UserInfo storage user = userInfo[pid][msg.sender];\\n        uint256 amount = user.amount;\\n        user.amount = 0;\\n        user.rewardDebt = 0;\\n\\n        IRewarder _rewarder = rewarder[pid];\\n        if (address(_rewarder) != address(0)) {\\n            _rewarder.onSushiReward(pid, msg.sender, to, 0, 0);\\n        }\\n\\n        // Note: transfer can fail or succeed if `amount` is zero.\\n        lpToken[pid].safeTransfer(to, amount);\\n        emit EmergencyWithdraw(msg.sender, pid, amount, to);\\n    }\\n}\\n\"\r\n    },\r\n    \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    // EIP 2612\\r\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n}\"\r\n    },\r\n    \"@boringcrypto/boring-solidity/contracts/BoringBatchable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\\r\\n\\r\\n// P1 - P3: OK\\r\\npragma solidity 0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n// solhint-disable avoid-low-level-calls\\r\\n\\r\\nimport \\\"./libraries/BoringERC20.sol\\\";\\r\\n\\r\\n// T1 - T4: OK\\r\\ncontract BaseBoringBatchable {\\r\\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\\r\\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\\r\\n        if (_returnData.length < 68) return \\\"Transaction reverted silently\\\";\\r\\n\\r\\n        assembly {\\r\\n            // Slice the sighash.\\r\\n            _returnData := add(_returnData, 0x04)\\r\\n        }\\r\\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\\r\\n    }    \\r\\n    \\r\\n    // F3 - F9: OK\\r\\n    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\\r\\n    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\\r\\n    // C1 - C21: OK\\r\\n    // C3: The length of the loop is fully under user control, so can't be exploited\\r\\n    // C7: Delegatecall is only used on the same contract, so it's safe\\r\\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns(bool[] memory successes, bytes[] memory results) {\\r\\n        // Interactions\\r\\n        successes = new bool[](calls.length);\\r\\n        results = new bytes[](calls.length);\\r\\n        for (uint256 i = 0; i < calls.length; i++) {\\r\\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\\r\\n            require(success || !revertOnFail, _getRevertMsg(result));\\r\\n            successes[i] = success;\\r\\n            results[i] = result;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// T1 - T4: OK\\r\\ncontract BoringBatchable is BaseBoringBatchable {\\r\\n    // F1 - F9: OK\\r\\n    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)\\r\\n    //     if part of a batch this could be used to grief once as the second call would not need the permit\\r\\n    // C1 - C21: OK\\r\\n    function permitToken(IERC20 token, address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\r\\n        // Interactions\\r\\n        // X1 - X5\\r\\n        token.permit(from, to, amount, deadline, v, r, s);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/sushi/libraries/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nlibrary SignedSafeMath {\\n    int256 private constant _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(\\n            !(a == -1 && b == _INT256_MIN),\\n            \\\"SignedSafeMath: multiplication overflow\\\"\\n        );\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(\\n            !(b == -1 && a == _INT256_MIN),\\n            \\\"SignedSafeMath: division overflow\\\"\\n        );\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require(\\n            (b >= 0 && c <= a) || (b < 0 && c > a),\\n            \\\"SignedSafeMath: subtraction overflow\\\"\\n        );\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require(\\n            (b >= 0 && c >= a) || (b < 0 && c < a),\\n            \\\"SignedSafeMath: addition overflow\\\"\\n        );\\n\\n        return c;\\n    }\\n\\n    function toUInt256(int256 a) internal pure returns (uint256) {\\n        require(a >= 0, \\\"Integer < 0\\\");\\n        return uint256(a);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/sushi/interfaces/IMasterChef.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\nimport \\\"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\\\";\\n\\ninterface IMasterChef {\\n    using BoringERC20 for IERC20;\\n    struct UserInfo {\\n        uint256 amount; // How many LP tokens the user has provided.\\n        uint256 rewardDebt; // Reward debt. See explanation below.\\n    }\\n\\n    struct PoolInfo {\\n        IERC20 lpToken; // Address of LP token contract.\\n        uint256 allocPoint; // How many allocation points assigned to this pool. SUSHI to distribute per block.\\n        uint256 lastRewardBlock; // Last block number that SUSHI distribution occurs.\\n        uint256 accSushiPerShare; // Accumulated SUSHI per share, times 1e12. See below.\\n    }\\n\\n    function poolInfo(uint256 pid)\\n        external\\n        view\\n        returns (IMasterChef.PoolInfo memory);\\n\\n    function totalAllocPoint() external view returns (uint256);\\n\\n    function deposit(uint256 _pid, uint256 _amount) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_MASTERCHEF_V2\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_rewardToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"}],\"name\":\"PoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"}],\"name\":\"PoolSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lastRewardBlock\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accSushiPerShare\",\"type\":\"uint256\"}],\"name\":\"PoolUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPerBlock\",\"type\":\"uint256\"}],\"name\":\"TokenPerBlockSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pids\",\"type\":\"uint256[]\"}],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpToken\",\"type\":\"uint256\"}],\"name\":\"onSushiReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingTokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"accSushiPerShare\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"lastRewardBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"allocPoint\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pools\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"}],\"name\":\"setPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenPerBlock\",\"type\":\"uint256\"}],\"name\":\"setTokenPerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateAllPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"accSushiPerShare\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"lastRewardBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"allocPoint\",\"type\":\"uint64\"}],\"internalType\":\"struct APWRewarder.PoolInfo\",\"name\":\"pool\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"APWRewarder","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"000000000000000000000000ef0881ec094552b2e128cf945ef17a6752b4ec5d0000000000000000000000004104b135dbc9609fc1a9490e61369036497660c8","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}