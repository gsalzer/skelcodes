{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\r\n    external returns (bytes4);\r\n}\r\n\r\n\r\ninterface IGoaldDAO721 {\r\n    /** Updates the owner of a deployed Goald. */\r\n    function setGoaldOwner(uint256 id) external;\r\n}\r\n\r\n/*\r\n * This is an implementation of the ERC721 standard for the Goald project that acts as a psuedo NFT (only has one token).\r\n *\r\n * See: @openzeppelin/contracts/token/ERC721/ERC721.sol\r\n */\r\n\r\ncontract Goald721 {\r\n    //// ERC165 ////\r\n    \r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    /// IERC721 ///\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    //// ERC721 ////\r\n\r\n    /*\r\n     *     bytes4(keccak256('balanceOf(address)'))                              == 0x70a08231\r\n     *     bytes4(keccak256('ownerOf(uint256)'))                                == 0x6352211e\r\n     *     bytes4(keccak256('approve(address,uint256)'))                        == 0x095ea7b3\r\n     *     bytes4(keccak256('getApproved(uint256)'))                            == 0x081812fc\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)'))                 == 0xa22cb465\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)'))               == 0xe985e9c5\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)'))           == 0x23b872dd\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)'))       == 0x42842e0e\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\r\n     *\r\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^\r\n     *        0x081812fc ^ 0xa22cb465 ^ 0xe985e9c5 ^\r\n     *        0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\r\n     */\r\n    bytes4 private constant INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    /*\r\n     *     bytes4(keccak256('name()')) == 0x06fdde03\r\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\r\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\r\n     *\r\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\r\n     */\r\n    bytes4 private constant INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    /** @dev The address that is allowed to `safeTransferFrom()` the token. */\r\n    address _approvedTransferer;\r\n\r\n    /** @dev The addresses that are always approved and also set third-party approvals. */\r\n    mapping(address => bool) _approveForAllAddresses;\r\n    \r\n    /** @dev Token name. */\r\n    string  private _name;\r\n\r\n    /** @dev Token symbol. */\r\n    string  private _symbol;\r\n    \r\n    /** @dev We only need to track ownership as a state rather than a balance since each Goald contract only issues a single token. */\r\n    address internal _owner;\r\n\r\n    /** @dev We are only tracking a single token, so we can manage its id as state. */\r\n    uint256 internal _tokenId;\r\n\r\n    /// Goald ///\r\n    \r\n    /** @dev The address of the Goald DAO which fees will be paid into. */\r\n    address internal _daoAddress;\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n     */\r\n    constructor (string memory name, string memory symbol, uint256 tokenId) public {\r\n        //// ERC165 ////\r\n        \r\n        // Derived contracts need only register support for their own interfaces, we register support for ERC165 itself here.\r\n        _supportedInterfaces[INTERFACE_ID_ERC165] = true;\r\n\r\n        // Register the supported interface to conform to ERC721 via ERC165.\r\n        _supportedInterfaces[INTERFACE_ID_ERC721] = true;\r\n\r\n        // Register the ERC721MEtatadata extension.\r\n        // NOTE: `tokenURI(uint256)` is not implemented in this contract.\r\n        _supportedInterfaces[INTERFACE_ID_ERC721_METADATA] = true;\r\n\r\n\r\n        //// ERC721 ////\r\n\r\n        _name    = name;\r\n        _symbol  = symbol;\r\n        _tokenId = tokenId;\r\n    }\r\n\r\n    //// ERC165 ////\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /// ERC721  - Views ///\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256) {\r\n        return owner == _owner ? 1 : 0;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address) {\r\n        require(tokenId == _tokenId, \"Wrong token id\");\r\n\r\n        return _approvedTransferer;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\r\n        require(owner == _owner, \"Not owner\");\r\n\r\n        return _approveForAllAddresses[operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address) {\r\n        return tokenId == _tokenId ? _owner : address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    //// ERC721 - Non Views ////\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) external {\r\n        require(\r\n               tokenId == _tokenId\r\n            && (\r\n                   msg.sender == _owner\r\n                || _approveForAllAddresses[msg.sender]\r\n               )\r\n        , \"Wrong token or not authorized\");\r\n\r\n        _approvedTransferer = to;\r\n\r\n        emit Approval(_owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, \"\"), \"ERC721: not ERC721Receiver\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: not ERC721Receiver\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external {\r\n        require(msg.sender == _owner, \"Not owner\");\r\n\r\n        _approveForAllAddresses[operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external {\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    //// ERC721 - Internal ////\r\n    \r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {\r\n        // If the recipient isn't a contract we can move on. This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the constructor execution.\r\n        uint256 size;\r\n        assembly { size := extcodesize(to) }\r\n        if (size == 0) {\r\n            return true;\r\n        }\r\n\r\n        // Otherwise validate that they can receive the token.\r\n        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\r\n            IERC721Receiver(to).onERC721Received.selector,\r\n            msg.sender,\r\n            from,\r\n            tokenId,\r\n            _data\r\n        ));\r\n        if (success) {\r\n            bytes4 retval = abi.decode(returndata, (bytes4));\r\n            return (retval == ERC721_RECEIVED);\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(\"ERC721: not ERC721Receiver\");\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` representation.\r\n     */\r\n    function _toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = byte(uint8(48 + temp % 10));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\r\n        require(\r\n            // Throw these in here as well to save gas.\r\n               to != address(0)\r\n            && tokenId == _tokenId\r\n\r\n            && from == _owner\r\n            && (msg.sender == _owner || msg.sender ==_approvedTransferer || _approveForAllAddresses[msg.sender])\r\n        , \"Not authorized\");\r\n\r\n        // Clear approvals from the previous owner.\r\n        _approvedTransferer = address(0);\r\n\r\n        // Update the owner.\r\n        _owner = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n\r\n        // GoaldDAO.setGoaldOwner transforms the id into an index using its `_idOffset`.\r\n        IGoaldDAO721(_daoAddress).setGoaldOwner(tokenId - 1);\r\n    }\r\n}\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\ninterface IGoaldDAO {\r\n    /** Returns the next Goald id so that we have a unique ID for each NFT, regardless of which deployer was used. */\r\n    function getNextGoaldId() external view returns (uint256);\r\n\r\n    /** Returns the current address that fees will be sent to. */\r\n    function getProxyAddress() external view returns (address);\r\n\r\n    /** Return the metadata for a specific Goald. */\r\n    function getTokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    /** Returns the address of the uniswap router. */\r\n    function getUniswapRouterAddress() external view returns (address);\r\n\r\n    /** Returns true if this deployer is allowed to deploy a goald. */\r\n    function isAllowedDeployer(address deployer) external view returns (bool);\r\n\r\n    /** Lets the DAO know that a Goald was created. */\r\n    function notifyGoaldCreated(address creator, address goaldAddress) external;\r\n\r\n    /** Updates the owner of a deployed Goald. */\r\n    function setGoaldOwner(uint256 id) external;\r\n}\r\n\r\ncontract GoaldFlexibleDeployer {\r\n    address constant DAO_ADDRESS = 0x544664F896eD703Afa025c8465903249D8f1C65A;\r\n\r\n    event GoaldDeployed(address goaldAddress);\r\n\r\n    /**\r\n     * See the constructor of the Goald contract for details on the parameters. There is no concern for reentrancy since this is the\r\n     * only function, and multiple calls will probably hit the block gas limit very quickly.\r\n     */\r\n    function deploy(\r\n        address collateralToken,\r\n        address paymentToken,\r\n        uint96  fee,\r\n        uint8   feeIntervalDays,\r\n        uint16  totalIntervals,\r\n        string memory name\r\n    ) external returns (address) {\r\n        // Make sure that we are allowed to create new Goald.\r\n        IGoaldDAO latestDAO = IGoaldDAO(IGoaldDAO(DAO_ADDRESS).getProxyAddress());\r\n        require(latestDAO.getProxyAddress() == address(latestDAO), \"DAO address mismatch\");\r\n        require(latestDAO.isAllowedDeployer(address(this)), \"Not allowed deployer\");\r\n\r\n        // Create the goald.\r\n        GoaldFlexible goald = new GoaldFlexible(\r\n            address(latestDAO),\r\n            msg.sender,\r\n            name,\r\n            latestDAO.getNextGoaldId(),\r\n            collateralToken,\r\n            paymentToken,\r\n            latestDAO.getUniswapRouterAddress(),\r\n            fee,\r\n            feeIntervalDays,\r\n            totalIntervals\r\n        );\r\n        address goaldAddress = address(goald);\r\n\r\n        // Tell the proxy we created a goald.\r\n        latestDAO.notifyGoaldCreated(msg.sender, goaldAddress);\r\n\r\n        // Hello world!\r\n        emit GoaldDeployed(goaldAddress);\r\n\r\n        return goaldAddress;\r\n    }\r\n}\r\n\r\ncontract GoaldFlexible is Goald721 {\r\n    // The masks and shift distances for each value from the packed state variable. This works for both arithmatic and logical shifts,\r\n    // though currrently shifts are logical. This is for big endian values.\r\n    // READ:\r\n    //      1) AND the MASK with the packed values to expose the slot\r\n    //      2) RIGHT SHIFT to get the raw value\r\n    //\r\n    //      value = (_staticValues & MASK) >> SHIFT\r\n    //      \r\n    // WRITE:\r\n    //      1) LEFT SHIFT to position with the slot\r\n    //      2) AND the MASK with the shifted value, to get rid of dirty bits\r\n    //      3) AND the NEGATIVE MASK with the packed values to wipe the slot\r\n    //      4) OR the shifted value to update\r\n    //\r\n    //      _staticValues = ((value << SHIFT) & MASK) | (_staticValues & ~MASK)\r\n    uint256 private constant FEE_MASK                     = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n    uint256 private constant FEE_SHIFT                    = 0;\r\n\r\n    uint256 private constant FEE_INTERVAL_DAYS_MASK       = 0x1FF000000000000000000000000000000000000000000;\r\n    uint256 private constant FEE_INTERVAL_DAYS_SHIFT      = 168;\r\n\r\n    uint256 private constant TOTAL_INTERVALS_MASK         = 0x1FFFFE00000000000000000000000000000000000000000000;\r\n    uint256 private constant TOTAL_INTERVALS_SHIFT        = 177;\r\n\r\n    uint256 private constant FINALIZATION_TIMESTAMP_MASK  = 0x1FFFFFFFFFFFE0000000000000000000000000000000000000000000000000;\r\n    uint256 private constant FINALIZATION_TIMESTAMP_SHIFT = 197;\r\n\r\n    uint256 private constant FINALIZED_MASK               = 0x20000000000000000000000000000000000000000000000000000000000000;\r\n    uint256 private constant FINALIZED_SHIFT              = 245;\r\n\r\n    // The divisor used to calculate the fee paid to the Goald DAO. This is currently 0.25%.\r\n    uint256 private constant FEE_DIVISOR = 400;\r\n\r\n\r\n    /** @dev The collateral token stored (e.g., WBTC). */\r\n    address private _collateralAddress;\r\n\r\n    /** @dev The payment token taken (e.g., WETH). */\r\n    address private _paymentAddress;\r\n\r\n    /** @dev The address of the Uniswap router which will facilitate the swap between the payment token and the collateral token. */\r\n    address private _uniswapRouterAddress;\r\n\r\n    /**\r\n     * @dev The owner of the Goald can optionally appoint a steward. The steward's only authority is to update the uniswap router\r\n     * address or replace themself. This is intended if the Goald needs separation between ownership and management (e.g., via DAOs).\r\n     */\r\n    address private _steward;\r\n\r\n    /**\r\n     * @dev Packed static values (all uints). The only one that will change is `finalized`, and only once.\r\n     *\r\n     *  bits    offset    variable name            description\r\n     *  ----    ------    -------------            -----------\r\n     *   168         0    fee                      The fee per interval of the goald.\r\n     *     9       168    feeIntervalDays          How many days between each fee payment; minimum 1.\r\n     *    20       177    totalIntervals           The total number of intervals this goald will have when it is finalized.\r\n     *    48       197    finalizationTimestamp    When the Goald can be finalized if it isn't paid in full.\r\n     *     1       245    finalized                If the Goald can be withdrawn from.\r\n     */\r\n    uint256 private _staticValues;\r\n\r\n    /** @dev The total amount of the payment token that must be paid over the life of the Goald to finalize it. */\r\n    uint256 private _requiredTotalFeePaid;\r\n\r\n    /** @dev The total amount of the payment token that has been paid over the life of the Goald. */\r\n    uint256 private _totalFeePaid;\r\n\r\n    // We include this here instead of the `nonReentrant` modifier to reduce gas costs. We also might change the reentrancy state\r\n    // multiple times within a single function depending on needs.\r\n    // See OpenZeppelin - ReentrancyGuard for more.\r\n    // Reentrancy reversions are the only calls to revert (in this contract) that do not have reasons.\r\n    uint256 private constant RE_NOT_ENTERED = 1;\r\n    uint256 private constant RE_ENTERED     = 2;\r\n    uint256 private _status;\r\n\r\n    /// Events ///\r\n\r\n    /** @dev Emitted whenever a fee is paid. */\r\n    event FeePaid(address paymentToken, uint256 feePaid, uint256 feeTokensSpent, uint256 collateralTokensReceived);\r\n\r\n    /** @dev Emitted when the collateral pool has been withdrawn from. */\r\n    event Withdrawal(uint256 amount);\r\n\r\n    /** @dev Emitted when the Uniswap router address has changed. */\r\n    event RouterAddressChanged(address newAddress);\r\n\r\n    /** @dev Emitted when the steward address has changed. */\r\n    event StewardChanged(address newSteward);\r\n\r\n    /// Modifiers ///\r\n\r\n    /** @dev Applied to functions that must be guarded against reentrancy which only the owner or steward can call. */\r\n    modifier nonReentrant_OnlyOwnerSteward {\r\n        require(_status == RE_NOT_ENTERED && (msg.sender == _owner || msg.sender == _steward));\r\n        _status = RE_ENTERED;\r\n\r\n        _;\r\n\r\n        // Store the original amount to get a refund.\r\n        _status = RE_NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Applied to functions that must be guarded against reentrancy which only the owner or steward can call. This modifier\r\n     * doesn't update the current value of `_status`, so it cannot make any non-internal function calls.\r\n     */\r\n    modifier nonReentrant_OnlyOwnerSteward_InternalCallsOnly {\r\n        require(_status == RE_NOT_ENTERED && (msg.sender == _owner || msg.sender == _steward));\r\n\r\n        _;\r\n    }\r\n\r\n    /** @dev Applied to functions that must be guarded against reentrancy, but are otherwise publicly accessible. */\r\n    modifier nonReentrant_Public {\r\n        // Reentrancy guard.\r\n        require(_status == RE_NOT_ENTERED);\r\n        _status = RE_ENTERED;\r\n\r\n        _;\r\n\r\n        // Store the original amount to get a refund.\r\n        _status = RE_NOT_ENTERED;\r\n    }\r\n\r\n    /// Constructor ///\r\n\r\n    /**\r\n     * @param daoAddress The address of the Goald DAO.\r\n     * @param owner Who owns the goald and is required to pay the fees to maintain it (though anyone can pay the fees).\r\n     * @param name The name of this goald.\r\n     * @param goaldId The unique id of this Goald.\r\n     * @param collateralToken Which token will be used as collateral in the collateral pool (e.g., WBTC).\r\n     * @param paymentToken Which token will be used to pay for the collateral token (e.g., WETH).\r\n     * @param uniswapRouterAddress The address of the liquidity swap router.\r\n     * @param fee The periodic fee required to be paid to maintain the goald; minimum 1. Anyone can pay the fee.\r\n     * @param feeIntervalDays How many days between each fee payment; minimum 1.\r\n     * @param totalIntervals How many fee intervals must pass before the goald finalizes; minimum 1.\r\n     */\r\n    constructor(\r\n        address daoAddress,\r\n        address owner,\r\n        string memory name,\r\n        uint256 goaldId,\r\n        address collateralToken,\r\n        address paymentToken,\r\n        address uniswapRouterAddress,\r\n        uint256 fee,\r\n        uint256 feeIntervalDays,\r\n        uint256 totalIntervals\r\n    ) Goald721(name, \"GOALD\", goaldId) public {\r\n        // Do validation. We don't do any validation on the addresses being contracts, only that they are unique among themselves\r\n        // and are not obviously invalid. It is up to the user to use addresses that are ERC20 compliant.\r\n        require(\r\n            // Validate the addresses.\r\n               daoAddress      != address(0)\r\n            && daoAddress      != address(this)\r\n            && owner           != address(0)\r\n            && owner           != address(this)\r\n            && owner           != collateralToken\r\n            && owner           != paymentToken\r\n            && collateralToken != address(0)\r\n            && collateralToken != address(this)\r\n            && collateralToken != paymentToken\r\n            && paymentToken    != address(0)\r\n            && paymentToken    != address(this)\r\n\r\n            // Validate the numbers.\r\n            && fee             > 0 && fee             <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF // uint168\r\n            && feeIntervalDays > 0 && feeIntervalDays <= 0x1FF                                        // uint9\r\n            && totalIntervals  > 0 && totalIntervals  <= 0xFFFFF                                      // uint20\r\n        , \"Invalid parameters\");\r\n\r\n        // Clean any dirty bits from the number values.\r\n        fee             = fee             & (FEE_MASK               >> FEE_SHIFT);\r\n        feeIntervalDays = feeIntervalDays & (FEE_INTERVAL_DAYS_MASK >> FEE_INTERVAL_DAYS_SHIFT);\r\n        totalIntervals  = totalIntervals  & (TOTAL_INTERVALS_MASK   >> TOTAL_INTERVALS_SHIFT);\r\n        uint256 finalizationTimestamp = block.timestamp + (totalIntervals * feeIntervalDays * 1 days);\r\n\r\n        // Set the addresses.\r\n        _daoAddress           = daoAddress;\r\n        _collateralAddress    = collateralToken;\r\n        _paymentAddress       = paymentToken;\r\n        _owner                = owner;\r\n        _uniswapRouterAddress = uniswapRouterAddress;\r\n\r\n        // Store the values.\r\n        _requiredTotalFeePaid = fee * totalIntervals;\r\n        _staticValues = 0\r\n            | (fee                   << FEE_SHIFT)\r\n            | (feeIntervalDays       << FEE_INTERVAL_DAYS_SHIFT)\r\n            | (totalIntervals        << TOTAL_INTERVALS_SHIFT)\r\n            | (finalizationTimestamp << FINALIZATION_TIMESTAMP_SHIFT);\r\n\r\n        // Set us up for reentrancy guarding.\r\n        _status = RE_NOT_ENTERED;\r\n    }\r\n\r\n    /// Views ///\r\n\r\n    /**\r\n     * Single view over all internal state variables.\r\n     *\r\n     * Returns:\r\n     *     Proxy contract address\r\n     *     Collateral token address\r\n     *     Payment token address (or 0 for ETH)\r\n     *     Uniswap router address\r\n     *     Next fee timestamp\r\n     *     Packed state values\r\n     */\r\n    function getDetails() external view returns (uint256[10] memory details) {\r\n        address collateralAddress = _collateralAddress;\r\n\r\n        // Important Addresses.\r\n        details[0] = uint256(_daoAddress);\r\n        details[1] = uint256(collateralAddress);\r\n        details[2] = uint256(_paymentAddress);\r\n        details[3] = uint256(_uniswapRouterAddress);\r\n        details[4] = uint256(_steward);\r\n        details[5] = uint256(_owner);\r\n\r\n        // The id of this Goald.\r\n        details[6] = _tokenId;\r\n\r\n        // The total amount paid into the Goald so far.\r\n        details[7] = _totalFeePaid;\r\n\r\n        // Current balance.\r\n        details[8] = IERC20(collateralAddress).balanceOf(address(this));\r\n\r\n        // Packed values.\r\n        details[9] = _staticValues;\r\n    }\r\n\r\n    /// External Functions ///\r\n\r\n    /**\r\n     * Pay out the stored collateral. This can only be called by and paid out to the owner, not a third party, even the steward. This\r\n     * This can only be called once the finalization date has been reached, but can be called multiple times after that if desired.\r\n     */\r\n    function withdrawFromGoald(uint256 amount) external {\r\n        // So we can extract the packed values without unnecessary SLOADs.\r\n        uint256 values = _staticValues;\r\n        uint256 finalized             = (values & FINALIZED_MASK)              >> FINALIZED_SHIFT;\r\n        uint256 finalizationTimestamp = (values & FINALIZATION_TIMESTAMP_MASK) >> FINALIZATION_TIMESTAMP_SHIFT;\r\n\r\n        // Rather than using a `nonReentrant_OnlyOwner` modifier, we include the reentrancy guard manually. This save gas since we're\r\n        // caching `_owner` into `owner`.\r\n        address owner = _owner;\r\n        require(\r\n               _status == RE_NOT_ENTERED\r\n            && msg.sender == owner\r\n            && (\r\n                // This is only set during a call to `payFee` if the Goald has been fully paid out.\r\n                   finalized > 0\r\n                || block.timestamp >= finalizationTimestamp\r\n            )\r\n        , \"Not authorized\");\r\n        _status = RE_ENTERED;\r\n\r\n        // Make sure we have something to withdraw.\r\n        IERC20 collateralToken = IERC20(_collateralAddress);\r\n        uint256 currentGoaldBalance = collateralToken.balanceOf(address(this));\r\n        uint256 currentOwnerBalance = collateralToken.balanceOf(owner);\r\n        require(\r\n               amount > 0\r\n            && amount <= currentGoaldBalance\r\n            && currentOwnerBalance + amount > currentOwnerBalance\r\n        , \"Invalid amount\");\r\n\r\n        // Transfer the collateral.\r\n        require(collateralToken.transfer(owner, amount));\r\n\r\n        // Validate the transfer.\r\n        require(\r\n               collateralToken.balanceOf(address(this)) == currentGoaldBalance - amount\r\n            && collateralToken.balanceOf(owner)         == currentOwnerBalance + amount\r\n        , \"Post transfer balance wrong\");\r\n\r\n        // Hello world!\r\n        emit Withdrawal(amount);\r\n\r\n        // Store the original amount to get a refund.\r\n        _status = RE_NOT_ENTERED;\r\n    }\r\n \r\n\r\n    /** Pay the goald fee. Overpayments change the finalization date. */\r\n    function payFee(uint256 amount, address[] calldata swapPath, uint256 deadline) external nonReentrant_Public {\r\n        // Make sure we have a valid swap path.\r\n        require(swapPath.length > 1 && swapPath[swapPath.length - 1] == _collateralAddress, \"Invalid swap path\");\r\n\r\n        // Clean up any dirty bits in the amount. We don't validate that this is more than zero. At best, the swap function will\r\n        // revert (either on input being zero, or minimum output not being more than one). At worst, The user called this function\r\n        // with invalid parameters.\r\n        amount = amount & (FEE_MASK >> FEE_SHIFT);\r\n\r\n        // Make sure we have the most up to date DAO address. If this call reverts, then no fees can be paid.\r\n        address daoAddress = IGoaldDAO(_daoAddress).getProxyAddress();\r\n        if (address(daoAddress) != daoAddress) {\r\n            _daoAddress = daoAddress;\r\n        }\r\n\r\n        uint256[] memory amounts;\r\n        uint256 receivedAmount;\r\n        { // Scoped to prevent stack too deep error.\r\n            // Transfer from the user.\r\n            IERC20 paymentContract = IERC20(swapPath[0]);\r\n            uint256 fee = amount / FEE_DIVISOR;\r\n            amount -= fee;\r\n            require(paymentContract.transferFrom(msg.sender, address(this), amount)); \r\n            if (fee > 0) {\r\n                require(paymentContract.transferFrom(msg.sender, daoAddress, fee));\r\n            }\r\n\r\n            // We'll be verifying uniswap did what it said it did.\r\n            IERC20 collateralContract = IERC20(_collateralAddress);\r\n            uint256 currentCollateralBalance = collateralContract.balanceOf(address(this));\r\n\r\n            // Set the router's allowance to cover the trade. We are only authorizing enough for the collateral amount.\r\n            address uniswapRouterAddress = _uniswapRouterAddress;\r\n            require(paymentContract.approve(uniswapRouterAddress, amount));\r\n            \r\n            // Try and transfer from the user to the goald. We use Uniswap to get the collateral token. We don't care how much of the\r\n            // collateral was returned, so long as it is greater than zero.\r\n            amounts = IUniswapV2Router02(uniswapRouterAddress).swapExactTokensForTokens(amount, 1, swapPath, address(this), deadline);\r\n\r\n            // Double check the balance. Amounts is the same length as `_uniPath`: 3.\r\n            receivedAmount = amounts[swapPath.length - 1];\r\n            require(currentCollateralBalance + receivedAmount > currentCollateralBalance, \"UNI: Overflow error\");\r\n            require(collateralContract.balanceOf(address(this)) == currentCollateralBalance + receivedAmount, \"UNI: Wrong balance\");\r\n\r\n            // Reset the router's allowance to zero to prevent unauthorized spending / double spending. The refund would be larger if\r\n            // it was kept non-zero, but though one token can be considered miniscule (e.g., for WETH, which has 18 decimal places),\r\n            // we still must be diligent.\r\n            require(paymentContract.approve(uniswapRouterAddress, 0));\r\n        }\r\n\r\n        // The Goald hasn't been finalized yet, so update the total amount paid. We don't keep track of how many payments have\r\n        // been made afer the it has been finalized.\r\n        if ((_staticValues & FINALIZED_MASK) >> FINALIZED_SHIFT == 0) {\r\n            // Calculate the new total.\r\n            uint256 totalFeePaid = _totalFeePaid;\r\n            uint256 newTotalFeePaid = totalFeePaid + amount;\r\n\r\n            // We'll consider an overflow on the amount paid to be the same as fully paying out the Goald.\r\n            if (newTotalFeePaid < totalFeePaid) {\r\n                _staticValues |= FINALIZED_MASK;\r\n            } else if (newTotalFeePaid >= _requiredTotalFeePaid) {\r\n                _staticValues |= FINALIZED_MASK;\r\n            } else {\r\n                _totalFeePaid = newTotalFeePaid;\r\n            }\r\n        }\r\n\r\n        // Hello world!\r\n        emit FeePaid(swapPath[0], amount, amounts[0], receivedAmount);\r\n    }\r\n\r\n    /** Failsafe so the owner can withdraw any tokens other than the collateral token that may end up within this Goald. */\r\n    function transferERC20(address tokenAddress, uint256 amount) external nonReentrant_OnlyOwnerSteward {\r\n        require(tokenAddress != _collateralAddress, \"Invalid address\");\r\n        require(IERC20(tokenAddress).transfer(_owner, amount));\r\n    }\r\n\r\n    /**\r\n     * Changes the uniswap router contract address for the swaps. This can be changed to anything that has the same API:\r\n     * \r\n     * `swapExactTokensForTokens(\r\n     *      uint256   amount,\r\n     *      uint256   minAmount,\r\n     *      address[] path,\r\n     *      address   destination,\r\n     *      uint256   deadline\r\n     *  ) external returns (uint256[] amounts);`\r\n     *\r\n     * Only the owner or steward of the Goald can update the router.\r\n     */\r\n    function updateRouterAddress(address newAddress) external nonReentrant_OnlyOwnerSteward_InternalCallsOnly {\r\n        // We're not doing address validation because this function is restricted to only two callers: the owner or steward. However,\r\n        // the things we would validate against would be:\r\n        //\r\n        // 1) Not being the zero address. Since that address doesn't support the swap function it would revert on any payments.\r\n        // 2) The goald address (or the deployer address). Again, neither support the swap function.\r\n        // 3) The DAO address / a token address. Again, neither support the swap function (although a unified proxy DAO is possible).\r\n        // 4) The steward / owner. It's possible this condition is legitimate.\r\n\r\n        // Update the router address.\r\n        _uniswapRouterAddress = newAddress;\r\n\r\n        emit RouterAddressChanged(newAddress);\r\n    }\r\n\r\n    /** Changes the steward. This can be set to the zero address to disable steward functionality.*/\r\n    function updateSteward(address newSteward) external nonReentrant_OnlyOwnerSteward_InternalCallsOnly {\r\n        // We don't do any validation on the new steward. Either the new address can be aware of its stewardship abilities or it\r\n        // cannot. In the second case, it doesn't matter what it is. In the first case, it would pass all theoretical validation.\r\n\r\n        // Update the steward.\r\n        _steward = newSteward;\r\n\r\n        emit StewardChanged(newSteward);\r\n    }\r\n\r\n    /// \"Overridden\" Functions ///\r\n\r\n    /** See {IERC721Metadata-tokenURI}. Pull metadata from the DAO. */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\r\n        require(tokenId == _tokenId, \"Wrong token\");\r\n\r\n        return IGoaldDAO(_daoAddress).getTokenURI(tokenId);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"goaldAddress\",\"type\":\"address\"}],\"name\":\"GoaldDeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"fee\",\"type\":\"uint96\"},{\"internalType\":\"uint8\",\"name\":\"feeIntervalDays\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"totalIntervals\",\"type\":\"uint16\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GoaldFlexibleDeployer","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fd66734edc09eb2240b510ba8f96c7f6f2158957ca5d1cae37fb66b0081d2f3a"}]}