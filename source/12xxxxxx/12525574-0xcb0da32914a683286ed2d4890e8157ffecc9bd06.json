{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/bridge/Bridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./Inbox.sol\\\";\\nimport \\\"./Outbox.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport \\\"./interfaces/IBridge.sol\\\";\\n\\ncontract Bridge is OwnableUpgradeable, IBridge {\\n    using Address for address;\\n    struct InOutInfo {\\n        uint256 index;\\n        bool allowed;\\n    }\\n\\n    mapping(address => InOutInfo) private allowedInboxesMap;\\n    mapping(address => InOutInfo) private allowedOutboxesMap;\\n\\n    address[] public allowedInboxList;\\n    address[] public allowedOutboxList;\\n\\n    address public override activeOutbox;\\n    bytes32[] public override inboxAccs;\\n\\n    function initialize() external initializer {\\n        __Ownable_init();\\n    }\\n\\n    function allowedInboxes(address inbox) external view override returns (bool) {\\n        return allowedInboxesMap[inbox].allowed;\\n    }\\n\\n    function allowedOutboxes(address outbox) external view override returns (bool) {\\n        return allowedOutboxesMap[outbox].allowed;\\n    }\\n\\n    function deliverMessageToInbox(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable override returns (uint256) {\\n        require(allowedInboxesMap[msg.sender].allowed, \\\"NOT_FROM_INBOX\\\");\\n        uint256 count = inboxAccs.length;\\n        bytes32 messageHash =\\n            Messages.messageHash(\\n                kind,\\n                sender,\\n                block.number,\\n                block.timestamp, // solhint-disable-line not-rely-on-time\\n                count,\\n                tx.gasprice,\\n                messageDataHash\\n            );\\n        bytes32 prevAcc = 0;\\n        if (count > 0) {\\n            prevAcc = inboxAccs[count - 1];\\n        }\\n        inboxAccs.push(Messages.addMessageToInbox(prevAcc, messageHash));\\n        emit MessageDelivered(count, prevAcc, msg.sender, kind, sender, messageDataHash);\\n        return count;\\n    }\\n\\n    function executeCall(\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external override returns (bool success, bytes memory returnData) {\\n        require(allowedOutboxesMap[msg.sender].allowed, \\\"NOT_FROM_OUTBOX\\\");\\n        if (data.length > 0) require(destAddr.isContract(), \\\"NO_CODE_AT_DEST\\\");\\n        address currentOutbox = activeOutbox;\\n        activeOutbox = msg.sender;\\n        (success, returnData) = destAddr.call{ value: amount }(data);\\n        activeOutbox = currentOutbox;\\n    }\\n\\n    function setInbox(address inbox, bool enabled) external override onlyOwner {\\n        InOutInfo storage info = allowedInboxesMap[inbox];\\n        bool alreadyEnabled = info.allowed;\\n        if ((alreadyEnabled && enabled) || (!alreadyEnabled && !enabled)) {\\n            return;\\n        }\\n        if (enabled) {\\n            allowedInboxesMap[inbox] = InOutInfo(allowedInboxList.length, true);\\n            allowedInboxList.push(inbox);\\n        } else {\\n            allowedInboxList[info.index] = allowedInboxList[allowedInboxList.length - 1];\\n            allowedInboxesMap[allowedInboxList[info.index]].index = info.index;\\n            allowedInboxList.pop();\\n            delete allowedInboxesMap[inbox];\\n        }\\n    }\\n\\n    function setOutbox(address outbox, bool enabled) external override onlyOwner {\\n        InOutInfo storage info = allowedOutboxesMap[outbox];\\n        bool alreadyEnabled = info.allowed;\\n        if ((alreadyEnabled && enabled) || (!alreadyEnabled && !enabled)) {\\n            return;\\n        }\\n        if (enabled) {\\n            allowedOutboxesMap[outbox] = InOutInfo(allowedOutboxList.length, true);\\n            allowedOutboxList.push(outbox);\\n        } else {\\n            allowedOutboxList[info.index] = allowedOutboxList[allowedOutboxList.length - 1];\\n            allowedOutboxesMap[allowedOutboxList[info.index]].index = info.index;\\n            allowedOutboxList.pop();\\n            delete allowedOutboxesMap[outbox];\\n        }\\n    }\\n\\n    function messageCount() external view override returns (uint256) {\\n        return inboxAccs.length;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/Inbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./interfaces/IInbox.sol\\\";\\nimport \\\"./interfaces/IBridge.sol\\\";\\n\\nimport \\\"./Messages.sol\\\";\\nimport \\\"../libraries/Cloneable.sol\\\";\\nimport \\\"../libraries/Whitelist.sol\\\";\\n\\ncontract Inbox is IInbox, WhitelistConsumer, Cloneable {\\n    uint8 internal constant ETH_TRANSFER = 0;\\n    uint8 internal constant L2_MSG = 3;\\n    uint8 internal constant L1MessageType_L2FundedByL1 = 7;\\n    uint8 internal constant L1MessageType_submitRetryableTx = 9;\\n\\n    uint8 internal constant L2MessageType_unsignedEOATx = 0;\\n    uint8 internal constant L2MessageType_unsignedContractTx = 1;\\n\\n    IBridge public override bridge;\\n\\n    function initialize(IBridge _bridge, address _whitelist) external {\\n        require(address(bridge) == address(0), \\\"ALREADY_INIT\\\");\\n        bridge = _bridge;\\n        WhitelistConsumer.whitelist = _whitelist;\\n    }\\n\\n    /**\\n     * @notice Send a generic L2 message to the chain\\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\\n     * @param messageData Data of the message being sent\\n     */\\n    function sendL2MessageFromOrigin(bytes calldata messageData)\\n        external\\n        onlyWhitelisted\\n        returns (uint256)\\n    {\\n        // solhint-disable-next-line avoid-tx-origin\\n        require(msg.sender == tx.origin, \\\"origin only\\\");\\n        uint256 msgNum = deliverToBridge(L2_MSG, msg.sender, keccak256(messageData));\\n        emit InboxMessageDeliveredFromOrigin(msgNum);\\n        return msgNum;\\n    }\\n\\n    /**\\n     * @notice Send a generic L2 message to the chain\\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\\n     * @param messageData Data of the message being sent\\n     */\\n    function sendL2Message(bytes calldata messageData)\\n        external\\n        override\\n        onlyWhitelisted\\n        returns (uint256)\\n    {\\n        uint256 msgNum = deliverToBridge(L2_MSG, msg.sender, keccak256(messageData));\\n        emit InboxMessageDelivered(msgNum, messageData);\\n        return msgNum;\\n    }\\n\\n    function sendL1FundedUnsignedTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        uint256 nonce,\\n        address destAddr,\\n        bytes calldata data\\n    ) external payable virtual override onlyWhitelisted returns (uint256) {\\n        return\\n            _deliverMessage(\\n                L1MessageType_L2FundedByL1,\\n                msg.sender,\\n                abi.encodePacked(\\n                    L2MessageType_unsignedEOATx,\\n                    maxGas,\\n                    gasPriceBid,\\n                    nonce,\\n                    uint256(uint160(bytes20(destAddr))),\\n                    msg.value,\\n                    data\\n                )\\n            );\\n    }\\n\\n    function sendL1FundedContractTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        address destAddr,\\n        bytes calldata data\\n    ) external payable virtual override onlyWhitelisted returns (uint256) {\\n        return\\n            _deliverMessage(\\n                L1MessageType_L2FundedByL1,\\n                msg.sender,\\n                abi.encodePacked(\\n                    L2MessageType_unsignedContractTx,\\n                    maxGas,\\n                    gasPriceBid,\\n                    uint256(uint160(bytes20(destAddr))),\\n                    msg.value,\\n                    data\\n                )\\n            );\\n    }\\n\\n    function sendUnsignedTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        uint256 nonce,\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external virtual override onlyWhitelisted returns (uint256) {\\n        return\\n            _deliverMessage(\\n                L2_MSG,\\n                msg.sender,\\n                abi.encodePacked(\\n                    L2MessageType_unsignedEOATx,\\n                    maxGas,\\n                    gasPriceBid,\\n                    nonce,\\n                    uint256(uint160(bytes20(destAddr))),\\n                    amount,\\n                    data\\n                )\\n            );\\n    }\\n\\n    function sendContractTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external virtual override onlyWhitelisted returns (uint256) {\\n        return\\n            _deliverMessage(\\n                L2_MSG,\\n                msg.sender,\\n                abi.encodePacked(\\n                    L2MessageType_unsignedContractTx,\\n                    maxGas,\\n                    gasPriceBid,\\n                    uint256(uint160(bytes20(destAddr))),\\n                    amount,\\n                    data\\n                )\\n            );\\n    }\\n\\n    function depositEth(uint256 maxSubmissionCost)\\n        external\\n        payable\\n        virtual\\n        override\\n        onlyWhitelisted\\n        returns (uint256)\\n    {\\n        return\\n            _deliverMessage(\\n                L1MessageType_submitRetryableTx,\\n                msg.sender,\\n                abi.encodePacked(\\n                    uint256(uint160(bytes20(msg.sender))),\\n                    uint256(0),\\n                    msg.value,\\n                    maxSubmissionCost,\\n                    uint256(uint160(bytes20(msg.sender))),\\n                    uint256(uint160(bytes20(msg.sender))),\\n                    uint256(0),\\n                    uint256(0),\\n                    uint256(0),\\n                    \\\"\\\"\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice Put an message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\\n     * @dev all msg.value will deposited to callValueRefundAddress on L2\\n     * @param destAddr destination L2 contract address\\n     * @param l2CallValue call value for retryable L2 message\\n     * @param  maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\\n     * @param excessFeeRefundAddress maxgas x gasprice - execution cost gets credited here on L2 balance\\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\\n     * @param maxGas Max gas deducted from user's L2 balance to cover L2 execution\\n     * @param gasPriceBid price bid for L2 execution\\n     * @param data ABI encoded data of L2 message\\n     * @return unique id for retryable transaction (keccak256(requestID, uint(0) )\\n     */\\n    function createRetryableTicket(\\n        address destAddr,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        bytes calldata data\\n    ) external payable virtual override onlyWhitelisted returns (uint256) {\\n        return\\n            _deliverMessage(\\n                L1MessageType_submitRetryableTx,\\n                msg.sender,\\n                abi.encodePacked(\\n                    uint256(uint160(bytes20(destAddr))),\\n                    l2CallValue,\\n                    msg.value,\\n                    maxSubmissionCost,\\n                    uint256(uint160(bytes20(excessFeeRefundAddress))),\\n                    uint256(uint160(bytes20(callValueRefundAddress))),\\n                    maxGas,\\n                    gasPriceBid,\\n                    data.length,\\n                    data\\n                )\\n            );\\n    }\\n\\n    function _deliverMessage(\\n        uint8 _kind,\\n        address _sender,\\n        bytes memory _messageData\\n    ) internal returns (uint256) {\\n        uint256 msgNum = deliverToBridge(_kind, _sender, keccak256(_messageData));\\n        emit InboxMessageDelivered(msgNum, _messageData);\\n        return msgNum;\\n    }\\n\\n    function deliverToBridge(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) internal returns (uint256) {\\n        return bridge.deliverMessageToInbox{ value: msg.value }(kind, sender, messageDataHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/Outbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./OutboxEntry.sol\\\";\\n\\nimport \\\"./interfaces/IOutbox.sol\\\";\\nimport \\\"./interfaces/IBridge.sol\\\";\\n\\nimport \\\"./Messages.sol\\\";\\nimport \\\"../libraries/MerkleLib.sol\\\";\\nimport \\\"../libraries/BytesLib.sol\\\";\\nimport \\\"../libraries/Cloneable.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/proxy/BeaconProxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/UpgradeableBeacon.sol\\\";\\n\\ncontract Outbox is IOutbox, Cloneable {\\n    using BytesLib for bytes;\\n\\n    bytes1 internal constant MSG_ROOT = 0;\\n\\n    uint8 internal constant SendType_sendTxToL1 = 3;\\n\\n    address public rollup;\\n    IBridge public bridge;\\n\\n    UpgradeableBeacon public beacon;\\n    OutboxEntry[] public outboxes;\\n\\n    // Note, these variables are set and then wiped during a single transaction.\\n    // Therefore their values don't need to be maintained, and their slots will\\n    // be empty outside of transactions\\n    address internal _sender;\\n    uint128 internal _l2Block;\\n    uint128 internal _l1Block;\\n    uint128 internal _timestamp;\\n\\n    function initialize(address _rollup, IBridge _bridge) external {\\n        require(rollup == address(0), \\\"ALREADY_INIT\\\");\\n        rollup = _rollup;\\n        bridge = _bridge;\\n\\n        address outboxEntryTemplate = address(new OutboxEntry());\\n        beacon = new UpgradeableBeacon(outboxEntryTemplate);\\n        beacon.transferOwnership(_rollup);\\n    }\\n\\n    /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\\n    /// When the return value is zero, that means this is a system message\\n    function l2ToL1Sender() external view override returns (address) {\\n        return _sender;\\n    }\\n\\n    function l2ToL1Block() external view override returns (uint256) {\\n        return uint256(_l2Block);\\n    }\\n\\n    function l2ToL1EthBlock() external view override returns (uint256) {\\n        return uint256(_l1Block);\\n    }\\n\\n    function l2ToL1Timestamp() external view override returns (uint256) {\\n        return uint256(_timestamp);\\n    }\\n\\n    function processOutgoingMessages(bytes calldata sendsData, uint256[] calldata sendLengths)\\n        external\\n        override\\n    {\\n        require(msg.sender == rollup, \\\"ONLY_ROLLUP\\\");\\n        // If we've reached here, we've already confirmed that sum(sendLengths) == sendsData.length\\n        uint256 messageCount = sendLengths.length;\\n        uint256 offset = 0;\\n        for (uint256 i = 0; i < messageCount; i++) {\\n            handleOutgoingMessage(bytes(sendsData[offset:offset + sendLengths[i]]));\\n            offset += sendLengths[i];\\n        }\\n    }\\n\\n    function handleOutgoingMessage(bytes memory data) private {\\n        // Otherwise we have an unsupported message type and we skip the message\\n        if (data[0] == MSG_ROOT) {\\n            require(data.length == 97, \\\"BAD_LENGTH\\\");\\n            uint256 batchNum = data.toUint(1);\\n            uint256 numInBatch = data.toUint(33);\\n            bytes32 outputRoot = data.toBytes32(65);\\n\\n            address clone = address(new BeaconProxy(address(beacon), \\\"\\\"));\\n            OutboxEntry(clone).initialize(outputRoot, numInBatch);\\n            uint256 outboxIndex = outboxes.length;\\n            outboxes.push(OutboxEntry(clone));\\n            emit OutboxEntryCreated(batchNum, outboxIndex, outputRoot, numInBatch);\\n        }\\n    }\\n\\n    /**\\n     * @notice Executes a messages in an Outbox entry. Reverts if dispute period hasn't expired and\\n     * @param outboxIndex Index of OutboxEntry in outboxes array\\n     * @param proof Merkle proof of message inclusion in outbox entry\\n     * @param index Index of message in outbox entry\\n     * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\\n     * @param destAddr destination address for L1 contract call\\n     * @param l2Block l2 block number at which sendTxToL1 call was made\\n     * @param l1Block l1 block number at which sendTxToL1 call was made\\n     * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\\n     * @param amount value in L1 message in wei\\n     * @param calldataForL1 abi-encoded L1 message data\\n     */\\n    function executeTransaction(\\n        uint256 outboxIndex,\\n        bytes32[] calldata proof,\\n        uint256 index,\\n        address l2Sender,\\n        address destAddr,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 amount,\\n        bytes calldata calldataForL1\\n    ) external virtual {\\n        bytes32 userTx =\\n            calculateItemHash(\\n                l2Sender,\\n                destAddr,\\n                l2Block,\\n                l1Block,\\n                l2Timestamp,\\n                amount,\\n                calldataForL1\\n            );\\n\\n        spendOutput(outboxIndex, proof, index, userTx);\\n        emit OutBoxTransactionExecuted(destAddr, l2Sender, outboxIndex, index);\\n\\n        address currentSender = _sender;\\n        uint128 currentL2Block = _l2Block;\\n        uint128 currentL1Block = _l1Block;\\n        uint128 currentTimestamp = _timestamp;\\n\\n        _sender = l2Sender;\\n        _l2Block = uint128(l2Block);\\n        _l1Block = uint128(l1Block);\\n        _timestamp = uint128(l2Timestamp);\\n\\n        executeBridgeCall(destAddr, amount, calldataForL1);\\n\\n        _sender = currentSender;\\n        _l2Block = currentL2Block;\\n        _l1Block = currentL1Block;\\n        _timestamp = currentTimestamp;\\n    }\\n\\n    function spendOutput(\\n        uint256 outboxIndex,\\n        bytes32[] memory proof,\\n        uint256 path,\\n        bytes32 item\\n    ) internal {\\n        require(proof.length <= 256, \\\"PROOF_TOO_LONG\\\");\\n        require(path < 2**proof.length, \\\"PATH_NOT_MINIMAL\\\");\\n\\n        // Hash the leaf an extra time to prove it's a leaf\\n        bytes32 calcRoot = calculateMerkleRoot(proof, path, item);\\n        OutboxEntry outbox = outboxes[outboxIndex];\\n        require(address(outbox) != address(0), \\\"NO_OUTBOX\\\");\\n\\n        // With a minimal path, the pair of path and proof length should always identify\\n        // a unique leaf. The path itself is not enough since the path length to different\\n        // leaves could potentially be different\\n        bytes32 uniqueKey = keccak256(abi.encodePacked(path, proof.length));\\n        uint256 numRemaining = outbox.spendOutput(calcRoot, uniqueKey);\\n\\n        if (numRemaining == 0) {\\n            outbox.destroy();\\n            outboxes[outboxIndex] = OutboxEntry(address(0));\\n        }\\n    }\\n\\n    function executeBridgeCall(\\n        address destAddr,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal {\\n        (bool success, bytes memory returndata) = bridge.executeCall(destAddr, amount, data);\\n        if (!success) {\\n            if (returndata.length > 0) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(\\\"BRIDGE_CALL_FAILED\\\");\\n            }\\n        }\\n    }\\n\\n    function calculateItemHash(\\n        address l2Sender,\\n        address destAddr,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 amount,\\n        bytes calldata calldataForL1\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    SendType_sendTxToL1,\\n                    uint256(uint160(bytes20(l2Sender))),\\n                    uint256(uint160(bytes20(destAddr))),\\n                    l2Block,\\n                    l1Block,\\n                    l2Timestamp,\\n                    amount,\\n                    calldataForL1\\n                )\\n            );\\n    }\\n\\n    function calculateMerkleRoot(\\n        bytes32[] memory proof,\\n        uint256 path,\\n        bytes32 item\\n    ) public pure returns (bytes32) {\\n        return MerkleLib.calculateRoot(proof, path, keccak256(abi.encodePacked(item)));\\n    }\\n\\n    function outboxesLength() public view returns (uint256) {\\n        return outboxes.length;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/interfaces/IBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface IBridge {\\n    event MessageDelivered(\\n        uint256 indexed messageIndex,\\n        bytes32 indexed beforeInboxAcc,\\n        address inbox,\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    );\\n\\n    function deliverMessageToInbox(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable returns (uint256);\\n\\n    function executeCall(\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    // These are only callable by the admin\\n    function setInbox(address inbox, bool enabled) external;\\n\\n    function setOutbox(address inbox, bool enabled) external;\\n\\n    // View functions\\n\\n    function activeOutbox() external view returns (address);\\n\\n    function allowedInboxes(address inbox) external view returns (bool);\\n\\n    function allowedOutboxes(address outbox) external view returns (bool);\\n\\n    function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function messageCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/interfaces/IInbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IMessageProvider.sol\\\";\\n\\ninterface IInbox is IMessageProvider {\\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\\n\\n    function sendUnsignedTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        uint256 nonce,\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function sendContractTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function sendL1FundedUnsignedTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        uint256 nonce,\\n        address destAddr,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function sendL1FundedContractTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        address destAddr,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function createRetryableTicket(\\n        address destAddr,\\n        uint256 arbTxCallValue,\\n        uint256 maxSubmissionCost,\\n        address submissionRefundAddress,\\n        address valueRefundAddress,\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\\n\\n    function bridge() external view returns (IBridge);\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/Messages.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nlibrary Messages {\\n    function messageHash(\\n        uint8 kind,\\n        address sender,\\n        uint256 blockNumber,\\n        uint256 timestamp,\\n        uint256 inboxSeqNum,\\n        uint256 gasPriceL1,\\n        bytes32 messageDataHash\\n    ) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    kind,\\n                    sender,\\n                    blockNumber,\\n                    timestamp,\\n                    inboxSeqNum,\\n                    gasPriceL1,\\n                    messageDataHash\\n                )\\n            );\\n    }\\n\\n    function addMessageToInbox(bytes32 inbox, bytes32 message) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(inbox, message));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Cloneable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./ICloneable.sol\\\";\\n\\ncontract Cloneable is ICloneable {\\n    string private constant NOT_CLONE = \\\"NOT_CLONE\\\";\\n\\n    bool private isMasterCopy;\\n\\n    constructor() public {\\n        isMasterCopy = true;\\n    }\\n\\n    function isMaster() external view override returns (bool) {\\n        return isMasterCopy;\\n    }\\n\\n    function safeSelfDestruct(address payable dest) internal {\\n        require(!isMasterCopy, NOT_CLONE);\\n        selfdestruct(dest);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Whitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nabstract contract WhitelistConsumer {\\n    address public whitelist;\\n\\n    event WhitelistSourceUpdated(address newSource);\\n\\n    modifier onlyWhitelisted {\\n        if (whitelist != address(0)) {\\n            require(Whitelist(whitelist).isAllowed(msg.sender), \\\"NOT_WHITELISTED\\\");\\n        }\\n        _;\\n    }\\n\\n    function updateWhitelistSource(address newSource) external {\\n        require(msg.sender == whitelist, \\\"NOT_FROM_LIST\\\");\\n        whitelist = newSource;\\n        emit WhitelistSourceUpdated(newSource);\\n    }\\n}\\n\\ncontract Whitelist {\\n    address public owner;\\n    mapping(address => bool) public isAllowed;\\n\\n    event OwnerUpdated(address newOwner);\\n    event WhitelistUpgraded(address newWhitelist, address[] targets);\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"ONLY_OWNER\\\");\\n        _;\\n    }\\n\\n    function setOwner(address newOwner) external onlyOwner {\\n        owner = newOwner;\\n        emit OwnerUpdated(newOwner);\\n    }\\n\\n    function setWhitelist(address[] memory user, bool[] memory val) external onlyOwner {\\n        require(user.length == val.length, \\\"INVALID_INPUT\\\");\\n\\n        for (uint256 i = 0; i < user.length; i++) {\\n            isAllowed[user[i]] = val[i];\\n        }\\n    }\\n\\n    // set new whitelist to address(0) to disable whitelist\\n    function triggerConsumers(address newWhitelist, address[] memory targets) external onlyOwner {\\n        for (uint256 i = 0; i < targets.length; i++) {\\n            WhitelistConsumer(targets[i]).updateWhitelistSource(newWhitelist);\\n        }\\n        emit WhitelistUpgraded(newWhitelist, targets);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/interfaces/IMessageProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface IMessageProvider {\\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\\n\\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ICloneable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface ICloneable {\\n    function isMaster() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/OutboxEntry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../libraries/Cloneable.sol\\\";\\n\\ncontract OutboxEntry is Cloneable {\\n    address outbox;\\n    bytes32 public root;\\n    uint256 public numRemaining;\\n    mapping(bytes32 => bool) public spentOutput;\\n\\n    function initialize(bytes32 _root, uint256 _numInBatch) external {\\n        require(outbox == address(0), \\\"ALREADY_INIT\\\");\\n        require(root == 0, \\\"ALREADY_INIT\\\");\\n        require(_root != 0, \\\"BAD_ROOT\\\");\\n        outbox = msg.sender;\\n        root = _root;\\n        numRemaining = _numInBatch;\\n    }\\n\\n    function spendOutput(bytes32 _root, bytes32 _id) external returns (uint256) {\\n        require(msg.sender == outbox, \\\"NOT_FROM_OUTBOX\\\");\\n        require(!spentOutput[_id], \\\"ALREADY_SPENT\\\");\\n        require(_root == root, \\\"BAD_ROOT\\\");\\n\\n        spentOutput[_id] = true;\\n        numRemaining--;\\n\\n        return numRemaining;\\n    }\\n\\n    function destroy() external {\\n        require(msg.sender == outbox, \\\"NOT_FROM_OUTBOX\\\");\\n        safeSelfDestruct(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/interfaces/IOutbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface IOutbox {\\n    event OutboxEntryCreated(\\n        uint256 indexed batchNum,\\n        uint256 outboxIndex,\\n        bytes32 outputRoot,\\n        uint256 numInBatch\\n    );\\n    event OutBoxTransactionExecuted(\\n        address indexed destAddr,\\n        address indexed l2Sender,\\n        uint256 indexed outboxIndex,\\n        uint256 transactionIndex\\n    );\\n\\n    function l2ToL1Sender() external view returns (address);\\n\\n    function l2ToL1Block() external view returns (uint256);\\n\\n    function l2ToL1EthBlock() external view returns (uint256);\\n\\n    function l2ToL1Timestamp() external view returns (uint256);\\n\\n    function processOutgoingMessages(bytes calldata sendsData, uint256[] calldata sendLengths)\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/MerkleLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nlibrary MerkleLib {\\n    function generateRoot(bytes32[] memory _hashes) internal pure returns (bytes32) {\\n        bytes32[] memory prevLayer = _hashes;\\n        while (prevLayer.length > 1) {\\n            bytes32[] memory nextLayer = new bytes32[]((prevLayer.length + 1) / 2);\\n            for (uint256 i = 0; i < nextLayer.length; i++) {\\n                if (2 * i + 1 < prevLayer.length) {\\n                    nextLayer[i] = keccak256(\\n                        abi.encodePacked(prevLayer[2 * i], prevLayer[2 * i + 1])\\n                    );\\n                } else {\\n                    nextLayer[i] = prevLayer[2 * i];\\n                }\\n            }\\n            prevLayer = nextLayer;\\n        }\\n        return prevLayer[0];\\n    }\\n\\n    function calculateRoot(\\n        bytes32[] memory nodes,\\n        uint256 route,\\n        bytes32 item\\n    ) internal pure returns (bytes32) {\\n        uint256 proofItems = nodes.length;\\n        require(proofItems <= 256);\\n        bytes32 h = item;\\n        for (uint256 i = 0; i < proofItems; i++) {\\n            if (route % 2 == 0) {\\n                h = keccak256(abi.encodePacked(nodes[i], h));\\n            } else {\\n                h = keccak256(abi.encodePacked(h, nodes[i]));\\n            }\\n            route /= 2;\\n        }\\n        return h;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BytesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\n\\npragma solidity ^0.6.11;\\n\\n/* solhint-disable no-inline-assembly */\\nlibrary BytesLib {\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= (_start + 20), \\\"Read out of bounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= (_start + 1), \\\"Read out of bounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= (_start + 32), \\\"Read out of bounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= (_start + 32), \\\"Read out of bounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n}\\n/* solhint-enable no-inline-assembly */\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/BeaconProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"./IBeacon.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\\n *\\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\\n * conflict with the storage layout of the implementation behind the proxy.\\n *\\n * _Available since v3.4._\\n */\\ncontract BeaconProxy is Proxy {\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 private constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Initializes the proxy with `beacon`.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\\n     * constructor.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract with the interface {IBeacon}.\\n     */\\n    constructor(address beacon, bytes memory data) public payable {\\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.beacon\\\")) - 1));\\n        _setBeacon(beacon, data);\\n    }\\n\\n    /**\\n     * @dev Returns the current beacon address.\\n     */\\n    function _beacon() internal view virtual returns (address beacon) {\\n        bytes32 slot = _BEACON_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            beacon := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address of the associated beacon.\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return IBeacon(_beacon()).implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the proxy to use a new beacon.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract.\\n     * - The implementation returned by `beacon` must be a contract.\\n     */\\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\\n        require(\\n            Address.isContract(beacon),\\n            \\\"BeaconProxy: beacon is not a contract\\\"\\n        );\\n        require(\\n            Address.isContract(IBeacon(beacon).implementation()),\\n            \\\"BeaconProxy: beacon implementation is not a contract\\\"\\n        );\\n        bytes32 slot = _BEACON_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, beacon)\\n        }\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(_implementation(), data, \\\"BeaconProxy: function call failed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/UpgradeableBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"../access/Ownable.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\n\\n/**\\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\\n * implementation contract, which is where they will delegate all function calls.\\n *\\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\\n */\\ncontract UpgradeableBeacon is IBeacon, Ownable {\\n    address private _implementation;\\n\\n    /**\\n     * @dev Emitted when the implementation returned by the beacon is changed.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\\n     * beacon.\\n     */\\n    constructor(address implementation_) public {\\n        _setImplementation(implementation_);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function implementation() public view virtual override returns (address) {\\n        return _implementation;\\n    }\\n\\n    /**\\n     * @dev Upgrades the beacon to a new implementation.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * Requirements:\\n     *\\n     * - msg.sender must be the owner of the contract.\\n     * - `newImplementation` must be a contract.\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Sets the implementation contract address for this beacon\\n     *\\n     * Requirements:\\n     *\\n     * - `newImplementation` must be a contract.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"UpgradeableBeacon: implementation is not a contract\\\");\\n        _implementation = newImplementation;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\nimport \\\"../proxy/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\nimport \\\"../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"beforeInboxAcc\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"}],\"name\":\"MessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activeOutbox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedInboxList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"}],\"name\":\"allowedInboxes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedOutboxList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"}],\"name\":\"allowedOutboxes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"}],\"name\":\"deliverMessageToInbox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"inboxAccs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setOutbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Bridge","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}