{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-04-21\r\n*/\r\n\r\npragma solidity ^0.7.6;\r\n\r\n// SPDX-License-Identifier: MIT\r\n// Source code: https://github.com/DeCash-Official/smart-contracts\r\n\r\ninterface ERC20 {\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool);\r\n\r\n    function transferMany(address[] calldata _tos, uint256[] calldata _values)\r\n        external\r\n        returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n    function mint(address _to, uint256 _value) external returns (bool);\r\n\r\n    function burn(uint256 _value) external returns (bool);\r\n\r\n    function burnFrom(address _from, uint256 _value) external returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Signature {\r\n    enum Std {typed, personal, stringHex}\r\n\r\n    enum Dest {transfer, transferFrom, transferMany, approve, approveAndCall}\r\n\r\n    bytes public constant ETH_SIGNED_MESSAGE_PREFIX =\r\n        \"\\x19Ethereum Signed Message:\\n\";\r\n\r\n    // `transferViaSignature`: keccak256(abi.encodePacked(address(this), from, to, value, fee, deadline, sigId))\r\n    bytes32 public constant DEST_TRANSFER =\r\n        keccak256(\r\n            abi.encodePacked(\r\n                \"address Contract\",\r\n                \"address Sender\",\r\n                \"address Recipient\",\r\n                \"uint256 Amount (last 2 digits are decimals)\",\r\n                \"uint256 Fee Amount (last 2 digits are decimals)\",\r\n                \"address Fee Address\",\r\n                \"uint256 Expiration\",\r\n                \"uint256 Signature ID\"\r\n            )\r\n        );\r\n\r\n    // `transferManyViaSignature`: keccak256(abi.encodePacked(address(this), from, to/value array, deadline, sigId))\r\n    bytes32 public constant DEST_TRANSFER_MANY =\r\n        keccak256(\r\n            abi.encodePacked(\r\n                \"address Contract\",\r\n                \"address Sender\",\r\n                \"bytes32 Recipient/Amount Array hash\",\r\n                \"uint256 Fee Amount (last 2 digits are decimals)\",\r\n                \"address Fee Address\",\r\n                \"uint256 Expiration\",\r\n                \"uint256 Signature ID\"\r\n            )\r\n        );\r\n\r\n    // `transferFromViaSignature`: keccak256(abi.encodePacked(address(this), signer, from, to, value, fee, deadline, sigId))\r\n    bytes32 public constant DEST_TRANSFER_FROM =\r\n        keccak256(\r\n            abi.encodePacked(\r\n                \"address Contract\",\r\n                \"address Approved\",\r\n                \"address From\",\r\n                \"address Recipient\",\r\n                \"uint256 Amount (last 2 digits are decimals)\",\r\n                \"uint256 Fee Amount (last 2 digits are decimals)\",\r\n                \"address Fee Address\",\r\n                \"uint256 Expiration\",\r\n                \"uint256 Signature ID\"\r\n            )\r\n        );\r\n\r\n    // `approveViaSignature`: keccak256(abi.encodePacked(address(this), from, spender, value, fee, deadline, sigId))\r\n    bytes32 public constant DEST_APPROVE =\r\n        keccak256(\r\n            abi.encodePacked(\r\n                \"address Contract\",\r\n                \"address Approval\",\r\n                \"address Recipient\",\r\n                \"uint256 Amount (last 2 digits are decimals)\",\r\n                \"uint256 Fee Amount (last 2 digits are decimals)\",\r\n                \"address Fee Address\",\r\n                \"uint256 Expiration\",\r\n                \"uint256 Signature ID\"\r\n            )\r\n        );\r\n\r\n    // `approveAndCallViaSignature`: keccak256(abi.encodePacked(address(this), from, spender, value, extraData, fee, deadline, sigId))\r\n    bytes32 public constant DEST_APPROVE_AND_CALL =\r\n        keccak256(\r\n            abi.encodePacked(\r\n                \"address Contract\",\r\n                \"address Approval\",\r\n                \"address Recipient\",\r\n                \"uint256 Amount (last 2 digits are decimals)\",\r\n                \"bytes Data to Transfer\",\r\n                \"uint256 Fee Amount (last 2 digits are decimals)\",\r\n                \"address Fee Address\",\r\n                \"uint256 Expiration\",\r\n                \"uint256 Signature ID\"\r\n            )\r\n        );\r\n\r\n    /**\r\n     * Utility costly function to encode bytes HEX representation as string.\r\n     *\r\n     * @param sig - signature as bytes32 to represent as string\r\n     */\r\n    function hexToString(bytes32 sig) internal pure returns (bytes memory) {\r\n        bytes memory str = new bytes(64);\r\n\r\n        for (uint8 i = 0; i < 32; ++i) {\r\n            str[2 * i] = bytes1(\r\n                (uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16\r\n            );\r\n            str[2 * i + 1] = bytes1(\r\n                (uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16)\r\n            );\r\n        }\r\n\r\n        return str;\r\n    }\r\n\r\n    /**\r\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\r\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\r\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\r\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\r\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\r\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\r\n     * third-party wallets must adopt a single standard for signing messages.\r\n     *\r\n     * @param _data      - original data which had to be signed by `signer`\r\n     * @param _signer    - account which made a signature\r\n     * @param _sig       - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\r\n     * @param _sigStd    - chosen standard for signature validation. The signer must explicitly tell which standard they use\r\n     * @param _sigDest   - for which type of action this signature was made for\r\n     */\r\n    function requireSignature(\r\n        bytes32 _data,\r\n        address _signer,\r\n        bytes memory _sig,\r\n        Std _sigStd,\r\n        Dest _sigDest\r\n    ) internal {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        assembly {\r\n            // solium-disable-line security/no-inline-assembly\r\n            r := mload(add(_sig, 32))\r\n            s := mload(add(_sig, 64))\r\n            v := byte(0, mload(add(_sig, 96)))\r\n        }\r\n\r\n        if (v < 27) v += 27;\r\n\r\n        if (_sigStd == Std.typed) {\r\n            bytes32 dest;\r\n\r\n            if (_sigDest == Dest.transfer) {\r\n                dest = DEST_TRANSFER;\r\n            } else if (_sigDest == Dest.transferMany) {\r\n                dest = DEST_TRANSFER_MANY;\r\n            } else if (_sigDest == Dest.transferFrom) {\r\n                dest = DEST_TRANSFER_FROM;\r\n            } else if (_sigDest == Dest.approve) {\r\n                dest = DEST_APPROVE;\r\n            } else if (_sigDest == Dest.approveAndCall) {\r\n                dest = DEST_APPROVE_AND_CALL;\r\n            }\r\n\r\n            // Typed signature. This is the most likely scenario to be used and accepted\r\n            require(\r\n                _signer ==\r\n                    ecrecover(\r\n                        keccak256(abi.encodePacked(dest, _data)),\r\n                        v,\r\n                        r,\r\n                        s\r\n                    ),\r\n                \"Invalid typed signature\"\r\n            );\r\n        } else if (_sigStd == Std.personal) {\r\n            // Ethereum signed message signature (Geth and Trezor)\r\n            require(\r\n                _signer ==\r\n                    ecrecover(\r\n                        keccak256(\r\n                            abi.encodePacked(\r\n                                ETH_SIGNED_MESSAGE_PREFIX,\r\n                                \"32\",\r\n                                _data\r\n                            )\r\n                        ),\r\n                        v,\r\n                        r,\r\n                        s\r\n                    ) || // Geth-adopted\r\n                    _signer ==\r\n                    ecrecover(\r\n                        keccak256(\r\n                            abi.encodePacked(\r\n                                ETH_SIGNED_MESSAGE_PREFIX,\r\n                                \"\\x20\",\r\n                                _data\r\n                            )\r\n                        ),\r\n                        v,\r\n                        r,\r\n                        s\r\n                    ), // Trezor-adopted\r\n                \"Invalid personal signature\"\r\n            );\r\n        } else {\r\n            // == 2; Signed string hash signature (the most expensive but universal)\r\n            require(\r\n                _signer ==\r\n                    ecrecover(\r\n                        keccak256(\r\n                            abi.encodePacked(\r\n                                ETH_SIGNED_MESSAGE_PREFIX,\r\n                                \"64\",\r\n                                hexToString(_data)\r\n                            )\r\n                        ),\r\n                        v,\r\n                        r,\r\n                        s\r\n                    ) || // Geth\r\n                    _signer ==\r\n                    ecrecover(\r\n                        keccak256(\r\n                            abi.encodePacked(\r\n                                ETH_SIGNED_MESSAGE_PREFIX,\r\n                                \"\\x40\",\r\n                                hexToString(_data)\r\n                            )\r\n                        ),\r\n                        v,\r\n                        r,\r\n                        s\r\n                    ), // Trezor\r\n                \"Invalid stringHex signature\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function return the signature of the array of recipient/value pair\r\n     *\r\n     * @param _tos[]         - array of account recipients\r\n     * @param _values[]      - array of amount\r\n     */\r\n    function calculateManySig(address[] memory _tos, uint256[] memory _values)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        bytes32 tv = keccak256(abi.encodePacked(_tos[0], _values[0]));\r\n\r\n        uint256 ln = _tos.length;\r\n\r\n        for (uint8 x = 1; x < ln; x++) {\r\n            tv = keccak256(abi.encodePacked(tv, _tos[x], _values[x]));\r\n        }\r\n\r\n        return tv;\r\n    }\r\n}\r\n\r\ninterface DeCashStorageInterface {\r\n    // Getters\r\n    function getAddress(bytes32 _key) external view returns (address);\r\n\r\n    function getUint(bytes32 _key) external view returns (uint256);\r\n\r\n    function getString(bytes32 _key) external view returns (string memory);\r\n\r\n    function getBytes(bytes32 _key) external view returns (bytes memory);\r\n\r\n    function getBool(bytes32 _key) external view returns (bool);\r\n\r\n    function getInt(bytes32 _key) external view returns (int256);\r\n\r\n    function getBytes32(bytes32 _key) external view returns (bytes32);\r\n\r\n    // Setters\r\n    function setAddress(bytes32 _key, address _value) external;\r\n\r\n    function setUint(bytes32 _key, uint256 _value) external;\r\n\r\n    function setString(bytes32 _key, string calldata _value) external;\r\n\r\n    function setBytes(bytes32 _key, bytes calldata _value) external;\r\n\r\n    function setBool(bytes32 _key, bool _value) external;\r\n\r\n    function setInt(bytes32 _key, int256 _value) external;\r\n\r\n    function setBytes32(bytes32 _key, bytes32 _value) external;\r\n\r\n    // Deleters\r\n    function deleteAddress(bytes32 _key) external;\r\n\r\n    function deleteUint(bytes32 _key) external;\r\n\r\n    function deleteString(bytes32 _key) external;\r\n\r\n    function deleteBytes(bytes32 _key) external;\r\n\r\n    function deleteBool(bytes32 _key) external;\r\n\r\n    function deleteInt(bytes32 _key) external;\r\n\r\n    function deleteBytes32(bytes32 _key) external;\r\n}\r\n\r\n/// @title Base settings / modifiers for each contract in DeCash Token (Credits David Rugendyke/Rocket Pool)\r\n/// @author Fabrizio Amodio (ZioFabry)\r\n\r\nabstract contract DeCashBase {\r\n    // Version of the contract\r\n    uint8 public version;\r\n\r\n    // The main storage contract where primary persistant storage is maintained\r\n    DeCashStorageInterface internal _decashStorage = DeCashStorageInterface(0);\r\n\r\n    /**\r\n     * @dev Throws if called by any sender that doesn't match one of the supplied contract or is the latest version of that contract\r\n     */\r\n    modifier onlyLatestContract(\r\n        string memory _contractName,\r\n        address _contractAddress\r\n    ) {\r\n        require(\r\n            _contractAddress ==\r\n                _getAddress(\r\n                    keccak256(\r\n                        abi.encodePacked(\"contract.address\", _contractName)\r\n                    )\r\n                ),\r\n            \"Invalid or outdated contract\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_isOwner(msg.sender), \"Account is not the owner\");\r\n        _;\r\n    }\r\n    modifier onlyAdmin() {\r\n        require(_isAdmin(msg.sender), \"Account is not an admin\");\r\n        _;\r\n    }\r\n    modifier onlySuperUser() {\r\n        require(_isSuperUser(msg.sender), \"Account is not a super user\");\r\n        _;\r\n    }\r\n    modifier onlyDelegator(address _address) {\r\n        require(_isDelegator(_address), \"Account is not a delegator\");\r\n        _;\r\n    }\r\n    modifier onlyFeeRecipient(address _address) {\r\n        require(_isFeeRecipient(_address), \"Account is not a fee recipient\");\r\n        _;\r\n    }\r\n    modifier onlyRole(string memory _role) {\r\n        require(_roleHas(_role, msg.sender), \"Account does not match the role\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Set the main DeCash Storage address\r\n    constructor(address _decashStorageAddress) {\r\n        // Update the contract address\r\n        _decashStorage = DeCashStorageInterface(_decashStorageAddress);\r\n    }\r\n\r\n    function isOwner(address _address) external view returns (bool) {\r\n        return _isOwner(_address);\r\n    }\r\n\r\n    function isAdmin(address _address) external view returns (bool) {\r\n        return _isAdmin(_address);\r\n    }\r\n\r\n    function isSuperUser(address _address) external view returns (bool) {\r\n        return _isSuperUser(_address);\r\n    }\r\n\r\n    function isDelegator(address _address) external view returns (bool) {\r\n        return _isDelegator(_address);\r\n    }\r\n\r\n    function isFeeRecipient(address _address) external view returns (bool) {\r\n        return _isFeeRecipient(_address);\r\n    }\r\n\r\n    function isBlacklisted(address _address) external view returns (bool) {\r\n        return _isBlacklisted(_address);\r\n    }\r\n\r\n    /// @dev Get the address of a network contract by name\r\n    function _getContractAddress(string memory _contractName)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        // Get the current contract address\r\n        address contractAddress =\r\n            _getAddress(\r\n                keccak256(abi.encodePacked(\"contract.address\", _contractName))\r\n            );\r\n        // Check it\r\n        require(contractAddress != address(0x0), \"Contract not found\");\r\n        // Return\r\n        return contractAddress;\r\n    }\r\n\r\n    /// @dev Get the name of a network contract by address\r\n    function _getContractName(address _contractAddress)\r\n        internal\r\n        view\r\n        returns (string memory)\r\n    {\r\n        // Get the contract name\r\n        string memory contractName =\r\n            _getString(\r\n                keccak256(abi.encodePacked(\"contract.name\", _contractAddress))\r\n            );\r\n        // Check it\r\n        require(\r\n            keccak256(abi.encodePacked(contractName)) !=\r\n                keccak256(abi.encodePacked(\"\")),\r\n            \"Contract not found\"\r\n        );\r\n        // Return\r\n        return contractName;\r\n    }\r\n\r\n    /// @dev Role Management\r\n    function _roleHas(string memory _role, address _address)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            _getBool(\r\n                keccak256(abi.encodePacked(\"access.role\", _role, _address))\r\n            );\r\n    }\r\n\r\n    function _isOwner(address _address) internal view returns (bool) {\r\n        return _roleHas(\"owner\", _address);\r\n    }\r\n\r\n    function _isAdmin(address _address) internal view returns (bool) {\r\n        return _roleHas(\"admin\", _address);\r\n    }\r\n\r\n    function _isSuperUser(address _address) internal view returns (bool) {\r\n        return _roleHas(\"admin\", _address) || _isOwner(_address);\r\n    }\r\n\r\n    function _isDelegator(address _address) internal view returns (bool) {\r\n        return _roleHas(\"delegator\", _address) || _isOwner(_address);\r\n    }\r\n\r\n    function _isFeeRecipient(address _address) internal view returns (bool) {\r\n        return _roleHas(\"fee\", _address) || _isOwner(_address);\r\n    }\r\n\r\n    function _isBlacklisted(address _address) internal view returns (bool) {\r\n        return _roleHas(\"blacklisted\", _address) && !_isOwner(_address);\r\n    }\r\n\r\n    /// @dev Storage get methods\r\n    function _getAddress(bytes32 _key) internal view returns (address) {\r\n        return _decashStorage.getAddress(_key);\r\n    }\r\n\r\n    function _getUint(bytes32 _key) internal view returns (uint256) {\r\n        return _decashStorage.getUint(_key);\r\n    }\r\n\r\n    function _getString(bytes32 _key) internal view returns (string memory) {\r\n        return _decashStorage.getString(_key);\r\n    }\r\n\r\n    function _getBytes(bytes32 _key) internal view returns (bytes memory) {\r\n        return _decashStorage.getBytes(_key);\r\n    }\r\n\r\n    function _getBool(bytes32 _key) internal view returns (bool) {\r\n        return _decashStorage.getBool(_key);\r\n    }\r\n\r\n    function _getInt(bytes32 _key) internal view returns (int256) {\r\n        return _decashStorage.getInt(_key);\r\n    }\r\n\r\n    function _getBytes32(bytes32 _key) internal view returns (bytes32) {\r\n        return _decashStorage.getBytes32(_key);\r\n    }\r\n\r\n    function _getAddressS(string memory _key) internal view returns (address) {\r\n        return _decashStorage.getAddress(keccak256(abi.encodePacked(_key)));\r\n    }\r\n\r\n    function _getUintS(string memory _key) internal view returns (uint256) {\r\n        return _decashStorage.getUint(keccak256(abi.encodePacked(_key)));\r\n    }\r\n\r\n    function _getStringS(string memory _key)\r\n        internal\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return _decashStorage.getString(keccak256(abi.encodePacked(_key)));\r\n    }\r\n\r\n    function _getBytesS(string memory _key)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return _decashStorage.getBytes(keccak256(abi.encodePacked(_key)));\r\n    }\r\n\r\n    function _getBoolS(string memory _key) internal view returns (bool) {\r\n        return _decashStorage.getBool(keccak256(abi.encodePacked(_key)));\r\n    }\r\n\r\n    function _getIntS(string memory _key) internal view returns (int256) {\r\n        return _decashStorage.getInt(keccak256(abi.encodePacked(_key)));\r\n    }\r\n\r\n    function _getBytes32S(string memory _key) internal view returns (bytes32) {\r\n        return _decashStorage.getBytes32(keccak256(abi.encodePacked(_key)));\r\n    }\r\n\r\n    /// @dev Storage set methods\r\n    function _setAddress(bytes32 _key, address _value) internal {\r\n        _decashStorage.setAddress(_key, _value);\r\n    }\r\n\r\n    function _setUint(bytes32 _key, uint256 _value) internal {\r\n        _decashStorage.setUint(_key, _value);\r\n    }\r\n\r\n    function _setString(bytes32 _key, string memory _value) internal {\r\n        _decashStorage.setString(_key, _value);\r\n    }\r\n\r\n    function _setBytes(bytes32 _key, bytes memory _value) internal {\r\n        _decashStorage.setBytes(_key, _value);\r\n    }\r\n\r\n    function _setBool(bytes32 _key, bool _value) internal {\r\n        _decashStorage.setBool(_key, _value);\r\n    }\r\n\r\n    function _setInt(bytes32 _key, int256 _value) internal {\r\n        _decashStorage.setInt(_key, _value);\r\n    }\r\n\r\n    function _setBytes32(bytes32 _key, bytes32 _value) internal {\r\n        _decashStorage.setBytes32(_key, _value);\r\n    }\r\n\r\n    function _setAddressS(string memory _key, address _value) internal {\r\n        _decashStorage.setAddress(keccak256(abi.encodePacked(_key)), _value);\r\n    }\r\n\r\n    function _setUintS(string memory _key, uint256 _value) internal {\r\n        _decashStorage.setUint(keccak256(abi.encodePacked(_key)), _value);\r\n    }\r\n\r\n    function _setStringS(string memory _key, string memory _value) internal {\r\n        _decashStorage.setString(keccak256(abi.encodePacked(_key)), _value);\r\n    }\r\n\r\n    function _setBytesS(string memory _key, bytes memory _value) internal {\r\n        _decashStorage.setBytes(keccak256(abi.encodePacked(_key)), _value);\r\n    }\r\n\r\n    function _setBoolS(string memory _key, bool _value) internal {\r\n        _decashStorage.setBool(keccak256(abi.encodePacked(_key)), _value);\r\n    }\r\n\r\n    function _setIntS(string memory _key, int256 _value) internal {\r\n        _decashStorage.setInt(keccak256(abi.encodePacked(_key)), _value);\r\n    }\r\n\r\n    function _setBytes32S(string memory _key, bytes32 _value) internal {\r\n        _decashStorage.setBytes32(keccak256(abi.encodePacked(_key)), _value);\r\n    }\r\n\r\n    /// @dev Storage delete methods\r\n    function _deleteAddress(bytes32 _key) internal {\r\n        _decashStorage.deleteAddress(_key);\r\n    }\r\n\r\n    function _deleteUint(bytes32 _key) internal {\r\n        _decashStorage.deleteUint(_key);\r\n    }\r\n\r\n    function _deleteString(bytes32 _key) internal {\r\n        _decashStorage.deleteString(_key);\r\n    }\r\n\r\n    function _deleteBytes(bytes32 _key) internal {\r\n        _decashStorage.deleteBytes(_key);\r\n    }\r\n\r\n    function _deleteBool(bytes32 _key) internal {\r\n        _decashStorage.deleteBool(_key);\r\n    }\r\n\r\n    function _deleteInt(bytes32 _key) internal {\r\n        _decashStorage.deleteInt(_key);\r\n    }\r\n\r\n    function _deleteBytes32(bytes32 _key) internal {\r\n        _decashStorage.deleteBytes32(_key);\r\n    }\r\n\r\n    function _deleteAddressS(string memory _key) internal {\r\n        _decashStorage.deleteAddress(keccak256(abi.encodePacked(_key)));\r\n    }\r\n\r\n    function _deleteUintS(string memory _key) internal {\r\n        _decashStorage.deleteUint(keccak256(abi.encodePacked(_key)));\r\n    }\r\n\r\n    function _deleteStringS(string memory _key) internal {\r\n        _decashStorage.deleteString(keccak256(abi.encodePacked(_key)));\r\n    }\r\n\r\n    function _deleteBytesS(string memory _key) internal {\r\n        _decashStorage.deleteBytes(keccak256(abi.encodePacked(_key)));\r\n    }\r\n\r\n    function _deleteBoolS(string memory _key) internal {\r\n        _decashStorage.deleteBool(keccak256(abi.encodePacked(_key)));\r\n    }\r\n\r\n    function _deleteIntS(string memory _key) internal {\r\n        _decashStorage.deleteInt(keccak256(abi.encodePacked(_key)));\r\n    }\r\n\r\n    function _deleteBytes32S(string memory _key) internal {\r\n        _decashStorage.deleteBytes32(keccak256(abi.encodePacked(_key)));\r\n    }\r\n}\r\n\r\n/// @title DeCash Token Multisignature Management\r\n/// @author Fabrizio Amodio (ZioFabry)\r\n\r\nabstract contract DeCashMultisignature {\r\n    bytes32[] public allOperations;\r\n    mapping(bytes32 => uint256) public allOperationsIndicies;\r\n    mapping(bytes32 => uint256) public votesCountByOperation;\r\n    mapping(bytes32 => address) public firstByOperation;\r\n    mapping(bytes32 => mapping(address => uint8)) public votesOwnerByOperation;\r\n    mapping(bytes32 => address[]) public votesIndicesByOperation;\r\n\r\n    uint256 public signerGeneration;\r\n    address internal _insideCallSender;\r\n    uint256 internal _insideCallCount;\r\n\r\n    event RequiredSignerChanged(\r\n        uint256 newRequiredSignature,\r\n        uint256 generation\r\n    );\r\n    event OperationCreated(bytes32 operation, address proposer);\r\n    event OperationUpvoted(bytes32 operation, address voter);\r\n    event OperationPerformed(bytes32 operation, address performer);\r\n    event OperationCancelled(bytes32 operation, address performer);\r\n\r\n    /**\r\n     * @dev Allows to perform method only after many owners call it with the same arguments\r\n     * @param _howMany defines how mant signature are required\r\n     * @param _generation multiusignature generation\r\n     */\r\n    modifier onlyMultiSignature(uint256 _howMany, uint256 _generation) {\r\n        if (_checkMultiSignature(_howMany, _generation)) {\r\n            bool update = (_insideCallSender == address(0));\r\n            if (update) {\r\n                _insideCallSender = msg.sender;\r\n                _insideCallCount = _howMany;\r\n            }\r\n\r\n            _;\r\n\r\n            if (update) {\r\n                _insideCallSender = address(0);\r\n                _insideCallCount = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Allows owners to change their mind by cacnelling votesMaskByOperation operations\r\n     * @param operation defines which operation to delete\r\n     */\r\n    function cancelOperation(bytes32 operation) external {\r\n        require(votesCountByOperation[operation] > 0, \"Operation not found\");\r\n\r\n        _deleteOperation(operation);\r\n\r\n        emit OperationCancelled(operation, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev onlyManyOwners modifier helper\r\n     * @param _howMany defines how mant signature are required\r\n     * @param _generation multiusignature generation\r\n     */\r\n    function _checkMultiSignature(uint256 _howMany, uint256 _generation)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (_howMany < 2) return true;\r\n\r\n        if (_insideCallSender == msg.sender) {\r\n            require(_howMany <= _insideCallCount, \"howMany > _insideCallCount\");\r\n            return true;\r\n        }\r\n\r\n        bytes32 operation = keccak256(abi.encodePacked(msg.data, _generation));\r\n\r\n        uint256 operationVotesCount = votesCountByOperation[operation] + 1;\r\n        votesCountByOperation[operation] = operationVotesCount;\r\n\r\n        if (firstByOperation[operation] == address(0)) {\r\n            firstByOperation[operation] = msg.sender;\r\n\r\n            allOperationsIndicies[operation] = allOperations.length;\r\n            allOperations.push(operation);\r\n\r\n            emit OperationCreated(operation, msg.sender);\r\n        } else {\r\n            require(\r\n                votesOwnerByOperation[operation][msg.sender] == 0,\r\n                \"[operation][msg.sender] != 0\"\r\n            );\r\n        }\r\n\r\n        votesIndicesByOperation[operation].push(msg.sender);\r\n        votesOwnerByOperation[operation][msg.sender] = 1;\r\n\r\n        emit OperationUpvoted(operation, msg.sender);\r\n\r\n        if (operationVotesCount < _howMany) return false;\r\n\r\n        _deleteOperation(operation);\r\n\r\n        emit OperationPerformed(operation, msg.sender);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Used to delete cancelled or performed operation\r\n     * @param operation defines which operation to delete\r\n     */\r\n    function _deleteOperation(bytes32 operation) internal {\r\n        uint256 index = allOperationsIndicies[operation];\r\n        if (index < allOperations.length - 1) {\r\n            // Not last\r\n            allOperations[index] = allOperations[allOperations.length - 1];\r\n            allOperationsIndicies[allOperations[index]] = index;\r\n        }\r\n\r\n        delete allOperations[allOperations.length - 1];\r\n        delete allOperationsIndicies[operation];\r\n        delete votesCountByOperation[operation];\r\n        delete firstByOperation[operation];\r\n\r\n        uint8 x;\r\n        uint256 ln = votesIndicesByOperation[operation].length;\r\n\r\n        for (x = 0; x < ln; x++) {\r\n            delete votesOwnerByOperation[operation][\r\n                votesIndicesByOperation[operation][x]\r\n            ];\r\n        }\r\n\r\n        for (x = 0; x < ln; x++) {\r\n            votesIndicesByOperation[operation].pop();\r\n        }\r\n    }\r\n}\r\n\r\n/// @title DeCash Token implementation based on the DeCash perpetual storage\r\n/// @author Fabrizio Amodio (ZioFabry)\r\n\r\ncontract DeCashToken is DeCashBase, DeCashMultisignature, ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    modifier onlyLastest {\r\n        require(\r\n            address(this) ==\r\n                _getAddress(\r\n                    keccak256(abi.encodePacked(\"contract.address\", \"token\"))\r\n                ) ||\r\n                address(this) ==\r\n                _getAddress(\r\n                    keccak256(abi.encodePacked(\"contract.address\", \"proxy\"))\r\n                ),\r\n            \"Invalid or outdated contract\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused {\r\n        require(!isPaused(), \"Contract is paused\");\r\n        _;\r\n    }\r\n    modifier whenPaused {\r\n        require(isPaused(), \"Contract is not paused\");\r\n        _;\r\n    }\r\n\r\n    event Paused(address indexed from);\r\n    event Unpaused(address indexed from);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    // Construct\r\n    constructor(address _decashStorageAddress)\r\n        DeCashBase(_decashStorageAddress)\r\n    {\r\n        version = 1;\r\n    }\r\n\r\n    function initialize(\r\n        string memory _tokenName,\r\n        string memory _tokenSymbol,\r\n        uint8 _tokenDecimals\r\n    ) public onlyOwner {\r\n        uint256 currentVersion =\r\n            _getUint(keccak256(abi.encodePacked(\"token.version\", _tokenName)));\r\n\r\n        if (currentVersion == 0) {\r\n            _name = _tokenName;\r\n            _symbol = _tokenSymbol;\r\n            _decimals = _tokenDecimals;\r\n\r\n            _setString(keccak256(abi.encodePacked(\"token.name\", _name)), _name);\r\n            _setString(\r\n                keccak256(abi.encodePacked(\"token.symbol\", _name)),\r\n                _symbol\r\n            );\r\n            _setUint(\r\n                keccak256(abi.encodePacked(\"token.decimals\", _name)),\r\n                _decimals\r\n            );\r\n            _setBool(\r\n                keccak256(abi.encodePacked(\"contract.paused\", _name)),\r\n                false\r\n            );\r\n            _setUint(keccak256(abi.encodePacked(\"mint.reqSign\", _name)), 1);\r\n        }\r\n\r\n        if (currentVersion != version) {\r\n            _setUint(\r\n                keccak256(abi.encodePacked(\"token.version\", _name)),\r\n                version\r\n            );\r\n        }\r\n    }\r\n\r\n    function isPaused() public view returns (bool) {\r\n        return _getBool(keccak256(abi.encodePacked(\"contract.paused\", _name)));\r\n    }\r\n\r\n    /**\r\n     * @dev Allows owners to change number of required signature for multiSignature Operations\r\n     * @param _reqsign defines how many signature is required\r\n     */\r\n    function changeRequiredSigners(uint256 _reqsign)\r\n        external\r\n        onlySuperUser\r\n        onlyLastest\r\n        returns (uint256)\r\n    {\r\n        _setReqSign(_reqsign);\r\n\r\n        uint256 _generation = _getSignGeneration() + 1;\r\n        _setSignGeneration(_generation);\r\n\r\n        emit RequiredSignerChanged(_reqsign, _generation);\r\n\r\n        return _generation;\r\n    }\r\n\r\n    // ERC20 Implementation\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() external view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return _getTotalSupply();\r\n    }\r\n\r\n    function pause() external onlySuperUser onlyLastest whenNotPaused {\r\n        _setBool(keccak256(abi.encodePacked(\"contract.paused\", _name)), true);\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    function unpause() external onlySuperUser onlyLastest whenPaused {\r\n        _setBool(keccak256(abi.encodePacked(\"contract.paused\", _name)), false);\r\n        emit Unpaused(msg.sender);\r\n    }\r\n\r\n    function balanceOf(address _owner)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _getBalance(_owner);\r\n    }\r\n\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _getAllowed(_owner, _spender);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value)\r\n        external\r\n        override\r\n        onlyLastest\r\n        whenNotPaused\r\n        returns (bool)\r\n    {\r\n        return _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function transferMany(address[] calldata _tos, uint256[] calldata _values)\r\n        external\r\n        override\r\n        onlyLastest\r\n        whenNotPaused\r\n        returns (bool)\r\n    {\r\n        return _transferMany(msg.sender, _tos, _values);\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external override onlyLastest whenNotPaused returns (bool) {\r\n        return _transferFrom(msg.sender, _from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value)\r\n        external\r\n        override\r\n        onlyLastest\r\n        whenNotPaused\r\n        returns (bool)\r\n    {\r\n        return _approve(msg.sender, _spender, _value);\r\n    }\r\n\r\n    function burn(uint256 _value)\r\n        external\r\n        override\r\n        onlyLastest\r\n        whenNotPaused\r\n        returns (bool)\r\n    {\r\n        return _burn(msg.sender, _value);\r\n    }\r\n\r\n    function burnFrom(address _from, uint256 _value)\r\n        external\r\n        override\r\n        onlyLastest\r\n        whenNotPaused\r\n        returns (bool)\r\n    {\r\n        _approve(_from, msg.sender, _getAllowed(_from, msg.sender).sub(_value));\r\n\r\n        return _burn(_from, _value);\r\n    }\r\n\r\n    function mint(address _to, uint256 _value)\r\n        external\r\n        override\r\n        onlySuperUser\r\n        onlyLastest\r\n        whenNotPaused\r\n        onlyMultiSignature(_getReqSign(), _getSignGeneration())\r\n        returns (bool success)\r\n    {\r\n        _addBalance(_to, _value);\r\n        _addTotalSupply(_value);\r\n\r\n        emit Transfer(address(0), _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\r\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account owner.\r\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\r\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\r\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\r\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\r\n     *\r\n     * @param _from          - the account giving its signature to transfer `value` tokens to `to` address\r\n     * @param _to            - the account receiving `value` tokens\r\n     * @param _value         - the value in tokens to transfer\r\n     * @param _fee           - a fee to pay to `feeRecipient`\r\n     * @param _feeRecipient  - account which will receive fee\r\n     * @param _deadline      - until when the signature is valid\r\n     * @param _sigId         - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\r\n     * @param _sig           - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\r\n     * @param _sigStd        - chosen standard for signature validation. The signer must explicitly tell which standard they use\r\n     */\r\n    function transferViaSignature(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        address _feeRecipient,\r\n        uint256 _deadline,\r\n        uint256 _sigId,\r\n        bytes calldata _sig,\r\n        Signature.Std _sigStd\r\n    ) external onlyLastest {\r\n        _validateViaSignatureParams(\r\n            msg.sender,\r\n            _from,\r\n            _feeRecipient,\r\n            _deadline,\r\n            _sigId\r\n        );\r\n\r\n        Signature.requireSignature(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    address(this),\r\n                    _from,\r\n                    _to,\r\n                    _value,\r\n                    _fee,\r\n                    _feeRecipient,\r\n                    _deadline,\r\n                    _sigId\r\n                )\r\n            ),\r\n            _from,\r\n            _sig,\r\n            _sigStd,\r\n            Signature.Dest.transfer\r\n        );\r\n\r\n        _subBalance(_from, _value.add(_fee)); // Subtract (value + fee)\r\n        _addBalance(_to, _value);\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        if (_fee > 0) {\r\n            _addBalance(_feeRecipient, _fee);\r\n            emit Transfer(_from, _feeRecipient, _fee);\r\n        }\r\n\r\n        _burnSigId(_from, _sigId);\r\n    }\r\n\r\n    /**\r\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\r\n     * from the `from` account to multiple recipient address by providing a valid signature, which can only be obtained from the `from` account owner.\r\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\r\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\r\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\r\n     * Also note that the 1st recipient must be a valid fee receiver\r\n     * Use case: the user wants to send some tokens to multiple users or smart contracts, but don't have ether to do so.\r\n     *\r\n     * @param _from          - the account giving its signature to transfer `value` tokens to `to` address\r\n     * @param _tos[]         - array of account recipients\r\n     * @param _values[]      - array of amount\r\n     * @param _fee           - a fee to pay to `feeRecipient`\r\n     * @param _feeRecipient  - account which will receive fee\r\n     * @param _deadline      - until when the signature is valid\r\n     * @param _sigId         - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\r\n     * @param _sig           - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\r\n     * @param _sigStd        - chosen standard for signature validation. The signer must explicitly tell which standard they use\r\n     */\r\n    function transferManyViaSignature(\r\n        address _from,\r\n        address[] calldata _tos,\r\n        uint256[] calldata _values,\r\n        uint256 _fee,\r\n        address _feeRecipient,\r\n        uint256 _deadline,\r\n        uint256 _sigId,\r\n        bytes calldata _sig,\r\n        Signature.Std _sigStd\r\n    ) external onlyLastest {\r\n        uint256 tosLen = _tos.length;\r\n\r\n        require(tosLen == _values.length, \"Wrong array parameters\");\r\n        require(tosLen <= 100, \"Too many receiver\");\r\n\r\n        _validateViaSignatureParams(\r\n            msg.sender,\r\n            _from,\r\n            _feeRecipient,\r\n            _deadline,\r\n            _sigId\r\n        );\r\n\r\n        bytes32 multisig = Signature.calculateManySig(_tos, _values);\r\n\r\n        Signature.requireSignature(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    address(this),\r\n                    _from,\r\n                    multisig,\r\n                    _fee,\r\n                    _feeRecipient,\r\n                    _deadline,\r\n                    _sigId\r\n                )\r\n            ),\r\n            _from,\r\n            _sig,\r\n            _sigStd,\r\n            Signature.Dest.transferMany\r\n        );\r\n\r\n        _subBalance(_from, _calculateTotal(_values).add(_fee));\r\n\r\n        for (uint8 x = 0; x < tosLen; x++) {\r\n            _addBalance(_tos[x], _values[x]);\r\n            emit Transfer(_from, _tos[x], _values[x]);\r\n        }\r\n\r\n        if (_fee > 0) {\r\n            _addBalance(_feeRecipient, _fee);\r\n            emit Transfer(_from, _feeRecipient, _fee);\r\n        }\r\n\r\n        _burnSigId(_from, _sigId);\r\n    }\r\n\r\n    /**\r\n     * Same as `transferViaSignature`, but for `approve`.\r\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\r\n     * balance.\r\n     *\r\n     * @param _from          - the account to approve withdrawal from, which signed all below parameters\r\n     * @param _spender       - the account allowed to withdraw tokens from `from` address\r\n     * @param _value         - the value in tokens to approve to withdraw\r\n     * @param _fee           - a fee to pay to `feeRecipient`\r\n     * @param _feeRecipient  - account which will receive fee\r\n     * @param _deadline      - until when the signature is valid\r\n     * @param _sigId         - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\r\n     * @param _sig           - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\r\n     * @param _sigStd        - chosen standard for signature validation. The signer must explicitely tell which standard they use\r\n     */\r\n    function approveViaSignature(\r\n        address _from,\r\n        address _spender,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        address _feeRecipient,\r\n        uint256 _deadline,\r\n        uint256 _sigId,\r\n        bytes calldata _sig,\r\n        Signature.Std _sigStd\r\n    ) external onlyLastest {\r\n        _validateViaSignatureParams(\r\n            msg.sender,\r\n            _from,\r\n            _feeRecipient,\r\n            _deadline,\r\n            _sigId\r\n        );\r\n\r\n        Signature.requireSignature(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    address(this),\r\n                    _from,\r\n                    _spender,\r\n                    _value,\r\n                    _fee,\r\n                    _feeRecipient,\r\n                    _deadline,\r\n                    _sigId\r\n                )\r\n            ),\r\n            _from,\r\n            _sig,\r\n            _sigStd,\r\n            Signature.Dest.approve\r\n        );\r\n\r\n        if (_fee > 0) {\r\n            _subBalance(_from, _fee);\r\n            _addBalance(_feeRecipient, _fee);\r\n            emit Transfer(_from, _feeRecipient, _fee);\r\n        }\r\n\r\n        _setAllowed(_from, _spender, _value);\r\n        emit Approval(_from, _spender, _value);\r\n\r\n        _burnSigId(_from, _sigId);\r\n    }\r\n\r\n    /**\r\n     * Same as `transferViaSignature`, but for `transferFrom`.\r\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to\r\n     * do so. Important note: the fee is subtracted from the `value`, and `to` address receives `value - fee`.\r\n     *\r\n     * @param _signer       - the address allowed to call transferFrom, which signed all below parameters\r\n     * @param _from         - the account to make withdrawal from\r\n     * @param _to           - the address of the recipient\r\n     * @param _value        - the value in tokens to withdraw\r\n     * @param _fee          - a fee to pay to `feeRecipient`\r\n     * @param _feeRecipient - account which will receive fee\r\n     * @param _deadline     - until when the signature is valid\r\n     * @param _sigId        - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\r\n     * @param _sig          - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\r\n     * @param _sigStd       - chosen standard for signature validation. The signer must explicitly tell which standard they use\r\n     */\r\n    function transferFromViaSignature(\r\n        address _signer,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        address _feeRecipient,\r\n        uint256 _deadline,\r\n        uint256 _sigId,\r\n        bytes calldata _sig,\r\n        Signature.Std _sigStd\r\n    ) external onlyLastest {\r\n        _validateViaSignatureParams(\r\n            msg.sender,\r\n            _from,\r\n            _feeRecipient,\r\n            _deadline,\r\n            _sigId\r\n        );\r\n\r\n        Signature.requireSignature(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    address(this),\r\n                    _from,\r\n                    _to,\r\n                    _value,\r\n                    _fee,\r\n                    _feeRecipient,\r\n                    _deadline,\r\n                    _sigId\r\n                )\r\n            ),\r\n            _signer,\r\n            _sig,\r\n            _sigStd,\r\n            Signature.Dest.transferFrom\r\n        );\r\n\r\n        _subAllowed(_from, _signer, _value.add(_fee));\r\n\r\n        _subBalance(_from, _value.add(_fee)); // Subtract (value + fee)\r\n        _addBalance(_to, _value);\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        if (_fee > 0) {\r\n            _addBalance(_feeRecipient, _fee);\r\n            emit Transfer(_from, _feeRecipient, _fee);\r\n        }\r\n\r\n        _burnSigId(_from, _sigId);\r\n    }\r\n\r\n    // Total Supply Handling\r\n    function _getTotalSupply() internal view returns (uint256) {\r\n        return\r\n            _getUint(keccak256(abi.encodePacked(\"token.totalSupply\", _name)));\r\n    }\r\n\r\n    function _setTotalSupply(uint256 _supply) internal {\r\n        _setUint(\r\n            keccak256(abi.encodePacked(\"token.totalSupply\", _name)),\r\n            _supply\r\n        );\r\n    }\r\n\r\n    function _addTotalSupply(uint256 _supply) internal {\r\n        _setTotalSupply(_getTotalSupply().add(_supply));\r\n    }\r\n\r\n    function _subTotalSupply(uint256 _supply) internal {\r\n        _setTotalSupply(_getTotalSupply().sub(_supply));\r\n    }\r\n\r\n    // Allowed Handling\r\n    function _getAllowed(address _owner, address _spender)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            _getUint(\r\n                keccak256(\r\n                    abi.encodePacked(\"token.allowed\", _name, _owner, _spender)\r\n                )\r\n            );\r\n    }\r\n\r\n    function _setAllowed(\r\n        address _owner,\r\n        address _spender,\r\n        uint256 _remaining\r\n    ) internal {\r\n        _setUint(\r\n            keccak256(\r\n                abi.encodePacked(\"token.allowed\", _name, _owner, _spender)\r\n            ),\r\n            _remaining\r\n        );\r\n    }\r\n\r\n    function _addAllowed(\r\n        address _owner,\r\n        address _spender,\r\n        uint256 _balance\r\n    ) internal {\r\n        _setAllowed(\r\n            _owner,\r\n            _spender,\r\n            _getAllowed(_owner, _spender).add(_balance)\r\n        );\r\n    }\r\n\r\n    function _subAllowed(\r\n        address _owner,\r\n        address _spender,\r\n        uint256 _balance\r\n    ) internal {\r\n        _setAllowed(\r\n            _owner,\r\n            _spender,\r\n            _getAllowed(_owner, _spender).sub(_balance)\r\n        );\r\n    }\r\n\r\n    // Balance Handling\r\n    function _getBalance(address _owner) internal view returns (uint256) {\r\n        return\r\n            _getUint(\r\n                keccak256(abi.encodePacked(\"token.balance\", _name, _owner))\r\n            );\r\n    }\r\n\r\n    function _setBalance(address _owner, uint256 _balance) internal {\r\n        require(!_isBlacklisted(_owner), \"Blacklisted\");\r\n        _setUint(\r\n            keccak256(abi.encodePacked(\"token.balance\", _name, _owner)),\r\n            _balance\r\n        );\r\n    }\r\n\r\n    function _addBalance(address _owner, uint256 _balance) internal {\r\n        _setBalance(_owner, _getBalance(_owner).add(_balance));\r\n    }\r\n\r\n    function _subBalance(address _owner, uint256 _balance) internal {\r\n        _setBalance(_owner, _getBalance(_owner).sub(_balance));\r\n    }\r\n\r\n    // Other Variable Handling\r\n    function _getReqSign() internal view returns (uint256) {\r\n        return _getUint(keccak256(abi.encodePacked(\"mint.reqSign\", _name)));\r\n    }\r\n\r\n    function _getSignGeneration() internal view returns (uint256) {\r\n        return _getUint(keccak256(abi.encodePacked(\"sign.generation\", _name)));\r\n    }\r\n\r\n    function _getUsedSigIds(address _signer, uint256 _sigId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            _getBool(\r\n                keccak256(\r\n                    abi.encodePacked(\"sign.generation\", _name, _signer, _sigId)\r\n                )\r\n            );\r\n    }\r\n\r\n    function _setReqSign(uint256 _reqsign) internal {\r\n        _setUint(keccak256(abi.encodePacked(\"mint.reqSign\", _name)), _reqsign);\r\n    }\r\n\r\n    function _setSignGeneration(uint256 _generation) internal {\r\n        _setUint(\r\n            keccak256(abi.encodePacked(\"sign.generation\", _name)),\r\n            _generation\r\n        );\r\n    }\r\n\r\n    function _setUsedSigIds(\r\n        address _signer,\r\n        uint256 _sigId,\r\n        bool _used\r\n    ) internal {\r\n        _setBool(\r\n            keccak256(\r\n                abi.encodePacked(\"sign.generation\", _name, _signer, _sigId)\r\n            ),\r\n            _used\r\n        );\r\n    }\r\n\r\n    function _burn(address _from, uint256 _value) internal returns (bool) {\r\n        _subBalance(_from, _value);\r\n        _subTotalSupply(_value);\r\n\r\n        emit Transfer(_from, address(0), _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        address _sender,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal returns (bool) {\r\n        _subBalance(_sender, _value);\r\n        _addBalance(_to, _value);\r\n\r\n        emit Transfer(_sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transferMany(\r\n        address _sender,\r\n        address[] calldata _tos,\r\n        uint256[] calldata _values\r\n    ) internal returns (bool) {\r\n        uint256 tosLen = _tos.length;\r\n\r\n        require(tosLen == _values.length, \"Wrong array parameter\");\r\n        require(tosLen <= 100, \"Too many receiver\");\r\n\r\n        _subBalance(_sender, _calculateTotal(_values));\r\n\r\n        for (uint8 x = 0; x < tosLen; x++) {\r\n            _addBalance(_tos[x], _values[x]);\r\n\r\n            emit Transfer(_sender, _tos[x], _values[x]);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transferFrom(\r\n        address _sender,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal returns (bool) {\r\n        _subAllowed(_from, _sender, _value);\r\n        _subBalance(_from, _value);\r\n        _addBalance(_to, _value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _approve(\r\n        address _sender,\r\n        address _spender,\r\n        uint256 _value\r\n    ) internal returns (bool) {\r\n        _setAllowed(_sender, _spender, _value);\r\n\r\n        emit Approval(_sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _calculateTotal(uint256[] memory _values)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 total = 0;\r\n        uint256 ln = _values.length;\r\n\r\n        for (uint8 x = 0; x < ln; x++) {\r\n            total = total.add(_values[x]);\r\n        }\r\n\r\n        return total;\r\n    }\r\n\r\n    // Delegated functions\r\n\r\n    /**\r\n     * These functions are used to avoid the use of the modifiers that can cause the \"stack too deep\" error\r\n     * also for code optimization\r\n     */\r\n    function _validateViaSignatureParams(\r\n        address _delegator,\r\n        address _from,\r\n        address _feeRecipient,\r\n        uint256 _deadline,\r\n        uint256 _sigId\r\n    ) internal view {\r\n        require(!isPaused(), \"Contract paused\");\r\n        require(_isDelegator(_delegator), \"Sender is not a delegator\");\r\n        require(_isFeeRecipient(_feeRecipient), \"Invalid fee recipient\");\r\n        require(block.timestamp <= _deadline, \"Request expired\");\r\n        require(!_getUsedSigIds(_from, _sigId), \"Request already used\");\r\n    }\r\n\r\n    function _burnSigId(address _from, uint256 _sigId) internal {\r\n        _setUsedSigIds(_from, _sigId, true);\r\n    }\r\n}\r\n\r\ncontract EURDToken is DeCashToken {\r\n    constructor(address _storage) DeCashToken(_storage) {}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_decashStorageAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"performer\",\"type\":\"address\"}],\"name\":\"OperationCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"}],\"name\":\"OperationCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"performer\",\"type\":\"address\"}],\"name\":\"OperationPerformed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"OperationUpvoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRequiredSignature\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"generation\",\"type\":\"uint256\"}],\"name\":\"RequiredSignerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allOperations\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"allOperationsIndicies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sigId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"},{\"internalType\":\"enum Signature.Std\",\"name\":\"_sigStd\",\"type\":\"uint8\"}],\"name\":\"approveViaSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"cancelOperation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reqsign\",\"type\":\"uint256\"}],\"name\":\"changeRequiredSigners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"firstByOperation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_tokenDecimals\",\"type\":\"uint8\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isDelegator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isFeeRecipient\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isSuperUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signerGeneration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sigId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"},{\"internalType\":\"enum Signature.Std\",\"name\":\"_sigStd\",\"type\":\"uint8\"}],\"name\":\"transferFromViaSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"transferMany\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sigId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"},{\"internalType\":\"enum Signature.Std\",\"name\":\"_sigStd\",\"type\":\"uint8\"}],\"name\":\"transferManyViaSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sigId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"},{\"internalType\":\"enum Signature.Std\",\"name\":\"_sigStd\",\"type\":\"uint8\"}],\"name\":\"transferViaSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"votesCountByOperation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"votesIndicesByOperation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"votesOwnerByOperation\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DeCashToken","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000070c70f1195a5d7544fa36eb70b58a89ab270daf0","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c63e2e11c2b27caf3fd9bd16085e1e7565f29679455f1ee5593a1d2ef113bba5"}]}