{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     *\r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either {approve} or {setApprovalForAll}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either {approve} or {setApprovalForAll}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\ncontract NFTBankedSale {\r\n\r\n    struct SwapDeal {\r\n        // Buyer's info: ERC-20\r\n        address token;\r\n        address buyer;\r\n        uint price;\r\n\r\n        // Bank's info: same ERC-20\r\n        address bank;\r\n        uint transferred;\r\n\r\n        // Seller's info: ERC-721\r\n        address collection;\r\n        address seller;\r\n        uint tokenId;\r\n    }\r\n\r\n    SwapDeal public swapDeal;\r\n\r\n    /**\r\n     * @dev Creates the contract instance and saves the parameters of the swap.\r\n     * @param token address The address of the ERC20 token used to buy.\r\n     * @param buyer address The address of the buyer using ERC20 tokens.\r\n     * @param price uint The quantity of ERC20 tokens given by the buyer when buying.\r\n     * @param bank address The address of the bank that provides additional ERC20 tokens when buying.\r\n     * @param transferred uint The quantity of ERC20 tokens given by the bank when buying.\r\n     * @param collection address The address of the ERC721 token collection exchanged.\r\n     * @param seller address The address of the seller of the ERC721 token.\r\n     * @param tokenId uint The id of the ERC721 token sold.\r\n     */\r\n    constructor(address token, address buyer, uint price, address bank, uint transferred, address collection, address seller, uint tokenId) public {\r\n        require(token != address(0), \"NFTBankedSale: ERC20 token is missing\");\r\n        require(buyer != address(0), \"NFTBankedSale: buyer is missing\");\r\n        require(price != 0, \"NFTBankedSale: price is missing\");\r\n        require(bank != address(0), \"NFTBankedSale: bank is missing\");\r\n        require(transferred != 0, \"NFTBankedSale: transferred is missing\");\r\n        require(collection != address(0), \"NFTBankedSale: ERC721 collection is missing\");\r\n        require(seller != address(0), \"NFTBankedSale: seller is missing\");\r\n        require(tokenId != 0, \"NFTBankedSale: tokenId is missing\");\r\n        swapDeal = SwapDeal({\r\n            token: token,\r\n            buyer: buyer,\r\n            price: price,\r\n            bank: bank,\r\n            transferred: transferred,\r\n            collection: collection,\r\n            seller: seller,\r\n            tokenId: tokenId\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @dev Does the 3 transfers constituting the swap.\r\n     * All seller, bank and buyer must have approved this swap contract as a spender of their respective tokens\r\n     * for the swap to proceed.\r\n     * The function can be called by anyone.\r\n     */\r\n    function swap() public {\r\n        SwapDeal memory deal = swapDeal;\r\n        delete swapDeal;\r\n        IERC721(deal.collection).safeTransferFrom(deal.seller, deal.buyer, deal.tokenId);\r\n        require(IERC20(deal.token).transferFrom(deal.buyer, deal.seller, deal.price), \"NFTBankedSale: ERC20 transfer failed\");\r\n        require(IERC20(deal.token).transferFrom(deal.bank, deal.seller, deal.transferred), \"NFTBankedSale: ERC20 bank transfer failed\");\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"bank\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"transferred\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[],\"name\":\"swap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapDeal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"bank\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"transferred\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"NFTBankedSale","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000a7bc4707414ce0fa5fb18062a04ea75c359bcfa8000000000000000000000000000000000000000000000000000000036f2b23800000000000000000000000009396632f0910793987933432112d03927816e4a800000000000000000000000000000000000000000000000000000153fdaeba8000000000000000000000000016faef437179beedcde3fedbba4d85b89a19495a0000000000000000000000000ee312247c6d013d36b96a8eaf3d2aa40244603f0000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://97cd6077d33c5da6bfc89a0d68b5957b1e874d087061b1894b37598e7d5eaa92"}]}