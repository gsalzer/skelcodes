{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.7;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n\r\nabstract contract AuctionHouseLike {\r\n    function bids(uint256) virtual external view returns (uint, uint);\r\n    function buyCollateral(uint256 id, uint256 wad) external virtual;\r\n    function liquidationEngine() view public virtual returns (LiquidationEngineLike);\r\n    function collateralType() view public virtual returns (bytes32);\r\n}\r\n\r\nabstract contract SAFEEngineLike {\r\n    mapping (bytes32 => mapping (address => uint256))  public tokenCollateral;  // [wad]\r\n    function canModifySAFE(address, address) virtual public view returns (uint);\r\n    function collateralTypes(bytes32) virtual public view returns (uint, uint, uint, uint, uint);\r\n    function coinBalance(address) virtual public view returns (uint);\r\n    function safes(bytes32, address) virtual public view returns (uint, uint);\r\n    function modifySAFECollateralization(bytes32, address, address, address, int, int) virtual public;\r\n    function approveSAFEModification(address) virtual public;\r\n    function transferInternalCoins(address, address, uint) virtual public;\r\n}\r\n\r\nabstract contract CollateralJoinLike {\r\n    function decimals() virtual public returns (uint);\r\n    function collateral() virtual public returns (CollateralLike);\r\n    function join(address, uint) virtual public payable;\r\n    function exit(address, uint) virtual public;\r\n}\r\n\r\nabstract contract CoinJoinLike {\r\n    function safeEngine() virtual public returns (SAFEEngineLike);\r\n    function systemCoin() virtual public returns (CollateralLike);\r\n    function join(address, uint) virtual public payable;\r\n    function exit(address, uint) virtual public;\r\n}\r\n\r\nabstract contract CollateralLike {\r\n    function approve(address, uint) virtual public;\r\n    function transfer(address, uint) virtual public;\r\n    function transferFrom(address, address, uint) virtual public;\r\n    function deposit() virtual public payable;\r\n    function withdraw(uint) virtual public;\r\n    function balanceOf(address) virtual public view returns (uint);\r\n}\r\n\r\nabstract contract LiquidationEngineLike {\r\n    function chosenSAFESaviour(bytes32, address) virtual public view returns (address);\r\n    function safeSaviours(address) virtual public view returns (uint256);\r\n    function liquidateSAFE(bytes32 collateralType, address safe) virtual external returns (uint256 auctionId);\r\n    function safeEngine() view public virtual returns (SAFEEngineLike);\r\n}\r\n\r\n/// @title GEB Keeper Flash Proxy\r\n/// @notice Trustless proxy that facilitates SAFE liquidation and bidding in auctions using Uniswap V2 flashswaps\r\n/// @notice Single collateral version, only meant to work with ETH collateral types\r\ncontract GebUniswapV2KeeperFlashProxyETH {\r\n    AuctionHouseLike       public auctionHouse;\r\n    SAFEEngineLike         public safeEngine;\r\n    CollateralLike         public weth;\r\n    CollateralLike         public coin;\r\n    CoinJoinLike           public coinJoin;\r\n    CoinJoinLike           public ethJoin;\r\n    IUniswapV2Pair         public uniswapPair;\r\n    LiquidationEngineLike  public liquidationEngine;\r\n    address payable        public caller;\r\n    bytes32                public collateralType;\r\n\r\n    uint256 public constant ZERO           = 0;\r\n    uint256 public constant ONE            = 1;\r\n    uint256 public constant THOUSAND       = 1000;\r\n    uint256 public constant NET_OUT_AMOUNT = 997;\r\n\r\n    /// @notice Constructor\r\n    /// @param auctionHouseAddress Address of the auction house\r\n    /// @param wethAddress WETH address\r\n    /// @param systemCoinAddress System coin address\r\n    /// @param uniswapPairAddress Uniswap V2 pair address\r\n    /// @param coinJoinAddress CoinJoin address\r\n    /// @param ethJoinAddress ETHJoin address\r\n    constructor(\r\n        address auctionHouseAddress,\r\n        address wethAddress,\r\n        address systemCoinAddress,\r\n        address uniswapPairAddress,\r\n        address coinJoinAddress,\r\n        address ethJoinAddress\r\n    ) public {\r\n        require(auctionHouseAddress != address(0), \"GebUniswapV2KeeperFlashProxyETH/null-auction-house\");\r\n        require(wethAddress != address(0), \"GebUniswapV2KeeperFlashProxyETH/null-weth\");\r\n        require(systemCoinAddress != address(0), \"GebUniswapV2KeeperFlashProxyETH/null-system-coin\");\r\n        require(uniswapPairAddress != address(0), \"GebUniswapV2KeeperFlashProxyETH/null-uniswap-pair\");\r\n        require(coinJoinAddress != address(0), \"GebUniswapV2KeeperFlashProxyETH/null-coin-join\");\r\n        require(ethJoinAddress != address(0), \"GebUniswapV2KeeperFlashProxyETH/null-eth-join\");\r\n\r\n        auctionHouse        = AuctionHouseLike(auctionHouseAddress);\r\n        weth                = CollateralLike(wethAddress);\r\n        coin                = CollateralLike(systemCoinAddress);\r\n        uniswapPair         = IUniswapV2Pair(uniswapPairAddress);\r\n        coinJoin            = CoinJoinLike(coinJoinAddress);\r\n        ethJoin             = CoinJoinLike(ethJoinAddress);\r\n        collateralType      = auctionHouse.collateralType();\r\n        liquidationEngine   = auctionHouse.liquidationEngine();\r\n        safeEngine          = liquidationEngine.safeEngine();\r\n\r\n        safeEngine.approveSAFEModification(address(auctionHouse));\r\n    }\r\n\r\n    // --- Math ---\r\n    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"GebUniswapV2KeeperFlashProxyETH/add-overflow\");\r\n    }\r\n    function subtract(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"GebUniswapV2KeeperFlashProxyETH/sub-underflow\");\r\n    }\r\n    function multiply(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == ZERO || (z = x * y) / y == x, \"GebUniswapV2KeeperFlashProxyETH/mul-overflow\");\r\n    }\r\n    function wad(uint rad) internal pure returns (uint) {\r\n        return rad / 10 ** 27;\r\n    }\r\n\r\n    // --- External Utils ---\r\n    /// @notice Bids in a single auction\r\n    /// @param auctionId Auction Id\r\n    /// @param amount Amount to bid\r\n    function bid(uint auctionId, uint amount) external {\r\n        require(msg.sender == address(this), \"GebUniswapV2KeeperFlashProxyETH/only-self\");\r\n        auctionHouse.buyCollateral(auctionId, amount);\r\n    }\r\n    /// @notice Bids in multiple auctions atomically\r\n    /// @param auctionIds Auction IDs\r\n    /// @param amounts Amounts to bid\r\n    function multipleBid(uint[] calldata auctionIds, uint[] calldata amounts) external {\r\n        require(msg.sender == address(this), \"GebUniswapV2KeeperFlashProxyETH/only-self\");\r\n        for (uint i = ZERO; i < auctionIds.length; i++) {\r\n            auctionHouse.buyCollateral(auctionIds[i], amounts[i]);\r\n        }\r\n    }\r\n    /// @notice Callback for/from Uniswap V2\r\n    /// @param _sender Requestor of the flashswap (must be this address)\r\n    /// @param _amount0 Amount of token0\r\n    /// @param _amount1 Amount of token1\r\n    /// @param _data Data sent back from Uniswap\r\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external {\r\n        require(_sender == address(this), \"GebUniswapV2KeeperFlashProxyETH/invalid-sender\");\r\n        require(msg.sender == address(uniswapPair), \"GebUniswapV2KeeperFlashProxyETH/invalid-uniswap-pair\");\r\n\r\n        // join system coins\r\n        uint amount = (_amount0 == ZERO ? _amount1 : _amount0);\r\n        coin.approve(address(coinJoin), amount);\r\n        coinJoin.join(address(this), amount);\r\n\r\n        // bid\r\n        (bool success, ) = address(this).call(_data);\r\n        require(success, \"GebUniswapV2KeeperFlashProxyETH/failed-bidding\");\r\n\r\n        // exit WETH\r\n        ethJoin.exit(address(this), safeEngine.tokenCollateral(collateralType, address(this)));\r\n\r\n        // repay loan\r\n        uint pairBalanceTokenBorrow = coin.balanceOf(address(uniswapPair));\r\n        uint pairBalanceTokenPay = weth.balanceOf(address(uniswapPair));\r\n        uint amountToRepay = addition((\r\n          multiply(multiply(THOUSAND, pairBalanceTokenPay), amount) /\r\n          multiply(NET_OUT_AMOUNT, pairBalanceTokenBorrow)\r\n        ), ONE);\r\n\r\n        require(amountToRepay <= weth.balanceOf(address(this)), \"GebUniswapV2KeeperFlashProxyETH/unprofitable\");\r\n        weth.transfer(address(uniswapPair), amountToRepay);\r\n\r\n        // send profit back\r\n        uint profit = weth.balanceOf(address(this));\r\n        weth.withdraw(profit);\r\n        caller.call{value: profit}(\"\");\r\n        caller = address(0x0);\r\n    }\r\n\r\n    // --- Internal Utils ---\r\n    /// @notice Initiates a flashwap\r\n    /// @param amount Amount to borrow\r\n    /// @param data Callback data\r\n    function _startSwap(uint amount, bytes memory data) internal {\r\n        caller = msg.sender;\r\n\r\n        uint amount0Out = address(coin) == uniswapPair.token0() ? amount : ZERO;\r\n        uint amount1Out = address(coin) == uniswapPair.token1() ? amount : ZERO;\r\n\r\n        uniswapPair.swap(amount0Out, amount1Out, address(this), data);\r\n    }\r\n    /// @notice Returns all available opportunities from a provided auction list\r\n    /// @param auctionIds Auction IDs\r\n    /// @return ids IDs of active auctions\r\n    /// @return bidAmounts Rad amounts still requested by auctions\r\n    /// @return totalAmount Wad amount to be borrowed\r\n    function getOpenAuctionsBidSizes(uint[] memory auctionIds) internal returns (uint[] memory, uint[] memory, uint) {\r\n        uint            amountToRaise;\r\n        uint            totalAmount;\r\n        uint            opportunityCount;\r\n\r\n        uint[] memory   ids = new uint[](auctionIds.length);\r\n        uint[] memory   bidAmounts = new uint[](auctionIds.length);\r\n\r\n        for (uint i = ZERO; i < auctionIds.length; i++) {\r\n            (, amountToRaise) = auctionHouse.bids(auctionIds[i]);\r\n\r\n            if (amountToRaise > ZERO) {\r\n                totalAmount                  = addition(totalAmount, addition(wad(amountToRaise), ONE));\r\n                ids[opportunityCount]        = auctionIds[i];\r\n                bidAmounts[opportunityCount] = amountToRaise;\r\n                opportunityCount++;\r\n            }\r\n        }\r\n\r\n        assembly {\r\n            mstore(ids, opportunityCount)\r\n            mstore(bidAmounts, opportunityCount)\r\n        }\r\n\r\n        return(ids, bidAmounts, totalAmount);\r\n    }\r\n\r\n    // --- Core Bidding and Settling Logic ---\r\n    /// @notice Liquidates an underwater safe and settles the auction right away\r\n    /// @dev It will revert for protected SAFEs (those that have saviours). Protected SAFEs need to be liquidated through the LiquidationEngine\r\n    /// @param safe A SAFE's ID\r\n    /// @return auction The auction ID\r\n    function liquidateAndSettleSAFE(address safe) public returns (uint auction) {\r\n        if (liquidationEngine.safeSaviours(liquidationEngine.chosenSAFESaviour(collateralType, safe)) == ONE) {\r\n            require (liquidationEngine.chosenSAFESaviour(collateralType, safe) == address(0),\r\n            \"GebUniswapV2KeeperFlashProxyETH/safe-is-protected\");\r\n        }\r\n\r\n        auction = liquidationEngine.liquidateSAFE(collateralType, safe);\r\n        settleAuction(auction);\r\n    }\r\n    /// @notice Settle auction\r\n    /// @param auctionId ID of the auction to be settled\r\n    function settleAuction(uint auctionId) public {\r\n        (, uint amountToRaise) = auctionHouse.bids(auctionId);\r\n        require(amountToRaise > ZERO, \"GebUniswapV2KeeperFlashProxyETH/auction-already-settled\");\r\n\r\n        bytes memory callbackData = abi.encodeWithSelector(this.bid.selector, auctionId, amountToRaise);\r\n\r\n        _startSwap(addition(wad(amountToRaise), ONE), callbackData);\r\n    }\r\n    /// @notice Settle auctions\r\n    /// @param auctionIds IDs of the auctions to be settled\r\n    function settleAuction(uint[] memory auctionIds) public {\r\n        (uint[] memory ids, uint[] memory bidAmounts, uint totalAmount) = getOpenAuctionsBidSizes(auctionIds);\r\n        require(totalAmount > ZERO, \"GebUniswapV2KeeperFlashProxyETH/all-auctions-already-settled\");\r\n\r\n        bytes memory callbackData = abi.encodeWithSelector(this.multipleBid.selector, ids, bidAmounts);\r\n\r\n        _startSwap(totalAmount, callbackData);\r\n    }\r\n\r\n    // --- Fallback ---\r\n    receive() external payable {\r\n        require(msg.sender == address(weth), \"GebUniswapV2KeeperFlashProxyETH/only-weth-withdrawals-allowed\");\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"auctionHouseAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wethAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"systemCoinAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapPairAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coinJoinAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ethJoinAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NET_OUT_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"THOUSAND\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZERO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionHouse\",\"outputs\":[{\"internalType\":\"contract AuctionHouseLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"caller\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coin\",\"outputs\":[{\"internalType\":\"contract CollateralLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coinJoin\",\"outputs\":[{\"internalType\":\"contract CoinJoinLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralType\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethJoin\",\"outputs\":[{\"internalType\":\"contract CoinJoinLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"}],\"name\":\"liquidateAndSettleSAFE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"auction\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidationEngine\",\"outputs\":[{\"internalType\":\"contract LiquidationEngineLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"auctionIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"multipleBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeEngine\",\"outputs\":[{\"internalType\":\"contract SAFEEngineLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"settleAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"auctionIds\",\"type\":\"uint256[]\"}],\"name\":\"settleAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapPair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"uniswapV2Call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract CollateralLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"GebUniswapV2KeeperFlashProxyETH","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009fc9ae5c87fd07368e87d1ea0970a6fc1e6dd6cb000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000003ab458634910aad20ef5f1c8ee96f1d6ac549190000000000000000000000008ae720a71622e824f576b4a8c03031066548a3b10000000000000000000000000a5653cca4db1b6e265f47caf6969e64f1cfdc450000000000000000000000002d3cd7b81c93f188f3cb8ad87c8acc73d6226e3a","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://df834f07a585089b001d0f6f9cf291a259a33971d08988b1f25b975a798bcb04"}]}