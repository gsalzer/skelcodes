{"status":"1","message":"OK","result":[{"SourceCode":"{\"CrowdConfigurableSale.sol\":{\"content\":\"pragma solidity ^0.6.0;\\nimport \\u0027./Ownable.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\n// SPDX-License-Identifier: UNLICENSED\\n\\ncontract CrowdConfigurableSale is Ownable {\\n    using SafeMath for uint256;\\n\\n    // start and end date where investments are allowed (both inclusive)\\n    uint256 public startDate; \\n    uint256 public endDate;\\n\\n    // Minimum amount to participate\\n    uint256 public minimumParticipationAmount;\\n\\n    uint256 public minimumToRaise;\\n\\n    // address where funds are collected\\n    address payable public wallet;\\n\\n    // Pancakeswap pair address for BNB and Token\\n    address public chainLinkAddress;\\n    \\n    //cap for the sale\\n    uint256 public cap; \\n\\n    // amount of raised money in wei\\n    uint256 public weiRaised;\\n\\n    //flag for final of crowdsale\\n    bool public isFinalized = false;\\n    bool public isCanceled = false;\\n\\n    \\n    function getChainlinkAddress() public view returns (address) {\\n        return chainLinkAddress;\\n    }\\n    \\n    function isStarted() public view returns (bool) {\\n        return startDate \\u003c= block.timestamp;\\n    }\\n\\n    function changeStartDate(uint256 _startDate) public onlyAdmin {\\n        startDate = _startDate;\\n    }\\n\\n    function changeEndDate(uint256 _endDate) public onlyAdmin {\\n        endDate = _endDate;\\n    }\\n}\\n\"},\"CrowdSale.sol\":{\"content\":\"pragma solidity ^0.6.0;\\nimport \\u0027./CrowdSaleBase.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\n// SPDX-License-Identifier: UNLICENSED\\n\\ncontract CrowdSale is CrowdSaleBase {\\n    using SafeMath for uint256;\\n    \\n    constructor() public {\\n        wallet = 0xA4A5564Fbb72a0C0026082C5E6863AE21FB79E31;\\n        // This is the Fundrasing address \\n        \\n        token = IERC20(0x1E19D4e538B1583613347671965A2FA848271f8a);\\n        // This is the address of the smart contract of token on ethscan.\\n      \\n        \\n        startDate = 1623715331;\\n        // start date of ICO in EPOCH time stamp - Use https://www.epochconverter.com/ for getting the timestamps\\n        \\n        endDate = 1640953855;\\n        // end date of ICO in EPOCH time stamp - Use https://www.epochconverter.com/ for getting the timestamps\\n        \\n        minimumParticipationAmount = 20000000000000000 wei;\\n        // Example value here is 0.02 eth. This is the minimum amount of eth a contributor will have to put in.\\n        \\n        minimumToRaise = 1000000000000000 wei;\\n        // 0.001 eth.\\n        // This the minimum amount to be raised for the ICO to marked as valid or complete. You can also put this as 0 or 1 wei.\\n        \\n        chainLinkAddress = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\\n     \\n        // Chainlink Address to get live rate of Eth\\n        \\n        \\n        cap = 16467100000000000000000 wei;\\n        // The amount you have to raise after which the ICO will close\\n        //16467.10 Eth \\n    }\\n}\"},\"CrowdSaleBase.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nimport \\u0027./CrowdConfigurableSale.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./Maps.sol\\u0027;\\n// SPDX-License-Identifier: UNLICENSED\\n\\ninterface IERC20 {\\n\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function decimals() external pure returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\\ncontract CrowdSaleBase is CrowdConfigurableSale {\\n    using SafeMath for uint256;\\n    using Maps for Maps.Map;\\n    // The token being sold\\n    IERC20 public token;\\n    mapping(address =\\u003e uint256) public participations;\\n    Maps.Map public participants;\\n\\n    event Finalized();\\n\\n    /**\\n    * event for token purchase logging\\n    * @param purchaser who paid for the tokens\\n    * @param value weis paid for purchase\\n    * @param amount amount of tokens purchased\\n    */ \\n    event BuyTokens(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\\n\\n    event ClaimBack(address indexed purchaser, uint256 amount);\\n    \\n    AggregatorV3Interface internal priceFeed;\\n\\n    constructor() public { // wallet which has the ICO tokens\\n        \\n    }\\n\\n    function setWallet(address payable _wallet) public onlyAdmin  {\\n        wallet = _wallet;\\n    }\\n\\n    receive () external payable {\\n        if(msg.sender != wallet \\u0026\\u0026 msg.sender != address(0x0) \\u0026\\u0026 !isCanceled) {\\n            buyTokens(msg.value);\\n        }\\n    }\\n    \\n    function initiatePricefeed() public onlyAdmin {\\n        priceFeed = AggregatorV3Interface(chainLinkAddress);\\n    }\\n\\n    function getTokenRate() public view returns (int) {\\n        (\\n            uint80 roundID, \\n            int price,\\n            uint startedAt,\\n            uint timeStamp,\\n            uint80 answeredInRound\\n        ) = priceFeed.latestRoundData();\\n        \\n        return (price * 100/6 * 10**10);\\n    }\\n\\n    function buyTokens(uint256 _weiAmount) private {\\n        require(validPurchase(), \\\"Requirements to buy are not met\\\");\\n        uint256 rate = uint256(getTokenRate());\\n        // uint256 rate = getTokenRate();\\n        // calculate token amount to be created\\n        uint256 amount = 0;\\n        uint256 tokens = 0;\\n        uint256 newBalance = 0;\\n       \\n        participations[msg.sender] = participations[msg.sender].safeAdd(_weiAmount);\\n        if(participants.containsAddress(msg.sender))\\n        {\\n            amount = _weiAmount.safeMul(rate);\\n            tokens = amount.safeDiv(1000000000000000000);\\n            Maps.Participant memory existingParticipant = participants.getByAddress(msg.sender);\\n            newBalance = tokens.safeAdd(existingParticipant.Tokens);\\n        }\\n        else {\\n            amount = _weiAmount.safeMul(rate);\\n            tokens = amount.safeDiv(1000000000000000000);\\n            newBalance = tokens;\\n        } \\n        participants.insertOrUpdate(Maps.Participant(msg.sender, participations[msg.sender], newBalance, block.timestamp));\\n\\n        //forward funds to wallet\\n        forwardFunds();\\n\\n         // update state\\n        weiRaised = weiRaised.safeAdd(_weiAmount);\\n         //purchase tokens and transfer to buyer\\n        token.transferFrom(wallet, msg.sender, tokens);\\n         //Token purchase event\\n        emit BuyTokens(msg.sender, msg.sender, _weiAmount, tokens);\\n    }\\n\\n    function GetNumberOfParticipants() public view  returns (uint) {\\n        return participants.count;\\n    }\\n\\n    function GetMaxIndex() public view  returns (uint) {\\n        return participants.lastIndex;\\n    }\\n\\n    function GetParticipant(uint index) public view  returns (address Address, uint256 Participation, uint256 Tokens, uint256 Timestamp ) {\\n        Maps.Participant memory participant = participants.get(index);\\n        Address = participant.Address;\\n        Participation = participant.Participation;\\n        Tokens = participant.Tokens;\\n        Timestamp = participant.Timestamp;\\n    }\\n    \\n    function Contains(address _address) public view returns (bool) {\\n        return participants.contains(Maps.Participant(_address, 0, 0, block.timestamp));\\n    }\\n    \\n    function Destroy() private returns (bool) {\\n        participants.destroy();\\n    }\\n\\n    function buyTokens() public payable {\\n        require(msg.sender != address(0x0), \\\"Can\\u0027t by from null\\\");\\n        buyTokens(msg.value);\\n    }\\n\\n    //send tokens to the given address used for investors with other conditions, only contract admin can call this\\n    function transferTokensManual(address beneficiary, uint256 amount) public onlyAdmin {\\n        require(beneficiary != address(0x0), \\\"address can\\u0027t be null\\\");\\n        require(amount \\u003e 0, \\\"amount should greater than 0\\\");\\n\\n        //transfer tokens\\n        token.transferFrom(wallet, beneficiary, amount);\\n\\n        //Token purchase event\\n        emit BuyTokens(wallet, beneficiary, 0, amount);\\n\\n    }\\n\\n    // send ether to the fund collection wallet\\n    function forwardFunds() internal {\\n        wallet.transfer(msg.value);\\n    }\\n\\n    // should be called after crowdsale ends or to emergency stop the sale\\n    function finalize() public onlyAdmin {\\n        require(!isFinalized, \\\"Is already finalised\\\");\\n        emit Finalized();\\n        isFinalized = true;\\n    }\\n\\n    // @return true if the transaction can buy tokens\\n    // check for valid time period, min amount and within cap\\n    function validPurchase() internal view returns (bool) {\\n        bool withinPeriod = startDate \\u003c= block.timestamp \\u0026\\u0026 endDate \\u003e= block.timestamp;\\n        bool nonZeroPurchase = msg.value != 0;\\n        bool minAmount = msg.value \\u003e= minimumParticipationAmount;\\n        bool withinCap = weiRaised.safeAdd(msg.value) \\u003c= cap;\\n\\n        return withinPeriod \\u0026\\u0026 nonZeroPurchase \\u0026\\u0026 minAmount \\u0026\\u0026 !isFinalized \\u0026\\u0026 withinCap;\\n    }\\n\\n    // @return true if the goal is reached\\n    function capReached() public view returns (bool) {\\n        return weiRaised \\u003e= cap;\\n    }\\n\\n    function minimumCapReached() public view returns (bool) {\\n        return weiRaised \\u003e= minimumToRaise;\\n    }\\n\\n    function claimBack() public {\\n        require(isCanceled, \\\"The presale is not canceled, claiming back is not possible\\\");\\n        require(participations[msg.sender] \\u003e 0, \\\"The sender didn\\u0027t participate to the presale\\\");\\n        uint256 participation = participations[msg.sender];\\n        participations[msg.sender] = 0;\\n        msg.sender.transfer(participation);\\n        emit ClaimBack(msg.sender, participation);\\n    }\\n\\n    function cancelSaleIfCapNotReached() public onlyAdmin {\\n        require(weiRaised \\u003c minimumToRaise, \\\"The amount raised must not exceed the minimum cap\\\");\\n        require(!isCanceled, \\\"The presale must not be canceled\\\");\\n        require(endDate \\u003e block.timestamp, \\\"The presale must not have ended\\\");\\n        isCanceled = true;\\n    }\\n}\"},\"Maps.sol\":{\"content\":\"pragma solidity ^0.6.0;\\nimport \\u0027./SafeMath.sol\\u0027;\\n// SPDX-License-Identifier: UNLICENSED\\n\\nlibrary Maps {\\n    using SafeMath for uint256;\\n\\n    struct Participant {\\n        address Address;\\n        uint256 Participation;\\n        uint256 Tokens;\\n        uint256 Timestamp;\\n    }\\n\\n    struct Map {\\n        mapping(uint =\\u003e Participant) data;\\n        uint count;\\n        uint lastIndex;\\n        mapping(address =\\u003e bool) addresses;\\n        mapping(address =\\u003e uint) indexes;\\n    }\\n\\n    function insertOrUpdate(Map storage self, Participant memory value) internal {\\n        if(!self.addresses[value.Address]) {\\n            uint newIndex = ++self.lastIndex;\\n            self.count++;\\n            self.indexes[value.Address] = newIndex;\\n            self.addresses[value.Address] = true;\\n            self.data[newIndex] = value;\\n        }\\n        else {\\n            uint existingIndex = self.indexes[value.Address];\\n            self.data[existingIndex] = value;\\n        }\\n    }\\n\\n    function remove(Map storage self, Participant storage value) internal returns (bool success) {\\n        if(!self.addresses[value.Address]) {\\n            return false;\\n        }\\n        uint index = self.indexes[value.Address];\\n        self.addresses[value.Address] = false;\\n        self.indexes[value.Address] = 0;\\n        delete self.data[index];\\n        self.count--;\\n        return true;\\n    }\\n\\n    function destroy(Map storage self) internal {\\n        for (uint i; i \\u003c= self.lastIndex; i++) {\\n            if(self.data[i].Address != address(0x0)) {\\n                delete self.addresses[self.data[i].Address];\\n                delete self.indexes[self.data[i].Address];\\n                delete self.data[i];\\n            }\\n        }\\n        self.count = 0;\\n        self.lastIndex = 0;\\n        return ;\\n    }\\n    \\n    function contains(Map storage self, Participant memory participant) internal view returns (bool exists) {\\n        return self.indexes[participant.Address] \\u003e 0;\\n    }\\n\\n    function length(Map memory self) internal pure returns (uint) {\\n        return self.count;\\n    }\\n\\n    function get(Map storage self, uint index) internal view returns (Participant storage) {\\n        return self.data[index];\\n    }\\n\\n    function getIndexOf(Map storage self, address _address) internal view returns (uint256) {\\n        return self.indexes[_address];\\n    }\\n\\n    function getByAddress(Map storage self, address _address) internal view returns (Participant storage) {\\n        uint index = self.indexes[_address];\\n        return self.data[index];\\n    }\\n\\n    function containsAddress(Map storage self, address _address) internal view returns (bool exists) {\\n        return self.indexes[_address] \\u003e 0;\\n    }\\n}\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n// SPDX-License-Identifier: UNLICENSED\\n\\ncontract Ownable {\\n    address payable public admin;\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `admin` of the contract to the sender\\n   * account.\\n   */\\n    constructor() public {\\n        admin = msg.sender;\\n    }\\n\\n  /**\\n   * @dev Throws if called by any account other than the admin.\\n   */\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"Function reserved to admin\\\");\\n        _;\\n    }\\n\\n  /**\\n   * @dev Allows the current admin to transfer control of the contract to a new admin.\\n   * @param _newAdmin The address to transfer ownership to.\\n   */\\n\\n    function transferOwnership(address payable _newAdmin) public onlyAdmin {\\n        require(_newAdmin != address(0), \\\"New admin can\\u0027t be null\\\");      \\n        admin = _newAdmin;\\n    }\\n\\n    function destroy() onlyAdmin public {\\n        selfdestruct(admin);\\n    }\\n\\n    function destroyAndSend(address payable _recipient) public onlyAdmin {\\n        selfdestruct(_recipient);\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n// SPDX-License-Identifier: UNLICENSED\\n\\nlibrary SafeMath {\\n    function safeMul(uint a, uint b) internal pure returns (uint) {\\n        uint c = a * b;\\n        assert(a == 0 || c / a == b);\\n        return c;\\n    }\\n\\n    function safeSub(uint a, uint b) internal pure returns (uint) {\\n        assert(b \\u003c= a);\\n        return a - b;\\n    }\\n\\n    function safeAdd(uint a, uint b) internal pure returns (uint) {\\n        uint c = a + b;\\n        assert(c\\u003e=a \\u0026\\u0026 c\\u003e=b);\\n        return c;\\n    }\\n\\n    function safeDiv(uint a, uint b) internal pure returns (uint) {\\n        assert(b \\u003e 0);\\n        uint c = a / b;\\n        assert(a == b * c + a % b);\\n        return c;\\n    }\\n}\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BuyTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"Contains\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetMaxIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetNumberOfParticipants\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"GetParticipant\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"Address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Participation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelSaleIfCapNotReached\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"capReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainLinkAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_endDate\",\"type\":\"uint256\"}],\"name\":\"changeEndDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startDate\",\"type\":\"uint256\"}],\"name\":\"changeStartDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"destroyAndSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainlinkAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenRate\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initiatePricefeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCanceled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumCapReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumParticipationAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumToRaise\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"participants\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"participations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferTokensManual\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"CrowdSale","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4bafb1b29f00c8e22d34cbf5b71e37854825a361c2bd945a90449b8a2ad8750e"}]}