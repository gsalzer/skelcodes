{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function sync() external;\r\n}\r\n\r\ninterface UniswapRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function addLiquidityETH(address token,uint amountTokenDesired,uint amountTokenMin,uint amountETHMin,address to,uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] memory path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IPVault {\r\n    function deposit(uint256 amount) external;\r\n    function claimReward(uint256 amount) external;\r\n    function claimRewardAll() external;\r\n    function withdraw(uint256 amount) external;\r\n}\r\n\r\ninterface YCrvGauge {\r\n    function deposit(uint256 amount) external;\r\n    function withdraw(uint256 amount) external;\r\n    function integrate_fraction(address account) external view returns (uint256);\r\n    function user_checkpoint(address account) external returns (bool);\r\n    function crv_token() external view returns (address);\r\n    function controller() external view returns (address);\r\n    function period() external view returns (uint256);\r\n    function period_timestamp(uint256 amount) external view returns (uint256);\r\n    function integrate_inv_supply(uint256 amount) external view returns (uint256);\r\n    function integrate_inv_supply_of(address account) external view returns (uint256);\r\n    function inflation_rate() external view returns (uint256);\r\n    function future_epoch_time() external view returns (uint256);\r\n    function working_balances(address account) external view returns (uint256);\r\n    function working_supply() external view returns (uint256);\r\n}\r\n\r\ninterface Controller {\r\n    function gauge_relative_weight(address account, uint256 time) external view returns (uint256);\r\n}\r\n\r\ninterface CRV20 {\r\n    function rate() external view returns (uint256);\r\n}\r\n\r\ninterface TokenMinter {\r\n    function mint(address account) external;\r\n    function minted(address account, address guage) external view returns (uint256);\r\n}\r\n\r\ninterface IUniswapV2ERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\ncontract auto_pvault {\r\n\r\n    IERC20 constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    UniswapRouter constant UNIROUTER = UniswapRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    IUniswapV2ERC20 constant LPT = IUniswapV2ERC20(0xBe9Ba93515e87C7Bd3A0CEbB9f61AAabE7A77Dd3);\r\n    YCrvGauge constant YCRVGAUGE = YCrvGauge(0xFA712EE4788C042e2B7BB55E6cb8ec569C4530c1);\r\n    TokenMinter constant TOKENMINTER = TokenMinter(0xd061D61a4d941c39E5453435B6345Dc261C2fcE0);\r\n    IERC20 constant CRV = IERC20(0xD533a949740bb3306d119CC777fa900bA034cd52);\r\n\r\n    IERC20 public token0;\r\n    IERC20 public token1;\r\n    IPVault public pvault;\r\n\r\n    address public feeAddress;\r\n    address public treasury;\r\n    address public gov;\r\n    address[] internal stakeholders;\r\n\r\n    string public vaultName;\r\n    uint32 constant TOTALRATE = 10000;\r\n    uint32 public feeRate;\r\n    uint32 public rewardUserRate = 7000;\r\n    uint32 public rewardTreasuryRate = 3000;\r\n    uint32 public gasRewardTreasuryRate = 7000;\r\n    uint32 public pvault_rate = 2000;\r\n    uint256 constant WEEK = 604800;\r\n    uint256 public address_array_len;\r\n    uint256 constant TOTALWETHRATE = 10000000000;\r\n    uint256 constant TOTALUSERWETHSHARE = 5384615385;\r\n    uint256 public timestamp_block;\r\n    uint256 public max;\r\n    uint256 public finalP;\r\n    uint256 public finalW;\r\n    uint256 public finalLPT;\r\n    uint256 public delayDuration = 1 days;\r\n\r\n    event yCRVDeposited(address indexed user, uint amount);\r\n    event AllRewardsClaimed(address indexed user, uint amount, uint amount2);\r\n    event WithdrawnAndAllRewardsClaimed(address indexed user, uint amount, uint amount2, uint amount3);\r\n    event AutoCompoundedCRV2PVAULT(address indexed user, uint amount);\r\n    event MassAutoCompoundedCRV2PVAULT(address indexed user, uint amount);\r\n\r\n    struct User {\r\n        uint256 rewardedBalancePerUser; // CRV\r\n        uint256 lastTimestampPerUser; \r\n        uint256 depositBalancePerUser;  // in yCRV\r\n        uint256 accDepositBalancePerUser; // in yCRV\r\n        uint256 lpTokenUserReward; // LP Token\r\n        uint256 userRewardProportion; // Proportion entitled to based on user's deposit in relation to total deposits\r\n        uint256 massClaimReward;\r\n        uint256 rewardedPYLON;\r\n    }\r\n\r\n    struct Global {\r\n        uint256 lastTotalTimestamp;\r\n        uint256 accTotalReward;\r\n        uint256 totalDeposit;\r\n        uint256 accTotalDeposit;\r\n        uint256 totalDepositForAPY;\r\n        uint256 lpTokenReward;\r\n        uint256 userCount;\r\n        uint256 lpTotalDeposit;\r\n        uint256 lastMassDrainTimestamp;\r\n        uint256 totalPYLON;\r\n        bool isEligibleI;\r\n    }\r\n\r\n    struct vals {\r\n        uint256 pylonAmount;\r\n        uint256 wethUser;\r\n        uint256 lpAmount;  \r\n        uint256 wethSent;\r\n        uint256 pylonSent;\r\n        uint256 pylonNeeded;\r\n        uint256 wethNeeded;\r\n        uint256 crvNeeded4Reward;\r\n        uint256 gasRewardTreasury;\r\n        uint256 finalLPTsent;\r\n        uint256 crv4LP;\r\n        uint256 crvFromGauge;\r\n        uint256 crv4pylonLP;\r\n        uint256 crv4wethLP;\r\n    }\r\n\r\n    // gas price is in wei\r\n    struct vespiangas {\r\n        uint getRewardGas;\r\n        uint getRewardGasPrice;\r\n    }\r\n\r\n    mapping(address => User) public user_; \r\n    mapping(uint256 => Global) public global_;\r\n    mapping(uint256 => vals) public vals_;\r\n    mapping(uint256 => vespiangas) public gas_;\r\n\r\n    constructor (address _token0, address _token1, address _feeAddress, address _pvault, string memory name, address _treasury) payable {\r\n        token0 = IERC20(_token0);\r\n        token1 = IERC20(_token1);\r\n        feeAddress = _feeAddress;\r\n        pvault = IPVault(_pvault);\r\n        vaultName = name;\r\n        gov = msg.sender;\r\n        treasury = _treasury;\r\n        token0.approve(address(YCRVGAUGE), type(uint).max);\r\n        CRV.approve(address(UNIROUTER), type(uint).max);\r\n        CRV.approve(address(this), type(uint).max);\r\n        WETH.approve(address(UNIROUTER), type(uint).max);\r\n        token1.approve(address(UNIROUTER), type(uint).max);\r\n        token1.approve(address(this), type(uint).max);\r\n        WETH.approve(address(this), type(uint).max);\r\n        WETH.approve(address(LPT), type(uint).max);\r\n        token1.approve(address(LPT), type(uint).max);\r\n        LPT.approve(address(this), type(uint).max);\r\n    }\r\n\r\n    modifier onlyGov() {\r\n        require(msg.sender == gov, \"!governance\");\r\n        _;\r\n    }\r\n\r\n    function isStakeholder(address _address) public view returns(bool, uint256) {\r\n        for (uint256 s = 0; s < stakeholders.length; s += 1){\r\n            if (_address == stakeholders[s]) return (true, s);\r\n        }\r\n        return (false, 0);\r\n    }\r\n\r\n    function isMassDrainEligible() internal returns (bool){\r\n        \r\n        bool result;\r\n        \r\n        // if first time calling this function via massAutoCompoundCRV2PVAULT then global_[0].lastMassDrainTimestamp\r\n        // will be assigned as the current timestamp and return false since 24 hours likely hasn't passed.\r\n        if (global_[0].lastMassDrainTimestamp == 0) {\r\n            global_[0].lastMassDrainTimestamp = block.timestamp;\r\n            result = false;\r\n        }\r\n        else if (global_[0].lastMassDrainTimestamp + delayDuration > block.timestamp) {\r\n            result = false; // last time was called + 24 hours is larger than current time, so 24 hours hasn't passed\r\n        }\r\n        else {\r\n            result = true;\r\n        }\r\n        global_[0].isEligibleI = result;\r\n        return (result);\r\n    }\r\n\r\n    function isEligibleExternal() external returns (bool){\r\n        \r\n        bool result;\r\n        \r\n        // if first time calling this function via massAutoCompoundCRV2PVAULT then global_[0].lastMassDrainTimestamp\r\n        // will be assigned as the current timestamp and return false since 24 hours likely hasn't passed.\r\n        if (global_[0].lastMassDrainTimestamp == 0) {\r\n            global_[0].lastMassDrainTimestamp = block.timestamp;\r\n            result = false;\r\n        }\r\n        else if (global_[0].lastMassDrainTimestamp + delayDuration > block.timestamp) {\r\n            result = false; // last time was called + 24 hours is larger than current time, so 24 hours hasn't passed\r\n        }\r\n        else {\r\n            result = true;\r\n        }\r\n        global_[0].isEligibleI = result;\r\n        return (result);\r\n    }\r\n    \r\n    // don't need to call this on main net test if the isEligibleExternal function is called first\r\n    function setMassTS() external {\r\n        if (global_[0].lastMassDrainTimestamp == 0) {\r\n            global_[0].lastMassDrainTimestamp = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function addStakeholder(address _stakeholder) public {\r\n        (bool _isStakeholder, ) = isStakeholder(_stakeholder);\r\n        if(!_isStakeholder) stakeholders.push(_stakeholder);\r\n    }\r\n\r\n    function removeStakeholder(address _stakeholder) public {\r\n        (bool _isStakeholder, uint256 s) = isStakeholder(_stakeholder);\r\n        if(_isStakeholder){\r\n            stakeholders[s] = stakeholders[stakeholders.length - 1];\r\n            stakeholders.pop();\r\n        }\r\n    }\r\n\r\n    modifier updateBalance(address userAddress) {\r\n        uint lastTimestamp = user_[userAddress].lastTimestampPerUser;\r\n        uint totalTimestamp = global_[0].lastTotalTimestamp;\r\n        if (lastTimestamp > 0) {\r\n            user_[userAddress].accDepositBalancePerUser += user_[userAddress].depositBalancePerUser * (block.timestamp - lastTimestamp);\r\n        }\r\n\r\n        if (totalTimestamp > 0) {\r\n            global_[0].accTotalDeposit += global_[0].totalDeposit * (block.timestamp - totalTimestamp);\r\n        }\r\n        user_[userAddress].lastTimestampPerUser = block.timestamp;\r\n        global_[0].lastTotalTimestamp = block.timestamp;\r\n        _;\r\n    }\r\n\r\n    modifier updateBalanceAllUsers() {\r\n\r\n        uint totalTimestamp = global_[0].lastTotalTimestamp;\r\n\r\n        // userCount is updated when someone deposits or withdraws\r\n        for (uint i=0; i < global_[0].userCount ; i += 1){\r\n\r\n            address ua = stakeholders[i];\r\n\r\n            uint lastTimestamp = user_[ua].lastTimestampPerUser;\r\n\r\n            if (lastTimestamp > 0) {\r\n                user_[ua].accDepositBalancePerUser += user_[ua].depositBalancePerUser * (block.timestamp - lastTimestamp);\r\n            }\r\n\r\n            user_[ua].lastTimestampPerUser = block.timestamp;\r\n        }\r\n\r\n        if (totalTimestamp > 0) {\r\n            global_[0].accTotalDeposit += global_[0].totalDeposit * (block.timestamp - totalTimestamp);\r\n        }\r\n        global_[0].lastTotalTimestamp = block.timestamp; \r\n        _;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        if (a > b) {\r\n            return b;\r\n        }\r\n        else {\r\n            return a;\r\n        }\r\n    }\r\n\r\n    function setGovernance(address _gov)\r\n        external\r\n        onlyGov\r\n    {\r\n        gov = _gov;\r\n    }\r\n\r\n    function setToken0(address _token)\r\n        external\r\n        onlyGov\r\n    {\r\n        token0 = IERC20(_token);\r\n    }\r\n\r\n    function setToken1(address _token)\r\n        external\r\n        onlyGov\r\n    {\r\n        token1 = IERC20(_token);\r\n    }\r\n\r\n    function setTreasury(address _treasury)\r\n        external\r\n        onlyGov\r\n    {\r\n        treasury = _treasury;\r\n    }\r\n\r\n    function setUserRate(uint32 _rewardUserRate)\r\n        external\r\n        onlyGov\r\n    {\r\n        rewardUserRate = _rewardUserRate;\r\n    }\r\n\r\n    function setTreasuryRate(uint32 _rewardTreasuryRate)\r\n        external\r\n        onlyGov\r\n    {\r\n        rewardTreasuryRate = _rewardTreasuryRate;\r\n    }\r\n\r\n    function setFeeAddress(address _feeAddress)\r\n        external\r\n        onlyGov\r\n    {\r\n        feeAddress = _feeAddress;\r\n    }\r\n\r\n    function setFeeRate(uint32 _feeRate)\r\n        external\r\n        onlyGov\r\n    {\r\n        feeRate = _feeRate;\r\n    }\r\n\r\n    function setVaultName(string memory name)\r\n        external\r\n        onlyGov\r\n    {\r\n        vaultName = name;\r\n    }\r\n\r\n    function getRewardI() internal {\r\n\r\n        uint256 rewardAmountForCRVToken = CRV.balanceOf(address(this));\r\n        TOKENMINTER.mint(address(YCRVGAUGE));\r\n        rewardAmountForCRVToken = CRV.balanceOf(address(this)) - rewardAmountForCRVToken;\r\n        uint256 rewardCRVTokenAmountForUsers = rewardAmountForCRVToken * rewardUserRate / TOTALRATE;\r\n        uint256 rewardCRVTokenAmountForTreasury = rewardAmountForCRVToken - rewardCRVTokenAmountForUsers; // 30% of reward goes to treasur\r\n\r\n        uint256 rewardPylonTokenAmountForUsers = token1.balanceOf(address(this));\r\n        \r\n        // apportion respective amounts to be made into ETH-PYLON LP Token\r\n        uint256 AmountForUsersCRV2PYLON = rewardCRVTokenAmountForUsers / 2; // 50% of the 70% will be converted to Pylon\r\n        uint256 amountForUsersCRV2WETH = rewardCRVTokenAmountForUsers / 2; // other 50% of the 70% will be converted to WET\r\n        \r\n        // combine the 50% CRV for user and 30% CRV for treasury so that only one call is made to convert CRV to WETH, will apportion returned WETH correctly below\r\n        uint256 totalCrv2WethReward = amountForUsersCRV2WETH + rewardCRVTokenAmountForTreasury;\r\n\r\n        address[] memory tokens = new address[](3);\r\n        address[] memory tokens1 = new address[](2);\r\n\r\n        tokens[0] = address(CRV);\r\n        tokens[1] = address(WETH);\r\n        tokens[2] = address(token1);\r\n        tokens1[0] = address(CRV);\r\n        tokens1[1] = address(WETH);\r\n\r\n        if (rewardCRVTokenAmountForUsers > 0) {\r\n            UNIROUTER.swapExactTokensForTokens(AmountForUsersCRV2PYLON, 0, tokens, address(this), type(uint).max);\r\n        }\r\n\r\n        uint256 wethBalance = WETH.balanceOf(address(this));\r\n        if (totalCrv2WethReward > 0) {\r\n            UNIROUTER.swapExactTokensForTokens(totalCrv2WethReward, 0, tokens1, address(this), type(uint).max);\r\n        }\r\n\r\n        wethBalance = WETH.balanceOf(address(this)) - wethBalance;\r\n\r\n        // lpWETH gets set to the proportion of WETH to go to users (that will be used in LP token creation)\r\n        uint256 lpWETH = wethBalance * TOTALUSERWETHSHARE / TOTALWETHRATE; // rougly 54% of WETH returned from CRV 2 WETH swap will go to LP token creation\r\n        vals_[0].wethUser = lpWETH;\r\n        uint256 treasuryWETH = wethBalance - lpWETH; // remaining ~46% of CRV 2 WETH swap goes to treasury\r\n\r\n        // Pylon amount to be combined with WETH to make LP Token\r\n        vals_[0].pylonAmount += token1.balanceOf(address(this)) - rewardPylonTokenAmountForUsers;\r\n\r\n        // Transfer reward to Treasury\r\n        if (treasuryWETH > 0) {\r\n            WETH.transfer(treasury, treasuryWETH);\r\n        }\r\n\r\n        addLiquidityAndStakeI();\r\n\r\n    }\r\n\r\n    function assessGasV2() internal {\r\n        \r\n        address[] memory tokens1 = new address[](2);\r\n        tokens1[0] = address(CRV);\r\n        tokens1[1] = address(WETH);\r\n\r\n        uint256 wethBalance = WETH.balanceOf(address(this));\r\n        uint256 crvRewardNeeded4swap = vals_[0].crvNeeded4Reward;\r\n        if (crvRewardNeeded4swap > 0) {\r\n            UNIROUTER.swapExactTokensForTokens(crvRewardNeeded4swap, 0, tokens1, address(this), type(uint).max);\r\n        }\r\n\r\n        wethBalance = WETH.balanceOf(address(this)) - wethBalance;\r\n\r\n        uint256 gasRewardTreasury = wethBalance * gasRewardTreasuryRate / TOTALRATE;\r\n        vals_[0].gasRewardTreasury = gasRewardTreasury; // will combine with weth reward for treasury in getRewardAllI()\r\n        \r\n        uint256 userMassGasReward  = wethBalance - gasRewardTreasury;\r\n        user_[msg.sender].massClaimReward = userMassGasReward;\r\n\r\n        // Transfer gas reward to user\r\n        if (userMassGasReward > 0) {\r\n            WETH.transfer(msg.sender, userMassGasReward);\r\n        }\r\n\r\n        // Transfer gas Reward to Treasury\r\n        if (gasRewardTreasury > 0) {\r\n            WETH.transfer(treasury, gasRewardTreasury);\r\n        }\r\n    }\r\n    \r\n    function getRewardAll() internal {\r\n\r\n        TOKENMINTER.mint(address(YCRVGAUGE));\r\n        uint256 rewardAmountForCRVToken = CRV.balanceOf(address(this));\r\n        vals_[0].crvFromGauge = rewardAmountForCRVToken;\r\n\r\n        uint256 numUsers = global_[0].userCount - 1; // subtracting 1 since the user calling shouldn't be included in calculation\r\n        \r\n        uint256 getRewardGasWei = 479470 * numUsers * tx.gasprice;\r\n        gas_[0].getRewardGas = getRewardGasWei;\r\n        //gas_[0].getRewardGasPrice = tx.gasprice;\r\n\r\n        address[] memory tokens = new address[](3);\r\n        address[] memory tokens1 = new address[](2);\r\n\r\n        tokens[0] = address(CRV);\r\n        tokens[1] = address(WETH);\r\n        tokens[2] = address(token1);\r\n        tokens1[0] = address(CRV);\r\n        tokens1[1] = address(WETH);\r\n        \r\n        uint256 crv_needed = UNIROUTER.getAmountsIn(getRewardGasWei, tokens1)[0];\r\n        vals_[0].crvNeeded4Reward = crv_needed;\r\n\r\n        uint256 rewardCRVTokenAmountForTreasury = rewardAmountForCRVToken * rewardTreasuryRate / TOTALRATE; // 30% of reward goes to treasur\r\n        uint256 rewardCRVTokenAmountForUsers = rewardAmountForCRVToken - rewardCRVTokenAmountForTreasury;\r\n        \r\n        require(rewardCRVTokenAmountForUsers > crv_needed, \"CRV reward from gauge not yet big enough for mass autocompound\");\r\n        rewardCRVTokenAmountForUsers = rewardCRVTokenAmountForUsers - crv_needed; // subtract out CRV needed for gasReward\r\n        vals_[0].crv4LP = rewardCRVTokenAmountForUsers;\r\n        \r\n        if (rewardCRVTokenAmountForUsers > 0){\r\n            assessGasV2(); \r\n        }\r\n\r\n        uint256 rewardPylonTokenAmountForUsers = token1.balanceOf(address(this));\r\n        \r\n        // apportion respective amounts to be made into ETH-PYLON LP Token\r\n        uint256 AmountForUsersCRV2PYLON = rewardCRVTokenAmountForUsers / 2; // 50% of the 70% will be converted to Pylon\r\n        vals_[0].crv4pylonLP = AmountForUsersCRV2PYLON;\r\n        uint256 amountForUsersCRV2WETH = rewardCRVTokenAmountForUsers / 2; // other 50% of the 70% will be converted to WET\r\n        vals_[0].crv4wethLP = amountForUsersCRV2WETH;\r\n        \r\n        \r\n        // combine the 50% CRV for user and 30% CRV for treasury so that only one call is made to convert CRV to WETH, will apportion returned WETH correctly below\r\n        uint256 totalCrv2WethReward = amountForUsersCRV2WETH + rewardCRVTokenAmountForTreasury; \r\n\r\n        if (rewardCRVTokenAmountForUsers > 0) {\r\n            UNIROUTER.swapExactTokensForTokens(AmountForUsersCRV2PYLON, 0, tokens, address(this), type(uint).max);\r\n        }\r\n\r\n        uint256 wethBalance = WETH.balanceOf(address(this));\r\n        if (totalCrv2WethReward > 0) {\r\n            UNIROUTER.swapExactTokensForTokens(totalCrv2WethReward, 0, tokens1, address(this), type(uint).max);\r\n        }\r\n\r\n        wethBalance = WETH.balanceOf(address(this)) - wethBalance;\r\n\r\n        // lpWETH gets set to the proportion of WETH to go to users (that will be used in LP token creation)\r\n        uint256 lpWETH = wethBalance * TOTALUSERWETHSHARE / TOTALWETHRATE; // rougly 54% of WETH returned from CRV 2 WETH swap will go to LP token creation\r\n        vals_[0].wethUser = lpWETH;\r\n        uint256 treasuryWETH = wethBalance - lpWETH; // remaining ~46% of CRV 2 WETH swap goes to treasury\r\n\r\n        // Pylon amount to be combined with WETH to make LP Token\r\n        vals_[0].pylonAmount = token1.balanceOf(address(this)) - rewardPylonTokenAmountForUsers;\r\n\r\n        addLiquidityAndStakeI(); // make LP token\r\n\r\n        // Transfer reward to Treasury\r\n        if (treasuryWETH > 0) {\r\n            WETH.transfer(treasury, treasuryWETH);\r\n        }\r\n    }\r\n\r\n    function addLiquidityAndStakeI() internal {\r\n        \r\n        uint pylonSent;\r\n        uint wethSent;\r\n        uint lpTotalReward;\r\n\r\n        // approving again; will test removing these as constructor should be doing this...\r\n        WETH.approve(address(LPT), type(uint).max);\r\n        token1.approve(address(LPT), type(uint).max);\r\n        \r\n        finalP = vals_[0].pylonAmount;\r\n        finalW = vals_[0].wethUser;\r\n        \r\n        // Need 50/50 PYLON/WETH for LP Token\r\n        if (finalP > finalW){\r\n            finalP = finalW;\r\n        }\r\n        if (finalW > finalP){\r\n            finalW = finalP;\r\n        }\r\n\r\n        // makes PYLON-ETH LP Token and sends to contract\r\n        (pylonSent, wethSent, lpTotalReward) = UNIROUTER.addLiquidity(address(token1), address(WETH), finalP, finalW, 0,  0, address(this), block.timestamp); \r\n\r\n        global_[0].lpTokenReward = LPT.balanceOf(address(this));\r\n    }\r\n\r\n    function _depositYCRV(uint amount) internal updateBalance(msg.sender) {\r\n\r\n        uint feeAmount = amount * feeRate / TOTALRATE;\r\n        uint realAmount = amount - feeAmount;\r\n\r\n        if (feeAmount > 0) {\r\n            token0.transferFrom(msg.sender, feeAddress, feeAmount);\r\n        }\r\n        \r\n        if (realAmount > 0) {\r\n            token0.transferFrom(msg.sender, address(this), realAmount);\r\n            YCRVGAUGE.deposit(realAmount);\r\n            user_[msg.sender].depositBalancePerUser += realAmount;\r\n            global_[0].totalDeposit += realAmount;\r\n            global_[0].totalDepositForAPY += realAmount;\r\n            emit yCRVDeposited(msg.sender, realAmount);\r\n        }\r\n    }\r\n\r\n    // need to reset accounts when switching on metamask and remix\r\n    function depositYCRV(uint amount) external {\r\n        require(amount > 0, \"deposit must be greater than 0\");\r\n        // check if user has deposited before, if not then will add to stakeholder list, otherwise does nothing\r\n        addStakeholder(msg.sender);\r\n        global_[0].userCount = stakeholders.length; // update this before updateBalance modifier is applied to _deposit\r\n        _depositYCRV(amount);\r\n    }\r\n\r\n    function updateUserPylonReward() internal {\r\n\r\n        // grab total pylon reward from pvault\r\n        pvault.claimRewardAll();\r\n        uint256 PYLON = token1.balanceOf(address(this));\r\n        global_[0].totalPYLON += PYLON;\r\n\r\n        // loop through stakeholders array and update each user's pylon reward\r\n        for (uint i=0; i < global_[0].userCount ; i += 1) {\r\n\r\n            address ua = stakeholders[i];\r\n            user_[ua].rewardedPYLON += PYLON * user_[ua].accDepositBalancePerUser / global_[0].accTotalDeposit;\r\n        }\r\n    }\r\n\r\n    // same as withdrawAndClaimAllRewards except leaves the yCRV deposited in the gauge\r\n    function ClaimAllRewards() external updateBalance(msg.sender) {\r\n        \r\n        // LPT Withdrawl from PVAULT\r\n        uint lpDepositBalance = user_[msg.sender].lpTokenUserReward; \r\n        uint amountWithdrawForLPT = LPT.balanceOf(address(this));\r\n        pvault.withdraw(lpDepositBalance); // assumes that this contract's address is sent to pvault so that the transfer below must happen\r\n        amountWithdrawForLPT = LPT.balanceOf(address(this)) - amountWithdrawForLPT;\r\n        LPT.transfer(msg.sender, amountWithdrawForLPT); // assumes that \r\n\r\n        user_[msg.sender].lpTokenUserReward = user_[msg.sender].lpTokenUserReward - amountWithdrawForLPT; // should be 0 after thi\r\n        global_[0].lpTotalDeposit -= amountWithdrawForLPT;\r\n\r\n        // PYLON Withdrawl from PVAULT\r\n        updateUserPylonReward();\r\n        uint256 amountWithdrawForPYLON = user_[msg.sender].rewardedPYLON; \r\n        global_[0].totalPYLON -= amountWithdrawForPYLON;\r\n\r\n        token1.transfer(msg.sender, amountWithdrawForPYLON);\r\n\r\n        emit AllRewardsClaimed(msg.sender, amountWithdrawForLPT, amountWithdrawForPYLON);\r\n    }\r\n\r\n    // need to test assumption that this contract's address is being used here rather than sending on msg.sender to the pvault contract; I think its the former\r\n    function _withdrawAndClaimAllRewards() internal updateBalance(msg.sender) {\r\n        \r\n        uint ycrvDepositBalance = user_[msg.sender].depositBalancePerUser;\r\n        uint amountWithdrawForYCRV = token0.balanceOf(address(this));\r\n        YCRVGAUGE.withdraw(ycrvDepositBalance);\r\n        amountWithdrawForYCRV = token0.balanceOf(address(this)) - amountWithdrawForYCRV;\r\n        token0.transfer(msg.sender, amountWithdrawForYCRV);\r\n        \r\n        user_[msg.sender].depositBalancePerUser = ycrvDepositBalance - amountWithdrawForYCRV;\r\n        global_[0].totalDeposit -= amountWithdrawForYCRV;\r\n\r\n        // LPT Withdrawl from PVAULT\r\n        uint lpDepositBalance = user_[msg.sender].lpTokenUserReward; \r\n        uint amountWithdrawForLPT = LPT.balanceOf(address(this));\r\n        pvault.withdraw(lpDepositBalance); // assumes that this contract's address is sent to pvault so that the transfer below must happen\r\n        amountWithdrawForLPT = LPT.balanceOf(address(this)) - amountWithdrawForLPT;\r\n        LPT.transfer(msg.sender, amountWithdrawForLPT); // assumes that \r\n\r\n        user_[msg.sender].lpTokenUserReward = user_[msg.sender].lpTokenUserReward - amountWithdrawForLPT; // should be 0 after thi\r\n        global_[0].lpTotalDeposit -= amountWithdrawForLPT;\r\n\r\n        // PYLON Withdrawl from PVAULT\r\n        updateUserPylonReward();\r\n        uint256 amountWithdrawForPYLON = user_[msg.sender].rewardedPYLON; \r\n        global_[0].totalPYLON -= amountWithdrawForPYLON;\r\n\r\n        token1.transfer(msg.sender, amountWithdrawForPYLON);\r\n\r\n        emit WithdrawnAndAllRewardsClaimed(msg.sender, amountWithdrawForYCRV, amountWithdrawForLPT, amountWithdrawForPYLON);\r\n    }\r\n\r\n    function withdrawAndClaimAllRewards() external {\r\n        removeStakeholder(msg.sender);\r\n        global_[0].userCount = stakeholders.length; //need to make sure that stakeholders array is actually getting updated properly\r\n        _withdrawAndClaimAllRewards();\r\n    }\r\n    \r\n    function autoCompoundCRV2PVAULT() external updateBalance(msg.sender) {\r\n        getRewardI(); \r\n\r\n        require(global_[0].userCount > 0, \"no users have deposited\");\r\n        uint256 LPTReward = global_[0].lpTokenReward;\r\n        require(LPTReward > 0, \"can't deposit 0 LP token into pvault\");\r\n        \r\n        uint256 userLPTReward = LPTReward * user_[msg.sender].accDepositBalancePerUser / global_[0].accTotalDeposit; // adjust for User's share before depositing on their behalf\r\n        user_[msg.sender].lpTokenUserReward = userLPTReward; // will need to decrement this in the PVWithdraw function\r\n\r\n        // do pvault deposit here\r\n        if (userLPTReward > LPTReward) {\r\n            userLPTReward = LPTReward;\r\n        }\r\n        if (userLPTReward > 0) {\r\n            \r\n            LPT.approve(address(this), type(uint).max);\r\n            LPT.approve(address(pvault), type(uint).max);\r\n\r\n            pvault.deposit(userLPTReward);\r\n            global_[0].lpTotalDeposit += userLPTReward; // keep track of total LP deposited by this contract\r\n\r\n            emit AutoCompoundedCRV2PVAULT(msg.sender, userLPTReward);\r\n        }      \r\n    }\r\n\r\n    // only using for testing for now\r\n    function alterMassTS() external {\r\n        global_[0].lastMassDrainTimestamp -= delayDuration;\r\n    }\r\n\r\n    function updateUserLPTReward() internal {\r\n\r\n        uint256 LPTReward = global_[0].lpTokenReward;\r\n\r\n        for (uint i=0; i < global_[0].userCount ; i += 1) {\r\n\r\n            address ua = stakeholders[i];\r\n            uint256 userLPTReward = LPTReward * user_[ua].accDepositBalancePerUser / global_[0].accTotalDeposit;\r\n            user_[ua].lpTokenUserReward  += userLPTReward;\r\n        }\r\n    }\r\n\r\n    function massAutoCompoundCRV2PVAULT() external updateBalanceAllUsers() {\r\n        \r\n        isMassDrainEligible(); // check that 24 hours has passed since last call \r\n        require(global_[0].isEligibleI == true, \"24 hours has not yet passed since last mass drain\");\r\n        require(global_[0].userCount > 1, \"2 or more users need to have deposited - use claimReward instead\");\r\n\r\n        getRewardAll();  \r\n\r\n        uint256 LPTReward = global_[0].lpTokenReward; \r\n        require(LPTReward > 0, \"can't deposit 0 LP token into pvault\");\r\n\r\n        updateUserLPTReward(); // update all user's share of LP Token reward\r\n\r\n        LPT.approve(address(this), type(uint).max); \r\n        LPT.approve(address(pvault), type(uint).max); \r\n\r\n        pvault.deposit(LPTReward); \r\n\r\n        global_[0].lpTotalDeposit += LPTReward; // keep track of total LP deposited by this contract\r\n            \r\n        global_[0].lastMassDrainTimestamp = block.timestamp;\r\n        emit MassAutoCompoundedCRV2PVAULT(msg.sender, LPTReward);\r\n    }\r\n\r\n    function seize(address token, address to) external onlyGov {\r\n        require(IERC20(token) != token1, \"main tokens\");\r\n        if (token != address(0)) {\r\n            uint amount = IERC20(token).balanceOf(address(this));\r\n            IERC20(token).transfer(to, amount);\r\n        }\r\n        else {\r\n            uint amount = address(this).balance;\r\n            payable(to).transfer(amount);\r\n        }\r\n    }\r\n        \r\n    fallback () external payable { }\r\n    receive () external payable {}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pvault\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount2\",\"type\":\"uint256\"}],\"name\":\"AllRewardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AutoCompoundedCRV2PVAULT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MassAutoCompoundedCRV2PVAULT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount3\",\"type\":\"uint256\"}],\"name\":\"WithdrawnAndAllRewardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"yCRVDeposited\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"ClaimAllRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeholder\",\"type\":\"address\"}],\"name\":\"addStakeholder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"address_array_len\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"alterMassTS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoCompoundCRV2PVAULT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositYCRV\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalLPT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalW\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasRewardTreasuryRate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gas_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"getRewardGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getRewardGasPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"global_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastTotalTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accTotalReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDepositForAPY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokenReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastMassDrainTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPYLON\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isEligibleI\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isEligibleExternal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isStakeholder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massAutoCompoundCRV2PVAULT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pvault\",\"outputs\":[{\"internalType\":\"contract IPVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pvault_rate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeholder\",\"type\":\"address\"}],\"name\":\"removeStakeholder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTreasuryRate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardUserRate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"seize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeAddress\",\"type\":\"address\"}],\"name\":\"setFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_feeRate\",\"type\":\"uint32\"}],\"name\":\"setFeeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gov\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setMassTS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken0\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_rewardTreasuryRate\",\"type\":\"uint32\"}],\"name\":\"setTreasuryRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_rewardUserRate\",\"type\":\"uint32\"}],\"name\":\"setUserRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setVaultName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timestamp_block\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardedBalancePerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTimestampPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositBalancePerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accDepositBalancePerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokenUserReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userRewardProportion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"massClaimReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardedPYLON\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vals_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pylonAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethSent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pylonSent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pylonNeeded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethNeeded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"crvNeeded4Reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasRewardTreasury\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalLPTsent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"crv4LP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"crvFromGauge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"crv4pylonLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"crv4wethLP\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAndClaimAllRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"auto_pvault","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000df5e0e81dff6faf3a7e52ba697820c5e32d806a8000000000000000000000000d7b7d3c0bda57723fb54ab95fd8f9ea033af37f2000000000000000000000000ad529aa6f7bc87079c5191f753fb5a59292d76220000000000000000000000001e232f3074e6b9eadf18aad92844eee2b4b3374400000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000ad529aa6f7bc87079c5191f753fb5a59292d762200000000000000000000000000000000000000000000000000000000000000196175746f636f6d706f756e645f707661756c745f746573743100000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://778f1e3a7a96a094d55b19d1017150b180831741b45b05a6c2d8cf94322177b5"}]}