{"status":"1","message":"OK","result":[{"SourceCode":"// contracts/multisender.sol\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title EternalStorage\r\n * @dev This contract holds all the necessary state variables to carry out the storage of any contract.\r\n */\r\ncontract EternalStorage {\r\n\r\n    mapping(bytes32 => uint256) internal uintStorage;\r\n    mapping(bytes32 => string) internal stringStorage;\r\n    mapping(bytes32 => address) internal addressStorage;\r\n    mapping(bytes32 => bytes) internal bytesStorage;\r\n    mapping(bytes32 => bool) internal boolStorage;\r\n    mapping(bytes32 => int256) internal intStorage;\r\n\r\n}\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title UpgradeabilityStorage\r\n * @dev This contract holds all the necessary state variables to support the upgrade functionality\r\n */\r\ncontract UpgradeabilityStorage {\r\n    // Version name of the current implementation\r\n    string internal _version;\r\n\r\n    // Address of the current implementation\r\n    address internal _implementation;\r\n\r\n    /**\r\n    * @dev Tells the version name of the current implementation\r\n    * @return string representing the name of the current version\r\n    */\r\n    function version() public view returns (string memory) {\r\n        return _version;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() public view returns (address) {\r\n        return _implementation;\r\n    }\r\n}\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title UpgradeabilityOwnerStorage\r\n * @dev This contract keeps track of the upgradeability owner\r\n */\r\ncontract UpgradeabilityOwnerStorage {\r\n    // Owner of the contract\r\n    address private _upgradeabilityOwner;\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function upgradeabilityOwner() public view returns (address) {\r\n        return _upgradeabilityOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the owner\r\n    */\r\n    function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {\r\n        _upgradeabilityOwner = newUpgradeabilityOwner;\r\n    }\r\n\r\n}\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title OwnedUpgradeabilityStorage\r\n * @dev This is the storage necessary to perform upgradeable contracts.\r\n * This means, required state variables for upgradeability purpose and eternal storage per se.\r\n */\r\ncontract OwnedUpgradeabilityStorage is UpgradeabilityOwnerStorage, UpgradeabilityStorage, EternalStorage {}\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev This contract has an owner address providing basic authorization control\r\n */\r\ncontract Ownable is EternalStorage {\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param previousOwner representing the address of the previous owner\r\n    * @param newOwner representing the address of the new owner\r\n    */\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner(), \"not an owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function owner() public view returns (address) {\r\n        return addressStorage[keccak256(\"owner\")];\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner the address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        setOwner(newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets a new owner address\r\n    */\r\n    function setOwner(address newOwner) internal {\r\n        emit OwnershipTransferred(owner(), newOwner);\r\n        addressStorage[keccak256(\"owner\")] = newOwner;\r\n    }\r\n}\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable is EternalStorage, Ownable {\r\n    function pendingOwner() public view returns (address) {\r\n        return addressStorage[keccak256(\"pendingOwner\")];\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier throws if called by any account other than the pendingOwner.\r\n    */\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to set the pendingOwner address.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        addressStorage[keccak256(\"pendingOwner\")] = newOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the pendingOwner address to finalize the transfer.\r\n    */\r\n    function claimOwnership() public onlyPendingOwner {\r\n        emit OwnershipTransferred(owner(), pendingOwner());\r\n        addressStorage[keccak256(\"owner\")] = addressStorage[keccak256(\"pendingOwner\")];\r\n        addressStorage[keccak256(\"pendingOwner\")] = address(0);\r\n    }\r\n}\r\n\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract Messages is EternalStorage {\r\n    struct Authorization {\r\n        address authorizedSigner;\r\n        uint256 expiration;\r\n    }\r\n    /**\r\n     * Domain separator encoding per EIP 712.\r\n     * keccak256(\r\n     *     \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\"\r\n     * )\r\n     */\r\n    bytes32 public constant EIP712_DOMAIN_TYPEHASH = 0xd87cd6ef79d4e2b95e15ce8abf732db51ec771f1ca2edccf22a46c729ac56472;\r\n\r\n    /**\r\n     * Validator struct type encoding per EIP 712\r\n     * keccak256(\r\n     *     \"Authorization(address authorizedSigner,uint256 expiration)\"\r\n     * )\r\n     */\r\n    bytes32 private constant AUTHORIZATION_TYPEHASH = 0xe419504a688f0e6ea59c2708f49b2bbc10a2da71770bd6e1b324e39c73e7dc25;\r\n\r\n\r\n    /**\r\n     * Domain separator per EIP 712\r\n     */\r\n    // bytes32 public DOMAIN_SEPARATOR;\r\n    function DOMAIN_SEPARATOR() public view returns(bytes32) {\r\n        bytes32 salt = 0xf2d857f4a3edcb9b78b4d503bfe733db1e3f6cdc2b7971ee739626c97e86a558;\r\n        return keccak256(abi.encode(\r\n                EIP712_DOMAIN_TYPEHASH,\r\n                keccak256(\"Multisender\"),\r\n                keccak256(\"2.0\"),\r\n                uintStorage[keccak256(\"chainId\")],\r\n                address(this),\r\n                salt\r\n            ));\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates authorizationHash according to EIP 712.\r\n     * @param _authorizedSigner address of trustee\r\n     * @param _expiration expiration date\r\n     * @return bytes32 EIP 712 hash of _authorization.\r\n     */\r\n    function hash(address _authorizedSigner, uint256 _expiration) public pure returns (bytes32) {\r\n        return keccak256(abi.encode(\r\n                AUTHORIZATION_TYPEHASH,\r\n                _authorizedSigner,\r\n                _expiration\r\n            ));\r\n    }\r\n\r\n    /**\r\n     * @return the recovered address from the signature\r\n     */\r\n    function recoverAddress(\r\n        bytes32 messageHash,\r\n        bytes memory signature\r\n    )\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        bytes1 v;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := mload(add(signature, 0x60))\r\n        }\r\n        bytes32 digest = keccak256(abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR(),\r\n                messageHash\r\n            ));\r\n        return ecrecover(digest, uint8(v), r, s);\r\n    }\r\n\r\n    function getApprover(uint256 timestamp, bytes memory signature) public view returns(address) {\r\n        if (timestamp < now) {\r\n            return address(0);\r\n        }\r\n        bytes32 messageHash = hash(msg.sender, timestamp);\r\n        return recoverAddress(messageHash, signature);\r\n    }\r\n\r\n\r\n}\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address who) public view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender)\r\n    public\r\n    view\r\n    returns (uint256);\r\n\r\n    function transferFrom(address from, address to, uint256 value)\r\n    public\r\n    returns (bool);\r\n\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n\r\ncontract UpgradebleStormSender is\r\nOwnedUpgradeabilityStorage,\r\nClaimable,\r\nMessages\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    event Multisended(uint256 total, address tokenAddress);\r\n    event ClaimedTokens(address token, address owner, uint256 balance);\r\n    event PurchaseVIP(address customer, uint256 tier);\r\n\r\n    modifier hasFee() {\r\n        uint256 contractFee = currentFee(msg.sender);\r\n        if (contractFee > 0) {\r\n            require(msg.value >= contractFee, \"no fee\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier validLists(uint256 _contributorsLength, uint256 _balancesLength) {\r\n        require(_contributorsLength > 0, \"no contributors sent\");\r\n        require(\r\n            _contributorsLength == _balancesLength,\r\n            \"different arrays lengths\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    function initialize(\r\n        address _owner,\r\n        uint256 _fee,\r\n        uint256 _vipPrice0,\r\n        uint256 _vipPrice1,\r\n        uint256 _vipPrice2,\r\n        uint256 _chainId\r\n    ) public {\r\n        require(!initialized() || msg.sender == owner());\r\n        setOwner(_owner);\r\n        setFee(_fee); // 0.05 ether fee\r\n        setVipPrice(0, _vipPrice0); // 1 eth\r\n        setVipPrice(1, _vipPrice1); // 5 eth\r\n        setVipPrice(2, _vipPrice2); // 10 eth\r\n        uintStorage[keccak256(\"chainId\")] = _chainId;\r\n        boolStorage[keccak256(\"rs_multisender_initialized\")] = true;\r\n        require(fee() >= 0.01 ether);\r\n        uintStorage[keccak256(\"referralFee\")] = 0.01 ether;\r\n    }\r\n\r\n    function initialized() public view returns (bool) {\r\n        return boolStorage[keccak256(\"rs_multisender_initialized\")];\r\n    }\r\n\r\n    function fee() public view returns (uint256) {\r\n        return uintStorage[keccak256(\"fee\")];\r\n    }\r\n\r\n    function currentFee(address _customer) public view returns (uint256) {\r\n        if (getUnlimAccess(_customer) >= block.timestamp) {\r\n            return 0;\r\n        }\r\n        return fee();\r\n    }\r\n\r\n    function setFee(uint256 _newStep) public onlyOwner {\r\n        require(_newStep != 0);\r\n        uintStorage[keccak256(\"fee\")] = _newStep;\r\n    }\r\n\r\n    function tokenFallback(address _from, uint256 _value, bytes memory _data)\r\n    public\r\n    {}\r\n\r\n    function _checkFee(address _user, address payable _referral) internal {\r\n        uint256 contractFee = currentFee(_user);\r\n        if (contractFee > 0) {\r\n            require(msg.value >= contractFee, \"no fee\");\r\n            if (_referral != address(0)) {\r\n                _referral.send(referralFee());\r\n            }\r\n        }\r\n    }\r\n\r\n    function multisendToken(\r\n        address _token,\r\n        address[] calldata _contributors,\r\n        uint256[] calldata _balances,\r\n        uint256 _total,\r\n        address payable _referral\r\n    ) external payable validLists(_contributors.length, _balances.length) {\r\n        bool isGoodToken;\r\n        bytes memory data;\r\n        _checkFee(msg.sender, _referral);\r\n        uint256 change = 0;\r\n        ERC20 erc20token = ERC20(_token);\r\n        // bytes4 transferFrom = 0x23b872dd;\r\n        (isGoodToken, data) = _token.call(\r\n            abi.encodeWithSelector(\r\n                0x23b872dd,\r\n                msg.sender,\r\n                address(this),\r\n                _total\r\n            )\r\n        );\r\n        require(isGoodToken, \"transferFrom failed\");\r\n        if (data.length > 0) {\r\n            bool success = abi.decode(data, (bool));\r\n            require(success, \"not enough allowed tokens\");\r\n        }\r\n        for (uint256 i = 0; i < _contributors.length; i++) {\r\n            (bool success, ) = _token.call(\r\n                abi.encodeWithSelector(\r\n                    erc20token.transfer.selector,\r\n                    _contributors[i],\r\n                    _balances[i]\r\n                )\r\n            );\r\n            if (!success) {\r\n                change += _balances[i];\r\n            }\r\n        }\r\n        if (change != 0) {\r\n            erc20token.transfer(msg.sender, change);\r\n        }\r\n        emit Multisended(_total, _token);\r\n    }\r\n\r\n    function findBadAddressesForBurners(\r\n        address _token,\r\n        address[] calldata _contributors,\r\n        uint256[] calldata _balances,\r\n        uint256 _total\r\n    )\r\n    external\r\n    payable\r\n    validLists(_contributors.length, _balances.length)\r\n    hasFee\r\n    returns (address[] memory badAddresses, uint256[] memory badBalances)\r\n    {\r\n        badAddresses = new address[](_contributors.length);\r\n        badBalances = new uint256[](_contributors.length);\r\n        ERC20 erc20token = ERC20(_token);\r\n        for (uint256 i = 0; i < _contributors.length; i++) {\r\n            (bool success, ) = _token.call(\r\n                abi.encodeWithSelector(\r\n                    erc20token.transferFrom.selector,\r\n                    msg.sender,\r\n                    _contributors[i],\r\n                    _balances[i]\r\n                )\r\n            );\r\n            if (!success) {\r\n                badAddresses[i] = _contributors[i];\r\n                badBalances[i] = _balances[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    function multisendTokenForBurners(\r\n        address _token,\r\n        address[] calldata _contributors,\r\n        uint256[] calldata _balances,\r\n        uint256 _total,\r\n        address payable _referral\r\n    ) external payable validLists(_contributors.length, _balances.length) {\r\n        _checkFee(msg.sender, _referral);\r\n        ERC20 erc20token = ERC20(_token);\r\n        for (uint256 i = 0; i < _contributors.length; i++) {\r\n            (bool success, ) = _token.call(\r\n                abi.encodeWithSelector(\r\n                    erc20token.transferFrom.selector,\r\n                    msg.sender,\r\n                    _contributors[i],\r\n                    _balances[i]\r\n                )\r\n            );\r\n        }\r\n        emit Multisended(_total, _token);\r\n    }\r\n\r\n    function multisendTokenForBurnersWithSignature(\r\n        address _token,\r\n        address[] calldata _contributors,\r\n        uint256[] calldata _balances,\r\n        uint256 _total,\r\n        address payable _referral,\r\n        bytes calldata _signature,\r\n        uint256 _timestamp\r\n    ) external payable {\r\n        address tokenHolder = getApprover(_timestamp, _signature);\r\n        require(\r\n            tokenHolder != address(0),\r\n            \"the signature is invalid or has expired\"\r\n        );\r\n        require(_contributors.length > 0, \"no contributors sent\");\r\n        require(\r\n            _contributors.length == _balances.length,\r\n            \"different arrays lengths\"\r\n        );\r\n        // require(msg.value >= currentFee(tokenHolder), \"no fee\");\r\n        _checkFee(tokenHolder, _referral);\r\n        ERC20 erc20token = ERC20(_token);\r\n        for (uint256 i = 0; i < _contributors.length; i++) {\r\n            (bool success, ) = _token.call(\r\n                abi.encodeWithSelector(\r\n                    erc20token.transferFrom.selector,\r\n                    tokenHolder,\r\n                    _contributors[i],\r\n                    _balances[i]\r\n                )\r\n            );\r\n        }\r\n        emit Multisended(_total, _token);\r\n    }\r\n\r\n    function multisendTokenWithSignature(\r\n        address _token,\r\n        address[] calldata _contributors,\r\n        uint256[] calldata _balances,\r\n        uint256 _total,\r\n        address payable _referral,\r\n        bytes calldata _signature,\r\n        uint256 _timestamp\r\n    ) external payable {\r\n        bool isGoodToken;\r\n        address tokenHolder = getApprover(_timestamp, _signature);\r\n        require(\r\n            tokenHolder != address(0),\r\n            \"the signature is invalid or has expired\"\r\n        );\r\n        require(_contributors.length > 0, \"no contributors sent\");\r\n        require(\r\n            _contributors.length == _balances.length,\r\n            \"different arrays lengths\"\r\n        );\r\n        _checkFee(tokenHolder, _referral);\r\n        uint256 change = 0;\r\n        (isGoodToken, ) = _token.call(\r\n            abi.encodeWithSelector(\r\n                0x23b872dd,\r\n                tokenHolder,\r\n                address(this),\r\n                _total\r\n            )\r\n        );\r\n        require(isGoodToken, \"not enough allowed tokens\");\r\n        for (uint256 i = 0; i < _contributors.length; i++) {\r\n            (bool success, ) = _token.call(\r\n                abi.encodeWithSelector(\r\n                // transfer\r\n                    0xa9059cbb,\r\n                    _contributors[i],\r\n                    _balances[i]\r\n                )\r\n            );\r\n            if (!success) {\r\n                change += _balances[i];\r\n            }\r\n        }\r\n        if (change != 0) {\r\n            _token.call(\r\n                abi.encodeWithSelector(\r\n                // transfer\r\n                    0xa9059cbb,\r\n                    tokenHolder,\r\n                    change\r\n                )\r\n            );\r\n        }\r\n        emit Multisended(_total, _token);\r\n    }\r\n\r\n    // DONT USE THIS METHOD, only for eth_call\r\n    function tokenFindBadAddresses(\r\n        address _token,\r\n        address[] calldata _contributors,\r\n        uint256[] calldata _balances,\r\n        uint256 _total\r\n    )\r\n    external\r\n    payable\r\n    validLists(_contributors.length, _balances.length)\r\n    hasFee\r\n    returns (address[] memory badAddresses, uint256[] memory badBalances)\r\n    {\r\n        badAddresses = new address[](_contributors.length);\r\n        badBalances = new uint256[](_contributors.length);\r\n        ERC20 erc20token = ERC20(_token);\r\n        bool isGoodToken;\r\n        (isGoodToken, ) = _token.call(\r\n            abi.encodeWithSelector(\r\n                0x23b872dd,\r\n                msg.sender,\r\n                address(this),\r\n                _total\r\n            )\r\n        );\r\n        // erc20token.transferFrom(msg.sender, address(this), _total);\r\n        for (uint256 i = 0; i < _contributors.length; i++) {\r\n            (bool success, ) = _token.call(\r\n                abi.encodeWithSelector(\r\n                    erc20token.transfer.selector,\r\n                    _contributors[i],\r\n                    _balances[i]\r\n                )\r\n            );\r\n            if (!success) {\r\n                badAddresses[i] = _contributors[i];\r\n                badBalances[i] = _balances[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    // DONT USE THIS METHOD, only for eth_call\r\n    function etherFindBadAddresses(\r\n        address payable[] calldata _contributors,\r\n        uint256[] calldata _balances\r\n    )\r\n    external\r\n    payable\r\n    validLists(_contributors.length, _balances.length)\r\n    returns (address[] memory badAddresses, uint256[] memory badBalances)\r\n    {\r\n        badAddresses = new address[](_contributors.length);\r\n        badBalances = new uint256[](_contributors.length);\r\n\r\n        uint256 _total = msg.value;\r\n        uint256 _contractFee = currentFee(msg.sender);\r\n        _total = _total.sub(_contractFee);\r\n\r\n        for (uint256 i = 0; i < _contributors.length; i++) {\r\n            bool _success = _contributors[i].send(_balances[i]);\r\n            if (!_success) {\r\n                badAddresses[i] = _contributors[i];\r\n                badBalances[i] = _balances[i];\r\n            } else {\r\n                _total = _total.sub(_balances[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function multisendEther(\r\n        address payable[] calldata _contributors,\r\n        uint256[] calldata _balances\r\n    ) external payable validLists(_contributors.length, _balances.length) {\r\n        uint256 _contractBalanceBefore = address(this).balance.sub(msg.value);\r\n        uint256 _total = msg.value;\r\n        uint256 _contractFee = currentFee(msg.sender);\r\n        _total = _total.sub(_contractFee);\r\n\r\n        for (uint256 i = 0; i < _contributors.length; i++) {\r\n            bool _success = _contributors[i].send(_balances[i]);\r\n            if (_success) {\r\n                _total = _total.sub(_balances[i]);\r\n            }\r\n        }\r\n\r\n        uint256 _contractBalanceAfter = address(this).balance;\r\n        // assert. Just for sure\r\n        require(\r\n            _contractBalanceAfter >= _contractBalanceBefore.add(_contractFee),\r\n            \"don’t try to take the contract money\"\r\n        );\r\n\r\n        emit Multisended(_total, 0x000000000000000000000000000000000000bEEF);\r\n    }\r\n\r\n    function setVipPrice(uint256 _tier, uint256 _price) public onlyOwner {\r\n        uintStorage[keccak256(abi.encodePacked(\"vip\", _tier))] = _price;\r\n    }\r\n\r\n    function setAddressToVip(address _address, uint256 _tier)\r\n    external\r\n    onlyOwner\r\n    {\r\n        setUnlimAccess(_address, _tier);\r\n        emit PurchaseVIP(msg.sender, _tier);\r\n    }\r\n\r\n    function buyVip(uint256 _tier) external payable {\r\n        require(\r\n            msg.value >= uintStorage[keccak256(abi.encodePacked(\"vip\", _tier))]\r\n        );\r\n        setUnlimAccess(msg.sender, _tier);\r\n        emit PurchaseVIP(msg.sender, _tier);\r\n    }\r\n\r\n    function setReferralFee(uint256 _newFee) external onlyOwner {\r\n        require(fee() >= _newFee);\r\n        uintStorage[keccak256(\"referralFee\")] = _newFee;\r\n    }\r\n\r\n    function referralFee() public view returns (uint256) {\r\n        return uintStorage[keccak256(\"referralFee\")];\r\n    }\r\n\r\n    function getVipPrice(uint256 _tier) public view returns (uint256) {\r\n        return uintStorage[keccak256(abi.encodePacked(\"vip\", _tier))];\r\n    }\r\n\r\n    function getAllVipPrices()\r\n    external\r\n    view\r\n    returns (uint256 tier0, uint256 tier1, uint256 tier2)\r\n    {\r\n        return (\r\n        uintStorage[keccak256(abi.encodePacked(\"vip\", uint256(0)))],\r\n        uintStorage[keccak256(abi.encodePacked(\"vip\", uint256(1)))],\r\n        uintStorage[keccak256(abi.encodePacked(\"vip\", uint256(2)))]\r\n        );\r\n    }\r\n\r\n    function claimTokens(address _token, uint256 _amount) external onlyOwner {\r\n        address payable ownerPayable = address(uint160(owner()));\r\n        uint256 amount = _amount;\r\n        if (_amount == 0) {\r\n            amount = address(this).balance;\r\n        }\r\n        if (_token == address(0)) {\r\n            ownerPayable.transfer(amount);\r\n            return;\r\n        }\r\n        ERC20 erc20token = ERC20(_token);\r\n        amount = erc20token.balanceOf(address(this));\r\n        erc20token.transfer(ownerPayable, amount);\r\n        emit ClaimedTokens(_token, ownerPayable, amount);\r\n    }\r\n\r\n    function getDeadline(uint256 _tier) public view returns (uint256) {\r\n        // 1 day\r\n        if (_tier == 0) {\r\n            return block.timestamp + 1 days;\r\n        }\r\n        // 7 days\r\n        if (_tier == 1) {\r\n            return block.timestamp + 7 days;\r\n        }\r\n        // Lifetime\r\n        if (_tier == 2) {\r\n            return block.timestamp + 30 days;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getUnlimAccess(address customer) public view returns (uint256) {\r\n        return\r\n        uintStorage[keccak256(abi.encodePacked(\"unlimAccess\", customer))];\r\n    }\r\n\r\n    function setUnlimAccess(address customer, uint256 _tier) private {\r\n        uintStorage[keccak256(\r\n            abi.encodePacked(\"unlimAccess\", customer)\r\n        )] = getDeadline(_tier);\r\n    }\r\n\r\n    function exploreETHBalances(address[] calldata targets)\r\n    external\r\n    view\r\n    returns (uint256[] memory balances)\r\n    {\r\n        balances = new uint256[](targets.length);\r\n        for (uint256 i = 0; i < targets.length; i++) {\r\n            balances[i] = targets[i].balance;\r\n        }\r\n    }\r\n\r\n    function exploreERC20Balances(ERC20 token, address[] calldata targets)\r\n    external\r\n    view\r\n    returns (uint256[] memory balances)\r\n    {\r\n        balances = new uint256[](targets.length);\r\n        for (uint256 i = 0; i < targets.length; i++) {\r\n            balances[i] = token.balanceOf(targets[i]);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_contributors\",\"type\":\"address[]\"},{\"name\":\"_balances\",\"type\":\"uint256[]\"},{\"name\":\"_total\",\"type\":\"uint256\"}],\"name\":\"findBadAddressesForBurners\",\"outputs\":[{\"name\":\"badAddresses\",\"type\":\"address[]\"},{\"name\":\"badBalances\",\"type\":\"uint256[]\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tier\",\"type\":\"uint256\"}],\"name\":\"getVipPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"getApprover\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_vipPrice0\",\"type\":\"uint256\"},{\"name\":\"_vipPrice1\",\"type\":\"uint256\"},{\"name\":\"_vipPrice2\",\"type\":\"uint256\"},{\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_contributors\",\"type\":\"address[]\"},{\"name\":\"_balances\",\"type\":\"uint256[]\"},{\"name\":\"_total\",\"type\":\"uint256\"},{\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"multisendToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"customer\",\"type\":\"address\"}],\"name\":\"getUnlimAccess\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_authorizedSigner\",\"type\":\"address\"},{\"name\":\"_expiration\",\"type\":\"uint256\"}],\"name\":\"hash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customer\",\"type\":\"address\"}],\"name\":\"currentFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_tier\",\"type\":\"uint256\"}],\"name\":\"setAddressToVip\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newStep\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tier\",\"type\":\"uint256\"}],\"name\":\"buyVip\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_contributors\",\"type\":\"address[]\"},{\"name\":\"_balances\",\"type\":\"uint256[]\"},{\"name\":\"_total\",\"type\":\"uint256\"},{\"name\":\"_referral\",\"type\":\"address\"},{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"multisendTokenWithSignature\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeabilityOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"setReferralFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"targets\",\"type\":\"address[]\"}],\"name\":\"exploreERC20Balances\",\"outputs\":[{\"name\":\"balances\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributors\",\"type\":\"address[]\"},{\"name\":\"_balances\",\"type\":\"uint256[]\"}],\"name\":\"etherFindBadAddresses\",\"outputs\":[{\"name\":\"badAddresses\",\"type\":\"address[]\"},{\"name\":\"badBalances\",\"type\":\"uint256[]\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tier\",\"type\":\"uint256\"}],\"name\":\"getDeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"targets\",\"type\":\"address[]\"}],\"name\":\"exploreETHBalances\",\"outputs\":[{\"name\":\"balances\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referralFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_contributors\",\"type\":\"address[]\"},{\"name\":\"_balances\",\"type\":\"uint256[]\"},{\"name\":\"_total\",\"type\":\"uint256\"},{\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"multisendTokenForBurners\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_contributors\",\"type\":\"address[]\"},{\"name\":\"_balances\",\"type\":\"uint256[]\"},{\"name\":\"_total\",\"type\":\"uint256\"},{\"name\":\"_referral\",\"type\":\"address\"},{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"multisendTokenForBurnersWithSignature\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributors\",\"type\":\"address[]\"},{\"name\":\"_balances\",\"type\":\"uint256[]\"}],\"name\":\"multisendEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_contributors\",\"type\":\"address[]\"},{\"name\":\"_balances\",\"type\":\"uint256[]\"},{\"name\":\"_total\",\"type\":\"uint256\"}],\"name\":\"tokenFindBadAddresses\",\"outputs\":[{\"name\":\"badAddresses\",\"type\":\"address[]\"},{\"name\":\"badBalances\",\"type\":\"uint256[]\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tier\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setVipPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"messageHash\",\"type\":\"bytes32\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"recoverAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EIP712_DOMAIN_TYPEHASH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllVipPrices\",\"outputs\":[{\"name\":\"tier0\",\"type\":\"uint256\"},{\"name\":\"tier1\",\"type\":\"uint256\"},{\"name\":\"tier2\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"Multisended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"customer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tier\",\"type\":\"uint256\"}],\"name\":\"PurchaseVIP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"UpgradebleStormSender","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c61059fd6a9318eafcda6850dacfa174bf93fa224f6854507e47c54115629282"}]}