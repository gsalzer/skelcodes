{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/logic/AssetBond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport '../libraries/DataStruct.sol';\\nimport '../libraries/Math.sol';\\nimport '../libraries/WadRayMath.sol';\\nimport '../libraries/TimeConverter.sol';\\n\\nlibrary AssetBond {\\n  using WadRayMath for uint256;\\n  using AssetBond for DataStruct.AssetBondData;\\n\\n  uint256 constant NONCE = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC00;\\n  uint256 constant COUNTRY_CODE =\\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC003FF;\\n  uint256 constant COLLATERAL_SERVICE_PROVIDER_IDENTIFICATION_NUMBER =\\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000003FFFFF;\\n  uint256 constant COLLATERAL_LATITUDE =\\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000FFFFFFFFFFFFFFFFFF;\\n  uint256 constant COLLATERAL_LATITUDE_SIGNS =\\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  uint256 constant COLLATERAL_LONGITUDE =\\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0000001FFFFFFFFFFFFFFFFFFFFFFFFF;\\n  uint256 constant COLLATERAL_LONGITUDE_SIGNS =\\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  uint256 constant COLLATERAL_DETAILS =\\n    0xFFFFFFFFFFFFFFFFFFFFFC0000000003FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  uint256 constant COLLATERAL_CATEGORY =\\n    0xFFFFFFFFFFFFFFFFFFF003FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  uint256 constant PRODUCT_NUMBER =\\n    0xFFFFFFFFFFFFFFFFC00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n  uint256 constant NONCE_START = 0;\\n  uint256 constant COUNTRY_CODE_START = 10;\\n  uint256 constant COLLATERAL_SERVICE_PROVIDER_IDENTIFICATION_NUMBER_START = 22;\\n  uint256 constant COLLATERAL_LATITUDE_START = 72;\\n  uint256 constant COLLATERAL_LATITUDE_SIGNS_START = 100;\\n  uint256 constant COLLATERAL_LONGITUDE_START = 101;\\n  uint256 constant COLLATERAL_LONGITUDE_SIGNS_START = 129;\\n  uint256 constant COLLATERAL_DETAILS_START = 130;\\n  uint256 constant COLLATERAL_CATEGORY_START = 170;\\n  uint256 constant PRODUCT_NUMBER_START = 180;\\n\\n  function parseAssetBondId(uint256 tokenId)\\n    public\\n    pure\\n    returns (DataStruct.AssetBondIdData memory)\\n  {\\n    DataStruct.AssetBondIdData memory vars;\\n    vars.nonce = tokenId & ~NONCE;\\n    vars.countryCode = (tokenId & ~COUNTRY_CODE) >> COUNTRY_CODE_START;\\n    vars.collateralServiceProviderIdentificationNumber =\\n      (tokenId & ~COLLATERAL_SERVICE_PROVIDER_IDENTIFICATION_NUMBER) >>\\n      COLLATERAL_SERVICE_PROVIDER_IDENTIFICATION_NUMBER_START;\\n    vars.collateralLatitude = (tokenId & ~COLLATERAL_LATITUDE) >> COLLATERAL_LATITUDE_START;\\n    vars.collateralLatitudeSign =\\n      (tokenId & ~COLLATERAL_LATITUDE_SIGNS) >>\\n      COLLATERAL_LATITUDE_SIGNS_START;\\n    vars.collateralLongitude = (tokenId & ~COLLATERAL_LONGITUDE) >> COLLATERAL_LONGITUDE_START;\\n    vars.collateralLongitudeSign =\\n      (tokenId & ~COLLATERAL_LONGITUDE_SIGNS) >>\\n      COLLATERAL_LONGITUDE_SIGNS_START;\\n    vars.collateralDetail = (tokenId & ~COLLATERAL_DETAILS) >> COLLATERAL_DETAILS_START;\\n    vars.collateralCategory = (tokenId & ~COLLATERAL_CATEGORY) >> COLLATERAL_CATEGORY_START;\\n    vars.productNumber = (tokenId & ~PRODUCT_NUMBER) >> PRODUCT_NUMBER_START;\\n\\n    return vars;\\n  }\\n\\n  function getAssetBondDebtData(DataStruct.AssetBondData memory assetBondData)\\n    public\\n    view\\n    returns (uint256, uint256)\\n  {\\n    if (assetBondData.state != DataStruct.AssetBondState.COLLATERALIZED) {\\n      return (0, 0);\\n    }\\n\\n    uint256 accruedDebtOnMoneyPool = Math\\n    .calculateCompoundedInterest(\\n      assetBondData.interestRate,\\n      assetBondData.collateralizeTimestamp,\\n      block.timestamp\\n    ).rayMul(assetBondData.principal);\\n\\n    uint256 feeOnCollateralServiceProvider = calculateFeeOnRepayment(\\n      assetBondData,\\n      block.timestamp\\n    );\\n\\n    return (accruedDebtOnMoneyPool, feeOnCollateralServiceProvider);\\n  }\\n\\n  struct CalculateFeeOnRepaymentLocalVars {\\n    TimeConverter.DateTime paymentDateTimeStruct;\\n    uint256 paymentDate;\\n    uint256 firstTermRate;\\n    uint256 secondTermRate;\\n    uint256 secondTermOverdueRate;\\n    uint256 thirdTermRate;\\n    uint256 totalRate;\\n  }\\n\\n  function calculateFeeOnRepayment(\\n    DataStruct.AssetBondData memory assetBondData,\\n    uint256 paymentTimestamp\\n  ) internal pure returns (uint256) {\\n    CalculateFeeOnRepaymentLocalVars memory vars;\\n\\n    vars.firstTermRate = Math.calculateCompoundedInterest(\\n      assetBondData.couponRate,\\n      assetBondData.loanStartTimestamp,\\n      assetBondData.collateralizeTimestamp\\n    );\\n\\n    vars.paymentDateTimeStruct = TimeConverter.parseTimestamp(paymentTimestamp);\\n    vars.paymentDate = TimeConverter.toTimestamp(\\n      vars.paymentDateTimeStruct.year,\\n      vars.paymentDateTimeStruct.month,\\n      vars.paymentDateTimeStruct.day + 1\\n    );\\n\\n    if (paymentTimestamp <= assetBondData.liquidationTimestamp) {\\n      vars.secondTermRate =\\n        Math.calculateCompoundedInterest(\\n          assetBondData.couponRate - assetBondData.interestRate,\\n          assetBondData.collateralizeTimestamp,\\n          paymentTimestamp\\n        ) -\\n        WadRayMath.ray();\\n      vars.thirdTermRate =\\n        Math.calculateCompoundedInterest(\\n          assetBondData.couponRate,\\n          paymentTimestamp,\\n          vars.paymentDate\\n        ) -\\n        WadRayMath.ray();\\n\\n      vars.totalRate = vars.firstTermRate + vars.secondTermRate + vars.thirdTermRate;\\n\\n      return assetBondData.principal.rayMul(vars.totalRate) - assetBondData.principal;\\n    }\\n\\n    vars.secondTermRate =\\n      Math.calculateCompoundedInterest(\\n        assetBondData.couponRate - assetBondData.interestRate,\\n        assetBondData.collateralizeTimestamp,\\n        assetBondData.maturityTimestamp\\n      ) -\\n      WadRayMath.ray();\\n    vars.secondTermOverdueRate =\\n      Math.calculateCompoundedInterest(\\n        assetBondData.couponRate + assetBondData.delinquencyRate - assetBondData.interestRate,\\n        assetBondData.maturityTimestamp,\\n        paymentTimestamp\\n      ) -\\n      WadRayMath.ray();\\n    vars.thirdTermRate =\\n      Math.calculateCompoundedInterest(\\n        assetBondData.couponRate + assetBondData.delinquencyRate,\\n        paymentTimestamp,\\n        vars.paymentDate\\n      ) -\\n      WadRayMath.ray();\\n\\n    vars.totalRate =\\n      vars.firstTermRate +\\n      vars.secondTermRate +\\n      vars.secondTermOverdueRate +\\n      vars.thirdTermRate;\\n\\n    return assetBondData.principal.rayMul(vars.totalRate) - assetBondData.principal;\\n  }\\n\\n  function getAssetBondLiquidationData(DataStruct.AssetBondData memory assetBondData)\\n    internal\\n    view\\n    returns (uint256, uint256)\\n  {\\n    uint256 accruedDebtOnMoneyPool = Math\\n    .calculateCompoundedInterest(\\n      assetBondData.interestRate,\\n      assetBondData.collateralizeTimestamp,\\n      block.timestamp\\n    ).rayMul(assetBondData.principal);\\n\\n    uint256 feeOnCollateralServiceProvider = calculateDebtAmountToLiquidation(\\n      assetBondData,\\n      block.timestamp\\n    );\\n\\n    return (accruedDebtOnMoneyPool, feeOnCollateralServiceProvider);\\n  }\\n\\n  struct CalculateDebtAmountToLiquidationLocalVars {\\n    TimeConverter.DateTime paymentDateTimeStruct;\\n    uint256 paymentDate;\\n    uint256 firstTermRate;\\n    uint256 secondTermRate;\\n    uint256 totalRate;\\n  }\\n\\n  function calculateDebtAmountToLiquidation(\\n    DataStruct.AssetBondData memory assetBondData,\\n    uint256 paymentTimestamp\\n  ) internal pure returns (uint256) {\\n    CalculateDebtAmountToLiquidationLocalVars memory vars;\\n    vars.firstTermRate = Math.calculateCompoundedInterest(\\n      assetBondData.couponRate,\\n      assetBondData.loanStartTimestamp,\\n      assetBondData.maturityTimestamp\\n    );\\n\\n    vars.paymentDateTimeStruct = TimeConverter.parseTimestamp(paymentTimestamp);\\n    vars.paymentDate = TimeConverter.toTimestamp(\\n      vars.paymentDateTimeStruct.year,\\n      vars.paymentDateTimeStruct.month,\\n      vars.paymentDateTimeStruct.day + 1\\n    );\\n\\n    vars.secondTermRate =\\n      Math.calculateCompoundedInterest(\\n        assetBondData.couponRate + assetBondData.delinquencyRate,\\n        assetBondData.maturityTimestamp,\\n        vars.paymentDate\\n      ) -\\n      WadRayMath.ray();\\n    vars.totalRate = vars.firstTermRate + vars.secondTermRate;\\n\\n    return assetBondData.principal.rayMul(vars.totalRate) - assetBondData.principal;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DataStruct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nlibrary DataStruct {\\n  /**\\n    @notice The main reserve data struct.\\n   */\\n  struct ReserveData {\\n    uint256 moneyPoolFactor;\\n    uint256 lTokenInterestIndex;\\n    uint256 borrowAPY;\\n    uint256 depositAPY;\\n    uint256 lastUpdateTimestamp;\\n    address lTokenAddress;\\n    address dTokenAddress;\\n    address interestModelAddress;\\n    address tokenizerAddress;\\n    uint8 id;\\n    bool isPaused;\\n    bool isActivated;\\n  }\\n\\n  /**\\n   * @notice The asset bond data struct.\\n   * @param ipfsHash The IPFS hash that contains the informations and contracts\\n   * between Collateral Service Provider and lender.\\n   * @param maturityTimestamp The amount of time measured in seconds that can elapse\\n   * before the NPL company liquidate the loan and seize the asset bond collateral.\\n   * @param borrower The address of the borrower.\\n   */\\n  struct AssetBondData {\\n    AssetBondState state;\\n    address borrower;\\n    address signer;\\n    address collateralServiceProvider;\\n    uint256 principal;\\n    uint256 debtCeiling;\\n    uint256 couponRate;\\n    uint256 interestRate;\\n    uint256 delinquencyRate;\\n    uint256 loanStartTimestamp;\\n    uint256 collateralizeTimestamp;\\n    uint256 maturityTimestamp;\\n    uint256 liquidationTimestamp;\\n    string ipfsHash; // refactor : gas\\n    string signerOpinionHash;\\n  }\\n\\n  struct AssetBondIdData {\\n    uint256 nonce;\\n    uint256 countryCode;\\n    uint256 collateralServiceProviderIdentificationNumber;\\n    uint256 collateralLatitude;\\n    uint256 collateralLatitudeSign;\\n    uint256 collateralLongitude;\\n    uint256 collateralLongitudeSign;\\n    uint256 collateralDetail;\\n    uint256 collateralCategory;\\n    uint256 productNumber;\\n  }\\n\\n  /**\\n    @notice The states of asset bond\\n    * EMPTY: After\\n    * SETTLED:\\n    * CONFIRMED:\\n    * COLLATERALIZED:\\n    * DELINQUENT:\\n    * REDEEMED:\\n    * LIQUIDATED:\\n   */\\n  enum AssetBondState {\\n    EMPTY,\\n    SETTLED,\\n    CONFIRMED,\\n    COLLATERALIZED,\\n    DELINQUENT,\\n    REDEEMED,\\n    LIQUIDATED\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport './WadRayMath.sol';\\n\\nlibrary Math {\\n  using WadRayMath for uint256;\\n\\n  uint256 internal constant SECONDSPERYEAR = 365 days;\\n\\n  function calculateLinearInterest(\\n    uint256 rate,\\n    uint256 lastUpdateTimestamp,\\n    uint256 currentTimestamp\\n  ) internal pure returns (uint256) {\\n    uint256 timeDelta = currentTimestamp - uint256(lastUpdateTimestamp);\\n\\n    return ((rate * timeDelta) / SECONDSPERYEAR) + WadRayMath.ray();\\n  }\\n\\n  /**\\n   * @notice Author : AAVE\\n   * @dev Function to calculate the interest using a compounded interest rate formula\\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\\n   *\\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\\n   * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\\n   *\\n   * @param rate The interest rate, in ray\\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\\n   * @return The interest rate compounded during the timeDelta, in ray\\n   **/\\n  function calculateCompoundedInterest(\\n    uint256 rate,\\n    uint256 lastUpdateTimestamp,\\n    uint256 currentTimestamp\\n  ) internal pure returns (uint256) {\\n    //solium-disable-next-line\\n    uint256 exp = currentTimestamp - lastUpdateTimestamp;\\n\\n    if (exp == 0) {\\n      return WadRayMath.ray();\\n    }\\n\\n    uint256 expMinusOne = exp - 1;\\n\\n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\\n\\n    // loss of precision is endurable\\n    // slither-disable-next-line divide-before-multiply\\n    uint256 ratePerSecond = rate / SECONDSPERYEAR;\\n\\n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\\n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\\n\\n    uint256 secondTerm = (exp * expMinusOne * basePowerTwo) / 2;\\n    uint256 thirdTerm = (exp * expMinusOne * expMinusTwo * basePowerThree) / 6;\\n\\n    return WadRayMath.ray() + (ratePerSecond * exp) + secondTerm + thirdTerm;\\n  }\\n\\n  function calculateRateInIncreasingBalance(\\n    uint256 averageRate,\\n    uint256 totalBalance,\\n    uint256 amountIn,\\n    uint256 rate\\n  ) internal pure returns (uint256, uint256) {\\n    uint256 weightedAverageRate = totalBalance.wadToRay().rayMul(averageRate);\\n    uint256 weightedAmountRate = amountIn.wadToRay().rayMul(rate);\\n\\n    uint256 newTotalBalance = totalBalance + amountIn;\\n    uint256 newAverageRate = (weightedAverageRate + weightedAmountRate).rayDiv(\\n      newTotalBalance.wadToRay()\\n    );\\n\\n    return (newTotalBalance, newAverageRate);\\n  }\\n\\n  function calculateRateInDecreasingBalance(\\n    uint256 averageRate,\\n    uint256 totalBalance,\\n    uint256 amountOut,\\n    uint256 rate\\n  ) internal pure returns (uint256, uint256) {\\n    // if decreasing amount exceeds totalBalance,\\n    // overall rate and balacne would be set 0\\n    if (totalBalance <= amountOut) {\\n      return (0, 0);\\n    }\\n\\n    uint256 weightedAverageRate = totalBalance.wadToRay().rayMul(averageRate);\\n    uint256 weightedAmountRate = amountOut.wadToRay().rayMul(rate);\\n\\n    if (weightedAverageRate <= weightedAmountRate) {\\n      return (0, 0);\\n    }\\n\\n    uint256 newTotalBalance = totalBalance - amountOut;\\n\\n    uint256 newAverageRate = (weightedAverageRate - weightedAmountRate).rayDiv(\\n      newTotalBalance.wadToRay()\\n    );\\n\\n    return (newTotalBalance, newAverageRate);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/WadRayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n **/\\n\\nlibrary WadRayMath {\\n  uint256 internal constant WAD = 1e18;\\n  uint256 internal constant halfWAD = WAD / 2;\\n\\n  uint256 internal constant RAY = 1e27;\\n  uint256 internal constant halfRAY = RAY / 2;\\n\\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n  /**\\n   * @return One ray, 1e27\\n   **/\\n  function ray() internal pure returns (uint256) {\\n    return RAY;\\n  }\\n\\n  /**\\n   * @return One wad, 1e18\\n   **/\\n\\n  function wad() internal pure returns (uint256) {\\n    return WAD;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e27/2\\n   **/\\n  function halfRay() internal pure returns (uint256) {\\n    return halfRAY;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e18/2\\n   **/\\n  function halfWad() internal pure returns (uint256) {\\n    return halfWAD;\\n  }\\n\\n  /**\\n   * @dev Multiplies two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a*b, in wad\\n   **/\\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    return (a * b + halfWAD) / WAD;\\n  }\\n\\n  /**\\n   * @dev Divides two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a/b, in wad\\n   **/\\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'Division by Zero');\\n    uint256 halfB = b / 2;\\n    return (a * WAD + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Multiplies two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a*b, in ray\\n   **/\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    return (a * b + halfRAY) / RAY;\\n  }\\n\\n  /**\\n   * @dev Divides two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a/b, in ray\\n   **/\\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'Division by Zero');\\n    uint256 halfB = b / 2;\\n    return (a * RAY + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Casts ray down to wad\\n   * @param a Ray\\n   * @return a casted to wad, rounded half up to the nearest wad\\n   **/\\n  function rayToWad(uint256 a) internal pure returns (uint256) {\\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\\n    uint256 result = halfRatio + a;\\n    return result / WAD_RAY_RATIO;\\n  }\\n\\n  /**\\n   * @dev Converts wad up to ray\\n   * @param a Wad\\n   * @return a converted in ray\\n   **/\\n  function wadToRay(uint256 a) internal pure returns (uint256) {\\n    uint256 result = a * WAD_RAY_RATIO;\\n    return result;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TimeConverter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\n/**\\n * @title Ethereum timestamp conversion library\\n * @author ethereum-datatime\\n */\\nlibrary TimeConverter {\\n  struct DateTime {\\n    uint16 year;\\n    uint8 month;\\n    uint8 day;\\n    uint8 hour;\\n    uint8 minute;\\n    uint8 second;\\n    uint8 weekday;\\n  }\\n\\n  uint256 constant DAY_IN_SECONDS = 86400;\\n  uint256 constant YEAR_IN_SECONDS = 31536000;\\n  uint256 constant LEAP_YEAR_IN_SECONDS = 31622400;\\n\\n  uint256 constant HOUR_IN_SECONDS = 3600;\\n  uint256 constant MINUTE_IN_SECONDS = 60;\\n\\n  uint16 constant ORIGIN_YEAR = 1970;\\n\\n  function isLeapYear(uint16 year) internal pure returns (bool) {\\n    if (year % 4 != 0) {\\n      return false;\\n    }\\n    if (year % 100 != 0) {\\n      return true;\\n    }\\n    if (year % 400 != 0) {\\n      return false;\\n    }\\n    return true;\\n  }\\n\\n  function leapYearsBefore(uint256 year) internal pure returns (uint256) {\\n    year -= 1;\\n    return year / 4 - year / 100 + year / 400;\\n  }\\n\\n  function getDaysInMonth(uint8 month, uint16 year) internal pure returns (uint8) {\\n    if (\\n      month == 1 ||\\n      month == 3 ||\\n      month == 5 ||\\n      month == 7 ||\\n      month == 8 ||\\n      month == 10 ||\\n      month == 12\\n    ) {\\n      return 31;\\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\\n      return 30;\\n    } else if (isLeapYear(year)) {\\n      return 29;\\n    } else {\\n      return 28;\\n    }\\n  }\\n\\n  function parseTimestamp(uint256 timestamp) public pure returns (DateTime memory dateTime) {\\n    uint256 secondsAccountedFor = 0;\\n    uint256 buf;\\n    uint8 i;\\n\\n    // Year\\n    dateTime.year = getYear(timestamp);\\n    buf = leapYearsBefore(dateTime.year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n    secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\\n    secondsAccountedFor += YEAR_IN_SECONDS * (dateTime.year - ORIGIN_YEAR - buf);\\n\\n    // Month\\n    uint256 secondsInMonth;\\n    for (i = 1; i <= 12; i++) {\\n      secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dateTime.year);\\n      if (secondsInMonth + secondsAccountedFor > timestamp) {\\n        dateTime.month = i;\\n        break;\\n      }\\n      secondsAccountedFor += secondsInMonth;\\n    }\\n\\n    // Day\\n    for (i = 1; i <= getDaysInMonth(dateTime.month, dateTime.year); i++) {\\n      if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\\n        dateTime.day = i;\\n        break;\\n      }\\n      secondsAccountedFor += DAY_IN_SECONDS;\\n    }\\n\\n    // Hour\\n    dateTime.hour = getHour(timestamp);\\n    // Minute\\n    dateTime.minute = getMinute(timestamp);\\n    // Second\\n    dateTime.second = getSecond(timestamp);\\n    // Day of week.\\n    dateTime.weekday = getWeekday(timestamp);\\n  }\\n\\n  function getYear(uint256 timestamp) internal pure returns (uint16) {\\n    uint256 secondsAccountedFor = 0;\\n    uint16 year;\\n    uint256 numLeapYears;\\n\\n    // Year\\n    year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\\n    numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n    secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\\n    secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\\n\\n    while (secondsAccountedFor > timestamp) {\\n      if (isLeapYear(uint16(year - 1))) {\\n        secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\\n      } else {\\n        secondsAccountedFor -= YEAR_IN_SECONDS;\\n      }\\n      year -= 1;\\n    }\\n    return year;\\n  }\\n\\n  function getMonth(uint256 timestamp) internal pure returns (uint8) {\\n    return parseTimestamp(timestamp).month;\\n  }\\n\\n  function getDay(uint256 timestamp) internal pure returns (uint8) {\\n    return parseTimestamp(timestamp).day;\\n  }\\n\\n  function getHour(uint256 timestamp) internal pure returns (uint8) {\\n    return uint8((timestamp / 60 / 60) % 24);\\n  }\\n\\n  function getMinute(uint256 timestamp) internal pure returns (uint8) {\\n    return uint8((timestamp / 60) % 60);\\n  }\\n\\n  function getSecond(uint256 timestamp) internal pure returns (uint8) {\\n    return uint8(timestamp % 60);\\n  }\\n\\n  function getWeekday(uint256 timestamp) internal pure returns (uint8) {\\n    return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\\n  }\\n\\n  function toTimestamp(\\n    uint16 year,\\n    uint8 month,\\n    uint8 day\\n  ) public pure returns (uint256 timestamp) {\\n    return toTimestamp(year, month, day, 0, 0, 0);\\n  }\\n\\n  function toTimestamp(\\n    uint16 year,\\n    uint8 month,\\n    uint8 day,\\n    uint8 hour\\n  ) public pure returns (uint256 timestamp) {\\n    return toTimestamp(year, month, day, hour, 0, 0);\\n  }\\n\\n  function toTimestamp(\\n    uint16 year,\\n    uint8 month,\\n    uint8 day,\\n    uint8 hour,\\n    uint8 minute,\\n    uint8 second\\n  ) public pure returns (uint256 timestamp) {\\n    uint16 i;\\n\\n    // Year\\n    for (i = ORIGIN_YEAR; i < year; i++) {\\n      if (isLeapYear(i)) {\\n        timestamp += LEAP_YEAR_IN_SECONDS;\\n      } else {\\n        timestamp += YEAR_IN_SECONDS;\\n      }\\n    }\\n\\n    // Month\\n    uint8[12] memory monthDayCounts;\\n    monthDayCounts[0] = 31;\\n    if (isLeapYear(year)) {\\n      monthDayCounts[1] = 29;\\n    } else {\\n      monthDayCounts[1] = 28;\\n    }\\n    monthDayCounts[2] = 31;\\n    monthDayCounts[3] = 30;\\n    monthDayCounts[4] = 31;\\n    monthDayCounts[5] = 30;\\n    monthDayCounts[6] = 31;\\n    monthDayCounts[7] = 31;\\n    monthDayCounts[8] = 30;\\n    monthDayCounts[9] = 31;\\n    monthDayCounts[10] = 30;\\n    monthDayCounts[11] = 31;\\n\\n    for (i = 1; i < month; i++) {\\n      timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\\n    }\\n\\n    // Day\\n    timestamp += DAY_IN_SECONDS * (day - 1);\\n    // Hour\\n    timestamp += HOUR_IN_SECONDS * (hour);\\n    // Minute\\n    timestamp += MINUTE_IN_SECONDS * (minute);\\n    // Second\\n    timestamp += second;\\n\\n    return timestamp;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/TimeConverter.sol\": {\r\n        \"TimeConverter\": \"0x01d07c9fd2e3fbc493e0a2de588ce1c1ead137e4\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"enum DataStruct.AssetBondState\",\"name\":\"state\",\"type\":\"DataStruct.AssetBondState\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralServiceProvider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtCeiling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"couponRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delinquencyRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralizeTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"signerOpinionHash\",\"type\":\"string\"}],\"internalType\":\"struct DataStruct.AssetBondData\",\"name\":\"assetBondData\",\"type\":\"tuple\"}],\"name\":\"getAssetBondDebtData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"parseAssetBondId\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"countryCode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralServiceProviderIdentificationNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralLatitude\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralLatitudeSign\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralLongitude\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralLongitudeSign\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralDetail\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralCategory\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"productNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DataStruct.AssetBondIdData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"AssetBond","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}