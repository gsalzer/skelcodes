{"status":"1","message":"OK","result":[{"SourceCode":"# Copyright (C) 2021 VolumeFi Software, Inc.\r\n\r\n#  This program is free software: you can redistribute it and/or modify\r\n#  it under the terms of the Apache 2.0 License. \r\n#  This program is distributed WITHOUT ANY WARRANTY without even the implied warranty of\r\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n#  @author VolumeFi, Software inc.\r\n#  @notice This Vyper contract removes liquidity from any Uniswap V2 pool into ETH or any ERC20 Token.\r\n#  SPDX-License-Identifier: Apache-2.0\r\n\r\n# @version ^0.2.0\r\n\r\ninterface ERC20:\r\n    def approve(spender: address, amount: uint256): nonpayable\r\n    def transfer(recipient: address, amount: uint256): nonpayable\r\n    def transferFrom(sender: address, recipient: address, amount: uint256): nonpayable\r\n\r\ninterface UniswapV2Pair:\r\n    def token0() -> address: view\r\n    def token1() -> address: view\r\n    def getReserves() -> (uint256, uint256, uint256): view\r\n    def burn(to: address) -> (uint256, uint256): nonpayable\r\n\r\ninterface UniswapV2Factory:\r\n    def getPair(tokenA: address, tokenB: address) -> address: view\r\n\r\ninterface UniswapV2Router02:\r\n    def removeLiquidity(tokenA: address, tokenB: address, liquidity: uint256, amountAMin: uint256, amountBMin: uint256, to: address, deadline: uint256) -> (uint256, uint256): nonpayable\r\n\r\ninterface WrappedEth:\r\n    def withdraw(wad: uint256): nonpayable\r\n\r\nUNISWAPV2ROUTER02: constant(address) = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\nUNISWAPV2FACTORY: constant(address) = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\r\n\r\nVETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\nWETH: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\nDEADLINE: constant(uint256) = MAX_UINT256 # change\r\n\r\npaused: public(bool)\r\nadmin: public(address)\r\nfeeAmount: public(uint256)\r\nfeeAddress: public(address)\r\n\r\n@external\r\ndef __init__():\r\n    self.paused = False\r\n    self.admin = msg.sender\r\n    self.feeAddress = 0xf29399fB3311082d9F8e62b988cBA44a5a98ebeD\r\n    self.feeAmount = 5 * 10 ** 15\r\n\r\n@internal\r\ndef _token2Token(fromToken: address, toToken: address, tokens2Trade: uint256, to: address, deadline: uint256) -> uint256:\r\n    if fromToken == toToken:\r\n        return tokens2Trade\r\n    ERC20(fromToken).approve(UNISWAPV2ROUTER02, 0)\r\n    ERC20(fromToken).approve(UNISWAPV2ROUTER02, tokens2Trade)\r\n    \r\n    addrBytes: Bytes[288] = concat(convert(tokens2Trade, bytes32), convert(0, bytes32), convert(160, bytes32), convert(to, bytes32), convert(deadline, bytes32), convert(2, bytes32), convert(fromToken, bytes32), convert(toToken, bytes32))\r\n    funcsig: Bytes[4] = method_id(\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\")\r\n    full_data: Bytes[292] = concat(funcsig, addrBytes)\r\n    \r\n    _response: Bytes[128] = raw_call(\r\n        UNISWAPV2ROUTER02,\r\n        full_data,\r\n        max_outsize=128\r\n    )\r\n    tokenBought: uint256 = convert(slice(_response, 96, 32), uint256)\r\n    assert tokenBought > 0, \"Error Swapping Token 2\"\r\n    return tokenBought\r\n\r\n@internal\r\n@pure\r\ndef _getPairTokens(pair: address) -> (address, address):\r\n    token0: address = UniswapV2Pair(pair).token0()\r\n    token1: address = UniswapV2Pair(pair).token1()\r\n    return (token0, token1)\r\n\r\n@internal\r\n@view\r\ndef _getLiquidityInPool(midToken: address, pair: address) -> uint256:\r\n    res0: uint256 = 0\r\n    res1: uint256 = 0\r\n    token0: address = ZERO_ADDRESS\r\n    token1: address = ZERO_ADDRESS\r\n    blockTimestampLast: uint256 = 0\r\n    (res0, res1, blockTimestampLast) = UniswapV2Pair(pair).getReserves()\r\n    (token0, token1) = self._getPairTokens(pair)\r\n    if token0 == midToken:\r\n        return res0\r\n    else:\r\n        return res1\r\n\r\n@internal\r\n@view\r\ndef _getMidToken(midToken: address, token0: address, token1: address) -> address:\r\n    pair0: address = UniswapV2Factory(UNISWAPV2FACTORY).getPair(midToken, token0)\r\n    pair1: address = UniswapV2Factory(UNISWAPV2FACTORY).getPair(midToken, token1)\r\n    eth0: uint256 = self._getLiquidityInPool(midToken, pair0)\r\n    eth1: uint256 = self._getLiquidityInPool(midToken, pair1)\r\n    if eth0 > eth1:\r\n        return token0\r\n    else:\r\n        return token1\r\n\r\n@external\r\n@payable\r\n@nonreentrant('lock')\r\ndef divestUniPairToToken(pair: address, token: address, amount: uint256, minTokenAmount: uint256, deadline: uint256=MAX_UINT256) -> uint256:\r\n    assert not self.paused, \"Paused\"\r\n    fee: uint256 = self.feeAmount\r\n    msg_value: uint256 = msg.value\r\n\r\n    assert msg.value >= fee, \"Insufficient fee\"\r\n    if msg.value > fee:\r\n        send(msg.sender, msg.value - fee)\r\n    send(self.feeAddress, fee)\r\n\r\n    assert pair != ZERO_ADDRESS, \"Invalid Unipool Address\"\r\n\r\n    token0: address = UniswapV2Pair(pair).token0()\r\n    token1: address = UniswapV2Pair(pair).token1()\r\n\r\n    ERC20(pair).transferFrom(msg.sender, self, amount)\r\n    ERC20(pair).approve(UNISWAPV2ROUTER02, amount)\r\n\r\n    token0Amount: uint256 = 0\r\n    token1Amount: uint256 = 0\r\n    (token0Amount, token1Amount) = UniswapV2Router02(UNISWAPV2ROUTER02).removeLiquidity(token0, token1, amount, 1, 1, self, deadline)\r\n    tokenAmount: uint256 = 0\r\n    if token == token0:\r\n        tokenAmount = token0Amount + self._token2Token(token1, token0, token1Amount, self, deadline)\r\n        ERC20(token).transfer(msg.sender, tokenAmount)\r\n        assert tokenAmount >= minTokenAmount, \"High Slippage\"\r\n        return tokenAmount\r\n    elif token == token1:\r\n        tokenAmount = token1Amount + self._token2Token(token0, token1, token0Amount, self, deadline)\r\n        ERC20(token).transfer(msg.sender, tokenAmount)\r\n        assert tokenAmount >= minTokenAmount, \"High Slippage\"\r\n        return tokenAmount\r\n    elif token0 == WETH:\r\n        tokenAmount = token0Amount + self._token2Token(token1, token0, token1Amount, self, deadline)\r\n    elif token1 == WETH:\r\n        tokenAmount = token1Amount + self._token2Token(token0, token1, token0Amount, self, deadline)\r\n    else:\r\n        midToken: address = self._getMidToken(WETH, token0, token1)\r\n        if midToken == token0:\r\n            tokenAmount = self._token2Token(token1, midToken, token1Amount, self, deadline)\r\n        elif midToken == token1:\r\n            tokenAmount = self._token2Token(token0, midToken, token0Amount, self, deadline)\r\n        else:\r\n            raise \"Token Error\"\r\n        tokenAmount = self._token2Token(midToken, WETH, tokenAmount, self, deadline)\r\n    if token == WETH:\r\n        ERC20(WETH).transfer(msg.sender, tokenAmount)\r\n        assert tokenAmount >= minTokenAmount, \"High Slippage\"\r\n        return tokenAmount\r\n    if token == VETH or token == ZERO_ADDRESS:\r\n        WrappedEth(WETH).withdraw(tokenAmount)\r\n        assert tokenAmount >= minTokenAmount, \"High Slippage\"\r\n        send(msg.sender, tokenAmount)\r\n        return tokenAmount\r\n    tokenAmount = self._token2Token(WETH, token, tokenAmount, msg.sender, deadline)\r\n    assert tokenAmount >= minTokenAmount, \"High Slippage\"\r\n    return tokenAmount\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef removeLiquidity(tokenA: address, tokenB: address, liquidity: uint256, amountAMin: uint256, amountBMin: uint256, to: address, deadline: uint256=DEADLINE) -> (uint256, uint256):\r\n    assert block.timestamp <= deadline, \"Expired!\"\r\n    pair: address = UniswapV2Factory(UNISWAPV2FACTORY).getPair(tokenA, tokenB)\r\n    ERC20(pair).transferFrom(msg.sender, pair, liquidity)\r\n    amount0: uint256 = 0\r\n    amount1: uint256 = 0\r\n    (amount0, amount1) = UniswapV2Pair(pair).burn(to)\r\n    if convert(tokenA, uint256) < convert(tokenB, uint256):\r\n        assert amount0 >= amountAMin, \"INSUFFICIENT_A_AMOUNT\"\r\n        assert amount1 >= amountBMin, \"INSUFFICIENT_B_AMOUNT\"\r\n        return (amount0, amount1)\r\n    else:\r\n        assert amount1 >= amountAMin, \"INSUFFICIENT_A_AMOUNT\"\r\n        assert amount0 >= amountBMin, \"INSUFFICIENT_B_AMOUNT\"\r\n        return (amount1, amount0)\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef removeLiquidityETH(token: address, liquidity: uint256, amountTokenMin: uint256, amountETHMin: uint256, to: address, deadline: uint256=DEADLINE) -> (uint256, uint256):\r\n    assert block.timestamp <= deadline, \"Expired!\"\r\n    pair: address = UniswapV2Factory(UNISWAPV2FACTORY).getPair(token, WETH)\r\n    ERC20(pair).transferFrom(msg.sender, pair, liquidity)\r\n    amount0: uint256 = 0\r\n    amount1: uint256 = 0\r\n    (amount0, amount1) = UniswapV2Pair(pair).burn(self)\r\n    if convert(token, uint256) < convert(WETH, uint256):\r\n        ERC20(token).transfer(to, amount0)\r\n        WrappedEth(WETH).withdraw(amount1)\r\n        send(to, amount1)\r\n        assert amount0 >= amountTokenMin, \"INSUFFICIENT_TOKEN_AMOUNT\"\r\n        assert amount1 >= amountETHMin, \"INSUFFICIENT_ETH_AMOUNT\"\r\n        return (amount0, amount1)\r\n    else:\r\n        ERC20(token).transfer(to, amount1)\r\n        WrappedEth(WETH).withdraw(amount0)\r\n        send(to, amount0)\r\n        assert amount1 >= amountTokenMin, \"INSUFFICIENT_TOKEN_AMOUNT\"\r\n        assert amount0 >= amountETHMin, \"INSUFFICIENT_ETH_AMOUNT\"\r\n        return (amount1, amount0)\r\n\r\n# Admin functions\r\n@external\r\ndef pause(_paused: bool):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.paused = _paused\r\n\r\n@external\r\ndef newAdmin(_admin: address):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.admin = _admin\r\n\r\n@external\r\ndef newFeeAmount(_feeAmount: uint256):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.feeAmount = _feeAmount\r\n\r\n@external\r\ndef newFeeAddress(_feeAddress: address):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.feeAddress = _feeAddress\r\n\r\n@external\r\n@payable\r\ndef __default__(): pass","ABI":"[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"divestUniPairToToken\",\"inputs\":[{\"name\":\"pair\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"minTokenAmount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"divestUniPairToToken\",\"inputs\":[{\"name\":\"pair\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"minTokenAmount\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"removeLiquidity\",\"inputs\":[{\"name\":\"tokenA\",\"type\":\"address\"},{\"name\":\"tokenB\",\"type\":\"address\"},{\"name\":\"liquidity\",\"type\":\"uint256\"},{\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"removeLiquidity\",\"inputs\":[{\"name\":\"tokenA\",\"type\":\"address\"},{\"name\":\"tokenB\",\"type\":\"address\"},{\"name\":\"liquidity\",\"type\":\"uint256\"},{\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"removeLiquidityETH\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"liquidity\",\"type\":\"uint256\"},{\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"removeLiquidityETH\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"liquidity\",\"type\":\"uint256\"},{\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"pause\",\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":36454},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"newAdmin\",\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"outputs\":[],\"gas\":36484},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"newFeeAmount\",\"inputs\":[{\"name\":\"_feeAmount\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":36414},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"newFeeAddress\",\"inputs\":[{\"name\":\"_feeAddress\",\"type\":\"address\"}],\"outputs\":[],\"gas\":36544},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"paused\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":1388},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1418},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"feeAmount\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":1448},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"feeAddress\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1478}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.11","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}