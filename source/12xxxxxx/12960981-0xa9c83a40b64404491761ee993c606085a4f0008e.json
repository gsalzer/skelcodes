{"status":"1","message":"OK","result":[{"SourceCode":"{\"GeneralToken.sol\":{\"content\":\"pragma solidity 0.7.2;\\r\\n\\r\\n// SPDX-License-Identifier: JPLv1.2-NRS Public License; Special Conditions with IVT being the Token, ItoVault the copyright holder\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract GeneralToken {\\r\\n    string public name;\\r\\n    string public symbol;\\r\\n    uint8 public constant decimals = 18;  \\r\\n    \\r\\n    address public startingOwner;\\r\\n\\r\\n\\r\\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\r\\n    event Transfer(address indexed from, address indexed to, uint tokens);\\r\\n\\r\\n\\r\\n    mapping(address =\\u003e uint256) public balances;\\r\\n\\r\\n    mapping(address =\\u003e mapping (address =\\u003e uint256)) public allowed;\\r\\n    \\r\\n    uint256 public totalSupply_;\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n\\r\\n   constructor(uint256 total, address _startingOwner, string memory _name, string memory _symbol) {  \\r\\n    name = _name;\\r\\n    symbol = _symbol;\\r\\n\\ttotalSupply_ = total;\\r\\n\\tstartingOwner = _startingOwner;\\r\\n\\tbalances[startingOwner] = totalSupply_;\\r\\n    }  \\r\\n\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n\\treturn totalSupply_;\\r\\n    }\\r\\n    \\r\\n    function balanceOf(address tokenOwner) public view returns (uint) {\\r\\n        return balances[tokenOwner];\\r\\n    }\\r\\n\\r\\n    function transfer(address receiver, uint numTokens) public returns (bool) {\\r\\n        require(numTokens \\u003c= balances[msg.sender]);\\r\\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\\r\\n        balances[receiver] = balances[receiver].add(numTokens);\\r\\n        emit Transfer(msg.sender, receiver, numTokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(address delegate, uint numTokens) public returns (bool) {\\r\\n        allowed[msg.sender][delegate] = numTokens;\\r\\n        emit Approval(msg.sender, delegate, numTokens);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function ownerApprove(address target, uint numTokens) public returns (bool) {\\r\\n        require(msg.sender == startingOwner, \\\"Only the Factory Contract Can Run This\\\");\\r\\n        allowed[target][startingOwner] = numTokens;\\r\\n        emit Approval(target, startingOwner, numTokens);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n\\r\\n    function allowance(address owner, address delegate) public view returns (uint) {\\r\\n        return allowed[owner][delegate];\\r\\n    }\\r\\n \\r\\n    function transferFrom(address owner, address buyer, uint numTokens) public returns (bool) {\\r\\n        require(numTokens \\u003c= balances[owner]);    \\r\\n        require(numTokens \\u003c= allowed[owner][msg.sender]);\\r\\n    \\r\\n        balances[owner] = balances[owner].sub(numTokens);\\r\\n        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\\r\\n        balances[buyer] = balances[buyer].add(numTokens);\\r\\n        emit Transfer(owner, buyer, numTokens);\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.2;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"},\"VaultSystem.sol\":{\"content\":\"pragma solidity 0.7.2;\\r\\n\\r\\n// SPDX-License-Identifier: JPLv1.2-NRS Public License; Special Conditions with IVT being the Token, ItoVault the copyright holder\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./GeneralToken.sol\\\";\\r\\n\\r\\ncontract VaultSystem {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    event loguint(string name, uint value);\\r\\n    \\r\\n    GeneralToken public vSYMToken;\\r\\n    GeneralToken public ivtToken;\\r\\n    \\r\\n    // NB: None of the storage variables below should store numbers greater than 1E36.   uint256 overflow above 1E73.\\r\\n    // So it is safe to mul two numbers always. But to mul more than 2 requires decimal counting.\\r\\n    \\r\\n    uint public weiPervSYM = 10 ** 18; \\r\\n    uint public maxvSYME18 = 10000 * 10 ** 18;           // Upper Bound on Number of vSYM tokens\\r\\n    uint public outstandingvSYME18 = 0;                 // Current outstanding vSYM tokens\\r\\n    \\r\\n    \\r\\n    // Forward (not counter) Vault System\\r\\n    uint public initialLTVE10   = 7 * 10 ** 9;    // Maximum starting loan to value of a vault                [Integer / 1E10]\\r\\n    uint public maintLTVE10     = 8 * 10 ** 9;      // Maximum maintnenance loan to value of a vault            [Integer / 1E10]\\r\\n    uint public liqPenaltyE10   = 1 * 10 ** 9;    // Bonus paid to any address for liquidating non-compliant\\r\\n                                                // contract                                                 [Integer / 1E10]\\r\\n\\r\\n    // In this system, individual vaults *are* addresses.  Instances of vaults then are mapped by bare address\\r\\n    // Each vault has an \\\"asset\\\" side and a \\\"debt\\\" side\\r\\n    mapping(address =\\u003e uint) public weiAsset;           // Weis the Vault owns -- the asset side\\r\\n    mapping(address =\\u003e uint) public vSYMDebtE18;        // vSYM -- the debt side of the balance sheet of each Vault\\r\\n    \\r\\n    \\r\\n    // Counter Vault Contract\\r\\n    uint public initialLTVCounterVaultE10   = 7 * 10 ** 9;                // Maximum starting loan to value of a vault                [Integer / 1E10]\\r\\n    uint public maintLTVCounterVaultE10     = 8 * 10 ** 9;                // Maximum maintnenance loan to value of a vault            [Integer / 1E10]\\r\\n    uint public liqPenaltyCounterVaultE10   = 1 * 10 ** 9;              // Bonus paid to any address for liquidating non-compliant\\r\\n                                                                        // contract                                                 [Integer / 1E10]\\r\\n    mapping(address =\\u003e uint) public vSYMAssetCounterVaultE18;             // vSYM deposited in inverse vault\\r\\n    mapping(address =\\u003e uint) public weiDebtCounterVault;                     // weiDebtCounterVault\\r\\n\\r\\n    \\r\\n    // The following variables track all Vaults.  Not strictly needed, but helps liquidate non-compliant vaults\\r\\n    mapping(address =\\u003e bool) public isAddressRegistered;    // Forward map to emulate a \\\"set\\\" struct\\r\\n    address[] public registeredAddresses;                   // Backward map for \\\"set\\\" struct\\r\\n    \\r\\n    address payable public owner;                           // owner is also governor here.  to be passed to WATDAO in the future\\r\\n    address payable public oracle;                          // \\r\\n    \\r\\n    \\r\\n    bool public inGlobalSettlement = false;\\r\\n    uint public globalSettlementStartTime;\\r\\n    uint public settledWeiPervSYM; \\r\\n    bool public isGloballySettled = false;\\r\\n    \\r\\n    \\r\\n    uint public lastOracleTime;\\r\\n    bool public oracleChallenged = false;   // Is the whitelisted oracle (system) in challenge?         \\r\\n    uint public lastChallengeValue; // The weiPervSYM value of the last challenge                [Integer atomic weis per 1 unit SPX (e.g. SPX ~ $3300 in Oct 2020)]\\r\\n    uint public lastChallengeIVT;   // The WATs staked in the last challenge                    [WAT atomic units]\\r\\n    uint public lastChallengeTime;  // The time of the last challenge, used for challenge expiry[Seconds since Epoch]\\r\\n    \\r\\n    \\r\\n    uint[] public challengeIVTokens;    // Dynamic array of all challenges, integer indexed to match analagous arrays, used like a stack in code\\r\\n    uint[] public challengeValues;  // Dynamic array of all challenges, integer indexed, used like a stack in code\\r\\n    address[] public challengers;   // Dynamic array of all challengers, integer indexed, used like a stack in code\\r\\n    \\r\\n    constructor() {\\r\\n        owner = msg.sender;\\r\\n        oracle = msg.sender;\\r\\n        vSYMToken = new GeneralToken(10 ** 30, address(this), \\\"vVTI Token V_1_0_0\\\", \\\"vVTI V1_0\\\"); // 18 decimals after the point, 12 before\\r\\n        ivtToken = GeneralToken(address(0xb5BC0481ff9EF553F11f031A469cd9DF71280A27));\\r\\n    }\\r\\n\\r\\n    \\r\\n    // Oracle Functions\\r\\n    function oracleUpdateweiPervSYM(uint _weiPervSYM) public {\\r\\n        require(msg.sender == oracle, \\\"Disallowed: You are not oracle\\\");\\r\\n        weiPervSYM = _weiPervSYM;\\r\\n        lastOracleTime = block.timestamp;\\r\\n    }\\r\\n    \\r\\n\\r\\n    // Governance Functions\\r\\n    function govUpdateinitialLTVE10(uint _initialLTVE10) public {\\r\\n        require(msg.sender == owner, \\\"Disallowed: You are not governance\\\");\\r\\n        initialLTVE10 = _initialLTVE10;\\r\\n    }\\r\\n    \\r\\n    function govUpdatemaintLTVE10(uint _maintLTVE10) public {\\r\\n        require(msg.sender == owner, \\\"Disallowed: You are not governance\\\");\\r\\n        maintLTVE10 = _maintLTVE10;\\r\\n    }\\r\\n    \\r\\n    function govUpdateliqPenaltyE10(uint _liqPenaltyE10) public {\\r\\n        require(msg.sender == owner, \\\"Disallowed: You are not governance\\\");\\r\\n        liqPenaltyE10 = _liqPenaltyE10;\\r\\n    }\\r\\n    \\r\\n    function govUpdateinitialLTVCounterVaultE10(uint _initialLTVCounterVaultE10) public {\\r\\n        require(msg.sender == owner, \\\"Disallowed: You are not governance\\\");\\r\\n        initialLTVCounterVaultE10 = _initialLTVCounterVaultE10;\\r\\n    }\\r\\n    \\r\\n    function govUpdatemaintLTVCounterVaultE10(uint _maintLTVCounterVaultE10) public {\\r\\n        require(msg.sender == owner, \\\"Disallowed: You are not governance\\\");\\r\\n        maintLTVCounterVaultE10 = _maintLTVCounterVaultE10;\\r\\n    }\\r\\n    \\r\\n    function govUpdateliqPenaltyCounterVaultE10(uint _liqPenaltyCounterVaultE10) public {\\r\\n        require(msg.sender == owner, \\\"Disallowed: You are not governance\\\");\\r\\n        liqPenaltyCounterVaultE10 = _liqPenaltyCounterVaultE10;\\r\\n    }\\r\\n    \\r\\n    function govChangeOwner(address payable _owner) public {\\r\\n        require(msg.sender == owner, \\\"Disallowed: You are not governance\\\");\\r\\n        owner = _owner;\\r\\n    }\\r\\n    \\r\\n    function govChangeOracle(address payable _oracle) public {\\r\\n        require(msg.sender == owner, \\\"Disallowed: You are not governance\\\");\\r\\n        oracle = _oracle;\\r\\n    }\\r\\n    \\r\\n    function govChangeMaxvSYME18(uint _maxvSYME18) public {\\r\\n        require(msg.sender == owner, \\\"Disallowed: You are not governance\\\");\\r\\n        maxvSYME18 = _maxvSYME18;\\r\\n    }\\r\\n    \\r\\n    function govStartGlobalSettlement() public {\\r\\n        require(msg.sender == owner, \\\"Disallowed: You are not governance\\\");\\r\\n        inGlobalSettlement = true;\\r\\n        globalSettlementStartTime = block.timestamp;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    \\r\\n    // Vault Functions\\r\\n    function depositWEI() public payable { // same as receive fallback; but explictily declared for symmetry\\r\\n        require(msg.value \\u003e 0, \\\"Must Deposit Nonzero Wei\\\"); \\r\\n        weiAsset[msg.sender] = weiAsset[msg.sender].add( msg.value );\\r\\n        \\r\\n        if(isAddressRegistered[msg.sender] != true) { // if user was not registered before\\r\\n            isAddressRegistered[msg.sender] = true;\\r\\n            registeredAddresses.push(msg.sender);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    receive() external payable { // same as receive fallback; but explictily declared for symmetry\\r\\n        require(msg.value \\u003e 0, \\\"Must Deposit Nonzero Wei\\\"); \\r\\n        \\r\\n        // Receiving is automatic so double entry accounting not possible here\\r\\n        weiAsset[msg.sender] = weiAsset[msg.sender].add( msg.value );\\r\\n        \\r\\n        if(isAddressRegistered[msg.sender] != true) { // if user was not registered before\\r\\n            isAddressRegistered[msg.sender] = true;\\r\\n            registeredAddresses.push(msg.sender);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdrawWEI(uint _weiWithdraw) public {  // NB: Security model is against msg.sender\\r\\n        // presuming contract withdrawal is from own vault\\r\\n        require( _weiWithdraw \\u003c 10 ** 30, \\\"Protective max bound for uint argument\\\");\\r\\n        \\r\\n        // Maintenence Equation: (vSYMDebtE18/1E18) * weiPervSYM \\u003c= (weiAsset) * (initialLTVE10/1E10)\\r\\n        // I need: (vSYMDebtE18)/1E18 * weiPervSYM \\u003c= (weiAsset - _weiWithdraw) * (initialLTVE10/1E10)\\r\\n        uint LHS = vSYMDebtE18[msg.sender].mul( weiPervSYM ).mul( 10 ** 10 );\\r\\n        uint RHS = (weiAsset[msg.sender].sub( _weiWithdraw )).mul( initialLTVE10 ).mul( 10 ** 18 );\\r\\n        require ( LHS \\u003c= RHS, \\\"Your initial margin is insufficient for withdrawing.\\\");\\r\\n        \\r\\n        // Double Entry Accounting\\r\\n        weiAsset[msg.sender] = weiAsset[msg.sender].sub( _weiWithdraw ); // penalize wei deposited before sending money out\\r\\n        msg.sender.transfer(_weiWithdraw);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function lendvSYM(uint _vSYMLendE18) public {\\r\\n        //presuming message sender is using his own vault\\r\\n        require(_vSYMLendE18 \\u003c 10 ** 30, \\\"Protective max bound for uint argument\\\");\\r\\n        require(outstandingvSYME18.add( _vSYMLendE18 ) \\u003c= maxvSYME18, \\\"Current version limits max amount of vSYM possible\\\");\\r\\n        \\r\\n        // Maintenence Equation: (vSYMDebtE18/1E18) * weiPervSYM \\u003c= (weiAsset) * (initialLTVE10/1E10)\\r\\n        // I need: (_vSYMLendE18 + vSYMDebtE18)/1E18 * weiPervSYM  \\u003c weiAsset * (initialLTVE10/1E10)\\r\\n        uint LHS = vSYMDebtE18[msg.sender].add( _vSYMLendE18 ).mul( weiPervSYM ).mul( 10 ** 10 );\\r\\n        uint RHS = weiAsset[msg.sender].mul( initialLTVE10 ).mul( 10 ** 18 );\\r\\n        require(LHS \\u003c RHS, \\\"Your initial margin is insufficient for lending\\\");\\r\\n        \\r\\n        // Double Entry Accounting\\r\\n        vSYMDebtE18[msg.sender] = vSYMDebtE18[msg.sender].add( _vSYMLendE18 ); // penalize debt first.\\r\\n        outstandingvSYME18 = outstandingvSYME18.add(_vSYMLendE18);\\r\\n        vSYMToken.transfer(msg.sender, _vSYMLendE18);\\r\\n    }\\r\\n    \\r\\n    function repayvSYM(uint _vSYMRepayE18) public {\\r\\n        require(_vSYMRepayE18 \\u003c 10 ** 30, \\\"Protective max bound for uint argument\\\");\\r\\n        \\r\\n        vSYMToken.ownerApprove(msg.sender, _vSYMRepayE18); \\r\\n        \\r\\n        // Double Entry Accounting\\r\\n        vSYMToken.transferFrom(msg.sender, address(this), _vSYMRepayE18); // the actual deduction from the token contract\\r\\n        vSYMDebtE18[msg.sender] = vSYMDebtE18[msg.sender].sub( _vSYMRepayE18 );\\r\\n        outstandingvSYME18 = outstandingvSYME18.sub(_vSYMRepayE18);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function liquidateNonCompliant(uint _vSYMProvidedE18, address payable target_address) public { // liquidates a portion of the contract for non-compliance\\r\\n\\r\\n        // While it possible to have a more complex liquidation system, since liqudations are off-equilibrium, for the MVP \\r\\n        // We have decided we want overly aggressive liqudiations \\r\\n        \\r\\n        // Maintenence Equation: (vSYMDebtE18/1E18) * weiPervSYM \\u003c= (weiAsset) * (maintLTVE10/1E10)\\r\\n        // For a violation, the above will be flipped: (vSYMDebtE18/1E18) * weiPervSYM \\u003e (weiAsset) * (maintLTVE10/1E10)\\r\\n        \\r\\n        require( _vSYMProvidedE18 \\u003c= vSYMDebtE18[target_address], \\\"You cannot provide more vSYM than vSYMDebt outstanding\\\");\\r\\n        \\r\\n        uint LHS = vSYMDebtE18[target_address].mul( weiPervSYM ).mul( 10 ** 10);\\r\\n        uint RHS = weiAsset[target_address].mul( maintLTVE10 ).mul( 10 ** 18);\\r\\n        require(LHS \\u003e RHS, \\\"Current contract is within maintainance margin, so you cannot run this\\\");\\r\\n        \\r\\n        \\r\\n\\r\\n        \\r\\n        \\r\\n        // If this vault is underwater-with-respect-to-rewards (different than noncompliant), liquidation is pro-rata\\r\\n        // underater iff: weiAsset[target_address] \\u003c vSYMDebtE18[target_address]/1E18 * weiPervSYM * (liqPenaltyE10+1E10)/1E10\\r\\n        uint LHS2 = weiAsset[target_address].mul( 10 ** 18 ).mul( 10 ** 10);\\r\\n        uint RHS2 = vSYMDebtE18[target_address].mul( weiPervSYM ).mul( liqPenaltyE10.add( 10 ** 10 ));\\r\\n        \\r\\n        uint weiClaim;\\r\\n        if( LHS2 \\u003c RHS2 ) { // pro-rata claim\\r\\n            // weiClaim = ( _vSYMProvidedE18 /  vSYMDebtE18[target_address]) * weiAsset[target_address];\\r\\n            weiClaim = _vSYMProvidedE18.mul( weiAsset[target_address] ).div( vSYMDebtE18[target_address] );\\r\\n        } else {\\r\\n            // maxWeiClaim = _vSYMProvidedE18/1E18 * weiPervSYM * (1+liqPenaltyE10/1E10)\\r\\n            weiClaim = _vSYMProvidedE18.mul( weiPervSYM ).mul( liqPenaltyE10.add( 10 ** 10 )).div( 10 ** 18 ).div( 10 ** 10 );\\r\\n        }\\r\\n        require(weiClaim \\u003c= weiAsset[target_address], \\\"Code Error if you reached this point\\\");\\r\\n        \\r\\n        \\r\\n        // Double Entry Accounting for returning vSYM Debt back\\r\\n        vSYMToken.ownerApprove(msg.sender, _vSYMProvidedE18); \\r\\n        vSYMToken.transferFrom(msg.sender, address(this), _vSYMProvidedE18); // the actual deduction from the token contract\\r\\n        vSYMDebtE18[target_address] = vSYMDebtE18[target_address].sub( _vSYMProvidedE18 );\\r\\n        outstandingvSYME18 = outstandingvSYME18.sub( _vSYMProvidedE18 );\\r\\n        \\r\\n        \\r\\n        // Double Entry Accounting for deducting the vault\\u0027s assets\\r\\n        weiAsset[target_address] = weiAsset[target_address].sub( weiClaim );\\r\\n        msg.sender.transfer( weiClaim );\\r\\n    }\\r\\n\\r\\n\\r\\n    \\r\\n\\r\\n    \\r\\n    // Counter Vault Functions\\r\\n    function depositvSYMCounterVault(uint _vSYMDepositE18) public { \\r\\n        require( _vSYMDepositE18 \\u003c 10 ** 30, \\\"Protective max bound for uint argument\\\");\\r\\n        \\r\\n        // Transfer Tokens from sender, then double-entry account for it\\r\\n        vSYMToken.ownerApprove(msg.sender, _vSYMDepositE18); \\r\\n        vSYMToken.transferFrom(msg.sender, address(this), _vSYMDepositE18);\\r\\n        vSYMAssetCounterVaultE18[msg.sender] = vSYMAssetCounterVaultE18[msg.sender].add(_vSYMDepositE18);\\r\\n        \\r\\n        if(isAddressRegistered[msg.sender] != true) { // if user was not registered before\\r\\n            isAddressRegistered[msg.sender] = true;\\r\\n            registeredAddresses.push(msg.sender);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\r\\n    function withdrawvSYMCounterVault(uint _vSYMWithdrawE18) public {\\r\\n        require( _vSYMWithdrawE18 \\u003c 10 ** 30, \\\"Protective max bound for uint argument\\\");\\r\\n        \\r\\n        // Master equation for countervault: (weiDebtCounterVault ) \\u003c (vSYMAssetCounterVaultE18)/1E18 * weiPervSYM * (initialLTVCounterVaultE10/1E10) \\r\\n        // I need: (weiDebtCounterVault ) \\u003c (vSYMAssetCounterVaultE18 - _vSYMLendE18)/1E18 * weiPervSYM * (initialLTVCounterVaultE10/1E10) \\r\\n        uint LHS = weiDebtCounterVault[msg.sender].mul( 10 ** 10 ).mul( 10 ** 18 );\\r\\n        uint RHS = vSYMAssetCounterVaultE18[msg.sender].sub( _vSYMWithdrawE18 ).mul( weiPervSYM ).mul( initialLTVCounterVaultE10 );\\r\\n        require ( LHS \\u003c= RHS, \\u0027Your initial margin is insufficient for withdrawing.\\u0027 );\\r\\n        \\r\\n        vSYMAssetCounterVaultE18[msg.sender] =  vSYMAssetCounterVaultE18[msg.sender].sub( _vSYMWithdrawE18 ); // Penalize Account First\\r\\n        vSYMToken.transfer(msg.sender, _vSYMWithdrawE18);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function lendWeiCounterVault(uint _weiLend) public {\\r\\n        //presuming message sender is using his own vault\\r\\n        require(_weiLend \\u003c 10 ** 30, \\\"Protective Max Bound for Input Hit\\\");\\r\\n\\r\\n        // Master equation for countervault: (weiDebtCounterVault ) \\u003c (vSYMAssetCounterVaultE18)/1E18 * weiPervSYM * (initialLTVCounterVaultE10/1E10) \\r\\n        // I need: (weiDebtCounterVault + _weiWithdraw ) \\u003c weiPervSYM * (vSYMAssetCounterVaultE18/1E18) * (initialLTVCounterVaultE10/1E10) \\r\\n        \\r\\n        uint LHS = weiDebtCounterVault[msg.sender].add( _weiLend ).mul( 10** 18 ).mul( 10 ** 10 );\\r\\n        uint RHS = weiPervSYM.mul( vSYMAssetCounterVaultE18[msg.sender] ).mul( initialLTVCounterVaultE10 );\\r\\n        \\r\\n        require(LHS \\u003c= RHS, \\\"Your initial margin is insufficient for lending.\\\");\\r\\n        \\r\\n        // Double-entry accounting\\r\\n        weiDebtCounterVault[msg.sender] = weiDebtCounterVault[msg.sender].add( _weiLend );    // penalize debt first.\\r\\n        msg.sender.transfer(_weiLend);\\r\\n    }\\r\\n    \\r\\n    function repayWeiCounterVault() public payable {\\r\\n        require(msg.value \\u003c 10 ** 30, \\\"Protective Max Bound for Input Hit\\\");\\r\\n        require(msg.value \\u003c= weiDebtCounterVault[msg.sender], \\\"You cannot pay down more Wei debt than exists in this counterVault\\\");\\r\\n        \\r\\n        // Single entry accounting\\r\\n        weiDebtCounterVault[msg.sender] = weiDebtCounterVault[msg.sender].sub( msg.value );\\r\\n    }\\r\\n    \\r\\n    \\r\\n\\r\\n\\r\\n    \\r\\n\\r\\n    function liquidateNonCompliantCounterVault(address payable _targetCounterVault) payable public { // liquidates a portion of the counterVault for non-compliance\\r\\n        \\r\\n        // Security Presumption here is against favor of the runner of this function\\r\\n        require( msg.value \\u003c 10 ** 30 , \\\"Protective Max Bound for WEI Hit\\\");\\r\\n        require( msg.value \\u003c= weiDebtCounterVault[_targetCounterVault], \\\"You cannot provide more Wei than Wei debt outstanding\\\");\\r\\n        \\r\\n        // Vault Needs to be in Violation: (weiDebtCounterVault ) \\u003e (vSYMAssetCounterVaultE18)/1E18 * weiPervSYM * (maintLTVE10InverseVault/1E10)\\r\\n        uint LHS = weiDebtCounterVault[_targetCounterVault].mul( 10 ** 18 ).mul( 10 ** 10 );\\r\\n        uint RHS = vSYMAssetCounterVaultE18[_targetCounterVault].mul( weiPervSYM ).mul( maintLTVCounterVaultE10 );\\r\\n        emit loguint(\\\"RHS\\\", RHS);\\r\\n        emit loguint(\\\"LHS\\\", LHS);\\r\\n        \\r\\n        require(LHS \\u003e RHS, \\\"Current contract is within maintenence margin\\\");\\r\\n        \\r\\n        \\r\\n        // If this Counter Vault is underwater-with-respect-to-rewards (different than noncompliant), liquidation is pro-rata  \\r\\n        // underater iff: vSYMAssetCounterVaultE18[_targetCounterVault] \\u003c  (weiDebtCounterVault[_targetCounterVault]/ weiPervSYM) * 1E18 * (liqPenaltyCounterVaultE10+1E10)/1E10\\r\\n        uint LHS2 = vSYMAssetCounterVaultE18[_targetCounterVault];\\r\\n        uint RHS2 = weiDebtCounterVault[_targetCounterVault].mul( liqPenaltyCounterVaultE10.add( 10 ** 10 )).mul( 10 ** 8 ).div( weiPervSYM );\\r\\n        \\r\\n        emit loguint(\\\"RHS2\\\", RHS2);\\r\\n        emit loguint(\\\"LHS2\\\", LHS2);\\r\\n        \\r\\n        uint vSYMClaimE18;\\r\\n        if( LHS2 \\u003c RHS2 ) { // if vault is rewards-underwater, pro-rate\\r\\n            // vSYMClaimE18 = ( msg.value /  weiDebtCounterVault[_targetCounterVault]) * vSYMAssetCounterVaultE18[_targetCounterVault];\\r\\n            vSYMClaimE18 = msg.value.mul( vSYMAssetCounterVaultE18[_targetCounterVault] ).div( weiDebtCounterVault[_targetCounterVault] );\\r\\n            require(vSYMClaimE18 \\u003c= vSYMAssetCounterVaultE18[_targetCounterVault], \\\"Code Error Branch 1 if you reached this point\\\");\\r\\n        } else { // if we have more than enough assets in this countervault\\r\\n            // vSYMClaimE18 = (msg.value / weiPervSYM) * 1E18 * (1E10+liqPenaltyE10) /1E10\\r\\n            vSYMClaimE18 = msg.value.mul( liqPenaltyCounterVaultE10.add( 10 ** 10 )).mul( 10 ** 8 ).div(weiPervSYM) ;\\r\\n            require(vSYMClaimE18 \\u003c= vSYMAssetCounterVaultE18[_targetCounterVault], \\\"Code Error Branch 2 if you reached this point\\\");\\r\\n            \\r\\n        }\\r\\n        \\r\\n        \\r\\n        // Single Entry Accounting for Returning the wei Debt\\r\\n        weiDebtCounterVault[_targetCounterVault] = weiDebtCounterVault[_targetCounterVault].sub( msg.value );\\r\\n        \\r\\n\\r\\n        // Double Entry Accounting\\r\\n        vSYMAssetCounterVaultE18[_targetCounterVault] = vSYMAssetCounterVaultE18[_targetCounterVault].sub( vSYMClaimE18 ); // Amount of Assets to Transfer override\\r\\n        vSYMToken.transfer( msg.sender , vSYMClaimE18 );\\r\\n        \\r\\n    }\\r\\n    \\r\\n    \\r\\n    \\r\\n    function partial1LiquidateNonCompliantCounterVault(address payable _targetCounterVault) payable public returns(uint, uint)  { // liquidates a portion of the counterVault for non-compliance\\r\\n        \\r\\n        // Security Presumption here is against favor of the runner of this function\\r\\n        require( msg.value \\u003c 10 ** 30 , \\\"Protective Max Bound for WEI Hit\\\");\\r\\n        require( msg.value \\u003c= weiDebtCounterVault[_targetCounterVault], \\\"You cannot provide more Wei than Wei debt outstanding\\\");\\r\\n        \\r\\n        // Vault Needs to be in Violation: (weiDebtCounterVault ) \\u003e (vSYMAssetCounterVaultE18)/1E18 * weiPervSYM * (maintLTVE10InverseVault/1E10)\\r\\n        uint LHS = weiDebtCounterVault[_targetCounterVault].mul( 10 ** 18 ).mul( 10 ** 10 );\\r\\n        uint RHS = vSYMAssetCounterVaultE18[_targetCounterVault].mul( weiPervSYM ).mul( maintLTVCounterVaultE10 );\\r\\n        \\r\\n        require(LHS \\u003e RHS, \\\"Current contract is within maintenence margin\\\");\\r\\n        \\r\\n        return(LHS, RHS);\\r\\n        \\r\\n    }\\r\\n    \\r\\n    \\r\\n    function partial2LiquidateNonCompliantCounterVault(address payable _targetCounterVault) payable public returns(uint, uint)  { // liquidates a portion of the counterVault for non-compliance\\r\\n        \\r\\n        // Security Presumption here is against favor of the runner of this function\\r\\n        require( msg.value \\u003c 10 ** 30 , \\\"Protective Max Bound for WEI Hit\\\");\\r\\n        require( msg.value \\u003c= weiDebtCounterVault[_targetCounterVault], \\\"You cannot provide more Wei than Wei debt outstanding\\\");\\r\\n        \\r\\n        // Vault Needs to be in Violation: (weiDebtCounterVault ) \\u003e (vSYMAssetCounterVaultE18)/1E18 * weiPervSYM * (maintLTVE10InverseVault/1E10)\\r\\n\\r\\n        \\r\\n        \\r\\n        // If this Counter Vault is underwater-with-respect-to-rewards (different than noncompliant), liquidation is pro-rata  \\r\\n        // underater iff: vSYMAssetCounterVaultE18[_targetCounterVault] \\u003c  (weiDebtCounterVault[_targetCounterVault]/ weiPervSYM) * 1E18 * (liqPenaltyCounterVaultE10+1E10)/1E10\\r\\n        uint LHS2 = vSYMAssetCounterVaultE18[_targetCounterVault];\\r\\n        uint RHS2 = weiDebtCounterVault[_targetCounterVault].mul( liqPenaltyCounterVaultE10.add( 10 ** 10 )).mul( 10 ** 8 ).div( weiPervSYM );\\r\\n        return(LHS2, RHS2);\\r\\n        \\r\\n    }\\r\\n    \\r\\n    \\r\\n    \\r\\n    function findNoncompliantVaults(uint _limitNum) public view returns(address[] memory, uint[] memory, uint[] memory, uint[] memory, uint[] memory, uint) {   // Return the first N noncompliant vaults\\r\\n        require(_limitNum \\u003e 0, \\u0027Must run this on a positive integer\\u0027);\\r\\n        address[] memory noncompliantAddresses = new address[](_limitNum);\\r\\n        uint[] memory LHSs_vault = new uint[](_limitNum);\\r\\n        uint[] memory RHSs_vault = new uint[](_limitNum);\\r\\n        \\r\\n        uint[] memory LHSs_counterVault = new uint[](_limitNum);\\r\\n        uint[] memory RHSs_counterVault = new uint[](_limitNum);\\r\\n        \\r\\n        \\r\\n        uint j = 0;  // Iterator up to _limitNum\\r\\n        for (uint i=0; i\\u003cregisteredAddresses.length; i++) {\\r\\n            if(j\\u003e= _limitNum) {\\r\\n                break;\\r\\n            } \\r\\n            // Vault maintainance margin violation: (vSYMDebtE18)/1E18 * weiPervSYM  \\u003e weiAsset * (maintLTVE10)/1E10 for a violation\\r\\n            uint LHS_vault = vSYMDebtE18[registeredAddresses[i]].mul(weiPervSYM);\\r\\n            uint RHS_vault  = weiAsset[registeredAddresses[i]].mul( maintLTVE10 ).mul( 10 ** 8);\\r\\n            \\r\\n            \\r\\n            // Countervault maintenance margin violation:  (weiDebtCounterVault ) \\u003e (vSYMAssetCounterVaultE18)/1E18 * weiPervSYM * (maintLTVE10InverseVault/1E10)\\r\\n            uint LHS_counterVault = weiDebtCounterVault[registeredAddresses[i]].mul( 10 ** 18 ).mul( 10 ** 10 );\\r\\n            uint RHS_counterVault = vSYMAssetCounterVaultE18[registeredAddresses[i]].mul( weiPervSYM ).mul( maintLTVCounterVaultE10 );\\r\\n            \\r\\n            if( (LHS_vault \\u003e RHS_vault) || (LHS_counterVault \\u003e RHS_counterVault) ) {\\r\\n                noncompliantAddresses[j] = registeredAddresses[i];\\r\\n                LHSs_vault[j] = LHS_vault;\\r\\n                RHSs_vault[j] = RHS_vault;\\r\\n                LHSs_counterVault[j] = LHS_counterVault;\\r\\n                RHSs_counterVault[j] = RHS_counterVault;\\r\\n\\r\\n                j = j + 1;\\r\\n            }\\r\\n        }\\r\\n        return(noncompliantAddresses, LHSs_vault, RHSs_vault, LHSs_counterVault, RHSs_counterVault,  j);\\r\\n    }\\r\\n    \\r\\n\\r\\n    // The following functions are off off-equilibrium.  Thus they are vetted to be safe, but not necessarily efficient/optimal.\\r\\n\\r\\n\\r\\n    // Global Settlement Functions\\r\\n    function registerGloballySettled() public { // Anyone can run this closing function\\r\\n        require(inGlobalSettlement, \\\"Register function can only be run if governance has declared global settlement\\\");\\r\\n        require(block.timestamp \\u003e (globalSettlementStartTime + 14 days), \\\"Need to wait 14 days to finalize global settlement\\\");\\r\\n        require(!isGloballySettled, \\\"This function has already be run; can only be run once.\\\");\\r\\n        settledWeiPervSYM = weiPervSYM;\\r\\n        isGloballySettled = true;\\r\\n    }\\r\\n    \\r\\n    function settledConvertvSYMtoWei(uint _vSYMTokenToConvertE18) public {\\r\\n        require(isGloballySettled);\\r\\n        require(_vSYMTokenToConvertE18 \\u003c 10 ** 30, \\\"Protective max bound for input hit\\\");\\r\\n        \\r\\n        uint weiToReturn = _vSYMTokenToConvertE18.mul( settledWeiPervSYM ).div( 10 ** 18); // Rounds down\\r\\n        \\r\\n        // vSYM accounting is no longer double entry.  Destroy vSYM to get wei\\r\\n        vSYMToken.ownerApprove(msg.sender, _vSYMTokenToConvertE18);                     // Factory gives itself approval\\r\\n        vSYMToken.transferFrom(msg.sender, address(this), _vSYMTokenToConvertE18);    // the actual deduction from the token contract\\r\\n        msg.sender.transfer(weiToReturn);                                           // return wei\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function settledConvertVaulttoWei() public {\\r\\n        require(isGloballySettled);\\r\\n        \\r\\n        uint weiDebt = vSYMDebtE18[msg.sender].mul( settledWeiPervSYM ).div( 10 ** 18).add( 1 );               // Round up value of debt\\r\\n        require(weiAsset[msg.sender] \\u003e weiDebt, \\\"This CTV is not above water, cannot convert\\\");     \\r\\n        \\r\\n        uint weiEquity = weiAsset[msg.sender] - weiDebt;\\r\\n        \\r\\n        \\r\\n        // Zero out CTV and transfer equity remaining\\r\\n        vSYMDebtE18[msg.sender] = 0;\\r\\n        weiAsset[msg.sender] = 0;\\r\\n        msg.sender.transfer(weiEquity);  \\r\\n    }\\r\\n\\r\\n    \\r\\n\\r\\n    // Challenge Functions -- non-optimized\\r\\n    function startChallengeWeiPervSYM(uint _proposedWeiPervSYM, uint _ivtStaked) public {\\r\\n        // Checking we\\u0027re in the right state\\r\\n        require(lastOracleTime \\u003e 0, \\\"Cannot challenge a newly created smart contract\\\");\\r\\n        require(block.timestamp.sub( lastOracleTime ) \\u003e 14 days, \\\"You must wait for the whitelist oracle to not respond for 14 days\\\" );\\r\\n        require(_ivtStaked \\u003e= 10 * 10 ** 18, \\u0027You must challenge with at least ten IVT\\u0027);\\r\\n        require(_proposedWeiPervSYM != weiPervSYM, \\u0027You do not disagree with current value of weiPervSYM\\u0027);\\r\\n        require(oracleChallenged == false);\\r\\n        \\r\\n        \\r\\n        // Deducting tokens and crediting\\r\\n        uint256 allowance = ivtToken.allowance(msg.sender, address(this));\\r\\n        require(allowance \\u003e= _ivtStaked, \\u0027You have not allowed this contract access to the number of IVTs you claim\\u0027);\\r\\n        ivtToken.transferFrom(msg.sender, address(this), _ivtStaked); // the actual deduction from the token contract\\r\\n        \\r\\n        // Credit this challenger\\r\\n        challengers.push(msg.sender);\\r\\n        \\r\\n        // Start the challenge\\r\\n        oracleChallenged = true;\\r\\n        challengeValues.push(_proposedWeiPervSYM);\\r\\n        challengeIVTokens.push(_ivtStaked);\\r\\n        lastChallengeValue = _proposedWeiPervSYM;\\r\\n        lastChallengeTime = block.timestamp;\\r\\n    }\\r\\n    \\r\\n    function rechallengeWeiPervSYM(uint _proposedWeiPervSYM, uint _ivtStaked) public {\\r\\n        require(oracleChallenged == true, \\\"rechallenge cannot be run if challenge has not started.  consider startChallengeWeiPervSYM()\\\");\\r\\n        require(_ivtStaked \\u003e= lastChallengeIVT * 2, \\\"You must double the IVT from the last challenge\\\");\\r\\n        require(_proposedWeiPervSYM != lastChallengeValue, \\\"You do not disagree with last challenge of weiPervSYM\\\");\\r\\n        \\r\\n        \\r\\n        // Deducting tokens and crediting\\r\\n        uint256 allowance = ivtToken.allowance(msg.sender, address(this));\\r\\n        require(allowance \\u003e= _ivtStaked, \\u0027You have not allowed this contract access to the number of WATs you claim\\u0027);\\r\\n        ivtToken.transferFrom(msg.sender, address(this), _ivtStaked); // the actual deduction from the token contract\\r\\n        \\r\\n        // Credit this challenger\\r\\n        challengers.push(msg.sender);\\r\\n        \\r\\n        // Actually do the challenge\\r\\n        challengeValues.push(_proposedWeiPervSYM);\\r\\n        challengeIVTokens.push(_ivtStaked);\\r\\n        lastChallengeValue = _proposedWeiPervSYM;\\r\\n        lastChallengeTime = block.timestamp;\\r\\n        lastChallengeIVT = _ivtStaked;\\r\\n    }\\r\\n    \\r\\n    function endChallegeWeiPerSPX() public {\\r\\n        require(oracleChallenged == true, \\\"Consider startChallengeWeiPervSYM()\\\");\\r\\n        require(block.timestamp.sub( lastChallengeTime ) \\u003e 2 days, \\\"You must wait 2 days since the last challenge to end the challenge\\\");\\r\\n        \\r\\n        // This now makes effective the challenge oracle\\r\\n        weiPervSYM = lastChallengeValue;\\r\\n        \\r\\n        // initialize cumulative counter of correct vs incorrect wats\\r\\n        uint incorrectIvts = 0;\\r\\n        uint correctIvts = 0; \\r\\n        \\r\\n        // calculate the payback ratio\\r\\n        for(uint i = 0; i \\u003c challengeIVTokens.length; i++) {\\r\\n            if(challengeValues[i] == weiPervSYM) {\\r\\n                correctIvts += challengeIVTokens[i];\\r\\n            } else {\\r\\n                incorrectIvts += challengeIVTokens[i];\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        // Distribute the tokens\\r\\n        for(uint i = 0; i \\u003c challengeIVTokens.length; i++) {  //NB -- this should not be very long due to block gas limits\\r\\n            if(challengeValues[i] == weiPervSYM) {\\r\\n                uint toTransfer =  incorrectIvts.add(correctIvts).mul( challengeIVTokens[i] ).div( correctIvts );\\r\\n                \\r\\n                // best practice: remove this person\\u0027s credit first\\r\\n                challengeIVTokens[i] = 0;\\r\\n                vSYMToken.transfer(challengers[i], toTransfer);\\r\\n            } else {\\r\\n                // erase the challengeIVTokens\\r\\n                challengeIVTokens[i] = 0;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        // reset arrays to zero type\\r\\n        delete challengeIVTokens;\\r\\n        delete challengeValues;\\r\\n        delete challengers;\\r\\n        \\r\\n        lastChallengeValue = 0;\\r\\n        lastChallengeIVT = 0;\\r\\n        lastChallengeTime = 0;\\r\\n        \\r\\n        // end challenge\\r\\n        oracleChallenged = false;\\r\\n    }\\r\\n\\r\\n\\r\\n    function detachOwner() public { // an emergency function to commitally shut off the owner account while retaining residual functionality of tokens\\r\\n        require(msg.sender == owner);\\r\\n        initialLTVE10 = 4 * 10 ** 9; // 40% LTV at start\\r\\n        maintLTVE10 = 5 * 10 ** 9; // 50% LTV to maintain\\r\\n        liqPenaltyE10 = 15 * 10 ** 8; // 15% liquidation penalty\\r\\n        oracle = address(0);\\r\\n        owner = address(0);\\r\\n    }\\r\\n\\r\\n    \\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"loguint\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"challengeIVTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"challengeValues\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"challengers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositWEI\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vSYMDepositE18\",\"type\":\"uint256\"}],\"name\":\"depositvSYMCounterVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"detachOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endChallegeWeiPerSPX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limitNum\",\"type\":\"uint256\"}],\"name\":\"findNoncompliantVaults\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalSettlementStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxvSYME18\",\"type\":\"uint256\"}],\"name\":\"govChangeMaxvSYME18\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"govChangeOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"govChangeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"govStartGlobalSettlement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialLTVCounterVaultE10\",\"type\":\"uint256\"}],\"name\":\"govUpdateinitialLTVCounterVaultE10\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialLTVE10\",\"type\":\"uint256\"}],\"name\":\"govUpdateinitialLTVE10\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liqPenaltyCounterVaultE10\",\"type\":\"uint256\"}],\"name\":\"govUpdateliqPenaltyCounterVaultE10\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liqPenaltyE10\",\"type\":\"uint256\"}],\"name\":\"govUpdateliqPenaltyE10\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maintLTVCounterVaultE10\",\"type\":\"uint256\"}],\"name\":\"govUpdatemaintLTVCounterVaultE10\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maintLTVE10\",\"type\":\"uint256\"}],\"name\":\"govUpdatemaintLTVE10\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inGlobalSettlement\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialLTVCounterVaultE10\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialLTVE10\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAddressRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGloballySettled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ivtToken\",\"outputs\":[{\"internalType\":\"contract GeneralToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastChallengeIVT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastChallengeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastChallengeValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastOracleTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_weiLend\",\"type\":\"uint256\"}],\"name\":\"lendWeiCounterVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vSYMLendE18\",\"type\":\"uint256\"}],\"name\":\"lendvSYM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liqPenaltyCounterVaultE10\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liqPenaltyE10\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vSYMProvidedE18\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"target_address\",\"type\":\"address\"}],\"name\":\"liquidateNonCompliant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_targetCounterVault\",\"type\":\"address\"}],\"name\":\"liquidateNonCompliantCounterVault\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maintLTVCounterVaultE10\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maintLTVE10\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxvSYME18\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleChallenged\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_weiPervSYM\",\"type\":\"uint256\"}],\"name\":\"oracleUpdateweiPervSYM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"outstandingvSYME18\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_targetCounterVault\",\"type\":\"address\"}],\"name\":\"partial1LiquidateNonCompliantCounterVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_targetCounterVault\",\"type\":\"address\"}],\"name\":\"partial2LiquidateNonCompliantCounterVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposedWeiPervSYM\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ivtStaked\",\"type\":\"uint256\"}],\"name\":\"rechallengeWeiPervSYM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registerGloballySettled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"repayWeiCounterVault\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vSYMRepayE18\",\"type\":\"uint256\"}],\"name\":\"repayvSYM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settledConvertVaulttoWei\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vSYMTokenToConvertE18\",\"type\":\"uint256\"}],\"name\":\"settledConvertvSYMtoWei\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settledWeiPervSYM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposedWeiPervSYM\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ivtStaked\",\"type\":\"uint256\"}],\"name\":\"startChallengeWeiPervSYM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vSYMAssetCounterVaultE18\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vSYMDebtE18\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vSYMToken\",\"outputs\":[{\"internalType\":\"contract GeneralToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"weiAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"weiDebtCounterVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weiPervSYM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_weiWithdraw\",\"type\":\"uint256\"}],\"name\":\"withdrawWEI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vSYMWithdrawE18\",\"type\":\"uint256\"}],\"name\":\"withdrawvSYMCounterVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"VaultSystem","CompilerVersion":"v0.7.2+commit.51b20bc0","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d4c425096222c27511b4ef6c4ec01b76fae0ef51f7d22c3584f329e72926e306"}]}