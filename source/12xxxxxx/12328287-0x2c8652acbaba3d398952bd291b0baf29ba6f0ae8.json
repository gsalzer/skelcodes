{"status":"1","message":"OK","result":[{"SourceCode":"{\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.12;\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// Safe maths\\r\\n// ----------------------------------------------------------------------------\\r\\nlibrary SafeMath {\\r\\n    function add(uint a, uint b) internal pure returns (uint c) {\\r\\n        c = a + b;\\r\\n        require(c \\u003e= a, \\u0027SafeMath:INVALID_ADD\\u0027);\\r\\n    }\\r\\n\\r\\n    function sub(uint a, uint b) internal pure returns (uint c) {\\r\\n        require(b \\u003c= a, \\u0027SafeMath:OVERFLOW_SUB\\u0027);\\r\\n        c = a - b;\\r\\n    }\\r\\n\\r\\n    function mul(uint a, uint b, uint decimal) internal pure returns (uint) {\\r\\n        uint dc = 10**decimal;\\r\\n        uint c0 = a * b;\\r\\n        require(a == 0 || c0 / a == b, \\\"SafeMath: multiple overflow\\\");\\r\\n        uint c1 = c0 + (dc / 2);\\r\\n        require(c1 \\u003e= c0, \\\"SafeMath: multiple overflow\\\");\\r\\n        uint c2 = c1 / dc;\\r\\n        return c2;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b, uint decimal) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\"SafeMath: division by zero\\\");\\r\\n        uint dc = 10**decimal;\\r\\n        uint c0 = a * dc;\\r\\n        require(a == 0 || c0 / a == dc, \\\"SafeMath: division internal\\\");\\r\\n        uint c1 = c0 + (b / 2);\\r\\n        require(c1 \\u003e= c0, \\\"SafeMath: division internal\\\");\\r\\n        uint c2 = c1 / b;\\r\\n        return c2;\\r\\n    }\\r\\n}\\r\\n\"},\"TransferHelper.sol\":{\"content\":\"pragma solidity ^0.6.12;\\r\\n\\r\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\r\\nlibrary TransferHelper {\\r\\n    function safeApprove(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(\\r\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\u0027TransferHelper::safeApprove: approve failed\\u0027\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransfer(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(\\r\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\u0027TransferHelper::safeTransfer: transfer failed\\u0027\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        require(\\r\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\u0027TransferHelper::transferFrom: transferFrom failed\\u0027\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n        require(success, \\u0027TransferHelper::safeTransferETH: ETH transfer failed\\u0027);\\r\\n    }\\r\\n}\\r\\n\"},\"TubeChief.sol\":{\"content\":\"pragma solidity ^0.6.12;\\r\\n\\r\\nimport \\u0027./TransferHelper.sol\\u0027;\\r\\nimport \\u0027./SafeMath.sol\\u0027;\\r\\n\\r\\ncontract TubeChief {\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    uint constant DECIMAL = 18;\\r\\n    uint constant FARMER  = 750000000000000000;\\r\\n    uint constant DEV     = 100000000000000000;\\r\\n    uint constant LOTTERY = 150000000000000000;\\r\\n\\r\\n    struct PoolInfo {\\r\\n        address lpTokenAddress; // the LP token pair address\\r\\n        uint rewardPerBlock;    // number of TUBE will mint per block\\r\\n        uint lastBlockNo;       // record pool mint finish last block number\\r\\n        uint lastDevBlockNo;    // record token mint to development last block number\\r\\n        uint lastLotBlockNo;    // record token mint to lottery last block number\\r\\n        uint accLpStaked;       // accumulate number of LP token user staked\\r\\n        uint accLastBlockNo;    // record last pass in block number\\r\\n        uint multiplier;        // reward multiplier\\r\\n        uint accTokenPerShare;  // accumulated token per share\\r\\n        bool locked;            // pool is locked\\r\\n        bool finished;          // pool is stop mint token. disable deposit. only allow claim\\r\\n    }\\r\\n\\r\\n    struct UserPoolInfo {\\r\\n        uint lpStaked;       // user staked LP\\r\\n        uint rewardDebt;     // user debt\\r\\n        uint lastClaimBlock; // last block number user retrieve reward\\r\\n    }\\r\\n\\r\\n    mapping(uint =\\u003e PoolInfo) public pools; // dynamic pool container (pool ID =\\u003e pool related data)\\r\\n    mapping(address =\\u003e uint[]) poolIdByLp;  // pool ids recorder (LP token =\\u003e pool ids)\\r\\n\\r\\n    // user pool allocate (user addr =\\u003e (\\u003cpool ID\\u003e =\\u003e user pool data))\\r\\n    mapping(address =\\u003e mapping(uint =\\u003e UserPoolInfo)) public users;\\r\\n\\r\\n    address public owner;   // owner of tube chief\\r\\n    address public tube;    // the TUBE token\\r\\n    address public devaddr; // development address\\r\\n    address public lotaddr; // lottery address\\r\\n    uint public poolLength; // next pool id. current length is (poolLength - 1)\\r\\n\\r\\n    event CreatePool(address lpTokenAddress, uint rewardPerBlock, uint poolId);\\r\\n    event UpdatePool(uint poolId, uint rewardPerBlock, uint multiplier, bool locked);\\r\\n    event Claim(uint poolId, uint amount, uint claimable);\\r\\n    event TransferCompany(address old_owner, address new_owner);\\r\\n\\r\\n    modifier onlyOwner {\\r\\n        require(msg.sender == owner, \\u0027NOT OWNER\\u0027);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor (address _tube, address _devaddr, address _lotaddr) public {\\r\\n        owner   = msg.sender;\\r\\n        tube    = _tube;\\r\\n        devaddr = _devaddr;\\r\\n        lotaddr = _lotaddr;\\r\\n    }\\r\\n\\r\\n    // create new pool. only owner executable\\r\\n    // XX do not create twice on same LP token. reward will mess up if you do\\r\\n    function createPool(address _lpTokenAddress, uint _rewardPerBlock, uint _multiplier) public onlyOwner {\\r\\n        require(_lpTokenAddress != address(0), \\u0027CREATE_POOL_EMPTY_ADDRESS\\u0027);\\r\\n\\r\\n        emit CreatePool(_lpTokenAddress, _rewardPerBlock, poolLength);\\r\\n        pools[poolLength].lpTokenAddress = _lpTokenAddress;\\r\\n        pools[poolLength].rewardPerBlock = _rewardPerBlock;\\r\\n        pools[poolLength].multiplier     = _multiplier;\\r\\n        pools[poolLength].accLastBlockNo = block.number;\\r\\n        pools[poolLength].lastDevBlockNo = block.number;\\r\\n        pools[poolLength].lastLotBlockNo = block.number;\\r\\n        poolIdByLp[_lpTokenAddress].push(poolLength);\\r\\n        poolLength = poolLength.add(1);\\r\\n    }\\r\\n\\r\\n    // update pool setting, edit wisely. only owner executable\\r\\n    function updatePool(uint poolId, uint _rewardPerBlock, uint _multiplier, bool _locked) public onlyOwner {\\r\\n        _updateAccTokenPerShare(poolId);\\r\\n        pools[poolId].rewardPerBlock = _rewardPerBlock;\\r\\n        pools[poolId].multiplier     = _multiplier;\\r\\n        pools[poolId].locked         = _locked;\\r\\n        emit UpdatePool(poolId, _rewardPerBlock, _multiplier, _locked);\\r\\n    }\\r\\n\\r\\n    // update development address. only owner executable\\r\\n    function updateDevAddr(address _address) public onlyOwner {\\r\\n        devaddr = _address;\\r\\n    }\\r\\n\\r\\n    // update lottery address. only owner executable\\r\\n    function updateLotAddr(address _address) public onlyOwner {\\r\\n        lotaddr = _address;\\r\\n    }\\r\\n\\r\\n    // set pool stop mint token. claim reward based on last block number recorded. only owner executable\\r\\n    function updatePoolFinish(uint poolId, bool _finished) public onlyOwner {\\r\\n        pools[poolId].finished    = _finished;\\r\\n        pools[poolId].lastBlockNo = _finished ? block.number : 0;\\r\\n    }\\r\\n\\r\\n    // stake LP token to earn TUBE\\r\\n    function stake(uint poolId, uint amount) public {\\r\\n        require(pools[poolId].lpTokenAddress != address(0), \\u0027STAKE_POOL_NOT_EXIST\\u0027);\\r\\n        require(pools[poolId].locked == false, \\u0027STAKE_POOL_LOCKED\\u0027);\\r\\n        require(pools[poolId].finished == false, \\u0027STAKE_POOL_FINISHED\\u0027);\\r\\n\\r\\n        claim(poolId, 0);\\r\\n        TransferHelper.safeTransferFrom(pools[poolId].lpTokenAddress, msg.sender, address(this), amount);\\r\\n        pools[poolId].accLpStaked = pools[poolId].accLpStaked.add(amount);\\r\\n        users[msg.sender][poolId].lpStaked       = users[msg.sender][poolId].lpStaked.add(amount);\\r\\n        users[msg.sender][poolId].lastClaimBlock = block.number;\\r\\n        users[msg.sender][poolId].rewardDebt     = pools[poolId].accTokenPerShare.mul(users[msg.sender][poolId].lpStaked, DECIMAL);\\r\\n    }\\r\\n\\r\\n    // claim TUBE token. input LP token to exit pool\\r\\n    function claim(uint poolId, uint amount) public {\\r\\n        require(pools[poolId].lpTokenAddress != address(0), \\u0027CLAIM_POOL_NOT_EXIST\\u0027);\\r\\n        require(pools[poolId].locked == false, \\u0027CLAIM_POOL_LOCKED\\u0027);\\r\\n        \\r\\n        _updateAccTokenPerShare(poolId);\\r\\n\\r\\n        uint claimable = _getRewardAmount(poolId);\\r\\n        if (claimable \\u003e 0) {\\r\\n            ITubeToken(tube).farmMint(address(this), claimable);\\r\\n            TransferHelper.safeTransfer(tube, msg.sender, claimable);\\r\\n            users[msg.sender][poolId].lastClaimBlock = block.number;\\r\\n        }\\r\\n\\r\\n        if (amount \\u003e 0) {\\r\\n            TransferHelper.safeTransfer(pools[poolId].lpTokenAddress, msg.sender, amount);\\r\\n            users[msg.sender][poolId].lpStaked = users[msg.sender][poolId].lpStaked.sub(amount);\\r\\n            pools[poolId].accLpStaked = pools[poolId].accLpStaked.sub(amount);\\r\\n        }\\r\\n\\r\\n        // emit if necessary. cost saving\\r\\n        if (claimable \\u003e 0 || amount \\u003e 0) {\\r\\n            emit Claim(poolId, amount, claimable);\\r\\n        }\\r\\n\\r\\n        // update the user reward debt at this moment\\r\\n        users[msg.sender][poolId].rewardDebt = pools[poolId].accTokenPerShare.mul(users[msg.sender][poolId].lpStaked, DECIMAL);\\r\\n    }\\r\\n\\r\\n    // get token per share with current block number\\r\\n    function getAccTokenInfo(uint poolId) public view returns (uint) {\\r\\n        if (pools[poolId].accLpStaked \\u003c= 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint reward_block = pools[poolId].rewardPerBlock;\\r\\n        uint multiplier   = pools[poolId].multiplier;\\r\\n        uint total_staked = pools[poolId].accLpStaked;\\r\\n        uint pending      = block.number.sub(pools[poolId].accLastBlockNo);\\r\\n        pending           = pending * 10**DECIMAL; // cast to \\\"wei\\\" unit\\r\\n        uint result       = reward_block.mul(multiplier, DECIMAL).mul(pending, DECIMAL).mul(FARMER, DECIMAL);\\r\\n\\r\\n        return result.div(total_staked, DECIMAL);\\r\\n    }\\r\\n\\r\\n    // emergency collect token from the contract. only owner executable\\r\\n    function emergencyCollectToken(address token, uint amount) public onlyOwner {\\r\\n        IERC20(token).transfer(owner, amount);\\r\\n    }\\r\\n\\r\\n    // emergency collect eth from the contract. only owner executable\\r\\n    function emergencyCollectEth(uint amount) public onlyOwner {\\r\\n        address payable owner_address = payable(owner);\\r\\n        owner_address.send(amount);\\r\\n    }\\r\\n\\r\\n    // transfer ownership. proceed wisely. only owner executable\\r\\n    function transferCompany(address new_owner) public onlyOwner {\\r\\n        owner = new_owner;\\r\\n        emit TransferCompany(owner, new_owner);\\r\\n    }\\r\\n\\r\\n    // transfer mintable token to development address\\r\\n    function transferDev(uint poolId) public onlyOwner {\\r\\n        uint mintable = getExMintable(poolId, true);\\r\\n        require(mintable \\u003e 0, \\u0027TRANSFER_DEV_EMPTY\\u0027);\\r\\n        ITubeToken(tube).farmMint(address(this), mintable);\\r\\n        TransferHelper.safeTransfer(tube, devaddr, mintable);\\r\\n        pools[poolId].lastDevBlockNo = block.number;\\r\\n    }\\r\\n\\r\\n    // transfer mintable token to lottery address\\r\\n    function transferLottery(uint poolId) public onlyOwner {\\r\\n        uint mintable = getExMintable(poolId, false);\\r\\n        require(mintable \\u003e 0, \\u0027TRANSFER_LOT_EMPTY\\u0027);\\r\\n        ITubeToken(tube).farmMint(address(this), mintable);\\r\\n        TransferHelper.safeTransfer(tube, lotaddr, mintable);\\r\\n        pools[poolId].lastLotBlockNo = block.number;\\r\\n    }\\r\\n\\r\\n    // retrieve the mintable amount for development or lottery\\r\\n    function getExMintable(uint poolId, bool is_dev) public view returns (uint) {\\r\\n        uint last_block   = 0;\\r\\n        uint rate         = 0;\\r\\n\\r\\n        if (is_dev) {\\r\\n            last_block = pools[poolId].lastDevBlockNo;\\r\\n            rate       = DEV;\\r\\n        } else {\\r\\n            last_block = pools[poolId].lastLotBlockNo;\\r\\n            rate       = LOTTERY;\\r\\n        }\\r\\n\\r\\n        uint block_diff = block.number.sub(last_block);\\r\\n        block_diff      = block_diff * 10**DECIMAL;\\r\\n\\r\\n        return block_diff.mul(pools[poolId].rewardPerBlock, DECIMAL).mul(pools[poolId].multiplier, DECIMAL).mul(rate, DECIMAL);\\r\\n    }\\r\\n\\r\\n    // retrieve pool ids by LP token address\\r\\n    function getPidByLpToken(address _lpTokenAddress) public view returns (uint[] memory) {\\r\\n        return poolIdByLp[_lpTokenAddress];\\r\\n    }\\r\\n\\r\\n    // retrieve user reward info on the pool with current block number\\r\\n    function getUserReward(uint poolId) public view returns (uint, uint, uint, uint, uint) {\\r\\n        uint accTokenPerShare = getAccTokenInfo(poolId);\\r\\n        accTokenPerShare      = accTokenPerShare.add(pools[poolId].accTokenPerShare);\\r\\n        \\r\\n        uint claimable = accTokenPerShare.mul(users[msg.sender][poolId].lpStaked, DECIMAL).sub(users[msg.sender][poolId].rewardDebt);\\r\\n        return (block.number, claimable, accTokenPerShare, users[msg.sender][poolId].lpStaked, users[msg.sender][poolId].rewardDebt);\\r\\n    }\\r\\n    \\r\\n    function _updateAccTokenPerShare(uint poolId) internal {\\r\\n        uint result = getAccTokenInfo(poolId);\\r\\n        pools[poolId].accTokenPerShare = pools[poolId].accTokenPerShare.add(result);\\r\\n        pools[poolId].accLastBlockNo   = block.number;\\r\\n    }\\r\\n\\r\\n    function _getRewardAmount(uint poolId) view internal returns (uint) {\\r\\n        if (pools[poolId].accLpStaked \\u003c= 0) {\\r\\n            return (0);\\r\\n        }\\r\\n\\r\\n        uint user_staked = users[msg.sender][poolId].lpStaked;\\r\\n        uint user_debt   = users[msg.sender][poolId].rewardDebt;\\r\\n        uint claimable   = pools[poolId].accTokenPerShare.mul(user_staked, DECIMAL).sub(user_debt);\\r\\n\\r\\n        return (claimable);\\r\\n    }\\r\\n\\r\\n    fallback() external payable {\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface ITubeToken {\\r\\n    function farmMint(address _address, uint amount) external;\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function transfer(address to, uint tokens) external returns (bool success);\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tube\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devaddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lotaddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimable\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"CreatePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"old_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"TransferCompany\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"}],\"name\":\"UpdatePool\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_multiplier\",\"type\":\"uint256\"}],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devaddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyCollectEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyCollectToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getAccTokenInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"is_dev\",\"type\":\"bool\"}],\"name\":\"getExMintable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpTokenAddress\",\"type\":\"address\"}],\"name\":\"getPidByLpToken\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getUserReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotaddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"lpTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastBlockNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDevBlockNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastLotBlockNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accLpStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accLastBlockNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accTokenPerShare\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"transferCompany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"transferDev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"transferLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tube\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateDevAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateLotAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_multiplier\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_locked\",\"type\":\"bool\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_finished\",\"type\":\"bool\"}],\"name\":\"updatePoolFinish\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lpStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TubeChief","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000da86006036540822e0cd2861dbd2fd7ff9caa0e8000000000000000000000000beccc99c38cdb6acf5ae43f6a1b4b0dc8d8c13d2000000000000000000000000beccc99c38cdb6acf5ae43f6a1b4b0dc8d8c13d2","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ae05ca95a9f97d14badaecdb3dd125a9993396306505772baa78335855760f8c"}]}