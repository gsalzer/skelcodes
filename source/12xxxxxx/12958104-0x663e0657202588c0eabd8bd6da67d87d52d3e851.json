{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\PhoenixModules\\multiSignature\\multiSignatureClient.sol\r\n\r\npragma solidity =0.5.16;\r\n/**\r\n * SPDX-License-Identifier: GPL-3.0-or-later\r\n * Phoenix\r\n * Copyright (C) 2020 Phoenix Options Protocol\r\n */\r\ninterface IMultiSignature{\r\n    function getValidSignature(bytes32 msghash,uint256 lastIndex) external view returns(uint256);\r\n}\r\ncontract multiSignatureClient{\r\n    uint256 private constant multiSignaturePositon = uint256(keccak256(\"org.Phoenix.multiSignature.storage\"));\r\n    event DebugEvent(address indexed from,bytes32 msgHash,uint256 value,uint256 value1);\r\n    constructor(address multiSignature) public {\r\n        require(multiSignature != address(0),\"multiSignatureClient : Multiple signature contract address is zero!\");\r\n        saveValue(multiSignaturePositon,uint256(multiSignature));\r\n    }    \r\n    function getMultiSignatureAddress()public view returns (address){\r\n        return address(getValue(multiSignaturePositon));\r\n    }\r\n    modifier validCall(){\r\n        checkMultiSignature();\r\n        _;\r\n    }\r\n    function checkMultiSignature() internal {\r\n        uint256 value;\r\n        assembly {\r\n            value := callvalue()\r\n        }\r\n        bytes32 msgHash = keccak256(abi.encodePacked(msg.sender, address(this),value,msg.data));\r\n        address multiSign = getMultiSignatureAddress();\r\n        uint256 index = getValue(uint256(msgHash));\r\n        uint256 newIndex = IMultiSignature(multiSign).getValidSignature(msgHash,index);\r\n        require(newIndex > index, \"multiSignatureClient : This tx is not aprroved\");\r\n        saveValue(uint256(msgHash),newIndex);\r\n    }\r\n    function saveValue(uint256 position,uint256 value) internal \r\n    {\r\n        assembly {\r\n            sstore(position, value)\r\n        }\r\n    }\r\n    function getValue(uint256 position) internal view returns (uint256 value) {\r\n        assembly {\r\n            value := sload(position)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\PhoenixModules\\proxyModules\\proxyOwner.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @title  proxyOwner Contract\r\n\r\n */\r\n\r\ncontract proxyOwner is multiSignatureClient{\r\n    bytes32 private constant ownerExpiredPosition = keccak256(\"org.Phoenix.ownerExpired.storage\");\r\n    bytes32 private constant versionPositon = keccak256(\"org.Phoenix.version.storage\");\r\n    bytes32 private constant proxyOwnerPosition  = keccak256(\"org.Phoenix.Owner.storage\");\r\n    bytes32 private constant proxyOriginPosition  = keccak256(\"org.Phoenix.Origin.storage\");\r\n    uint256 private constant oncePosition  = uint256(keccak256(\"org.Phoenix.Once.storage\"));\r\n    uint256 private constant ownerExpired =  90 days;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event OriginTransferred(address indexed previousOrigin, address indexed newOrigin);\r\n    constructor(address multiSignature) multiSignatureClient(multiSignature) public{\r\n        _setProxyOwner(msg.sender);\r\n        _setProxyOrigin(tx.origin);\r\n    }\r\n    /**\r\n     * @dev Allows the current owner to transfer ownership\r\n     * @param _newOwner The address to transfer ownership to\r\n     */\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner\r\n    {\r\n        _setProxyOwner(_newOwner);\r\n    }\r\n    function _setProxyOwner(address _newOwner) internal \r\n    {\r\n        emit OwnershipTransferred(owner(),_newOwner);\r\n        bytes32 position = proxyOwnerPosition;\r\n        assembly {\r\n            sstore(position, _newOwner)\r\n        }\r\n        position = ownerExpiredPosition;\r\n        uint256 expired = now+ownerExpired;\r\n        assembly {\r\n            sstore(position, expired)\r\n        }\r\n    }\r\n    function owner() public view returns (address _owner) {\r\n        bytes32 position = proxyOwnerPosition;\r\n        assembly {\r\n            _owner := sload(position)\r\n        }\r\n    }\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require (isOwner(),\"proxyOwner: caller must be the proxy owner and a contract and not expired\");\r\n        _;\r\n    }\r\n    function transferOrigin(address _newOrigin) public onlyOrigin\r\n    {\r\n        _setProxyOrigin(_newOrigin);\r\n    }\r\n    function _setProxyOrigin(address _newOrigin) internal \r\n    {\r\n        emit OriginTransferred(txOrigin(),_newOrigin);\r\n        bytes32 position = proxyOriginPosition;\r\n        assembly {\r\n            sstore(position, _newOrigin)\r\n        }\r\n    }\r\n    function txOrigin() public view returns (address _origin) {\r\n        bytes32 position = proxyOriginPosition;\r\n        assembly {\r\n            _origin := sload(position)\r\n        }\r\n    }\r\n    function ownerExpiredTime() public view returns (uint256 _expired) {\r\n        bytes32 position = ownerExpiredPosition;\r\n        assembly {\r\n            _expired := sload(position)\r\n        }\r\n    }\r\n    modifier originOnce() {\r\n        require (msg.sender == txOrigin(),\"proxyOwner: caller is not the tx origin!\");\r\n        uint256 key = oncePosition+uint32(msg.sig);\r\n        require (getValue(key)==0, \"proxyOwner : This function must be invoked only once!\");\r\n        saveValue(key,1);\r\n        _;\r\n    }\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == owner() && isContract(msg.sender);\r\n    }\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOrigin() {\r\n        require (msg.sender == txOrigin(),\"proxyOwner: caller is not the tx origin!\");\r\n        checkMultiSignature();\r\n        _;\r\n    }\r\n    modifier OwnerOrOrigin(){\r\n        if (isOwner()){\r\n        }else if(msg.sender == txOrigin()){\r\n            checkMultiSignature();\r\n        }else{\r\n            require(false,\"proxyOwner: caller is not owner or origin\");\r\n        }\r\n        _;\r\n    }\r\n    function _setVersion(uint256 version_) internal \r\n    {\r\n        bytes32 position = versionPositon;\r\n        assembly {\r\n            sstore(position, version_)\r\n        }\r\n    }\r\n    function version() public view returns(uint256 version_){\r\n        bytes32 position = versionPositon;\r\n        assembly {\r\n            version_ := sload(position)\r\n        }\r\n    }\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts\\PhoenixModules\\proxy\\phxProxy.sol\r\n\r\npragma solidity =0.5.16;\r\n/**\r\n * SPDX-License-Identifier: GPL-3.0-or-later\r\n * Phoenix\r\n * Copyright (C) 2020 Phoenix Options Protocol\r\n */\r\n/**\r\n * @title  phxProxy Contract\r\n\r\n */\r\n\r\ncontract phxProxy is proxyOwner {\r\n    bytes32 private constant implementPositon = keccak256(\"org.Phoenix.implementation.storage\");\r\n    event Upgraded(address indexed implementation,uint256 indexed version);\r\n    constructor(address implementation_,address multiSignature) proxyOwner(multiSignature) public {\r\n\r\n        // Creator of the contract is admin during initialization\r\n        (bool success,) = implementation_.delegatecall(abi.encodeWithSignature(\"initialize()\"));\r\n        _setImplementation(implementation_);\r\n        require(success);\r\n    }\r\n    function proxyType() public pure returns (uint256){\r\n        return 2;\r\n    }\r\n    /**\r\n     * @dev Tells the address of the current implementation\r\n     * @return address of the current implementation\r\n     */\r\n    function implementation() public view returns (address impl) {\r\n        bytes32 position = implementPositon;\r\n        assembly {\r\n            impl := sload(position)\r\n        }\r\n    }\r\n    function _setImplementation(address _newImplementation) internal \r\n    {\r\n        (bool success, bytes memory returnData) = _newImplementation.delegatecall(abi.encodeWithSignature(\"implementationVersion()\"));\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize)\r\n            }\r\n        }\r\n        uint256 version_ = abi.decode(returnData, (uint256));\r\n        require (version_>version(),\"upgrade version number must be greater than current version\");\r\n        bytes32 position = implementPositon;\r\n        assembly {\r\n            sstore(position, _newImplementation)\r\n        }\r\n        _setVersion(version_);\r\n        emit Upgraded(_newImplementation,version_);\r\n    }\r\n    function upgradeTo(address _newImplementation)public OwnerOrOrigin{\r\n        address currentImplementation = implementation();\r\n        require(currentImplementation != _newImplementation,\"upgrade implementation is not changed!\");\r\n        (bool success,) = _newImplementation.delegatecall(abi.encodeWithSignature(\"update()\"));\r\n        _setImplementation(_newImplementation);\r\n        require(success);\r\n    }\r\n    function () payable external {\r\n        address _impl = implementation();\r\n        require(_impl != address(0));\r\n\r\n        assembly {\r\n        let ptr := mload(0x40)\r\n        calldatacopy(ptr, 0, calldatasize)\r\n        let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n        let size := returndatasize\r\n        returndatacopy(ptr, 0, size)\r\n\r\n        switch result\r\n        case 0 { revert(ptr, size) }\r\n        default { return(ptr, size) }\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiSignature\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value1\",\"type\":\"uint256\"}],\"name\":\"DebugEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOrigin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOrigin\",\"type\":\"address\"}],\"name\":\"OriginTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMultiSignatureAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerExpiredTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_expired\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOrigin\",\"type\":\"address\"}],\"name\":\"transferOrigin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"txOrigin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_origin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"version_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"phxProxy","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e0f5bd87e939235eb3bc9d81c6d9f0cdcb3480b3000000000000000000000000994a8c8d38718dc67fa2514cfcfeb16f96b2a144","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"1","Implementation":"0xe0f5bd87e939235eb3bc9d81c6d9f0cdcb3480b3","SwarmSource":"bzzr://ef9681872df15e42cc2d86fde82329106db82945a5b1a6c64b6fa2741cb591da"}]}