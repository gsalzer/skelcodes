{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.12;\r\n\r\ncontract BDSCITransferableTrustFundAccount {\r\n    address owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function withdrawAll() public {\r\n        require(owner == msg.sender);\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n    function withdrawAmount(uint256 amount) public {\r\n        require(owner == msg.sender);\r\n        require(address(this).balance >= amount);\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    function transferAccount(address newAccount) public {\r\n    require(owner == msg.sender);\r\n    require(newAccount != address(0));\r\n    owner = newAccount;\r\n    }\r\n\r\n    function terminateAccount() public {\r\n    require(owner == msg.sender);\r\n    selfdestruct(msg.sender);\r\n    }\r\n}\r\n\r\ncontract BDSCIAssetTokenized{\r\nuint public supply;\r\nuint public pricePerEth;\r\nmapping( address => uint ) public balance;\r\n\r\nconstructor() public {\r\n    supply = 1000000000000;                    // There are a total of 1000 tokens for this asset\r\n    pricePerEth = 100000000000000000; // One token costs 0.1 ether\r\n  }\r\n\r\n  function check() public view returns(uint) {\r\n    return balance[msg.sender];\r\n  }\r\n\r\n  function () external payable {\r\n    balance[msg.sender] += msg.value/pricePerEth; // adds asset tokens to how much ether is sent by the investor\r\n    supply -= msg.value/pricePerEth;              //subtracts the remaining asset tokens from the total supply\r\n  }\r\n}\r\n\r\ncontract CoreInterface {\r\n\r\n    /* Module manipulation events */\r\n\r\n    event ModuleAdded(string name, address indexed module);\r\n\r\n    event ModuleRemoved(string name, address indexed module);\r\n\r\n    event ModuleReplaced(string name, address indexed from, address indexed to);\r\n\r\n\r\n    /* Functions */\r\n\r\n    function set(string memory  _name, address _module, bool _constant) public;\r\n\r\n    function setMetadata(string memory _name, string  memory _description) public;\r\n\r\n    function remove(string memory _name) public;\r\n    \r\n    function contains(address _module)  public view returns (bool);\r\n\r\n    function size() public view returns (uint);\r\n\r\n    function isConstant(string memory _name) public view returns (bool);\r\n\r\n    function get(string memory _name)  public view returns (address);\r\n\r\n    function getName(address _module)  public view returns (string memory);\r\n\r\n    function first() public view returns (address);\r\n\r\n    function next(address _current)  public view returns (address);\r\n}\r\n\r\nlibrary ISQRT {\r\n\r\n    /**\r\n     * @notice Calculate Square Root\r\n     * @param n Operand of sqrt() function\r\n     * @return greatest integer less than or equal to the square root of n\r\n     */\r\n    function sqrt(uint256 n) internal pure returns(uint256){\r\n        return sqrtBabylonian(n);\r\n    }\r\n\r\n    /**\r\n     * Based on Martin Guy implementation\r\n     * http://freaknet.org/martin/tape/gos/misc/personal/msc/sqrt/sqrt.c\r\n     */\r\n    function isqrtBitByBit(uint256 x) internal pure returns (uint256){\r\n        uint256 op = x;\r\n        uint256 res = 0;\r\n        /* \"one\" starts at the highest power of four <= than the argument. */\r\n        uint256 one = 1 << 254; /* second-to-top bit set */\r\n        while (one > op) {\r\n            one = one >> 2;\r\n        }\r\n        while (one != 0) {\r\n            if (op >= res + one) {\r\n                op = op - (res + one);\r\n                res = res + (one << 1);\r\n            }\r\n            res = res >> 1;\r\n            one = one >> 2;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Babylonian method implemented in dapp-bin library\r\n     * https://github.com/ethereum/dapp-bin/pull/50\r\n     */\r\n    function sqrtBabylonian(uint256 x) internal pure returns (uint256) {\r\n        // x == MAX_UINT256 makes this method fail, so in this case return value calculated separately\r\n        if (x == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n        uint256 z = (x + 1) / 2;\r\n        uint256 y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2; //No overflow possible here, because greatest possible z = MAX_UINT256/2\r\n        }\r\n        return y;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"check\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pricePerEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BDSCIAssetTokenized","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":"bzzr://b79621cffe27e7abeaadfab7e521a2d19aadedf50d6114e447fe4dbc37e39a17"}]}