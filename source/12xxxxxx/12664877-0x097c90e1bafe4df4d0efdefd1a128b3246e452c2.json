{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FunctionX.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.13;\\n\\ncontract ERC20Basic {\\n\\tuint256 public totalSupply;\\n\\tfunction balanceOf(address who) public constant returns (uint256);\\n\\tfunction transfer(address to, uint256 value) public returns (bool);\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\nlibrary SafeMath {\\n\\tfunction mul(uint256 a, uint256 b) internal constant returns (uint256) {\\n\\t\\tuint256 c = a * b;\\n\\t\\tassert(a == 0 || c / a == b);\\n\\t\\treturn c;\\n\\t}\\n\\n\\tfunction div(uint256 a, uint256 b) internal constant returns (uint256) {\\n\\t\\t// assert(b > 0); // Solidity automatically throws when dividing by 0\\n\\t\\tuint256 c = a / b;\\n\\t\\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\t\\treturn c;\\n\\t}\\n\\n\\tfunction sub(uint256 a, uint256 b) internal constant returns (uint256) {\\n\\t\\tassert(b <= a);\\n\\t\\treturn a - b;\\n\\t}\\n\\n\\tfunction add(uint256 a, uint256 b) internal constant returns (uint256) {\\n\\t\\tuint256 c = a + b;\\n\\t\\tassert(c >= a);\\n\\t\\treturn c;\\n\\t}\\n}\\n\\ncontract BasicToken is ERC20Basic {\\n\\tusing SafeMath for uint256;\\n\\n\\tmapping(address => uint256) balances;\\n\\n\\t/**\\n    * @dev transfer token for a specified address\\n    * @param _to The address to transfer to.\\n    * @param _value The amount to be transferred.\\n    */\\n\\tfunction transfer(address _to, uint256 _value) public returns (bool) {\\n\\t\\trequire(_to != address(0));\\n\\t\\trequire(_value <= balances[msg.sender]);\\n\\n\\t\\t// SafeMath.sub will throw if there is not enough balance.\\n\\t\\tbalances[msg.sender] = balances[msg.sender].sub(_value);\\n\\t\\tbalances[_to] = balances[_to].add(_value);\\n\\t\\tTransfer(msg.sender, _to, _value);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n    * @dev Gets the balance of the specified address.\\n    * @param _owner The address to query the the balance of.\\n    * @return An uint256 representing the amount owned by the passed address.\\n    */\\n\\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\\n\\t\\treturn balances[_owner];\\n\\t}\\n\\n}\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20 is ERC20Basic {\\n\\tfunction allowance(address owner, address spender) public constant returns (uint256);\\n\\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\\n\\tfunction approve(address spender, uint256 value) public returns (bool);\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * @dev https://github.com/ethereum/EIPs/issues/20\\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n */\\ncontract StandardToken is ERC20, BasicToken {\\n\\n\\tmapping (address => mapping (address => uint256)) internal allowed;\\n\\n\\t/**\\n     * @dev Transfer tokens from one address to another\\n     * @param _from address The address which you want to send tokens from\\n     * @param _to address The address which you want to transfer to\\n     * @param _value uint256 the amount of tokens to be transferred\\n     */\\n\\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\\n\\t\\trequire(_to != address(0));\\n\\t\\trequire(_value <= balances[_from]);\\n\\t\\trequire(_value <= allowed[_from][msg.sender]);\\n\\n\\t\\tbalances[_from] = balances[_from].sub(_value);\\n\\t\\tbalances[_to] = balances[_to].add(_value);\\n\\t\\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n\\t\\tTransfer(_from, _to, _value);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     *\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param _spender The address which will spend the funds.\\n     * @param _value The amount of tokens to be spent.\\n     */\\n\\tfunction approve(address _spender, uint256 _value) public returns (bool) {\\n\\t\\tallowed[msg.sender][_spender] = _value;\\n\\t\\tApproval(msg.sender, _spender, _value);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param _owner address The address which owns the funds.\\n     * @param _spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n\\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\\n\\t\\treturn allowed[_owner][_spender];\\n\\t}\\n\\n\\t/**\\n     * approve should be called when allowed[_spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     */\\n\\tfunction increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\\n\\t\\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\\n\\t\\tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\\n\\t\\tuint oldValue = allowed[msg.sender][_spender];\\n\\t\\tif (_subtractedValue > oldValue) {\\n\\t\\t\\tallowed[msg.sender][_spender] = 0;\\n\\t\\t} else {\\n\\t\\t\\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n\\t\\t}\\n\\t\\tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n\\t\\treturn true;\\n\\t}\\n\\n}\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n\\taddress public owner;\\n\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\t/**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n\\tfunction Ownable() {\\n\\t\\towner = msg.sender;\\n\\t}\\n\\n\\t/**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n\\tmodifier onlyOwner() {\\n\\t\\trequire(msg.sender == owner);\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n\\tfunction transferOwnership(address newOwner) onlyOwner public {\\n\\t\\trequire(newOwner != address(0));\\n\\t\\tOwnershipTransferred(owner, newOwner);\\n\\t\\towner = newOwner;\\n\\t}\\n\\n}\\n\\n/**\\n * @title Mintable token\\n * @dev Simple ERC20 Token example, with mintable token creation\\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\\n */\\n\\ncontract MintableToken is StandardToken, Ownable {\\n\\tevent Mint(address indexed to, uint256 amount);\\n\\tevent MintFinished();\\n\\n\\tbool public mintingFinished = false;\\n\\n\\n\\tmodifier canMint() {\\n\\t\\trequire(!mintingFinished);\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n     * @dev Function to mint tokens\\n     * @param _to The address that will receive the minted tokens.\\n     * @param _amount The amount of tokens to mint.\\n     * @return A boolean that indicates if the operation was successful.\\n     */\\n\\tfunction mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\\n\\t\\ttotalSupply = totalSupply.add(_amount);\\n\\t\\tbalances[_to] = balances[_to].add(_amount);\\n\\t\\tMint(_to, _amount);\\n\\t\\tTransfer(0x0, _to, _amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n     * @dev Function to stop minting new tokens.\\n     * @return True if the operation was successful.\\n     */\\n\\tfunction finishMinting() onlyOwner public returns (bool) {\\n\\t\\tmintingFinished = true;\\n\\t\\tMintFinished();\\n\\t\\treturn true;\\n\\t}\\n}\\n\\n/**\\n * @title Burnable Token\\n * @dev Token that can be irreversibly burned (destroyed).\\n */\\ncontract BurnableToken is StandardToken {\\n\\n\\tevent Burn(address indexed burner, uint256 value);\\n\\n\\t/**\\n     * @dev Burns a specific amount of tokens.\\n     * @param _value The amount of token to be burned.\\n     */\\n\\tfunction burn(uint256 _value) public {\\n\\t\\trequire(_value > 0);\\n\\t\\trequire(_value <= balances[msg.sender]);\\n\\t\\t// no need to require value <= totalSupply, since that would imply the\\n\\t\\t// sender's balance is greater than the totalSupply, which *should* be an assertion failure\\n\\n\\t\\taddress burner = msg.sender;\\n\\t\\tbalances[burner] = balances[burner].sub(_value);\\n\\t\\ttotalSupply = totalSupply.sub(_value);\\n\\t\\tBurn(burner, _value);\\n\\t}\\n}\\n\\n/**\\n * @title Pausable\\n * @dev Base contract which allows children to implement an emergency stop mechanism.\\n */\\ncontract Pausable is Ownable {\\n\\tevent Pause();\\n\\tevent Unpause();\\n\\n\\tbool public paused = false;\\n\\n\\n\\t/**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     */\\n\\tmodifier whenNotPaused() {\\n\\t\\trequire(!paused);\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     */\\n\\tmodifier whenPaused() {\\n\\t\\trequire(paused);\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n     * @dev called by the owner to pause, triggers stopped state\\n     */\\n\\tfunction pause() onlyOwner whenNotPaused public {\\n\\t\\tpaused = true;\\n\\t\\tPause();\\n\\t}\\n\\n\\t/**\\n     * @dev called by the owner to unpause, returns to normal state\\n     */\\n\\tfunction unpause() onlyOwner whenPaused public {\\n\\t\\tpaused = false;\\n\\t\\tUnpause();\\n\\t}\\n}\\n\\n/**\\n * @title Pausable token\\n *\\n * @dev StandardToken modified with pausable transfers.\\n **/\\n\\ncontract PausableToken is StandardToken, Pausable {\\n\\n\\tfunction transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\\n\\t\\treturn super.transfer(_to, _value);\\n\\t}\\n\\n\\tfunction transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\\n\\t\\treturn super.transferFrom(_from, _to, _value);\\n\\t}\\n\\n\\tfunction approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\\n\\t\\treturn super.approve(_spender, _value);\\n\\t}\\n\\n\\tfunction increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\\n\\t\\treturn super.increaseApproval(_spender, _addedValue);\\n\\t}\\n\\n\\tfunction decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\\n\\t\\treturn super.decreaseApproval(_spender, _subtractedValue);\\n\\t}\\n}\\n\\n/**\\n * @title RefundVault\\n * @dev This contract is used for storing funds while a crowdsale\\n * is in progress. Supports refunding the money if crowdsale fails,\\n * and forwarding it if crowdsale is successful.\\n */\\ncontract WithdrawVault is Ownable {\\n\\tusing SafeMath for uint256;\\n\\n\\tmapping (address => uint256) public deposited;\\n\\taddress public wallet;\\n\\n\\n\\tfunction WithdrawVault(address _wallet) {\\n\\t\\trequire(_wallet != 0x0);\\n\\t\\twallet = _wallet;\\n\\t}\\n\\n\\tfunction deposit(address investor) onlyOwner payable {\\n\\t\\tdeposited[investor] = deposited[investor].add(msg.value);\\n\\t}\\n\\n\\tfunction close() onlyOwner {\\n\\t\\twallet.transfer(this.balance);\\n\\t}\\n\\n}\\n\\ncontract Migrations {\\n\\taddress public owner;\\n\\tuint public last_completed_migration;\\n\\n\\tmodifier restricted() {\\n\\t\\tif (msg.sender == owner) _;\\n\\t}\\n\\n\\tfunction Migrations() {\\n\\t\\towner = msg.sender;\\n\\t}\\n\\n\\tfunction setCompleted(uint completed) restricted {\\n\\t\\tlast_completed_migration = completed;\\n\\t}\\n\\n\\tfunction upgrade(address new_address) restricted {\\n\\t\\tMigrations upgraded = Migrations(new_address);\\n\\t\\tupgraded.setCompleted(last_completed_migration);\\n\\t}\\n}\\n\\ncontract TokenRecipient {\\n\\n\\tfunction tokenFallback(address sender, uint256 _value, bytes _extraData) returns (bool) {}\\n\\n}\\n\\ncontract FunctionX is MintableToken, BurnableToken, PausableToken {\\n\\n\\tstring public constant name = \\\"Function X\\\";\\n\\tstring public constant symbol = \\\"FX\\\";\\n\\tuint8 public constant decimals = 18;\\n\\n\\tfunction FunctionX() {\\n\\t\\tmint(msg.sender, 1e26 );\\n\\t\\tmint(0x901FCeaF2DC4A7b5c6d699a79DBf8468a29DD873, 1e25);\\n\\t\\tmint(0xEd9dd2a4F4455C0B42b053343F74Af2F926537ae, 1e25);\\n\\t\\tmint(0x14Aab2435DDa3A7b77538731750B49CA7733A65d, 1e25);\\n\\t}\\n\\n\\tfunction transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\\n\\t\\tbool result = super.transferFrom(_from, _to, _value);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tmapping (address => bool) stopReceive;\\n\\n\\tfunction setStopReceive(bool stop) {\\n\\t\\tstopReceive[msg.sender] = stop;\\n\\t}\\n\\n\\tfunction getStopReceive() constant public returns (bool) {\\n\\t\\treturn stopReceive[msg.sender];\\n\\t}\\n\\n\\tfunction transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\\n\\t\\trequire(!stopReceive[_to]);\\n\\t\\tbool result = super.transfer(_to, _value);\\n\\t\\treturn result;\\n\\t}\\n\\n\\n\\tfunction mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\\n\\t\\tbool result = super.mint(_to, _amount);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tfunction burn(uint256 _value) public {\\n\\t\\tsuper.burn(_value);\\n\\t}\\n\\n\\tfunction pause() onlyOwner whenNotPaused public {\\n\\t\\tsuper.pause();\\n\\t}\\n\\n\\tfunction unpause() onlyOwner whenPaused public {\\n\\t\\tsuper.unpause();\\n\\t}\\n\\n\\tfunction transferAndCall(address _recipient, uint256 _amount, bytes _data) {\\n\\t\\trequire(_recipient != address(0));\\n\\t\\trequire(_amount <= balances[msg.sender]);\\n\\n\\t\\tbalances[msg.sender] = balances[msg.sender].sub(_amount);\\n\\t\\tbalances[_recipient] = balances[_recipient].add(_amount);\\n\\n\\t\\trequire(TokenRecipient(_recipient).tokenFallback(msg.sender, _amount, _data));\\n\\t\\tTransfer(msg.sender, _recipient, _amount);\\n\\t}\\n\\n\\tfunction transferERCToken(address _tokenContractAddress, address _to, uint256 _amount) onlyOwner {\\n\\t\\trequire(ERC20(_tokenContractAddress).transfer(_to, _amount));\\n\\t}\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContractAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferERCToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"stop\",\"type\":\"bool\"}],\"name\":\"setStopReceive\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStopReceive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"FunctionX","CompilerVersion":"v0.4.13+commit.0fb4cb1a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}