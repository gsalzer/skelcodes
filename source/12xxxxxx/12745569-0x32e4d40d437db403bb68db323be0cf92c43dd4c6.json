{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n███╗░░██╗███████╗████████╗\r\n████╗░██║██╔════╝╚══██╔══╝\r\n██╔██╗██║█████╗░░░░░██║░░░\r\n██║╚████║██╔══╝░░░░░██║░░░\r\n██║░╚███║██║░░░░░░░░██║░░░\r\n╚═╝░░╚══╝╚═╝░░░░░░░░╚═╝░░░\r\n\r\n██████╗░██████╗░░█████╗░  \r\n██╔══██╗██╔══██╗██╔══██╗  \r\n██████╔╝██████╔╝██║░░██║  \r\n██╔═══╝░██╔══██╗██║░░██║  \r\n██║░░░░░██║░░██║╚█████╔╝  \r\n╚═╝░░░░░╚═╝░░╚═╝░╚════╝░  \r\n\r\n░█████╗░██████╗░██╗░░░██╗██████╗░████████╗░█████╗░\r\n██╔══██╗██╔══██╗╚██╗░██╔╝██╔══██╗╚══██╔══╝██╔══██╗\r\n██║░░╚═╝██████╔╝░╚████╔╝░██████╔╝░░░██║░░░██║░░██║\r\n██║░░██╗██╔══██╗░░╚██╔╝░░██╔═══╝░░░░██║░░░██║░░██║\r\n╚█████╔╝██║░░██║░░░██║░░░██║░░░░░░░░██║░░░╚█████╔╝\r\n░╚════╝░╚═╝░░╚═╝░░░╚═╝░░░╚═╝░░░░░░░░╚═╝░░░░╚════╝░\r\n\r\nhttps://nftprocrypto.com\r\n\r\n𝑇ℎ𝑖𝑠 𝑖𝑠 𝑡ℎ𝑒 𝑟𝑒𝑎𝑙 𝑎𝑟𝑡 𝑓𝑟𝑜𝑚 𝑝𝑟𝑜𝑓𝑒𝑠𝑠𝑖𝑜𝑛𝑎𝑙𝑠 | 𝑁𝐹𝑇 + 𝑅𝐸𝐴𝐿 𝐴𝑅𝑇 = 𝑁𝐹𝑇 𝑃𝑅𝑂 𝐶𝑅𝑌𝑃𝑇𝑂\r\n\r\n*/\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract Context {\r\n   \r\n    constructor () internal { }\r\n \r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ninterface IERC165 {\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract IERC721Receiver {\r\n\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary SafeMath {\r\n  \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^0.5.5;\r\n\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n\r\n        uint256 _value; \r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract ERC165 is IERC165 {\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract ERC721 is Context, ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n\r\n\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n\r\n    mapping (uint256 => address) private _tokenOwner;\r\n\r\n\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n\r\n \r\n    mapping (address => Counters.Counter) private _ownedTokensCount;\r\n\r\n\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    constructor () public {\r\n\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n    }\r\n\r\n\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n\r\n        return _ownedTokensCount[owner].current();\r\n    }\r\n\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n\r\n        return owner;\r\n    }\r\n\r\n\r\n    function approve(address to, uint256 tokenId) public {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        require(to != _msgSender(), \"ERC721: approve to caller\");\r\n\r\n        _operatorApprovals[_msgSender()][to] = approved;\r\n        emit ApprovalForAll(_msgSender(), to, approved);\r\n    }\r\n\r\n\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        \r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _safeTransferFrom(from, to, tokenId, _data);\r\n    }\r\n\r\n\r\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\r\n        _transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    function _safeMint(address to, uint256 tokenId) internal {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\r\n        _mint(to, tokenId);\r\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to].increment();\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[owner].decrement();\r\n        _tokenOwner[tokenId] = address(0);\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    function _burn(uint256 tokenId) internal {\r\n        _burn(ownerOf(tokenId), tokenId);\r\n    }\r\n\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[from].decrement();\r\n        _ownedTokensCount[to].increment();\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n \r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        internal returns (bool)\r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    function _clearApproval(uint256 tokenId) private {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract IERC721Enumerable is IERC721 {\r\n    function totalSupply() public view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256);\r\n}\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract ERC721Enumerable is Context, ERC165, ERC721, IERC721Enumerable {\r\n\r\n    mapping(address => uint256[]) private _ownedTokens;\r\n\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n    uint256[] private _allTokens;\r\n\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\r\n\r\n    constructor () public {\r\n\r\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\r\n        require(index < balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n  \r\n    function tokenByIndex(uint256 index) public view returns (uint256) {\r\n        require(index < totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n        return _allTokens[index];\r\n    }\r\n\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        super._transferFrom(from, to, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(from, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n    }\r\n\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        super._mint(to, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n\r\n        _addTokenToAllTokensEnumeration(tokenId);\r\n    }\r\n\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        super._burn(owner, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\r\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\r\n        _ownedTokensIndex[tokenId] = 0;\r\n\r\n        _removeTokenFromAllTokensEnumeration(tokenId);\r\n    }\r\n\r\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\r\n        return _ownedTokens[owner];\r\n    }\r\n\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\r\n        _ownedTokens[to].push(tokenId);\r\n    }\r\n\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n\r\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; \r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; \r\n        }\r\n\r\n        _ownedTokens[from].length--;\r\n\r\n    }\r\n\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n\r\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId; \r\n        _allTokensIndex[lastTokenId] = tokenIndex; \r\n\r\n\r\n        _allTokens.length--;\r\n        _allTokensIndex[tokenId] = 0;\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract ENSRegistryOwnerI {\r\n    function owner(bytes32 node) public view returns (address);\r\n}\r\n\r\ncontract ENSReverseRegistrarI {\r\n    function setName(string memory name) public returns (bytes32 node);\r\n}\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC721Metadata is Context, ERC165, ERC721, IERC721Metadata {\r\n\r\n    string private _name;\r\n\r\n\r\n    string private _symbol;\r\n\r\n  \r\n    mapping(uint256 => string) private _tokenURIs;\r\n\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n\r\n    constructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n\r\n\r\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\r\n    }\r\n\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n        return _tokenURIs[tokenId];\r\n    }\r\n\r\n\r\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\r\n        _tokenURIs[tokenId] = uri;\r\n    }\r\n\r\n \r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        super._burn(owner, tokenId);\r\n\r\n        // Clear metadata (if any)\r\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\r\n            delete _tokenURIs[tokenId];\r\n        }\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract NFTPROCrypto is ERC721, ERC721Enumerable, ERC721Metadata(\"NFT PRO CRYPTO\", \"NFTPRO\") {\r\n\r\n    string public uribase;\r\n\r\n    address public createControl;\r\n\r\n    address public tokenAssignmentControl;\r\n\t\r\n\tbool public mintingFinished = false;\r\n\r\n    uint256 constant finalSupply= 5000;\r\n\r\n\r\n    constructor(address _createControl, address _tokenAssignmentControl)\r\n    public\r\n    {\r\n        createControl = _createControl;\r\n        tokenAssignmentControl = _tokenAssignmentControl;\r\n        uribase = \"https://nftprocrypto.com/nft/procrypto/meta/\";\r\n \r\n    }\r\n\r\n    modifier onlyCreateControl()\r\n    {\r\n        require(msg.sender == createControl, \"createControl key required for this function.\");\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    modifier onlyTokenAssignmentControl() {\r\n        require(msg.sender == tokenAssignmentControl, \"tokenAssignmentControl key required for this function.\");\r\n        _;\r\n    }\r\n    \r\n\tmodifier requireMinting() {\r\n        require(mintingFinished == false, \"This call only works when minting is not finished.\");\r\n        _;\r\n    }\r\n\r\n\r\n\t\r\n    function totalSupply()\r\n    public view\r\n    returns (uint256) {\r\n        return finalSupply;\r\n    }\r\n\r\n  \r\n    function mintedSupply()\r\n    public view\r\n    returns (uint256) {\r\n        return super.totalSupply();\r\n    }\r\n\r\n\r\n    function create(uint256 _tokenId, address _owner)\r\n    public\r\n    onlyCreateControl\r\n\trequireMinting\r\n    {\r\n       \r\n        require(_tokenId == 0 || _exists(_tokenId.sub(1)), \"Previous token ID has to exist.\");\r\n       \r\n        _mint(_owner, _tokenId);\r\n    }\r\n\r\n\r\n\r\n    function createMulti(uint256 _tokenIdStart, address _owner, uint256 count)\r\n    public\r\n    onlyCreateControl\r\n    requireMinting\r\n    {\r\n        \r\n        require(_tokenIdStart == 0 || _exists(_tokenIdStart.sub(1)), \"Previous token ID has to exist.\");\r\n        for (uint256 i = 0; i < count; i++) {\r\n       \r\n            _mint(_owner, _tokenIdStart + i);\r\n        }\r\n    }\r\n\t\r\n\tfunction finishMinting()\r\n    public\r\n    onlyCreateControl\r\n    {\r\n        mintingFinished = true;\r\n    }\r\n\t\r\n\r\n\r\n\r\n\r\n    function newUriBase(string memory _newUriBase)\r\n    public\r\n    onlyCreateControl\r\n    {\r\n        uribase = _newUriBase;\r\n    }\r\n\r\n\r\n    function tokenURI(uint256 _tokenId)\r\n    external view\r\n    returns (string memory)\r\n    {\r\n        require(_exists(_tokenId), \"Token ID does not exist.\");\r\n        return string(abi.encodePacked(uribase, uint2str(_tokenId)));\r\n    }\r\n\r\n\r\n    function exists(uint256 tokenId) public view returns (bool) {\r\n        return _exists(tokenId);\r\n    }\r\n\r\n\r\n    function uint2str(uint256 inp)\r\n    internal pure\r\n    returns (string memory)\r\n    {\r\n        if (inp == 0) return \"0\";\r\n        uint i = inp;\r\n        uint j = i;\r\n        uint length;\r\n        while (j != 0) {\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n        while (i != 0) {\r\n            bstr[k--] = byte(uint8(48 + i % 10));\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n\r\n    function registerReverseENS(address _reverseRegistrarAddress, string calldata _name)\r\n    external\r\n    onlyTokenAssignmentControl\r\n    {\r\n        require(_reverseRegistrarAddress != address(0), \"need a valid reverse registrar\");\r\n        ENSReverseRegistrarI(_reverseRegistrarAddress).setName(_name);\r\n    }\r\n\r\n\r\n    function rescueToken(IERC20 _foreignToken, address _to)\r\n    external\r\n    onlyTokenAssignmentControl\r\n    {\r\n        _foreignToken.transfer(_to, _foreignToken.balanceOf(address(this)));\r\n    }\r\n\r\n\r\n    function()\r\n    external payable\r\n    {\r\n        revert(\"The contract cannot receive ETH payments.\");\r\n    }\r\n}\r\n\r\n/*\r\n\r\n\r\nLearn more about NFT PRO CRYPTO \r\n\r\nNFT PRO CRYPTO©\r\nWebsite:https://nftprocrypto.com\r\n\r\nSocial Media:\r\nhttps://www.facebook.com/nftprocrypto\r\nhttps://twitter.com/nftprocrypto\r\n\r\n\r\n\r\n\r\n\r\n𝙰𝚞𝚝𝚑𝚘𝚛𝚒𝚣𝚎𝚍 𝚜𝚎𝚕𝚕𝚎𝚛 𝚏𝚘𝚛 𝚝𝚑𝚎 𝚜𝚊𝚕𝚎 𝚘𝚏 𝙽𝙵𝚃\r\n\r\n\r\n░█████╗░██╗░░░░░██╗░░░░░███╗░░░███╗███████╗██████╗░░██████╗░██████╗░░█████╗░██╗░░░██╗██████╗░\r\n██╔══██╗██║░░░░░██║░░░░░████╗░████║██╔════╝██╔══██╗██╔════╝░██╔══██╗██╔══██╗██║░░░██║██╔══██╗\r\n███████║██║░░░░░██║░░░░░██╔████╔██║█████╗░░██║░░██║██║░░██╗░██████╔╝██║░░██║██║░░░██║██████╔╝\r\n██╔══██║██║░░░░░██║░░░░░██║╚██╔╝██║██╔══╝░░██║░░██║██║░░╚██╗██╔══██╗██║░░██║██║░░░██║██╔═══╝░\r\n██║░░██║███████╗███████╗██║░╚═╝░██║███████╗██████╔╝╚██████╔╝██║░░██║╚█████╔╝╚██████╔╝██║░░░░░\r\n╚═╝░░╚═╝╚══════╝╚══════╝╚═╝░░░░░╚═╝╚══════╝╚═════╝░░╚═════╝░╚═╝░░╚═╝░╚════╝░░╚═════╝░╚═╝░░░░░\r\n\r\n░█████╗░░█████╗░██████╗░██████╗░░█████╗░██████╗░░█████╗░████████╗██╗░█████╗░███╗░░██╗\r\n██╔══██╗██╔══██╗██╔══██╗██╔══██╗██╔══██╗██╔══██╗██╔══██╗╚══██╔══╝██║██╔══██╗████╗░██║\r\n██║░░╚═╝██║░░██║██████╔╝██████╔╝██║░░██║██████╔╝███████║░░░██║░░░██║██║░░██║██╔██╗██║\r\n██║░░██╗██║░░██║██╔══██╗██╔═══╝░██║░░██║██╔══██╗██╔══██║░░░██║░░░██║██║░░██║██║╚████║\r\n╚█████╔╝╚█████╔╝██║░░██║██║░░░░░╚█████╔╝██║░░██║██║░░██║░░░██║░░░██║╚█████╔╝██║░╚███║\r\n░╚════╝░░╚════╝░╚═╝░░╚═╝╚═╝░░░░░░╚════╝░╚═╝░░╚═╝╚═╝░░╚═╝░░░╚═╝░░░╚═╝░╚════╝░╚═╝░░╚══╝\r\n\r\n\r\n𝐀𝐋𝐋𝐌𝐄𝐃 𝐆𝐑𝐎𝐔𝐏 𝐂𝐎𝐑𝐏𝐎𝐑𝐀𝐓𝐈𝐎𝐍\r\n\r\n𝔘𝔫𝔦𝔱𝔢𝔡 𝔖𝔱𝔞𝔱𝔢𝔰 𝔬𝔣 𝔄𝔪𝔢𝔯𝔦𝔠𝔞 (𝚄𝚂𝙰)\r\n𝙵𝚕𝚘𝚛𝚒𝚍𝚊 𝚁𝚎𝚐𝚒𝚜𝚝𝚛𝚊𝚝𝚒𝚘𝚗 𝚠𝚠𝚠.𝚍𝚘𝚜.𝚜𝚝𝚊𝚎.𝚏𝚕.𝚞𝚜 𝚁𝚎𝚐𝚒𝚜𝚝𝚛𝚊𝚝𝚒𝚘𝚗 ℙ𝟙𝟛𝟘𝟘𝟘𝟘𝟟𝟜𝟜𝟙𝟟𝟿 | 𝙵𝚎𝚍𝚎𝚛𝚊𝚕 𝚃𝚊𝚡 𝙸𝚍𝚎𝚗𝚝𝚒𝚏𝚒𝚌𝚊𝚝𝚒𝚘𝚗 𝙽𝚞𝚖𝚋𝚎𝚛 (𝙴𝙸𝙽) 𝟛𝟘-𝟘𝟟𝟡𝟞𝟞𝟜𝟘\r\n----------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------\r\n----------------------------------------------------------------\r\n-----------------------------------------------\r\n---------------------------------\r\n----------------------\r\nWebsite:\r\n https://allmedgroup.org/\r\n \r\ninfo@allmedgroup.org\r\n\r\nSocial Media: \r\nhttps://www.facebook.com/allmedgroup/\r\nhttps://twitter.com/allmedgroup\r\nhttps://www.instagram.com/allmedgroup/\r\n\r\n\r\nAʟʟ Rɪɢʜᴛs Rᴇsᴇʀᴠᴇᴅ. AʟʟᴍᴇᴅGʀᴏᴜᴘ Cᴏʀᴘᴏʀᴀᴛɪᴏɴ\r\n\r\n*/","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_createControl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAssignmentControl\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"create\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"createControl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenIdStart\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"createMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newUriBase\",\"type\":\"string\"}],\"name\":\"newUriBase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reverseRegistrarAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"registerReverseENS\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_foreignToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAssignmentControl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uribase\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"NFTPROCrypto","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000013C7c338CE7cc7a8ACa8711c8e706AdB4834383600000000000000000000000013C7c338CE7cc7a8ACa8711c8e706AdB48343836","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://2974277fa45da063327636fa1c7c9ae81837270a3ab47d3c560940515957384b"}]}