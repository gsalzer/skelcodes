{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n\\n/**\\n * @title Address\\n * @dev Check if the address is a contract using eip-1052\\n */\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\n    }\\n}\"},\"Context.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n\\ncontract Context {\\n    constructor () internal { }\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n}\\n\"},\"DextokenFactoryCollateral.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity 0.5.17;\\n\\nimport \\\"./Math.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./DextokenPoolCollateral.sol\\\";\\n\\n\\ncontract DextokenFactoryCollateral {\\n    using SafeMath for uint;\\n\\n    event PoolCreated(address indexed token0, address indexed pair, address indexed creator, uint);\\n\\n    address public owner;\\n    address public feePool;\\n    address public collateral;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e address)) private _allPools;\\n    address [] public allPoolsAddress;\\n\\n    constructor(address token1) public {\\n        owner = msg.sender;\\n        feePool = address(0);\\n        collateral = token1;\\n    }\\n\\n    function createPool(address token0, uint Ct, uint Pt) external returns (address pool) {\\n        require(token0 != address(0), \\u0027createPool: zero address\\u0027);\\n        require(feePool != address(0), \\u0027createPool: feePool not set\\u0027);\\n        require(_allPools[token0][msg.sender] == address(0), \\u0027createPool: user pool exists\\u0027);\\n        bytes memory bytecode = type(DextokenPoolCollateral).creationCode;\\n        bytes32 salt = keccak256(abi.encodePacked(token0, collateral, msg.sender));\\n        /// precompute the address where a contract will be deployed\\n        assembly {\\n            pool := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n        IDextokenPool(pool).initialize(token0, collateral, Ct, Pt);\\n        _allPools[token0][msg.sender] = pool;\\n        allPoolsAddress.push(pool);\\n        emit PoolCreated(token0, pool, msg.sender, allPoolsAddress.length);\\n        return pool;\\n    }\\n\\n    function getFeePool() external view returns (address) {\\n        return feePool;\\n    }\\n\\n    function setFeePool(address _feePool) external {\\n        require(msg.sender == owner, \\\"setFeePool: Forbidden\\\");\\n        feePool = _feePool;\\n    }\\n\\n    function getAllPools() external view returns (address [] memory) {\\n        return allPoolsAddress;\\n    }   \\n}   \"},\"DextokenPoolCollateral.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity 0.5.17;\\n\\nimport \\\"./Math.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./IDextokenPool.sol\\\";\\nimport \\\"./IDextokenFactory.sol\\\";\\nimport \\\"./LPToken.sol\\\";\\n\\n\\ncontract DextokenPoolCollateral is LPToken, IDextokenPool, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint;\\n\\n    /// AMM fee\\n    uint public constant FEE_BASE      = 100; // 1%\\n    uint public constant FEE_FACTOR    = 3;\\n\\n    IDextokenFactory public factory;\\n\\n    /// The collateral token\\n    IERC20 public COLLATERAL;\\n\\n    /// Pooling\\n    uint public totalLiquidity;\\n    IERC20 public token0;\\n\\n    /// Speculative AMM\\n    struct AMM {\\n        uint Ct;\\n        uint Pt;\\n        uint Nt;\\n        uint lastUpdateTime;\\n    }\\n\\n    /// AMM states\\n    AMM private _AMM;\\n\\n    modifier updatePriceTick() {   \\n        _;\\n        /// step the price tick (t+1)\\n        _AMM.lastUpdateTime = _lastPriceTickApplicable();   \\n    }\\n\\n    constructor() public {\\n        factory = IDextokenFactory(msg.sender);\\n        _AMM.lastUpdateTime = 0;\\n        totalLiquidity = 0;\\n    }\\n\\n    function initialize(address _token0, address _token1, uint _Ct, uint _Pt) \\n        external \\n    {\\n        require(msg.sender == address(factory), \\u0027initialize: Forbidden\\u0027);\\n\\n        token0 = IERC20(_token0); \\n        require(_Ct \\u003c= token0.totalSupply(), \\\"initialize: Invalid _Ct\\\");     \\n        \\n        /// snapshot of the pooled token\\n        _AMM.Ct = _Ct;\\n        _AMM.Pt = _Pt;\\n        _AMM.Nt = _AMM.Pt.mul(_AMM.Ct).div(1e18);\\n\\n        /// The collateral token\\n        COLLATERAL = IERC20(_token1);  \\n    }\\n\\n    function deposit(uint amount) \\n        external \\n        nonReentrant\\n        updatePriceTick()\\n    {\\n        require(amount \\u003e 0, \\\"deposit: invalid amount\\\");\\n        uint _totalBalance = getPoolBalance();\\n        address _token0 = address(token0);\\n        uint _Ct = _AMM.Ct.add(amount);\\n        uint _Nt = _AMM.Nt;\\n\\n        // liquidity at price tick (t)\\n        uint spotPrice = getSpotPrice(_Ct, _Nt);\\n        uint liquidity = spotPrice.mul(amount);\\n        require(liquidity \\u003e 0, \\\"deposit: invalid user liquidity\\\");\\n\\n        _totalBalance = _totalBalance.add(amount);\\n        uint _totalLiquidity = totalLiquidity.add(liquidity);\\n\\n        // mint liquidity tokens\\n        uint mintedTokens = _calcLiquidityToken(_totalLiquidity, _totalBalance, liquidity);\\n\\n        /// calculate the virtual collateral tokens at price tick (t)\\n        uint _Mb = COLLATERAL.balanceOf(address(this)).mul(mintedTokens).div(totalSupply().add(mintedTokens));\\n\\n        // move price tick to (t+1) \\n        _AMM.Ct = _Ct;\\n        _AMM.Nt = _Nt.add(_Mb);\\n        totalLiquidity = _totalLiquidity;\\n\\n        // mint liquidity token at price tick (t+1)\\n        _mintLiquidityToken(msg.sender, mintedTokens);\\n        _tokenSafeTransferFrom(_token0, msg.sender, address(this), amount);\\n        emit TokenDeposit(_token0, msg.sender, amount, spotPrice);        \\n    }\\n\\n    function withdraw(uint tokens) \\n        external \\n        nonReentrant\\n        updatePriceTick()\\n    {\\n        require(tokens \\u003e 0, \\\"withdraw: invalid tokens\\\");\\n        require(totalSupply() \\u003e 0, \\\"withdraw: insufficient liquidity\\\");\\n        require(balanceOf(msg.sender) \\u003e= tokens, \\\"withdraw: insufficient tokens\\\");\\n        address _token0 = address(token0);\\n      \\n        // liquidity at price tick (t)\\n        uint amount = liquidityTokenToAmount(tokens);\\n\\n        /// calculate the collateral token shares\\n        uint balance = COLLATERAL.balanceOf(address(this));\\n        uint amountOut = balance.mul(tokens).div(totalSupply());\\n\\n        /// Ensure the amountOut is not more than the balance in the contract.\\n        /// Preventing underflow due to very low values of the balance.        \\n        require(amountOut \\u003c= balance, \\\"withdraw: insufficient ETH balance\\\");\\n\\n        // prepare for price tick (t+1)\\n        uint _Ct = _AMM.Ct;\\n        uint _Nt = _AMM.Nt;\\n        _Ct = _Ct.sub(amount);\\n        _Nt = _Nt.sub(amountOut);\\n\\n        // liquidity at price tick (t+1)        \\n        uint spotPrice = getSpotPrice(_Ct, _Nt);\\n        totalLiquidity = spotPrice.mul(getPoolBalance().sub(amount));\\n\\n        _AMM.Ct = _Ct;\\n        _AMM.Nt = _Nt;\\n\\n        _tokenSafeTransfer(_token0, msg.sender, amount);\\n        _tokenSafeTransfer(address(COLLATERAL), msg.sender, amountOut);\\n\\n        _burnLiquidityToken(msg.sender, tokens);\\n        emit TokenWithdraw(_token0, msg.sender, amount, spotPrice);\\n    }\\n\\n    function swapExactETHForTokens(\\n        uint amountIn,\\n        uint minAmountOut,\\n        uint maxPrice,\\n        uint deadline\\n    )\\n        external \\n        nonReentrant\\n        returns (uint)\\n    {\\n        require(COLLATERAL.balanceOf(msg.sender) \\u003e= amountIn, \\\"swapExactETHForTokens: Insufficient collateral balance\\\");\\n        require(deadline \\u003e _lastPriceTickApplicable(), \\\"swapExactETHForTokens: Invalid transaction\\\");\\n        require(amountIn \\u003e 0, \\\"swapExactETHForTokens: Invalid amountIn\\\");\\n        uint spotPrice;\\n        IERC20 _COLLATERAL = COLLATERAL;\\n\\n        /// the price tick at (t)\\n        /// increase the collateral token supply including interests rate        \\n        {\\n            spotPrice = getSpotPrice(_AMM.Ct, _AMM.Nt.add(amountIn));\\n            require(spotPrice \\u003c= maxPrice, \\\"swapExactETHForTokens: Invalid price slippage\\\");\\n        }\\n\\n        /// check amount out without fees\\n        uint amountOut = amountIn.mul(1e18).div(spotPrice);\\n        require(amountOut \\u003e= minAmountOut, \\\"swapExactETHForTokens: Invalid amountOut\\\");\\n\\n        /// split fees and check exact amount out\\n        uint feeAmountIn = _calcFees(amountIn);\\n        uint exactAmountIn = amountIn.sub(feeAmountIn);\\n        uint exactAmountOut = exactAmountIn.mul(1e18).div(spotPrice);\\n\\n        /// increase the collateral token supply\\n        _AMM.Nt = _AMM.Nt.add(exactAmountIn);\\n        spotPrice = getSpotPrice(_AMM.Ct.sub(exactAmountOut), _AMM.Nt);\\n        totalLiquidity = spotPrice.mul(getPoolBalance().sub(exactAmountOut));\\n\\n        /// transfer the collateral tokens in\\n        _tokenSafeTransferFrom(address(_COLLATERAL), msg.sender, address(this), amountIn);\\n        \\n        /// transfer fees\\n        _tokenSafeTransfer(address(_COLLATERAL), factory.getFeePool(), feeAmountIn);\\n\\n        /// move to the next price tick (t+1)\\n        _withdrawAndTransfer(msg.sender, exactAmountOut);\\n\\n        emit SwapExactETHForTokens(address(this), exactAmountOut, amountIn, spotPrice, msg.sender);\\n        return exactAmountOut;\\n    } \\n\\n    function swapExactTokensForETH(\\n        uint amountIn,\\n        uint minAmountOut,\\n        uint minPrice,\\n        uint deadline\\n    )\\n        external \\n        nonReentrant\\n        returns (uint)\\n    {\\n        require(token0.balanceOf(msg.sender) \\u003e= amountIn, \\\"swapExactTokensForETH: Insufficient user balance\\\");    \\n        require(deadline \\u003e _lastPriceTickApplicable(), \\\"swapExactTokensForETH: Invalid order\\\");\\n        require(amountIn \\u003e 0, \\\"swapExactTokensForETH: Invalid amountIn\\\");\\n        uint _Nt = _AMM.Nt;\\n        IERC20 _COLLATERAL = COLLATERAL;\\n\\n        /// add liquidity at the price tick (t)\\n        uint spotPrice = getSpotPrice(_AMM.Ct.add(amountIn), _Nt);\\n        require(spotPrice \\u003e= minPrice, \\\"swapExactTokensForETH: Invalid price slippage\\\");\\n\\n        /// user receives\\n        uint amountOut = spotPrice.mul(amountIn).div(1e18);\\n        require(_COLLATERAL.balanceOf(address(this)) \\u003e= amountOut, \\\"swapExactTokensForETH: Insufficient collateral liquidity\\\");\\n        require(amountOut \\u003e= minAmountOut, \\\"swapExactTokensForETH: Invalid amountOut\\\");\\n\\n        /// split fees\\n        uint feeAmountOut = _calcFees(amountOut);\\n        uint exactAmountOut = amountOut.sub(feeAmountOut);\\n\\n        /// decrease the collateral token, and add liquidity \\n        /// providers\\u0027 fee shares back to the pool\\n        _AMM.Nt = _Nt.sub(exactAmountOut);\\n\\n        totalLiquidity = spotPrice.mul(getPoolBalance().add(amountIn));\\n\\n        /// move the next price tick (t+1)\\n        _depositAndTransfer(msg.sender, amountIn);\\n\\n        /// transfer the collateral token out\\n        _tokenSafeTransfer(address(_COLLATERAL), msg.sender, exactAmountOut);\\n\\n        emit SwapExactTokensForETH(address(this), exactAmountOut, amountIn, spotPrice, msg.sender);\\n        return exactAmountOut;\\n    }\\n\\n    function getLastUpdateTime() external view returns (uint) {\\n        return _AMM.lastUpdateTime;\\n    }  \\n\\n    function getCirculatingSupply() external view returns (uint) {\\n        return _AMM.Ct;\\n    }    \\n\\n    function getUserbase() external view returns (uint) {\\n        return _AMM.Nt;\\n    }\\n\\n    function getToken() external view returns (address) {\\n        return address(token0);\\n    }\\n\\n    function getTotalLiquidity() external view returns (uint) {\\n        return totalLiquidity.div(1e18);\\n    }  \\n\\n    function liquidityOf(address account) external view returns (uint) {\\n        return balanceOf(account);\\n    }\\n\\n    function liquiditySharesOf(address account) external view returns (uint) {\\n        uint userTokens = balanceOf(account);\\n        if (userTokens == 0) {\\n            return 0;\\n        }\\n        return totalSupply()\\n            .mul(1e18)\\n            .div(userTokens);\\n    }  \\n\\n    function mean() public view returns (uint) {\\n        return _AMM.Nt\\n            .mul(_AMM.Pt);\\n    }\\n\\n    function getPoolBalance() public view returns (uint) {\\n        return token0.balanceOf(address(this));\\n    }\\n\\n    function getPrice() public view returns (uint) {\\n        return _AMM.Nt.mul(1e18).div(_AMM.Ct);\\n    }   \\n\\n    function getSpotPrice(uint _Ct, uint _Nt) public pure returns (uint) {\\n        return _Nt.mul(1e18).div(_Ct);\\n    }\\n\\n    function liquidityTokenToAmount(uint token) public view returns (uint) {\\n        if (totalSupply() == 0) {\\n            return 0;\\n        }        \\n        return getPoolBalance()\\n            .mul(token)\\n            .div(totalSupply());\\n    }  \\n\\n    function liquidityFromAmount(uint amount) public view returns (uint) {\\n        return getPrice().mul(amount); \\n    }\\n\\n    function _depositAndTransfer(address account, uint amount) \\n        internal\\n        updatePriceTick()\\n    {\\n        _AMM.Ct = _AMM.Ct.add(amount);    \\n        _tokenSafeTransferFrom(address(token0), account, address(this), amount);\\n    }\\n\\n    function _withdrawAndTransfer(address account, uint amount) \\n        internal\\n        updatePriceTick()\\n    {\\n        _AMM.Ct = _AMM.Ct.sub(amount);    \\n        _tokenSafeTransfer(address(token0), account, amount);\\n    }\\n    \\n    function _lastPriceTickApplicable() internal view returns (uint) {\\n        return Math.max(block.timestamp, _AMM.lastUpdateTime);\\n    }\\n\\n    function _mintLiquidityToken(address to, uint amount) internal {\\n        _mint(address(this), amount);\\n        _transfer(address(this), to, amount);\\n    }\\n\\n    function _burnLiquidityToken(address from, uint amount) internal {\\n        _transfer(from, address(this), amount);\\n        _burn(address(this), amount);\\n    } \\n\\n    function _calcFees(uint amount) internal pure returns (uint) {\\n        return amount.mul(FEE_FACTOR).div(FEE_BASE);\\n    }\\n\\n    function _calcLiquidityToken(\\n        uint _totalLiquidity, \\n        uint _totalBalance, \\n        uint _liquidity\\n    ) \\n        internal \\n        pure \\n        returns (uint) \\n    {\\n        if (_totalLiquidity == 0) {\\n            return 0;\\n        }    \\n        return _totalBalance\\n            .mul(_liquidity)\\n            .div(_totalLiquidity);\\n    }\\n\\n    function _tokenSafeTransfer(\\n        address token,\\n        address to,\\n        uint amount\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, amount));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\\"_tokenSafeTransfer failed\\\");\\n    }\\n\\n    function _tokenSafeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint amount\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, amount));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\\"_tokenSafeTransferFrom failed\\\");\\n    }                    \\n}\"},\"ERC20.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\n/**\\n * @dev The ERC20 standard implementation.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint;\\n\\n    mapping (address =\\u003e uint) private _balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint)) private _allowances;\\n\\n    uint private _totalSupply;\\n\\n    function totalSupply() public view returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view returns (uint) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint amount) public returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view returns (uint) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint amount) public returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint amount) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint addedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account, uint amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint amount) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _approve(address owner, address spender, uint amount) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n}\\n\"},\"ERC20Detailed.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"},\"IDextokenExchange.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n\\ninterface IDextokenExchange {\\n    event SwapExactAmountOut(\\n        address indexed poolIn, \\n        uint amountSwapIn, \\n        address indexed poolOut, \\n        uint exactAmountOut,\\n        address indexed to\\n    );\\n\\n    event SwapExactAmountIn(\\n        address indexed poolIn, \\n        uint amountSwapIn, \\n        address indexed poolOut, \\n        uint exactAmountOut,\\n        address indexed to\\n    );\\n    \\n\\tfunction swapMaxAmountOut(\\n        address poolIn,\\n        address poolOut, \\n        uint maxAmountOut,\\n        uint deadline\\n    ) external;\\n\\n    function swapExactAmountIn(\\n        address poolIn,\\n        address poolOut, \\n        uint exactAmountIn,\\n        uint deadline\\n    ) external;  \\n}\"},\"IDextokenFactory.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n\\ninterface IDextokenFactory {\\n    function getFeePool() external view returns (address);\\n}\"},\"IDextokenPool.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n\\ninterface IDextokenPool {\\n    event TokenDeposit(\\n        address indexed token, \\n        address indexed account, \\n        uint amount,\\n        uint spotPrice\\n    );\\n\\n    event TokenWithdraw(\\n        address indexed token, \\n        address indexed account, \\n        uint amount,\\n        uint spotPrice\\n    );\\n\\n    event SwapExactETHForTokens(\\n        address indexed poolOut, \\n        uint amountOut, \\n        uint amountIn,\\n        uint spotPrice,\\n        address indexed account\\n    );\\n\\n    event SwapExactTokensForETH(\\n        address indexed poolOut, \\n        uint amountOut, \\n        uint amountIn, \\n        uint spotPrice,\\n        address indexed account\\n    );\\n\\n    /// Speculative AMM\\n    function initialize(address _token0, address _token1, uint _Ct, uint _Pt) external;\\n    function mean() external view returns (uint);\\n    function getLastUpdateTime() external view returns (uint);\\n    function getCirculatingSupply() external view returns (uint);\\n    function getUserbase() external view returns (uint);\\n    function getPrice() external view returns (uint);\\n    function getSpotPrice(uint _Ct, uint _Nt) external pure returns (uint);\\n\\tfunction getToken() external view returns (address);\\n\\n    /// Pool Management\\n    function getPoolBalance() external view returns (uint);    \\n    function getTotalLiquidity() external view returns (uint);\\n    function liquidityOf(address account) external view returns (uint);\\n    function liquiditySharesOf(address account) external view returns (uint);\\n    function liquidityTokenToAmount(uint token) external view returns (uint);\\n    function liquidityFromAmount(uint amount) external view returns (uint);\\n    function deposit(uint amount) external;\\n    function withdraw(uint tokens) external;\\n\\n    /// Trading\\n    function swapExactETHForTokens(\\n        uint amountIn,\\n        uint minAmountOut,\\n        uint maxPrice,\\n        uint deadline\\n    ) external returns (uint);\\n\\n    function swapExactTokensForETH(\\n        uint amountIn,\\n        uint minAmountOut,\\n        uint minPrice,\\n        uint deadline\\n    ) external returns (uint);\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address account) external view returns (uint);\\n    function transfer(address recipient, uint amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function approve(address spender, uint amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\"},\"IWETH.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n\\ninterface IWETH {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function balanceOf(address) external view returns (uint);\\n\\n    function allowance(address, address) external view returns (uint);\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint wad) external;\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function approve(address guy, uint wad) external returns (bool);\\n\\n    function transfer(address dst, uint wad) external returns (bool);\\n\\n    function transferFrom(address src, address dst, uint wad) external returns (bool);\\n}\"},\"LPToken.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity 0.5.17;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\n\\ncontract LPToken is ERC20 {\\n    string public constant name     = \\\"DEXG Liquidity Pool\\\";\\n    string public constant symbol   = \\\"DEXG-LP\\\";\\n    uint8  public constant decimals = 18;\\n}\"},\"Math.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003e= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003c b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"},\"Migrations.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\ncontract Migrations {\\n  address public owner;\\n  uint public last_completed_migration;\\n\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  modifier restricted() {\\n    if (msg.sender == owner) _;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n}\\n\"},\"Owned.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\ncontract Ownable {\\n    address public owner;\\n    address public newOwner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() public {\\n        owner = msg.sender;\\n        newOwner = address(0);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyNewOwner() {\\n        require(msg.sender != address(0));\\n        require(msg.sender == newOwner);\\n        _;\\n    }\\n    \\n    function isOwner(address account) public view returns (bool) {\\n        if(account == owner) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\n    function transferOwnership(address _newOwner) public onlyOwner {\\n        require(_newOwner != address(0));\\n        newOwner = _newOwner;\\n    }\\n\\n    function acceptOwnership() public onlyNewOwner {\\n        emit OwnershipTransferred(owner, newOwner);        \\n        owner = newOwner;\\n        newOwner = address(0);\\n    }\\n}\"},\"Pausable.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\nimport \\\"./Owned.sol\\\";\\n\\n\\ncontract Pausable is Ownable {\\n    event Paused(address account);\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    constructor () public {\\n        _paused = false;\\n    }    \\n\\n    modifier whenNotPaused() {\\n        require(!_paused);\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(_paused);\\n        _;\\n    }\\n\\n    function paused() public view returns (bool) {\\n        return _paused;\\n    }\\n\\n    function pause() public onlyOwner whenNotPaused {\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    function unpause() public onlyOwner whenPaused {\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\\n * available, which can be aplied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n */\\ncontract ReentrancyGuard {\\n    /// @dev counter to allow mutex lock with only one SSTORE operation\\n    uint256 private _guardCounter;\\n\\n    constructor () internal {\\n        // The counter starts at one to prevent changing it from zero to a non-zero\\n        // value, which is a more expensive operation.\\n        _guardCounter = 1;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _guardCounter += 1;\\n        uint256 localCounter = _guardCounter;\\n        _;\\n        require(localCounter == _guardCounter, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint value) internal {\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length \\u003e 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n\\nlibrary SafeMath {\\n    function add(uint a, uint b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n    function sub(uint a, uint b) internal pure returns (uint) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\n        require(b \\u003c= a, errorMessage);\\n        uint c = a - b;\\n\\n        return c;\\n    }\\n    function mul(uint a, uint b) internal pure returns (uint) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n    function div(uint a, uint b) internal pure returns (uint) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint c = a / b;\\n\\n        return c;\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPoolsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Ct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Pt\",\"type\":\"uint256\"}],\"name\":\"createPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllPools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFeePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feePool\",\"type\":\"address\"}],\"name\":\"setFeePool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DextokenFactoryCollateral","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b81d70802a816b5dacba06d708b5acf19dcd436d","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://bd01ccd67dfdd9e4db0d9219bd6b2192d8304a88916bdd8d0d38a03d41612515"}]}