{"status":"1","message":"OK","result":[{"SourceCode":"{\"LkupInterfaces.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.6;\\n\\n// import { DataTypes } from \\\"LkupLibraries.sol\\\";\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  // underlying function is not available for Aave tokens\\n  function underlying (  ) external view returns ( address );\\n\\n  function liquidateBorrow ( address borrower, uint256 repayAmount, address cTokenCollateral ) external returns ( uint256 );\\n  /************\\n   * The mint function transfers an asset into the CompFi protocol, which begins \\n   * accumulating interest based on the current Supply Rate for the asset. \\n   * The user receives a quantity of cTokens equal to the underlying \\n   * tokens supplied, divided by the current Exchange Rate.\\n   * **********/\\n  function mint ( uint256 mintAmount ) external returns ( uint256 );\\n  /**********\\n   * redeem function converts a specified quantity of cTokens into the underlying asset, \\n   * and returns them to the user.\\n   * redeemTokens - numberr of tokens to convert to the underlying token.\\n   * RETURN: 0 on success, otherwise an Error code.\\n   * ********/\\n  function redeem( uint redeemTokens ) external returns ( uint );\\n  \\n  /**\\n   * redeem underlying function converts cTokens into a specified quantity of the \\n   * underlying asset, and returns them to the user.\\n   * redeemAmount - number of underlying tokens desired, depends on the exchange rate\\n   **/\\n    // available only for Compound tokens, like cUSDC or cETH\\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IComptroller {\\n\\n    /**\\n     * @notice Returns whether the given account is entered in the given asset\\n     * @param account The address of the account to check\\n     * @param cToken The cToken to check\\n     * @return True if the account is in the asset, otherwise false.\\n     */\\n  function checkMembership ( address account, address cToken ) external view returns ( bool );\\n  \\n    /**\\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\\n     */\\n  function closeFactorMantissa (  ) external view returns ( uint256 );\\n\\n  function enterMarkets ( address[] memory cTokens ) external returns ( uint256[] memory );\\n\\n  function exitMarket ( address cTokenAddress ) external returns ( uint256 );\\n\\n    /**\\n     * @notice Determine the current account liquidity wrt collateral requirements\\n     * @return ( possible error code ( semi-opaque ),\\n                account liquidity in excess of collateral requirements,\\n     *          account shortfall below collateral requirements )\\n     */\\n  function getAccountLiquidity ( address account ) external view returns ( uint256, uint256, uint256 );\\n\\n  function getAllMarkets (  ) external view returns ( address[] memory );\\n\\n    /**\\n     * @notice Returns the assets an account has entered\\n     * @param account The address of the account to pull assets for\\n     * @return A dynamic list with the assets the account has entered\\n     */\\n  function getAssetsIn ( address account ) external view returns ( address[] memory );\\n\\n  function liquidateBorrowAllowed ( address cTokenBorrowed, address cTokenCollateral, address liquidator, address borrower, uint256 repayAmount ) external returns ( uint256 );\\n\\n  function liquidateBorrowVerify ( address cTokenBorrowed, address cTokenCollateral, address liquidator, address borrower, uint256 actualRepayAmount, uint256 seizeTokens ) external;\\n\\n    /**\\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\\n     */\\n  function liquidationIncentiveMantissa (  ) external view returns ( uint256 );\\n}\\n\\ninterface IUniswapV2Factory {\\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\\n  function allPairs(uint) external view returns (address pair);\\n  function allPairsLength() external view returns (uint);\\n  function feeTo() external view returns (address);\\n  function feeToSetter() external view returns (address);\\n  function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IUniswapV2Pair {\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  function name() external pure returns (string memory);\\n  function symbol() external pure returns (string memory);\\n  function decimals() external pure returns (uint8);\\n  function totalSupply() external view returns (uint);\\n  function balanceOf(address owner) external view returns (uint);\\n  function allowance(address owner, address spender) external view returns (uint);\\n  function approve(address spender, uint value) external returns (bool);\\n  function transfer(address to, uint value) external returns (bool);\\n  function transferFrom(address from, address to, uint value) external returns (bool);\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\\n  function nonces(address owner) external view returns (uint);\\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n  event Mint(address indexed sender, uint amount0, uint amount1);\\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n  event Swap(\\n      address indexed sender,\\n      uint amount0In,\\n      uint amount1In,\\n      uint amount0Out,\\n      uint amount1Out,\\n      address indexed to\\n  );\\n  event Sync(uint112 reserve0, uint112 reserve1);\\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\\n  function factory() external view returns (address);\\n  function token0() external view returns (address);\\n  function token1() external view returns (address);\\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n  function price0CumulativeLast() external view returns (uint);\\n  function price1CumulativeLast() external view returns (uint);\\n  function kLast() external view returns (uint);\\n  function mint(address to) external returns (uint liquidity);\\n  function burn(address to) external returns (uint amount0, uint amount1);\\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n  function skim(address to) external;\\n  function sync() external;\\n}\\n\"},\"PreachersUniSwapLkup.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\n// PreachersUniSwapLkup v1.0.13\\n// Mainnet 0x26a6B97b8e3Dc7Ef801AB063EC415A540C91B656\\n// Kovan 7446 bytes  0x41b120BA589947E364f5123b7BF2dAcDf4E3f61E\\npragma solidity ^0.8.6;\\n\\nimport {IComptroller, IUniswapV2Factory, IUniswapV2Pair, IERC20} from \\\"LkupInterfaces.sol\\\";\\n\\n// https://uniswap.org/docs/v2/smart-contracts/router02/\\n// Same address on Mainnet and Kovan\\naddress constant UNISWAP_ROUTER_ADDRESS = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\naddress constant kUniswapV2Factory = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\\n                                            \\n//address constant kETH = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\naddress constant ETH = address(0);    // preferred by UniSwap\\n\\n//address constant kWETH = address(0xd0A1E359811322d97991E03f863a0C30C2cF029C);           // Kovan\\n//address constant kUnitroller = address( 0x5eAe89DC1C671724A672ff0630122ee834098657 );   // Kovan\\n\\naddress constant kUnitroller = address(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);   // Mainnet\\naddress constant kWETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);         // Mainnet\\n\\n\\ncontract PreachersUniSwapLkup {\\n\\n    IUniswapV2Factory constant uniswapV2Factory = IUniswapV2Factory(kUniswapV2Factory); // same for all networks\\n\\n    function GetPair(address _tokenA, address _tokenB) public view returns(string memory sResp){\\n        \\n        (address token0, address token1) = _tokenA \\u003c _tokenB ?\\n            (_tokenA, _tokenB) : (_tokenB, _tokenA);\\n            \\n        address pairAddress = \\n            IUniswapV2Factory(kUniswapV2Factory).getPair(token0, token1);\\n\\n        uint256 token0Balance = 0;\\n        uint256 token1Balance = 0;\\n        \\n        if (pairAddress != address(0)){\\n            token0Balance = IERC20(token0).balanceOf(pairAddress);\\n            token1Balance = IERC20(token1).balanceOf(pairAddress);\\n        }\\n        \\n        // Pairaddress: xxx, tokenA balance: xxx, tokenB balance: xxx\\n        string memory sResp1 = joinStr(joinStr(\\\"Pair address: \\\", address2str(pairAddress)), \\\", Token A: \\\");\\n        \\n        string memory sResp2 = joinStr(joinStr(address2str(_tokenA), \\\" : \\\"),\\n            uint2str(_tokenA == token0 ? token0Balance : token1Balance));\\n            \\n        string memory sResp3 = joinStr(joinStr(joinStr(\\\", Token B: \\\", address2str(_tokenB)), \\\" : \\\"),\\n            uint2str(_tokenB == token0 ? token0Balance : token1Balance));\\n            \\n        sResp = joinStr(joinStr(sResp1, sResp2), sResp3);\\n\\t}\\n\\n    function GetTriPair(address _tokenBorrow, address _tokenPay) public pure returns(string memory sResp) {\\n        \\n        (address token0, address token1) = _tokenBorrow \\u003c kWETH ?\\n            (_tokenBorrow, kWETH) : (kWETH, _tokenBorrow);\\n        address borrowPairAddress = GetUniPairAddress(token0, token1);\\n        \\n        \\n        (token0, token1) = _tokenPay \\u003c kWETH ?\\n            (_tokenPay, kWETH) : (kWETH, _tokenPay);\\n        address payPairAddress = GetUniPairAddress(token0, token1);\\n        \\n        sResp = joinStr(\\\"Borrow: \\\",joinStr(joinStr(address2str(borrowPairAddress), \\\", Pay: \\\"),\\n            address2str(payPairAddress)));\\n    }\\n\\n    function CreateTriPair(address tokenA, address tokenB)\\n        public  returns(string memory sResp){\\n            \\n        // Does _tokenA =\\u003e kWETH pair exist?\\n        (address token0, address token1) = tokenA \\u003c kWETH ?\\n            (tokenA, kWETH) : (kWETH, tokenA);\\n        \\n        address PairAddressA = uniswapV2Factory.getPair(token0, token1);\\n        if (PairAddressA == address(0)){\\n            PairAddressA = uniswapV2Factory.createPair(token0, token1);\\n        }\\n        \\n        (token0, token1) = tokenB \\u003c kWETH ?\\n            (tokenB, kWETH) : (kWETH, tokenB);\\n        \\n        address PairAddressB = uniswapV2Factory.getPair(token0, token1);\\n        if (PairAddressB == address(0)){\\n            PairAddressB = uniswapV2Factory.createPair(token0, token1);\\n        }\\n        \\n        // emit PairAddr(borrowPairAddress, payPairAddress);\\n        sResp = joinStr(joinStr(joinStr(\\\"PairA: \\\", address2str(PairAddressA)), \\\", PairB: \\\"),\\n            address2str(PairAddressB));\\n        \\n    }\\n    \\n    function getReserves(address tokenA, address tokenB) external view \\n        returns(string memory sResp){\\n            \\n        // return \\\"tokenA: reservesA, tokenB: reservesB\\\"\\n        if (tokenA == kWETH || tokenB == kWETH){\\n            (address token0, address token1) = tokenA \\u003c tokenB ?\\n                (tokenA, tokenB) : (tokenB, tokenA);\\n            \\n            (uint256 reserves0, uint reserves1) =\\n                getReserves(kUniswapV2Factory, token0, token1);\\n\\n            sResp = joinStr(\\\"Token A - \\\",joinStr(joinStr(joinStr(address2str(tokenA), \\\" reserves: \\\"),\\n                uint2str(token0 == tokenA ? reserves0 : reserves1)), \\\", Token B - \\\"));\\n            sResp = joinStr(sResp, joinStr(joinStr(address2str(tokenB), \\\" reserves: \\\"),\\n                uint2str(token0 == tokenB ? reserves0 : reserves1)));\\n            \\n        } else {\\n\\n            (address token0, address token1) = tokenA \\u003c kWETH ?\\n                (tokenA, kWETH) : (kWETH, tokenA);\\n            \\n            (uint256 reserves0, uint reserves1) =\\n                getReserves(kUniswapV2Factory, token0, token1);\\n\\n            sResp = joinStr(\\\"Token A - \\\",joinStr(joinStr(joinStr(address2str(tokenA), \\\" reserves: \\\"),\\n                uint2str(token0 == tokenA ? reserves0 : reserves1)), \\\", Token B - \\\"));\\n\\n            (token0, token1) = tokenB \\u003c kWETH ?\\n                (tokenB, kWETH) : (kWETH, tokenB);\\n            \\n            (reserves0, reserves1) =\\n                getReserves(kUniswapV2Factory, token0, token1);\\n\\n            sResp = joinStr(sResp, joinStr(joinStr(address2str(tokenB), \\\" reserves: \\\"),\\n                uint2str(token0 == tokenA ? reserves0 : reserves1)));\\n        }\\n    }\\n    \\n    function GetUniPairAddress(address token0, address token1) public pure returns(address _pair){\\n        \\n        address PairAddress = address(uint160(uint(keccak256(abi.encodePacked(\\n            hex\\u0027ff\\u0027,\\n            kUniswapV2Factory,\\n            keccak256(abi.encodePacked(address(token0), address(token1))),\\n            hex\\u002796e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\u0027\\n         )))));\\n        return PairAddress;\\n    }\\n    \\n    function GetTriPairSupply(address _token1, address _token2)\\n        public view returns(string memory sResp){\\n        \\n        uint256 Supply1 = 0;\\n        uint256 Supply2 = 0;\\n\\n        (address token0, address token1) = _token1 \\u003c kWETH ?\\n            (_token1, kWETH) : (kWETH, _token1);\\n        address borrowPairAddress = GetUniPairAddress(token0, token1);\\n        if (borrowPairAddress != address(0)){\\n            IUniswapV2Pair Pair1 = IUniswapV2Pair(borrowPairAddress);\\n\\n            Supply1 = Pair1.totalSupply();\\n        } else {\\n            Supply1 = 99;\\n        }\\n        \\n        (token0, token1) = _token2 \\u003c kWETH ?\\n            (_token2, kWETH) : (kWETH, _token2);\\n        address payPairAddress = GetUniPairAddress(token0, token1);\\n        if (payPairAddress != address(0)){\\n            IUniswapV2Pair Pair2 = IUniswapV2Pair(payPairAddress);\\n\\n            Supply2 = Pair2.totalSupply();\\n        } else {\\n            Supply2 = 99;\\n        }\\n        sResp = joinStr(joinStr(\\\"Supply1 \\\", uint2str(Supply1)),joinStr(\\\", Supply2 \\\", uint2str(Supply2)));\\n    }\\n    \\n    function GetTriPairBalance(address _token1, address _token2) public view\\n        returns (string memory sResp){\\n        \\n        uint256 Balance1 = 0;\\n        uint256 Balance2 = 0;\\n        \\n        (address token0, address token1) = _token1 \\u003c kWETH ?\\n            (_token1, kWETH) : (kWETH, _token1);\\n        address borrowPairAddress = GetUniPairAddress(token0, token1);\\n        if (borrowPairAddress == address(0)){\\n            Balance1 = 99;\\n        } else {\\n            Balance1 = IERC20(_token1).balanceOf(borrowPairAddress);\\n        }\\n        \\n        (token0, token1) = _token2 \\u003c kWETH ?\\n            (_token2, kWETH) : (kWETH, _token2);\\n        address payPairAddress = GetUniPairAddress(token0, token1);\\n        if (payPairAddress == address(0)){\\n            Balance2 = 99;\\n        } else {\\n            Balance2 = IERC20(_token2).balanceOf(payPairAddress);\\n        }\\n\\n        sResp = joinStr(joinStr(joinStr(\\\"Balance1: \\\",uint2str(Balance1)), \\\", Balance2: \\\"),\\n            uint2str(Balance2));\\n    }\\n    \\n    function AccountLiquidity(address _account) public view returns (string memory sResp){\\n\\n        IComptroller cTroll = IComptroller(kUnitroller);\\n        \\n        // possible error code (semi-opaque),\\n        //        account liquidity in excess of collateral requirements,\\n        //        account shortfall below collateral requirements)\\n        (uint errorCode, uint excess, uint shortfall) = cTroll.getAccountLiquidity(address(_account));\\n        \\n        sResp = joinStr(joinStr(joinStr(joinStr(joinStr(\\\"Error: \\\", uint2str(errorCode)), \\\", Excess: \\\"),\\n            uint2str(excess)), \\\", Shortfall: \\\"), uint2str(shortfall));\\n            \\n        if (errorCode == 0 \\u0026\\u0026 excess == 0 \\u0026\\u0026 shortfall \\u003e 0){\\n            sResp = joinStr(sResp, \\\" == LIQUIDATE\\\");\\n        }\\n\\n\\t}\\n\\n    \\n    function uint2str(uint256 _i) internal pure returns (string memory str){\\n        if (_i == 0){\\n            return \\\"0\\\";\\n        }\\n        \\n        uint256 j = _i;\\n        uint256 length;\\n        \\n        while (j != 0){\\n            length++;\\n            j /= 10;\\n        }\\n        \\n        bytes memory bstr = new bytes(length);\\n        uint256 k = length;\\n        j = _i;\\n        \\n        while (j != 0){\\n            bstr[--k] = bytes1(uint8(48 + j % 10));\\n            j /= 10;\\n        }\\n        \\n        str = string(bstr);\\n    }\\n    \\n    function joinStr(string memory sm0, string memory sm1) \\n        internal pure returns (string memory)\\n    {\\n        return string(abi.encodePacked(sm0, sm1));\\n    }\\n    \\n    function address2str(address x) internal pure returns (string memory) {\\n        bytes memory s = new bytes(40);\\n        for (uint i = 0; i \\u003c 20; i++) {\\n            bytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));\\n            bytes1 hi = bytes1(uint8(b) / 16);\\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n            s[2*i] = char(hi);\\n            s[2*i+1] = char(lo);\\n        }\\n        \\n        return string(s);\\n        \\n    }\\n\\n    function char(bytes1 b) internal pure returns (bytes1 c) {\\n        if (uint8(b) \\u003c 10) return bytes1(uint8(b) + 0x30);\\n        else return bytes1(uint8(b) + 0x57);\\n    }\\n\\n    // from UniswapV2Library\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(address factory, address tokenA, address tokenB) \\n        internal view returns (uint reserveA, uint reserveB) {\\n            \\n        address token0 = tokenA \\u003c tokenB ? tokenA : tokenB;\\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n    \\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n        (address token0, address token1) = tokenA \\u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        pair = address( uint160( uint( keccak256( abi.encodePacked(\\n            hex\\u0027ff\\u0027,\\n            factory,\\n            keccak256( abi.encodePacked( address( token0 ), address( token1 ) ) ),\\n            hex\\u002796e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\u0027\\n            ) ) ) ) );\\n            \\n        /*******************\\n        pair = address(uint(keccak256(abi.encodePacked(\\n                hex\\u0027ff\\u0027,\\n                factory,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                hex\\u002796e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\u0027 // init code hash\\n            ))));\\n        *******************/\\n    }\\n\\n    /*****************************\\n     * @notice Checks if the liquidation should be allowed to occur\\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\n     * @param borrower The address of the borrower\\n     * @param repayAmount The amount of underlying being repaid\\n    ******************/\\n    function isLiquidationAllowed(address lqdtToken, address cTokenCollateral, address account, uint256 lqdtAmount)\\n    public {\\n        \\n        IComptroller cTroll = IComptroller(kUnitroller);\\n\\n        //uint allowed = cTroll.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\\n        emit LqdtAllowed(cTroll.liquidateBorrowAllowed(lqdtToken, address(cTokenCollateral),\\n            address(this), account, lqdtAmount));\\n    }\\n    event LqdtAllowed(uint isAllowed);\\n \\n\\n}\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"isAllowed\",\"type\":\"uint256\"}],\"name\":\"LqdtAllowed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"AccountLiquidity\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"sResp\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"CreateTriPair\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"sResp\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"}],\"name\":\"GetPair\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"sResp\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenBorrow\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenPay\",\"type\":\"address\"}],\"name\":\"GetTriPair\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"sResp\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token2\",\"type\":\"address\"}],\"name\":\"GetTriPairBalance\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"sResp\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token2\",\"type\":\"address\"}],\"name\":\"GetTriPairSupply\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"sResp\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"name\":\"GetUniPairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"sResp\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lqdtToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cTokenCollateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lqdtAmount\",\"type\":\"uint256\"}],\"name\":\"isLiquidationAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PreachersUniSwapLkup","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8b10c0c9ac593d66408aa850ccc75c059a0d06d0ebb687d343d8d4b0696dc66d"}]}