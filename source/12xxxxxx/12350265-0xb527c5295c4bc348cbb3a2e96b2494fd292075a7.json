{"status":"1","message":"OK","result":[{"SourceCode":"// File contracts/swappers/SushiSwapMultiExactSwapper.sol\r\n// SPDX-License-Identifier: MIT AND GPL-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n// solhint-disable avoid-low-level-calls\r\n\r\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.1\r\ninterface IERC20 {\r\n\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.1\r\n\r\nlibrary BoringERC20 {\r\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\r\n\r\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\r\n    /// Reverts on a failed transfer.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param to Transfer tokens to.\r\n    /// @param amount The token amount.\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.1\r\n\r\n/// @notice A library for performing overflow-/underflow-safe math,\r\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\r\nlibrary BoringMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\r\n    }\r\n}\r\n\r\n// File @sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol@v1.4.2\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File contracts/libraries/UniswapV2Library.sol\r\n\r\nlibrary UniswapV2Library {\r\n    using BoringMath for uint256;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB,\r\n        bytes32 pairCodeHash\r\n    ) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        hex\"ff\",\r\n                        factory,\r\n                        keccak256(abi.encodePacked(token0, token1)),\r\n                        pairCodeHash // init code hash\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB,\r\n        bytes32 pairCodeHash\r\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\r\n        (address token0, ) = sortTokens(tokenA, tokenB);\r\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB, pairCodeHash)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n    \r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountOut) {\r\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\r\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\r\n        uint256 amountInWithFee = amountIn.mul(997);\r\n        uint256 numerator = amountInWithFee.mul(reserveOut);\r\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(\r\n        address factory,\r\n        uint256 amountIn,\r\n        address[] memory path,\r\n        bytes32 pairCodeHash\r\n    ) internal view returns (uint256[] memory amounts) {\r\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\r\n        amounts = new uint256[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint256 i; i < path.length - 1; i++) {\r\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1], pairCodeHash);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n    \r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(address factory, uint amountOut, address[] memory path, bytes32 pairCodeHash) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint i = path.length - 1; i > 0; i--) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i], pairCodeHash);\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}\r\n\r\n// File @sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol@v1.0.2\r\n\r\ninterface IBentoBoxV1 {\r\n    function deposit(\r\n        IERC20 token_,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\r\n\r\n    function toAmount(\r\n        IERC20 token,\r\n        uint256 share,\r\n        bool roundUp\r\n    ) external view returns (uint256 amount);\r\n    \r\n    function toShare(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        bool roundUp\r\n    ) external view returns (uint256 share);\r\n    \r\n    function transfer(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 share\r\n    ) external;\r\n\r\n    function withdraw(\r\n        IERC20 token_,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256 amountOut, uint256 shareOut);\r\n}\r\n\r\n// File contracts/swappers/SushiSwapMultiSwapper.sol\r\n\r\ncontract SushiSwapMultiExactSwapper {\r\n    using BoringERC20 for IERC20;\r\n    using BoringMath for uint256;\r\n\r\n    address private immutable factory;\r\n    IBentoBoxV1 private immutable bentoBox;\r\n    bytes32 private immutable pairCodeHash;\r\n\r\n    constructor(\r\n        address _factory,\r\n        IBentoBoxV1 _bentoBox,\r\n        bytes32 _pairCodeHash\r\n    ) public {\r\n        factory = _factory;\r\n        bentoBox = _bentoBox;\r\n        pairCodeHash = _pairCodeHash;\r\n    }\r\n\r\n    function getInputAmount(\r\n        IERC20 tokenOut,\r\n        address[] memory path,\r\n        uint256 shareOut\r\n    ) public view returns (uint256 amountIn) {\r\n        uint256 amountOut = bentoBox.toAmount(tokenOut, shareOut, true);\r\n        uint256[] memory amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path, pairCodeHash);\r\n        amountIn = amounts[0];\r\n    }\r\n\r\n    function swap(\r\n        IERC20 tokenIn,\r\n        IERC20 tokenOut,\r\n        uint256 amountMaxIn,\r\n        address path1,\r\n        address path2,\r\n        address to,\r\n        uint256 shareIn,\r\n        uint256 shareOut\r\n    ) external returns (uint256) {\r\n        address[] memory path;\r\n        if (path2 == address(0)) {\r\n            if (path1 == address(0)) {\r\n                path = new address[](2);\r\n                path[1] = address(tokenOut);\r\n            } else {\r\n                path = new address[](3);\r\n                path[1] = path1;\r\n                path[2] = address(tokenOut);\r\n            }\r\n        } else {\r\n            path = new address[](4);\r\n            path[1] = path1;\r\n            path[2] = path2;\r\n            path[3] = address(tokenOut);\r\n        }\r\n        path[0] = address(tokenIn);\r\n        uint256 amountIn = getInputAmount(tokenOut, path, shareOut);\r\n        require(amountIn <= amountMaxIn, \"insufficient-amount-in\");\r\n        uint256 difference = shareIn.sub(bentoBox.toShare(tokenIn, amountIn, true));\r\n        bentoBox.withdraw(tokenIn, address(this), UniswapV2Library.pairFor(factory, path[0], path[1], pairCodeHash), amountIn, 0);\r\n        _swapExactTokensForTokens(amountIn, path, address(bentoBox));\r\n        bentoBox.transfer(tokenIn, address(this), to, difference);\r\n        bentoBox.deposit(tokenOut, address(bentoBox), to, 0, shareOut);\r\n        return (difference);\r\n    }\r\n\r\n    // Swaps an exact amount of tokens for another token through the path passed as an argument\r\n    // Returns the amount of the final token\r\n    function _swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        address[] memory path,\r\n        address to\r\n    ) internal {\r\n        uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path, pairCodeHash);\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(\r\n        uint256[] memory amounts,\r\n        address[] memory path,\r\n        address _to\r\n    ) internal virtual {\r\n        for (uint256 i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0, ) = UniswapV2Library.sortTokens(input, output);\r\n            uint256 amountOut = amounts[i + 1];\r\n            (uint256 amount0Out, uint256 amount1Out) = input == token0 ? (uint256(0), amountOut) : (amountOut, uint256(0));\r\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2], pairCodeHash) : _to;\r\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output, pairCodeHash)).swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"contract IBentoBoxV1\",\"name\":\"_bentoBox\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_pairCodeHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"shareOut\",\"type\":\"uint256\"}],\"name\":\"getInputAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMaxIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"path1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"path2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shareIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shareOut\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SushiSwapMultiExactSwapper","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c0aee478e3658e2610c5f7a4a2e1777ce9e4f2ac000000000000000000000000f5bce5077908a1b7370b9ae04adc565ebd643966e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ed97890dc9bc79bc049915ab8e229e6d9bac9a99f96d16153e4f84d58b510e11"}]}