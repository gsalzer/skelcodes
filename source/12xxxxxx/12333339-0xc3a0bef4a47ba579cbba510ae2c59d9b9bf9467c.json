{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.8.2;\r\n\r\n/**\r\n * This file is part of the 1st Solidity Gas Golfing Contest.\r\n *\r\n * This work is licensed under Creative Commons Attribution ShareAlike 3.0.\r\n * https://creativecommons.org/licenses/by-sa/3.0/\r\n *\r\n * Author: Greg Hysen (hyszeth.eth)\r\n * Date: June 2018\r\n * Description: A simple hash table with open-addressing and linear probing\r\n *              is used to filter out duplicate array elements. The unique\r\n *              array is generated in-place, with distinct elements overwriting\r\n *              duplicates. At the end of the algorithm, these values are\r\n *              transposed to a separate array with a length equal to the number\r\n *              of unique elements.\r\n */\r\ncontract UniqueAddressesHelper {\r\n    // Convert uint256 > address\r\n    function toUint(address val) internal pure returns (uint256 addr) {\r\n        assembly {\r\n            addr := add(val, 32)\r\n        }\r\n    }\r\n\r\n    // Convert address > uint256\r\n    function toAddr(uint256 val) internal pure returns (address addr) {\r\n        assembly {\r\n            addr := add(val, 32)\r\n        }\r\n    }\r\n\r\n    // Hash table size.\r\n    // - Size should be prime for a good average distribution.\r\n    // - Space is preallocated, for efficiency.\r\n    // - Specific value was selected based on gas and average # of collisions.\r\n    uint256 constant HASH_TABLE_SIZE = 313;\r\n\r\n    // A randomly generated offset that is added to each entry in the hash table.\r\n    // Rather than storing additional information on occupancy, we add this offset to each entry.\r\n    // Since the table is initially zeroed out, we consider `0` to mean unoccupied.\r\n    uint256 constant RAND_OFFSET =\r\n        0x613c12789c3f663a544355053c9e1e25d50176d60796a155f553aa0f8445ee66;\r\n\r\n    function uniqueAddresses(address[] memory input)\r\n        public\r\n        pure\r\n        returns (address[] memory ret)\r\n    {\r\n        // Base cases\r\n        uint256 inputLength = input.length;\r\n        if (inputLength == 0 || inputLength == 1) return input;\r\n\r\n        // Fast forward to second unique character, if one exists.\r\n        uint256 firstCharacter = toUint(input[0]);\r\n        uint256 i = 1;\r\n        while (toUint(input[i]) == firstCharacter) {\r\n            if (++i != inputLength) continue;\r\n            // The entire array was composed of a single value.\r\n            ret = createUniqueArray(input, 1);\r\n            return ret;\r\n        }\r\n\r\n        // Run uniquify on remaining elements.\r\n        // `i` is the index of the first mismatch.\r\n        ret = uniquifyPrivate(input, inputLength, firstCharacter, i);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * @dev A simple hash table with open-addressing and linear probing\r\n     *      is used to filter out duplicate array elements. The unique\r\n     *      array is generated in-place, with distinct elements overwriting\r\n     *      duplicates. At the end of the algorithm, these values are\r\n     *      transposed to a separate array with a length equal to the number\r\n     *      of unqiue elements.\r\n     *\r\n     * @param input The list of integers to uniquify.\r\n     * @param inputLength The length of `input`.\r\n     * @param current First element in `input`.\r\n     * @param i Where to start search.\r\n     * @return The input list, with any duplicate elements removed.\r\n     */\r\n    function uniquifyPrivate(\r\n        address[] memory input,\r\n        uint256 inputLength,\r\n        uint256 current,\r\n        uint256 i\r\n    ) private pure returns (address[] memory) {\r\n        // Create hash table; initialized to all zeroes.\r\n        uint256[HASH_TABLE_SIZE] memory hashTable;\r\n        // Record first element in `hashTable`\r\n        uint256 hashKey = current % HASH_TABLE_SIZE;\r\n        uint256 hashValue = current + RAND_OFFSET;\r\n        hashTable[hashKey] = hashValue;\r\n        // Unique elements overwrite duplicates in `input`.\r\n        uint256 uniqueIndex = 1;\r\n        // Holds the current hash value while searching the hash table.\r\n        uint256 queriedHashValue;\r\n\r\n        // Create unique list.\r\n        while (i != inputLength) {\r\n            // One the right side of `==`, `current` resolves\r\n            // to the value it had on the previous loop iteration.\r\n            if ((current = toUint(input[i])) == current) {\r\n                ++i;\r\n                continue;\r\n            }\r\n\r\n            // Check if current `input` element is unique.\r\n            hashValue = current + RAND_OFFSET;\r\n            if (\r\n                (queriedHashValue = hashTable[\r\n                    (hashKey = current % HASH_TABLE_SIZE)\r\n                ]) == 0\r\n            ) {\r\n                // Current element is unique.\r\n                // Move value to its correct position in `input` and record in hash table.\r\n                if (uniqueIndex != i++) input[uniqueIndex] = toAddr(current);\r\n                uniqueIndex++;\r\n                hashTable[hashKey] = hashValue;\r\n                continue;\r\n            }\r\n\r\n            // We know `hashKey` exists in `hashTable`, meaning this value\r\n            // is either a duplcicate or we have a hash collision.\r\n            while (queriedHashValue != hashValue) {\r\n                // Calculate next key\r\n                hashKey = (hashKey + 1) % HASH_TABLE_SIZE;\r\n                // If non-zero, keep searching.\r\n                if ((queriedHashValue = hashTable[(hashKey)]) != 0) {\r\n                    continue;\r\n                }\r\n                // False positive, this element is unique.\r\n                // Move value to its correct position in `input` and record in hash table.\r\n                if (uniqueIndex != i) input[uniqueIndex] = toAddr(current);\r\n                uniqueIndex++;\r\n                hashTable[hashKey] = hashValue;\r\n                break;\r\n            }\r\n\r\n            // We found a duplicate element. Increment index into `input`.\r\n            ++i;\r\n        }\r\n\r\n        // If all elements were unique, simply return `input`.\r\n        // Otherwise, transpose the unique list to its own array.\r\n        if (i == uniqueIndex) return input;\r\n        return createUniqueArray(input, uniqueIndex);\r\n    }\r\n\r\n    function createUniqueArray(address[] memory input, uint256 uniqueLength)\r\n        private\r\n        pure\r\n        returns (address[] memory ret)\r\n    {\r\n        // Copy in groups of 10 to save gas.\r\n        ret = new address[](uniqueLength);\r\n        uint256 max = (uniqueLength / 10) * 10;\r\n        uint256 i;\r\n        while (i != max) {\r\n            ret[i++] = input[i];\r\n            ret[i++] = input[i];\r\n            ret[i++] = input[i];\r\n            ret[i++] = input[i];\r\n            ret[i++] = input[i];\r\n            ret[i++] = input[i];\r\n            ret[i++] = input[i];\r\n            ret[i++] = input[i];\r\n            ret[i++] = input[i];\r\n            ret[i++] = input[i];\r\n        }\r\n        while (i != uniqueLength) ret[i++] = input[i];\r\n        return ret;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"input\",\"type\":\"address[]\"}],\"name\":\"uniqueAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"ret\",\"type\":\"address[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"UniqueAddressesHelper","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://13d67821fe918456978092cdc46dfe6601537a82416baf09d7e51967ef9d371a"}]}