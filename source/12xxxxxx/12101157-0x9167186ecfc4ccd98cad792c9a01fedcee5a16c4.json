{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/tepnik/Desktop/swaps2/contracts/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.6;\\n\\n/**\\n * @title ERC20 interface without bool returns\\n * @dev see https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external;\\n\\n    function approve(address spender, uint256 value) external;\\n\\n    function transferFrom(address from, address to, uint256 value) external;\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"/home/tepnik/Desktop/swaps2/contracts/ISwaps.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.7;\\n\\ninterface ISwaps {\\n    function createOrder(\\n        address _baseAddress,\\n        address _quoteAddress,\\n        uint _baseLimit,\\n        uint _quoteLimit,\\n        uint _expirationTimestamp,\\n        address _baseOnlyInvestor,\\n        uint _minBaseInvestment,\\n        uint _minQuoteInvestment,\\n        address _brokerAddress,\\n        uint _brokerBasePercent,\\n        uint _brokerQuotePercent\\n    ) external payable returns(bytes32 _id);\\n\\n    function deposit(bytes32 _id, address _token, uint _amount)\\n        external\\n        payable;\\n\\n    function cancel(bytes32 _id) external;\\n\\n    function refund(bytes32 _id, address _token) external;\\n}\\n\"\r\n    },\r\n    \"/home/tepnik/Desktop/swaps2/contracts/Swaps.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.7;\\n\\nimport \\\"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/ownership/Ownable.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ISwaps.sol\\\";\\nimport \\\"./Vault.sol\\\";\\n\\ncontract Swaps is Ownable, ISwaps, ReentrancyGuard {\\n    using SafeMath for uint;\\n\\n    uint public MAX_INVESTORS = 10;\\n\\n    uint256 public feeAmount;\\n    address payable public feeAddress;\\n\\n    Vault public vault;\\n    //     id          whiteAddr\\n    mapping(bytes32 => address) public baseOnlyInvestor;\\n    //     id          owner\\n    mapping(bytes32 => address) public owners;\\n    //     id          baseAddr\\n    mapping(bytes32 => address) public baseAddresses;\\n    //     id          quoteAddr\\n    mapping(bytes32 => address) public quoteAddresses;\\n    //     id          expire\\n    mapping(bytes32 => uint) public expirationTimestamps;\\n    //     id          swapped?\\n    mapping(bytes32 => bool) public isSwapped;\\n    //     id          cancelled?\\n    mapping(bytes32 => bool) public isCancelled;\\n    //      id                base/quote  limit\\n    mapping(bytes32 => mapping(address => uint)) public limits;\\n    //      id                base/quote  raised\\n    mapping(bytes32 => mapping(address => uint)) public raised;\\n    //      id                base/quote  investors\\n    mapping(bytes32 => mapping(address => address[])) public investors;\\n    //      id                base/quote         investor    amount\\n    mapping(bytes32 => mapping(address => mapping(address => uint))) public investments;\\n    //      id                base/quote  minLimit\\n    mapping(bytes32 => mapping(address => uint)) public minInvestments;\\n    //      id         brokers\\n    mapping(bytes32 => address[]) public brokers;\\n    //      id                base/quote         broker      percent\\n    mapping(bytes32 => mapping(address => mapping(address => uint))) public brokerPercents;\\n\\n    uint public myWishBasePercent;\\n    uint public myWishQuotePercent;\\n    address public myWishAddress;\\n\\n    modifier onlyInvestor(bytes32 _id, address _token) {\\n        require(\\n            _isInvestor(_id, _token, msg.sender),\\n            \\\"Swaps: Allowed only for investors\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyWhenVaultDefined() {\\n        require(address(vault) != address(0), \\\"Swaps: Vault is not defined\\\");\\n        _;\\n    }\\n\\n    modifier onlyOrderOwner(bytes32 _id) {\\n        require(msg.sender == owners[_id], \\\"Swaps: Allowed only for owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyWhenOrderExists(bytes32 _id) {\\n        require(owners[_id] != address(0), \\\"Swaps: Order doesn't exist\\\");\\n        _;\\n    }\\n\\n    modifier hasFeeAndTransferIt {\\n        require(\\n            msg.value == feeAmount,\\n            \\\"Swaps: Not enough fee\\\"\\n        );\\n        feeAddress.transfer(msg.value);\\n        _;\\n    }\\n\\n    event OrderCreated(\\n        bytes32 id,\\n        address owner,\\n        address baseAddress,\\n        address quoteAddress,\\n        uint baseLimit,\\n        uint quoteLimit,\\n        uint expirationTimestamp,\\n        address baseOnlyInvestor,\\n        uint minBaseInvestment,\\n        uint minQuoteInvestment,\\n        address broker,\\n        uint brokerBasePercent,\\n        uint brokerQuotePercent\\n    );\\n\\n    event OrderCancelled(bytes32 id);\\n\\n    event Deposit(\\n        bytes32 id,\\n        address token,\\n        address user,\\n        uint amount,\\n        uint balance\\n    );\\n\\n    event Refund(bytes32 id, address token, address user, uint amount);\\n\\n    event OrderSwapped(bytes32 id, address byUser);\\n\\n    event SwapSend(bytes32 id, address token, address user, uint amount);\\n\\n    event BrokerSend(bytes32 id, address token, address broker, uint amount);\\n\\n    event MyWishAddressChange(\\n        address oldMyWishAddress,\\n        address newMyWishAddress\\n    );\\n\\n    event MyWishPercentsChange(\\n        uint oldBasePercent,\\n        uint oldQuotePercent,\\n        uint newBasePercent,\\n        uint newQuotePercent\\n    );\\n\\n    constructor(\\n        uint256 _feeAmount,\\n        address payable _feeAddress\\n    ) public {\\n        feeAmount = _feeAmount;\\n        feeAddress = _feeAddress;\\n    }\\n\\n    function tokenFallback(address, uint, bytes calldata) external {}\\n\\n    function createOrder(\\n        address _baseAddress,\\n        address _quoteAddress,\\n        uint _baseLimit,\\n        uint _quoteLimit,\\n        uint _expirationTimestamp,\\n        address _baseOnlyInvestor,\\n        uint _minBaseInvestment,\\n        uint _minQuoteInvestment,\\n        address _brokerAddress,\\n        uint _brokerBasePercent,\\n        uint _brokerQuotePercent\\n    )\\n        external\\n        payable\\n        nonReentrant\\n        onlyWhenVaultDefined\\n        hasFeeAndTransferIt\\n        returns(bytes32 _id)\\n    {\\n        _id = createKey(msg.sender);\\n        require(owners[_id] == address(0), \\\"Swaps: Order already exists\\\");\\n        require(\\n            _baseAddress != _quoteAddress,\\n            \\\"Swaps: Exchanged tokens must be different\\\"\\n        );\\n        require(_baseLimit > 0, \\\"Swaps: Base limit must be positive\\\");\\n        require(_quoteLimit > 0, \\\"Swaps: Quote limit must be positive\\\");\\n        require(\\n            _expirationTimestamp > now,\\n            \\\"Swaps: Expiration time must be in future\\\"\\n        );\\n        require(\\n            _brokerBasePercent.add(myWishBasePercent) <= 10000,\\n            \\\"Swaps: Base percent sum should be less than 100%\\\"\\n        );\\n        require(\\n            _brokerQuotePercent.add(myWishQuotePercent) <= 10000,\\n            \\\"Swaps: Quote percent sum should be less than 100%\\\"\\n        );\\n\\n        owners[_id] = msg.sender;\\n        baseAddresses[_id] = _baseAddress;\\n        quoteAddresses[_id] = _quoteAddress;\\n        expirationTimestamps[_id] = _expirationTimestamp;\\n        limits[_id][_baseAddress] = _baseLimit;\\n        limits[_id][_quoteAddress] = _quoteLimit;\\n        baseOnlyInvestor[_id] = _baseOnlyInvestor;\\n        minInvestments[_id][_baseAddress] = _minBaseInvestment;\\n        minInvestments[_id][_quoteAddress] = _minQuoteInvestment;\\n        if (_brokerAddress != address(0)) {\\n            brokers[_id].push(_brokerAddress);\\n            brokerPercents[_id][_baseAddress][_brokerAddress] = _brokerBasePercent;\\n            brokerPercents[_id][_quoteAddress][_brokerAddress] = _brokerQuotePercent;\\n        }\\n        if (myWishAddress != address(0)) {\\n            brokers[_id].push(myWishAddress);\\n            brokerPercents[_id][_baseAddress][myWishAddress] = myWishBasePercent;\\n            brokerPercents[_id][_quoteAddress][myWishAddress] = myWishQuotePercent;\\n        }\\n\\n        emit OrderCreated(\\n            _id,\\n            msg.sender,\\n            _baseAddress,\\n            _quoteAddress,\\n            _baseLimit,\\n            _quoteLimit,\\n            _expirationTimestamp,\\n            _baseOnlyInvestor,\\n            _minBaseInvestment,\\n            _minQuoteInvestment,\\n            _brokerAddress,\\n            _brokerBasePercent,\\n            _brokerQuotePercent\\n        );\\n    }\\n\\n    function deposit(bytes32 _id, address _token, uint _amount)\\n        external\\n        payable\\n        nonReentrant\\n        onlyWhenVaultDefined\\n        onlyWhenOrderExists(_id)\\n    {\\n        if (_token == address(0)) {\\n            require(\\n                msg.value == _amount,\\n                \\\"Swaps: Payable value should be equals value\\\"\\n            );\\n            address(vault).transfer(msg.value);\\n        } else {\\n            require(msg.value == 0, \\\"Swaps: Payable not allowed here\\\");\\n            uint allowance = IERC20(_token).allowance(\\n                msg.sender,\\n                address(this)\\n            );\\n            require(\\n                _amount <= allowance,\\n                \\\"Swaps: Allowance should be not less than amount\\\"\\n            );\\n            IERC20(_token).transferFrom(msg.sender, address(vault), _amount);\\n        }\\n        _deposit(_id, _token, msg.sender, _amount);\\n    }\\n\\n    function cancel(bytes32 _id)\\n        external\\n        nonReentrant\\n        onlyOrderOwner(_id)\\n        onlyWhenVaultDefined\\n        onlyWhenOrderExists(_id)\\n    {\\n        require(!isCancelled[_id], \\\"Swaps: Already cancelled\\\");\\n        require(!isSwapped[_id], \\\"Swaps: Already swapped\\\");\\n\\n        address[2] memory tokens = [baseAddresses[_id], quoteAddresses[_id]];\\n        for (uint t = 0; t < tokens.length; t++) {\\n            address token = tokens[t];\\n            for (uint u = 0; u < investors[_id][token].length; u++) {\\n                address user = investors[_id][token][u];\\n                uint userInvestment = investments[_id][token][user];\\n                vault.withdraw(token, user, userInvestment);\\n            }\\n        }\\n\\n        isCancelled[_id] = true;\\n        emit OrderCancelled(_id);\\n    }\\n\\n    function refund(bytes32 _id, address _token)\\n        external\\n        nonReentrant\\n        onlyInvestor(_id, _token)\\n        onlyWhenVaultDefined\\n        onlyWhenOrderExists(_id)\\n    {\\n        require(!isCancelled[_id], \\\"Swaps: Order cancelled\\\");\\n        require(!isSwapped[_id], \\\"Swaps: Already swapped\\\");\\n        address user = msg.sender;\\n        uint investment = investments[_id][_token][user];\\n        if (investment > 0) {\\n            delete investments[_id][_token][user];\\n        }\\n\\n        _removeInvestor(investors[_id][_token], user);\\n\\n        if (investment > 0) {\\n            raised[_id][_token] = raised[_id][_token].sub(investment);\\n            vault.withdraw(_token, user, investment);\\n        }\\n\\n        emit Refund(_id, _token, user, investment);\\n    }\\n\\n    function setVault(Vault _vault) external onlyOwner {\\n        vault = _vault;\\n    }\\n\\n    function setMyWishPercents(uint _basePercent, uint _quotePercent)\\n        external\\n        onlyOwner\\n    {\\n        require(_basePercent <= 10000, \\\"Swaps: Base percent should be less than 100%\\\");\\n        require(\\n            _quotePercent <= 10000,\\n            \\\"Swaps: Quote percent should be less than 100%\\\"\\n        );\\n\\n        emit MyWishPercentsChange(\\n            myWishBasePercent,\\n            myWishQuotePercent,\\n            _basePercent,\\n            _quotePercent\\n        );\\n\\n        myWishBasePercent = _basePercent;\\n        myWishQuotePercent = _quotePercent;\\n    }\\n\\n    function setMyWishAddress(address _myWishAddress) external onlyOwner {\\n        emit MyWishAddressChange(myWishAddress, _myWishAddress);\\n        myWishAddress = _myWishAddress;\\n    }\\n\\n    function setFeeParameters(\\n        uint256 _feeAmount,\\n        address payable _feeAddress\\n    )\\n        external\\n        onlyOwner\\n    {\\n        feeAmount = _feeAmount;\\n        feeAddress = _feeAddress;\\n    }\\n\\n    function createKey(address _owner) public view returns (bytes32 result) {\\n        uint creationTime = now;\\n        result = 0x0000000000000000000000000000000000000000000000000000000000000000;\\n        assembly {\\n            result := or(result, mul(_owner, 0x1000000000000000000000000))\\n            result := or(result, and(creationTime, 0xffffffffffffffffffffffff))\\n        }\\n    }\\n\\n    function allBrokersBasePercent(bytes32 _id) public view returns (uint) {\\n        return _allBrokersPercent(baseAddresses[_id], _id);\\n    }\\n\\n    function allBrokersQuotePercent(bytes32 _id) public view returns (uint) {\\n        return _allBrokersPercent(quoteAddresses[_id], _id);\\n    }\\n\\n    function baseLimit(bytes32 _id) public view returns (uint) {\\n        return limits[_id][baseAddresses[_id]];\\n    }\\n\\n    function quoteLimit(bytes32 _id) public view returns (uint) {\\n        return limits[_id][quoteAddresses[_id]];\\n    }\\n\\n    function baseRaised(bytes32 _id) public view returns (uint) {\\n        return raised[_id][baseAddresses[_id]];\\n    }\\n\\n    function quoteRaised(bytes32 _id) public view returns (uint) {\\n        return raised[_id][quoteAddresses[_id]];\\n    }\\n\\n    function isBaseFilled(bytes32 _id) public view returns (bool) {\\n        return raised[_id][baseAddresses[_id]] == limits[_id][baseAddresses[_id]];\\n    }\\n\\n    function isQuoteFilled(bytes32 _id) public view returns (bool) {\\n        return raised[_id][quoteAddresses[_id]] == limits[_id][quoteAddresses[_id]];\\n    }\\n\\n    function baseInvestors(bytes32 _id) public view returns (address[] memory) {\\n        return investors[_id][baseAddresses[_id]];\\n    }\\n\\n    function quoteInvestors(bytes32 _id)\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        return investors[_id][quoteAddresses[_id]];\\n    }\\n\\n    function baseUserInvestment(bytes32 _id, address _user)\\n        public\\n        view\\n        returns (uint)\\n    {\\n        return investments[_id][baseAddresses[_id]][_user];\\n    }\\n\\n    function quoteUserInvestment(bytes32 _id, address _user)\\n        public\\n        view\\n        returns (uint)\\n    {\\n        return investments[_id][quoteAddresses[_id]][_user];\\n    }\\n\\n    function orderBrokers(bytes32 _id) public view returns (address[] memory) {\\n        return brokers[_id];\\n    }\\n\\n    function _allBrokersPercent(address _side, bytes32 _id) internal view returns (uint) {\\n        uint percents;\\n\\n        for (uint i = 0; i < brokers[_id].length; i++) {\\n            address broker = brokers[_id][i];\\n            uint percent = brokerPercents[_id][_side][broker];\\n            percents = percents.add(percent);\\n        }\\n        return percents;\\n    }\\n\\n    function _swap(bytes32 _id) internal {\\n        require(!isSwapped[_id], \\\"Swaps: Already swapped\\\");\\n        require(!isCancelled[_id], \\\"Swaps: Already cancelled\\\");\\n        require(isBaseFilled(_id), \\\"Swaps: Base tokens not filled\\\");\\n        require(isQuoteFilled(_id), \\\"Swaps: Quote tokens not filled\\\");\\n        require(now <= expirationTimestamps[_id], \\\"Contract expired\\\");\\n\\n        _distribute(_id, baseAddresses[_id], quoteAddresses[_id]);\\n        _distribute(_id, quoteAddresses[_id], baseAddresses[_id]);\\n\\n        isSwapped[_id] = true;\\n        emit OrderSwapped(_id, msg.sender);\\n    }\\n\\n    function _distribute(bytes32 _id, address _aSide, address _bSide) internal {\\n        uint brokersPercent;\\n        for (uint i = 0; i < brokers[_id].length; i++) {\\n            address broker = brokers[_id][i];\\n            uint percent = brokerPercents[_id][_bSide][broker];\\n            brokersPercent = brokersPercent.add(percent);\\n        }\\n\\n        uint toPayBrokers = raised[_id][_bSide].mul(brokersPercent).div(10000);\\n        uint toPayInvestors = raised[_id][_bSide].sub(toPayBrokers);\\n\\n        uint remainder = toPayInvestors;\\n        for (uint i = 0; i < investors[_id][_aSide].length; i++) {\\n            address user = investors[_id][_aSide][i];\\n            uint toPay;\\n            // last\\n            if (i + 1 == investors[_id][_aSide].length) {\\n                toPay = remainder;\\n            } else {\\n                uint aSideRaised = raised[_id][_aSide];\\n                uint userInvestment = investments[_id][_aSide][user];\\n                toPay = userInvestment.mul(toPayInvestors).div(aSideRaised);\\n                remainder = remainder.sub(toPay);\\n            }\\n\\n            vault.withdraw(_bSide, user, toPay);\\n            emit SwapSend(_id, _bSide, user, toPay);\\n        }\\n\\n        remainder = toPayBrokers;\\n        for (uint i = 0; i < brokers[_id].length; i++) {\\n            address broker = brokers[_id][i];\\n            uint toPay;\\n            if (i + 1 == brokers[_id].length) {\\n                toPay = remainder;\\n            } else {\\n                uint percent = brokerPercents[_id][_bSide][broker];\\n                toPay = toPayBrokers.mul(percent).div(brokersPercent);\\n                remainder = remainder.sub(toPay);\\n            }\\n\\n            vault.withdraw(_bSide, broker, toPay);\\n            emit BrokerSend(_id, _bSide, broker, toPay);\\n        }\\n    }\\n\\n    function _removeInvestor(address[] storage _array, address _investor)\\n        internal\\n    {\\n        uint idx = _array.length - 1;\\n        for (uint i = 0; i < _array.length - 1; i++) {\\n            if (_array[i] == _investor) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n\\n        _array[idx] = _array[_array.length - 1];\\n        delete _array[_array.length - 1];\\n        _array.length--;\\n    }\\n\\n    function _deposit(bytes32 _id, address _token, address _from, uint _amount)\\n        internal\\n    {\\n        uint amount = _amount;\\n        require(\\n            baseAddresses[_id] == _token || quoteAddresses[_id] == _token,\\n            \\\"Swaps: You can deposit only base or quote currency\\\"\\n        );\\n        require(\\n            raised[_id][_token] < limits[_id][_token],\\n            \\\"Swaps: Limit already reached\\\"\\n        );\\n        require(now <= expirationTimestamps[_id], \\\"Swaps: Contract expired\\\");\\n        if (baseAddresses[_id] == _token && baseOnlyInvestor[_id] != address(\\n            0\\n        )) {\\n            require(\\n                msg.sender == baseOnlyInvestor[_id],\\n                \\\"Swaps: Allowed only for specified address\\\"\\n            );\\n        }\\n        if (limits[_id][_token].sub(\\n            raised[_id][_token]\\n        ) > minInvestments[_id][_token]) {\\n            require(\\n                _amount >= minInvestments[_id][_token],\\n                \\\"Swaps: Should not be less than minimum value\\\"\\n            );\\n        }\\n\\n        if (!_isInvestor(_id, _token, _from)) {\\n            require(\\n                investors[_id][_token].length < MAX_INVESTORS,\\n                \\\"Swaps: Too many investors\\\"\\n            );\\n            investors[_id][_token].push(_from);\\n        }\\n\\n        uint raisedWithOverflow = raised[_id][_token].add(amount);\\n        if (raisedWithOverflow > limits[_id][_token]) {\\n            uint overflow = raisedWithOverflow.sub(limits[_id][_token]);\\n            vault.withdraw(_token, _from, overflow);\\n            amount = amount.sub(overflow);\\n        }\\n\\n        investments[_id][_token][_from] = investments[_id][_token][_from].add(\\n            amount\\n        );\\n\\n        raised[_id][_token] = raised[_id][_token].add(amount);\\n        emit Deposit(\\n            _id,\\n            _token,\\n            _from,\\n            amount,\\n            investments[_id][_token][_from]\\n        );\\n\\n        if (isBaseFilled(_id) && isQuoteFilled(_id)) {\\n            _swap(_id);\\n        }\\n    }\\n\\n    function _isInvestor(bytes32 _id, address _token, address _who)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return investments[_id][_token][_who] > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/tepnik/Desktop/swaps2/contracts/Vault.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.7;\\n\\nimport \\\"openzeppelin-solidity/contracts/ownership/Ownable.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\ncontract Vault is Ownable {\\n    address public swaps;\\n\\n    modifier onlySwaps() {\\n        require(msg.sender == swaps);\\n        _;\\n    }\\n\\n    function() external payable {}\\n\\n    function tokenFallback(address, uint, bytes calldata) external {}\\n\\n    function setSwaps(address _swaps) public onlyOwner {\\n        swaps = _swaps;\\n    }\\n\\n    function withdraw(address _token, address _receiver, uint _amount)\\n        public\\n        onlySwaps\\n    {\\n        if (_token == address(0)) {\\n            address(uint160(_receiver)).transfer(_amount);\\n        } else {\\n            IERC20(_token).transfer(_receiver, _amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two unsigned integers, reverts on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n     * reverts when dividing by zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     * @notice Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n/**\\n * @title Helps contracts guard against reentrancy attacks.\\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\\n * @dev If you mark a function `nonReentrant`, you should also\\n * mark it `external`.\\n */\\ncontract ReentrancyGuard {\\n    /// @dev counter to allow mutex lock with only one SSTORE operation\\n    uint256 private _guardCounter;\\n\\n    constructor () internal {\\n        // The counter starts at one to prevent changing it from zero to a non-zero\\n        // value, which is a more expensive operation.\\n        _guardCounter = 1;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _guardCounter += 1;\\n        uint256 localCounter = _guardCounter;\\n        _;\\n        require(localCounter == _guardCounter);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_feeAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"broker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BrokerSend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldMyWishAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMyWishAddress\",\"type\":\"address\"}],\"name\":\"MyWishAddressChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldBasePercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldQuotePercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBasePercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newQuotePercent\",\"type\":\"uint256\"}],\"name\":\"MyWishPercentsChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"baseAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"quoteAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"baseOnlyInvestor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minBaseInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minQuoteInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"broker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"brokerBasePercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"brokerQuotePercent\",\"type\":\"uint256\"}],\"name\":\"OrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"byUser\",\"type\":\"address\"}],\"name\":\"OrderSwapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SwapSend\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_INVESTORS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"allBrokersBasePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"allBrokersQuotePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"baseAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"baseInvestors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"baseLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"baseOnlyInvestor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"baseRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"baseUserInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"brokerPercents\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"brokers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"createKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_quoteAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_baseLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_quoteLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expirationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_baseOnlyInvestor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minBaseInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minQuoteInvestment\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_brokerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_brokerBasePercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_brokerQuotePercent\",\"type\":\"uint256\"}],\"name\":\"createOrder\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"expirationTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"investments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"isBaseFilled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isCancelled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"isQuoteFilled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isSwapped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"limits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minInvestments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myWishAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myWishBasePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myWishQuotePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"orderBrokers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"quoteAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"quoteInvestors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"quoteLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"quoteRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"quoteUserInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"raised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_feeAddress\",\"type\":\"address\"}],\"name\":\"setFeeParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_myWishAddress\",\"type\":\"address\"}],\"name\":\"setMyWishAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_basePercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_quotePercent\",\"type\":\"uint256\"}],\"name\":\"setMyWishPercents\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"setVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Swaps","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"00000000000000000000000000000000000000000000000000354a6ba7a180000000000000000000000000007367409e0c12b2b7caa5c990e11a75e0d86580fc","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}