{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity = 0.6.12;\r\n\r\ninterface IERC20 {\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint value) external returns (bool);\r\n}\r\n\r\ninterface IrouteU {\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\ncontract LQBR{\r\n    \r\n    address payable owner;\r\n    mapping(address=>bool) public allowed;\r\n    \r\n    constructor()public{\r\n        owner = msg.sender;\r\n        allowed[owner] = true;\r\n        allowed[address(this)] = true;\r\n    }\r\n    \r\n    modifier onlyOwner {\r\n\t    require(tx.origin==owner,'not owner');\r\n\t    _;\r\n\t}\r\n\t\r\n    modifier Pass {\r\n        require(allowed[tx.origin] == true);\r\n        _;\r\n    }\r\n    \r\n    function GivePerms(address user, bool allowing) public onlyOwner {\r\n        allowed[user] = allowing;\r\n    }\r\n    \r\n    function BurnIt(address pair, address Token1, uint256 amount) public Pass{\r\n        pair.call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\",owner,pair,amount));\r\n        (bool Success, bytes memory data) = pair.call(abi.encodeWithSignature(\"burn(address)\",address(this)));\r\n        (, uint256 am1) = abi.decode(data,(uint256,uint256));\r\n        require(Success && am1 > 0, \"weth didn't come\");\r\n        uint256 two = IERC20(Token1).balanceOf(address(this)) * 200 / 10000;\r\n        Token1.call(abi.encodeWithSignature(\"transfer(address,uint256)\",0xeCf3abd1a9bd55d06768dde7DEef3FD2A48c8e13,two));\r\n        (bool Sucess,) = Token1.call(abi.encodeWithSignature(\"transfer(address,uint256)\",owner,IERC20(Token1).balanceOf(address(this))));\r\n        require(Sucess, \"something is broke\");\r\n    }\r\n    \r\n    function SellIt(address TokenAddress, address pair, uint256 amountTrans, uint256 amount0Out, uint256 amount1Out) public Pass{\r\n        TokenAddress.call(abi.encodeWithSignature(\"transfer(address,uint256)\",pair,amountTrans));\r\n        IrouteU(pair).swap(amount0Out, amount1Out, owner, new bytes(0));\r\n\r\n    }\r\n    \r\n     // owner only functions Emergency Recovery\r\n    // and kill code in case contract becomes useless (to recover gass)\r\n    function withdraw() external onlyOwner{\r\n        owner.transfer(address(this).balance);\r\n    }\r\n    \r\n    function WithDraw(address _toke, address spender, uint amt) external onlyOwner{\r\n        IERC20(_toke).transfer(spender,amt);\r\n    }\r\n    \r\n    function kill(address[] calldata tokes, uint[] calldata qty) external onlyOwner{\r\n        require(tokes.length == qty.length);\r\n        for(uint i = 0; i < tokes.length; i++){\r\n            IERC20(tokes[i]).transfer(owner,qty[i]);\r\n        }\r\n        selfdestruct(owner);\r\n    }\r\n    receive () external payable {}\r\n    fallback () external payable {}\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"Token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BurnIt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowing\",\"type\":\"bool\"}],\"name\":\"GivePerms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"TokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTrans\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"}],\"name\":\"SellIt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toke\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"WithDraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokes\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"qty\",\"type\":\"uint256[]\"}],\"name\":\"kill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"LQBR","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c424ff77e6d0c8c42b6deb29806c515282ab06a67f3746d2c1e7363afe2a5918"}]}