{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/jacob/Developer/DeFiWorkspace/punk.protocol/contracts/Saver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.9.0;\\n\\nstruct Saver{\\n    uint256 createTimestamp;\\n    uint256 startTimestamp;\\n    uint count;\\n    uint interval;\\n    uint256 mint;\\n    uint256 released;\\n    uint256 accAmount;\\n    uint256 relAmount;\\n    uint score;\\n    uint status;\\n    uint updatedTimestamp;\\n    bytes12 ref;\\n}\\n\\nstruct Transaction{\\n    bool pos;\\n    uint timestamp;\\n    uint amount;\\n}\"\r\n    },\r\n    \"/Users/jacob/Developer/DeFiWorkspace/punk.protocol/contracts/libs/CommitmentWeight.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.9.0;\\n\\nlibrary CommitmentWeight {\\n    \\n    uint constant DECIMALS = 8;\\n    int constant ONE = int(10**DECIMALS);\\n\\n    function calculate( uint day ) external pure returns (uint){\\n        int x = int(day) * ONE;\\n        int c = 3650 * ONE;\\n        \\n        int numerator = div( div( x, c ) - ONE, sqrt( ( div( pow( x, 2 ), 13322500 * ONE ) - div( x, 1825 * ONE ) + ONE + ONE ) ) ) + div( ONE, sqrt( 2 * ONE ) );\\n        int denominator = ( ONE + div( ONE, sqrt( 2 * ONE ) ) );\\n        \\n        return uint( ONE + div( numerator, denominator ) );\\n    }\\n    \\n    function div( int a, int b ) internal pure returns ( int ){\\n        return ( a * int(ONE) / b );\\n    }\\n    \\n    function sqrt( int a ) internal pure returns ( int ){\\n        int s = a * int(ONE);\\n        if( s < 0 ) s = s * -1;\\n        uint k = uint(s);\\n        uint z = (k + 1) / 2;\\n        uint y = k;\\n        while (z < y) {\\n            y = z;\\n            z = (k / z + z) / 2;\\n        }\\n        return int(y);\\n    }\\n\\n    function pow( int a, int b ) internal pure returns ( int ){\\n        return int(uint(a) ** uint(b) / uint(ONE));\\n    }\\n    \\n}\"\r\n    },\r\n    \"/Users/jacob/Developer/DeFiWorkspace/punk.protocol/contracts/libs/Score.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"./CommitmentWeight.sol\\\";\\nimport \\\"../Saver.sol\\\";\\n\\nlibrary Score {\\n    using SafeMath for uint;\\n    \\n    uint constant SECONDS_OF_DAY = 24 * 60 * 60;\\n\\n    function _getTimes( uint createTimestamp, uint startTimestamp, uint count, uint interval ) pure private returns( uint deposit, uint withdraw, uint timeline, uint max ){\\n        deposit     = startTimestamp.sub( createTimestamp );\\n        withdraw    = SECONDS_OF_DAY.mul( count ).mul( interval );\\n        timeline    = deposit + withdraw;\\n        max         = SECONDS_OF_DAY.mul( 365 ).mul( 30 );\\n    }\\n    \\n    function _getDepositTransactions( uint createTimestamp, uint deposit, Transaction [] memory transactions ) private pure returns( uint depositCount, uint [] memory xAxis, uint [] memory yAxis ){\\n        depositCount = 0;\\n        yAxis = new uint [] ( transactions.length );\\n        xAxis = new uint [] ( transactions.length + 1 );\\n        \\n        for( uint i = 0 ; i <  transactions.length ; i++ ){\\n            if( transactions[i].pos ) {\\n                yAxis[ depositCount ] = i == 0 ? transactions[ i ].amount : transactions[ i ].amount.add( yAxis[ i - 1 ] );\\n                xAxis[ depositCount ] = transactions[ i ].timestamp.sub( createTimestamp );\\n                depositCount++;\\n            }\\n        }\\n        xAxis[ depositCount ] = deposit;\\n        \\n        uint tempX = 0;\\n        for( uint i = 1 ; i <= depositCount ; i++ ){\\n            tempX = tempX + xAxis[ i - 1 ];\\n            xAxis[ i ] = xAxis[ i ].sub( tempX );\\n        }\\n    }\\n\\n    function calculate( uint createTimestamp, uint startTimestamp, Transaction [] memory transactions, uint count, uint interval, uint decimals ) public pure returns ( uint ){\\n        \\n        ( uint deposit, uint withdraw, uint timeline, uint max ) = _getTimes(createTimestamp, startTimestamp, count, interval);\\n        ( uint depositCount, uint [] memory xAxis, uint [] memory yAxis ) = _getDepositTransactions( createTimestamp, deposit, transactions );\\n        \\n        uint cw = CommitmentWeight.calculate( timeline.div( SECONDS_OF_DAY ) );\\n        \\n        if( max <= deposit ){\\n            \\n            uint accX = 0;\\n            for( uint i = 0 ; i < depositCount ; i++ ){\\n                accX = accX.add( xAxis[ i + 1 ] );\\n                if( accX > max ){\\n                    xAxis[ i + 1 ] = max.sub( accX.sub( xAxis[ i + 1 ] ) );\\n                    depositCount = i + 1;\\n                    break;\\n                }\\n            }\\n            \\n            uint beforeWithdraw = 0;\\n            for( uint i = 0 ; i < depositCount ; i++ ){\\n                beforeWithdraw = beforeWithdraw.add( yAxis[ i ].mul( xAxis[ i + 1 ] ) );\\n            }\\n            \\n            uint afterWithdraw = 0;\\n            \\n            return beforeWithdraw.add( afterWithdraw ).div( SECONDS_OF_DAY ).mul( cw ).div( 10 ** decimals );\\n            \\n        }else if( max <= timeline ){\\n            \\n            uint beforeWithdraw = 0;\\n            for( uint i = 0 ; i < depositCount ; i++ ){\\n                beforeWithdraw = beforeWithdraw.add( yAxis[ i ].mul( xAxis[ i + 1 ] ) );\\n            }\\n            \\n            uint afterWithdraw = 0;\\n            if( withdraw > 0 ){\\n                uint tempY = yAxis[ depositCount - 1 ].mul( timeline.sub( max ) ).div( withdraw );\\n                afterWithdraw = yAxis[ depositCount - 1 ].mul( withdraw ).div( 2 );\\n                afterWithdraw = afterWithdraw.sub( tempY.mul( timeline.sub( max ) ).div( 2 ) );\\n            }\\n            \\n            return beforeWithdraw.add( afterWithdraw ).div( SECONDS_OF_DAY ).mul( cw ).div( 10 ** decimals );\\n            \\n        }else {\\n            \\n            uint beforeWithdraw = 0;\\n            for( uint i = 0 ; i < depositCount ; i++ ){\\n                beforeWithdraw = beforeWithdraw.add( yAxis[ i ].mul( xAxis[ i + 1 ] ) );\\n            }\\n            \\n            uint afterWithdraw = yAxis[ depositCount - 1 ].mul( withdraw ).div( 2 );\\n            \\n            return beforeWithdraw.add( afterWithdraw ).div( SECONDS_OF_DAY ).mul( cw ).div( 10 ** decimals );\\n            \\n        }\\n        \\n    }\\n    \\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"evmVersion\": \"byzantium\",\r\n    \"libraries\": {\r\n      \"/Users/jacob/Developer/DeFiWorkspace/punk.protocol/contracts/libs/CommitmentWeight.sol\": {\r\n        \"CommitmentWeight\": \"0x2b18d7988B298B5c7Ea02C4d4a33d6DCb3282d8B\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"createTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"pos\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Transaction[]\",\"name\":\"transactions\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"calculate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"Score","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"","EVMVersion":"byzantium","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}