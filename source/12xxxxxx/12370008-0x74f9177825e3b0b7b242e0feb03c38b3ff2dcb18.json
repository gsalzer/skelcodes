{"status":"1","message":"OK","result":[{"SourceCode":"{\"ApymonPack721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./ERC165.sol\\\";\\nimport \\u0027./Events721.sol\\u0027;\\nimport \\u0027./Ownable.sol\\u0027;\\n\\ninterface IERC721 {\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n    function exists(uint256 tokenId) external view returns (bool);\\n    function approve(address to, uint256 tokenId) external;\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n}\\n\\ninterface IAPYMONPACK {\\n    function isLocked(uint256 eggId) external view returns (bool locked, uint256 endTime);\\n    function isOpened(uint256 eggId) external view returns (bool);\\n}\\n\\ninterface ISwap {\\n    function swapErc721(\\n        uint256 eggId,\\n        address inToken,\\n        uint256 inId,\\n        address outToken,\\n        uint8 router,\\n        address to\\n    ) external;\\n}\\n\\ncontract ApymonPack721 is ERC165, IERC721Receiver, Context, Events721, Ownable {\\n\\n    // Mapping from egg ID -\\u003e tokens\\n    mapping(uint256 =\\u003e address[]) private _insideTokens;\\n\\n    // Mapping from egg ID -\\u003e token(erc721) -\\u003e ids\\n    mapping(uint256 =\\u003e mapping(address =\\u003e uint256[])) private _insideTokenIds;\\n\\n    IERC721 public _apymon;\\n    IAPYMONPACK public _apymonPack;\\n\\n    ISwap public _swap;\\n\\n    modifier onlyEggOwner(uint256 eggId) {\\n        require(_apymon.exists(eggId));\\n        require(_apymon.ownerOf(eggId) == msg.sender);\\n        _;\\n    }\\n\\n    modifier unlocked(uint256 eggId) {\\n        (bool locked, ) = _apymonPack.isLocked(eggId);\\n        require(!locked, \\\"Egg has been locked.\\\");\\n        _;\\n    }\\n\\n    modifier opened(uint256 eggId) {\\n        require(_apymonPack.isOpened(eggId), \\\"Egg has been closed\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        _apymon = IERC721(0x9C008A22D71B6182029b694B0311486e4C0e53DB);\\n        _apymonPack = IAPYMONPACK(0x3dFCB488F6e96654e827Ab2aB10a463B9927d4f9);\\n    }\\n\\n    // View functions\\n\\n    /**\\n     * @dev check if egg token id exists in egg.\\n     */\\n    function existsId(\\n        uint256 eggId,\\n        address token,\\n        uint256 id\\n    ) public view returns (bool) {\\n        uint256[] memory ids = _insideTokenIds[eggId][token];\\n\\n        for (uint256 i; i \\u003c ids.length; i++) {\\n            if (ids[i] == id) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @dev check if tokenId exists in egg\\n     */\\n    function getInsideTokensCount(\\n        uint256 eggId\\n    ) public view opened(eggId) returns (\\n        uint256 erc721Len\\n    ) {\\n        return _insideTokens[eggId].length;\\n    }\\n\\n    /**\\n     * @dev get ERC721 token info\\n     */\\n    function getERC721Tokens(\\n        uint256 eggId\\n    ) public view opened(eggId) returns (\\n        address[] memory addresses,\\n        uint256[] memory tokenBalances\\n    ) {\\n        address[] memory tokens = _insideTokens[eggId];\\n        uint256 erc721Len = tokens.length;\\n        \\n        tokenBalances = new uint256[](erc721Len);\\n        addresses = new address[](erc721Len);\\n        uint256 j;\\n\\n        for (uint256 i; i \\u003c tokens.length; i++) {\\n            addresses[j] = tokens[i];\\n            tokenBalances[j] = _insideTokenIds[eggId][tokens[i]].length;\\n            j++;\\n        }\\n    }\\n\\n    /**\\n     * @dev get ERC721 ids\\n     */\\n    function getTokenIds(\\n        uint256 eggId,\\n        address insideToken\\n    ) public view opened(eggId) returns (uint256[] memory) {\\n        return _insideTokenIds[eggId][insideToken];\\n    }\\n\\n    // Write functions\\n\\n    function setSwap(address swap) external onlyOwner {\\n        _swap = ISwap(swap);\\n    }\\n\\n    function setApymonPack(address _pack) external onlyOwner {\\n        _apymonPack = IAPYMONPACK(_pack);\\n    }\\n\\n    /**\\n     * @dev deposit erc721 tokens into egg.\\n     */\\n    function depositErc721IntoEgg(\\n        uint256 eggId,\\n        address token,\\n        uint256[] memory tokenIds\\n    ) external {\\n        require(token != address(0));\\n\\n        for (uint256 i; i \\u003c tokenIds.length; i++) {\\n            require(\\n                token != address(_apymon) ||\\n                (token == address(_apymon) \\u0026\\u0026 eggId != tokenIds[i])\\n            );\\n            IERC721 iToken = IERC721(token);\\n            \\n            iToken.safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                tokenIds[i]\\n            );\\n\\n            _putInsideTokenId(\\n                eggId,\\n                token,\\n                tokenIds[i]\\n            );\\n\\n            if (_apymonPack.isOpened(eggId)) {\\n                emit DepositedErc721IntoEgg(\\n                    eggId,\\n                    msg.sender,\\n                    token,\\n                    tokenIds[i]\\n                );\\n            }\\n        }\\n\\n        _putTokenIntoEgg(\\n            eggId,\\n            token\\n        );\\n    }\\n\\n    /**\\n     * @dev withdraw erc721 token from egg.\\n     */\\n    function withdrawErc721FromEgg(\\n        uint256 eggId,\\n        address token,\\n        uint256[] memory tokenIds,\\n        address to\\n    ) public onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\\n        require(token != address(0));\\n        IERC721 iToken = IERC721(token);\\n\\n        for (uint256 i; i \\u003c tokenIds.length; i++) {\\n            address tokenOwner = iToken.ownerOf(tokenIds[i]);\\n\\n            require(tokenOwner == address(this));\\n\\n            iToken.safeTransferFrom(\\n                tokenOwner,\\n                to,\\n                tokenIds[i]\\n            );\\n\\n            _popInsideTokenId(\\n                eggId,\\n                token,\\n                tokenIds[i]\\n            );\\n\\n            emit WithdrewErc721FromEgg(\\n                eggId,\\n                msg.sender,\\n                token,\\n                tokenIds[i],\\n                to\\n            );\\n        }\\n\\n        uint256[] memory ids = _insideTokenIds[eggId][token];\\n\\n        if (ids.length == 0) {\\n            _popTokenFromEgg(\\n                eggId,\\n                token\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev send erc721 tokens from my egg to another egg.\\n     */\\n    function sendErc721(\\n        uint256 fromEggId,\\n        address token,\\n        uint256[] memory tokenIds,\\n        uint256 toEggId\\n    ) public onlyEggOwner(fromEggId) unlocked(fromEggId) opened(fromEggId) {\\n        require(fromEggId != toEggId);\\n        require(token != address(0));\\n        require(_apymon.exists(toEggId));\\n\\n        for (uint256 i; i \\u003c tokenIds.length; i++) {\\n            _popInsideTokenId(\\n                fromEggId,\\n                token,\\n                tokenIds[i]\\n            );\\n\\n            _putInsideTokenId(\\n                toEggId,\\n                token,\\n                tokenIds[i]\\n            );\\n\\n            emit SentErc721(\\n                fromEggId,\\n                msg.sender,\\n                token,\\n                tokenIds[i],\\n                toEggId\\n            );\\n        }\\n\\n        uint256[] memory ids = _insideTokenIds[fromEggId][token];\\n\\n        if (ids.length == 0) {\\n            _popTokenFromEgg(\\n                fromEggId,\\n                token\\n            );\\n        }\\n\\n        _putTokenIntoEgg(\\n            toEggId,\\n            token\\n        );\\n    }\\n\\n    function swapErc721(\\n        uint256 eggId,\\n        address inToken,\\n        uint256 inId,\\n        address outToken,\\n        uint8 router,\\n        address to\\n    ) external onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\\n        require(address(_swap) != address(0));\\n        require(existsId(eggId, inToken, inId));\\n        \\n        IERC721(inToken).approve(address(_swap), inId);\\n\\n        _swap.swapErc721(\\n            eggId,\\n            inToken,\\n            inId,\\n            outToken,\\n            router,\\n            to\\n        );\\n        emit SwapedErc721(\\n            msg.sender,\\n            eggId,\\n            inToken,\\n            inId,\\n            outToken,\\n            to\\n        );\\n\\n        _popInsideTokenId(\\n            eggId,\\n            inToken,\\n            inId\\n        );\\n    }\\n\\n    /**\\n     * @dev private function to put a token id to egg\\n     */\\n    function _putInsideTokenId(\\n        uint256 eggId,\\n        address token,\\n        uint256 tokenId\\n    ) private {\\n        uint256[] storage ids = _insideTokenIds[eggId][token];\\n        ids.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev private function to pop a token id from egg\\n     */\\n    function _popInsideTokenId(\\n        uint256 eggId,\\n        address token,\\n        uint256 tokenId\\n    ) private {\\n        uint256[] storage ids = _insideTokenIds[eggId][token];\\n        for (uint256 i; i \\u003c ids.length; i++) {\\n            if (ids[i] == tokenId) {\\n                ids[i] = ids[ids.length - 1];\\n                ids.pop();\\n            }\\n        }\\n\\n        if (ids.length == 0) {\\n            delete _insideTokenIds[eggId][token];\\n        }\\n    }\\n\\n    /**\\n     * @dev put token(type, address) to egg\\n     */\\n    function _putTokenIntoEgg(\\n        uint256 eggId,\\n        address tokenAddress\\n    ) private {\\n        address[] storage tokens = _insideTokens[eggId];\\n        bool exists = false;\\n        for (uint256 i; i \\u003c tokens.length; i++) {\\n            if (tokens[i] == tokenAddress) {\\n                exists = true;\\n                break;\\n            }\\n        }\\n\\n        if (!exists) {\\n            tokens.push(tokenAddress);\\n        }\\n    }\\n\\n    /**\\n     * @dev pop token(type, address) from egg\\n     */\\n    function _popTokenFromEgg(\\n        uint256 eggId,\\n        address tokenAddress\\n    ) private {\\n        address[] storage tokens = _insideTokens[eggId];\\n        for (uint256 i; i \\u003c tokens.length; i++) {\\n            if (tokens[i] == tokenAddress) {\\n                tokens[i] = tokens[tokens.length - 1];\\n                tokens.pop();\\n                break;\\n            }\\n        }\\n\\n        if (tokens.length == 0) {\\n            delete _insideTokens[eggId];\\n        }\\n    }\\n   \\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256(\\u0027supportsInterface(bytes4)\\u0027)) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it\\u0027s supported.\\n     */\\n    mapping(bytes4 =\\u003e bool) private _supportedInterfaces;\\n\\n    constructor () {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"},\"Events721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ncontract Events721 {\\n    event DepositedErc721IntoEgg(\\n        uint256 eggId,\\n        address indexed owner,\\n        address indexed erc721Token,\\n        uint256 tokenId\\n    );\\n\\n    event WithdrewErc721FromEgg(\\n        uint256 eggId,\\n        address indexed owner,\\n        address indexed erc721Token,\\n        uint256 tokenId,\\n        address indexed to\\n    );\\n\\n    event SentErc721(\\n        uint256 fromEggId,\\n        address indexed owner,\\n        address indexed erc721Token,\\n        uint256 tokenId,\\n        uint256 toEggId\\n    );\\n\\n    event SwapedErc721(\\n        address indexed owner,\\n        uint256 eggId,\\n        address inToken,\\n        uint256 inId,\\n        address outToken,\\n        address indexed to\\n    );\\n}\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc721Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"DepositedErc721IntoEgg\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromEggId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc721Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toEggId\",\"type\":\"uint256\"}],\"name\":\"SentErc721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"SwapedErc721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc721Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"WithdrewErc721FromEgg\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_apymon\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_apymonPack\",\"outputs\":[{\"internalType\":\"contract IAPYMONPACK\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swap\",\"outputs\":[{\"internalType\":\"contract ISwap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"depositErc721IntoEgg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"existsId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"}],\"name\":\"getERC721Tokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenBalances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"}],\"name\":\"getInsideTokensCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"erc721Len\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"insideToken\",\"type\":\"address\"}],\"name\":\"getTokenIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fromEggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"toEggId\",\"type\":\"uint256\"}],\"name\":\"sendErc721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pack\",\"type\":\"address\"}],\"name\":\"setApymonPack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"swap\",\"type\":\"address\"}],\"name\":\"setSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"inToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"outToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"router\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"swapErc721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawErc721FromEgg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ApymonPack721","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c39b1ca6323ec98a344fba992060afa7e0af2b0a6073cd1f2cd18d6c5bae72de"}]}