{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.6.4 https://hardhat.org\n\n// File contracts/Ethereum/libraries/LibAppStorage.sol\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nstruct Aavegotchi {\n    address owner;\n}\n\nstruct AppStorage {\n    mapping(uint256 => bool) itemTypeExists;\n    uint256[] itemTypes;\n    mapping(address => mapping(uint256 => uint256)) items;\n    string itemsBaseUri;\n    mapping(address => uint256) aavegotchiBalance;\n    mapping(uint256 => Aavegotchi) aavegotchis;\n    mapping(address => mapping(address => bool)) operators;\n    mapping(uint256 => address) approved;    \n    address rootChainManager;\n    uint32[] tokenIds;\n    mapping(uint256 => uint256) tokenIdIndexes;\n}\n\n\n// File contracts/shared/libraries/LibStrings.sol\n\n\n\n\n// From Open Zeppelin contracts: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\n\n/**\n * @dev String operations.\n */\nlibrary LibStrings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function strWithUint(string memory _str, uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n        bytes memory buffer;\n        unchecked {\n            if (value == 0) {\n                return string(abi.encodePacked(_str, \"0\"));\n            }\n            uint256 temp = value;\n            uint256 digits;\n            while (temp != 0) {\n                digits++;\n                temp /= 10;\n            }\n            buffer = new bytes(digits);\n            uint256 index = digits - 1;\n            temp = value;\n            while (temp != 0) {\n                buffer[index--] = bytes1(uint8(48 + (temp % 10)));\n                temp /= 10;\n            }\n        }\n        return string(abi.encodePacked(_str, buffer));\n    }\n\n\n\n}\n\n\n// File contracts/shared/interfaces/IERC721TokenReceiver.sol\n\n\n\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface IERC721TokenReceiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    ///  after a `transfer`. This function MAY throw to revert and reject the\n    ///  transfer. Return of other than the magic value MUST result in the\n    ///  transaction being reverted.\n    ///  Note: the contract address is always the message sender.\n    /// @param _operator The address which called `safeTransferFrom` function\n    /// @param _from The address which previously owned the token\n    /// @param _tokenId The NFT identifier which is being transferred\n    /// @param _data Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external returns (bytes4);\n}\n\n\n// File contracts/shared/libraries/LibERC721.sol\n\n\n\n\nlibrary LibERC721 {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n    ///  may be created and assigned without emitting Transfer. At the time of\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    ///  reaffirmed. The zero address indicates there is no approved address.\n    ///  When a Transfer event emits, this also indicates that the approved\n    ///  address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    ///  The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\n\n    function checkOnERC721Received(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) internal {\n        uint256 size;\n        assembly {\n            size := extcodesize(_to)\n        }\n        if (size > 0) {\n            require(\n                ERC721_RECEIVED == IERC721TokenReceiver(_to).onERC721Received(_operator, _from, _tokenId, _data),\n                \"AavegotchiFacet: Transfer rejected/failed by _to\"\n            );\n        }\n    }\n}\n\n\n// File contracts/shared/libraries/LibMeta.sol\n\n\n\n\nlibrary LibMeta {\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(bytes(\"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\"));\n\n    function domainSeparator(string memory name, string memory version) internal view returns (bytes32 domainSeparator_) {\n        domainSeparator_ = keccak256(\n            abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes(version)), getChainID(), address(this))\n        );\n    }\n\n    function getChainID() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    function msgSender() internal view returns (address sender_) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender_ := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n            }\n        } else {\n            sender_ = msg.sender;\n        }\n    }\n}\n\n\n// File contracts/Ethereum/facets/AavegotchiFacet.sol\n\n\n\n\n\n\n\n\ncontract AavegotchiFacet {\n    AppStorage internal s;\n    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\n\n    function tokenIdsOfOwner(address _owner) external view returns (uint256[] memory tokenIds_) {\n        uint256 len = s.tokenIds.length;\n        tokenIds_ = new uint256[](len);\n        uint256 count;\n        for (uint256 i; i < len; ) {\n            uint256 tokenId = s.tokenIds[i];\n            if (s.aavegotchis[tokenId].owner == _owner) {\n                tokenIds_[count] = tokenId;\n                unchecked {\n                    count++;\n                }\n            }\n            unchecked {\n                i++;\n            }\n        }\n        assembly {\n            mstore(tokenIds_, count)\n        }\n    }\n\n    function totalSupply() external view returns (uint256 totalSupply_) {\n        totalSupply_ = s.tokenIds.length;\n    }\n\n    /// @notice Enumerate valid NFTs\n    /// @dev Throws if `_index` >= `totalSupply()`.\n    /// @param _index A counter less than `totalSupply()`\n    /// @return tokenId_ The token identifier for the `_index`th NFT,\n    ///  (sort order not specified)\n    function tokenByIndex(uint256 _index) external view returns (uint256 tokenId_) {\n        require(_index < s.tokenIds.length, \"AavegotchiFacet: _index is greater than total supply.\");\n        tokenId_ = s.tokenIds[_index];\n    }\n    \n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this.\n    ///  function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return balance_ The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256 balance_) {\n        balance_ = s.aavegotchiBalance[_owner];\n    }\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    ///  about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return owner_ The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address owner_) {\n        owner_ = s.aavegotchis[_tokenId].owner;\n    }\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return approved_ The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address approved_) {\n        require(s.aavegotchis[_tokenId].owner != address(0), \"AavegotchiFacet: tokenId is invalid or is not owned\");\n        approved_ = s.approved[_tokenId];\n    }\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return approved_ True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool approved_) {\n        approved_ = s.operators[_owner][_operator];\n    }\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n    ///  `onERC721Received` on `_to` and throws if the return value is not\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param _data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external {\n        address sender = LibMeta.msgSender();\n        internalTransferFrom(sender, _from, _to, _tokenId);\n        LibERC721.checkOnERC721Received(sender, _from, _to, _tokenId, _data);\n    }\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    ///  except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external {\n        address sender = LibMeta.msgSender();\n        internalTransferFrom(sender, _from, _to, _tokenId);\n        LibERC721.checkOnERC721Received(sender, _from, _to, _tokenId, \"\");\n    }\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    ///  THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external {\n        address sender = LibMeta.msgSender();\n        internalTransferFrom(sender, _from, _to, _tokenId);\n    }\n\n    // This function is used by transfer functions\n    function internalTransferFrom(\n        address _sender,\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal {\n        require(_to != address(0), \"ER721: Can't transfer to 0 address\");\n        address owner = s.aavegotchis[_tokenId].owner;\n        require(owner != address(0), \"ERC721: Invalid tokenId or can't be transferred\");\n        require(\n            _sender == owner || s.operators[owner][_sender] || s.approved[_tokenId] == _sender,\n            \"AavegotchiFacet: Not owner or approved to transfer\"\n        );\n        require(_from == owner, \"ERC721: _from is not owner, transfer failed\");\n        s.aavegotchis[_tokenId].owner = _to;\n        s.aavegotchiBalance[_from]--;\n        s.aavegotchiBalance[_to]++;\n        if (s.approved[_tokenId] != address(0)) {\n            delete s.approved[_tokenId];\n            emit LibERC721.Approval(owner, address(0), _tokenId);\n        }\n        emit LibERC721.Transfer(_from, _to, _tokenId);\n    }\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external {\n        address owner = s.aavegotchis[_tokenId].owner;\n        address sender = LibMeta.msgSender();\n        require(owner == sender || s.operators[owner][sender], \"ERC721: Not owner or operator of token.\");\n        s.approved[_tokenId] = _approved;\n        emit LibERC721.Approval(owner, _approved, _tokenId);\n    }\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    ///  multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external {\n        address sender = LibMeta.msgSender();\n        s.operators[sender][_operator] = _approved;\n        emit LibERC721.ApprovalForAll(sender, _operator, _approved);\n    }\n\n    function name() external pure returns (string memory) {\n        return \"Aavegotchi\";\n    }\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external pure returns (string memory) {\n        return \"GOTCHI\";\n    }\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external pure returns (string memory) {\n        return LibStrings.strWithUint(\"https://aavegotchi.com/metadata/aavegotchis/\", _tokenId); //Here is your URL!\n    }\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"approved_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"approved_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokenIdsOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AavegotchiFacet","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}