{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-05-06\r\n*/\r\n\r\npragma solidity ^0.5.10;\r\n\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\r\n}\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 energy.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address who) public view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC721 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    // interface\r\n    function balanceOf(address _owner) public view returns (uint256);\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns (address);\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public;\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\r\n    function approve(address _approved, uint256 _tokenId) public;\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) public;\r\n\r\n    function getApproved(uint256 _tokenId) public view returns (address);\r\n\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n}\r\n\r\ncontract AuctionEngineV5 is ERC721TokenReceiver, ERC165 {\r\n    modifier trxAuction(uint256 auctionIndex) {\r\n        require(isTRXAuction(auctionIndex), \"auction only use trx\");\r\n        _;\r\n    }\r\n\r\n    modifier erc20Auction(uint256 auctionIndex) {\r\n        require(!isTRXAuction(auctionIndex), \"auction only use erc20\");\r\n        _;\r\n    }\r\n\r\n    using SafeMath for uint256;\r\n    event AuctionCreated(uint256 _index, address _creator, address _asset, uint256 _assetID);\r\n    event AuctionBid(uint256 _index, address _bidder, uint256 amount);\r\n    event ClaimTokens(uint256 auctionIndex, address claimer, uint256 amount);\r\n    event ClaimAsset(uint256 auctionIndex, address claimer);\r\n    enum Status {pending, active, finished}\r\n    struct Auction {\r\n        address assetAddress;\r\n        uint256 assetId;\r\n        uint256 startTime;\r\n        uint256 minPrice;\r\n        uint256 endTime;\r\n        uint256 currentBidAmount;\r\n        address currentBidOwner;\r\n        uint256 bidCount;\r\n        uint256 instantBuyPrice;\r\n        bool finished;\r\n        bool isWonBidSent;\r\n        address erc20tokenAddress; //If we prefer to accept erc20 token (like USDT) instead of trx;\r\n        address creator;\r\n        mapping(address => uint) pendingReturns;\r\n    }\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    Auction[] private auctions;\r\n\r\n    function createAuction(\r\n        address _assetAddress,\r\n        uint256 _assetId,\r\n        uint256 _startPrice,\r\n        uint256 _startTime,\r\n        uint256 _duration,\r\n        uint256 _instantBuyPrice,\r\n        address _erc20tokenAddress\r\n    ) public returns (uint256) {\r\n        require(ERC165(_assetAddress).supportsInterface(_INTERFACE_ID_ERC721), \"Not valid ERC721 asset\");\r\n        ERC721 asset = ERC721(_assetAddress);\r\n        asset.safeTransferFrom(msg.sender, address(this), _assetId, \"\");\r\n        if (_startTime == 0) {\r\n            _startTime = now;\r\n        }\r\n        require(_startTime >= now, \"Start time should be in future\");\r\n        require(_duration > 0, \"Duration should be positive\");\r\n\r\n        Auction memory auction = Auction({\r\n        assetAddress : _assetAddress,\r\n        assetId : _assetId,\r\n        startTime : _startTime,\r\n        endTime : _startTime.add(_duration),\r\n        minPrice : _startPrice,\r\n        currentBidAmount : 0,\r\n        currentBidOwner : msg.sender, //If no one binds, creator will be able to claim back the asset.\r\n        bidCount : 0,\r\n        instantBuyPrice : _instantBuyPrice,\r\n        finished : false,\r\n        creator : msg.sender,\r\n        isWonBidSent : false,\r\n        erc20tokenAddress: _erc20tokenAddress\r\n        });\r\n        uint256 index = auctions.push(auction) - 1;\r\n        emit AuctionCreated(index, msg.sender, _assetAddress, _assetId);\r\n        return index;\r\n    }\r\n\r\n    function isTRXAuction(uint256 auctionIndex) public view returns (bool) {\r\n        Auction storage auction = auctions[auctionIndex];\r\n        return auction.erc20tokenAddress == address(0);\r\n    }\r\n\r\n    function bidTRX(uint256 auctionIndex) public payable trxAuction(auctionIndex) {\r\n        _bid(auctionIndex, msg.value);\r\n    }\r\n\r\n    function bidERC20(uint256 auctionIndex, uint256 amount) public erc20Auction(auctionIndex) {\r\n        _bid(auctionIndex, amount);\r\n        Auction storage auction = auctions[auctionIndex];\r\n        ERC20 token = ERC20(auction.erc20tokenAddress);\r\n        require(token.transferFrom(msg.sender, address(this), amount));\r\n    }\r\n\r\n    function _bid(uint256 auctionIndex, uint256 amount) internal {\r\n        Auction storage auction = auctions[auctionIndex];\r\n        require(amount >= auction.minPrice, \"Value should be not smaller than start price\");\r\n        require(amount > auction.currentBidAmount, \"Value should be bigger the current bid\");\r\n\r\n        if (auction.currentBidAmount != 0) {\r\n            auction.pendingReturns[auction.currentBidOwner] += auction.currentBidAmount;\r\n        }\r\n        auction.currentBidAmount = amount;\r\n        auction.currentBidOwner = msg.sender;\r\n        auction.bidCount = auction.bidCount.add(1);\r\n        emit AuctionBid(auctionIndex, msg.sender, amount);\r\n    }\r\n\r\n    function getTotalAuctions() public view returns (uint256) {\r\n        return auctions.length;\r\n    }\r\n\r\n    function isActive(uint256 index) public view returns (bool) {\r\n        return getStatus(index) == Status.active;\r\n    }\r\n\r\n    function isFinished(uint256 index) public view returns (bool) {\r\n        return getStatus(index) == Status.finished;\r\n    }\r\n\r\n\r\n    function getStatus(uint256 index) public view returns (Status) {\r\n        Auction storage auction = auctions[index];\r\n        if (auction.finished) {\r\n            return Status.finished;\r\n        }\r\n\r\n        if (now < auction.startTime) {\r\n            return Status.pending;\r\n        }\r\n\tif (now < auction.endTime) {\r\n            return Status.active;\r\n        }\r\n\treturn Status.finished;\r\n    }\r\n\r\n    function getCurrentBidOwner(uint256 auctionIndex) public view returns (address) {\r\n        return auctions[auctionIndex].currentBidOwner;\r\n    }\r\n\r\n    function getCurrentBidAmount(uint256 auctionIndex) public view returns (uint256) {\r\n        return auctions[auctionIndex].currentBidAmount;\r\n    }\r\n\r\n    function getBidCount(uint256 auctionIndex) public view returns (uint256) {\r\n        return auctions[auctionIndex].bidCount;\r\n    }\r\n\r\n    function getWinner(uint256 auctionIndex) public view returns (address) {\r\n        require(isFinished(auctionIndex));\r\n        return auctions[auctionIndex].currentBidOwner;\r\n    }\r\n\r\n    function claimTokens(uint256 auctionIndex) public {\r\n        Auction storage auction = auctions[auctionIndex];\r\n        uint amount = auction.pendingReturns[msg.sender];\r\n\r\n        require(amount > 0, \"Nothing to claim\");\r\n\r\n        auction.pendingReturns[msg.sender] = 0;\r\n        _sendTo(auctionIndex, amount);\r\n        emit ClaimTokens(auctionIndex, msg.sender, amount);\r\n    }\r\n\r\n    function _sendTo(uint256 auctionIndex, uint256 amount) internal {\r\n        Auction storage auction = auctions[auctionIndex];\r\n        if (isTRXAuction(auctionIndex)) {\r\n            require(msg.sender.send(amount));\r\n        } else {\r\n            ERC20 token = ERC20(auction.erc20tokenAddress);\r\n            require(token.transfer(msg.sender, amount));\r\n        }\r\n    }\r\n\r\n    function claimAsset(uint256 auctionIndex) public {\r\n        address winner = getWinner(auctionIndex);\r\n        require(isFinished(auctionIndex), \"auction is not finished yet\");\r\n        require(winner == msg.sender, \"you are not winner\");\r\n\r\n        Auction storage auction = auctions[auctionIndex];\r\n        ERC721 asset = ERC721(auction.assetAddress);\r\n        asset.transferFrom(address(this), winner, auction.assetId);\r\n        emit ClaimAsset(auctionIndex, winner);\r\n    }\r\n\r\n    function claimWonBid(uint256 auctionIndex) public {\r\n        require(isFinished(auctionIndex), \"auction is not finished yet\");\r\n        Auction storage auction = auctions[auctionIndex];\r\n        require(auction.creator == msg.sender, \"not creator of auction\");\r\n        require(!auction.isWonBidSent, \"you already collected a won bid\");\r\n        auction.isWonBidSent = true;\r\n        _sendTo(auctionIndex, auction.currentBidAmount);\r\n    }\r\n\r\n\r\n    function instantBuyAssetWithTRX(uint256 auctionIndex) public payable trxAuction(auctionIndex) {\r\n        _instantBuy(auctionIndex, msg.value);\r\n    }\r\n\r\n    function instantBuyAssetWithERC20(uint256 auctionIndex, uint256 amount) public erc20Auction(auctionIndex) {\r\n        _instantBuy(auctionIndex, amount);\r\n        Auction storage auction = auctions[auctionIndex];\r\n        ERC20 token = ERC20(auction.erc20tokenAddress);\r\n        require(token.transferFrom(msg.sender, address(this), amount));\r\n    }\r\n    function _instantBuy(uint256 auctionIndex, uint256 amount) internal {\r\n        Auction storage auction = auctions[auctionIndex];\r\n\r\n        require(isActive(auctionIndex), \"Auction is not active\");\r\n        require(auction.instantBuyPrice > 0, \"Instant price was not set. This can not be bought instantly\");\r\n\r\n        require(amount >= auction.instantBuyPrice);\r\n\r\n        if (auction.currentBidAmount != 0) {\r\n            auction.pendingReturns[auction.currentBidOwner] += auction.currentBidAmount;\r\n        }\r\n\r\n        auction.currentBidAmount = amount;\r\n        auction.currentBidOwner = msg.sender;\r\n        auction.finished = true;\r\n    }\r\n\r\n    function onERC721Received(address, address, uint256, bytes calldata) external returns (bytes4) {\r\n        return 0xf0b9e5ba;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool) {\r\n        return interfaceID == 0x01ffc9a7 || // ERC165\r\n        interfaceID == 0xf0b9e5ba;\r\n        // ERC721TokenReceiver\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"instantBuyAssetWithTRX\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"bidTRX\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalAuctions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getCurrentBidAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getBidCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetAddress\",\"type\":\"address\"},{\"name\":\"_assetId\",\"type\":\"uint256\"},{\"name\":\"_startPrice\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_instantBuyPrice\",\"type\":\"uint256\"},{\"name\":\"_erc20tokenAddress\",\"type\":\"address\"}],\"name\":\"createAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getCurrentBidOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"isTRXAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"instantBuyAssetWithERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"claimAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"claimWonBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bidERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_assetID\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AuctionBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"claimer\",\"type\":\"address\"}],\"name\":\"ClaimAsset\",\"type\":\"event\"}]","ContractName":"AuctionEngineV5","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c39e168453874afb646b031bb479238d5b7dbc265ff4af125ec641fcde2833b6"}]}