{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/dependencies/open-zeppelin/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts with custom message when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/executor/ProposalValidatorMixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IDydxGovernor } from '../../interfaces/IDydxGovernor.sol';\\nimport { IGovernanceStrategy } from '../../interfaces/IGovernanceStrategy.sol';\\nimport { IProposalValidator } from '../../interfaces/IProposalValidator.sol';\\n\\n/**\\n * @title Proposal validator contract mixin, inherited the governance executor contract.\\n * @dev Validates/Invalidations propositions state modifications.\\n * Proposition Power functions: Validates proposition creations/ cancellation\\n * Voting Power functions: Validates success of propositions.\\n * @author dYdX\\n **/\\ncontract ProposalValidatorMixin is IProposalValidator {\\n  using SafeMath for uint256;\\n\\n  uint256 public immutable override PROPOSITION_THRESHOLD;\\n  uint256 public immutable override VOTING_DURATION;\\n  uint256 public immutable override VOTE_DIFFERENTIAL;\\n  uint256 public immutable override MINIMUM_QUORUM;\\n  uint256 public constant override ONE_HUNDRED_WITH_PRECISION = 10000; // Represents 100%.\\n\\n  /**\\n   * @dev Constructor\\n   * @param propositionThreshold minimum percentage of supply needed to submit a proposal\\n   * - In ONE_HUNDRED_WITH_PRECISION units\\n   * @param votingDuration duration in blocks of the voting period\\n   * @param voteDifferential percentage of supply that `for` votes need to be over `against`\\n   *   in order for the proposal to pass\\n   * - In ONE_HUNDRED_WITH_PRECISION units\\n   * @param minimumQuorum minimum percentage of the supply in FOR-voting-power need for a proposal to pass\\n   * - In ONE_HUNDRED_WITH_PRECISION units\\n   **/\\n  constructor(\\n    uint256 propositionThreshold,\\n    uint256 votingDuration,\\n    uint256 voteDifferential,\\n    uint256 minimumQuorum\\n  ) {\\n    PROPOSITION_THRESHOLD = propositionThreshold;\\n    VOTING_DURATION = votingDuration;\\n    VOTE_DIFFERENTIAL = voteDifferential;\\n    MINIMUM_QUORUM = minimumQuorum;\\n  }\\n\\n  /**\\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\\n   * @param governance Governance Contract\\n   * @param user Address of the proposal creator\\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\\n   * @return boolean, true if can be created\\n   **/\\n  function validateCreatorOfProposal(\\n    IDydxGovernor governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view override returns (bool) {\\n    return isPropositionPowerEnough(governance, user, blockNumber);\\n  }\\n\\n  /**\\n   * @dev Called to validate the cancellation of a proposal\\n   * Needs to creator to have lost proposition power threashold\\n   * @param governance Governance Contract\\n   * @param user Address of the proposal creator\\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\\n   * @return boolean, true if can be cancelled\\n   **/\\n  function validateProposalCancellation(\\n    IDydxGovernor governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view override returns (bool) {\\n    return !isPropositionPowerEnough(governance, user, blockNumber);\\n  }\\n\\n  /**\\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\\n   * @param governance Governance Contract\\n   * @param user Address of the user to be challenged.\\n   * @param blockNumber Block Number against which to make the challenge.\\n   * @return true if user has enough power\\n   **/\\n  function isPropositionPowerEnough(\\n    IDydxGovernor governance,\\n    address user,\\n    uint256 blockNumber\\n  ) public view override returns (bool) {\\n    IGovernanceStrategy currentGovernanceStrategy = IGovernanceStrategy(\\n      governance.getGovernanceStrategy()\\n    );\\n    return\\n      currentGovernanceStrategy.getPropositionPowerAt(user, blockNumber) >=\\n      getMinimumPropositionPowerNeeded(governance, blockNumber);\\n  }\\n\\n  /**\\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\\n   * @param governance Governance Contract\\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return minimum Proposition Power needed\\n   **/\\n  function getMinimumPropositionPowerNeeded(IDydxGovernor governance, uint256 blockNumber)\\n    public\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    IGovernanceStrategy currentGovernanceStrategy = IGovernanceStrategy(\\n      governance.getGovernanceStrategy()\\n    );\\n    return\\n      currentGovernanceStrategy\\n        .getTotalPropositionSupplyAt(blockNumber)\\n        .mul(PROPOSITION_THRESHOLD)\\n        .div(ONE_HUNDRED_WITH_PRECISION);\\n  }\\n\\n  /**\\n   * @dev Returns whether a proposal passed or not\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to set\\n   * @return true if proposal passed\\n   **/\\n  function isProposalPassed(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    override\\n    returns (bool)\\n  {\\n    return (isQuorumValid(governance, proposalId) &&\\n      isVoteDifferentialValid(governance, proposalId));\\n  }\\n\\n  /**\\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\\n   * @param votingSupply Total number of oustanding voting tokens\\n   * @return voting power needed for a proposal to pass\\n   **/\\n  function getMinimumVotingPowerNeeded(uint256 votingSupply)\\n    public\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return votingSupply.mul(MINIMUM_QUORUM).div(ONE_HUNDRED_WITH_PRECISION);\\n  }\\n\\n  /**\\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to verify\\n   * @return voting power needed for a proposal to pass\\n   **/\\n  function isQuorumValid(IDydxGovernor governance, uint256 proposalId)\\n    public\\n    view\\n    override\\n    returns (bool)\\n  {\\n    IDydxGovernor.ProposalWithoutVotes memory proposal = governance.getProposalById(proposalId);\\n    uint256 votingSupply = IGovernanceStrategy(proposal.strategy).getTotalVotingSupplyAt(\\n      proposal.startBlock\\n    );\\n\\n    return proposal.forVotes >= getMinimumVotingPowerNeeded(votingSupply);\\n  }\\n\\n  /**\\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to verify\\n   * @return true if enough For-Votes\\n   **/\\n  function isVoteDifferentialValid(IDydxGovernor governance, uint256 proposalId)\\n    public\\n    view\\n    override\\n    returns (bool)\\n  {\\n    IDydxGovernor.ProposalWithoutVotes memory proposal = governance.getProposalById(proposalId);\\n    uint256 votingSupply = IGovernanceStrategy(proposal.strategy).getTotalVotingSupplyAt(\\n      proposal.startBlock\\n    );\\n\\n    return (proposal.forVotes.mul(ONE_HUNDRED_WITH_PRECISION).div(votingSupply) >\\n      proposal.againstVotes.mul(ONE_HUNDRED_WITH_PRECISION).div(votingSupply).add(\\n        VOTE_DIFFERENTIAL\\n      ));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDydxGovernor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { IExecutorWithTimelock } from './IExecutorWithTimelock.sol';\\n\\ninterface IDydxGovernor {\\n\\n  enum ProposalState {\\n    Pending,\\n    Canceled,\\n    Active,\\n    Failed,\\n    Succeeded,\\n    Queued,\\n    Expired,\\n    Executed\\n  }\\n\\n  struct Vote {\\n    bool support;\\n    uint248 votingPower;\\n  }\\n\\n  struct Proposal {\\n    uint256 id;\\n    address creator;\\n    IExecutorWithTimelock executor;\\n    address[] targets;\\n    uint256[] values;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n    uint256 startBlock;\\n    uint256 endBlock;\\n    uint256 executionTime;\\n    uint256 forVotes;\\n    uint256 againstVotes;\\n    bool executed;\\n    bool canceled;\\n    address strategy;\\n    bytes32 ipfsHash;\\n    mapping(address => Vote) votes;\\n  }\\n\\n  struct ProposalWithoutVotes {\\n    uint256 id;\\n    address creator;\\n    IExecutorWithTimelock executor;\\n    address[] targets;\\n    uint256[] values;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n    uint256 startBlock;\\n    uint256 endBlock;\\n    uint256 executionTime;\\n    uint256 forVotes;\\n    uint256 againstVotes;\\n    bool executed;\\n    bool canceled;\\n    address strategy;\\n    bytes32 ipfsHash;\\n  }\\n\\n  /**\\n   * @dev emitted when a new proposal is created\\n   * @param id Id of the proposal\\n   * @param creator address of the creator\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param targets list of contracts called by proposal's associated transactions\\n   * @param values list of value in wei for each propoposal's associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\\n   * @param startBlock block number when vote starts\\n   * @param endBlock block number when vote ends\\n   * @param strategy address of the governanceStrategy contract\\n   * @param ipfsHash IPFS hash of the proposal\\n   **/\\n  event ProposalCreated(\\n    uint256 id,\\n    address indexed creator,\\n    IExecutorWithTimelock indexed executor,\\n    address[] targets,\\n    uint256[] values,\\n    string[] signatures,\\n    bytes[] calldatas,\\n    bool[] withDelegatecalls,\\n    uint256 startBlock,\\n    uint256 endBlock,\\n    address strategy,\\n    bytes32 ipfsHash\\n  );\\n\\n  /**\\n   * @dev emitted when a proposal is canceled\\n   * @param id Id of the proposal\\n   **/\\n  event ProposalCanceled(uint256 id);\\n\\n  /**\\n   * @dev emitted when a proposal is queued\\n   * @param id Id of the proposal\\n   * @param executionTime time when proposal underlying transactions can be executed\\n   * @param initiatorQueueing address of the initiator of the queuing transaction\\n   **/\\n  event ProposalQueued(uint256 id, uint256 executionTime, address indexed initiatorQueueing);\\n  /**\\n   * @dev emitted when a proposal is executed\\n   * @param id Id of the proposal\\n   * @param initiatorExecution address of the initiator of the execution transaction\\n   **/\\n  event ProposalExecuted(uint256 id, address indexed initiatorExecution);\\n  /**\\n   * @dev emitted when a vote is registered\\n   * @param id Id of the proposal\\n   * @param voter address of the voter\\n   * @param support boolean, true = vote for, false = vote against\\n   * @param votingPower Power of the voter/vote\\n   **/\\n  event VoteEmitted(uint256 id, address indexed voter, bool support, uint256 votingPower);\\n\\n  event GovernanceStrategyChanged(address indexed newStrategy, address indexed initiatorChange);\\n\\n  event VotingDelayChanged(uint256 newVotingDelay, address indexed initiatorChange);\\n\\n  event ExecutorAuthorized(address executor);\\n\\n  event ExecutorUnauthorized(address executor);\\n\\n  /**\\n   * @dev Creates a Proposal (needs Proposition Power of creator > Threshold)\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param targets list of contracts called by proposal's associated transactions\\n   * @param values list of value in wei for each propoposal's associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\\n   * @param withDelegatecalls if true, transaction delegatecalls the taget, else calls the target\\n   * @param ipfsHash IPFS hash of the proposal\\n   **/\\n  function create(\\n    IExecutorWithTimelock executor,\\n    address[] memory targets,\\n    uint256[] memory values,\\n    string[] memory signatures,\\n    bytes[] memory calldatas,\\n    bool[] memory withDelegatecalls,\\n    bytes32 ipfsHash\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Cancels a Proposal, when proposal is Pending/Active and threshold no longer reached\\n   * @param proposalId id of the proposal\\n   **/\\n  function cancel(uint256 proposalId) external;\\n\\n  /**\\n   * @dev Queue the proposal (If Proposal Succeeded)\\n   * @param proposalId id of the proposal to queue\\n   **/\\n  function queue(uint256 proposalId) external;\\n\\n  /**\\n   * @dev Execute the proposal (If Proposal Queued)\\n   * @param proposalId id of the proposal to execute\\n   **/\\n  function execute(uint256 proposalId) external payable;\\n\\n  /**\\n   * @dev Function allowing msg.sender to vote for/against a proposal\\n   * @param proposalId id of the proposal\\n   * @param support boolean, true = vote for, false = vote against\\n   **/\\n  function submitVote(uint256 proposalId, bool support) external;\\n\\n  /**\\n   * @dev Function to register the vote of user that has voted offchain via signature\\n   * @param proposalId id of the proposal\\n   * @param support boolean, true = vote for, false = vote against\\n   * @param v v part of the voter signature\\n   * @param r r part of the voter signature\\n   * @param s s part of the voter signature\\n   **/\\n  function submitVoteBySignature(\\n    uint256 proposalId,\\n    bool support,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Set new GovernanceStrategy\\n   * Note: owner should be a timelocked executor, so needs to make a proposal\\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\\n   **/\\n  function setGovernanceStrategy(address governanceStrategy) external;\\n\\n  /**\\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\\n   * Note: owner should be a timelocked executor, so needs to make a proposal\\n   * @param votingDelay new voting delay in seconds\\n   **/\\n  function setVotingDelay(uint256 votingDelay) external;\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized executors\\n   * @param executors list of new addresses to be authorized executors\\n   **/\\n  function authorizeExecutors(address[] memory executors) external;\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized executors\\n   * @param executors list of addresses to be removed as authorized executors\\n   **/\\n  function unauthorizeExecutors(address[] memory executors) external;\\n\\n  /**\\n   * @dev Getter of the current GovernanceStrategy address\\n   * @return The address of the current GovernanceStrategy contracts\\n   **/\\n  function getGovernanceStrategy() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\\n   * Different from the voting duration\\n   * @return The voting delay in seconds\\n   **/\\n  function getVotingDelay() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns whether an address is an authorized executor\\n   * @param executor address to evaluate as authorized executor\\n   * @return true if authorized\\n   **/\\n  function isExecutorAuthorized(address executor) external view returns (bool);\\n\\n  /**\\n   * @dev Getter of the proposal count (the current number of proposals ever created)\\n   * @return the proposal count\\n   **/\\n  function getProposalsCount() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of a proposal by id\\n   * @param proposalId id of the proposal to get\\n   * @return the proposal as ProposalWithoutVotes memory object\\n   **/\\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVotes memory);\\n\\n  /**\\n   * @dev Getter of the Vote of a voter about a proposal\\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @return The associated Vote memory object\\n   **/\\n  function getVoteOnProposal(uint256 proposalId, address voter) external view returns (Vote memory);\\n\\n  /**\\n   * @dev Get the current state of a proposal\\n   * @param proposalId id of the proposal\\n   * @return The current state if the proposal\\n   **/\\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernanceStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\ninterface IGovernanceStrategy {\\n\\n  /**\\n   * @dev Returns the Proposition Power of a user at a specific block number.\\n   * @param user Address of the user.\\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\\n   * @return Power number\\n   **/\\n  function getPropositionPowerAt(address user, uint256 blockNumber) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the total supply of Outstanding Proposition Tokens\\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return total supply at blockNumber\\n   **/\\n  function getTotalPropositionSupplyAt(uint256 blockNumber) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the total supply of Outstanding Voting Tokens\\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return total supply at blockNumber\\n   **/\\n  function getTotalVotingSupplyAt(uint256 blockNumber) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the Vote Power of a user at a specific block number.\\n   * @param user Address of the user.\\n   * @param blockNumber Blocknumber at which to fetch Vote Power\\n   * @return Vote number\\n   **/\\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IProposalValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { IDydxGovernor } from './IDydxGovernor.sol';\\n\\ninterface IProposalValidator {\\n\\n  /**\\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\\n   * @param governance Governance Contract\\n   * @param user Address of the proposal creator\\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\\n   * @return boolean, true if can be created\\n   **/\\n  function validateCreatorOfProposal(\\n    IDydxGovernor governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Called to validate the cancellation of a proposal\\n   * @param governance Governance Contract\\n   * @param user Address of the proposal creator\\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\\n   * @return boolean, true if can be cancelled\\n   **/\\n  function validateProposalCancellation(\\n    IDydxGovernor governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\\n   * @param governance Governance Contract\\n   * @param user Address of the user to be challenged.\\n   * @param blockNumber Block Number against which to make the challenge.\\n   * @return true if user has enough power\\n   **/\\n  function isPropositionPowerEnough(\\n    IDydxGovernor governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\\n   * @param governance Governance Contract\\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return minimum Proposition Power needed\\n   **/\\n  function getMinimumPropositionPowerNeeded(IDydxGovernor governance, uint256 blockNumber)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Returns whether a proposal passed or not\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to set\\n   * @return true if proposal passed\\n   **/\\n  function isProposalPassed(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to verify\\n   * @return voting power needed for a proposal to pass\\n   **/\\n  function isQuorumValid(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to verify\\n   * @return true if enough For-Votes\\n   **/\\n  function isVoteDifferentialValid(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\\n   * @param votingSupply Total number of oustanding voting tokens\\n   * @return voting power needed for a proposal to pass\\n   **/\\n  function getMinimumVotingPowerNeeded(uint256 votingSupply) external view returns (uint256);\\n\\n  /**\\n   * @dev Get proposition threshold constant value\\n   * @return the proposition threshold value (100 <=> 1%)\\n   **/\\n  function PROPOSITION_THRESHOLD() external view returns (uint256);\\n\\n  /**\\n   * @dev Get voting duration constant value\\n   * @return the voting duration value in seconds\\n   **/\\n  function VOTING_DURATION() external view returns (uint256);\\n\\n  /**\\n   * @dev Get the vote differential threshold constant value\\n   * to compare with % of for votes/total supply - % of against votes/total supply\\n   * @return the vote differential threshold value (100 <=> 1%)\\n   **/\\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\\n\\n  /**\\n   * @dev Get quorum threshold constant value\\n   * to compare with % of for votes/total supply\\n   * @return the quorum threshold value (100 <=> 1%)\\n   **/\\n  function MINIMUM_QUORUM() external view returns (uint256);\\n\\n  /**\\n   * @dev precision helper: 100% = 10000\\n   * @return one hundred percents with our chosen precision\\n   **/\\n  function ONE_HUNDRED_WITH_PRECISION() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IExecutorWithTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { IDydxGovernor } from './IDydxGovernor.sol';\\n\\ninterface IExecutorWithTimelock {\\n  /**\\n   * @dev emitted when a new pending admin is set\\n   * @param newPendingAdmin address of the new pending admin\\n   **/\\n  event NewPendingAdmin(address newPendingAdmin);\\n\\n  /**\\n   * @dev emitted when a new admin is set\\n   * @param newAdmin address of the new admin\\n   **/\\n  event NewAdmin(address newAdmin);\\n\\n  /**\\n   * @dev emitted when a new delay (between queueing and execution) is set\\n   * @param delay new delay\\n   **/\\n  event NewDelay(uint256 delay);\\n\\n  /**\\n   * @dev emitted when a new (trans)action is Queued.\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  event QueuedAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  );\\n\\n  /**\\n   * @dev emitted when an action is Cancelled\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  event CancelledAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  );\\n\\n  /**\\n   * @dev emitted when an action is Cancelled\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @param resultData the actual callData used on the target\\n   **/\\n  event ExecutedAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall,\\n    bytes resultData\\n  );\\n\\n  /**\\n   * @dev Getter of the current admin address (should be governance)\\n   * @return The address of the current admin\\n   **/\\n  function getAdmin() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the current pending admin address\\n   * @return The address of the pending admin\\n   **/\\n  function getPendingAdmin() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the delay between queuing and execution\\n   * @return The delay in seconds\\n   **/\\n  function getDelay() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns whether an action (via actionHash) is queued\\n   * @param actionHash hash of the action to be checked\\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\\n   * @return true if underlying action of actionHash is queued\\n   **/\\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\\n\\n  /**\\n   * @dev Checks whether a proposal is over its grace period\\n   * @param governance Governance contract\\n   * @param proposalId Id of the proposal against which to test\\n   * @return true of proposal is over grace period\\n   **/\\n  function isProposalOverGracePeriod(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Getter of grace period constant\\n   * @return grace period in seconds\\n   **/\\n  function GRACE_PERIOD() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of minimum delay constant\\n   * @return minimum delay in seconds\\n   **/\\n  function MINIMUM_DELAY() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of maximum delay constant\\n   * @return maximum delay in seconds\\n   **/\\n  function MAXIMUM_DELAY() external view returns (uint256);\\n\\n  /**\\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external returns (bytes32);\\n\\n  /**\\n   * @dev Function, called by Governance, that executes a transaction, returns the callData executed\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external payable returns (bytes memory);\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/governance/executor/ExecutorWithTimelockMixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IExecutorWithTimelock } from '../../interfaces/IExecutorWithTimelock.sol';\\nimport { IDydxGovernor } from '../../interfaces/IDydxGovernor.sol';\\n\\n/**\\n * @title Time-locked executor contract mixin, inherited the governance executor contract.\\n * @dev Contract that can queue, execute, cancel transactions voted by Governance\\n * Queued transactions can be executed after a delay and until\\n * Grace period is not over.\\n * @author dYdX\\n **/\\ncontract ExecutorWithTimelockMixin is IExecutorWithTimelock {\\n  using SafeMath for uint256;\\n\\n  uint256 public immutable override GRACE_PERIOD;\\n  uint256 public immutable override MINIMUM_DELAY;\\n  uint256 public immutable override MAXIMUM_DELAY;\\n\\n  address private _admin;\\n  address private _pendingAdmin;\\n  uint256 private _delay;\\n\\n  mapping(bytes32 => bool) private _queuedTransactions;\\n\\n  /**\\n   * @dev Constructor\\n   * @param admin admin address, that can call the main functions, (Governance)\\n   * @param delay minimum time between queueing and execution of proposal\\n   * @param gracePeriod time after `delay` while a proposal can be executed\\n   * @param minimumDelay lower threshold of `delay`, in seconds\\n   * @param maximumDelay upper threhold of `delay`, in seconds\\n   **/\\n  constructor(\\n    address admin,\\n    uint256 delay,\\n    uint256 gracePeriod,\\n    uint256 minimumDelay,\\n    uint256 maximumDelay\\n  ) {\\n    require(delay >= minimumDelay, 'DELAY_SHORTER_THAN_MINIMUM');\\n    require(delay <= maximumDelay, 'DELAY_LONGER_THAN_MAXIMUM');\\n    _delay = delay;\\n    _admin = admin;\\n\\n    GRACE_PERIOD = gracePeriod;\\n    MINIMUM_DELAY = minimumDelay;\\n    MAXIMUM_DELAY = maximumDelay;\\n\\n    emit NewDelay(delay);\\n    emit NewAdmin(admin);\\n  }\\n\\n  modifier onlyAdmin() {\\n    require(msg.sender == _admin, 'ONLY_BY_ADMIN');\\n    _;\\n  }\\n\\n  modifier onlyTimelock() {\\n    require(msg.sender == address(this), 'ONLY_BY_THIS_TIMELOCK');\\n    _;\\n  }\\n\\n  modifier onlyPendingAdmin() {\\n    require(msg.sender == _pendingAdmin, 'ONLY_BY_PENDING_ADMIN');\\n    _;\\n  }\\n\\n  /**\\n   * @dev Set the delay\\n   * @param delay delay between queue and execution of proposal\\n   **/\\n  function setDelay(uint256 delay) public onlyTimelock {\\n    _validateDelay(delay);\\n    _delay = delay;\\n\\n    emit NewDelay(delay);\\n  }\\n\\n  /**\\n   * @dev Function enabling pending admin to become admin\\n   **/\\n  function acceptAdmin() public onlyPendingAdmin {\\n    _admin = msg.sender;\\n    _pendingAdmin = address(0);\\n\\n    emit NewAdmin(msg.sender);\\n  }\\n\\n  /**\\n   * @dev Setting a new pending admin (that can then become admin)\\n   * Can only be called by this executor (i.e via proposal)\\n   * @param newPendingAdmin address of the new admin\\n   **/\\n  function setPendingAdmin(address newPendingAdmin) public onlyTimelock {\\n    _pendingAdmin = newPendingAdmin;\\n\\n    emit NewPendingAdmin(newPendingAdmin);\\n  }\\n\\n  /**\\n   * @dev Function, called by Governance, that queues a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @return the action Hash\\n   **/\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) public override onlyAdmin returns (bytes32) {\\n    require(executionTime >= block.timestamp.add(_delay), 'EXECUTION_TIME_UNDERESTIMATED');\\n\\n    bytes32 actionHash = keccak256(\\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\\n    );\\n    _queuedTransactions[actionHash] = true;\\n\\n    emit QueuedAction(actionHash, target, value, signature, data, executionTime, withDelegatecall);\\n    return actionHash;\\n  }\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @return the action Hash of the canceled tx\\n   **/\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) public override onlyAdmin returns (bytes32) {\\n    bytes32 actionHash = keccak256(\\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\\n    );\\n    _queuedTransactions[actionHash] = false;\\n\\n    emit CancelledAction(\\n      actionHash,\\n      target,\\n      value,\\n      signature,\\n      data,\\n      executionTime,\\n      withDelegatecall\\n    );\\n    return actionHash;\\n  }\\n\\n  /**\\n   * @dev Function, called by Governance, that executes a transaction, returns the callData executed\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @return the callData executed as memory bytes\\n   **/\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) public payable override onlyAdmin returns (bytes memory) {\\n    bytes32 actionHash = keccak256(\\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\\n    );\\n    require(_queuedTransactions[actionHash], 'ACTION_NOT_QUEUED');\\n    require(block.timestamp >= executionTime, 'TIMELOCK_NOT_FINISHED');\\n    require(block.timestamp <= executionTime.add(GRACE_PERIOD), 'GRACE_PERIOD_FINISHED');\\n\\n    _queuedTransactions[actionHash] = false;\\n\\n    bytes memory callData;\\n\\n    if (bytes(signature).length == 0) {\\n      callData = data;\\n    } else {\\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\n    }\\n\\n    bool success;\\n    bytes memory resultData;\\n    if (withDelegatecall) {\\n      require(msg.value >= value, \\\"NOT_ENOUGH_MSG_VALUE\\\");\\n      // solium-disable-next-line security/no-call-value\\n      (success, resultData) = target.delegatecall(callData);\\n    } else {\\n      // solium-disable-next-line security/no-call-value\\n      (success, resultData) = target.call{value: value}(callData);\\n    }\\n\\n    require(success, 'FAILED_ACTION_EXECUTION');\\n\\n    emit ExecutedAction(\\n      actionHash,\\n      target,\\n      value,\\n      signature,\\n      data,\\n      executionTime,\\n      withDelegatecall,\\n      resultData\\n    );\\n\\n    return resultData;\\n  }\\n\\n  /**\\n   * @dev Getter of the current admin address (should be governance)\\n   * @return The address of the current admin\\n   **/\\n  function getAdmin() external view override returns (address) {\\n    return _admin;\\n  }\\n\\n  /**\\n   * @dev Getter of the current pending admin address\\n   * @return The address of the pending admin\\n   **/\\n  function getPendingAdmin() external view override returns (address) {\\n    return _pendingAdmin;\\n  }\\n\\n  /**\\n   * @dev Getter of the delay between queuing and execution\\n   * @return The delay in seconds\\n   **/\\n  function getDelay() external view override returns (uint256) {\\n    return _delay;\\n  }\\n\\n  /**\\n   * @dev Returns whether an action (via actionHash) is queued\\n   * @param actionHash hash of the action to be checked\\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\\n   * @return true if underlying action of actionHash is queued\\n   **/\\n  function isActionQueued(bytes32 actionHash) external view override returns (bool) {\\n    return _queuedTransactions[actionHash];\\n  }\\n\\n  /**\\n   * @dev Checks whether a proposal is over its grace period\\n   * @param governance Governance contract\\n   * @param proposalId Id of the proposal against which to test\\n   * @return true of proposal is over grace period\\n   **/\\n  function isProposalOverGracePeriod(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    override\\n    returns (bool)\\n  {\\n    IDydxGovernor.ProposalWithoutVotes memory proposal = governance.getProposalById(proposalId);\\n\\n    return (block.timestamp > proposal.executionTime.add(GRACE_PERIOD));\\n  }\\n\\n  function _validateDelay(uint256 delay) internal view {\\n    require(delay >= MINIMUM_DELAY, 'DELAY_SHORTER_THAN_MINIMUM');\\n    require(delay <= MAXIMUM_DELAY, 'DELAY_LONGER_THAN_MAXIMUM');\\n  }\\n\\n  receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/governance/executor/Executor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n//\\n// Contracts by dYdX Foundation. Individual files are released under different licenses.\\n//\\n// https://dydx.community\\n// https://github.com/dydxfoundation/governance-contracts\\n\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { ExecutorWithTimelockMixin } from './ExecutorWithTimelockMixin.sol';\\nimport { ProposalValidatorMixin } from './ProposalValidatorMixin.sol';\\n\\n/**\\n * @title Time Locked, Validator, Executor Contract\\n * @dev Contract\\n * - Validate Proposal creations/ cancellation\\n * - Validate Vote Quorum and Vote success on proposal\\n * - Queue, Execute, Cancel, successful proposals' transactions.\\n * @author dYdX\\n **/\\ncontract Executor is ExecutorWithTimelockMixin, ProposalValidatorMixin {\\n  constructor(\\n    address admin,\\n    uint256 delay,\\n    uint256 gracePeriod,\\n    uint256 minimumDelay,\\n    uint256 maximumDelay,\\n    uint256 propositionThreshold,\\n    uint256 voteDuration,\\n    uint256 voteDifferential,\\n    uint256 minimumQuorum\\n  )\\n    ExecutorWithTimelockMixin(admin, delay, gracePeriod, minimumDelay, maximumDelay)\\n    ProposalValidatorMixin(propositionThreshold, voteDuration, voteDifferential, minimumQuorum)\\n  {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gracePeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"propositionThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteDifferential\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumQuorum\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"actionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"}],\"name\":\"CancelledAction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"actionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"resultData\",\"type\":\"bytes\"}],\"name\":\"ExecutedAction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"NewDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"actionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"}],\"name\":\"QueuedAction\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GRACE_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_QUORUM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_HUNDRED_WITH_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROPOSITION_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VOTE_DIFFERENTIAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VOTING_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"}],\"name\":\"cancelTransaction\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"}],\"name\":\"executeTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDydxGovernor\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getMinimumPropositionPowerNeeded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"votingSupply\",\"type\":\"uint256\"}],\"name\":\"getMinimumVotingPowerNeeded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"actionHash\",\"type\":\"bytes32\"}],\"name\":\"isActionQueued\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDydxGovernor\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"isProposalOverGracePeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDydxGovernor\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"isProposalPassed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDydxGovernor\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"isPropositionPowerEnough\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDydxGovernor\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"isQuorumValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDydxGovernor\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"isVoteDifferentialValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"}],\"name\":\"queueTransaction\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"setDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDydxGovernor\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"validateCreatorOfProposal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDydxGovernor\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"validateProposalCancellation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Executor","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007e9b1672616ff6d6629ef2879419aae79a9018d20000000000000000000000000000000000000000000000000000000000093a800000000000000000000000000000000000000000000000000000000000093a80000000000000000000000000000000000000000000000000000000000006978000000000000000000000000000000000000000000000000000000000001baf8000000000000000000000000000000000000000000000000000000000000000c800000000000000000000000000000000000000000000000000000000000100a400000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000003e8","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}