{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity =0.6.6;\r\n\r\ninterface IUniswapV2Pair {\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\n\r\ncontract Swap  {\r\n     using SafeMath for uint;\r\n\r\n    address public factory = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\r\n    \r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n\r\n    function pairFor(address tokenA, address tokenB) internal view returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\r\n            ))));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::transferFrom: transferFrom failed'\r\n        );\r\n    }\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    function swapTokensForTokens(\r\n        uint amountIn,\r\n        address[] memory path,\r\n        uint _reserveIn,\r\n        uint _reserveOut,\r\n        address to,\r\n        uint deadline\r\n    )  public ensure(deadline) returns (uint amountOut) {\r\n        amountOut = getAmountOut(amountIn, _reserveIn, _reserveOut);\r\n        safeTransferFrom(\r\n            path[0], msg.sender, pairFor(path[0], path[1]), amountIn\r\n        );\r\n        _swap(amountOut, path, to);\r\n    }\r\n\r\n    function _swap(uint amountOut, address[] memory path, address to) internal  {\r\n        (address input, address output) = (path[0], path[1]);\r\n        (address token0,) = sortTokens(input, output);\r\n        (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n        IUniswapV2Pair(pairFor(input, output)).swap(\r\n            amount0Out, amount1Out, to, new bytes(0)\r\n        );\r\n    }\r\n\r\n\r\n}","ABI":"[{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Swap","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://55c6b6c497f8c02e5bb57bfebf3a3b84d58572ec75c248bdaf2f28f7e1597bee"}]}