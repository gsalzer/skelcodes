{"status":"1","message":"OK","result":[{"SourceCode":"{\"BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gonçalo Sá \\u003cgoncalo.sa@consensys.net\\u003e\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity 0.8.4;\\n\\nlibrary BytesLib {\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_length + 31 \\u003e= _length, \\u0027slice_overflow\\u0027);\\n        require(_start + _length \\u003e= _start, \\u0027slice_overflow\\u0027);\\n        require(_bytes.length \\u003e= _start + _length, \\u0027slice_outOfBounds\\u0027);\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n                case 0 {\\n                    // Get a location of some free memory and store it in tempBytes as\\n                    // Solidity does for memory variables.\\n                    tempBytes := mload(0x40)\\n\\n                    // The first word of the slice result is potentially a partial\\n                    // word read from the original array. To read it, we calculate\\n                    // the length of that partial word and start copying that many\\n                    // bytes into the array. The first word we copy will start with\\n                    // data we don\\u0027t care about, but the last `lengthmod` bytes will\\n                    // land at the beginning of the contents of the new array. When\\n                    // we\\u0027re done copying, we overwrite the full first word with\\n                    // the actual length of the slice.\\n                    let lengthmod := and(_length, 31)\\n\\n                    // The multiplication in the next line is necessary\\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                    // the following copy loop was copying the origin\\u0027s length\\n                    // and then ending prematurely not copying everything it should.\\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                    let end := add(mc, _length)\\n\\n                    for {\\n                        // The multiplication in the next line has the same exact purpose\\n                        // as the one above.\\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                    } lt(mc, end) {\\n                        mc := add(mc, 0x20)\\n                        cc := add(cc, 0x20)\\n                    } {\\n                        mstore(mc, mload(cc))\\n                    }\\n\\n                    mstore(tempBytes, _length)\\n\\n                    //update free-memory pointer\\n                    //allocating the array padded to 32 bytes like the compiler does now\\n                    mstore(0x40, and(add(mc, 31), not(31)))\\n                }\\n                //if we want a zero-length slice let\\u0027s just return a zero-length array\\n                default {\\n                    tempBytes := mload(0x40)\\n                    //zero out the 32 bytes slice we are about to return\\n                    //we need to do it because Solidity does not garbage collect\\n                    mstore(tempBytes, 0)\\n\\n                    mstore(0x40, add(tempBytes, 0x20))\\n                }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_start + 20 \\u003e= _start, \\u0027toAddress_overflow\\u0027);\\n        require(_bytes.length \\u003e= _start + 20, \\u0027toAddress_outOfBounds\\u0027);\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\\n        require(_start + 3 \\u003e= _start, \\u0027toUint24_overflow\\u0027);\\n        require(_bytes.length \\u003e= _start + 3, \\u0027toUint24_outOfBounds\\u0027);\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"IUniswapV3Router.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface IUniswapV3Router{\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\"},\"matrEXRouterV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IUniswapV3Router.sol\\\";\\nimport {Path} from \\\"./Path.sol\\\";\\n\\ncontract matrEXRouterV3 is Ownable, IUniswapV3Router{\\n    using Path for bytes;\\n\\n    /**\\n    * @dev Event emitted when the charity fee is taken\\n    * @param from: The user it is taken from\\n    * @param token: The token that was taken from the user\\n    * @param amount: The amount of the token taken for charity\\n    */\\n    event feeTaken(address from, IERC20 token, uint256 amount);\\n\\n    /**\\n    * @dev Event emitted when the charity fee is taken (in ETH)\\n    * @param from: The user it was taken from\\n    * @param amount: The amount of ETH taken in wei\\n    */\\n    event feeTakenInETH(address from, uint256 amount);\\n\\n    /**\\n    * @dev Event emmited when a token is approved for trade for the first\\n    * time on Uniswap (check takeFeeAndApprove())\\n    * @param token: The tokens that was approved for trade\\n    */\\n    event approvedForTrade(IERC20 token);\\n\\n    /**\\n    * @dev \\n    * _charityFee: The % that is taken from each swap that gets sent to charity\\n    * _charityAddress: The address that the charity funds get sent to\\n    * _uniswapV3Router: Uniswap router that all swaps go through\\n    * WETH: The address of the WETH token\\n    */\\n    uint256 private _charityFee;\\n    address private _charityAddress;\\n    IUniswapV3Router private _uniswapV3Router;\\n    address private WETH;\\n\\n    /**\\n    * @dev Sets the Uniswap router, the charity fee, the charity address and\\n    * the WETH token address \\n    */\\n    constructor(){\\n        _uniswapV3Router = IUniswapV3Router(0xE592427A0AEce92De3Edee1F18E0157C05861564);\\n        _charityFee = 20;\\n        _charityAddress = address(0x830be1dba01bfF12C706b967AcDeCd2fDEa48990);\\n        WETH = address(0xc778417E063141139Fce010982780140Aa0cD5Ab);\\n    }\\n\\n    /**\\n    * @dev Calculates the fee and takes it, transfers the fee to the charity\\n    * address and the remains to this contract.\\n    * emits feeTaken()\\n    * Then, it checks if there is enough approved for the swap, if not it\\n    * approves it to the uniswap contract. Emits approvedForTrade() if so.\\n    * @param user: The payer\\n    * @param token: The token that will be swapped and the fee will be paid\\n    * in\\n    * @param totalAmount: The total amount of tokens that will be swapped, will\\n    * be used to calculate how much the fee will be\\n    */\\n    function takeFeeAndApprove(address user, IERC20 token, uint256 totalAmount) internal returns (uint256){\\n        uint256 _feeTaken = (totalAmount / 10000) * _charityFee;\\n        token.transferFrom(user, address(this), totalAmount - _feeTaken);\\n        token.transferFrom(user, _charityAddress, _feeTaken);\\n        if (token.allowance(address(this), address(_uniswapV3Router)) \\u003c totalAmount){\\n            token.approve(address(_uniswapV3Router), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n            emit approvedForTrade(token);\\n        }\\n        emit feeTaken(user, token, _feeTaken);\\n        return totalAmount -= _feeTaken;\\n    }\\n\\n    /**\\n    * @dev Calculates the fee and takes it, transfers the fee to the charity\\n    * address and the remains to this contract.\\n    * emits feeTakenInETH()\\n    * @param totalAmount: The total amount of tokens that will be swapped, will\\n    * be used to calculate how much the fee will be\\n    */   \\n    function takeFeeETH(uint256 totalAmount) internal returns (uint256 fee){\\n        uint256 _feeTaken = (totalAmount / 10000) * _charityFee;\\n        payable(_charityAddress).transfer(_feeTaken);\\n        emit feeTakenInETH(_msgSender(), _feeTaken);\\n        return totalAmount - _feeTaken;\\n    }\\n    \\n    /**\\n    * @dev The functions below are all the same as the Uniswap contract but\\n    * they call takeFeeAndApprove() or takeFeeETH() (See the functions above)\\n    * and deduct the fee from the amount that will be traded.\\n    */\\n    \\n    function exactInputSingle(ExactInputSingleParams calldata params) external virtual override payable returns (uint256){\\n        if (params.tokenIn == WETH \\u0026\\u0026 msg.value \\u003e= params.amountIn){\\n            uint256 newValue = takeFeeETH(params.amountIn);\\n            ExactInputSingleParams memory params_ = params;\\n            params_.amountIn = newValue;\\n            return _uniswapV3Router.exactInputSingle{value: params_.amountIn}(params_);\\n        }else{\\n            IERC20 token = IERC20(params.tokenIn);\\n            uint256 newAmount = takeFeeAndApprove(_msgSender(), token, params.amountIn);\\n            ExactInputSingleParams memory _params = params;\\n            _params.amountIn = newAmount;\\n            return _uniswapV3Router.exactInputSingle(_params);\\n        }\\n    }\\n    \\n    function exactInput(ExactInputParams calldata params) external virtual override payable returns (uint256){\\n        (address tokenIn, address tokenOut, uint24 fee) = params.path.decodeFirstPool();\\n        if (tokenIn == WETH \\u0026\\u0026 msg.value \\u003e= params.amountIn){\\n            uint256 newValue = takeFeeETH(params.amountIn);\\n            ExactInputParams memory params_ = params;\\n            params_.amountIn = newValue;\\n            return _uniswapV3Router.exactInput{value: params_.amountIn}(params_);\\n        }else{\\n            IERC20 token = IERC20(tokenIn);\\n            uint256 newAmount = takeFeeAndApprove(_msgSender(), IERC20(token), params.amountIn);\\n            ExactInputParams memory _params = params;\\n            _params.amountIn = newAmount;\\n            return _uniswapV3Router.exactInput(_params);\\n        }\\n    }\\n    \\n     function exactOutputSingle(ExactOutputSingleParams calldata params) external virtual payable override returns (uint256){\\n        if (params.tokenIn == address(WETH) \\u0026\\u0026 msg.value \\u003e= params.amountOut){\\n            uint256 newValue = takeFeeETH(params.amountOut);\\n            ExactOutputSingleParams memory params_ = params;\\n            params_.amountOut = newValue;\\n            return _uniswapV3Router.exactOutputSingle{value: params_.amountOut}(params_);\\n        }else{\\n            IERC20 token = IERC20(params.tokenIn);\\n            uint256 newAmount = takeFeeAndApprove(_msgSender(), token, params.amountOut);\\n            ExactOutputSingleParams memory _params = params;\\n            _params.amountOut = newAmount;\\n            return _uniswapV3Router.exactOutputSingle(_params);\\n        }\\n    }\\n    \\n    function exactOutput(ExactOutputParams calldata params) external virtual override payable returns (uint256){\\n        (address tokenIn, address tokenOut, uint24 fee) = params.path.decodeFirstPool();\\n         if (tokenIn == address(WETH) \\u0026\\u0026 msg.value \\u003e= params.amountOut){\\n            uint256 newValue = takeFeeETH(params.amountOut);\\n            ExactOutputParams memory params_ = params;\\n            params_.amountOut == newValue;\\n            return _uniswapV3Router.exactOutput{value: params_.amountOut}(params_);\\n        }else{\\n            IERC20 token = IERC20(tokenIn);\\n            uint256 newAmount = takeFeeAndApprove(_msgSender(), IERC20(token), params.amountOut);\\n            ExactOutputParams memory _params = params;\\n            _params.amountOut == newAmount;\\n            return _uniswapV3Router.exactOutput(_params);\\n        }\\n    } \\n    \\n    /**\\n    * @dev Functions that only the owner can call that change the variables\\n    * in this contract\\n    */    \\n    function setCharityFee(uint256 newCharityFee) external onlyOwner {\\n        _charityFee = newCharityFee;\\n    }\\n    \\n    function setCharityAddress(address newCharityAddress) external onlyOwner {\\n        _charityAddress = newCharityAddress;\\n    }\\n    \\n    function setUniswapV3Router(IUniswapV3Router newUniswapV3Router) external onlyOwner {\\n        _uniswapV3Router = newUniswapV3Router;\\n    }\\n\\n    /**\\n    * @return Returns the % fee taken from each swap that goes to charity\\n    */\\n    function charityFee() external view returns (uint256) {\\n        return _charityFee;\\n    }\\n    \\n    /**\\n    * @return The address that the \\\"Charity Fee\\\" is sent to\\n    */\\n    function charityAddress() external view returns (address) {\\n        return _charityAddress;\\n    }\\n    \\n    /**\\n    * @return The router that all swaps will be directed through\\n    */\\n    function uniswapV3Router() external view returns (IUniswapV3Router) {\\n        return _uniswapV3Router;\\n    }\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"},\"Path.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport \\u0027./BytesLib.sol\\u0027;\\n\\n/// @title Functions for manipulating path data for multihop swaps\\nlibrary Path {\\n    using BytesLib for bytes;\\n\\n    /// @dev The length of the bytes encoded address\\n    uint256 private constant ADDR_SIZE = 20;\\n    /// @dev The length of the bytes encoded fee\\n    uint256 private constant FEE_SIZE = 3;\\n\\n    /// @dev The offset of a single token address and pool fee\\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\\n    /// @dev The offset of an encoded pool key\\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\\n    /// @dev The minimum length of an encoding that contains 2 or more pools\\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\\n\\n    /// @notice Returns true iff the path contains two or more pools\\n    /// @param path The encoded swap path\\n    /// @return True if path contains two or more pools, otherwise false\\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\\n        return path.length \\u003e= MULTIPLE_POOLS_MIN_LENGTH;\\n    }\\n\\n    /// @notice Decodes the first pool in path\\n    /// @param path The bytes encoded swap path\\n    /// @return tokenA The first token of the given pool\\n    /// @return tokenB The second token of the given pool\\n    /// @return fee The fee level of the pool\\n    function decodeFirstPool(bytes memory path)\\n        internal\\n        pure\\n        returns (\\n            address tokenA,\\n            address tokenB,\\n            uint24 fee\\n        )\\n    {\\n        tokenA = path.toAddress(0);\\n        fee = path.toUint24(ADDR_SIZE);\\n        tokenB = path.toAddress(NEXT_OFFSET);\\n    }\\n\\n    /// @notice Gets the segment corresponding to the first pool in the path\\n    /// @param path The bytes encoded swap path\\n    /// @return The segment containing all data necessary to target the first pool in the path\\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\\n        return path.slice(0, POP_OFFSET);\\n    }\\n\\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\\n    /// @param path The swap path\\n    /// @return The remaining token + fee elements in the path\\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\\n    }\\n}\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"approvedForTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"feeTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"feeTakenInETH\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"charityAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"}],\"internalType\":\"struct IUniswapV3Router.ExactInputParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct IUniswapV3Router.ExactInputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactInputSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"}],\"internalType\":\"struct IUniswapV3Router.ExactOutputParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct IUniswapV3Router.ExactOutputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactOutputSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCharityAddress\",\"type\":\"address\"}],\"name\":\"setCharityAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCharityFee\",\"type\":\"uint256\"}],\"name\":\"setCharityFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV3Router\",\"name\":\"newUniswapV3Router\",\"type\":\"address\"}],\"name\":\"setUniswapV3Router\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV3Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV3Router\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"matrEXRouterV3","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://49762812f020dea6c9932eaf57b2966be5baacfa8227b7285e56d66d385bb4db"}]}