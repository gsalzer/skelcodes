{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.7.0 <0.9.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n    * @notice this interface is taken from indexed-core commit hash dae7f231d0f58bfc0993f6c01199cd6b74b01895\r\n */\r\ninterface IndexPoolI {\r\n  function getDenormalizedWeight(address token) external view returns (uint256);\r\n  function getBalance(address token) external view returns (uint256);\r\n  function getUsedBalance(address token) external view returns (uint256);\r\n  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256);    \r\n}\r\n\r\ninterface ERC20I {\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\n/**\r\n    * @notice SimpleMultiCall is a multicall-like contract for reading IndexPool information\r\n    * @notice it is intended to minimize the need for manual abi encoding/decoding\r\n    * @notice and leverage Golang's abigen to do the heavy lifting\r\n */\r\ncontract SimpleMultiCall {\r\n\r\n    struct Bundle {\r\n        // address of the pool this bundle applies to\r\n        address pool;\r\n        // address of tokens included in this bundle\r\n        // the order of tokens is the order of their weights, balances, and supplies\r\n        // this means that denormalizedWeights[1], balances[1], totalSupplies[1] will\r\n        // apply to tokens[1], while denormalizedWeights[0], balances[0], totalSupplies[0]\r\n        // will apply to tokens[0], etc...\r\n        address[] tokens;\r\n        uint256[] denormalizedWeights;\r\n        uint256[] balances;\r\n        uint256[] totalSupplies;\r\n    }\r\n    \r\n    function getBundle(\r\n        address poolAddress,\r\n        address[] memory tokens\r\n    )\r\n        public\r\n        view\r\n        returns (Bundle memory)\r\n    {\r\n        // order of the elements will be based on the ordering of the tokens\r\n        // so we can ignore the return values of the address array\r\n        (, uint256[] memory weights) = getDenormalizedWeights(poolAddress, tokens);\r\n        (, uint256[] memory balances) = getBalances(poolAddress, tokens);\r\n        (, uint256[] memory totalSupplies) = getTotalSupplies(tokens);\r\n        return Bundle({\r\n            pool: poolAddress,\r\n            tokens: tokens,\r\n            denormalizedWeights: weights,\r\n            balances: balances,\r\n            totalSupplies: totalSupplies\r\n        });\r\n    }\r\n\r\n    function getBundles(\r\n        address[] memory pools,\r\n        address[][] memory tokens\r\n    )\r\n        public\r\n        view\r\n        returns (Bundle[] memory)\r\n    {\r\n        Bundle[] memory bundles = new Bundle[](pools.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            bundles[i] = getBundle(pools[i], tokens[i]);\r\n        }\r\n        return bundles;\r\n    }\r\n\r\n    // index pool methods\r\n\r\n    function getDenormalizedWeights(\r\n        address poolAddress,\r\n        address[] memory tokens\r\n    ) \r\n        public \r\n        view\r\n        returns (address[] memory, uint256[] memory) \r\n    {\r\n        uint256[] memory weights = new uint256[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            weights[i] = IndexPoolI(poolAddress).getDenormalizedWeight(tokens[i]);\r\n        }\r\n        return (tokens, weights);\r\n    }\r\n\r\n    function getBalances(\r\n        address poolAddress,\r\n        address[] memory tokens\r\n    ) \r\n        public \r\n        view\r\n        returns (address[] memory, uint256[] memory) \r\n    {\r\n        uint256[] memory balances = new uint256[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            balances[i] = IndexPoolI(poolAddress).getBalance(tokens[i]);\r\n        }\r\n        return (tokens, balances);\r\n    }\r\n\r\n    function getUsedBalances(\r\n        address poolAddress,\r\n        address[] memory tokens\r\n    ) \r\n        public \r\n        view\r\n        returns (address[] memory, uint256[] memory) \r\n    {\r\n        uint256[] memory balances = new uint256[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            balances[i] = IndexPoolI(poolAddress).getUsedBalance(tokens[i]);\r\n        }\r\n        return (tokens, balances);\r\n    }\r\n\r\n    function getSpotPrices(\r\n        address poolAddress,\r\n        address[] memory inTokens,\r\n        address[] memory outTokens\r\n    )\r\n        public\r\n        view \r\n        returns (address[] memory, address[] memory, uint256[] memory)\r\n    {\r\n        uint256[] memory prices = new uint256[](inTokens.length);\r\n        for (uint256 i = 0; i < inTokens.length; i++) {\r\n            prices[i] = IndexPoolI(poolAddress).getSpotPrice(inTokens[i], outTokens[i]);\r\n        }\r\n        return (inTokens, outTokens, prices);\r\n    }\r\n\r\n    // erc20 methods\r\n\r\n    function getTotalSupplies(\r\n        address[] memory tokens\r\n    )\r\n        public\r\n        view\r\n        returns (address[] memory, uint256[] memory)\r\n    {\r\n        uint256[] memory supplies = new uint256[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            supplies[i] = ERC20I(tokens[i]).totalSupply();\r\n        }\r\n        return (tokens, supplies);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getBalances\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getBundle\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"denormalizedWeights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"totalSupplies\",\"type\":\"uint256[]\"}],\"internalType\":\"struct SimpleMultiCall.Bundle\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"},{\"internalType\":\"address[][]\",\"name\":\"tokens\",\"type\":\"address[][]\"}],\"name\":\"getBundles\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"denormalizedWeights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"totalSupplies\",\"type\":\"uint256[]\"}],\"internalType\":\"struct SimpleMultiCall.Bundle[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getDenormalizedWeights\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"inTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"outTokens\",\"type\":\"address[]\"}],\"name\":\"getSpotPrices\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getTotalSupplies\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getUsedBalances\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SimpleMultiCall","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://79c876ad27cf77dbfaa2a0f979c22a5a8ac8b7582be1bd0d0b9587095c0ecfb5"}]}