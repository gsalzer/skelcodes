{"status":"1","message":"OK","result":[{"SourceCode":"# @version ^0.2.12\r\n\"\"\"\r\n@title Polymer's Vesting and distribution contract\r\n@author Polymer\r\n@license MIT\r\n@notice\r\n    Enables vesting of a token distribution.\r\n    The token to distribution is stored until vesting has initiated.\r\n\r\n    Vesting is by a linear schedule set globally. \r\n    The schedule can be changed by the owner as long as the\r\n    cliff has not been passed yet. This is a mathematical concern.\r\n\r\n    Cliff\r\n    The contract contains a start timestamp, referred to as the cliff. \r\n    Once the cliff is passed, the vesting schedule and vesting amounts\r\n    are /fixed/. No new amounts can be entered into vesting, but the punisher\r\n    can lower vested amounts. The punisher can be disabled by setting him \r\n    to ZERO_ADDRESS, as he decides who inherits the role.\r\n\r\n    Whitelists\r\n    On contract creation, whitelisting is enabled by default.The administrator\r\n    can enable or disable a whitelist of allowed users. Alternatively, the\r\n    whitelist can be disabled. If the whitelist is disabled, a token contribution\r\n    is recommended. Even if entering is free, a token contribution (for example)\r\n    be used to ensure people only register a certain amount.\r\n\r\n    One-time payout\r\n    The contract contains a flag that enables a one-time payout of a fixed\r\n    percentage of the vesting. If the flag is never raised, this withholds the\r\n    percentage contribution.\r\n\"\"\"\r\n\r\n# Load the ERC20 interface to add an ERC20 token to the contract\r\nfrom vyper.interfaces import ERC20\r\n\r\nevent Collect:\r\n    to: indexed(address)\r\n    token: address\r\n    amount: uint256\r\n\r\nevent VestedClaims:\r\n    to: indexed(address)\r\n    amount: uint256\r\n\r\nevent Enter:\r\n    who: indexed(address)\r\n    amount: uint256\r\n    contribution: uint256\r\n\r\nevent ContributionPrice:\r\n    new: uint256\r\n\r\nevent Flag:\r\n    status: bool\r\n\r\nevent Slope:\r\n    cliff: uint256\r\n    end: uint256\r\n\r\nevent Punish:\r\n    _who: indexed(address)\r\n    _from: uint256\r\n    _to: uint256\r\n\r\nevent Whitelist:\r\n    who: indexed(address)\r\n    status: uint256\r\n\r\n\r\n\r\nevent OwnerTransfer:\r\n    old: indexed(address)\r\n    new: indexed(address)\r\n\r\nevent ClaimTransfer:\r\n    old: indexed(address)\r\n    new: indexed(address)\r\n\r\nevent PunisherTransfer:\r\n    old: indexed(address)\r\n    new: indexed(address)\r\n\r\n\r\n\r\n# scale to increase precision.\r\nRESOLUTION: constant(uint256) = 10**18\r\n\r\n# Contract variables\r\nowner: public(address)\r\npunisher: public(address)\r\n\r\n# Vesting Variables\r\ncliffTimestamp: public(uint256)\r\nendTimestamp: public(uint256)\r\nflag: public(bool)\r\nIMMEDIATEALLOCATION: constant(uint256) = 10**17 # out of RESOLUTION\r\n\r\nuseWhitelist: public(bool)\r\nwhitelisted: public(HashMap[address, uint256])\r\n\r\n\r\n# Token contribution\r\ncontributionToken: public(address)\r\ncontributionPrice: public(uint256) # · resolution\r\n\r\n\r\n# Token management variables\r\ntotalTokens: public(uint256)\r\n# Alternatively a struct.\r\nuserVesting: public(HashMap[address, uint256])\r\nuserClaimed: public(HashMap[address, uint256])\r\nvestingToken: public(address)\r\n\r\n\r\n# Preclaim token storage.\r\n#  Tokens owned by claimAddress is distributable by this contract.\r\n#  Requires allowance.\r\nclaimAddress: public(address)\r\n\r\n\r\n@external\r\ndef __init__(_claimAddress : address, _vestingToken : address):\r\n    self.claimAddress = _claimAddress\r\n    self.useWhitelist = True\r\n    self.owner = msg.sender\r\n    self.punisher = msg.sender\r\n    self.vestingToken = _vestingToken\r\n\r\n\r\n@external\r\ndef transferOwner(_owner : address):\r\n    \"\"\"\r\n    @notice Transfer ownership to another address\r\n    @dev Reverts if msg.sender is not owner\r\n    @param _owner address Address of new owner\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"unauthorized\"\r\n\r\n    log OwnerTransfer(self.owner, _owner)\r\n\r\n    self.owner = _owner\r\n\r\n\r\n@external\r\ndef transferPunisher(_punisher : address):\r\n    \"\"\"\r\n    @notice Transfer punisher to another address\r\n    @dev Reverts if msg.sender is not punisher\r\n    @param _punisher address Address of new punisher\r\n    \"\"\"\r\n    assert msg.sender == self.punisher, \"unauthorized\"\r\n\r\n    log PunisherTransfer(self.punisher, _punisher)\r\n\r\n    self.punisher = _punisher\r\n\r\n\r\n@external\r\ndef setClaim(_contract : address):\r\n    \"\"\"\r\n    @notice Sets the source of tokens\r\n    @dev Reverts if msg.sender is not owner\r\n    @param _contract address Address of the new source of tokens to vest\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"unauthorized\"\r\n\r\n    log ClaimTransfer(self.claimAddress, _contract)\r\n\r\n    self.claimAddress = _contract\r\n\r\n\r\n@external\r\ndef setSlope(_cliffTimestamp : uint256, _endTimestamp : uint256):\r\n    \"\"\"\r\n    @notice Sets the slope settings\r\n    @dev \r\n        Reverts if msg.sender != owner\r\n        Reverts if cliff has already passed\r\n        Reverts if _cliffTimestamp has passed.\r\n    @param _cliffTimestamp uint256 New cliff\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"unauthorized\"\r\n    assert (block.timestamp <= self.cliffTimestamp) or (self.cliffTimestamp == 0), \"Cliff passed\"\r\n    assert block.timestamp <= _cliffTimestamp, \"Cliff invalid\"\r\n    assert _cliffTimestamp < _endTimestamp\r\n\r\n    log Slope(_cliffTimestamp, _endTimestamp)\r\n\r\n    self.cliffTimestamp = _cliffTimestamp\r\n    self.endTimestamp = _endTimestamp\r\n\r\n\r\n@external\r\ndef raiseFlag():\r\n    \"\"\"\r\n    @notice Allows the initial tokens to be released\r\n    @dev \r\n        Reverts if msg.sender != owner\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n\r\n    self.flag = True\r\n\r\n    log Flag(True)\r\n\r\n\r\n@external\r\ndef setWhitelist(_bool : bool):\r\n    \"\"\"\r\n    @notice Enable or disable whitelist.\r\n    @dev \r\n        Reverts if msg.sender != owner\r\n    @param _bool bool\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"unauthorized\"\r\n\r\n    log Whitelist(ZERO_ADDRESS, convert(_bool, uint256))\r\n\r\n    self.useWhitelist = _bool\r\n\r\n\r\n@external\r\ndef whitelist(_who : address, _amount : uint256):\r\n    \"\"\"\r\n    @notice Sets whitelist for a user\r\n    @dev \r\n        Reverts if msg.sender != owner\r\n    @param _who address User to set whitelist for\r\n    @param _amount uint256 The amount to whitelist the user for\r\n        True for whitelisted\r\n        False for not whitelisted\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"unauthorized\"\r\n\r\n    log Whitelist(_who, _amount)\r\n\r\n    self.whitelisted[_who] = _amount\r\n\r\n\r\n@external\r\ndef setContribution(_price : uint256, _contributionToken : address):\r\n    \"\"\"\r\n    @notice Sets a new contributionPrice and contributionToken for vesting\r\n    @dev \r\n        Reverts if msg.sender != owner\r\n    @param _price uint256 New contributionPrice\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"unauthorized\"\r\n\r\n    log ContributionPrice(_price)\r\n\r\n    self.contributionPrice = _price\r\n    self.contributionToken = _contributionToken\r\n\r\n\r\n@external\r\ndef punish(_who : address, _newAmount : uint256):\r\n    \"\"\"\r\n    @notice Set a vesting user's amount.\r\n    @dev \r\n        Reverts if msg.sender != punisher\r\n        Reverts if _newAmount results in an increase.\r\n    @param _who address The address to punish\r\n    @param _newAmount uint256 The new amount.\r\n    \"\"\"\r\n    assert msg.sender == self.punisher, \"unauthorized\"\r\n\r\n    _userClaimed: uint256 = self.userClaimed[_who]\r\n\r\n    assert self.userVesting[_who] - _userClaimed >= _newAmount, \"Increases vesting\"\r\n\r\n    log Punish(_who, self.userVesting[_who], _newAmount + _userClaimed)\r\n\r\n    self.userVesting[_who] = _newAmount + _userClaimed\r\n\r\n\r\n@external\r\ndef collect(_to : address, _token : address, _amount : uint256):\r\n    \"\"\"\r\n    @notice Collect token contributions and forward them to _to.\r\n    @dev \r\n        Reverts if msg.sender != owner\r\n    @param _to address The address to send token contributions to\r\n    @param _token address The token to send contributions to. (Required in case contributionToken changed)\r\n    @param _amount uint256 Amount of _token to send to _to.\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"unauthorized\"\r\n\r\n    log Collect(_to, _token, _amount)\r\n\r\n    assert ERC20(_token).transfer(_to, _amount), \"Transfer failed\"\r\n\r\n\r\n@external\r\ndef enter(_amount : uint256) -> bool:\r\n    \"\"\"\r\n    @notice Enter a vesting for _amount of vestingToken.\r\n    @dev \r\n        Reverts if cliff has been passed.\r\n        Reverts if useWhitelist == True and msg.sender is not whitelisted. \r\n        Reverts if user cannot pay _amount · contributionPrice.\r\n    @param _amount uint256 Amount of _token to allocate to msg.sender\r\n    @return bool True\r\n    \"\"\"\r\n    assert block.timestamp <= self.cliffTimestamp, \"Cliff passed\"\r\n    if self.useWhitelist:\r\n        self.whitelisted[msg.sender] -= _amount  # dev: Not enough whitelisted\r\n\r\n    if self.contributionPrice > 0:\r\n        assert ERC20(self.contributionToken).transferFrom(msg.sender, self, (_amount*self.contributionPrice)/RESOLUTION), \"Contribution\"\r\n    assert ERC20(self.vestingToken).transferFrom(self.claimAddress, self, _amount), \"Vest allocation\"\r\n\r\n    log Enter(msg.sender, _amount, (_amount * self.contributionPrice)/RESOLUTION)\r\n\r\n    self.userVesting[msg.sender] += _amount\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef claimVested() -> uint256:\r\n    \"\"\"\r\n    @notice Claims vested tokens\r\n    @dev\r\n        !Reverts if block.timestamp < cliffTimestamp. \r\n    @return uint256 Vested tokens.\r\n    \"\"\"\r\n    \r\n    userVest: uint256 = self.userVesting[msg.sender]\r\n\r\n    # Logic for initial allocation\r\n    initial: uint256 = 0\r\n    if self.flag:\r\n        initial = (userVest*IMMEDIATEALLOCATION)/RESOLUTION\r\n\r\n    # Create vesting function.\r\n    #\r\n    # Y |         /-----\r\n    #   |       /\r\n    #   |     /     \r\n    # --+---/-----------\r\n    #   |   A     B     \r\n    # A: cliffTimestamp\r\n    # B: endTimestamp\r\n    # Y: userVesting\r\n    # y = a * x + b\r\n    # Y = ?a * B + ?b and 0 = ?a * A + ?b \r\n    # <=> a = -Y/(B-A), b = YB/(B-A)\r\n    # y = Y/(B-A) * x - YA/(B-A) = (Y·(x-A))/(B-A)\r\n\r\n    A: uint256 = self.cliffTimestamp\r\n    numRewardTokens: uint256 = initial\r\n    if block.timestamp > self.cliffTimestamp:\r\n        B: uint256 = self.endTimestamp\r\n        Y: uint256 = (userVest*(RESOLUTION-IMMEDIATEALLOCATION))/RESOLUTION\r\n\r\n\r\n        # Piecewise right.\r\n        x: uint256 = min(block.timestamp, B)\r\n        # Sainty check: x >= B <=> x = B <=> (Y·(x-A))/(B-A) = (Y·(B-A))/(B-A) = Y · (B-A)/(B-A) = Y\r\n        \r\n\r\n        # Piecewise left.\r\n        numRewardTokens += ((Y*(x-A))/(B-A)) # Dev: Call later; x < A => x-A < 0. uint256 < 0 => reverts.\r\n\r\n    numRewardTokens -= self.userClaimed[msg.sender]\r\n    \r\n    self.userClaimed[msg.sender] += numRewardTokens\r\n\r\n    assert ERC20(self.vestingToken).transfer(msg.sender, numRewardTokens)\r\n\r\n    log VestedClaims(msg.sender, numRewardTokens)\r\n\r\n    return numRewardTokens\r\n\r\n\r\n@view\r\n@external\r\ndef viewVested(_user : address) -> uint256:\r\n    \"\"\"\r\n    @notice Claims vested tokens\r\n    @dev\r\n        !Reverts if block.timestamp < cliffTimestamp. \r\n    @return uint256 Vested tokens.\r\n    \"\"\"\r\n    \r\n    userVest: uint256 = self.userVesting[_user]\r\n\r\n    initial: uint256 = 0\r\n    if self.flag:\r\n        initial = (userVest*IMMEDIATEALLOCATION)/RESOLUTION\r\n\r\n\r\n    A: uint256 = self.cliffTimestamp\r\n    numRewardTokens: uint256 = initial\r\n    if block.timestamp > self.cliffTimestamp:\r\n        B: uint256 = self.endTimestamp\r\n        Y: uint256 = (userVest*(RESOLUTION-IMMEDIATEALLOCATION))/RESOLUTION\r\n\r\n        x: uint256 = min(block.timestamp, B)\r\n        numRewardTokens += ((Y*(x-A))/(B-A)) \r\n\r\n    return numRewardTokens - self.userClaimed[_user]","ABI":"[{\"name\":\"Collect\",\"inputs\":[{\"name\":\"to\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token\",\"type\":\"address\",\"indexed\":false},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"VestedClaims\",\"inputs\":[{\"name\":\"to\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Enter\",\"inputs\":[{\"name\":\"who\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"contribution\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ContributionPrice\",\"inputs\":[{\"name\":\"new\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Flag\",\"inputs\":[{\"name\":\"status\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Slope\",\"inputs\":[{\"name\":\"cliff\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"end\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Punish\",\"inputs\":[{\"name\":\"_who\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_from\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"_to\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Whitelist\",\"inputs\":[{\"name\":\"who\",\"type\":\"address\",\"indexed\":true},{\"name\":\"status\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"OwnerTransfer\",\"inputs\":[{\"name\":\"old\",\"type\":\"address\",\"indexed\":true},{\"name\":\"new\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ClaimTransfer\",\"inputs\":[{\"name\":\"old\",\"type\":\"address\",\"indexed\":true},{\"name\":\"new\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PunisherTransfer\",\"inputs\":[{\"name\":\"old\",\"type\":\"address\",\"indexed\":true},{\"name\":\"new\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_claimAddress\",\"type\":\"address\"},{\"name\":\"_vestingToken\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferOwner\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"outputs\":[],\"gas\":41192},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferPunisher\",\"inputs\":[{\"name\":\"_punisher\",\"type\":\"address\"}],\"outputs\":[],\"gas\":41222},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setClaim\",\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"outputs\":[],\"gas\":41252},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setSlope\",\"inputs\":[{\"name\":\"_cliffTimestamp\",\"type\":\"uint256\"},{\"name\":\"_endTimestamp\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":79084},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"raiseFlag\",\"inputs\":[],\"outputs\":[],\"gas\":38909},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setWhitelist\",\"inputs\":[{\"name\":\"_bool\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":39461},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"whitelist\",\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":39597},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setContribution\",\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_contributionToken\",\"type\":\"address\"}],\"outputs\":[],\"gas\":74140},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"punish\",\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_newAmount\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":47539},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"collect\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":7773},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"enter\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":100365},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claimVested\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":59062},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"viewVested\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":15449},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2778},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"punisher\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2808},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"cliffTimestamp\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2838},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"endTimestamp\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2868},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"flag\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":2898},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"useWhitelist\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":2928},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"whitelisted\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3173},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"contributionToken\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2988},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"contributionPrice\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3018},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalTokens\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3048},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"userVesting\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3293},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"userClaimed\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3323},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vestingToken\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3138},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"claimAddress\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3168}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.12","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000d6cbac2fbd3c070a80369ac730743ee8780d222400000000000000000000000052c761ac87f6c890034daefd2f13d5efbbb762d0","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}