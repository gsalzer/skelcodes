{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity 0.7.4;\r\n\r\nlibrary SafeMathLib {\r\n  function times(uint a, uint b) public pure returns (uint) {\r\n    uint c = a * b;\r\n    require(a == 0 || c / a == b, 'Overflow detected');\r\n    return c;\r\n  }\r\n\r\n  function minus(uint a, uint b) public pure returns (uint) {\r\n    require(b <= a, 'Underflow detected');\r\n    return a - b;\r\n  }\r\n\r\n  function plus(uint a, uint b) public pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c>=a && c>=b, 'Overflow detected');\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract MostBasicYield {\r\n    using SafeMathLib for uint;\r\n\r\n    struct Receipt {\r\n        uint id;\r\n        uint amountDeposited;\r\n        uint timeDeposited;\r\n        uint timeWithdrawn;\r\n        address owner;\r\n    }\r\n\r\n    uint[] public tokensPerSecondPerToken;\r\n    uint public maximumDeposit;\r\n    uint public totalDeposits = 0;\r\n    uint[] public rewardsClaimed;\r\n    uint public numReceipts = 0;\r\n    uint public startTime;\r\n    uint public endTime;\r\n\r\n    address public management;\r\n\r\n    IERC20 public depositToken;\r\n    IERC20[] public rewardTokens;\r\n    mapping (uint => Receipt) public receipts;\r\n\r\n    event DepositOccurred(uint indexed id, address indexed owner);\r\n    event WithdrawalOccurred(uint indexed id, address indexed owner);\r\n    event ExcessRewardsWithdrawn();\r\n\r\n    constructor(\r\n        uint _startTime,\r\n        uint maxDeposit,\r\n        uint[] memory rewards,\r\n        uint programLengthDays,\r\n        address depositTokenAddress,\r\n        address[] memory rewardTokenAddresses,\r\n        address mgmt)\r\n    {\r\n        tokensPerSecondPerToken = rewards;\r\n        startTime = _startTime > 0 ? _startTime : block.timestamp;\r\n        endTime = startTime.plus(programLengthDays * 1 days);\r\n        depositToken = IERC20(depositTokenAddress);\r\n        require(tokensPerSecondPerToken.length == rewardTokenAddresses.length, 'Rewards and reward token arrays must be same length');\r\n\r\n        for (uint i = 0; i < rewardTokenAddresses.length; i++) {\r\n            rewardTokens.push(IERC20(rewardTokenAddresses[i]));\r\n            rewardsClaimed.push(0);\r\n        }\r\n\r\n        maximumDeposit = maxDeposit;\r\n        management = mgmt;\r\n    }\r\n\r\n    function getRewards(uint receiptId) public view returns (uint[] memory) {\r\n        Receipt memory receipt = receipts[receiptId];\r\n        uint nowish = block.timestamp;\r\n        if (nowish > endTime) {\r\n            nowish = endTime;\r\n        }\r\n\r\n        uint secondsDiff = nowish.minus(receipt.timeDeposited);\r\n        uint[] memory rewardsLocal = new uint[](tokensPerSecondPerToken.length);\r\n        for (uint i = 0; i < tokensPerSecondPerToken.length; i++) {\r\n            rewardsLocal[i] = (secondsDiff.times(tokensPerSecondPerToken[i]).times(receipt.amountDeposited)) / 1e18;\r\n        }\r\n\r\n        return rewardsLocal;\r\n    }\r\n\r\n    function deposit(uint amount) external {\r\n        require(block.timestamp > startTime, 'Cannot deposit before pool start');\r\n        require(block.timestamp < endTime, 'Cannot deposit after pool ends');\r\n        require(totalDeposits < maximumDeposit, 'Maximum deposit already reached');\r\n        if (totalDeposits.plus(amount) > maximumDeposit) {\r\n            amount = maximumDeposit.minus(totalDeposits);\r\n        }\r\n        depositToken.transferFrom(msg.sender, address(this), amount);\r\n        totalDeposits = totalDeposits.plus(amount);\r\n\r\n        Receipt storage receipt = receipts[++numReceipts];\r\n        receipt.id = numReceipts;\r\n        receipt.amountDeposited = amount;\r\n        receipt.timeDeposited = block.timestamp;\r\n        receipt.owner = msg.sender;\r\n\r\n        emit DepositOccurred(numReceipts, msg.sender);\r\n    }\r\n\r\n    function withdraw(uint receiptId) external {\r\n        Receipt storage receipt = receipts[receiptId];\r\n        require(receipt.id == receiptId, 'Can only withdraw real receipts');\r\n        require(receipt.owner == msg.sender || block.timestamp > endTime, 'Can only withdraw your own deposit');\r\n        require(receipt.timeWithdrawn == 0, 'Can only withdraw once per receipt');\r\n        receipt.timeWithdrawn = block.timestamp;\r\n        uint[] memory rewards = getRewards(receiptId);\r\n        totalDeposits = totalDeposits.minus(receipt.amountDeposited);\r\n\r\n        for (uint i = 0; i < rewards.length; i++) {\r\n            rewardsClaimed[i] = rewardsClaimed[i].plus(rewards[i]);\r\n            rewardTokens[i].transfer(receipt.owner, rewards[i]);\r\n        }\r\n        depositToken.transfer(receipt.owner, receipt.amountDeposited);\r\n        emit WithdrawalOccurred(receiptId, receipt.owner);\r\n    }\r\n\r\n    function withdrawExcessRewards() external {\r\n        require(totalDeposits == 0, 'Cannot withdraw until all deposits are withdrawn');\r\n        require(block.timestamp > endTime, 'Contract must reach maturity');\r\n\r\n        for (uint i = 0; i < rewardTokens.length; i++) {\r\n            uint rewards = rewardTokens[i].balanceOf(address(this));\r\n            rewardTokens[i].transfer(management, rewards);\r\n        }\r\n\r\n        depositToken.transfer(management, depositToken.balanceOf(address(this)));\r\n        emit ExcessRewardsWithdrawn();\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"rewards\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"programLengthDays\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"depositTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"rewardTokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"mgmt\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"DepositOccurred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ExcessRewardsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"WithdrawalOccurred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"receiptId\",\"type\":\"uint256\"}],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numReceipts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"receipts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardTokens\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardsClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensPerSecondPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"receiptId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawExcessRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MostBasicYield","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000607041c0000000000000000000000000000000000000000000084595161401484a00000000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000b700000000000000000000000045080a6531d671ddff20db42f93792a489685e320000000000000000000000000000000000000000000000000000000000000120000000000000000000000000a874fa6ccdccb57d9397247e088575c4ef34ec660000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000075ce30638000000000000000000000000000000000000000000000000000000000000000100000000000000000000000045080a6531d671ddff20db42f93792a489685e32","EVMVersion":"Default","Library":"SafeMathLib:82d7630c5eb722557de6d76575c9a7b8de718500","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1f1d3bd0095dabc15daa2922f8a0a27d8feca8f293be5954616636e4d255f326"}]}