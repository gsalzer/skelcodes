{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.0;\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  \r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n  \r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n  \r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n      \r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract Whitelist is Ownable {\r\n\r\n // 1 => whitelisted; 0 => NOT whitelisted\r\n  mapping (address => uint8) public whitelistedMap;\r\n\r\n // true => whitelist is activated; false => whitelist is deactivated\r\n  bool public WhitelistStatus;\r\n  \r\n  event WhitelistStatusChanged(bool indexed Status);\r\n\r\n  constructor() {\r\n    WhitelistStatus = true;\r\n  }\r\n\r\n  modifier Whitelisted() {\r\n    require(whitelistedMap[msg.sender] == 1 || WhitelistStatus == false, 'You are not whitelisted');\r\n  _;}\r\n\r\n  function whitelistAddress(address[] calldata AddressList)\r\n    public\r\n    onlyOwner\r\n  {\r\n    uint j;\r\n    for (j = 0; j < AddressList.length; ++j)\r\n    {\r\n    whitelistedMap[AddressList[j]] = 1;\r\n    }\r\n  }\r\n\r\n  function blacklistAddress(address[] calldata AdressList)\r\n    public\r\n    onlyOwner\r\n    \r\n  {\r\n    uint j;\r\n    for (j = 0; j < AdressList.length; ++j)\r\n    {\r\n    whitelistedMap[AdressList[j]] = 2;\r\n    }\r\n  }\r\n\r\n  function changeWhitelistStatus()\r\n    public\r\n    onlyOwner\r\n  {\r\n    if (WhitelistStatus == true){\r\n      WhitelistStatus = false;\r\n      emit WhitelistStatusChanged(false);\r\n    }else{\r\n      WhitelistStatus = true;\r\n      emit WhitelistStatusChanged(true);\r\n    }\r\n  }\r\n}\r\n\r\ncontract IFOV3 is Whitelist{\r\n    using SafeERC20 for IERC20;\r\n\r\n    // The LP token used\r\n    IERC20 public lpToken;\r\n\r\n    // The offering token\r\n    IERC20 public offeringToken;\r\n\r\n    // Number of pools\r\n    uint8 public constant numberPools = 3;\r\n\r\n    uint public HarvestDelay;\r\n\r\n    // The block number when IFO starts\r\n    uint256 public startBlock;\r\n\r\n    // The block number when IFO ends\r\n    uint256 public endBlock;\r\n\r\n    PoolCharacteristics[numberPools] private _poolInformation;\r\n\r\n    mapping(address => mapping(uint8 => uint256)) private amountPool;\r\n\r\n    struct PoolCharacteristics {\r\n        uint256 offeringAmountPool; \r\n        uint256 priceA; \r\n        uint256 priceB; \r\n        uint256 totalAmountPool; \r\n    }\r\n\r\n    event AdminWithdraw(uint256 amountLP, uint256 amountOfferingToken, uint256 amountWei);\r\n\r\n    event AdminTokenRecovery(address tokenAddress, uint256 amountTokens);\r\n\r\n    event Deposit(address indexed user, uint256 amount, uint8 indexed pid);\r\n\r\n    event Harvest(address indexed user, uint256 offeringAmount, uint256 excessAmount, uint8 indexed pid);\r\n\r\n    event NewStartAndEndBlocks(uint256 startBlock, uint256 endBlock);\r\n\r\n    event PoolParametersSet(uint256 offeringAmountPool, uint priceA_, uint priceB_, uint8 pid);\r\n\r\n    modifier TimeLock() {\r\n        require(block.number > endBlock + 90000, 'Admin must wait before calling this function');\r\n    _;}\r\n\r\n    constructor(\r\n        IERC20 _lpToken,\r\n        IERC20 _offeringToken,\r\n        uint256 _startBlock,\r\n        uint256 _endBlock,\r\n        uint _harvestdelay\r\n    ) {\r\n        lpToken = _lpToken;\r\n        offeringToken = _offeringToken;\r\n        startBlock = _startBlock;\r\n        endBlock = _endBlock;\r\n        HarvestDelay = _harvestdelay;\r\n    }\r\n\r\n    function depositPool(uint256 _amount, uint8 _pid) external {\r\n\r\n        require(_pid < numberPools, \"Non valid pool id\");\r\n\r\n        require(_poolInformation[_pid].offeringAmountPool > 0, \"Pool not set\");\r\n\r\n        require(block.number > startBlock, \"Too early\");\r\n\r\n        require(block.number < endBlock, \"Too late\");\r\n\r\n        require(_amount > 0, \"Amount must be > 0\");\r\n\r\n\r\n        if(_pid == 0){\r\n          require(\r\n            _poolInformation[_pid].offeringAmountPool >= (_poolInformation[_pid].totalAmountPool + (_amount)) * (_poolInformation[_pid].priceA),\r\n            'not enough Offering Tokens left in Pool1');\r\n        }\r\n\r\n        lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n\r\n        amountPool[msg.sender][_pid] += _amount;\r\n\r\n        _poolInformation[_pid].totalAmountPool += _amount;\r\n\r\n        emit Deposit(msg.sender, _amount, _pid);\r\n    }\r\n\r\n    function harvestPool(uint8 _pid) external {\r\n\r\n        require(block.number > endBlock + HarvestDelay, \"Too early to harvest\");\r\n\r\n        require(_pid < numberPools, \"Non valid pool id\");\r\n\r\n        require(amountPool[msg.sender][_pid] > 0, \"Did not participate\");\r\n\r\n        if(whitelistedMap[msg.sender] != 1 && WhitelistStatus == true){\r\n          uint amount = amountPool[msg.sender][_pid];\r\n          amountPool[msg.sender][_pid] = 0;\r\n          lpToken.safeTransfer(address(msg.sender), amount);\r\n          emit Harvest(msg.sender, 0, amount, _pid);\r\n        }else{\r\n\r\n          uint256 offeringTokenAmount;\r\n          uint256 refundingTokenAmount;\r\n\r\n          (offeringTokenAmount, refundingTokenAmount) = _calculateOfferingAndRefundingAmountsPool(\r\n            msg.sender,\r\n            _pid\r\n          );\r\n\r\n          amountPool[msg.sender][_pid] = 0;\r\n\r\n          if (offeringTokenAmount > 0) {\r\n            offeringToken.safeTransfer(address(msg.sender), offeringTokenAmount);\r\n          }\r\n\r\n          if (refundingTokenAmount > 0) {\r\n            lpToken.safeTransfer(address(msg.sender), refundingTokenAmount);\r\n          }\r\n\r\n          emit Harvest(msg.sender, offeringTokenAmount, refundingTokenAmount, _pid);\r\n        }\r\n    }\r\n\r\n    function finalWithdraw(uint256 _lpAmount, uint256 _offerAmount, uint256 _weiAmount) external  onlyOwner TimeLock {\r\n        require(_lpAmount <= lpToken.balanceOf(address(this)), \"Not enough LP tokens\");\r\n        require(_offerAmount <= offeringToken.balanceOf(address(this)), \"Not enough offering token\");\r\n\r\n        if (_lpAmount > 0) {\r\n            lpToken.safeTransfer(address(msg.sender), _lpAmount);\r\n        }\r\n\r\n        if (_offerAmount > 0) {\r\n            offeringToken.safeTransfer(address(msg.sender), _offerAmount);\r\n        }\r\n\r\n        if (_weiAmount > 0){\r\n            payable(address(msg.sender)).transfer(_weiAmount);\r\n        }\r\n\r\n        emit AdminWithdraw(_lpAmount, _offerAmount, _weiAmount);\r\n    }\r\n\r\n    function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\r\n        require(_tokenAddress != address(lpToken), \"Cannot be LP token\");\r\n        require(_tokenAddress != address(offeringToken), \"Cannot be offering token\");\r\n\r\n        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _tokenAmount);\r\n\r\n        emit AdminTokenRecovery(_tokenAddress, _tokenAmount);\r\n    }\r\n    function setPool(\r\n        uint256 _offeringAmountPool,\r\n        uint256 _priceA,\r\n        uint _priceB,\r\n        uint8 _pid\r\n    ) external  onlyOwner TimeLock {\r\n        require(_pid < numberPools, \"Pool does not exist\");\r\n\r\n        _poolInformation[_pid].offeringAmountPool = _offeringAmountPool;\r\n        _poolInformation[_pid].priceA = _priceA;\r\n        _poolInformation[_pid].priceB = _priceB;\r\n\r\n        uint sum = 0;\r\n        for (uint j = 0; j < numberPools; j++){\r\n            sum += _poolInformation[j].offeringAmountPool;\r\n        }\r\n        require(sum <= offeringToken.balanceOf(address(this)),\r\n        'cant offer more than balance');\r\n\r\n        emit PoolParametersSet(_offeringAmountPool, _priceA, _priceB, _pid);\r\n    }\r\n\r\n    function updateStartAndEndBlocks(uint256 _startBlock, uint256 _endBlock) external onlyOwner TimeLock {\r\n        require(_startBlock < _endBlock, \"New startBlock must be lower than new endBlock\");\r\n        require(block.number < _startBlock, \"New startBlock must be higher than current block\");\r\n        for(uint j = 0; j < numberPools; j++){\r\n            _poolInformation[j].totalAmountPool = 0;\r\n        }\r\n        startBlock = _startBlock;\r\n        endBlock = _endBlock;\r\n\r\n        emit NewStartAndEndBlocks(_startBlock, _endBlock);\r\n    }\r\n\r\n    function viewPoolInformation(uint256 _pid)\r\n        external\r\n        view\r\n        \r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        return (\r\n            _poolInformation[_pid].offeringAmountPool,\r\n            _poolInformation[_pid].priceA,\r\n            _poolInformation[_pid].priceB,\r\n            _poolInformation[_pid].totalAmountPool\r\n        );\r\n    }\r\n\r\n    function viewUserAllocationPools(address _user, uint8[] calldata _pids)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory allocationPools = new uint256[](_pids.length);\r\n        for (uint8 i = 0; i < _pids.length; i++) {\r\n            allocationPools[i] = _getUserAllocationPool(_user, _pids[i]);\r\n        }\r\n        return allocationPools;\r\n    }\r\n\r\n    function viewUserAmount(address _user, uint8[] calldata _pids)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory amountPools = new uint256[](_pids.length);\r\n\r\n        for (uint8 i = 0; i < numberPools; i++) {\r\n            amountPools[i] = amountPool[_user][i];\r\n        }\r\n        return (amountPools);\r\n    }\r\n    function viewUserOfferingAndRefundingAmountsForPools(address _user, uint8[] calldata _pids)\r\n        external\r\n        view\r\n        returns (uint256[2][] memory)\r\n    {\r\n        uint256[2][] memory amountPools = new uint256[2][](_pids.length);\r\n\r\n        for (uint8 i = 0; i < _pids.length; i++) {\r\n            uint256 userOfferingAmountPool;\r\n            uint256 userRefundingAmountPool;\r\n\r\n            if (_poolInformation[_pids[i]].offeringAmountPool > 0) {\r\n                (\r\n                    userOfferingAmountPool,\r\n                    userRefundingAmountPool\r\n                ) = _calculateOfferingAndRefundingAmountsPool(_user, _pids[i]);\r\n            }\r\n\r\n            amountPools[i] = [userOfferingAmountPool, userRefundingAmountPool];\r\n        }\r\n        return amountPools;\r\n    }\r\n    function _calculateOfferingAndRefundingAmountsPool(address _user, uint8 _pid)\r\n        internal\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n      if(amountPool[_user][_pid] == 0){\r\n        return(0, 0);\r\n      }\r\n\r\n      uint256 userOfferingAmount;\r\n      uint256 userRefundingAmount;\r\n      if (_pid == 0){\r\n        userOfferingAmount = amountPool[_user][0] * (_poolInformation[0].priceA);\r\n        return (userOfferingAmount, 0);\r\n      }\r\n\r\n      uint256 allocation = _getUserAllocationPool(_user, _pid);\r\n      if (_pid == 2){\r\n        userOfferingAmount = _poolInformation[2].offeringAmountPool * (allocation) / (1e12);\r\n        return (userOfferingAmount, 0);\r\n      }\r\n      if (_poolInformation[1].totalAmountPool * (_poolInformation[1].priceA) > _poolInformation[1].offeringAmountPool){\r\n        userOfferingAmount = _poolInformation[1].offeringAmountPool * (allocation) / (1e12);\r\n      }else{\r\n        userOfferingAmount = amountPool[_user][1] * (_poolInformation[1].priceA);\r\n        return(userOfferingAmount, 0);\r\n      }\r\n      if (_poolInformation[1].totalAmountPool * (_poolInformation[1].priceB) <= _poolInformation[1].offeringAmountPool){\r\n        return (userOfferingAmount, 0);\r\n      }else{\r\n        uint notcompensatedAmount = _poolInformation[1].totalAmountPool - (_poolInformation[1].offeringAmountPool / (_poolInformation[1].priceB));\r\n        userRefundingAmount = allocation * (notcompensatedAmount) / (1e12);\r\n        return (userOfferingAmount, userRefundingAmount);\r\n      }\r\n    }\r\n\r\n    function _getUserAllocationPool(address _user, uint8 _pid) internal view returns (uint256) {\r\n        if (_poolInformation[_pid].totalAmountPool > 0) {\r\n            return amountPool[_user][_pid] * (1e12) / _poolInformation[_pid].totalAmountPool;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n    function SetHarvestDelay(uint _HarvestDelay) external onlyOwner {\r\n        require( _HarvestDelay < 90000, 'max delay is 90000 blocks');\r\n        HarvestDelay = _HarvestDelay;\r\n    }\r\n    fallback() external payable{}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_offeringToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_harvestdelay\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"AdminTokenRecovery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLP\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOfferingToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWei\",\"type\":\"uint256\"}],\"name\":\"AdminWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"pid\",\"type\":\"uint8\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offeringAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"excessAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"pid\",\"type\":\"uint8\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"}],\"name\":\"NewStartAndEndBlocks\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offeringAmountPool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceA_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceB_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"pid\",\"type\":\"uint8\"}],\"name\":\"PoolParametersSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"Status\",\"type\":\"bool\"}],\"name\":\"WhitelistStatusChanged\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"HarvestDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_HarvestDelay\",\"type\":\"uint256\"}],\"name\":\"SetHarvestDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WhitelistStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"AdressList\",\"type\":\"address[]\"}],\"name\":\"blacklistAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"changeWhitelistStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"}],\"name\":\"depositPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_offerAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"finalWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"}],\"name\":\"harvestPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberPools\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offeringToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverWrongTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offeringAmountPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceB\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"}],\"name\":\"setPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endBlock\",\"type\":\"uint256\"}],\"name\":\"updateStartAndEndBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"viewPoolInformation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint8[]\",\"name\":\"_pids\",\"type\":\"uint8[]\"}],\"name\":\"viewUserAllocationPools\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint8[]\",\"name\":\"_pids\",\"type\":\"uint8[]\"}],\"name\":\"viewUserAmount\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint8[]\",\"name\":\"_pids\",\"type\":\"uint8[]\"}],\"name\":\"viewUserOfferingAndRefundingAmountsForPools\",\"outputs\":[{\"internalType\":\"uint256[2][]\",\"name\":\"\",\"type\":\"uint256[2][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"AddressList\",\"type\":\"address[]\"}],\"name\":\"whitelistAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedMap\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"IFOV3","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000008765b1a0eb57ca49be7eacd35b24a574d020365600000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000afc8","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://63084729297f662c37abb54c8a32d4cc273b180a0bddea897e1fda17280de083"}]}