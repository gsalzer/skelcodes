{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ichiPowah.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.3;\\n\\nimport \\\"./lib/AddressSet.sol\\\";\\nimport \\\"./interfaces/ISatellite.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract ICHIPowah is Ownable {\\n\\n    using SafeMath for uint;\\n    using AddressSet for AddressSet.Set;\\n\\n    uint public constant PRECISION = 100;\\n\\n    bytes32 constant NULL_DATA = \\\"\\\";\\n\\n    // a Constituency contains balance information that can be interpreted by an interpreter\\n    struct Constituency {\\n        address interpreter;\\n        uint16 weight; // 100 = 100%\\n        bytes32 params;\\n    }\\n    // constituency address => details\\n    mapping(address => Constituency) public constituencies; \\n    // interable key set with delete\\n    AddressSet.Set constituencySet;\\n\\n    event NewConstituency(address instance, address interpreter, uint16 weight, bytes32 params);\\n    event UpdateConstituency(address instance, address interpreter, uint16 weight, bytes32 params);\\n    event DeleteConstituency(address instance);\\n\\n    /**\\n     * @notice user voting power reported through a normal ERC20 function \\n     * @param user the user to inspect\\n     * @param powah user's voting power\\n     */    \\n    function balanceOf(address user) public view returns(uint powah) {\\n        uint count = constituencySet.count();\\n        for(uint i=0; i<count; i++) {\\n            address instance = constituencySet.keyAtIndex(i);\\n            Constituency storage c = constituencies[instance];\\n            powah = powah.add(ISatellite(c.interpreter).getPowah(instance, user, c.params).mul(c.weight).div(PRECISION));\\n        }\\n    }\\n\\n    /**\\n     * @notice adjusted total supply factor (for computing quorum) is the weight-adjusted sum of all possible votes\\n     * @param supply the total number of votes possible given circulating supply and weighting\\n     */\\n    function totalSupply() public view returns(uint supply) {\\n        uint count = constituencySet.count();\\n        for(uint i=0; i<count; i++) {\\n            address instance = constituencySet.keyAtIndex(i);\\n            Constituency storage c = constituencies[instance];\\n            supply = supply.add(ISatellite(c.interpreter).getSupply(instance).mul(c.weight).div(PRECISION));\\n        }\\n    }\\n\\n    /*********************************\\n     * Discoverable Internal Structure\\n     *********************************/\\n\\n    /**\\n     * @notice count configured constituencies\\n     * @param count number of constituencies configured\\n     */\\n    function constituencyCount() public view returns(uint count) {\\n        count = constituencySet.count();\\n    }\\n\\n    /**\\n     * @notice enumerate the configured constituencies\\n     * @param index row number to inspect\\n     * @param constituency address of the contract where tokens are staked\\n     */\\n    function constituencyAtIndex(uint index) public view returns(address constituency) {\\n        constituency = constituencySet.keyAtIndex(index);\\n    }\\n\\n    /*********************************\\n     * CRUD\\n     *********************************/\\n\\n    /**\\n     * @notice insert a new constituency to start counting as voting power\\n     * @param constituency address of the contract to inspect\\n     * @param interpreter address of the satellite that can interact with the type of contract at constituency address \\n     * @param weight scaling adjustment to increase/decrease voting power. 100 = 100% is correct in most cases\\n     */\\n    function insertConstituency(address constituency, address interpreter, uint16 weight, bytes32 params) external onlyOwner {\\n        constituencySet.insert(constituency, \\\"ICHIPowah: constituency is already registered.\\\");\\n        Constituency storage c = constituencies[constituency];\\n        c.interpreter = interpreter;\\n        c.weight = weight;\\n        c.params = params;\\n        emit NewConstituency(constituency, interpreter, weight, params);\\n    }\\n\\n    /**\\n     * @notice delete a constituency to stop counting as voting power\\n     * @param constituency address of the contract to stop inspecting\\n     */\\n    function deleteConstituency(address constituency) external onlyOwner {\\n        constituencySet.remove(constituency, \\\"ICHIPowah: unknown instance\\\");\\n        delete constituencies[constituency];\\n        emit DeleteConstituency(constituency);\\n    }\\n\\n    /**\\n     * @notice update a constituency by overwriting all values (safe to remove and use 2-step delete, re-add)\\n     * @param constituency address of the contract to inspect\\n     * @param interpreter address of the satellite that can interact with the type of contract at constituency address \\n     * @param weight scaling adjustment to increase/decrease voting power. 100 = 100% is correct in most cases\\n     */\\n    function updateConstituency(address constituency, address interpreter, uint16 weight, bytes32 params) external onlyOwner {\\n        require(constituencySet.exists(constituency), \\\"ICHIPowah unknown constituency\\\");\\n        Constituency storage c = constituencies[constituency];\\n        c.interpreter = interpreter;\\n        c.weight = weight;\\n        c.params = params;\\n        emit UpdateConstituency(constituency, interpreter, weight, params);\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/lib/AddressSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.3;\\n\\n/**\\n * @notice Key sets with enumeration and delete. Uses mappings for random access\\n * and existence checks and dynamic arrays for enumeration. Key uniqueness is enforced. \\n * @dev Sets are unordered. Delete operations reorder keys. All operations have a \\n * fixed gas cost at any scale, O(1). \\n */\\n\\nlibrary AddressSet {\\n    \\n    struct Set {\\n        mapping(address => uint) keyPointers;\\n        address[] keyList;\\n    }\\n\\n    /**\\n     @notice insert a key. \\n     @dev duplicate keys are not permitted.\\n     @param self storage pointer to a Set. \\n     @param key value to insert.\\n     */    \\n    function insert(Set storage self, address key, string memory errorMessage) internal {\\n        require(!exists(self, key), errorMessage);\\n        self.keyList.push(key);\\n        self.keyPointers[key] = self.keyList.length-1;\\n    }\\n\\n    /**\\n     @notice remove a key.\\n     @dev key to remove must exist. \\n     @param self storage pointer to a Set.\\n     @param key value to remove.\\n     */    \\n    function remove(Set storage self, address key, string memory errorMessage) internal {\\n        require(exists(self, key), errorMessage);\\n        uint last = count(self) - 1;\\n        uint rowToReplace = self.keyPointers[key];\\n        address keyToMove = self.keyList[last];\\n        self.keyPointers[keyToMove] = rowToReplace;\\n        self.keyList[rowToReplace] = keyToMove;\\n        delete self.keyPointers[key];\\n        self.keyList.pop();\\n    }\\n\\n    /**\\n     @notice count the keys.\\n     @param self storage pointer to a Set. \\n     */       \\n    function count(Set storage self) internal view returns(uint) {\\n        return(self.keyList.length);\\n    }\\n\\n    /**\\n     @notice check if a key is in the Set.\\n     @param self storage pointer to a Set.\\n     @param key value to check. Version\\n     @return bool true: Set member, false: not a Set member.\\n     */  \\n    function exists(Set storage self, address key) internal view returns(bool) {\\n        if(self.keyList.length == 0) return false;\\n        return self.keyList[self.keyPointers[key]] == key;\\n    }\\n\\n    /**\\n     @notice fetch a key by row (enumerate).\\n     @param self storage pointer to a Set.\\n     @param index row to enumerate. Must be < count() - 1.\\n     */      \\n    function keyAtIndex(Set storage self, uint index) internal view returns(address) {\\n        return self.keyList[index];\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISatellite.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.3;\\n\\ninterface ISatellite {\\n\\n    function getPowah(address instance, address user, bytes32 params) external view returns(uint powah);\\n    function getSupply(address instance) external view returns(uint supply);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"}],\"name\":\"DeleteConstituency\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"weight\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"params\",\"type\":\"bytes32\"}],\"name\":\"NewConstituency\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"weight\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"params\",\"type\":\"bytes32\"}],\"name\":\"UpdateConstituency\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"powah\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"constituencies\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"weight\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"params\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"constituencyAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"constituency\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"constituencyCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"constituency\",\"type\":\"address\"}],\"name\":\"deleteConstituency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"constituency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"weight\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"params\",\"type\":\"bytes32\"}],\"name\":\"insertConstituency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"constituency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"weight\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"params\",\"type\":\"bytes32\"}],\"name\":\"updateConstituency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ICHIPowah","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}