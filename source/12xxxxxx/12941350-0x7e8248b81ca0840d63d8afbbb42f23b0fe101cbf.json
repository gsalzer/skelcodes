{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/aave-v2/AaveV2Erc20Adapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../interfaces/AaveV2Interfaces.sol\\\";\\nimport \\\"../../interfaces/ITokenAdapter.sol\\\";\\nimport \\\"../../interfaces/IERC20.sol\\\";\\nimport \\\"../../libraries/LowGasSafeMath.sol\\\";\\nimport \\\"../../libraries/TransferHelper.sol\\\";\\nimport \\\"../../libraries/SymbolHelper.sol\\\";\\nimport \\\"../../libraries/RayMul.sol\\\";\\nimport \\\"../../libraries/ReserveConfigurationLib.sol\\\";\\nimport \\\"../../libraries/MinimalSignedMath.sol\\\";\\nimport \\\"../../libraries/CloneLibrary.sol\\\";\\n\\n\\ncontract AaveV2Erc20Adapter is IErc20Adapter {\\n  using MinimalSignedMath for uint256;\\n  using LowGasSafeMath for uint256;\\n  using RayMul for uint256;\\n  using SymbolHelper for address;\\n  using TransferHelper for address;\\n\\n/* ========== Constants ========== */\\n\\n  ILendingPoolAddressesProvider public immutable addressesProvider;\\n  address public constant aave = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\\n  IAaveDistributionManager internal constant distributor = IAaveDistributionManager(0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5);\\n  ILendingPool public immutable pool;\\n\\n/* ========== Storage ========== */\\n\\n  address public userModuleImplementation;\\n  address public override underlying;\\n  address public override token;\\n  mapping(address => address) public userModules;\\n  // Pre-calculated and stored in the initializer to reduce gas costs in `getRewardsAPR`.\\n  uint256 internal _oneUnderlyingToken;\\n\\n/* ========== Constructor & Initializer ========== */\\n\\n  constructor(ILendingPoolAddressesProvider _addressesProvider) {\\n    addressesProvider = _addressesProvider;\\n    pool = _addressesProvider.getLendingPool();\\n  }\\n\\n  function initialize(address _underlying, address _token) public virtual {\\n    require(underlying == address(0) && token == address(0), \\\"initialized\\\");\\n    require(_underlying != address(0) && _token != address(0), \\\"bad address\\\");\\n    underlying = _underlying;\\n    token = _token;\\n    userModuleImplementation = address(new AaveV2UserModule(\\n      addressesProvider,\\n      _underlying,\\n      _token\\n    ));\\n    _oneUnderlyingToken = 10 ** IERC20Metadata(_underlying).decimals();\\n  }\\n\\n/* ========== Metadata ========== */\\n\\n  function name() external view virtual override returns (string memory) {\\n    return string(abi.encodePacked(\\n      \\\"Aave V2 \\\",\\n      bytes(underlying.getSymbol()),\\n      \\\" Adapter\\\"\\n    ));\\n  }\\n\\n/* ========== Metadata ========== */\\n\\n  function availableLiquidity() public view override returns (uint256) {\\n    return IERC20(underlying).balanceOf(token);\\n  }\\n\\n/* ========== Conversion Queries ========== */\\n\\n  function toUnderlyingAmount(uint256 tokenAmount) public pure override returns (uint256) {\\n    return tokenAmount;\\n  }\\n\\n  function toWrappedAmount(uint256 underlyingAmount) public pure override returns (uint256) {\\n    return underlyingAmount;\\n  }\\n\\n/* ========== User Modules ========== */\\n\\n  function getOrCreateUserModule() internal returns (AaveV2UserModule) {\\n    address module = userModules[msg.sender];\\n    if (module == address(0)) {\\n      module = (userModules[msg.sender] = CloneLibrary.createClone(userModuleImplementation));\\n      AaveV2UserModule(payable(module)).initialize(msg.sender);\\n    }\\n    return AaveV2UserModule(payable(module));\\n  }\\n\\n/* ========== Performance Queries ========== */\\n\\n  function getRewardsAPR(uint256 _totalLiquidity) internal view returns (uint256) {\\n    address _token = token;\\n    (, uint256 emissionsPerSecond,) = distributor.getAssetData(_token);\\n    if (emissionsPerSecond == 0) return 0;\\n    IPriceOracle oracle = addressesProvider.getPriceOracle();\\n    uint256 aavePrice = oracle.getAssetPrice(aave);\\n    uint256 underlyingPrice = oracle.getAssetPrice(underlying);\\n    if (aavePrice == 0 || underlyingPrice == 0) {\\n      return 0;\\n    }\\n    uint256 underlyingValue = underlyingPrice.mul(_totalLiquidity) / _oneUnderlyingToken;\\n    uint256 rewardsValue = aavePrice.mul(emissionsPerSecond.mul(365 days));\\n    return rewardsValue / underlyingValue;\\n  }\\n\\n  function getRewardsAPR() external view returns (uint256) {\\n    return getRewardsAPR(IERC20(token).totalSupply());\\n  }\\n\\n  function getBaseAPR() internal view returns (uint256) {\\n    ILendingPool.ReserveData memory reserve = pool.getReserveData(underlying);\\n    return uint256(reserve.currentLiquidityRate) / 1e9;\\n  }\\n\\n  function getAPR() public view virtual override returns (uint256 apr) {\\n    return getBaseAPR().add(getRewardsAPR(IERC20(token).totalSupply()));\\n  }\\n\\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256 apr) {\\n    address reserve = underlying;\\n    ILendingPool.ReserveData memory data = pool.getReserveData(reserve);\\n    uint256 _availableLiquidity = IERC20(reserve).balanceOf(data.aTokenAddress).add(liquidityDelta);\\n    uint256 totalVariableDebt = data.variableDebtToken.scaledTotalSupply().rayMul(data.variableBorrowIndex);\\n    (uint256 totalStableDebt, uint256 avgStableRate) = data.stableDebtToken.getTotalSupplyAndAvgRate();\\n    (uint256 liquidityRate, ,) = data.interestRateStrategy.calculateInterestRates(\\n      reserve,\\n      _availableLiquidity,\\n      totalStableDebt,\\n      totalVariableDebt,\\n      avgStableRate,\\n      ReserveConfigurationLib.getReserveFactor(data.configuration)\\n    );\\n    uint256 newLiquidity = _availableLiquidity.add(totalVariableDebt).add(totalStableDebt);\\n    return (liquidityRate / 1e9).add(getRewardsAPR(newLiquidity));\\n  }\\n\\n  function getRevenueBreakdown()\\n    external\\n    view\\n    override\\n    returns (\\n      address[] memory assets,\\n      uint256[] memory aprs\\n    )\\n  {\\n    uint256 rewardsAPR = getRewardsAPR(IERC20(token).totalSupply());\\n    uint256 size = rewardsAPR > 0 ? 2 : 1;\\n    assets = new address[](size);\\n    aprs = new uint256[](size);\\n    assets[0] = underlying;\\n    aprs[0] = getBaseAPR();\\n    if (rewardsAPR > 0) {\\n      assets[1] = aave;\\n      aprs[1] = rewardsAPR;\\n    }\\n  }\\n\\n/* ========== Caller Balance Queries ========== */\\n\\n  function balanceWrapped() public view virtual override returns (uint256) {\\n    address module = userModules[msg.sender];\\n    return IERC20(token).balanceOf(module == address(0) ? msg.sender : module);\\n  }\\n\\n  function balanceUnderlying() external view virtual override returns (uint256) {\\n    address module = userModules[msg.sender];\\n    return IERC20(token).balanceOf(module == address(0) ? msg.sender : module);\\n  }\\n\\n/* ========== Token Actions ========== */\\n\\n  function deposit(uint256 amountUnderlying) external virtual override returns (uint256 amountMinted) {\\n    require(amountUnderlying > 0, \\\"deposit 0\\\");\\n    AaveV2UserModule module = getOrCreateUserModule();\\n    underlying.safeTransferFrom(msg.sender, address(module), amountUnderlying);\\n    module.deposit(amountUnderlying);\\n    return amountUnderlying;\\n  }\\n\\n  function withdraw(uint256 amountToken) public virtual override returns (uint256 amountReceived) {\\n    require(amountToken > 0, \\\"withdraw 0\\\");\\n    address module = userModules[msg.sender];\\n    if (module == address(0)) {\\n      token.safeTransferFrom(msg.sender, address(this), amountToken);\\n      pool.withdraw(underlying, amountToken, msg.sender);\\n      return amountToken;\\n    }\\n    AaveV2UserModule(payable(module)).withdraw(amountToken, true);\\n    amountReceived = amountToken;\\n  }\\n\\n  function withdrawAll() external virtual override returns (uint256 amountReceived) {\\n    return withdraw(balanceWrapped());\\n  }\\n\\n  function withdrawUnderlying(uint256 amountUnderlying) external virtual override returns (uint256 amountBurned) {\\n    amountBurned = withdraw(amountUnderlying);\\n  }\\n\\n  function withdrawUnderlyingUpTo(uint256 amountUnderlying) external virtual override returns (uint256 amountReceived) {\\n    require(amountUnderlying > 0, \\\"withdraw 0\\\");\\n    uint256 amountAvailable = availableLiquidity();\\n    amountReceived = amountAvailable < amountUnderlying ? amountAvailable : amountUnderlying;\\n    withdraw(amountReceived);\\n  }\\n}\\n\\n\\ncontract AaveV2UserModule {\\n  using TransferHelper for address;\\n\\n  IStakedAave internal constant stkAave = IStakedAave(0x4da27a545c0c5B758a6BA100e3a049001de870f5);\\n  IAaveDistributionManager internal constant incentives = IAaveDistributionManager(0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5);\\n  ILendingPool internal immutable pool;\\n  address internal immutable underlying;\\n  address internal immutable aToken;\\n  address internal immutable adapter;\\n\\n  address internal user;\\n  bool public assetHasRewards;\\n  uint32 public cooldownUnlockAt;\\n\\n  constructor(\\n    ILendingPoolAddressesProvider addressesProvider,\\n    address _underlying,\\n    address _aToken\\n  ) {\\n    adapter = msg.sender;\\n    underlying = _underlying;\\n    aToken = _aToken;\\n    ILendingPool _pool = addressesProvider.getLendingPool();\\n    pool = _pool;\\n  }\\n\\n  function initialize(address _user) external {\\n    require(msg.sender == adapter && user == address(0));\\n    user = _user;\\n    underlying.safeApproveMax(address(pool));\\n    (, uint256 emissionPerSecond,) = incentives.getAssetData(aToken);\\n    assetHasRewards = emissionPerSecond > 0;\\n  }\\n\\n  function setHasRewards() external {\\n    (, uint256 emissionPerSecond,) = incentives.getAssetData(aToken);\\n    assetHasRewards = emissionPerSecond > 0;\\n  }\\n\\n  function _claimAndTriggerCooldown() internal {\\n    address[] memory assets = new address[](1);\\n    assets[0] = aToken;\\n    uint256 r = incentives.getUserUnclaimedRewards(address(this));\\n    if (r > 0) {\\n      incentives.claimRewards(assets, r, address(this));\\n      stkAave.cooldown();\\n      uint256 cooldownDuration = stkAave.COOLDOWN_SECONDS();\\n      cooldownUnlockAt = uint32(block.timestamp + cooldownDuration);\\n    }\\n  }\\n\\n  function poke() public {\\n    // We do not check if the asset has rewards inside of poke so that if\\n    // rewards are accrued and then the asset's incentives are set to zero,\\n    // the existing rewards can still be manually claimed.\\n    // If there's not a pending cooldown, claim any rewards and begin the cooldown\\n    // If there is a pending cooldown:\\n    // - If it is over, redeem stkAave, reset the timer, claim stkAave and begin new cooldown\\n    // - If it is not over, do nothing\\n    if (cooldownUnlockAt > 0) {\\n      if (cooldownUnlockAt < block.timestamp) {\\n        stkAave.redeem(user, type(uint256).max);\\n        cooldownUnlockAt = 0;\\n      } else {\\n        return;\\n      }\\n    }\\n    _claimAndTriggerCooldown();\\n  }\\n\\n  function deposit(uint256 amount) external {\\n    require(msg.sender == adapter, \\\"!adapter\\\");\\n    pool.deposit(underlying, amount, address(this), 0);\\n    if (assetHasRewards) poke();\\n  }\\n\\n  function withdraw(uint256 amount, bool toUser) external {\\n    require(msg.sender == adapter, \\\"!adapter\\\");\\n    pool.withdraw(underlying, amount, toUser ? user : adapter);\\n    if (assetHasRewards) poke();\\n  }\\n}\"\r\n    },\r\n    \"contracts/adapters/aave-v2/AaveV2EtherAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./AaveV2Erc20Adapter.sol\\\";\\nimport \\\"../../interfaces/IWETH.sol\\\";\\n\\n\\ncontract AaveV2EtherAdapter is IEtherAdapter {\\n  using MinimalSignedMath for uint256;\\n  using LowGasSafeMath for uint256;\\n  using RayMul for uint256;\\n  using SymbolHelper for address;\\n  using TransferHelper for address;\\n  using TransferHelper for address payable;\\n\\n/* ========== Constants ========== */\\n\\n  ILendingPoolAddressesProvider public immutable addressesProvider;\\n  address public constant aave = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\\n  IAaveDistributionManager internal constant distributor = IAaveDistributionManager(0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5);\\n  ILendingPool public immutable pool;\\n  address public immutable userModuleImplementation;\\n  address public immutable override underlying;\\n  address public immutable override token;\\n\\n/* ========== Storage ========== */\\n  mapping(address => address) public userModules;\\n\\n/* ========== Fallbacks ========== */\\n\\n  receive() external payable { return; }\\n\\n/* ========== Constructor & Initializer ========== */\\n\\n  constructor(\\n    ILendingPoolAddressesProvider _addressesProvider,\\n    address _underlying,\\n    address _token\\n  ) {\\n    addressesProvider = _addressesProvider;\\n    pool = _addressesProvider.getLendingPool();\\n    underlying = _underlying;\\n    token = _token;\\n    userModuleImplementation = address(new AaveV2UserModule(\\n      _addressesProvider,\\n      _underlying,\\n      _token\\n    ));\\n  }\\n\\n/* ========== Metadata ========== */\\n\\n  function name() external view virtual override returns (string memory) {\\n    return string(abi.encodePacked(\\n      \\\"Aave V2 \\\",\\n      bytes(underlying.getSymbol()),\\n      \\\" Adapter\\\"\\n    ));\\n  }\\n\\n/* ========== Metadata ========== */\\n\\n  function availableLiquidity() public view override returns (uint256) {\\n    return IERC20(underlying).balanceOf(token);\\n  }\\n\\n/* ========== Conversion Queries ========== */\\n\\n  function toUnderlyingAmount(uint256 tokenAmount) public pure override returns (uint256) {\\n    return tokenAmount;\\n  }\\n\\n  function toWrappedAmount(uint256 underlyingAmount) public pure override returns (uint256) {\\n    return underlyingAmount;\\n  }\\n\\n/* ========== User Modules ========== */\\n\\n  function getOrCreateUserModule() internal returns (AaveV2UserModule) {\\n    address module = userModules[msg.sender];\\n    if (module == address(0)) {\\n      module = (userModules[msg.sender] = CloneLibrary.createClone(userModuleImplementation));\\n      AaveV2UserModule(payable(module)).initialize(msg.sender);\\n    }\\n    return AaveV2UserModule(payable(module));\\n  }\\n\\n/* ========== Performance Queries ========== */\\n\\n  function getRewardsAPR(uint256 _totalLiquidity) internal view returns (uint256) {\\n    address _token = token;\\n    (, uint256 emissionsPerSecond,) = distributor.getAssetData(_token);\\n    if (emissionsPerSecond == 0) return 0;\\n    IPriceOracle oracle = addressesProvider.getPriceOracle();\\n    uint256 aavePrice = oracle.getAssetPrice(aave);\\n    uint256 underlyingPrice = oracle.getAssetPrice(underlying);\\n    if (aavePrice == 0 || underlyingPrice == 0) {\\n      return 0;\\n    }\\n    return aavePrice.mul(emissionsPerSecond.mul(365 days)).mul(1e18) / underlyingPrice.mul(_totalLiquidity);\\n  }\\n\\n  function getRewardsAPR() external view returns (uint256) {\\n    return getRewardsAPR(IERC20(token).totalSupply());\\n  }\\n\\n  function getBaseAPR() internal view returns (uint256) {\\n    ILendingPool.ReserveData memory reserve = pool.getReserveData(underlying);\\n    return uint256(reserve.currentLiquidityRate) / 1e9;\\n  }\\n\\n  function getAPR() public view virtual override returns (uint256 apr) {\\n    return getBaseAPR().add(getRewardsAPR(IERC20(token).totalSupply()));\\n  }\\n\\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256 apr) {\\n    address reserve = underlying;\\n    ILendingPool.ReserveData memory data = pool.getReserveData(reserve);\\n    uint256 _availableLiquidity = IERC20(reserve).balanceOf(data.aTokenAddress).add(liquidityDelta);\\n    uint256 totalVariableDebt = data.variableDebtToken.scaledTotalSupply().rayMul(data.variableBorrowIndex);\\n    (uint256 totalStableDebt, uint256 avgStableRate) = data.stableDebtToken.getTotalSupplyAndAvgRate();\\n    (uint256 liquidityRate, ,) = data.interestRateStrategy.calculateInterestRates(\\n      reserve,\\n      _availableLiquidity,\\n      totalStableDebt,\\n      totalVariableDebt,\\n      avgStableRate,\\n      ReserveConfigurationLib.getReserveFactor(data.configuration)\\n    );\\n    uint256 newLiquidity = _availableLiquidity.add(totalVariableDebt).add(totalStableDebt);\\n    return (liquidityRate / 1e9).add(getRewardsAPR(newLiquidity));\\n  }\\n\\n  function getRevenueBreakdown()\\n    external\\n    view\\n    override\\n    returns (\\n      address[] memory assets,\\n      uint256[] memory aprs\\n    )\\n  {\\n    uint256 rewardsAPR = getRewardsAPR(IERC20(token).totalSupply());\\n    uint256 size = rewardsAPR > 0 ? 2 : 1;\\n    assets = new address[](size);\\n    aprs = new uint256[](size);\\n    assets[0] = underlying;\\n    aprs[0] = getBaseAPR();\\n    if (rewardsAPR > 0) {\\n      assets[1] = aave;\\n      aprs[1] = rewardsAPR;\\n    }\\n  }\\n\\n/* ========== Caller Balance Queries ========== */\\n\\n  function balanceWrapped() public view virtual override returns (uint256) {\\n    address module = userModules[msg.sender];\\n    return IERC20(token).balanceOf(module == address(0) ? msg.sender : module);\\n  }\\n\\n  function balanceUnderlying() external view virtual override returns (uint256) {\\n    address module = userModules[msg.sender];\\n    return IERC20(token).balanceOf(module == address(0) ? msg.sender : module);\\n  }\\n\\n/* ========== Token Actions ========== */\\n\\n  function deposit(uint256 amountUnderlying) external virtual override returns (uint256 amountMinted) {\\n    require(amountUnderlying > 0, \\\"deposit 0\\\");\\n    AaveV2UserModule module = getOrCreateUserModule();\\n    underlying.safeTransferFrom(msg.sender, address(module), amountUnderlying);\\n    module.deposit(amountUnderlying);\\n    return amountUnderlying;\\n  }\\n\\n  function depositETH() external payable virtual override returns (uint256 amountMinted) {\\n    require(msg.value > 0, \\\"deposit 0\\\");\\n    AaveV2UserModule module = getOrCreateUserModule();\\n    IWETH(underlying).deposit{value: msg.value}();\\n    underlying.safeTransfer(address(module), msg.value);\\n    module.deposit(msg.value);\\n    return msg.value;\\n  }\\n\\n  function withdraw(uint256 amountToken) public virtual override returns (uint256 amountReceived) {\\n    require(amountToken > 0, \\\"withdraw 0\\\");\\n    address module = userModules[msg.sender];\\n    if (module == address(0)) {\\n      token.safeTransferFrom(msg.sender, address(this), amountToken);\\n      pool.withdraw(underlying, amountToken, msg.sender);\\n      return amountToken;\\n    }\\n    AaveV2UserModule(payable(module)).withdraw(amountToken, true);\\n    return amountToken;\\n  }\\n\\n  function withdrawAsETH(uint256 amountToken) public virtual override returns (uint256 amountReceived) {\\n    require(amountToken > 0, \\\"withdraw 0\\\");\\n    address module = userModules[msg.sender];\\n    if (module == address(0)) {\\n      token.safeTransferFrom(msg.sender, address(this), amountToken);\\n      pool.withdraw(underlying, amountToken, address(this));\\n    } else {\\n      AaveV2UserModule(payable(module)).withdraw(amountToken, false);\\n    }\\n    IWETH(underlying).withdraw(amountToken);\\n    msg.sender.safeTransferETH(amountToken);\\n    return amountToken;\\n  }\\n\\n  function withdrawAll() public virtual override returns (uint256 amountReceived) {\\n    return withdraw(balanceWrapped());\\n  }\\n\\n  function withdrawAllAsETH() public virtual override returns (uint256 amountReceived) {\\n    return withdrawAsETH(balanceWrapped());\\n  }\\n\\n  function withdrawUnderlying(uint256 amountUnderlying) external virtual override returns (uint256 amountBurned) {\\n    return withdraw(amountUnderlying);\\n  }\\n\\n  function withdrawUnderlyingAsETH(uint256 amountUnderlying) external virtual override returns (uint256 amountBurned) {\\n    return withdrawAsETH(amountUnderlying);\\n  }\\n\\n  function withdrawUnderlyingUpTo(uint256 amountUnderlying) external virtual override returns (uint256 amountReceived) {\\n    require(amountUnderlying > 0, \\\"withdraw 0\\\");\\n    uint256 amountAvailable = availableLiquidity();\\n    amountReceived = amountAvailable < amountUnderlying ? amountAvailable : amountUnderlying;\\n    withdraw(amountReceived);\\n  }\\n}\"\r\n    },\r\n    \"contracts/interfaces/AaveV2Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\npragma abicoder v2;\\n\\n\\ninterface ILendingPoolAddressesProvider {\\n  function getLendingPool() external view returns (ILendingPool);\\n\\n  function getPriceOracle() external view returns (IPriceOracle);\\n}\\n\\n\\ninterface IVariableDebtToken {\\n  function scaledTotalSupply() external view returns (uint256);\\n}\\n\\n\\ninterface IReserveInterestRateStrategy {\\n  function calculateInterestRates(\\n    address reserve,\\n    uint256 availableLiquidity,\\n    uint256 totalStableDebt,\\n    uint256 totalVariableDebt,\\n    uint256 averageStableBorrowRate,\\n    uint256 reserveFactor\\n  ) external\\n    view\\n    returns (\\n      uint256 liquidityRate,\\n      uint256 stableBorrowRate,\\n      uint256 variableBorrowRate\\n    );\\n}\\n\\n\\ninterface IStableDebtToken {\\n  function getTotalSupplyAndAvgRate() external view returns (uint256, uint256);\\n}\\n\\n\\ninterface ILendingPool {\\n  struct ReserveConfigurationMap {\\n    uint256 data;\\n  }\\n\\n  struct ReserveData {\\n    ReserveConfigurationMap configuration;\\n    uint128 liquidityIndex;\\n    uint128 variableBorrowIndex;\\n    uint128 currentLiquidityRate;\\n    uint128 currentVariableBorrowRate;\\n    uint128 currentStableBorrowRate;\\n    uint40 lastUpdateTimestamp;\\n    address aTokenAddress;\\n    IStableDebtToken stableDebtToken;\\n    IVariableDebtToken variableDebtToken;\\n    IReserveInterestRateStrategy interestRateStrategy;\\n    uint8 id;\\n  }\\n\\n  function getReserveNormalizedIncome(address asset) external view returns (uint128);\\n\\n  function getReserveData(address asset) external view returns (ReserveData memory);\\n\\n  function getReservesList() external view returns (address[] memory);\\n\\n  function getConfiguration(address asset) external view returns (ReserveConfigurationMap memory);\\n\\n  function deposit(\\n    address asset,\\n    uint256 amount,\\n    address onBehalfOf,\\n    uint16 referralCode\\n  ) external;\\n\\n  function withdraw(\\n    address asset,\\n    uint256 amount,\\n    address to\\n  ) external;\\n}\\n\\n\\ninterface IAaveDistributionManager {\\n  function getAssetData(address asset) external view returns (uint256 index, uint256 emissionPerSecond, uint256 lastUpdateTimestamp);\\n\\n  function getUserUnclaimedRewards(address account) external view returns (uint256);\\n\\n  function getRewardsBalance(address[] calldata assets, address user)\\n    external\\n    view\\n    returns (uint256);\\n\\n  function claimRewards(\\n    address[] calldata assets,\\n    uint256 amount,\\n    address to\\n  ) external returns (uint256);\\n}\\n\\n\\ninterface IPriceOracle {\\n  function getAssetPrice(address asset) external view returns (uint256);\\n}\\n\\n\\ninterface IStakedAave {\\n  function COOLDOWN_SECONDS() external view returns (uint256);\\n\\n  function stake(address to, uint256 amount) external;\\n\\n  function redeem(address to, uint256 amount) external;\\n\\n  function cooldown() external;\\n\\n  function claimRewards(address to, uint256 amount) external;\\n\\n  function stakerRewardsToClaim(address account) external view returns (uint256);\\n\\n  function stakersCooldowns(address account) external view returns (uint256);\\n\\n  function getTotalRewardsBalance(address staker) external view returns (uint256);\\n\\n  function getNextCooldownTimestamp(\\n    uint256 fromCooldownTimestamp,\\n    uint256 amountToReceive,\\n    address toAddress,\\n    uint256 toBalance\\n  ) external returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IAdapterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\n\\ninterface IAdapterRegistry {\\n/* ========== Events ========== */\\n\\n  event ProtocolAdapterAdded(uint256 protocolId, address protocolAdapter);\\n\\n  event ProtocolAdapterRemoved(uint256 protocolId);\\n\\n  event TokenAdapterAdded(address adapter, uint256 protocolId, address underlying, address wrapper);\\n\\n  event TokenAdapterRemoved(address adapter, uint256 protocolId, address underlying, address wrapper);\\n\\n  event TokenSupportAdded(address underlying);\\n\\n  event TokenSupportRemoved(address underlying);\\n\\n  event VaultFactoryAdded(address factory);\\n\\n  event VaultFactoryRemoved(address factory);\\n\\n  event VaultAdded(address underlying, address vault);\\n\\n  event VaultRemoved(address underlying, address vault);\\n\\n/* ========== Structs ========== */\\n\\n  struct TokenAdapter {\\n    address adapter;\\n    uint96 protocolId;\\n  }\\n\\n/* ========== Storage ========== */\\n\\n  function protocolsCount() external view returns (uint256);\\n\\n  function protocolAdapters(uint256 id) external view returns (address protocolAdapter);\\n\\n  function protocolAdapterIds(address protocolAdapter) external view returns (uint256 id);\\n\\n  function vaultsByUnderlying(address underlying) external view returns (address vault);\\n\\n  function approvedVaultFactories(address factory) external view returns (bool approved);\\n\\n/* ========== Vault Factory Management ========== */\\n\\n  function addVaultFactory(address _factory) external;\\n\\n  function removeVaultFactory(address _factory) external;\\n\\n/* ========== Vault Management ========== */\\n\\n  function addVault(address vault) external;\\n\\n  function removeVault(address vault) external;\\n\\n/* ========== Protocol Adapter Management ========== */\\n\\n  function addProtocolAdapter(address protocolAdapter) external returns (uint256 id);\\n\\n  function removeProtocolAdapter(address protocolAdapter) external;\\n\\n/* ========== Token Adapter Management ========== */\\n\\n  function addTokenAdapter(address adapter) external;\\n\\n  function addTokenAdapters(address[] calldata adapters) external;\\n\\n  function removeTokenAdapter(address adapter) external;\\n\\n/* ========== Vault Queries ========== */\\n\\n  function getVaultsList() external view returns (address[] memory);\\n\\n  function haveVaultFor(address underlying) external view returns (bool);\\n\\n/* ========== Protocol Queries ========== */\\n\\n  function getProtocolAdaptersAndIds() external view returns (address[] memory adapters, uint256[] memory ids);\\n\\n  function getProtocolMetadata(uint256 id) external view returns (address protocolAdapter, string memory name);\\n\\n  function getProtocolForTokenAdapter(address adapter) external view returns (address protocolAdapter);\\n\\n/* ========== Supported Token Queries ========== */\\n\\n  function isSupported(address underlying) external view returns (bool);\\n\\n  function getSupportedTokens() external view returns (address[] memory list);\\n\\n/* ========== Token Adapter Queries ========== */\\n\\n  function isApprovedAdapter(address adapter) external view returns (bool);\\n\\n  function getAdaptersList(address underlying) external view returns (address[] memory list);\\n\\n  function getAdapterForWrapperToken(address wrapperToken) external view returns (address);\\n\\n  function getAdaptersCount(address underlying) external view returns (uint256);\\n\\n  function getAdaptersSortedByAPR(address underlying)\\n    external\\n    view\\n    returns (address[] memory adapters, uint256[] memory aprs);\\n\\n  function getAdaptersSortedByAPRWithDeposit(\\n    address underlying,\\n    uint256 deposit,\\n    address excludingAdapter\\n  )\\n    external\\n    view\\n    returns (address[] memory adapters, uint256[] memory aprs);\\n\\n  function getAdapterWithHighestAPR(address underlying) external view returns (address adapter, uint256 apr);\\n\\n  function getAdapterWithHighestAPRForDeposit(\\n    address underlying,\\n    uint256 deposit,\\n    address excludingAdapter\\n  ) external view returns (address adapter, uint256 apr);\\n}\\n\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\n\\ninterface IERC20 {\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  function totalSupply() external view returns (uint256);\\n  function balanceOf(address account) external view returns (uint256);\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  function approve(address spender, uint256 amount) external returns (bool);\\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\n\\ninterface IERC20Metadata {\\n  function name() external view returns (string memory);\\n  function symbol() external view returns (string memory);\\n  function decimals() external view returns (uint8);\\n}\\n\\n\\ninterface IERC20MetadataBytes32 {\\n  function name() external view returns (bytes32);\\n  function symbol() external view returns (bytes32);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITokenAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\n\\ninterface IErc20Adapter {\\n/* ========== Metadata ========== */\\n\\n  function underlying() external view returns (address);\\n\\n  function token() external view returns (address);\\n\\n  function name() external view returns (string memory);\\n\\n  function availableLiquidity() external view returns (uint256);\\n\\n/* ========== Conversion ========== */\\n\\n  function toUnderlyingAmount(uint256 tokenAmount) external view returns (uint256);\\n\\n  function toWrappedAmount(uint256 underlyingAmount) external view returns (uint256);\\n\\n/* ========== Performance Queries ========== */\\n\\n  function getAPR() external view returns (uint256);\\n\\n  function getHypotheticalAPR(int256 liquidityDelta) external view returns (uint256);\\n\\n  function getRevenueBreakdown()\\n    external\\n    view\\n    returns (\\n      address[] memory assets,\\n      uint256[] memory aprs\\n    );\\n\\n/* ========== Caller Balance Queries ========== */\\n\\n  function balanceWrapped() external view returns (uint256);\\n\\n  function balanceUnderlying() external view returns (uint256);\\n\\n/* ========== Interactions ========== */\\n\\n  function deposit(uint256 amountUnderlying) external returns (uint256 amountMinted);\\n\\n  function withdraw(uint256 amountToken) external returns (uint256 amountReceived);\\n\\n  function withdrawAll() external returns (uint256 amountReceived);\\n\\n  function withdrawUnderlying(uint256 amountUnderlying) external returns (uint256 amountBurned);\\n\\n  function withdrawUnderlyingUpTo(uint256 amountUnderlying) external returns (uint256 amountReceived);\\n}\\n\\ninterface IEtherAdapter is IErc20Adapter {\\n  function depositETH() external payable returns (uint256 amountMinted);\\n\\n  function withdrawAsETH(uint256 amountToken) external returns (uint256 amountReceived);\\n\\n  function withdrawAllAsETH() external returns (uint256 amountReceived);\\n\\n  function withdrawUnderlyingAsETH(uint256 amountUnderlying) external returns (uint256 amountBurned); \\n}\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\n\\ninterface IWETH {\\n  function deposit() external payable;\\n  function withdraw(uint) external;\\n}\"\r\n    },\r\n    \"contracts/libraries/ArrayHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\nimport \\\"../libraries/LowGasSafeMath.sol\\\";\\nimport \\\"../interfaces/ITokenAdapter.sol\\\";\\n\\n\\nlibrary ArrayHelper {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using LowGasSafeMath for uint256;\\n\\n/* ========== Type Cast ========== */\\n\\n  /**\\n   * @dev Cast an enumerable address set as an address array.\\n   * The enumerable set library stores the values as a bytes32 array, this function\\n   * casts it as an address array with a pointer assignment.\\n   */\\n  function toArray(EnumerableSet.AddressSet storage set) internal view returns (address[] memory arr) {\\n    bytes32[] memory bytes32Arr = set._inner._values;\\n    assembly { arr := bytes32Arr }\\n  }\\n\\n  /**\\n   * @dev Cast an array of IErc20Adapter to an array of address using a pointer assignment.\\n   * Note: The resulting array is the same as the original, so all changes to one will be\\n   * reflected in the other.\\n   */\\n  function toAddressArray(IErc20Adapter[] memory _arr) internal pure returns (address[] memory arr) {\\n    assembly { arr := _arr }\\n  }\\n\\n/* ========== Math ========== */\\n\\n  /**\\n   * @dev Computes the sum of a uint256 array.\\n   */\\n  function sum(uint256[] memory arr) internal pure returns (uint256 _sum) {\\n    uint256 len = arr.length;\\n    for (uint256 i; i < len; i++) _sum = _sum.add(arr[i]);\\n  }\\n\\n/* ========== Removal ========== */\\n\\n  /**\\n   * @dev Remove the element at `index` from an array and decrement its length.\\n   * If `index` is the last index in the array, pops it from the array.\\n   * Otherwise, stores the last element in the array at `index` and then pops the last element.\\n   */\\n  function mremove(uint256[] memory arr, uint256 index) internal pure {\\n    uint256 len = arr.length;\\n    if (index != len - 1) {\\n      uint256 last = arr[len - 1];\\n      arr[index] = last;\\n    }\\n    assembly { mstore(arr, sub(len, 1)) }\\n  }\\n\\n  /**\\n   * @dev Remove the element at `index` from an array and decrement its length.\\n   * If `index` is the last index in the array, pops it from the array.\\n   * Otherwise, stores the last element in the array at `index` and then pops the last element.\\n   */\\n  function mremove(address[] memory arr, uint256 index) internal pure {\\n    uint256 len = arr.length;\\n    if (index != len - 1) {\\n      address last = arr[len - 1];\\n      arr[index] = last;\\n    }\\n    assembly { mstore(arr, sub(len, 1)) }\\n  }\\n\\n  /**\\n   * @dev Remove the element at `index` from an array and decrement its length.\\n   * If `index` is the last index in the array, pops it from the array.\\n   * Otherwise, stores the last element in the array at `index` and then pops the last element.\\n   */\\n  function mremove(IErc20Adapter[] memory arr, uint256 index) internal pure {\\n    uint256 len = arr.length;\\n    if (index != len - 1) {\\n      IErc20Adapter last = arr[len - 1];\\n      arr[index] = last;\\n    }\\n    assembly { mstore(arr, sub(len, 1)) }\\n  }\\n\\n  /**\\n   * @dev Remove the element at `index` from an array and decrement its length.\\n   * If `index` is the last index in the array, pops it from the array.\\n   * Otherwise, stores the last element in the array at `index` and then pops the last element.\\n   */\\n  function remove(bytes32[] storage arr, uint256 index) internal {\\n    uint256 len = arr.length;\\n    if (index == len - 1) {\\n      arr.pop();\\n      return;\\n    }\\n    bytes32 last = arr[len - 1];\\n    arr[index] = last;\\n    arr.pop();\\n  }\\n\\n  /**\\n   * @dev Remove the element at `index` from an array and decrement its length.\\n   * If `index` is the last index in the array, pops it from the array.\\n   * Otherwise, stores the last element in the array at `index` and then pops the last element.\\n   */\\n  function remove(address[] storage arr, uint256 index) internal {\\n    uint256 len = arr.length;\\n    if (index == len - 1) {\\n      arr.pop();\\n      return;\\n    }\\n    address last = arr[len - 1];\\n    arr[index] = last;\\n    arr.pop();\\n  }\\n\\n/* ========== Search ========== */\\n\\n  /**\\n   * @dev Find the index of an address in an array.\\n   * If the address is not found, revert.\\n   */\\n  function indexOf(address[] memory arr, address find) internal pure returns (uint256) {\\n    uint256 len = arr.length;\\n    for (uint256 i; i < len; i++) if (arr[i] == find) return i;\\n    revert(\\\"element not found\\\");\\n  }\\n\\n  /**\\n   * @dev Determine whether an element is included in an array.\\n   */\\n  function includes(address[] memory arr, address find) internal pure returns (bool) {\\n    uint256 len = arr.length;\\n    for (uint256 i; i < len; i++) if (arr[i] == find) return true;\\n    return false;\\n  }\\n\\n/* ========== Sorting ========== */\\n\\n  /**\\n   * @dev Given an array of tokens and scores, sort by scores in descending order.\\n   * Maintains the relationship between elements of each array at the same index.\\n   */\\n  function sortByDescendingScore(\\n    address[] memory addresses,\\n    uint256[] memory scores\\n  ) internal pure {\\n    uint256 len = addresses.length;\\n    for (uint256 i = 0; i < len; i++) {\\n      uint256 score = scores[i];\\n      address _address = addresses[i];\\n      uint256 j = i - 1;\\n      while (int(j) >= 0 && scores[j] < score) {\\n        scores[j + 1] = scores[j];\\n        addresses[j + 1] = addresses[j];\\n        j--;\\n      }\\n      scores[j + 1] = score;\\n      addresses[j + 1] = _address;\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/libraries/CloneLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\n/*\\nThe MIT License (MIT)\\nCopyright (c) 2018 Murray Software, LLC.\\nPermission is hereby granted, free of charge, to any person obtaining\\na copy of this software and associated documentation files (the\\n\\\"Software\\\"), to deal in the Software without restriction, including\\nwithout limitation the rights to use, copy, modify, merge, publish,\\ndistribute, sublicense, and/or sell copies of the Software, and to\\npermit persons to whom the Software is furnished to do so, subject to\\nthe following conditions:\\nThe above copyright notice and this permission notice shall be included\\nin all copies or substantial portions of the Software.\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n*/\\n\\n/**\\n * EIP 1167 Proxy Deployment\\n * Originally from https://github.com/optionality/clone-factory/\\n */\\nlibrary CloneLibrary {\\n  function getCreateCode(address target) internal pure returns (bytes memory createCode) {\\n    // Reserve 55 bytes for the deploy code + 17 bytes as a buffer to prevent overwriting\\n    // other memory in the final mstore\\n    createCode = new bytes(72);\\n    assembly {\\n      let clone := add(createCode, 32)\\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n      mstore(add(clone, 0x14), shl(96, target))\\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n      mstore(createCode, 55)\\n    }\\n  }\\n\\n  function createClone(address target) internal returns (address result) {\\n    bytes memory createCode = getCreateCode(target);\\n    assembly { result := create(0, add(createCode, 32), 55) }\\n  }\\n\\n  function createClone(address target, bytes32 salt) internal returns (address result) {\\n    bytes memory createCode = getCreateCode(target);\\n    assembly { result := create2(0, add(createCode, 32), 55, salt) }\\n  }\\n\\n  function isClone(address target, address query) internal view returns (bool result) {\\n    assembly {\\n      let clone := mload(0x40)\\n      mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\\n      mstore(add(clone, 0xa), shl(96, target))\\n      mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n\\n      let other := add(clone, 0x40)\\n      extcodecopy(query, other, 0, 0x2d)\\n      result := and(\\n        eq(mload(clone), mload(other)),\\n        eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\\n      )\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/libraries/LowGasSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.0;\\n\\n/************************************************************************************************\\nOriginally from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/LowGasSafeMath.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash b83fcf497e895ae59b97c9d04e997023f69b5e97.\\n\\nSubject to the GPL-2.0 license\\n*************************************************************************************************/\\n\\n\\n/// @title Optimized overflow and underflow safe math operations\\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\\nlibrary LowGasSafeMath {\\n  /// @notice Returns x + y, reverts if sum overflows uint256\\n  /// @param x The augend\\n  /// @param y The addend\\n  /// @return z The sum of x and y\\n  function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    require((z = x + y) >= x);\\n  }\\n\\n  /// @notice Returns x + y, reverts if sum overflows uint256\\n  /// @param x The augend\\n  /// @param y The addend\\n  /// @return z The sum of x and y\\n  function add(uint256 x, uint256 y, string memory errorMessage) internal pure returns (uint256 z) {\\n    require((z = x + y) >= x, errorMessage);\\n  }\\n\\n  /// @notice Returns x - y, reverts if underflows\\n  /// @param x The minuend\\n  /// @param y The subtrahend\\n  /// @return z The difference of x and y\\n  function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    require(y <= x);\\n    z = x - y;\\n  }\\n\\n  /// @notice Returns x - y, reverts if underflows\\n  /// @param x The minuend\\n  /// @param y The subtrahend\\n  /// @return z The difference of x and y\\n  function sub(uint256 x, uint256 y, string memory errorMessage) internal pure returns (uint256 z) {\\n    require(y <= x, errorMessage);\\n    z = x - y;\\n  }\\n\\n  /// @notice Returns x * y, reverts if overflows\\n  /// @param x The multiplicand\\n  /// @param y The multiplier\\n  /// @return z The product of x and y\\n  function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    if (x == 0) return 0;\\n    z = x * y;\\n    require(z / x == y);\\n  }\\n\\n  /// @notice Returns x * y, reverts if overflows\\n  /// @param x The multiplicand\\n  /// @param y The multiplier\\n  /// @return z The product of x and y\\n  function mul(uint256 x, uint256 y, string memory errorMessage) internal pure returns (uint256 z) {\\n    if (x == 0) return 0;\\n    z = x * y;\\n    require(z / x == y, errorMessage);\\n  }\\n\\n  /// @notice Returns ceil(x / y)\\n  /// @param x The numerator\\n  /// @param y The denominator\\n  /// @return z The quotient of x and y\\n  function divCeil(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    z = x % y == 0 ? x / y : (x/y) + 1;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/MinimalSignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n\\nlibrary MinimalSignedMath {\\n  function add(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a + b;\\n    require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n    return c;\\n  }\\n\\n  function sub(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a - b;\\n    require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n    return c;\\n  }\\n\\n  function add(uint256 a, int256 b) internal pure returns (uint256) {\\n    require(a < 2**255);\\n    int256 _a = int256(a);\\n    int256 c = _a + b;\\n    require((b >= 0 && c >= _a) || (b < 0 && c < _a));\\n    if (c < 0) return 0;\\n    return uint256(c);\\n  }\\n}\"\r\n    },\r\n    \"contracts/libraries/RayMul.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\n\\nlibrary RayMul {\\n  uint256 internal constant RAY = 1e27;\\n  uint256 internal constant halfRAY = RAY / 2;\\n\\n  /**\\n   * @dev Multiplies two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a*b, in ray\\n   **/\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n\\n    require(a <= (type(uint256).max - halfRAY) / b, \\\"rayMul overflow\\\");\\n\\n    return (a * b + halfRAY) / RAY;\\n  }\\n}\"\r\n    },\r\n    \"contracts/libraries/ReserveConfigurationLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"../interfaces/AaveV2Interfaces.sol\\\";\\n\\n\\nlibrary ReserveConfigurationLib {\\n  uint256 internal constant RESERVE_FACTOR_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant FROZEN_MASK                  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 internal constant RESERVE_FACTOR_START_BIT_POSITION = 64;\\n\\n  /**\\n   * @dev Gets the reserve factor of the reserve\\n   * @param self The reserve configuration\\n   * @return The reserve factor\\n   **/\\n  function getReserveFactor(ILendingPool.ReserveConfigurationMap memory self)\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\\n  }\\n\\n  function isFrozen(ILendingPool.ReserveConfigurationMap memory self)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return (self.data & ~FROZEN_MASK) != 0;\\n  }\\n}\"\r\n    },\r\n    \"contracts/libraries/SymbolHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"../interfaces/IERC20Metadata.sol\\\";\\n\\n\\nlibrary SymbolHelper {\\n\\n  /**\\n   * @dev Returns the index of the lowest bit set in `self`.\\n   * Note: Requires that `self != 0`\\n   */\\n  function lowestBitSet(uint256 self) internal pure returns (uint256 _z) {\\n    require (self > 0, \\\"Bits::lowestBitSet: Value 0 has no bits set\\\");\\n    uint256 _magic = 0x00818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff;\\n    uint256 val = (self & -self) * _magic >> 248;\\n    uint256 _y = val >> 5;\\n    _z = (\\n      _y < 4\\n        ? _y < 2\\n          ? _y == 0\\n            ? 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100\\n            : 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606\\n          : _y == 2\\n            ? 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707\\n            : 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e\\n        : _y < 6\\n          ? _y == 4\\n            ? 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff\\n            : 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616\\n          : _y == 6\\n            ? 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe\\n            : 0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd\\n    );\\n    _z >>= (val & 0x1f) << 3;\\n    return _z & 0xff;\\n  }\\n\\n  function getSymbol(address token) internal view returns (string memory) {\\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSignature(\\\"symbol()\\\"));\\n    if (!success) return \\\"UNKNOWN\\\";\\n    if (data.length != 32) return abi.decode(data, (string));\\n    uint256 symbol = abi.decode(data, (uint256));\\n    if (symbol == 0) return \\\"UNKNOWN\\\";\\n    uint256 emptyBits = 255 - lowestBitSet(symbol);\\n    uint256 size = (emptyBits / 8) + (emptyBits % 8 > 0 ? 1 : 0);\\n    assembly { mstore(data, size) }\\n    return string(data);\\n  }\\n\\n  function getName(address token) internal view returns (string memory) {\\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSignature(\\\"name()\\\"));\\n    if (!success) return \\\"UNKNOWN\\\";\\n    if (data.length != 32) return abi.decode(data, (string));\\n    uint256 symbol = abi.decode(data, (uint256));\\n    if (symbol == 0) return \\\"UNKNOWN\\\";\\n    uint256 emptyBits = 255 - lowestBitSet(symbol);\\n    uint256 size = (emptyBits / 8) + (emptyBits % 8 > 0 ? 1 : 0);\\n    assembly { mstore(data, size) }\\n    return string(data);\\n  }\\n\\n  function getPrefixedSymbol(string memory prefix, address token) internal view returns (string memory prefixedSymbol) {\\n    prefixedSymbol = string(abi.encodePacked(\\n      prefix,\\n      getSymbol(token)\\n    ));\\n  }\\n\\n  function getPrefixedName(string memory prefix, address token) internal view returns (string memory prefixedName) {\\n    prefixedName = string(abi.encodePacked(\\n      prefix,\\n      getName(token)\\n    ));\\n  }\\n}\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\n/************************************************************************************************\\nOriginally from https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash cfedb1f55864dcf8cc0831fdd8ec18eb045b7fd1.\\n\\nSubject to the MIT license\\n*************************************************************************************************/\\n\\n\\nlibrary TransferHelper {\\n  function safeApproveMax(address token, address to) internal {\\n    safeApprove(token, to, type(uint256).max);\\n  }\\n\\n  function safeUnapprove(address token, address to) internal {\\n    safeApprove(token, to, 0);\\n  }\\n\\n  function safeApprove(address token, address to, uint value) internal {\\n    // bytes4(keccak256(bytes(\\\"approve(address,uint256)\\\")));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TH:SA\\\");\\n  }\\n\\n  function safeTransfer(address token, address to, uint value) internal {\\n    // bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TH:ST\\\");\\n  }\\n\\n  function safeTransferFrom(address token, address from, address to, uint value) internal {\\n    // bytes4(keccak256(bytes(\\\"transferFrom(address,address,uint256)\\\")));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TH:STF\\\");\\n  }\\n\\n  function safeTransferETH(address to, uint256 value) internal {\\n    (bool success, ) = to.call{value: value}(\\\"\\\");\\n    require(success, \\\"TH:STE\\\");\\n  }\\n}\"\r\n    },\r\n    \"contracts/protocols/AaveV2ProtocolAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../interfaces/AaveV2Interfaces.sol\\\";\\nimport \\\"../adapters/aave-v2/AaveV2Erc20Adapter.sol\\\";\\nimport \\\"../adapters/aave-v2/AaveV2EtherAdapter.sol\\\";\\nimport \\\"../libraries/ReserveConfigurationLib.sol\\\";\\nimport \\\"./AbstractProtocolAdapter.sol\\\";\\n\\n\\ncontract AaveV2ProtocolAdapter is AbstractProtocolAdapter {\\n  using ReserveConfigurationLib for ILendingPool.ReserveConfigurationMap;\\n\\n/* ========== Constants ========== */\\n\\n  ILendingPoolAddressesProvider public constant aave = ILendingPoolAddressesProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);\\n  ILendingPool public immutable pool;\\n  address public immutable erc20AdapterImplementation;\\n\\n/* ========== Constructor ========== */\\n\\n  constructor(IAdapterRegistry _registry) AbstractProtocolAdapter(_registry) {\\n    erc20AdapterImplementation = address(new AaveV2Erc20Adapter(aave));\\n    pool = aave.getLendingPool();\\n  }\\n\\n/* ========== Internal Actions ========== */\\n\\n  function deployAdapter(address underlying) internal override returns (address adapter) {\\n    address aToken = pool.getReserveData(underlying).aTokenAddress;\\n    if (underlying == weth) {\\n      adapter = address(new AaveV2EtherAdapter(aave, underlying, aToken));\\n    } else {\\n      adapter = CloneLibrary.createClone(erc20AdapterImplementation);\\n      AaveV2Erc20Adapter(adapter).initialize(underlying, aToken);\\n    }\\n  }\\n\\n/* ========== Public Queries ========== */\\n\\n  function protocol() external pure virtual override returns (string memory) {\\n    return \\\"Aave V2\\\";\\n  }\\n\\n  function getUnmapped() public view virtual override returns (address[] memory tokens) {\\n    tokens = pool.getReservesList();\\n    uint256 len = tokens.length;\\n    uint256 prevLen = totalMapped;\\n    if (len == prevLen) {\\n      assembly { mstore(tokens, 0) }\\n    } else {\\n      assembly {\\n        tokens := add(tokens, mul(prevLen, 32))\\n        mstore(tokens, sub(len, prevLen))\\n      }\\n    }\\n  }\\n\\n/* ========== Internal Queries ========== */\\n\\n  function isAdapterMarketFrozen(address adapter) internal view virtual override returns (bool) {\\n    return isTokenMarketFrozen(IErc20Adapter(adapter).underlying());\\n  }\\n\\n  function isTokenMarketFrozen(address underlying) internal view virtual override returns (bool) {\\n    return pool.getConfiguration(underlying).isFrozen();\\n  }\\n}\\n\\n\"\r\n    },\r\n    \"contracts/protocols/AbstractProtocolAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../interfaces/IAdapterRegistry.sol\\\";\\nimport \\\"../libraries/CloneLibrary.sol\\\";\\nimport \\\"../libraries/ArrayHelper.sol\\\";\\n\\n\\nabstract contract AbstractProtocolAdapter {\\n  using ArrayHelper for address[];\\n\\n/* ========== Events ========== */\\n\\n  event MarketFrozen(address token);\\n\\n  event MarketUnfrozen(address token);\\n\\n  event AdapterFrozen(address adapter);\\n\\n  event AdapterUnfrozen(address adapter);\\n\\n/* ========== Constants ========== */\\n\\n  /**\\n   * @dev WETH address used for deciding whether to deploy an ERC20 or Ether adapter.\\n   */\\n  address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n  /**\\n   * @dev Global registry of adapters.\\n   */\\n  IAdapterRegistry public immutable registry;\\n\\n/* ========== Storage ========== */\\n\\n  /**\\n   * @dev List of adapters which have been deployed and then frozen.\\n   */\\n  address[] public frozenAdapters;\\n\\n  /**\\n   * @dev List of tokens which have been frozen and which do not have an adapter.\\n   */\\n  address[] public frozenTokens;\\n\\n  /**\\n   * @dev Number of tokens which have been mapped by the adapter.\\n   */\\n  uint256 public totalMapped;\\n\\n/* ========== Constructor ========== */\\n\\n  constructor(IAdapterRegistry _registry) {\\n    registry = _registry;\\n  }\\n\\n/* ========== Public Actions ========== */\\n\\n  /**\\n   * @dev Map up to `max` tokens, starting at `totalMapped`.\\n   */\\n  function map(uint256 max) external virtual {\\n    address[] memory tokens = getUnmappedUpTo(max);\\n    uint256 len = tokens.length;\\n    address[] memory adapters = new address[](len);\\n    uint256 skipped;\\n    for (uint256 i; i < len; i++) {\\n      address token = tokens[i];\\n      if (isTokenMarketFrozen(token)) {\\n        skipped++;\\n        frozenTokens.push(token);\\n        emit MarketFrozen(token);\\n        continue;\\n      }\\n      address adapter = deployAdapter(token);\\n      adapters[i - skipped] = adapter;\\n    }\\n    totalMapped += len;\\n    assembly { if gt(skipped, 0) { mstore(adapters, sub(len, skipped)) } }\\n    registry.addTokenAdapters(adapters);\\n  }\\n\\n  /**\\n   * @dev Unfreeze adapter at `index` in `frozenAdapters`.\\n   * Market for the adapter must not be frozen by the protocol.\\n   */\\n  function unfreezeAdapter(uint256 index) external virtual {\\n    address adapter = frozenAdapters[index];\\n    require(!isAdapterMarketFrozen(adapter), \\\"Market still frozen\\\");\\n    frozenAdapters.remove(index);\\n    registry.addTokenAdapter(adapter);\\n    emit AdapterUnfrozen(adapter);\\n  }\\n\\n  /**\\n   * @dev Unfreeze token at `index` in `frozenTokens` and create a new adapter for it.\\n   * Market for the token must not be frozen by the protocol.\\n   */\\n  function unfreezeToken(uint256 index) external virtual {\\n    address token = frozenTokens[index];\\n    require(!isTokenMarketFrozen(token), \\\"Market still frozen\\\");\\n    frozenTokens.remove(index);\\n    address adapter = deployAdapter(token);\\n    registry.addTokenAdapter(adapter);\\n    emit MarketUnfrozen(token);\\n  }\\n\\n  /**\\n   * @dev Freeze `adapter` - add it to `frozenAdapters` and remove it from the registry.\\n   * Does not verify adapter exists or has been registered by this contract because the\\n   * registry handles that.\\n   */\\n  function freezeAdapter(address adapter) external virtual {\\n    require(isAdapterMarketFrozen(adapter), \\\"Market not frozen\\\");\\n    frozenAdapters.push(adapter);\\n    registry.removeTokenAdapter(adapter);\\n    emit AdapterFrozen(adapter);\\n  }\\n\\n/* ========== Internal Actions ========== */\\n\\n  /**\\n   * @dev Deploys an adapter for `token`, which will either be an underlying token\\n   * or a wrapper token, whichever is returned by `getUnmapped`.\\n   */\\n  function deployAdapter(address token) internal virtual returns (address);\\n\\n/* ========== Public Queries ========== */\\n\\n  /**\\n   * @dev Name of the protocol the adapter is for.\\n   */\\n  function protocol() external view virtual returns (string memory);\\n\\n  /**\\n   * @dev Get the list of tokens which have not already been mapped by the adapter.\\n   * Tokens may be underlying tokens or wrapper tokens for a lending market.\\n   */\\n  function getUnmapped() public view virtual returns (address[] memory tokens);\\n\\n  /**\\n   * @dev Get up to `max` tokens which have not already been mapped by the adapter.\\n   * Tokens may be underlying tokens or wrapper tokens for a lending market.\\n   */\\n  function getUnmappedUpTo(uint256 max) public view virtual returns (address[] memory tokens) {\\n    tokens = getUnmapped();\\n    if (tokens.length > max) {\\n      assembly { mstore(tokens, max) }\\n    }\\n  }\\n\\n  function getFrozenAdapters() external view returns (address[] memory tokens) {\\n    tokens = frozenAdapters;\\n  }\\n\\n  function getFrozenTokens() external view returns (address[] memory tokens) {\\n    tokens = frozenTokens;\\n  }\\n\\n/* ========== Internal Queries ========== */\\n\\n  /**\\n   * @dev Check whether the market for an adapter is frozen.\\n   */\\n  function isAdapterMarketFrozen(address adapter) internal view virtual returns (bool);\\n\\n  /**\\n   * @dev Check whether the market for a token is frozen.\\n   */\\n  function isTokenMarketFrozen(address token) internal view virtual returns (bool);\\n}\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IAdapterRegistry\",\"name\":\"_registry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"}],\"name\":\"AdapterFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"}],\"name\":\"AdapterUnfrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"MarketFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"MarketUnfrozen\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"aave\",\"outputs\":[{\"internalType\":\"contract ILendingPoolAddressesProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20AdapterImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"}],\"name\":\"freezeAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"frozenAdapters\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"frozenTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFrozenAdapters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFrozenTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnmapped\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"getUnmappedUpTo\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"map\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract ILendingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract IAdapterRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMapped\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"unfreezeAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"unfreezeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AaveV2ProtocolAdapter","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"800","ConstructorArguments":"0000000000000000000000005f2945604013ee9f80ae2eddb384462b681859c4","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}