{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/aave/AaveBasicProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../utils/GasBurner.sol\\\";\\nimport \\\"../interfaces/IAToken.sol\\\";\\nimport \\\"../interfaces/ILendingPool.sol\\\";\\nimport \\\"../interfaces/ILendingPoolAddressesProvider.sol\\\";\\n\\nimport \\\"../utils/SafeERC20.sol\\\";\\n\\n/// @title Basic compound interactions through the DSProxy\\ncontract AaveBasicProxy is GasBurner {\\n\\n    using SafeERC20 for ERC20;\\n\\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant AAVE_LENDING_POOL_ADDRESSES = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\\n\\n    uint16 public constant AAVE_REFERRAL_CODE = 64;\\n\\n    /// @notice User deposits tokens to the Aave protocol\\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\\n    /// @param _tokenAddr The address of the token to be deposited\\n    /// @param _amount Amount of tokens to be deposited\\n    function deposit(address _tokenAddr, uint256 _amount) public burnGas(5) payable {\\n        address lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\\n\\n        uint ethValue = _amount;\\n\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\\n            approveToken(_tokenAddr, lendingPoolCore);\\n            ethValue = 0;\\n        }\\n\\n        ILendingPool(lendingPool).deposit{value: ethValue}(_tokenAddr, _amount, AAVE_REFERRAL_CODE);\\n\\n        setUserUseReserveAsCollateralIfNeeded(_tokenAddr);\\n    }\\n\\n    /// @notice User withdraws tokens from the Aave protocol\\n    /// @param _tokenAddr The address of the token to be withdrawn\\n    /// @param _aTokenAddr ATokens to be withdrawn\\n    /// @param _amount Amount of tokens to be withdrawn\\n    /// @param _wholeAmount If true we will take the whole amount on chain\\n    function withdraw(address _tokenAddr, address _aTokenAddr, uint256 _amount, bool _wholeAmount) public burnGas(8) {\\n        uint256 amount = _wholeAmount ? ERC20(_aTokenAddr).balanceOf(address(this)) : _amount;\\n\\n        IAToken(_aTokenAddr).redeem(amount);\\n\\n        withdrawTokens(_tokenAddr);\\n    }\\n\\n    /// @notice User borrows tokens to the Aave protocol\\n    /// @param _tokenAddr The address of the token to be borrowed\\n    /// @param _amount Amount of tokens to be borrowed\\n    /// @param _type Send 1 for stable rate and 2 for variable rate\\n    function borrow(address _tokenAddr, uint256 _amount, uint256 _type) public burnGas(8) {\\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\\n\\n        ILendingPool(lendingPool).borrow(_tokenAddr, _amount, _type, AAVE_REFERRAL_CODE);\\n\\n        withdrawTokens(_tokenAddr);\\n    }\\n\\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\\n    /// @notice User paybacks tokens to the Aave protocol\\n    /// @param _tokenAddr The address of the token to be paybacked\\n    /// @param _aTokenAddr ATokens to be paybacked\\n    /// @param _amount Amount of tokens to be payed back\\n    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt\\n    function payback(address _tokenAddr, address _aTokenAddr, uint256 _amount, bool _wholeDebt) public burnGas(3) payable {\\n        address lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\\n\\n        uint256 amount = _amount;\\n\\n        (,uint256 borrowAmount,,,,,uint256 originationFee,,,) = ILendingPool(lendingPool).getUserReserveData(_tokenAddr, address(this));\\n\\n        if (_wholeDebt) {\\n            amount = borrowAmount + originationFee;\\n        }\\n\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), amount);\\n            approveToken(_tokenAddr, lendingPoolCore);\\n        }\\n\\n        ILendingPool(lendingPool).repay{value: msg.value}(_tokenAddr, amount, payable(address(this)));\\n\\n        withdrawTokens(_tokenAddr);\\n    }\\n\\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\\n    /// @notice User paybacks tokens to the Aave protocol\\n    /// @param _tokenAddr The address of the token to be paybacked\\n    /// @param _aTokenAddr ATokens to be paybacked\\n    /// @param _amount Amount of tokens to be payed back\\n    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt\\n    function paybackOnBehalf(address _tokenAddr, address _aTokenAddr, uint256 _amount, bool _wholeDebt, address payable _onBehalf) public burnGas(3) payable {\\n        address lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\\n\\n        uint256 amount = _amount;\\n\\n        (,uint256 borrowAmount,,,,,uint256 originationFee,,,) = ILendingPool(lendingPool).getUserReserveData(_tokenAddr, _onBehalf);\\n\\n        if (_wholeDebt) {\\n            amount = borrowAmount + originationFee;\\n        }\\n\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), amount);\\n            approveToken(_tokenAddr, lendingPoolCore);\\n        }\\n\\n        ILendingPool(lendingPool).repay{value: msg.value}(_tokenAddr, amount, _onBehalf);\\n\\n        withdrawTokens(_tokenAddr);\\n    }\\n\\n    /// @notice Helper method to withdraw tokens from the DSProxy\\n    /// @param _tokenAddr Address of the token to be withdrawn\\n    function withdrawTokens(address _tokenAddr) public {\\n        uint256 amount = _tokenAddr == ETH_ADDR ? address(this).balance : ERC20(_tokenAddr).balanceOf(address(this));\\n\\n        if (amount > 0) {\\n            if (_tokenAddr != ETH_ADDR) {\\n                ERC20(_tokenAddr).safeTransfer(msg.sender, amount);\\n            } else {\\n                msg.sender.transfer(amount);\\n            }\\n        }\\n    }\\n\\n    /// @notice Approves token contract to pull underlying tokens from the DSProxy\\n    /// @param _tokenAddr Token we are trying to approve\\n    /// @param _caller Address which will gain the approval\\n    function approveToken(address _tokenAddr, address _caller) internal {\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeApprove(_caller, uint256(-1));\\n        }\\n    }\\n\\n    function setUserUseReserveAsCollateralIfNeeded(address _tokenAddr) public {\\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\\n        (,,,,,,,,,bool collateralEnabled) = ILendingPool(lendingPool).getUserReserveData(_tokenAddr, address(this));\\n\\n        if (!collateralEnabled) {\\n            ILendingPool(lendingPool).setUserUseReserveAsCollateral(_tokenAddr, true);\\n        }\\n    }\\n\\n    function setUserUseReserveAsCollateral(address _tokenAddr, bool _true) public {\\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\\n\\n        ILendingPool(lendingPool).setUserUseReserveAsCollateral(_tokenAddr, _true);\\n    }\\n\\n    function swapBorrowRateMode(address _reserve) public {\\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\\n\\n        ILendingPool(lendingPool).swapBorrowRateMode(_reserve);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/GasBurner.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../interfaces/GasTokenInterface.sol\\\";\\n\\ncontract GasBurner {\\n    // solhint-disable-next-line const-name-snakecase\\n    GasTokenInterface public constant gasToken = GasTokenInterface(0x0000000000b3F879cb30FE243b4Dfee438691c04);\\n\\n    modifier burnGas(uint _amount) {\\n        if (gasToken.balanceOf(address(this)) >= _amount) {\\n            gasToken.free(_amount);\\n        }\\n\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract IAToken {\\n    function redeem(uint256 _amount) external virtual;\\n    function balanceOf(address _owner) external virtual view returns (uint256 balance);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingPool.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract ILendingPool {\\n    function flashLoan( address payable _receiver, address _reserve, uint _amount, bytes calldata _params) external virtual;\\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode) external virtual payable;\\n\\tfunction setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external virtual;\\n\\tfunction borrow(address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode) external virtual;\\n\\tfunction repay( address _reserve, uint256 _amount, address payable _onBehalfOf) external virtual payable;\\n\\tfunction swapBorrowRateMode(address _reserve) external virtual;\\n    function getReserves() external virtual view returns(address[] memory);\\n\\n    /// @param _reserve underlying token address\\n    function getReserveData(address _reserve)\\n        external virtual\\n        view\\n        returns (\\n            uint256 totalLiquidity,               // reserve total liquidity\\n            uint256 availableLiquidity,           // reserve available liquidity for borrowing\\n            uint256 totalBorrowsStable,           // total amount of outstanding borrows at Stable rate\\n            uint256 totalBorrowsVariable,         // total amount of outstanding borrows at Variable rate\\n            uint256 liquidityRate,                // current deposit APY of the reserve for depositors, in Ray units.\\n            uint256 variableBorrowRate,           // current variable rate APY of the reserve pool, in Ray units.\\n            uint256 stableBorrowRate,             // current stable rate APY of the reserve pool, in Ray units.\\n            uint256 averageStableBorrowRate,      // current average stable borrow rate\\n            uint256 utilizationRate,              // expressed as total borrows/total liquidity.\\n            uint256 liquidityIndex,               // cumulative liquidity index\\n            uint256 variableBorrowIndex,          // cumulative variable borrow index\\n            address aTokenAddress,                // aTokens contract address for the specific _reserve\\n            uint40 lastUpdateTimestamp            // timestamp of the last update of reserve data\\n        );\\n\\n    /// @param _user users address\\n    function getUserAccountData(address _user)\\n        external virtual\\n        view\\n        returns (\\n            uint256 totalLiquidityETH,            // user aggregated deposits across all the reserves. In Wei\\n            uint256 totalCollateralETH,           // user aggregated collateral across all the reserves. In Wei\\n            uint256 totalBorrowsETH,              // user aggregated outstanding borrows across all the reserves. In Wei\\n            uint256 totalFeesETH,                 // user aggregated current outstanding fees in ETH. In Wei\\n            uint256 availableBorrowsETH,          // user available amount to borrow in ETH\\n            uint256 currentLiquidationThreshold,  // user current average liquidation threshold across all the collaterals deposited\\n            uint256 ltv,                          // user average Loan-to-Value between all the collaterals\\n            uint256 healthFactor                  // user current Health Factor\\n    );\\n\\n    /// @param _reserve underlying token address\\n    /// @param _user users address\\n    function getUserReserveData(address _reserve, address _user)\\n        external virtual\\n        view\\n        returns (\\n            uint256 currentATokenBalance,         // user current reserve aToken balance\\n            uint256 currentBorrowBalance,         // user current reserve outstanding borrow balance\\n            uint256 principalBorrowBalance,       // user balance of borrowed asset\\n            uint256 borrowRateMode,               // user borrow rate mode either Stable or Variable\\n            uint256 borrowRate,                   // user current borrow rate APY\\n            uint256 liquidityRate,                // user current earn rate on _reserve\\n            uint256 originationFee,               // user outstanding loan origination fee\\n            uint256 variableBorrowIndex,          // user variable cumulative index\\n            uint256 lastUpdateTimestamp,          // Timestamp of the last data update\\n            bool usageAsCollateralEnabled         // Whether the user's current reserve is enabled as a collateral\\n    );\\n\\n    function getReserveConfigurationData(address _reserve)\\n        external virtual\\n        view\\n        returns (\\n            uint256 ltv,\\n            uint256 liquidationThreshold,\\n            uint256 liquidationBonus,\\n            address rateStrategyAddress,\\n            bool usageAsCollateralEnabled,\\n            bool borrowingEnabled,\\n            bool stableBorrowRateEnabled,\\n            bool isActive\\n    );\\n\\n    // ------------------ LendingPoolCoreData ------------------------\\n    function getReserveATokenAddress(address _reserve) public virtual view returns (address);\\n    function getReserveConfiguration(address _reserve)\\n        external virtual\\n        view\\n        returns (uint256, uint256, uint256, bool);\\n    function getUserUnderlyingAssetBalance(address _reserve, address _user)\\n        public virtual\\n        view\\n        returns (uint256);\\n\\n    function getReserveCurrentLiquidityRate(address _reserve)\\n        public virtual\\n        view\\n        returns (uint256);\\n    function getReserveCurrentVariableBorrowRate(address _reserve)\\n        public virtual\\n        view\\n        returns (uint256);\\n    function getReserveCurrentStableBorrowRate(address _reserve)\\n        public virtual\\n        view\\n        returns (uint256);\\n    function getReserveTotalLiquidity(address _reserve)\\n        public virtual\\n        view\\n        returns (uint256);\\n    function getReserveAvailableLiquidity(address _reserve)\\n        public virtual\\n        view\\n        returns (uint256);\\n    function getReserveTotalBorrowsVariable(address _reserve)\\n        public virtual\\n        view\\n        returns (uint256);\\n    function getReserveTotalBorrowsStable(address _reserve)\\n        public virtual\\n        view\\n        returns (uint256);\\n\\n    // ---------------- LendingPoolDataProvider ---------------------\\n    function calculateUserGlobalData(address _user)\\n        public virtual\\n        view\\n        returns (\\n            uint256 totalLiquidityBalanceETH,\\n            uint256 totalCollateralBalanceETH,\\n            uint256 totalBorrowBalanceETH,\\n            uint256 totalFeesETH,\\n            uint256 currentLtv,\\n            uint256 currentLiquidationThreshold,\\n            uint256 healthFactor,\\n            bool healthFactorBelowThreshold\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingPoolAddressesProvider.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n@title ILendingPoolAddressesProvider interface\\n@notice provides the interface to fetch the LendingPoolCore address\\n */\\nabstract contract ILendingPoolAddressesProvider {\\n\\n    function getLendingPool() public virtual view returns (address);\\n    function getLendingPoolCore() public virtual view returns (address payable);\\n    function getLendingPoolConfigurator() public virtual view returns (address);\\n    function getLendingPoolDataProvider() public virtual view returns (address);\\n    function getLendingPoolParametersProvider() public virtual view returns (address);\\n    function getTokenDistributor() public virtual view returns (address);\\n    function getFeeProvider() public virtual view returns (address);\\n    function getLendingPoolLiquidationManager() public virtual view returns (address);\\n    function getLendingPoolManager() public virtual view returns (address);\\n    function getPriceOracle() public virtual view returns (address);\\n    function getLendingRateOracle() public virtual view returns (address);\\n}\"\r\n    },\r\n    \"contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../interfaces/ERC20.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     */\\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function _callOptionalReturn(ERC20 token, bytes memory data) private {\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/GasTokenInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\nabstract contract GasTokenInterface is ERC20 {\\n    function free(uint256 value) public virtual returns (bool success);\\n\\n    function freeUpTo(uint256 value) public virtual returns (uint256 freed);\\n\\n    function freeFrom(address from, uint256 value) public virtual returns (bool success);\\n\\n    function freeFromUpTo(address from, uint256 value) public virtual returns (uint256 freed);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface ERC20 {\\n    function totalSupply() external view returns (uint256 supply);\\n\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n\\n    function transferFrom(address _from, address _to, uint256 _value)\\n        external\\n        returns (bool success);\\n\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n\\n    function decimals() external view returns (uint256 digits);\\n\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/PullTokensProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../interfaces/DSProxyInterface.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\n/// @title Pulls a specified amount of tokens from the EOA owner account to the proxy\\ncontract PullTokensProxy {\\n    using SafeERC20 for ERC20;\\n\\n    /// @notice Pulls a token from the proxyOwner -> proxy\\n    /// @dev Proxy owner must first give approve to the proxy address\\n    /// @param _tokenAddr Address of the ERC20 token\\n    /// @param _amount Amount of tokens which will be transfered to the proxy\\n    function pullTokens(address _tokenAddr, uint _amount) public {\\n        address proxyOwner = DSProxyInterface(address(this)).owner();\\n\\n        ERC20(_tokenAddr).safeTransferFrom(proxyOwner, address(this), _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/DSProxyInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\nabstract contract DSProxyInterface {\\n\\n    /// Truffle wont compile if this isn't commented\\n    // function execute(bytes memory _code, bytes memory _data)\\n    //     public virtual\\n    //     payable\\n    //     returns (address, bytes32);\\n\\n    function execute(address _target, bytes memory _data) public virtual payable returns (bytes32);\\n\\n    function setCache(address _cacheAddr) public virtual payable returns (bool);\\n\\n    function owner() public virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/DFSProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../auth/Auth.sol\\\";\\nimport \\\"../interfaces/DSProxyInterface.sol\\\";\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\ncontract DFSProxy is Auth {\\n    string public constant NAME = \\\"DFSProxy\\\";\\n    string public constant VERSION = \\\"v0.1\\\";\\n\\n    mapping(address => mapping(uint => bool)) public nonces;\\n\\n    // --- EIP712 niceties ---\\n    bytes32 public DOMAIN_SEPARATOR;\\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\\\"callProxy(address _user,address _proxy,address _contract,bytes _txData,uint256 _nonce)\\\");\\n\\n    constructor(uint256 chainId_) public {\\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\\n            keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n            keccak256(bytes(NAME)),\\n            keccak256(bytes(VERSION)),\\n            chainId_,\\n            address(this)\\n        ));\\n    }\\n\\n    function callProxy(address _user, address _proxy, address _contract, bytes calldata _txData, uint256 _nonce,\\n                    uint8 _v, bytes32 _r, bytes32 _s) external payable onlyAuthorized\\n    {\\n        bytes32 digest =\\n            keccak256(abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(PERMIT_TYPEHASH,\\n                                     _user,\\n                                     _proxy,\\n                                     _contract,\\n                                     _txData,\\n                                     _nonce))\\n        ));\\n\\n        // user must be proxy owner\\n        require(DSProxyInterface(_proxy).owner() == _user);\\n        require(_user == ecrecover(digest, _v, _r, _s), \\\"DFSProxy/user-not-valid\\\");\\n        require(!nonces[_user][_nonce], \\\"DFSProxy/invalid-nonce\\\");\\n        \\n        nonces[_user][_nonce] = true;\\n\\n        DSProxyInterface(_proxy).execute{value: msg.value}(_contract, _txData);\\n    }\\n}\"\r\n    },\r\n    \"contracts/auth/Auth.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./AdminAuth.sol\\\";\\n\\ncontract Auth is AdminAuth {\\n\\n\\tbool public ALL_AUTHORIZED = false;\\n\\n\\tmapping(address => bool) public authorized;\\n\\n\\tmodifier onlyAuthorized() {\\n        require(ALL_AUTHORIZED || authorized[msg.sender]);\\n        _;\\n    }\\n\\n\\tconstructor() public {\\n\\t\\tauthorized[msg.sender] = true;\\n\\t}\\n\\n\\tfunction setAuthorized(address _user, bool _approved) public onlyOwner {\\n\\t\\tauthorized[_user] = _approved;\\n\\t}\\n\\n\\tfunction setAllAuthorized(bool _authorized) public onlyOwner {\\n\\t\\tALL_AUTHORIZED = _authorized;\\n\\t}\\n}\"\r\n    },\r\n    \"contracts/auth/AdminAuth.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../utils/SafeERC20.sol\\\";\\n\\ncontract AdminAuth {\\n\\n    using SafeERC20 for ERC20;\\n\\n    address public owner;\\n    address public admin;\\n\\n    modifier onlyOwner() {\\n        require(owner == msg.sender);\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(admin == msg.sender);\\n        _;\\n    }\\n\\n    constructor() public {\\n        owner = msg.sender;\\n        admin = 0x25eFA336886C74eA8E282ac466BdCd0199f85BB9;\\n    }\\n\\n    /// @notice Admin is set by owner first time, after that admin is super role and has permission to change owner\\n    /// @param _admin Address of multisig that becomes admin\\n    function setAdminByOwner(address _admin) public {\\n        require(msg.sender == owner);\\n        require(admin == address(0));\\n\\n        admin = _admin;\\n    }\\n\\n    /// @notice Admin is able to set new admin\\n    /// @param _admin Address of multisig that becomes new admin\\n    function setAdminByAdmin(address _admin) public {\\n        require(msg.sender == admin);\\n\\n        admin = _admin;\\n    }\\n\\n    /// @notice Admin is able to change owner\\n    /// @param _owner Address of new owner\\n    function setOwnerByAdmin(address _owner) public {\\n        require(msg.sender == admin);\\n\\n        owner = _owner;\\n    }\\n\\n    /// @notice Destroy the contract\\n    function kill() public onlyOwner {\\n        selfdestruct(payable(owner));\\n    }\\n\\n    /// @notice  withdraw stuck funds\\n    function withdrawStuckFunds(address _token, uint _amount) public onlyOwner {\\n        if (_token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\\n            payable(owner).transfer(_amount);\\n        } else {\\n            ERC20(_token).safeTransfer(owner, _amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/shifter/LoanShifterTaker.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/ILendingPool.sol\\\";\\nimport \\\"../interfaces/CTokenInterface.sol\\\";\\nimport \\\"../interfaces/ILoanShifter.sol\\\";\\nimport \\\"../interfaces/DSProxyInterface.sol\\\";\\nimport \\\"../interfaces/Vat.sol\\\";\\nimport \\\"../interfaces/Manager.sol\\\";\\nimport \\\"../interfaces/IMCDSubscriptions.sol\\\";\\nimport \\\"../interfaces/ICompoundSubscriptions.sol\\\";\\nimport \\\"../auth/AdminAuth.sol\\\";\\nimport \\\"../auth/ProxyPermission.sol\\\";\\nimport \\\"../exchangeV3/DFSExchangeData.sol\\\";\\nimport \\\"./ShifterRegistry.sol\\\";\\nimport \\\"../utils/GasBurner.sol\\\";\\nimport \\\"../loggers/DefisaverLogger.sol\\\";\\n\\n\\n/// @title LoanShifterTaker Entry point for using the shifting operation\\ncontract LoanShifterTaker is AdminAuth, ProxyPermission, GasBurner {\\n\\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\\n\\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant CETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n\\n    address public constant MCD_SUB_ADDRESS = 0xC45d4f6B6bf41b6EdAA58B01c4298B8d9078269a;\\n    address public constant COMPOUND_SUB_ADDRESS = 0x52015EFFD577E08f498a0CCc11905925D58D6207;\\n\\n    address public constant MANAGER_ADDRESS = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\\n\\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\\n\\n    Manager public constant manager = Manager(MANAGER_ADDRESS);\\n    ShifterRegistry public constant shifterRegistry = ShifterRegistry(0x597C52281b31B9d949a9D8fEbA08F7A2530a965e);\\n\\n    enum Protocols { MCD, COMPOUND }\\n    enum SwapType { NO_SWAP, COLL_SWAP, DEBT_SWAP }\\n    enum Unsub { NO_UNSUB, FIRST_UNSUB, SECOND_UNSUB, BOTH_UNSUB }\\n\\n    struct LoanShiftData {\\n        Protocols fromProtocol;\\n        Protocols toProtocol;\\n        SwapType swapType;\\n        Unsub unsub;\\n        bool wholeDebt;\\n        uint collAmount;\\n        uint debtAmount;\\n        address debtAddr1;\\n        address debtAddr2;\\n        address addrLoan1;\\n        address addrLoan2;\\n        uint id1;\\n        uint id2;\\n    }\\n\\n    /// @notice Main entry point, it will move or transform a loan\\n    /// @dev Called through DSProxy\\n    function moveLoan(\\n        DFSExchangeData.ExchangeData memory _exchangeData,\\n        LoanShiftData memory _loanShift\\n    ) public payable burnGas(20) {\\n        if (_isSameTypeVaults(_loanShift)) {\\n            _forkVault(_loanShift);\\n            logEvent(_exchangeData, _loanShift);\\n            return;\\n        }\\n\\n        _callCloseAndOpen(_exchangeData, _loanShift);\\n    }\\n\\n    //////////////////////// INTERNAL FUNCTIONS //////////////////////////\\n\\n    function _callCloseAndOpen(\\n        DFSExchangeData.ExchangeData memory _exchangeData,\\n        LoanShiftData memory _loanShift\\n    ) internal {\\n        address protoAddr = shifterRegistry.getAddr(getNameByProtocol(uint8(_loanShift.fromProtocol)));\\n\\n        if (_loanShift.wholeDebt) {\\n            _loanShift.debtAmount = ILoanShifter(protoAddr).getLoanAmount(_loanShift.id1, _loanShift.debtAddr1);\\n        }\\n\\n        // encode data\\n        bytes memory paramsData = abi.encode(_loanShift, _exchangeData, address(this));\\n\\n        address payable loanShifterReceiverAddr = payable(shifterRegistry.getAddr(\\\"LOAN_SHIFTER_RECEIVER\\\"));\\n\\n        loanShifterReceiverAddr.transfer(address(this).balance);\\n\\n        // call FL\\n        givePermission(loanShifterReceiverAddr);\\n\\n        lendingPool.flashLoan(loanShifterReceiverAddr,\\n           getLoanAddr(_loanShift.debtAddr1, _loanShift.fromProtocol), _loanShift.debtAmount, paramsData);\\n\\n        removePermission(loanShifterReceiverAddr);\\n\\n        unsubFromAutomation(\\n            _loanShift.unsub,\\n            _loanShift.id1,\\n            _loanShift.id2,\\n            _loanShift.fromProtocol,\\n            _loanShift.toProtocol\\n        );\\n\\n        logEvent(_exchangeData, _loanShift);\\n    }\\n\\n    function _forkVault(LoanShiftData memory _loanShift) internal {\\n        // Create new Vault to move to\\n        if (_loanShift.id2 == 0) {\\n            _loanShift.id2 = manager.open(manager.ilks(_loanShift.id1), address(this));\\n        }\\n\\n        if (_loanShift.wholeDebt) {\\n            manager.shift(_loanShift.id1, _loanShift.id2);\\n        }\\n    }\\n\\n    function _isSameTypeVaults(LoanShiftData memory _loanShift) internal pure returns (bool) {\\n        return _loanShift.fromProtocol == Protocols.MCD && _loanShift.toProtocol == Protocols.MCD\\n                && _loanShift.addrLoan1 == _loanShift.addrLoan2;\\n    }\\n\\n    function getNameByProtocol(uint8 _proto) internal pure returns (string memory) {\\n        if (_proto == 0) {\\n            return \\\"MCD_SHIFTER\\\";\\n        } else if (_proto == 1) {\\n            return \\\"COMP_SHIFTER\\\";\\n        }\\n    }\\n\\n    function getLoanAddr(address _address, Protocols _fromProtocol) internal returns (address) {\\n        if (_fromProtocol == Protocols.COMPOUND) {\\n            return getUnderlyingAddr(_address);\\n        } else if (_fromProtocol == Protocols.MCD) {\\n            return DAI_ADDRESS;\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\\n        if (_cTokenAddress == CETH_ADDRESS) {\\n            return ETH_ADDRESS;\\n        } else {\\n            return CTokenInterface(_cTokenAddress).underlying();\\n        }\\n    }\\n\\n    function logEvent(\\n        DFSExchangeData.ExchangeData memory _exchangeData,\\n        LoanShiftData memory _loanShift\\n    ) internal {\\n        address srcAddr = _exchangeData.srcAddr;\\n        address destAddr = _exchangeData.destAddr;\\n\\n        uint collAmount = _exchangeData.srcAmount;\\n        uint debtAmount = _exchangeData.destAmount;\\n\\n        if (_loanShift.swapType == SwapType.NO_SWAP) {\\n            srcAddr = _loanShift.addrLoan1;\\n            destAddr = _loanShift.debtAddr1;\\n\\n            collAmount = _loanShift.collAmount;\\n            debtAmount = _loanShift.debtAmount;\\n        }\\n\\n        DefisaverLogger(DEFISAVER_LOGGER)\\n            .Log(address(this), msg.sender, \\\"LoanShifter\\\",\\n            abi.encode(\\n            _loanShift.fromProtocol,\\n            _loanShift.toProtocol,\\n            _loanShift.swapType,\\n            srcAddr,\\n            destAddr,\\n            collAmount,\\n            debtAmount\\n        ));\\n    }\\n\\n    function unsubFromAutomation(Unsub _unsub, uint _cdp1, uint _cdp2, Protocols _from, Protocols _to) internal {\\n        if (_unsub != Unsub.NO_UNSUB) {\\n            if (_unsub == Unsub.FIRST_UNSUB || _unsub == Unsub.BOTH_UNSUB) {\\n                unsubscribe(_cdp1, _from);\\n            }\\n\\n            if (_unsub == Unsub.SECOND_UNSUB || _unsub == Unsub.BOTH_UNSUB) {\\n                unsubscribe(_cdp2, _to);\\n            }\\n        }\\n    }\\n\\n    function unsubscribe(uint _cdpId, Protocols _protocol) internal {\\n        if (_cdpId != 0 && _protocol == Protocols.MCD) {\\n            IMCDSubscriptions(MCD_SUB_ADDRESS).unsubscribe(_cdpId);\\n        }\\n\\n        if (_protocol == Protocols.COMPOUND) {\\n            ICompoundSubscriptions(COMPOUND_SUB_ADDRESS).unsubscribe();\\n        }\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/CTokenInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\nabstract contract CTokenInterface is ERC20 {\\n    function mint(uint256 mintAmount) external virtual returns (uint256);\\n\\n    // function mint() external virtual payable;\\n\\n    function accrueInterest() public virtual returns (uint);\\n\\n    function redeem(uint256 redeemTokens) external virtual returns (uint256);\\n\\n    function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);\\n\\n    function borrow(uint256 borrowAmount) external virtual returns (uint256);\\n    function borrowIndex() public view virtual returns (uint);\\n    function borrowBalanceStored(address) public view virtual returns(uint);\\n\\n    function repayBorrow(uint256 repayAmount) external virtual returns (uint256);\\n\\n    function repayBorrow() external virtual payable;\\n\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (uint256);\\n\\n    function repayBorrowBehalf(address borrower) external virtual payable;\\n\\n    function liquidateBorrow(address borrower, uint256 repayAmount, address cTokenCollateral)\\n        external virtual\\n        returns (uint256);\\n\\n    function liquidateBorrow(address borrower, address cTokenCollateral) external virtual payable;\\n\\n    function exchangeRateCurrent() external virtual returns (uint256);\\n\\n    function supplyRatePerBlock() external virtual returns (uint256);\\n\\n    function borrowRatePerBlock() external virtual returns (uint256);\\n\\n    function totalReserves() external virtual returns (uint256);\\n\\n    function reserveFactorMantissa() external virtual returns (uint256);\\n\\n    function borrowBalanceCurrent(address account) external virtual returns (uint256);\\n\\n    function totalBorrowsCurrent() external virtual returns (uint256);\\n\\n    function getCash() external virtual returns (uint256);\\n\\n    function balanceOfUnderlying(address owner) external virtual returns (uint256);\\n\\n    function underlying() external virtual returns (address);\\n\\n    function getAccountSnapshot(address account) external virtual view returns (uint, uint, uint, uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILoanShifter.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract ILoanShifter {\\n    function getLoanAmount(uint, address) public virtual returns (uint);\\n    function getUnderlyingAsset(address _addr) public view virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Vat.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract Vat {\\n\\n    struct Urn {\\n        uint256 ink;   // Locked Collateral  [wad]\\n        uint256 art;   // Normalised Debt    [wad]\\n    }\\n\\n    struct Ilk {\\n        uint256 Art;   // Total Normalised Debt     [wad]\\n        uint256 rate;  // Accumulated Rates         [ray]\\n        uint256 spot;  // Price with Safety Margin  [ray]\\n        uint256 line;  // Debt Ceiling              [rad]\\n        uint256 dust;  // Urn Debt Floor            [rad]\\n    }\\n\\n    mapping (bytes32 => mapping (address => Urn )) public urns;\\n    mapping (bytes32 => Ilk)                       public ilks;\\n    mapping (bytes32 => mapping (address => uint)) public gem;  // [wad]\\n\\n    function can(address, address) virtual public view returns (uint);\\n    function dai(address) virtual public view returns (uint);\\n    function frob(bytes32, address, address, address, int, int) virtual public;\\n    function hope(address) virtual public;\\n    function move(address, address, uint) virtual public;\\n    function fork(bytes32, address, address, int, int) virtual public;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Manager.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract Manager {\\n    function last(address) virtual public returns (uint);\\n    function cdpCan(address, uint, address) virtual public view returns (uint);\\n    function ilks(uint) virtual public view returns (bytes32);\\n    function owns(uint) virtual public view returns (address);\\n    function urns(uint) virtual public view returns (address);\\n    function vat() virtual public view returns (address);\\n    function open(bytes32, address) virtual public returns (uint);\\n    function give(uint, address) virtual public;\\n    function cdpAllow(uint, address, uint) virtual public;\\n    function urnAllow(address, uint) virtual public;\\n    function frob(uint, int, int) virtual public;\\n    function flux(uint, address, uint) virtual public;\\n    function move(uint, address, uint) virtual public;\\n    function exit(address, uint, address, uint) virtual public;\\n    function quit(uint, address) virtual public;\\n    function enter(address, uint) virtual public;\\n    function shift(uint, uint) virtual public;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMCDSubscriptions.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract IMCDSubscriptions {\\n    function unsubscribe(uint256 _cdpId) external virtual ;\\n    function subscribersPos(uint256 _cdpId) external virtual returns (uint256, bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICompoundSubscriptions.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract ICompoundSubscriptions {\\n    function unsubscribe() external virtual ;\\n}\\n\"\r\n    },\r\n    \"contracts/auth/ProxyPermission.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../DS/DSGuard.sol\\\";\\nimport \\\"../DS/DSAuth.sol\\\";\\n\\ncontract ProxyPermission {\\n    address public constant FACTORY_ADDRESS = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;\\n\\n    /// @notice Called in the context of DSProxy to authorize an address\\n    /// @param _contractAddr Address which will be authorized\\n    function givePermission(address _contractAddr) public {\\n        address currAuthority = address(DSAuth(address(this)).authority());\\n        DSGuard guard = DSGuard(currAuthority);\\n\\n        if (currAuthority == address(0)) {\\n            guard = DSGuardFactory(FACTORY_ADDRESS).newGuard();\\n            DSAuth(address(this)).setAuthority(DSAuthority(address(guard)));\\n        }\\n\\n        guard.permit(_contractAddr, address(this), bytes4(keccak256(\\\"execute(address,bytes)\\\")));\\n    }\\n\\n    /// @notice Called in the context of DSProxy to remove authority of an address\\n    /// @param _contractAddr Auth address which will be removed from authority list\\n    function removePermission(address _contractAddr) public {\\n        address currAuthority = address(DSAuth(address(this)).authority());\\n        \\n        // if there is no authority, that means that contract doesn't have permission\\n        if (currAuthority == address(0)) {\\n            return;\\n        }\\n\\n        DSGuard guard = DSGuard(currAuthority);\\n        guard.forbid(_contractAddr, address(this), bytes4(keccak256(\\\"execute(address,bytes)\\\")));\\n    }\\n\\n    function proxyOwner() internal returns(address) {\\n        return DSAuth(address(this)).owner();\\n    } \\n}\\n\"\r\n    },\r\n    \"contracts/exchangeV3/DFSExchangeData.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\ncontract DFSExchangeData {\\n\\n    // first is empty to keep the legacy order in place\\n    enum ExchangeType { _, OASIS, KYBER, UNISWAP, ZEROX }\\n\\n    enum ActionType { SELL, BUY }\\n\\n    struct OffchainData {\\n        address wrapper;\\n        address exchangeAddr;\\n        address allowanceTarget;\\n        uint256 price;\\n        uint256 protocolFee;\\n        bytes callData;\\n    }\\n\\n    struct ExchangeData {\\n        address srcAddr;\\n        address destAddr;\\n        uint256 srcAmount;\\n        uint256 destAmount;\\n        uint256 minPrice;\\n        uint256 dfsFeeDivider; // service fee divider\\n        address user; // user to check special fee\\n        address wrapper;\\n        bytes wrapperData;\\n        OffchainData offchainData;\\n    }\\n\\n    function packExchangeData(ExchangeData memory _exData) public pure returns(bytes memory) {\\n        return abi.encode(_exData);\\n    }\\n\\n    function unpackExchangeData(bytes memory _data) public pure returns(ExchangeData memory _exData) {\\n        _exData = abi.decode(_data, (ExchangeData));\\n    }\\n}\"\r\n    },\r\n    \"contracts/shifter/ShifterRegistry.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../auth/AdminAuth.sol\\\";\\n\\ncontract ShifterRegistry is AdminAuth {\\n    mapping (string => address) public contractAddresses;\\n    bool public finalized;\\n\\n    function changeContractAddr(string memory _contractName, address _protoAddr) public onlyOwner {\\n        require(!finalized);\\n        contractAddresses[_contractName] = _protoAddr;\\n    }\\n\\n    function lock() public onlyOwner {\\n        finalized = true;\\n    }\\n\\n    function getAddr(string memory _contractName) public view returns (address contractAddr) {\\n        contractAddr = contractAddresses[_contractName];\\n\\n        require(contractAddr != address(0), \\\"No contract address registred\\\");\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/loggers/DefisaverLogger.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ncontract DefisaverLogger {\\n    event LogEvent(\\n        address indexed contractAddress,\\n        address indexed caller,\\n        string indexed logName,\\n        bytes data\\n    );\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function Log(address _contract, address _caller, string memory _logName, bytes memory _data)\\n        public\\n    {\\n        emit LogEvent(_contract, _caller, _logName, _data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DS/DSGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\nabstract contract DSGuard {\\n    function canCall(address src_, address dst_, bytes4 sig) public view virtual returns (bool);\\n\\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\\n\\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\\n\\n    function permit(address src, address dst, bytes32 sig) public virtual;\\n\\n    function forbid(address src, address dst, bytes32 sig) public virtual;\\n}\\n\\n\\nabstract contract DSGuardFactory {\\n    function newGuard() public virtual returns (DSGuard guard);\\n}\\n\"\r\n    },\r\n    \"contracts/DS/DSAuth.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./DSAuthority.sol\\\";\\n\\n\\ncontract DSAuthEvents {\\n    event LogSetAuthority(address indexed authority);\\n    event LogSetOwner(address indexed owner);\\n}\\n\\n\\ncontract DSAuth is DSAuthEvents {\\n    DSAuthority public authority;\\n    address public owner;\\n\\n    constructor() public {\\n        owner = msg.sender;\\n        emit LogSetOwner(msg.sender);\\n    }\\n\\n    function setOwner(address owner_) public auth {\\n        owner = owner_;\\n        emit LogSetOwner(owner);\\n    }\\n\\n    function setAuthority(DSAuthority authority_) public auth {\\n        authority = authority_;\\n        emit LogSetAuthority(address(authority));\\n    }\\n\\n    modifier auth {\\n        require(isAuthorized(msg.sender, msg.sig));\\n        _;\\n    }\\n\\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\\n        if (src == address(this)) {\\n            return true;\\n        } else if (src == owner) {\\n            return true;\\n        } else if (authority == DSAuthority(0)) {\\n            return false;\\n        } else {\\n            return authority.canCall(src, address(this), sig);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DS/DSAuthority.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\nabstract contract DSAuthority {\\n    function canCall(address src, address dst, bytes4 sig) public virtual view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/reflexer/saver/RAISaverProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../utils/Discount.sol\\\";\\n\\nimport \\\"../../interfaces/reflexer/IOracleRelayer.sol\\\";\\nimport \\\"../../interfaces/reflexer/ITaxCollector.sol\\\";\\nimport \\\"../../interfaces/reflexer/ICoinJoin.sol\\\";\\n\\nimport \\\"./RAISaverProxyHelper.sol\\\";\\nimport \\\"../../utils/BotRegistry.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeCore.sol\\\";\\n\\n/// @title Implements Boost and Repay for Reflexer Safes\\ncontract RAISaverProxy is DFSExchangeCore, RAISaverProxyHelper {\\n\\n    uint public constant MANUAL_SERVICE_FEE = 400; // 0.25% Fee\\n    uint public constant AUTOMATIC_SERVICE_FEE = 333; // 0.3% Fee\\n\\n    bytes32 public constant ETH_COLL_TYPE = 0x4554482d41000000000000000000000000000000000000000000000000000000;\\n\\n    address public constant SAFE_ENGINE_ADDRESS = 0xCC88a9d330da1133Df3A7bD823B95e52511A6962;\\n    address public constant ORACLE_RELAYER_ADDRESS = 0x4ed9C0dCa0479bC64d8f4EB3007126D5791f7851;\\n    address public constant RAI_JOIN_ADDRESS = 0x0A5653CCa4DB1B6E265F47CAf6969e64f1CFdC45;\\n    address public constant TAX_COLLECTOR_ADDRESS = 0xcDB05aEda142a1B0D6044C09C64e4226c1a281EB;\\n    address public constant RAI_ADDRESS = 0x03ab458634910AaD20eF5f1C8ee96F1D6ac54919;\\n\\n    address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;\\n\\n    ISAFEEngine public constant safeEngine = ISAFEEngine(SAFE_ENGINE_ADDRESS);\\n    ICoinJoin public constant raiJoin = ICoinJoin(RAI_JOIN_ADDRESS);\\n    IOracleRelayer public constant oracleRelayer = IOracleRelayer(ORACLE_RELAYER_ADDRESS);\\n\\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\\n\\n    /// @notice Repay - draws collateral, converts to Rai and repays the debt\\n    /// @dev Must be called by the DSProxy contract that owns the Safe\\n    function repay(\\n        ExchangeData memory _exchangeData,\\n        uint _safeId,\\n        uint _gasCost,\\n        address _joinAddr,\\n        ManagerType _managerType\\n    ) public payable {\\n\\n        address managerAddr = getManagerAddr(_managerType);\\n\\n        address user = getOwner(ISAFEManager(managerAddr), _safeId);\\n        bytes32 ilk = ISAFEManager(managerAddr).collateralTypes(_safeId);\\n\\n        drawCollateral(managerAddr, _safeId, _joinAddr, _exchangeData.srcAmount, true);\\n\\n        _exchangeData.user = user;\\n        _exchangeData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\\n        (, uint raiAmount) = _sell(_exchangeData);\\n\\n        raiAmount -= takeFee(_gasCost, raiAmount);\\n\\n        paybackDebt(managerAddr, _safeId, ilk, raiAmount, user);\\n\\n        // if there is some eth left (0x fee), return it to user\\n        if (address(this).balance > 0) {\\n            tx.origin.transfer(address(this).balance);\\n        }\\n\\n        logger.Log(address(this), msg.sender, \\\"RAIRepay\\\", abi.encode(_safeId, user, _exchangeData.srcAmount, raiAmount));\\n\\n    }\\n\\n    /// @notice Boost - draws Rai, converts to collateral and adds to Safe\\n    /// @dev Must be called by the DSProxy contract that owns the Safe\\n    function boost(\\n        ExchangeData memory _exchangeData,\\n        uint _safeId,\\n        uint _gasCost,\\n        address _joinAddr,\\n        ManagerType _managerType\\n    ) public payable {\\n\\n        address managerAddr = getManagerAddr(_managerType);\\n\\n        address user = getOwner(ISAFEManager(managerAddr), _safeId);\\n        bytes32 ilk = ISAFEManager(managerAddr).collateralTypes(_safeId);\\n\\n        uint raiDrawn = drawRai(managerAddr, _safeId, ilk, _exchangeData.srcAmount);\\n\\n        _exchangeData.user = user;\\n        _exchangeData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\\n        _exchangeData.srcAmount = raiDrawn - takeFee(_gasCost, raiDrawn);\\n        (, uint swapedColl) = _sell(_exchangeData);\\n\\n        addCollateral(managerAddr, _safeId, _joinAddr, swapedColl, true);\\n\\n        // if there is some eth left (0x fee), return it to user\\n        if (address(this).balance > 0) {\\n            tx.origin.transfer(address(this).balance);\\n        }\\n\\n        logger.Log(address(this), msg.sender, \\\"RAIBoost\\\", abi.encode(_safeId, user, _exchangeData.srcAmount, swapedColl));\\n    }\\n\\n    /// @notice Draws Rai from the Safe\\n    /// @dev If _raiAmount is bigger than max available we'll draw max\\n    /// @param _managerAddr Address of the Safe Manager\\n    /// @param _safeId Id of the Safe\\n    /// @param _collType Coll type of the Safe\\n    /// @param _raiAmount Amount of Rai to draw\\n    function drawRai(address _managerAddr, uint _safeId, bytes32 _collType, uint _raiAmount) internal returns (uint) {\\n        uint rate = ITaxCollector(TAX_COLLECTOR_ADDRESS).taxSingle(_collType);\\n        uint raiVatBalance = safeEngine.coinBalance(ISAFEManager(_managerAddr).safes(_safeId));\\n\\n        uint maxAmount = getMaxDebt(_managerAddr, _safeId, _collType);\\n\\n        if (_raiAmount >= maxAmount) {\\n            _raiAmount = sub(maxAmount, 1);\\n        }\\n\\n        ISAFEManager(_managerAddr).modifySAFECollateralization(_safeId, int(0), normalizeDrawAmount(_raiAmount, rate, raiVatBalance));\\n        ISAFEManager(_managerAddr).transferInternalCoins(_safeId, address(this), toRad(_raiAmount));\\n\\n        if (safeEngine.safeRights(address(this), address(RAI_JOIN_ADDRESS)) == 0) {\\n            safeEngine.approveSAFEModification(RAI_JOIN_ADDRESS);\\n        }\\n\\n        ICoinJoin(RAI_JOIN_ADDRESS).exit(address(this), _raiAmount);\\n\\n        return _raiAmount;\\n    }\\n\\n    /// @notice Adds collateral to the Safe\\n    /// @param _managerAddr Address of the Safe Manager\\n    /// @param _safeId Id of the Safe\\n    /// @param _joinAddr Address of the join contract for the Safe collateral\\n    /// @param _amount Amount of collateral to add\\n    /// @param _toWeth Should we convert to Weth\\n    function addCollateral(address _managerAddr, uint _safeId, address _joinAddr, uint _amount, bool _toWeth) internal {\\n        int convertAmount = 0;\\n\\n        if (isEthJoinAddr(_joinAddr) && _toWeth) {\\n            TokenInterface(IBasicTokenAdapters(_joinAddr).collateral()).deposit{value: _amount}();\\n            convertAmount = toPositiveInt(_amount);\\n        } else {\\n            convertAmount = toPositiveInt(convertTo18(_joinAddr, _amount));\\n        }\\n\\n        ERC20(address(IBasicTokenAdapters(_joinAddr).collateral())).safeApprove(_joinAddr, _amount);\\n\\n        IBasicTokenAdapters(_joinAddr).join(address(this), _amount);\\n\\n        safeEngine.modifySAFECollateralization(\\n            ISAFEManager(_managerAddr).collateralTypes(_safeId),\\n            ISAFEManager(_managerAddr).safes(_safeId),\\n            address(this),\\n            address(this),\\n            convertAmount,\\n            0\\n        );\\n\\n    }\\n\\n    /// @notice Draws collateral and returns it to DSProxy\\n    /// @param _managerAddr Address of the Safe Manager\\n    /// @dev If _amount is bigger than max available we'll draw max\\n    /// @param _safeId Id of the Safe\\n    /// @param _joinAddr Address of the join contract for the Safe collateral\\n    /// @param _amount Amount of collateral to draw\\n    /// @param _toEth Boolean if we should unwrap Ether\\n    function drawCollateral(address _managerAddr, uint _safeId, address _joinAddr, uint _amount, bool _toEth) internal returns (uint) {\\n        uint frobAmount = _amount;\\n\\n        if (IBasicTokenAdapters(_joinAddr).decimals() != 18) {\\n            frobAmount = _amount * (10 ** (18 - IBasicTokenAdapters(_joinAddr).decimals()));\\n        }\\n\\n        ISAFEManager(_managerAddr).modifySAFECollateralization(_safeId, -toPositiveInt(frobAmount), 0);\\n        ISAFEManager(_managerAddr).transferCollateral(_safeId, address(this), frobAmount);\\n\\n        IBasicTokenAdapters(_joinAddr).exit(address(this), _amount);\\n\\n        if (isEthJoinAddr(_joinAddr) && _toEth) {\\n            TokenInterface(IBasicTokenAdapters(_joinAddr).collateral()).withdraw(_amount); // Weth -> Eth\\n        }\\n\\n        return _amount;\\n    }\\n\\n    /// @notice Paybacks Rai debt\\n    /// @param _managerAddr Address of the Safe Manager\\n    /// @dev If the _raiAmount is bigger than the whole debt, returns extra Rai\\n    /// @param _safeId Id of the Safe\\n    /// @param _collType Coll type of the Safe\\n    /// @param _raiAmount Amount of Rai to payback\\n    /// @param _owner Address that owns the DSProxy that owns the Safe\\n    function paybackDebt(address _managerAddr, uint _safeId, bytes32 _collType, uint _raiAmount, address _owner) internal {\\n        address urn = ISAFEManager(_managerAddr).safes(_safeId);\\n\\n        uint wholeDebt = getAllDebt(SAFE_ENGINE_ADDRESS, urn, urn, _collType);\\n\\n        if (_raiAmount > wholeDebt) {\\n            ERC20(RAI_ADDRESS).transfer(_owner, sub(_raiAmount, wholeDebt));\\n            _raiAmount = wholeDebt;\\n        }\\n\\n        if (ERC20(RAI_ADDRESS).allowance(address(this), RAI_JOIN_ADDRESS) == 0) {\\n            ERC20(RAI_ADDRESS).approve(RAI_JOIN_ADDRESS, uint(-1));\\n        }\\n\\n        raiJoin.join(urn, _raiAmount);\\n\\n        int paybackAmnt = _getRepaidDeltaDebt(SAFE_ENGINE_ADDRESS, ISAFEEngine(safeEngine).coinBalance(urn), urn, _collType);\\n\\n        ISAFEManager(_managerAddr).modifySAFECollateralization(_safeId, 0, paybackAmnt);\\n    }\\n\\n    /// @notice Gets the maximum amount of collateral available to draw\\n    /// @param _managerAddr Address of the Safe Manager\\n    /// @param _safeId Id of the Safe\\n    /// @param _collType Coll type of the Safe\\n    /// @param _joinAddr Joind address of collateral\\n    /// @dev Substracts 1% to aviod rounding error later on\\n    function getMaxCollateral(address _managerAddr, uint _safeId, bytes32 _collType, address _joinAddr) public view returns (uint) {\\n        (uint collateral, uint debt) = getSafeInfo(ISAFEManager(_managerAddr), _safeId, _collType);\\n\\n        (, , uint256 safetyPrice, , , ) =\\n            ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);\\n\\n        uint maxCollateral = sub(collateral, wmul(wdiv(RAY, safetyPrice), debt));\\n\\n        uint normalizeMaxCollateral = maxCollateral / (10 ** (18 - IBasicTokenAdapters(_joinAddr).decimals()));\\n\\n        // take one percent due to precision issues\\n        return normalizeMaxCollateral * 99 / 100;\\n    }\\n\\n    /// @notice Gets the maximum amount of debt available to generate\\n    /// @param _managerAddr Address of the Safe Manager\\n    /// @param _safeId Id of the Safe\\n    /// @param _collType Coll type of the Safe\\n    /// @dev Substracts 10 wei to aviod rounding error later on\\n    function getMaxDebt(\\n        address _managerAddr,\\n        uint256 _safeId,\\n        bytes32 _collType\\n    ) public view virtual returns (uint256) {\\n        (uint256 collateral, uint256 debt) =\\n            getSafeInfo(ISAFEManager(_managerAddr), _safeId, _collType);\\n\\n        (, , uint256 safetyPrice, , , ) =\\n            ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);\\n\\n        return sub(sub(rmul(collateral, safetyPrice), debt), 10);\\n    }\\n\\n    function getPrice(bytes32 _collType) public returns (uint256) {\\n        (, uint256 safetyCRatio) =\\n            IOracleRelayer(ORACLE_RELAYER_ADDRESS).collateralTypes(_collType);\\n        (, , uint256 safetyPrice, , , ) =\\n            ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);\\n\\n        uint256 redemptionPrice = IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionPrice();\\n\\n        return rmul(rmul(safetyPrice, redemptionPrice), safetyCRatio);\\n    }\\n\\n    function isAutomation() internal view returns(bool) {\\n        return BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin);\\n    }\\n\\n    function takeFee(uint256 _gasCost, uint _amount) internal returns(uint) {\\n        if (_gasCost > 0) {\\n            uint ethRaiPrice = getPrice(ETH_COLL_TYPE);\\n            uint feeAmount = rmul(_gasCost, ethRaiPrice);\\n\\n            if (feeAmount > _amount / 5) {\\n                feeAmount = _amount / 5;\\n            }\\n\\n            address walletAddr = _feeRecipient.getFeeAddr();\\n\\n            ERC20(RAI_ADDRESS).transfer(walletAddr, feeAmount);\\n\\n            return feeAmount;\\n        }\\n\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Discount.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\ncontract Discount {\\n    address public owner;\\n    mapping(address => CustomServiceFee) public serviceFees;\\n\\n    uint256 constant MAX_SERVICE_FEE = 400;\\n\\n    struct CustomServiceFee {\\n        bool active;\\n        uint256 amount;\\n    }\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    function isCustomFeeSet(address _user) public view returns (bool) {\\n        return serviceFees[_user].active;\\n    }\\n\\n    function getCustomServiceFee(address _user) public view returns (uint256) {\\n        return serviceFees[_user].amount;\\n    }\\n\\n    function setServiceFee(address _user, uint256 _fee) public {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        require(_fee >= MAX_SERVICE_FEE || _fee == 0);\\n\\n        serviceFees[_user] = CustomServiceFee({active: true, amount: _fee});\\n    }\\n\\n    function disableServiceFee(address _user) public {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n\\n        serviceFees[_user] = CustomServiceFee({active: false, amount: 0});\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/reflexer/IOracleRelayer.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract IOracleRelayer {\\n    struct CollateralType {\\n        address orcl;\\n        uint256 safetyCRatio;\\n    }\\n\\n    mapping (bytes32 => CollateralType) public collateralTypes;\\n\\n    function redemptionPrice() public virtual returns (uint256);\\n    uint256 public redemptionRate;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/reflexer/ITaxCollector.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract ITaxCollector {\\n    struct CollateralType {\\n        uint256 stabilityFee;\\n        uint256 updateTime;\\n    }\\n\\n    mapping (bytes32 => CollateralType) public collateralTypes;\\n\\n    function taxSingle(bytes32) public virtual returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/reflexer/ICoinJoin.sol\": {\r\n      \"content\": \"\\npragma solidity ^0.6.0;\\n\\nabstract contract ICoinJoin {\\n    uint256 public decimals;\\n\\n    function join(address account, uint256 wad) external virtual;\\n\\n    function exit(address account, uint256 wad) external virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/reflexer/saver/RAISaverProxyHelper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../DS/DSProxy.sol\\\";\\nimport \\\"../../interfaces/reflexer/IBasicTokenAdapters.sol\\\";\\nimport \\\"../../interfaces/reflexer/ISAFEManager.sol\\\";\\nimport \\\"../../interfaces/reflexer/ISAFEEngine.sol\\\";\\nimport \\\"../../interfaces/reflexer/ITaxCollector.sol\\\";\\n\\n/// @title Helper methods for RAISaverProxy\\ncontract RAISaverProxyHelper is DSMath {\\n\\n    enum ManagerType { RAI }\\n\\n    /// @notice Returns a normalized debt _amount based on the current rate\\n    /// @param _amount Amount of dai to be normalized\\n    /// @param _rate Current rate of the stability fee\\n    /// @param _daiVatBalance Balance od Dai in the Vat for that Safe\\n    function normalizeDrawAmount(uint _amount, uint _rate, uint _daiVatBalance) internal pure returns (int dart) {\\n        if (_daiVatBalance < mul(_amount, RAY)) {\\n            dart = toPositiveInt(sub(mul(_amount, RAY), _daiVatBalance) / _rate);\\n            dart = mul(uint(dart), _rate) < mul(_amount, RAY) ? dart + 1 : dart;\\n        }\\n    }\\n\\n    /// @notice Converts a number to Rad percision\\n    /// @param _wad The input number in wad percision\\n    function toRad(uint _wad) internal pure returns (uint) {\\n        return mul(_wad, 10 ** 27);\\n    }\\n\\n    /// @notice Converts a number to 18 decimal percision\\n    /// @param _joinAddr Join address of the collateral\\n    /// @param _amount Number to be converted\\n    function convertTo18(address _joinAddr, uint256 _amount) internal view returns (uint256) {\\n        return mul(_amount, 10 ** (18 - IBasicTokenAdapters(_joinAddr).decimals()));\\n    }\\n\\n    /// @notice Converts a uint to int and checks if positive\\n    /// @param _x Number to be converted\\n    function toPositiveInt(uint _x) internal pure returns (int y) {\\n        y = int(_x);\\n        require(y >= 0, \\\"int-overflow\\\");\\n    }\\n\\n    /// @notice Gets Dai amount in Vat which can be added to Safe\\n    /// @param _safeEngine Address of Vat contract\\n    /// @param _urn Urn of the Safe\\n    /// @param _collType CollType of the Safe\\n    function normalizePaybackAmount(address _safeEngine, address _urn, bytes32 _collType) internal view returns (int amount) {\\n        uint dai = ISAFEEngine(_safeEngine).coinBalance(_urn);\\n\\n        (, uint rate,,,,) = ISAFEEngine(_safeEngine).collateralTypes(_collType);\\n        (, uint art) = ISAFEEngine(_safeEngine).safes(_collType, _urn);\\n\\n        amount = toPositiveInt(dai / rate);\\n        amount = uint(amount) <= art ? - amount : - toPositiveInt(art);\\n    }\\n\\n    /// @notice Gets delta debt generated (Total Safe debt minus available safeHandler COIN balance)\\n    /// @param safeEngine address\\n    /// @param taxCollector address\\n    /// @param safeHandler address\\n    /// @param collateralType bytes32\\n    /// @return deltaDebt\\n    function _getGeneratedDeltaDebt(\\n        address safeEngine,\\n        address taxCollector,\\n        address safeHandler,\\n        bytes32 collateralType,\\n        uint wad\\n    ) internal returns (int deltaDebt) {\\n        // Updates stability fee rate\\n        uint rate = ITaxCollector(taxCollector).taxSingle(collateralType);\\n        require(rate > 0, \\\"invalid-collateral-type\\\");\\n\\n        // Gets COIN balance of the handler in the safeEngine\\n        uint coin = ISAFEEngine(safeEngine).coinBalance(safeHandler);\\n\\n        // If there was already enough COIN in the safeEngine balance, just exits it without adding more debt\\n        if (coin < mul(wad, RAY)) {\\n            // Calculates the needed deltaDebt so together with the existing coins in the safeEngine is enough to exit wad amount of COIN tokens\\n            deltaDebt = toPositiveInt(sub(mul(wad, RAY), coin) / rate);\\n            // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given COIN wad amount)\\n            deltaDebt = mul(uint(deltaDebt), rate) < mul(wad, RAY) ? deltaDebt + 1 : deltaDebt;\\n        }\\n    }\\n\\n    function _getRepaidDeltaDebt(\\n        address safeEngine,\\n        uint coin,\\n        address safe,\\n        bytes32 collateralType\\n    ) internal view returns (int deltaDebt) {\\n        // Gets actual rate from the safeEngine\\n        (, uint rate,,,,) = ISAFEEngine(safeEngine).collateralTypes(collateralType);\\n        require(rate > 0, \\\"invalid-collateral-type\\\");\\n\\n        // Gets actual generatedDebt value of the safe\\n        (, uint generatedDebt) = ISAFEEngine(safeEngine).safes(collateralType, safe);\\n\\n        // Uses the whole coin balance in the safeEngine to reduce the debt\\n        deltaDebt = toPositiveInt(coin / rate);\\n        // Checks the calculated deltaDebt is not higher than safe.generatedDebt (total debt), otherwise uses its value\\n        deltaDebt = uint(deltaDebt) <= generatedDebt ? - deltaDebt : - toPositiveInt(generatedDebt);\\n    }\\n\\n    /// @notice Gets the whole debt of the Safe\\n    /// @param _safeEngine Address of Vat contract\\n    /// @param _usr Address of the Dai holder\\n    /// @param _urn Urn of the Safe\\n    /// @param _collType CollType of the Safe\\n    function getAllDebt(address _safeEngine, address _usr, address _urn, bytes32 _collType) internal view returns (uint daiAmount) {\\n        (, uint rate,,,,) = ISAFEEngine(_safeEngine).collateralTypes(_collType);\\n        (, uint art) = ISAFEEngine(_safeEngine).safes(_collType, _urn);\\n        uint dai = ISAFEEngine(_safeEngine).coinBalance(_usr);\\n\\n        uint rad = sub(mul(art, rate), dai);\\n        daiAmount = rad / RAY;\\n\\n        daiAmount = mul(daiAmount, RAY) < rad ? daiAmount + 1 : daiAmount;\\n    }\\n\\n    /// @notice Gets the token address from the Join contract\\n    /// @param _joinAddr Address of the Join contract\\n    function getCollateralAddr(address _joinAddr) internal view returns (address) {\\n        return address(IBasicTokenAdapters(_joinAddr).collateral());\\n    }\\n\\n    /// @notice Checks if the join address is one of the Ether coll. types\\n    /// @param _joinAddr Join address to check\\n    function isEthJoinAddr(address _joinAddr) internal view returns (bool) {\\n        // if it's dai_join_addr don't check gem() it will fail\\n        if (_joinAddr == 0x0A5653CCa4DB1B6E265F47CAf6969e64f1CFdC45) return false;\\n\\n        // if coll is weth it's and eth type coll\\n        if (address(IBasicTokenAdapters(_joinAddr).collateral()) == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Gets Safe info (collateral, debt)\\n    /// @param _manager Manager contract\\n    /// @param _safeId Id of the Safe\\n    /// @param _collType CollType of the Safe\\n    function getSafeInfo(ISAFEManager _manager, uint _safeId, bytes32 _collType) public view returns (uint, uint) {\\n        address vat = _manager.safeEngine();\\n        address urn = _manager.safes(_safeId);\\n\\n        (uint collateral, uint debt) = ISAFEEngine(vat).safes(_collType, urn);\\n        (,uint rate,,,,) = ISAFEEngine(vat).collateralTypes(_collType);\\n\\n        return (collateral, rmul(debt, rate));\\n    }\\n\\n    /// @notice Address that owns the DSProxy that owns the Safe\\n    /// @param _manager Manager contract\\n    /// @param _safeId Id of the Safe\\n    function getOwner(ISAFEManager _manager, uint _safeId) public view returns (address) {\\n        DSProxy proxy = DSProxy(uint160(_manager.ownsSAFE(_safeId)));\\n\\n        return proxy.owner();\\n    }\\n\\n    /// @notice Based on the manager type returns the address\\n    /// @param _managerType Type of vault manager to use\\n    function getManagerAddr(ManagerType _managerType) public pure returns (address) {\\n        if (_managerType == ManagerType.RAI) {\\n            return 0xEfe0B4cA532769a3AE758fD82E1426a03A94F185;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/BotRegistry.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../auth/AdminAuth.sol\\\";\\n\\ncontract BotRegistry is AdminAuth {\\n\\n    mapping (address => bool) public botList;\\n\\n    constructor() public {\\n        botList[0x776B4a13093e30B05781F97F6A4565B6aa8BE330] = true;\\n\\n        botList[0xAED662abcC4FA3314985E67Ea993CAD064a7F5cF] = true;\\n        botList[0xa5d330F6619d6bF892A5B87D80272e1607b3e34D] = true;\\n        botList[0x5feB4DeE5150B589a7f567EA7CADa2759794A90A] = true;\\n        botList[0x7ca06417c1d6f480d3bB195B80692F95A6B66158] = true;\\n    }\\n\\n    function setBot(address _botAddr, bool _state) public onlyOwner {\\n        botList[_botAddr] = _state;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/exchangeV3/DFSExchangeCore.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../DS/DSMath.sol\\\";\\nimport \\\"../interfaces/TokenInterface.sol\\\";\\nimport \\\"../interfaces/ExchangeInterfaceV3.sol\\\";\\nimport \\\"../utils/ZrxAllowlist.sol\\\";\\nimport \\\"./DFSExchangeData.sol\\\";\\nimport \\\"./DFSExchangeHelper.sol\\\";\\nimport \\\"../exchange/SaverExchangeRegistry.sol\\\";\\nimport \\\"../interfaces/OffchainWrapperInterface.sol\\\";\\n\\ncontract DFSExchangeCore is DFSExchangeHelper, DSMath, DFSExchangeData {\\n\\n    string public constant ERR_SLIPPAGE_HIT = \\\"Slippage hit\\\";\\n    string public constant ERR_DEST_AMOUNT_MISSING = \\\"Dest amount missing\\\";\\n    string public constant ERR_WRAPPER_INVALID = \\\"Wrapper invalid\\\";\\n    string public constant ERR_NOT_ZEROX_EXCHANGE = \\\"Zerox exchange invalid\\\";\\n\\n    /// @notice Internal method that preforms a sell on 0x/on-chain\\n    /// @dev Usefull for other DFS contract to integrate for exchanging\\n    /// @param exData Exchange data struct\\n    /// @return (address, uint) Address of the wrapper used and destAmount\\n    function _sell(ExchangeData memory exData) internal returns (address, uint) {\\n\\n        address wrapper;\\n        uint swapedTokens;\\n        bool success;\\n\\n        // if selling eth, convert to weth\\n        if (exData.srcAddr == KYBER_ETH_ADDRESS) {\\n            exData.srcAddr = ethToWethAddr(exData.srcAddr);\\n            TokenInterface(EXCHANGE_WETH_ADDRESS).deposit{value: exData.srcAmount}();\\n        }\\n\\n        exData.srcAmount -= getFee(exData.srcAmount, exData.user, exData.srcAddr, exData.dfsFeeDivider);\\n\\n        // Try 0x first and then fallback on specific wrapper\\n        if (exData.offchainData.price > 0) {\\n            (success, swapedTokens) = takeOrder(exData, ActionType.SELL);\\n\\n            if (success) {\\n                wrapper = exData.offchainData.exchangeAddr;\\n            }\\n        }\\n\\n        // fallback to desired wrapper if 0x failed\\n        if (!success) {\\n            swapedTokens = saverSwap(exData, ActionType.SELL);\\n            wrapper = exData.wrapper;\\n        }\\n\\n        // if anything is left in weth, pull it to user as eth\\n        if (getBalance(EXCHANGE_WETH_ADDRESS) > 0) {\\n            TokenInterface(EXCHANGE_WETH_ADDRESS).withdraw(\\n                TokenInterface(EXCHANGE_WETH_ADDRESS).balanceOf(address(this))\\n            );\\n        }\\n\\n        if (exData.destAddr == EXCHANGE_WETH_ADDRESS) {\\n            require(getBalance(KYBER_ETH_ADDRESS) >= wmul(exData.minPrice, exData.srcAmount), ERR_SLIPPAGE_HIT);\\n        } else {\\n            require(getBalance(exData.destAddr) >= wmul(exData.minPrice, exData.srcAmount), ERR_SLIPPAGE_HIT);\\n        }\\n\\n        return (wrapper, swapedTokens);\\n    }\\n\\n    /// @notice Internal method that preforms a buy on 0x/on-chain\\n    /// @dev Usefull for other DFS contract to integrate for exchanging\\n    /// @param exData Exchange data struct\\n    /// @return (address, uint) Address of the wrapper used and srcAmount\\n    function _buy(ExchangeData memory exData) internal returns (address, uint) {\\n\\n        address wrapper;\\n        uint swapedTokens;\\n        bool success;\\n\\n        require(exData.destAmount != 0, ERR_DEST_AMOUNT_MISSING);\\n\\n        exData.srcAmount -= getFee(exData.srcAmount, exData.user, exData.srcAddr, exData.dfsFeeDivider);\\n\\n        // if selling eth, convert to weth\\n        if (exData.srcAddr == KYBER_ETH_ADDRESS) {\\n            exData.srcAddr = ethToWethAddr(exData.srcAddr);\\n            TokenInterface(EXCHANGE_WETH_ADDRESS).deposit{value: exData.srcAmount}();\\n        }\\n\\n        if (exData.offchainData.price > 0) {\\n            (success, swapedTokens) = takeOrder(exData, ActionType.BUY);\\n\\n            if (success) {\\n                wrapper = exData.offchainData.exchangeAddr;\\n            }\\n        }\\n\\n        // fallback to desired wrapper if 0x failed\\n        if (!success) {\\n            swapedTokens = saverSwap(exData, ActionType.BUY);\\n            wrapper = exData.wrapper;\\n        }\\n\\n        // if anything is left in weth, pull it to user as eth\\n        if (getBalance(EXCHANGE_WETH_ADDRESS) > 0) {\\n            TokenInterface(EXCHANGE_WETH_ADDRESS).withdraw(\\n                TokenInterface(EXCHANGE_WETH_ADDRESS).balanceOf(address(this))\\n            );\\n        }\\n\\n        if (exData.destAddr == EXCHANGE_WETH_ADDRESS) {\\n            require(getBalance(KYBER_ETH_ADDRESS) >= exData.destAmount, ERR_SLIPPAGE_HIT);\\n        } else {\\n            require(getBalance(exData.destAddr) >= exData.destAmount, ERR_SLIPPAGE_HIT);\\n        }\\n\\n        return (wrapper, getBalance(exData.destAddr));\\n    }\\n\\n    /// @notice Takes order from 0x and returns bool indicating if it is successful\\n    /// @param _exData Exchange data\\n    function takeOrder(\\n        ExchangeData memory _exData,\\n        ActionType _type\\n    ) private returns (bool success, uint256) {\\n        if (!ZrxAllowlist(ZRX_ALLOWLIST_ADDR).isZrxAddr(_exData.offchainData.exchangeAddr)) {\\n            return (false, 0);\\n        }\\n\\n        if (!SaverExchangeRegistry(SAVER_EXCHANGE_REGISTRY).isWrapper(_exData.offchainData.wrapper)) {\\n            return (false, 0);\\n        }\\n\\n        // send src amount\\n        ERC20(_exData.srcAddr).safeTransfer(_exData.offchainData.wrapper, _exData.srcAmount);\\n\\n        return OffchainWrapperInterface(_exData.offchainData.wrapper).takeOrder{value: _exData.offchainData.protocolFee}(_exData, _type);\\n    }\\n\\n    /// @notice Calls wraper contract for exchage to preform an on-chain swap\\n    /// @param _exData Exchange data struct\\n    /// @param _type Type of action SELL|BUY\\n    /// @return swapedTokens For Sell that the destAmount, for Buy thats the srcAmount\\n    function saverSwap(ExchangeData memory _exData, ActionType _type) internal returns (uint swapedTokens) {\\n        require(SaverExchangeRegistry(SAVER_EXCHANGE_REGISTRY).isWrapper(_exData.wrapper), ERR_WRAPPER_INVALID);\\n\\n        ERC20(_exData.srcAddr).safeTransfer(_exData.wrapper, _exData.srcAmount);\\n\\n        if (_type == ActionType.SELL) {\\n            swapedTokens = ExchangeInterfaceV3(_exData.wrapper).\\n                    sell(_exData.srcAddr, _exData.destAddr, _exData.srcAmount, _exData.wrapperData);\\n        } else {\\n            swapedTokens = ExchangeInterfaceV3(_exData.wrapper).\\n                    buy(_exData.srcAddr, _exData.destAddr, _exData.destAmount, _exData.wrapperData);\\n        }\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external virtual payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/DS/DSMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\ncontract DSMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x);\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x);\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x);\\n    }\\n\\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x / y;\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    uint256 constant WAD = 10**18;\\n    uint256 constant RAY = 10**27;\\n\\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n\\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DS/DSProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./DSAuth.sol\\\";\\nimport \\\"./DSNote.sol\\\";\\n\\n\\nabstract contract DSProxy is DSAuth, DSNote {\\n    DSProxyCache public cache; // global cache for contracts\\n\\n    constructor(address _cacheAddr) public {\\n        require(setCache(_cacheAddr));\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external payable {}\\n\\n    // use the proxy to execute calldata _data on contract _code\\n    // function execute(bytes memory _code, bytes memory _data)\\n    //     public\\n    //     payable\\n    //     virtual\\n    //     returns (address target, bytes32 response);\\n\\n    function execute(address _target, bytes memory _data)\\n        public\\n        payable\\n        virtual\\n        returns (bytes32 response);\\n\\n    //set new cache\\n    function setCache(address _cacheAddr) public virtual payable returns (bool);\\n}\\n\\n\\ncontract DSProxyCache {\\n    mapping(bytes32 => address) cache;\\n\\n    function read(bytes memory _code) public view returns (address) {\\n        bytes32 hash = keccak256(_code);\\n        return cache[hash];\\n    }\\n\\n    function write(bytes memory _code) public returns (address target) {\\n        assembly {\\n            target := create(0, add(_code, 0x20), mload(_code))\\n            switch iszero(extcodesize(target))\\n                case 1 {\\n                    // throw if contract failed to deploy\\n                    revert(0, 0)\\n                }\\n        }\\n        bytes32 hash = keccak256(_code);\\n        cache[hash] = target;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/reflexer/IBasicTokenAdapters.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract IBasicTokenAdapters {\\n    bytes32 public collateralType;\\n\\n    function decimals() virtual public view returns (uint);\\n    function collateral() virtual public view returns (address);\\n    function join(address, uint) virtual public payable;\\n    function exit(address, uint) virtual public;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/reflexer/ISAFEManager.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract ISAFEManager {\\n\\n    function lastSAFEID(address) virtual public returns (uint);\\n    function safeCan(address, uint, address) virtual public view returns (uint);\\n    function collateralTypes(uint) virtual public view returns (bytes32);\\n    function ownsSAFE(uint) virtual public view returns (address);\\n    function safes(uint) virtual public view returns (address);\\n    function safeEngine() virtual public view returns (address);\\n    function openSAFE(bytes32, address) virtual public returns (uint);\\n    function transferSAFEOwnership(uint, address) virtual public;\\n    function allowSAFE(uint, address, uint) virtual public;\\n    function handlerAllowed(address, uint) virtual public;\\n    function modifySAFECollateralization(uint, int, int) virtual public;\\n    function transferCollateral(uint, address, uint) virtual public;\\n    function transferInternalCoins(uint, address, uint) virtual public;\\n    function quitSystem(uint, address) virtual public;\\n    function enterSystem(address, uint) virtual public;\\n    function moveSAFE(uint, uint) virtual public;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/reflexer/ISAFEEngine.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract ISAFEEngine {\\n\\n    struct SAFE {\\n        uint256 lockedCollateral;\\n        uint256 generatedDebt;\\n    }\\n\\n    struct CollateralType {\\n        // Total debt issued for this specific collateral type\\n        uint256 debtAmount;        // [wad]\\n        // Accumulator for interest accrued on this collateral type\\n        uint256 accumulatedRate;   // [ray]\\n        // Floor price at which a SAFE is allowed to generate debt\\n        uint256 safetyPrice;       // [ray]\\n        // Maximum amount of debt that can be generated with this collateral type\\n        uint256 debtCeiling;       // [rad]\\n        // Minimum amount of debt that must be generated by a SAFE using this collateral\\n        uint256 debtFloor;         // [rad]\\n        // Price at which a SAFE gets liquidated\\n        uint256 liquidationPrice;  // [ray]\\n    }\\n\\n    mapping (bytes32 => mapping (address => SAFE )) public safes;\\n    mapping (bytes32 => CollateralType) public collateralTypes;\\n    mapping (bytes32 => mapping (address => uint)) public tokenCollateral;\\n\\n    function safeRights(address, address) virtual public view returns (uint);\\n    function coinBalance(address) virtual public view returns (uint);\\n    function modifySAFECollateralization(bytes32, address, address, address, int, int) virtual public;\\n    function approveSAFEModification(address) virtual public;\\n    function transferInternalCoins(address, address, uint) virtual public;\\n    function transferSAFECollateralAndDebt(bytes32, address, address, int, int) virtual public;\\n}\\n\"\r\n    },\r\n    \"contracts/DS/DSNote.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\ncontract DSNote {\\n    event LogNote(\\n        bytes4 indexed sig,\\n        address indexed guy,\\n        bytes32 indexed foo,\\n        bytes32 indexed bar,\\n        uint256 wad,\\n        bytes fax\\n    ) anonymous;\\n\\n    modifier note {\\n        bytes32 foo;\\n        bytes32 bar;\\n\\n        assembly {\\n            foo := calldataload(4)\\n            bar := calldataload(36)\\n        }\\n\\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\\n\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/TokenInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract TokenInterface {\\n\\taddress public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    \\n    function allowance(address, address) public virtual returns (uint256);\\n\\n    function balanceOf(address) public virtual returns (uint256);\\n\\n    function approve(address, uint256) public virtual;\\n\\n    function transfer(address, uint256) public virtual returns (bool);\\n\\n    function transferFrom(address, address, uint256) public virtual returns (bool);\\n\\n    function deposit() public virtual payable;\\n\\n    function withdraw(uint256) public virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ExchangeInterfaceV3.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface ExchangeInterfaceV3 {\\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) external payable returns (uint);\\n\\n    function buy(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) external payable returns(uint);\\n\\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) external view returns (uint);\\n\\n    function getBuyRate(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ZrxAllowlist.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../auth/AdminAuth.sol\\\";\\n\\ncontract ZrxAllowlist is AdminAuth {\\n\\n    mapping (address => bool) public zrxAllowlist;\\n    mapping(address => bool) private nonPayableAddrs;\\n\\n    constructor() public {\\n        zrxAllowlist[0x6958F5e95332D93D21af0D7B9Ca85B8212fEE0A5] = true;\\n        zrxAllowlist[0x61935CbDd02287B511119DDb11Aeb42F1593b7Ef] = true;\\n        zrxAllowlist[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;\\n        zrxAllowlist[0x080bf510FCbF18b91105470639e9561022937712] = true;\\n\\n        nonPayableAddrs[0x080bf510FCbF18b91105470639e9561022937712] = true;\\n    }\\n\\n    function setAllowlistAddr(address _zrxAddr, bool _state) public onlyOwner {\\n        zrxAllowlist[_zrxAddr] = _state;\\n    }\\n\\n    function isZrxAddr(address _zrxAddr) public view returns (bool) {\\n        return zrxAllowlist[_zrxAddr];\\n    }\\n\\n    function addNonPayableAddr(address _nonPayableAddr) public onlyOwner {\\n\\t\\tnonPayableAddrs[_nonPayableAddr] = true;\\n\\t}\\n\\n\\tfunction removeNonPayableAddr(address _nonPayableAddr) public onlyOwner {\\n\\t\\tnonPayableAddrs[_nonPayableAddr] = false;\\n\\t}\\n\\n\\tfunction isNonPayableAddr(address _addr) public view returns(bool) {\\n\\t\\treturn nonPayableAddrs[_addr];\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/exchangeV3/DFSExchangeHelper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../utils/SafeERC20.sol\\\";\\nimport \\\"../utils/Discount.sol\\\";\\nimport \\\"../interfaces/IFeeRecipient.sol\\\";\\n\\ncontract DFSExchangeHelper {\\n\\n    string public constant ERR_OFFCHAIN_DATA_INVALID = \\\"Offchain data invalid\\\";\\n\\n    using SafeERC20 for ERC20;\\n\\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant EXCHANGE_WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    IFeeRecipient public constant _feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);\\n\\n    address public constant DISCOUNT_ADDRESS = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\\n    address public constant SAVER_EXCHANGE_REGISTRY = 0x25dd3F51e0C3c3Ff164DDC02A8E4D65Bb9cBB12D;\\n\\n    address public constant ZRX_ALLOWLIST_ADDR = 0x4BA1f38427b33B8ab7Bb0490200dAE1F1C36823F;\\n\\n\\n    function getDecimals(address _token) internal view returns (uint256) {\\n        if (_token == KYBER_ETH_ADDRESS) return 18;\\n\\n        return ERC20(_token).decimals();\\n    }\\n\\n    function getBalance(address _tokenAddr) internal view returns (uint balance) {\\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\\n            balance = address(this).balance;\\n        } else {\\n            balance = ERC20(_tokenAddr).balanceOf(address(this));\\n        }\\n    }\\n\\n    function sendLeftover(address _srcAddr, address _destAddr, address payable _to) internal {\\n        // send back any leftover ether or tokens\\n        if (address(this).balance > 0) {\\n            _to.transfer(address(this).balance);\\n        }\\n\\n        if (getBalance(_srcAddr) > 0) {\\n            ERC20(_srcAddr).safeTransfer(_to, getBalance(_srcAddr));\\n        }\\n\\n        if (getBalance(_destAddr) > 0) {\\n            ERC20(_destAddr).safeTransfer(_to, getBalance(_destAddr));\\n        }\\n    }\\n\\n    /// @notice Takes a feePercentage and sends it to wallet\\n    /// @param _amount Dai amount of the whole trade\\n    /// @param _user Address of the user\\n    /// @param _token Address of the token\\n    /// @param _dfsFeeDivider Dfs fee divider\\n    /// @return feeAmount Amount in Dai owner earned on the fee\\n    function getFee(uint256 _amount, address _user, address _token, uint256 _dfsFeeDivider) internal returns (uint256 feeAmount) {\\n        if (_dfsFeeDivider != 0 && Discount(DISCOUNT_ADDRESS).isCustomFeeSet(_user)) {\\n            _dfsFeeDivider = Discount(DISCOUNT_ADDRESS).getCustomServiceFee(_user);\\n        }\\n\\n        if (_dfsFeeDivider == 0) {\\n            feeAmount = 0;\\n        } else {\\n            feeAmount = _amount / _dfsFeeDivider;\\n\\n            // fee can't go over 10% of the whole amount\\n            if (feeAmount > (_amount / 10)) {\\n                feeAmount = _amount / 10;\\n            }\\n\\n            address walletAddr = _feeRecipient.getFeeAddr();\\n\\n            if (_token == KYBER_ETH_ADDRESS) {\\n                payable(walletAddr).transfer(feeAmount);\\n            } else {\\n                ERC20(_token).safeTransfer(walletAddr, feeAmount);\\n            }\\n        }\\n    }\\n\\n    function sliceUint(bytes memory bs, uint256 start) internal pure returns (uint256) {\\n        require(bs.length >= start + 32, \\\"slicing out of range\\\");\\n\\n        uint256 x;\\n        assembly {\\n            x := mload(add(bs, add(0x20, start)))\\n        }\\n\\n        return x;\\n    }\\n\\n        function writeUint256(bytes memory _b, uint256 _index, uint _input) internal pure {\\n        if (_b.length < _index + 32) {\\n            revert(ERR_OFFCHAIN_DATA_INVALID);\\n        }\\n\\n        bytes32 input = bytes32(_input);\\n\\n        _index += 32;\\n\\n        // Read the bytes32 from array memory\\n        assembly {\\n            mstore(add(_b, _index), input)\\n        }\\n    }\\n\\n    /// @notice Converts Kybers Eth address -> Weth\\n    /// @param _src Input address\\n    function ethToWethAddr(address _src) internal pure returns (address) {\\n        return _src == KYBER_ETH_ADDRESS ? EXCHANGE_WETH_ADDRESS : _src;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/SaverExchangeRegistry.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../auth/AdminAuth.sol\\\";\\n\\ncontract SaverExchangeRegistry is AdminAuth {\\n\\n\\tmapping(address => bool) private wrappers;\\n\\n\\tconstructor() public {\\n\\t\\twrappers[0x880A845A85F843a5c67DB2061623c6Fc3bB4c511] = true;\\n\\t\\twrappers[0x4c9B55f2083629A1F7aDa257ae984E03096eCD25] = true;\\n\\t\\twrappers[0x42A9237b872368E1bec4Ca8D26A928D7d39d338C] = true;\\n\\t}\\n\\n\\tfunction addWrapper(address _wrapper) public onlyOwner {\\n\\t\\twrappers[_wrapper] = true;\\n\\t}\\n\\n\\tfunction removeWrapper(address _wrapper) public onlyOwner {\\n\\t\\twrappers[_wrapper] = false;\\n\\t}\\n\\n\\tfunction isWrapper(address _wrapper) public view returns(bool) {\\n\\t\\treturn wrappers[_wrapper];\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/OffchainWrapperInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../exchangeV3/DFSExchangeData.sol\\\";\\n\\nabstract contract OffchainWrapperInterface is DFSExchangeData {\\n    function takeOrder(\\n        ExchangeData memory _exData,\\n        ActionType _type\\n    ) virtual public payable returns (bool success, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeeRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nabstract contract IFeeRecipient {\\n    function getFeeAddr() public view virtual returns (address);\\n    function changeWalletAddr(address _newWallet) public virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/shifter/LoanShifterReceiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../auth/AdminAuth.sol\\\";\\nimport \\\"../utils/FlashLoanReceiverBase.sol\\\";\\nimport \\\"../interfaces/DSProxyInterface.sol\\\";\\nimport \\\"../exchangeV3/DFSExchangeCore.sol\\\";\\nimport \\\"./ShifterRegistry.sol\\\";\\nimport \\\"./LoanShifterTaker.sol\\\";\\n\\n/// @title LoanShifterReceiver Recevies the Aave flash loan and calls actions through users DSProxy\\ncontract LoanShifterReceiver is DFSExchangeCore, FlashLoanReceiverBase, AdminAuth {\\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\\n\\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER =\\n        ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    uint public constant SERVICE_FEE = 400; // 0.25% Fee\\n\\n    ShifterRegistry public constant shifterRegistry =\\n        ShifterRegistry(0x597C52281b31B9d949a9D8fEbA08F7A2530a965e);\\n\\n    struct ParamData {\\n        bytes proxyData1;\\n        bytes proxyData2;\\n        address proxy;\\n        address debtAddr;\\n        uint8 protocol1;\\n        uint8 protocol2;\\n        uint8 swapType;\\n    }\\n\\n    constructor() public FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER) {}\\n\\n    function executeOperation(\\n        address _reserve,\\n        uint256 _amount,\\n        uint256 _fee,\\n        bytes calldata _params\\n    ) external override {\\n        // Format the call data for DSProxy\\n        (ParamData memory paramData, ExchangeData memory exchangeData) =\\n            packFunctionCall(_amount, _fee, _params);\\n\\n        address protocolAddr1 = shifterRegistry.getAddr(getNameByProtocol(paramData.protocol1));\\n        address protocolAddr2 = shifterRegistry.getAddr(getNameByProtocol(paramData.protocol2));\\n\\n        // Send Flash loan amount to DSProxy\\n        sendTokenToProxy(payable(paramData.proxy), _reserve, _amount);\\n\\n        // Execute the Close/Change debt operation\\n        DSProxyInterface(paramData.proxy).execute(protocolAddr1, paramData.proxyData1);\\n\\n        exchangeData.dfsFeeDivider = SERVICE_FEE;\\n        exchangeData.user = DSProxyInterface(paramData.proxy).owner();\\n\\n        if (paramData.swapType == 1) {\\n            uint256 amount = exchangeData.srcAmount;\\n\\n            if (exchangeData.srcAddr != exchangeData.destAddr) {\\n                // COLL_SWAP\\n                (, amount) = _sell(exchangeData);\\n            }\\n\\n            sendTokenAndEthToProxy(payable(paramData.proxy), exchangeData.destAddr, amount);\\n        } else if (paramData.swapType == 2) {\\n            // DEBT_SWAP\\n\\n            if (exchangeData.srcAddr != exchangeData.destAddr) {\\n                exchangeData.destAmount = (_amount + _fee);\\n                _buy(exchangeData);\\n\\n                // Send extra to DSProxy\\n                sendTokenToProxy(\\n                    payable(paramData.proxy),\\n                    exchangeData.srcAddr,\\n                    ERC20(exchangeData.srcAddr).balanceOf(address(this))\\n                );\\n            }\\n        } else {\\n            // NO_SWAP just send tokens to proxy\\n            sendTokenAndEthToProxy(\\n                payable(paramData.proxy),\\n                exchangeData.srcAddr,\\n                getBalance(exchangeData.srcAddr)\\n            );\\n        }\\n\\n        // Execute the Open operation\\n        DSProxyInterface(paramData.proxy).execute(protocolAddr2, paramData.proxyData2);\\n\\n        // Repay FL\\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\\n\\n        // if there is some eth left (0x fee), return it to user\\n        if (address(this).balance > 0) {\\n            tx.origin.transfer(address(this).balance);\\n        }\\n    }\\n\\n    function packFunctionCall(\\n        uint256 _amount,\\n        uint256 _fee,\\n        bytes memory _params\\n    )\\n        internal\\n        pure\\n        returns (ParamData memory paramData, ExchangeData memory exchangeData)\\n    {\\n\\n        LoanShifterTaker.LoanShiftData memory shiftData;\\n        address proxy;\\n\\n        (shiftData, exchangeData, proxy) = abi.decode(\\n            _params,\\n            (LoanShifterTaker.LoanShiftData, ExchangeData, address)\\n        );\\n\\n        bytes memory proxyData1;\\n        bytes memory proxyData2;\\n        uint256 openDebtAmount = (_amount + _fee);\\n\\n        if (shiftData.fromProtocol == LoanShifterTaker.Protocols.MCD) {\\n            // MAKER FROM\\n            proxyData1 = abi.encodeWithSignature(\\n                \\\"close(uint256,address,uint256,uint256)\\\",\\n                shiftData.id1,\\n                shiftData.addrLoan1,\\n                _amount,\\n                shiftData.collAmount\\n            );\\n        } else if (shiftData.fromProtocol == LoanShifterTaker.Protocols.COMPOUND) {\\n            // COMPOUND FROM\\n            if (shiftData.swapType == LoanShifterTaker.SwapType.DEBT_SWAP) {\\n                // DEBT_SWAP\\n                proxyData1 = abi.encodeWithSignature(\\n                    \\\"changeDebt(address,address,uint256,uint256)\\\",\\n                    shiftData.debtAddr1,\\n                    shiftData.debtAddr2,\\n                    _amount,\\n                    exchangeData.srcAmount\\n                );\\n            } else {\\n                proxyData1 = abi.encodeWithSignature(\\n                    \\\"close(address,address,uint256,uint256)\\\",\\n                    shiftData.addrLoan1,\\n                    shiftData.debtAddr1,\\n                    shiftData.collAmount,\\n                    shiftData.debtAmount\\n                );\\n            }\\n        }\\n\\n        if (shiftData.toProtocol == LoanShifterTaker.Protocols.MCD) {\\n            // MAKER TO\\n            proxyData2 = abi.encodeWithSignature(\\n                \\\"open(uint256,address,uint256)\\\",\\n                shiftData.id2,\\n                shiftData.addrLoan2,\\n                openDebtAmount\\n            );\\n        } else if (shiftData.toProtocol == LoanShifterTaker.Protocols.COMPOUND) {\\n            // COMPOUND TO\\n            if (shiftData.swapType == LoanShifterTaker.SwapType.DEBT_SWAP) {\\n                // DEBT_SWAP\\n                proxyData2 = abi.encodeWithSignature(\\\"repayAll(address)\\\", shiftData.debtAddr2);\\n            } else {\\n                proxyData2 = abi.encodeWithSignature(\\n                    \\\"open(address,address,uint256)\\\",\\n                    shiftData.addrLoan2,\\n                    shiftData.debtAddr2,\\n                    openDebtAmount\\n                );\\n            }\\n        }\\n\\n        paramData = ParamData({\\n            proxyData1: proxyData1,\\n            proxyData2: proxyData2,\\n            proxy: proxy,\\n            debtAddr: shiftData.debtAddr1,\\n            protocol1: uint8(shiftData.fromProtocol),\\n            protocol2: uint8(shiftData.toProtocol),\\n            swapType: uint8(shiftData.swapType)\\n        });\\n    }\\n\\n    function sendTokenAndEthToProxy(\\n        address payable _proxy,\\n        address _reserve,\\n        uint256 _amount\\n    ) internal {\\n        if (_reserve != ETH_ADDRESS) {\\n            ERC20(_reserve).safeTransfer(_proxy, _amount);\\n        }\\n\\n        _proxy.transfer(address(this).balance);\\n    }\\n\\n    function sendTokenToProxy(\\n        address payable _proxy,\\n        address _reserve,\\n        uint256 _amount\\n    ) internal {\\n        if (_reserve != ETH_ADDRESS) {\\n            ERC20(_reserve).safeTransfer(_proxy, _amount);\\n        } else {\\n            _proxy.transfer(address(this).balance);\\n        }\\n    }\\n\\n    function getNameByProtocol(uint8 _proto) internal pure returns (string memory) {\\n        if (_proto == 0) {\\n            return \\\"MCD_SHIFTER\\\";\\n        } else if (_proto == 1) {\\n            return \\\"COMP_SHIFTER\\\";\\n        }\\n    }\\n\\n    receive() external payable override(FlashLoanReceiverBase, DFSExchangeCore) {}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/FlashLoanReceiverBase.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./SafeERC20.sol\\\";\\n\\ninterface IFlashLoanReceiver {\\n    function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external;\\n}\\n\\nabstract contract ILendingPoolAddressesProvider {\\n\\n    function getLendingPool() public view virtual returns (address);\\n    function setLendingPoolImpl(address _pool) public virtual;\\n\\n    function getLendingPoolCore() public virtual view returns (address payable);\\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public virtual;\\n\\n    function getLendingPoolConfigurator() public virtual view returns (address);\\n    function setLendingPoolConfiguratorImpl(address _configurator) public virtual;\\n\\n    function getLendingPoolDataProvider() public virtual view returns (address);\\n    function setLendingPoolDataProviderImpl(address _provider) public virtual;\\n\\n    function getLendingPoolParametersProvider() public virtual view returns (address);\\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public virtual;\\n\\n    function getTokenDistributor() public virtual view returns (address);\\n    function setTokenDistributor(address _tokenDistributor) public virtual;\\n\\n\\n    function getFeeProvider() public virtual view returns (address);\\n    function setFeeProviderImpl(address _feeProvider) public virtual;\\n\\n    function getLendingPoolLiquidationManager() public virtual view returns (address);\\n    function setLendingPoolLiquidationManager(address _manager) public virtual;\\n\\n    function getLendingPoolManager() public virtual view returns (address);\\n    function setLendingPoolManager(address _lendingPoolManager) public virtual;\\n\\n    function getPriceOracle() public virtual view returns (address);\\n    function setPriceOracle(address _priceOracle) public virtual;\\n\\n    function getLendingRateOracle() public view virtual returns (address);\\n    function setLendingRateOracle(address _lendingRateOracle) public virtual;\\n}\\n\\nlibrary EthAddressLib {\\n\\n    function ethAddress() internal pure returns(address) {\\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    }\\n}\\n\\nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver {\\n\\n    using SafeERC20 for ERC20;\\n    using SafeMath for uint256;\\n\\n    ILendingPoolAddressesProvider public addressesProvider;\\n\\n    constructor(ILendingPoolAddressesProvider _provider) public {\\n        addressesProvider = _provider;\\n    }\\n\\n    receive () external virtual payable {}\\n\\n    function transferFundsBackToPoolInternal(address _reserve, uint256 _amount) internal {\\n\\n        address payable core = addressesProvider.getLendingPoolCore();\\n\\n        transferInternal(core,_reserve, _amount);\\n    }\\n\\n    function transferInternal(address payable _destination, address _reserve, uint256  _amount) internal {\\n        if(_reserve == EthAddressLib.ethAddress()) {\\n            //solium-disable-next-line\\n            _destination.call{value: _amount}(\\\"\\\");\\n            return;\\n        }\\n\\n        ERC20(_reserve).safeTransfer(_destination, _amount);\\n\\n\\n    }\\n\\n    function getBalanceInternal(address _target, address _reserve) internal view returns(uint256) {\\n        if(_reserve == EthAddressLib.ethAddress()) {\\n\\n            return _target.balance;\\n        }\\n\\n        return ERC20(_reserve).balanceOf(_target);\\n\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/compound/create/CompoundCreateReceiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../DS/DSProxy.sol\\\";\\nimport \\\"../../utils/FlashLoanReceiverBase.sol\\\";\\nimport \\\"../../interfaces/DSProxyInterface.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeCore.sol\\\";\\nimport \\\"../../shifter/ShifterRegistry.sol\\\";\\nimport \\\"./CompoundCreateTaker.sol\\\";\\n\\n/// @title Contract that receives the FL from Aave for Creating loans\\ncontract CompoundCreateReceiver is FlashLoanReceiverBase, DFSExchangeCore {\\n\\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\\n    ShifterRegistry public constant shifterRegistry = ShifterRegistry(0x597C52281b31B9d949a9D8fEbA08F7A2530a965e);\\n\\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\\n\\n    uint public constant SERVICE_FEE = 400; // 0.25% Fee\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor() public FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER) {}\\n\\n    struct CompCreateData {\\n        address payable proxyAddr;\\n        bytes proxyData;\\n        address cCollAddr;\\n        address cDebtAddr;\\n    }\\n\\n    /// @notice Called by Aave when sending back the FL amount\\n    /// @param _reserve The address of the borrowed token\\n    /// @param _amount Amount of FL tokens received\\n    /// @param _fee FL Aave fee\\n    /// @param _params The params that are sent from the original FL caller contract\\n   function executeOperation(\\n        address _reserve,\\n        uint256 _amount,\\n        uint256 _fee,\\n        bytes calldata _params)\\n    external override {\\n        // Format the call data for DSProxy\\n        (CompCreateData memory compCreate, ExchangeData memory exchangeData)\\n                                 = packFunctionCall(_amount, _fee, _params);\\n\\n\\n        address leveragedAsset = _reserve;\\n\\n        // If the assets are different\\n        if (compCreate.cCollAddr != compCreate.cDebtAddr) {\\n            exchangeData.dfsFeeDivider = SERVICE_FEE;\\n            exchangeData.user = DSProxyInterface(compCreate.proxyAddr).owner();\\n\\n            _sell(exchangeData);\\n\\n            leveragedAsset = exchangeData.destAddr;\\n        }\\n\\n        // Send amount to DSProxy\\n        sendToProxy(compCreate.proxyAddr, leveragedAsset);\\n\\n        address compOpenProxy = shifterRegistry.getAddr(\\\"COMP_SHIFTER\\\");\\n\\n        // Execute the DSProxy call\\n        DSProxyInterface(compCreate.proxyAddr).execute(compOpenProxy, compCreate.proxyData);\\n\\n        // Repay the loan with the money DSProxy sent back\\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\\n\\n        // if there is some eth left (0x fee), return it to user\\n        if (address(this).balance > 0) {\\n            // solhint-disable-next-line avoid-tx-origin\\n            tx.origin.transfer(address(this).balance);\\n        }\\n    }\\n\\n    /// @notice Formats function data call so we can call it through DSProxy\\n    /// @param _amount Amount of FL\\n    /// @param _fee Fee of the FL\\n    /// @param _params Saver proxy params\\n    function packFunctionCall(uint _amount, uint _fee, bytes memory _params) internal pure  returns (CompCreateData memory compCreate, ExchangeData memory exchangeData) {\\n\\n        CompoundCreateTaker.CreateInfo memory createData;\\n        address proxy;\\n\\n        (createData , exchangeData, proxy)= abi.decode(_params, (CompoundCreateTaker.CreateInfo, ExchangeData, address));\\n\\n        bytes memory proxyData = abi.encodeWithSignature(\\n            \\\"open(address,address,uint256)\\\",\\n                                createData.cCollAddress, createData.cBorrowAddress, (_amount + _fee));\\n\\n\\n        compCreate = CompCreateData({\\n            proxyAddr: payable(proxy),\\n            proxyData: proxyData,\\n            cCollAddr: createData.cCollAddress,\\n            cDebtAddr: createData.cBorrowAddress\\n        });\\n\\n        return (compCreate, exchangeData);\\n    }\\n\\n    /// @notice Send the FL funds received to DSProxy\\n    /// @param _proxy DSProxy address\\n    /// @param _reserve Token address\\n    function sendToProxy(address payable _proxy, address _reserve) internal {\\n        if (_reserve != ETH_ADDRESS) {\\n            ERC20(_reserve).safeTransfer(_proxy, ERC20(_reserve).balanceOf(address(this)));\\n        } else {\\n            _proxy.transfer(address(this).balance);\\n        }\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external override(FlashLoanReceiverBase, DFSExchangeCore) payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/compound/create/CompoundCreateTaker.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../interfaces/ILendingPool.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../auth/ProxyPermission.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeData.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\n\\n/// @title Opens compound positions with a leverage\\ncontract CompoundCreateTaker is ProxyPermission {\\n    using SafeERC20 for ERC20;\\n\\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\\n\\n    // solhint-disable-next-line const-name-snakecase\\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\\n\\n    struct CreateInfo {\\n        address cCollAddress;\\n        address cBorrowAddress;\\n        uint depositAmount;\\n    }\\n\\n    /// @notice Main function which will take a FL and open a leverage position\\n    /// @dev Call through DSProxy, if _exchangeData.destAddr is a token approve DSProxy\\n    /// @param _createInfo [cCollAddress, cBorrowAddress, depositAmount]\\n    /// @param _exchangeData Exchange data struct\\n    function openLeveragedLoan(\\n        CreateInfo memory _createInfo,\\n        DFSExchangeData.ExchangeData memory _exchangeData,\\n        address payable _compReceiver\\n    ) public payable {\\n        uint loanAmount = _exchangeData.srcAmount;\\n\\n        // Pull tokens from user\\n        if (_exchangeData.destAddr != ETH_ADDRESS) {\\n            ERC20(_exchangeData.destAddr).safeTransferFrom(msg.sender, address(this), _createInfo.depositAmount);\\n        } else {\\n            require(msg.value >= _createInfo.depositAmount, \\\"Must send correct amount of eth\\\");\\n        }\\n\\n        // Send tokens to FL receiver\\n        sendDeposit(_compReceiver, _exchangeData.destAddr);\\n\\n        bytes memory paramsData = abi.encode(_createInfo, _exchangeData, address(this));\\n\\n        givePermission(_compReceiver);\\n\\n        lendingPool.flashLoan(_compReceiver, _exchangeData.srcAddr, loanAmount, paramsData);\\n\\n        removePermission(_compReceiver);\\n\\n        logger.Log(address(this), msg.sender, \\\"CompoundLeveragedLoan\\\",\\n            abi.encode(_exchangeData.srcAddr, _exchangeData.destAddr, _exchangeData.srcAmount, _exchangeData.destAmount));\\n    }\\n\\n    function sendDeposit(address payable _compoundReceiver, address _token) internal {\\n        if (_token != ETH_ADDRESS) {\\n            ERC20(_token).safeTransfer(_compoundReceiver, ERC20(_token).balanceOf(address(this)));\\n        }\\n\\n        _compoundReceiver.transfer(address(this).balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/reflexer/saver/RAISaverTaker.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../saver/RAISaverProxy.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeData.sol\\\";\\nimport \\\"../../utils/GasBurner.sol\\\";\\nimport \\\"../../interfaces/ILendingPool.sol\\\";\\nimport \\\"../../utils/DydxFlashLoanBase.sol\\\";\\n\\ncontract RAISaverTaker is RAISaverProxy, DydxFlashLoanBase, GasBurner {\\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    struct SaverData {\\n        uint256 flAmount;\\n        bool isRepay;\\n        uint256 safeId;\\n        uint256 gasCost;\\n        address joinAddr;\\n        ManagerType managerType;\\n    }\\n\\n    function boostWithLoan(\\n        ExchangeData memory _exchangeData,\\n        uint256 _safeId,\\n        uint256 _gasCost,\\n        address _joinAddr,\\n        ManagerType _managerType,\\n        address _raiSaverFlashLoan\\n    ) public payable burnGas(25) {\\n        address managerAddr = getManagerAddr(_managerType);\\n\\n        uint256 maxDebt =\\n            getMaxDebt(managerAddr, _safeId, ISAFEManager(managerAddr).collateralTypes(_safeId));\\n\\n        if (maxDebt >= _exchangeData.srcAmount) {\\n            if (_exchangeData.srcAmount > maxDebt) {\\n                _exchangeData.srcAmount = maxDebt;\\n            }\\n\\n            boost(_exchangeData, _safeId, _gasCost, _joinAddr, _managerType);\\n            return;\\n        }\\n\\n        uint256 loanAmount = getAvailableEthLiquidity();\\n\\n        SaverData memory saverData =\\n            SaverData({\\n                flAmount: loanAmount,\\n                isRepay: false,\\n                safeId: _safeId,\\n                gasCost: _gasCost,\\n                joinAddr: _joinAddr,\\n                managerType: _managerType\\n            });\\n\\n        _flashLoan(_raiSaverFlashLoan, _exchangeData, saverData);\\n    }\\n\\n    function repayWithLoan(\\n        ExchangeData memory _exchangeData,\\n        uint256 _safeId,\\n        uint256 _gasCost,\\n        address _joinAddr,\\n        ManagerType _managerType,\\n        address _raiSaverFlashLoan\\n    ) public payable burnGas(25) {\\n        address managerAddr = getManagerAddr(_managerType);\\n\\n        uint256 maxColl =\\n            getMaxCollateral(\\n                managerAddr,\\n                _safeId,\\n                ISAFEManager(managerAddr).collateralTypes(_safeId),\\n                _joinAddr\\n            );\\n\\n        if (maxColl >= _exchangeData.srcAmount) {\\n            if (_exchangeData.srcAmount > maxColl) {\\n                _exchangeData.srcAmount = maxColl;\\n            }\\n\\n            repay(_exchangeData, _safeId, _gasCost, _joinAddr, _managerType);\\n            return;\\n        }\\n\\n        uint256 loanAmount = _exchangeData.srcAmount;\\n\\n        SaverData memory saverData =\\n            SaverData({\\n                flAmount: loanAmount,\\n                isRepay: true,\\n                safeId: _safeId,\\n                gasCost: _gasCost,\\n                joinAddr: _joinAddr,\\n                managerType: _managerType\\n            });\\n\\n        _flashLoan(_raiSaverFlashLoan, _exchangeData, saverData);\\n    }\\n\\n    /// @notice Gets the maximum amount of debt available to generate\\n    /// @param _managerAddr Address of the CDP Manager\\n    /// @param _safeId Id of the CDP\\n    /// @param _collType Coll type of the CDP\\n    function getMaxDebt(\\n        address _managerAddr,\\n        uint256 _safeId,\\n        bytes32 _collType\\n    ) public override view returns (uint256) {\\n        (uint256 collateral, uint256 debt) =\\n            getSafeInfo(ISAFEManager(_managerAddr), _safeId, _collType);\\n\\n        (, , uint256 safetyPrice, , , ) =\\n            ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);\\n\\n        return sub(rmul(collateral, safetyPrice), debt);\\n    }\\n\\n    /// @notice Fetches Eth Dydx liqudity\\n    function getAvailableEthLiquidity() internal view returns (uint256 liquidity) {\\n        liquidity = ERC20(WETH_ADDR).balanceOf(SOLO_MARGIN_ADDRESS);\\n    }\\n\\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\\n    /// @dev User must send 2 wei with this transaction\\n    function _flashLoan(address RAI_SAVER_FLASH_LOAN, ExchangeData memory _exchangeData, SaverData memory _saverData) internal {\\n        ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\\n\\n        address managerAddr = getManagerAddr(_saverData.managerType);\\n\\n        // Get marketId from token address\\n        uint256 marketId = _getMarketIdFromTokenAddress(WETH_ADDR);\\n\\n        // Calculate repay amount (_amount + (2 wei))\\n        // Approve transfer from\\n        uint256 repayAmount = _getRepaymentAmountInternal(_saverData.flAmount);\\n        ERC20(WETH_ADDR).approve(SOLO_MARGIN_ADDRESS, repayAmount);\\n\\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\\n\\n        operations[0] = _getWithdrawAction(marketId, _saverData.flAmount, RAI_SAVER_FLASH_LOAN);\\n        payable(RAI_SAVER_FLASH_LOAN).transfer(msg.value); // 0x fee\\n\\n        bytes memory exchangeData = packExchangeData(_exchangeData);\\n        operations[1] = _getCallAction(abi.encode(exchangeData, _saverData), RAI_SAVER_FLASH_LOAN);\\n\\n        operations[2] = _getDepositAction(marketId, repayAmount, address(this));\\n\\n        Account.Info[] memory accountInfos = new Account.Info[](1);\\n        accountInfos[0] = _getAccountInfo();\\n\\n        ISAFEManager(managerAddr).allowSAFE(_saverData.safeId, RAI_SAVER_FLASH_LOAN, 1);\\n        solo.operate(accountInfos, operations);\\n        ISAFEManager(managerAddr).allowSAFE(_saverData.safeId, RAI_SAVER_FLASH_LOAN, 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/DydxFlashLoanBase.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../utils/SafeMath.sol\\\";\\nimport \\\"../savings/dydx/ISoloMargin.sol\\\";\\n\\ncontract DydxFlashLoanBase {\\n    using SafeMath for uint256;\\n\\n    address public constant SOLO_MARGIN_ADDRESS = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\\n\\n    function _getMarketIdFromTokenAddress(address token)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return 0;\\n    }\\n\\n    function _getRepaymentAmountInternal(uint256 amount)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        // Needs to be overcollateralize\\n        // Needs to provide +2 wei to be safe\\n        return amount.add(2);\\n    }\\n\\n    function _getAccountInfo() internal view returns (Account.Info memory) {\\n        return Account.Info({owner: address(this), number: 1});\\n    }\\n\\n    function _getWithdrawAction(uint marketId, uint256 amount, address contractAddr)\\n        internal\\n        view\\n        returns (Actions.ActionArgs memory)\\n    {\\n        return\\n            Actions.ActionArgs({\\n                actionType: Actions.ActionType.Withdraw,\\n                accountId: 0,\\n                amount: Types.AssetAmount({\\n                    sign: false,\\n                    denomination: Types.AssetDenomination.Wei,\\n                    ref: Types.AssetReference.Delta,\\n                    value: amount\\n                }),\\n                primaryMarketId: marketId,\\n                secondaryMarketId: 0,\\n                otherAddress: contractAddr,\\n                otherAccountId: 0,\\n                data: \\\"\\\"\\n            });\\n    }\\n\\n    function _getCallAction(bytes memory data, address contractAddr)\\n        internal\\n        view\\n        returns (Actions.ActionArgs memory)\\n    {\\n        return\\n            Actions.ActionArgs({\\n                actionType: Actions.ActionType.Call,\\n                accountId: 0,\\n                amount: Types.AssetAmount({\\n                    sign: false,\\n                    denomination: Types.AssetDenomination.Wei,\\n                    ref: Types.AssetReference.Delta,\\n                    value: 0\\n                }),\\n                primaryMarketId: 0,\\n                secondaryMarketId: 0,\\n                otherAddress: contractAddr,\\n                otherAccountId: 0,\\n                data: data\\n            });\\n    }\\n\\n    function _getDepositAction(uint marketId, uint256 amount, address contractAddr)\\n        internal\\n        view\\n        returns (Actions.ActionArgs memory)\\n    {\\n        return\\n            Actions.ActionArgs({\\n                actionType: Actions.ActionType.Deposit,\\n                accountId: 0,\\n                amount: Types.AssetAmount({\\n                    sign: true,\\n                    denomination: Types.AssetDenomination.Wei,\\n                    ref: Types.AssetReference.Delta,\\n                    value: amount\\n                }),\\n                primaryMarketId: marketId,\\n                secondaryMarketId: 0,\\n                otherAddress: contractAddr,\\n                otherAccountId: 0,\\n                data: \\\"\\\"\\n            });\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/savings/dydx/ISoloMargin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\n\\nlibrary Account {\\n    enum Status {Normal, Liquid, Vapor}\\n    struct Info {\\n        address owner; // The address that owns the account\\n        uint256 number; // A nonce that allows a single address to control many accounts\\n    }\\n    struct Storage {\\n        mapping(uint256 => Types.Par) balances; // Mapping from marketId to principal\\n        Status status;\\n    }\\n}\\n\\n\\nlibrary Actions {\\n    enum ActionType {\\n        Deposit, // supply tokens\\n        Withdraw, // borrow tokens\\n        Transfer, // transfer balance between accounts\\n        Buy, // buy an amount of some token (public virtually)\\n        Sell, // sell an amount of some token (public virtually)\\n        Trade, // trade tokens against another account\\n        Liquidate, // liquidate an undercollateralized or expiring account\\n        Vaporize, // use excess tokens to zero-out a completely negative account\\n        Call // send arbitrary data to an address\\n    }\\n\\n    enum AccountLayout {OnePrimary, TwoPrimary, PrimaryAndSecondary}\\n\\n    enum MarketLayout {ZeroMarkets, OneMarket, TwoMarkets}\\n\\n    struct ActionArgs {\\n        ActionType actionType;\\n        uint256 accountId;\\n        Types.AssetAmount amount;\\n        uint256 primaryMarketId;\\n        uint256 secondaryMarketId;\\n        address otherAddress;\\n        uint256 otherAccountId;\\n        bytes data;\\n    }\\n\\n    struct DepositArgs {\\n        Types.AssetAmount amount;\\n        Account.Info account;\\n        uint256 market;\\n        address from;\\n    }\\n\\n    struct WithdrawArgs {\\n        Types.AssetAmount amount;\\n        Account.Info account;\\n        uint256 market;\\n        address to;\\n    }\\n\\n    struct TransferArgs {\\n        Types.AssetAmount amount;\\n        Account.Info accountOne;\\n        Account.Info accountTwo;\\n        uint256 market;\\n    }\\n\\n    struct BuyArgs {\\n        Types.AssetAmount amount;\\n        Account.Info account;\\n        uint256 makerMarket;\\n        uint256 takerMarket;\\n        address exchangeWrapper;\\n        bytes orderData;\\n    }\\n\\n    struct SellArgs {\\n        Types.AssetAmount amount;\\n        Account.Info account;\\n        uint256 takerMarket;\\n        uint256 makerMarket;\\n        address exchangeWrapper;\\n        bytes orderData;\\n    }\\n\\n    struct TradeArgs {\\n        Types.AssetAmount amount;\\n        Account.Info takerAccount;\\n        Account.Info makerAccount;\\n        uint256 inputMarket;\\n        uint256 outputMarket;\\n        address autoTrader;\\n        bytes tradeData;\\n    }\\n\\n    struct LiquidateArgs {\\n        Types.AssetAmount amount;\\n        Account.Info solidAccount;\\n        Account.Info liquidAccount;\\n        uint256 owedMarket;\\n        uint256 heldMarket;\\n    }\\n\\n    struct VaporizeArgs {\\n        Types.AssetAmount amount;\\n        Account.Info solidAccount;\\n        Account.Info vaporAccount;\\n        uint256 owedMarket;\\n        uint256 heldMarket;\\n    }\\n\\n    struct CallArgs {\\n        Account.Info account;\\n        address callee;\\n        bytes data;\\n    }\\n}\\n\\n\\nlibrary Decimal {\\n    struct D256 {\\n        uint256 value;\\n    }\\n}\\n\\n\\nlibrary Interest {\\n    struct Rate {\\n        uint256 value;\\n    }\\n\\n    struct Index {\\n        uint96 borrow;\\n        uint96 supply;\\n        uint32 lastUpdate;\\n    }\\n}\\n\\n\\nlibrary Monetary {\\n    struct Price {\\n        uint256 value;\\n    }\\n    struct Value {\\n        uint256 value;\\n    }\\n}\\n\\n\\nlibrary Storage {\\n    // All information necessary for tracking a market\\n    struct Market {\\n        // Contract address of the associated ERC20 token\\n        address token;\\n        // Total aggregated supply and borrow amount of the entire market\\n        Types.TotalPar totalPar;\\n        // Interest index of the market\\n        Interest.Index index;\\n        // Contract address of the price oracle for this market\\n        address priceOracle;\\n        // Contract address of the interest setter for this market\\n        address interestSetter;\\n        // Multiplier on the marginRatio for this market\\n        Decimal.D256 marginPremium;\\n        // Multiplier on the liquidationSpread for this market\\n        Decimal.D256 spreadPremium;\\n        // Whether additional borrows are allowed for this market\\n        bool isClosing;\\n    }\\n\\n    // The global risk parameters that govern the health and security of the system\\n    struct RiskParams {\\n        // Required ratio of over-collateralization\\n        Decimal.D256 marginRatio;\\n        // Percentage penalty incurred by liquidated accounts\\n        Decimal.D256 liquidationSpread;\\n        // Percentage of the borrower's interest fee that gets passed to the suppliers\\n        Decimal.D256 earningsRate;\\n        // The minimum absolute borrow value of an account\\n        // There must be sufficient incentivize to liquidate undercollateralized accounts\\n        Monetary.Value minBorrowedValue;\\n    }\\n\\n    // The maximum RiskParam values that can be set\\n    struct RiskLimits {\\n        uint64 marginRatioMax;\\n        uint64 liquidationSpreadMax;\\n        uint64 earningsRateMax;\\n        uint64 marginPremiumMax;\\n        uint64 spreadPremiumMax;\\n        uint128 minBorrowedValueMax;\\n    }\\n\\n    // The entire storage state of Solo\\n    struct State {\\n        // number of markets\\n        uint256 numMarkets;\\n        // marketId => Market\\n        mapping(uint256 => Market) markets;\\n        // owner => account number => Account\\n        mapping(address => mapping(uint256 => Account.Storage)) accounts;\\n        // Addresses that can control other users accounts\\n        mapping(address => mapping(address => bool)) operators;\\n        // Addresses that can control all users accounts\\n        mapping(address => bool) globalOperators;\\n        // mutable risk parameters of the system\\n        RiskParams riskParams;\\n        // immutable risk limits of the system\\n        RiskLimits riskLimits;\\n    }\\n}\\n\\n\\nlibrary Types {\\n    enum AssetDenomination {\\n        Wei, // the amount is denominated in wei\\n        Par // the amount is denominated in par\\n    }\\n\\n    enum AssetReference {\\n        Delta, // the amount is given as a delta from the current value\\n        Target // the amount is given as an exact number to end up at\\n    }\\n\\n    struct AssetAmount {\\n        bool sign; // true if positive\\n        AssetDenomination denomination;\\n        AssetReference ref;\\n        uint256 value;\\n    }\\n\\n    struct TotalPar {\\n        uint128 borrow;\\n        uint128 supply;\\n    }\\n\\n    struct Par {\\n        bool sign; // true if positive\\n        uint128 value;\\n    }\\n\\n    struct Wei {\\n        bool sign; // true if positive\\n        uint256 value;\\n    }\\n}\\n\\n\\nabstract contract ISoloMargin {\\n    struct OperatorArg {\\n        address operator;\\n        bool trusted;\\n    }\\n\\n    function ownerSetSpreadPremium(\\n        uint256 marketId,\\n        Decimal.D256 memory spreadPremium\\n    ) public virtual;\\n\\n    function getIsGlobalOperator(address operator) public virtual view returns (bool);\\n\\n    function getMarketTokenAddress(uint256 marketId)\\n        public virtual\\n        view\\n        returns (address);\\n\\n    function ownerSetInterestSetter(uint256 marketId, address interestSetter)\\n        public virtual;\\n\\n    function getAccountValues(Account.Info memory account)\\n        public virtual\\n        view\\n        returns (Monetary.Value memory, Monetary.Value memory);\\n\\n    function getMarketPriceOracle(uint256 marketId)\\n        public virtual\\n        view\\n        returns (address);\\n\\n    function getMarketInterestSetter(uint256 marketId)\\n        public virtual\\n        view\\n        returns (address);\\n\\n    function getMarketSpreadPremium(uint256 marketId)\\n        public virtual\\n        view\\n        returns (Decimal.D256 memory);\\n\\n    function getNumMarkets() public virtual view returns (uint256);\\n\\n    function ownerWithdrawUnsupportedTokens(address token, address recipient)\\n        public virtual\\n        returns (uint256);\\n\\n    function ownerSetMinBorrowedValue(Monetary.Value memory minBorrowedValue)\\n        public virtual;\\n\\n    function ownerSetLiquidationSpread(Decimal.D256 memory spread) public virtual;\\n\\n    function ownerSetEarningsRate(Decimal.D256 memory earningsRate) public virtual;\\n\\n    function getIsLocalOperator(address owner, address operator)\\n        public virtual\\n        view\\n        returns (bool);\\n\\n    function getAccountPar(Account.Info memory account, uint256 marketId)\\n        public virtual\\n        view\\n        returns (Types.Par memory);\\n\\n    function ownerSetMarginPremium(\\n        uint256 marketId,\\n        Decimal.D256 memory marginPremium\\n    ) public virtual;\\n\\n    function getMarginRatio() public virtual view returns (Decimal.D256 memory);\\n\\n    function getMarketCurrentIndex(uint256 marketId)\\n        public virtual\\n        view\\n        returns (Interest.Index memory);\\n\\n    function getMarketIsClosing(uint256 marketId) public virtual view returns (bool);\\n\\n    function getRiskParams() public virtual view returns (Storage.RiskParams memory);\\n\\n    function getAccountBalances(Account.Info memory account)\\n        public virtual\\n        view\\n        returns (address[] memory, Types.Par[] memory, Types.Wei[] memory);\\n\\n    function renounceOwnership() public virtual;\\n\\n    function getMinBorrowedValue() public virtual view returns (Monetary.Value memory);\\n\\n    function setOperators(OperatorArg[] memory args) public virtual;\\n\\n    function getMarketPrice(uint256 marketId) public virtual view returns (address);\\n\\n    function owner() public virtual view returns (address);\\n\\n    function isOwner() public virtual view returns (bool);\\n\\n    function ownerWithdrawExcessTokens(uint256 marketId, address recipient)\\n        public virtual\\n        returns (uint256);\\n\\n    function ownerAddMarket(\\n        address token,\\n        address priceOracle,\\n        address interestSetter,\\n        Decimal.D256 memory marginPremium,\\n        Decimal.D256 memory spreadPremium\\n    ) public virtual;\\n\\n    function operate(\\n        Account.Info[] memory accounts,\\n        Actions.ActionArgs[] memory actions\\n    ) public virtual;\\n\\n    function getMarketWithInfo(uint256 marketId)\\n        public virtual\\n        view\\n        returns (\\n            Storage.Market memory,\\n            Interest.Index memory,\\n            Monetary.Price memory,\\n            Interest.Rate memory\\n        );\\n\\n    function ownerSetMarginRatio(Decimal.D256 memory ratio) public virtual;\\n\\n    function getLiquidationSpread() public virtual view returns (Decimal.D256 memory);\\n\\n    function getAccountWei(Account.Info memory account, uint256 marketId)\\n        public virtual\\n        view\\n        returns (Types.Wei memory);\\n\\n    function getMarketTotalPar(uint256 marketId)\\n        public virtual\\n        view\\n        returns (Types.TotalPar memory);\\n\\n    function getLiquidationSpreadForPair(\\n        uint256 heldMarketId,\\n        uint256 owedMarketId\\n    ) public virtual view returns (Decimal.D256 memory);\\n\\n    function getNumExcessTokens(uint256 marketId)\\n        public virtual\\n        view\\n        returns (Types.Wei memory);\\n\\n    function getMarketCachedIndex(uint256 marketId)\\n        public virtual\\n        view\\n        returns (Interest.Index memory);\\n\\n    function getAccountStatus(Account.Info memory account)\\n        public virtual\\n        view\\n        returns (uint8);\\n\\n    function getEarningsRate() public virtual view returns (Decimal.D256 memory);\\n\\n    function ownerSetPriceOracle(uint256 marketId, address priceOracle) public virtual;\\n\\n    function getRiskLimits() public virtual view returns (Storage.RiskLimits memory);\\n\\n    function getMarket(uint256 marketId)\\n        public virtual\\n        view\\n        returns (Storage.Market memory);\\n\\n    function ownerSetIsClosing(uint256 marketId, bool isClosing) public virtual;\\n\\n    function ownerSetGlobalOperator(address operator, bool approved) public virtual;\\n\\n    function transferOwnership(address newOwner) public virtual;\\n\\n    function getAdjustedAccountValues(Account.Info memory account)\\n        public virtual\\n        view\\n        returns (Monetary.Value memory, Monetary.Value memory);\\n\\n    function getMarketMarginPremium(uint256 marketId)\\n        public virtual\\n        view\\n        returns (Decimal.D256 memory);\\n\\n    function getMarketInterestRate(uint256 marketId)\\n        public virtual\\n        view\\n        returns (Interest.Rate memory);\\n}\\n\"\r\n    },\r\n    \"contracts/flashloan/DydxFlashLoanTaker.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../auth/ProxyPermission.sol\\\";\\nimport \\\"../utils/DydxFlashLoanBase.sol\\\";\\nimport \\\"../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../interfaces/ERC20.sol\\\";\\n\\n\\n/// @title Takes flash loan\\ncontract DyDxFlashLoanTaker is DydxFlashLoanBase, ProxyPermission {\\n\\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\\n\\n    /// @notice Takes flash loan for _receiver\\n    /// @dev Receiver must send back WETH + 2 wei after executing transaction\\n    /// @dev Method is meant to be called from proxy and proxy will give authorization to _receiver\\n    /// @param _receiver Address of funds receiver\\n    /// @param _ethAmount ETH amount that needs to be pulled from dydx    \\n    /// @param _encodedData Bytes with packed data\\n    function takeLoan(address _receiver, uint256 _ethAmount, bytes memory _encodedData) public {\\n        ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\\n\\n        // Get marketId from token address\\n        uint256 marketId = _getMarketIdFromTokenAddress(WETH_ADDR);\\n\\n        // Calculate repay amount (_amount + (2 wei))\\n        // Approve transfer from\\n        uint256 repayAmount = _getRepaymentAmountInternal(_ethAmount);\\n        ERC20(WETH_ADDR).approve(SOLO_MARGIN_ADDRESS, repayAmount);\\n\\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\\n\\n        operations[0] = _getWithdrawAction(marketId, _ethAmount, _receiver);\\n        operations[1] = _getCallAction(\\n            _encodedData,\\n            _receiver\\n        );\\n        operations[2] = _getDepositAction(marketId, repayAmount, address(this));\\n\\n        Account.Info[] memory accountInfos = new Account.Info[](1);\\n        accountInfos[0] = _getAccountInfo();\\n\\n        givePermission(_receiver);\\n        solo.operate(accountInfos, operations);\\n        removePermission(_receiver);\\n\\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \\\"DyDxFlashLoanTaken\\\", abi.encode(_receiver, _ethAmount, _encodedData));\\n    }\\n}\"\r\n    },\r\n    \"contracts/savings/SavingsProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ProtocolInterface.sol\\\";\\nimport \\\"../interfaces/ERC20.sol\\\";\\nimport \\\"../interfaces/ITokenInterface.sol\\\";\\nimport \\\"../interfaces/ComptrollerInterface.sol\\\";\\nimport \\\"./dydx/ISoloMargin.sol\\\";\\nimport \\\"./SavingsLogger.sol\\\";\\nimport \\\"./dsr/DSRSavingsProtocol.sol\\\";\\nimport \\\"./compound/CompoundSavingsProtocol.sol\\\";\\n\\n\\ncontract SavingsProxy is DSRSavingsProtocol, CompoundSavingsProtocol {\\n    address public constant ADAI_ADDRESS = 0xfC1E690f61EFd961294b3e1Ce3313fBD8aa4f85d;\\n\\n    address public constant SAVINGS_DYDX_ADDRESS = 0x03b1565e070df392e48e7a8e01798C4B00E534A5;\\n    address public constant SAVINGS_AAVE_ADDRESS = 0x535B9035E9bA8D7efe0FeAEac885fb65b303E37C;\\n    address public constant NEW_IDAI_ADDRESS = 0x493C57C4763932315A328269E1ADaD09653B9081;\\n\\n    address public constant COMP_ADDRESS = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\\n\\n    address public constant SAVINGS_LOGGER_ADDRESS = 0x89b3635BD2bAD145C6f92E82C9e83f06D5654984;\\n    address public constant SOLO_MARGIN_ADDRESS = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\\n\\n    enum SavingsProtocol {Compound, Dydx, Fulcrum, Dsr, Aave}\\n\\n    function deposit(SavingsProtocol _protocol, uint256 _amount) public {\\n        if (_protocol == SavingsProtocol.Dsr) {\\n            dsrDeposit(_amount, true);\\n        } else if (_protocol == SavingsProtocol.Compound) {\\n            compDeposit(msg.sender, _amount);\\n        } else {\\n            _deposit(_protocol, _amount, true);\\n        }\\n\\n        SavingsLogger(SAVINGS_LOGGER_ADDRESS).logDeposit(msg.sender, uint8(_protocol), _amount);\\n    }\\n\\n    function withdraw(SavingsProtocol _protocol, uint256 _amount) public {\\n        if (_protocol == SavingsProtocol.Dsr) {\\n            dsrWithdraw(_amount, true);\\n        } else if (_protocol == SavingsProtocol.Compound) {\\n            compWithdraw(msg.sender, _amount);\\n        } else {\\n            _withdraw(_protocol, _amount, true);\\n        }\\n\\n        SavingsLogger(SAVINGS_LOGGER_ADDRESS).logWithdraw(msg.sender, uint8(_protocol), _amount);\\n    }\\n\\n    function swap(SavingsProtocol _from, SavingsProtocol _to, uint256 _amount) public {\\n        if (_from == SavingsProtocol.Dsr) {\\n            dsrWithdraw(_amount, false);\\n        } else if (_from == SavingsProtocol.Compound) {\\n            compWithdraw(msg.sender, _amount);\\n        } else {\\n            _withdraw(_from, _amount, false);\\n        }\\n\\n        // possible to withdraw 1-2 wei less than actual amount due to division precision\\n        // so we deposit all amount on DSProxy\\n        uint256 amountToDeposit = ERC20(DAI_ADDRESS).balanceOf(address(this));\\n\\n        if (_to == SavingsProtocol.Dsr) {\\n            dsrDeposit(amountToDeposit, false);\\n        } else if (_from == SavingsProtocol.Compound) {\\n            compDeposit(msg.sender, _amount);\\n        } else {\\n            _deposit(_to, amountToDeposit, false);\\n        }\\n\\n        SavingsLogger(SAVINGS_LOGGER_ADDRESS).logSwap(\\n            msg.sender,\\n            uint8(_from),\\n            uint8(_to),\\n            _amount\\n        );\\n    }\\n\\n    function withdrawDai() public {\\n        ERC20(DAI_ADDRESS).transfer(msg.sender, ERC20(DAI_ADDRESS).balanceOf(address(this)));\\n    }\\n\\n    function claimComp() public {\\n        ComptrollerInterface(COMP_ADDRESS).claimComp(address(this));\\n    }\\n\\n    function getAddress(SavingsProtocol _protocol) public pure returns (address) {\\n\\n        if (_protocol == SavingsProtocol.Dydx) {\\n            return SAVINGS_DYDX_ADDRESS;\\n        }\\n\\n        if (_protocol == SavingsProtocol.Aave) {\\n            return SAVINGS_AAVE_ADDRESS;\\n        }\\n    }\\n\\n    function _deposit(SavingsProtocol _protocol, uint256 _amount, bool _fromUser) internal {\\n        if (_fromUser) {\\n            ERC20(DAI_ADDRESS).transferFrom(msg.sender, address(this), _amount);\\n        }\\n\\n        approveDeposit(_protocol);\\n\\n        ProtocolInterface(getAddress(_protocol)).deposit(address(this), _amount);\\n\\n        endAction(_protocol);\\n    }\\n\\n    function _withdraw(SavingsProtocol _protocol, uint256 _amount, bool _toUser) public {\\n        approveWithdraw(_protocol);\\n\\n        ProtocolInterface(getAddress(_protocol)).withdraw(address(this), _amount);\\n\\n        endAction(_protocol);\\n\\n        if (_toUser) {\\n            withdrawDai();\\n        }\\n    }\\n\\n    function endAction(SavingsProtocol _protocol) internal {\\n        if (_protocol == SavingsProtocol.Dydx) {\\n            setDydxOperator(false);\\n        }\\n    }\\n\\n    function approveDeposit(SavingsProtocol _protocol) internal {\\n        if (_protocol == SavingsProtocol.Compound || _protocol == SavingsProtocol.Fulcrum || _protocol == SavingsProtocol.Aave) {\\n            ERC20(DAI_ADDRESS).approve(getAddress(_protocol), uint256(-1));\\n        }\\n\\n        if (_protocol == SavingsProtocol.Dydx) {\\n            ERC20(DAI_ADDRESS).approve(SOLO_MARGIN_ADDRESS, uint256(-1));\\n            setDydxOperator(true);\\n        }\\n    }\\n\\n    function approveWithdraw(SavingsProtocol _protocol) internal {\\n        if (_protocol == SavingsProtocol.Compound) {\\n            ERC20(NEW_CDAI_ADDRESS).approve(getAddress(_protocol), uint256(-1));\\n        }\\n\\n        if (_protocol == SavingsProtocol.Dydx) {\\n            setDydxOperator(true);\\n        }\\n\\n        if (_protocol == SavingsProtocol.Fulcrum) {\\n            ERC20(NEW_IDAI_ADDRESS).approve(getAddress(_protocol), uint256(-1));\\n        }\\n\\n        if (_protocol == SavingsProtocol.Aave) {\\n            ERC20(ADAI_ADDRESS).approve(getAddress(_protocol), uint256(-1));\\n        }\\n    }\\n\\n    function setDydxOperator(bool _trusted) internal {\\n        ISoloMargin.OperatorArg[] memory operatorArgs = new ISoloMargin.OperatorArg[](1);\\n        operatorArgs[0] = ISoloMargin.OperatorArg({\\n            operator: getAddress(SavingsProtocol.Dydx),\\n            trusted: _trusted\\n        });\\n\\n        ISoloMargin(SOLO_MARGIN_ADDRESS).setOperators(operatorArgs);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/savings/ProtocolInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract ProtocolInterface {\\n    function deposit(address _user, uint256 _amount) public virtual;\\n\\n    function withdraw(address _user, uint256 _amount) public virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\nabstract contract ITokenInterface is ERC20 {\\n    function assetBalanceOf(address _owner) public virtual view returns (uint256);\\n\\n    function mint(address receiver, uint256 depositAmount) external virtual returns (uint256 mintAmount);\\n\\n    function burn(address receiver, uint256 burnAmount) external virtual returns (uint256 loanAmountPaid);\\n\\n    function tokenPrice() public virtual view returns (uint256 price);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ComptrollerInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nabstract contract ComptrollerInterface {\\n    struct CompMarketState {\\n        uint224 index;\\n        uint32 block;\\n    }\\n\\n    function claimComp(address holder) public virtual;\\n    function claimComp(address holder, address[] memory cTokens) public virtual;\\n    function claimComp(address[] memory holders, address[] memory cTokens, bool borrowers, bool suppliers) public virtual;\\n\\n    function compSupplyState(address) public view virtual returns (CompMarketState memory);\\n    function compSupplierIndex(address,address) public view virtual returns (uint);\\n    function compAccrued(address) public view virtual returns (uint);\\n\\n    function compBorrowState(address) public view virtual returns (CompMarketState memory);\\n    function compBorrowerIndex(address,address) public view virtual returns (uint);\\n\\n    function enterMarkets(address[] calldata cTokens) external virtual returns (uint256[] memory);\\n\\n    function exitMarket(address cToken) external virtual returns (uint256);\\n\\n    function getAssetsIn(address account) external virtual view returns (address[] memory);\\n\\n    function markets(address account) public virtual view returns (bool, uint256);\\n\\n    function getAccountLiquidity(address account) external virtual view returns (uint256, uint256, uint256);\\n\\n    function oracle() public virtual view returns (address);\\n\\n    function borrowCaps(address) external virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/savings/SavingsLogger.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ncontract SavingsLogger {\\n    event Deposit(address indexed sender, uint8 protocol, uint256 amount);\\n    event Withdraw(address indexed sender, uint8 protocol, uint256 amount);\\n    event Swap(address indexed sender, uint8 fromProtocol, uint8 toProtocol, uint256 amount);\\n\\n    function logDeposit(address _sender, uint8 _protocol, uint256 _amount) external {\\n        emit Deposit(_sender, _protocol, _amount);\\n    }\\n\\n    function logWithdraw(address _sender, uint8 _protocol, uint256 _amount) external {\\n        emit Withdraw(_sender, _protocol, _amount);\\n    }\\n\\n    function logSwap(address _sender, uint8 _protocolFrom, uint8 _protocolTo, uint256 _amount)\\n        external\\n    {\\n        emit Swap(_sender, _protocolFrom, _protocolTo, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/savings/dsr/DSRSavingsProtocol.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../interfaces/Join.sol\\\";\\nimport \\\"../../DS/DSMath.sol\\\";\\n\\nabstract contract VatLike {\\n    function can(address, address) virtual public view returns (uint);\\n    function ilks(bytes32) virtual public view returns (uint, uint, uint, uint, uint);\\n    function dai(address) virtual public view returns (uint);\\n    function urns(bytes32, address) virtual public view returns (uint, uint);\\n    function frob(bytes32, address, address, address, int, int) virtual public;\\n    function hope(address) virtual public;\\n    function move(address, address, uint) virtual public;\\n}\\n\\nabstract contract PotLike {\\n    function pie(address) virtual public view returns (uint);\\n    function drip() virtual public returns (uint);\\n    function join(uint) virtual public;\\n    function exit(uint) virtual public;\\n}\\n\\nabstract contract GemLike {\\n    function approve(address, uint) virtual public;\\n    function transfer(address, uint) virtual public;\\n    function transferFrom(address, address, uint) virtual public;\\n    function deposit() virtual public payable;\\n    function withdraw(uint) virtual public;\\n}\\n\\nabstract contract DaiJoinLike {\\n    function vat() virtual public returns (VatLike);\\n    function dai() virtual public returns (GemLike);\\n    function join(address, uint) virtual public payable;\\n    function exit(address, uint) virtual public;\\n}\\n\\ncontract DSRSavingsProtocol is DSMath {\\n\\n    // Mainnet\\n    address public constant POT_ADDRESS = 0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7;\\n    address public constant DAI_JOIN_ADDRESS = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\\n\\n    function dsrDeposit(uint _amount, bool _fromUser) internal {\\n        VatLike vat = DaiJoinLike(DAI_JOIN_ADDRESS).vat();\\n\\n        uint chi = PotLike(POT_ADDRESS).drip();\\n\\n        daiJoin_join(DAI_JOIN_ADDRESS, address(this), _amount, _fromUser);\\n\\n        if (vat.can(address(this), address(POT_ADDRESS)) == 0) {\\n            vat.hope(POT_ADDRESS);\\n        }\\n\\n        PotLike(POT_ADDRESS).join(mul(_amount, RAY) / chi);\\n    }\\n\\n    function dsrWithdraw(uint _amount, bool _toUser) internal {\\n        VatLike vat = DaiJoinLike(DAI_JOIN_ADDRESS).vat();\\n\\n        uint chi = PotLike(POT_ADDRESS).drip();\\n        uint pie = mul(_amount, RAY) / chi;\\n\\n        PotLike(POT_ADDRESS).exit(pie);\\n        uint balance = DaiJoinLike(DAI_JOIN_ADDRESS).vat().dai(address(this));\\n\\n        if (vat.can(address(this), address(DAI_JOIN_ADDRESS)) == 0) {\\n            vat.hope(DAI_JOIN_ADDRESS);\\n        }\\n\\n        address to;\\n        if (_toUser) {\\n            to = msg.sender;\\n        } else {\\n            to = address(this);\\n        }\\n\\n        if (_amount == uint(-1)) {\\n            DaiJoinLike(DAI_JOIN_ADDRESS).exit(to, mul(chi, pie) / RAY);\\n        } else {\\n            DaiJoinLike(DAI_JOIN_ADDRESS).exit(\\n                to,\\n                balance >= mul(_amount, RAY) ? _amount : balance / RAY\\n            );\\n        }\\n    }\\n\\n    function daiJoin_join(address apt, address urn, uint wad, bool _fromUser) internal {\\n        if (_fromUser) {\\n            DaiJoinLike(apt).dai().transferFrom(msg.sender, address(this), wad);\\n        }\\n\\n        DaiJoinLike(apt).dai().approve(apt, wad);\\n\\n        DaiJoinLike(apt).join(urn, wad);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/savings/compound/CompoundSavingsProtocol.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../ProtocolInterface.sol\\\";\\nimport \\\"../../interfaces/CTokenInterface.sol\\\";\\nimport \\\"../../compound/helpers/Exponential.sol\\\";\\nimport \\\"../../interfaces/ERC20.sol\\\";\\n\\ncontract CompoundSavingsProtocol {\\n\\n    address public constant NEW_CDAI_ADDRESS = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n\\n    CTokenInterface public constant cDaiContract = CTokenInterface(NEW_CDAI_ADDRESS);\\n\\n    function compDeposit(address _user, uint _amount) internal {\\n        // get dai from user\\n        require(ERC20(DAI_ADDRESS).transferFrom(_user, address(this), _amount));\\n\\n        // mainnet only\\n        ERC20(DAI_ADDRESS).approve(NEW_CDAI_ADDRESS, uint(-1));\\n\\n        // mint cDai\\n        require(cDaiContract.mint(_amount) == 0, \\\"Failed Mint\\\");\\n    }\\n\\n    function compWithdraw(address _user, uint _amount) internal {\\n        // transfer all users balance to this contract\\n        require(cDaiContract.transferFrom(_user, address(this), ERC20(NEW_CDAI_ADDRESS).balanceOf(_user)));\\n\\n        // approve cDai to compound contract\\n        cDaiContract.approve(NEW_CDAI_ADDRESS, uint(-1));\\n        // get dai from cDai contract\\n        require(cDaiContract.redeemUnderlying(_amount) == 0, \\\"Reedem Failed\\\");\\n\\n        // return to user balance we didn't spend\\n        uint cDaiBalance = cDaiContract.balanceOf(address(this));\\n        if (cDaiBalance > 0) {\\n            cDaiContract.transfer(_user, cDaiBalance);\\n        }\\n        // return dai we have to user\\n        ERC20(DAI_ADDRESS).transfer(_user, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Join.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./Gem.sol\\\";\\n\\nabstract contract Join {\\n    bytes32 public ilk;\\n\\n    function dec() virtual public view returns (uint);\\n    function gem() virtual public view returns (Gem);\\n    function join(address, uint) virtual public payable;\\n    function exit(address, uint) virtual public;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Gem.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract Gem {\\n    function dec() virtual public returns (uint);\\n    function gem() virtual public returns (Gem);\\n    function join(address, uint) virtual public payable;\\n    function exit(address, uint) virtual public;\\n\\n    function approve(address, uint) virtual public;\\n    function transfer(address, uint) virtual public returns (bool);\\n    function transferFrom(address, address, uint) virtual public returns (bool);\\n    function deposit() virtual public payable;\\n    function withdraw(uint) virtual public;\\n    function allowance(address, address) virtual public returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/compound/helpers/Exponential.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./CarefulMath.sol\\\";\\n\\ncontract Exponential is CarefulMath {\\n    uint constant expScale = 1e18;\\n    uint constant doubleScale = 1e36;\\n    uint constant halfExpScale = expScale/2;\\n    uint constant mantissaOne = expScale;\\n\\n    struct Exp {\\n        uint mantissa;\\n    }\\n\\n    struct Double {\\n        uint mantissa;\\n    }\\n\\n    /**\\n     * @dev Creates an exponential from numerator and denominator values.\\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\\n     *            or if `denom` is zero.\\n     */\\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\\n        if (err1 != MathError.NO_ERROR) {\\n            return (err1, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\\n    }\\n\\n    /**\\n     * @dev Adds two exponentials, returning a new exponential.\\n     */\\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\\n\\n        return (error, Exp({mantissa: result}));\\n    }\\n\\n    /**\\n     * @dev Subtracts two exponentials, returning a new exponential.\\n     */\\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\\n\\n        return (error, Exp({mantissa: result}));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\\n     */\\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n     */\\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, truncate(product));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n     */\\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return addUInt(truncate(product), addend);\\n    }\\n\\n    /**\\n     * @dev Divide an Exp by a scalar, returning a new Exp.\\n     */\\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\\n    }\\n\\n    /**\\n     * @dev Divide a scalar by an Exp, returning a new Exp.\\n     */\\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\\n        /*\\n          We are doing this as:\\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\\n\\n          How it works:\\n          Exp = a / b;\\n          Scalar = s;\\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\\n        */\\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n        return getExp(numerator, divisor.mantissa);\\n    }\\n\\n    /**\\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\\n     */\\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, truncate(fraction));\\n    }\\n\\n    /**\\n     * @dev Multiplies two exponentials, returning a new exponential.\\n     */\\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n\\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        // We add half the scale before dividing so that we get rounding instead of truncation.\\n        //  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717\\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\\n        if (err1 != MathError.NO_ERROR) {\\n            return (err1, Exp({mantissa: 0}));\\n        }\\n\\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\\n        assert(err2 == MathError.NO_ERROR);\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\\n    }\\n\\n    /**\\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\\n     */\\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\\n    }\\n\\n    /**\\n     * @dev Multiplies three exponentials, returning a new exponential.\\n     */\\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\\n        (MathError err, Exp memory ab) = mulExp(a, b);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, ab);\\n        }\\n        return mulExp(ab, c);\\n    }\\n\\n    /**\\n     * @dev Divides two exponentials, returning a new exponential.\\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\\n     */\\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n        return getExp(a.mantissa, b.mantissa);\\n    }\\n\\n    /**\\n     * @dev Truncates the given exp to a whole number value.\\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\n     */\\n    function truncate(Exp memory exp) pure internal returns (uint) {\\n        // Note: We are not using careful math here as we're performing a division that cannot fail\\n        return exp.mantissa / expScale;\\n    }\\n\\n    /**\\n     * @dev Checks if first Exp is less than second Exp.\\n     */\\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa < right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp <= right Exp.\\n     */\\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa <= right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp > right Exp.\\n     */\\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa > right.mantissa;\\n    }\\n\\n    /**\\n     * @dev returns true if Exp is exactly zero\\n     */\\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\\n        return value.mantissa == 0;\\n    }\\n\\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(uint a, uint b) pure internal returns (uint) {\\n        return sub_(a, b, \\\"subtraction underflow\\\");\\n    }\\n\\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\\n    }\\n\\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / expScale;\\n    }\\n\\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\\n    }\\n\\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / doubleScale;\\n    }\\n\\n    function mul_(uint a, uint b) pure internal returns (uint) {\\n        return mul_(a, b, \\\"multiplication overflow\\\");\\n    }\\n\\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n        uint c = a * b;\\n        require(c / a == b, errorMessage);\\n        return c;\\n    }\\n\\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\\n    }\\n\\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\\n        return div_(mul_(a, expScale), b.mantissa);\\n    }\\n\\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\\n    }\\n\\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Double memory b) pure internal returns (uint) {\\n        return div_(mul_(a, doubleScale), b.mantissa);\\n    }\\n\\n    function div_(uint a, uint b) pure internal returns (uint) {\\n        return div_(a, b, \\\"divide by zero\\\");\\n    }\\n\\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(uint a, uint b) pure internal returns (uint) {\\n        return add_(a, b, \\\"addition overflow\\\");\\n    }\\n\\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, errorMessage);\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/compound/helpers/CarefulMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ncontract CarefulMath {\\n\\n    /**\\n     * @dev Possible error codes that we can return\\n     */\\n    enum MathError {\\n        NO_ERROR,\\n        DIVISION_BY_ZERO,\\n        INTEGER_OVERFLOW,\\n        INTEGER_UNDERFLOW\\n    }\\n\\n    /**\\n    * @dev Multiplies two numbers, returns an error on overflow.\\n    */\\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        if (a == 0) {\\n            return (MathError.NO_ERROR, 0);\\n        }\\n\\n        uint c = a * b;\\n\\n        if (c / a != b) {\\n            return (MathError.INTEGER_OVERFLOW, 0);\\n        } else {\\n            return (MathError.NO_ERROR, c);\\n        }\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        if (b == 0) {\\n            return (MathError.DIVISION_BY_ZERO, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, a / b);\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        if (b <= a) {\\n            return (MathError.NO_ERROR, a - b);\\n        } else {\\n            return (MathError.INTEGER_UNDERFLOW, 0);\\n        }\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, returns an error on overflow.\\n    */\\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        uint c = a + b;\\n\\n        if (c >= a) {\\n            return (MathError.NO_ERROR, c);\\n        } else {\\n            return (MathError.INTEGER_OVERFLOW, 0);\\n        }\\n    }\\n\\n    /**\\n    * @dev add a and b and then subtract c\\n    */\\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\\n        (MathError err0, uint sum) = addUInt(a, b);\\n\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, 0);\\n        }\\n\\n        return subUInt(sum, c);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cream/helpers/CreamSaverHelper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../interfaces/CEtherInterface.sol\\\";\\nimport \\\"../../interfaces/CompoundOracleInterface.sol\\\";\\nimport \\\"../../interfaces/CTokenInterface.sol\\\";\\nimport \\\"../../interfaces/ComptrollerInterface.sol\\\";\\nimport \\\"../../interfaces/IFeeRecipient.sol\\\";\\n\\nimport \\\"../../utils/Discount.sol\\\";\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../DS/DSProxy.sol\\\";\\nimport \\\"../../compound/helpers/Exponential.sol\\\";\\nimport \\\"../../utils/BotRegistry.sol\\\";\\n\\nimport \\\"../../utils/SafeERC20.sol\\\";\\n\\n/// @title Utlity functions for cream contracts\\ncontract CreamSaverHelper is DSMath, Exponential {\\n\\n    using SafeERC20 for ERC20;\\n\\n    IFeeRecipient public constant feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);\\n\\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\\n\\n    uint public constant MANUAL_SERVICE_FEE = 400; // 0.25% Fee\\n    uint public constant AUTOMATIC_SERVICE_FEE = 333; // 0.3% Fee\\n\\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant CETH_ADDRESS = 0xD06527D5e56A3495252A528C4987003b712860eE;\\n    address public constant COMPTROLLER = 0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258;\\n\\n    address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;\\n\\n    /// @notice Helper method to payback the cream debt\\n    /// @dev If amount is bigger it will repay the whole debt and send the extra to the _user\\n    /// @param _amount Amount of tokens we want to repay\\n    /// @param _cBorrowToken Ctoken address we are repaying\\n    /// @param _borrowToken Token address we are repaying\\n    /// @param _user Owner of the cream position we are paying back\\n    function paybackDebt(uint _amount, address _cBorrowToken, address _borrowToken, address payable _user) internal {\\n        uint wholeDebt = CTokenInterface(_cBorrowToken).borrowBalanceCurrent(address(this));\\n\\n        if (_amount > wholeDebt) {\\n            if (_borrowToken == ETH_ADDRESS) {\\n                _user.transfer((_amount - wholeDebt));\\n            } else {\\n                ERC20(_borrowToken).safeTransfer(_user, (_amount - wholeDebt));\\n            }\\n\\n            _amount = wholeDebt;\\n        }\\n\\n        approveCToken(_borrowToken, _cBorrowToken);\\n\\n        if (_borrowToken == ETH_ADDRESS) {\\n            CEtherInterface(_cBorrowToken).repayBorrow{value: _amount}();\\n        } else {\\n            require(CTokenInterface(_cBorrowToken).repayBorrow(_amount) == 0);\\n        }\\n    }\\n\\n    /// @notice Calculates the fee amount\\n    /// @param _amount Amount that is converted\\n    /// @param _user Actuall user addr not DSProxy\\n    /// @param _gasCost Ether amount of gas we are spending for tx\\n    /// @param _cTokenAddr CToken addr. of token we are getting for the fee\\n    /// @return feeAmount The amount we took for the fee\\n    function getFee(uint _amount, address _user, uint _gasCost, address _cTokenAddr) internal returns (uint feeAmount) {\\n        uint fee = MANUAL_SERVICE_FEE;\\n\\n        if (BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin)) {\\n            fee = AUTOMATIC_SERVICE_FEE;\\n        }\\n\\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\\n\\n        if (Discount(DISCOUNT_ADDR).isCustomFeeSet(_user)) {\\n            fee = Discount(DISCOUNT_ADDR).getCustomServiceFee(_user);\\n        }\\n\\n        feeAmount = (fee == 0) ? 0 : (_amount / fee);\\n\\n        if (_gasCost != 0) {\\n            address oracle = ComptrollerInterface(COMPTROLLER).oracle();\\n\\n            uint ethTokenPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cTokenAddr);\\n\\n            _gasCost = wdiv(_gasCost, ethTokenPrice);\\n\\n            feeAmount = add(feeAmount, _gasCost);\\n        }\\n\\n        // fee can't go over 20% of the whole amount\\n        if (feeAmount > (_amount / 5)) {\\n            feeAmount = _amount / 5;\\n        }\\n\\n        address walletAddr = feeRecipient.getFeeAddr();\\n\\n\\n        if (tokenAddr == ETH_ADDRESS) {\\n            payable(walletAddr).transfer(feeAmount);\\n        } else {\\n            ERC20(tokenAddr).safeTransfer(walletAddr, feeAmount);\\n        }\\n    }\\n\\n    /// @notice Calculates the gas cost of transaction and send it to wallet\\n    /// @param _amount Amount that is converted\\n    /// @param _gasCost Ether amount of gas we are spending for tx\\n    /// @param _cTokenAddr CToken addr. of token we are getting for the fee\\n    /// @return feeAmount The amount we took for the fee\\n    function getGasCost(uint _amount, uint _gasCost, address _cTokenAddr) internal returns (uint feeAmount) {\\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\\n\\n        if (_gasCost != 0) {\\n            address oracle = ComptrollerInterface(COMPTROLLER).oracle();\\n\\n            uint ethTokenPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cTokenAddr);\\n\\n            feeAmount = wdiv(_gasCost, ethTokenPrice);\\n        }\\n\\n        // fee can't go over 20% of the whole amount\\n        if (feeAmount > (_amount / 5)) {\\n            feeAmount = _amount / 5;\\n        }\\n\\n        address walletAddr = feeRecipient.getFeeAddr();\\n\\n        if (tokenAddr == ETH_ADDRESS) {\\n            payable(walletAddr).transfer(feeAmount);\\n        } else {\\n            ERC20(tokenAddr).safeTransfer(walletAddr, feeAmount);\\n        }\\n    }\\n\\n    /// @notice Enters the market for the collatera and borrow tokens\\n    /// @param _cTokenAddrColl Collateral address we are entering the market in\\n    /// @param _cTokenAddrBorrow Borrow address we are entering the market in\\n    function enterMarket(address _cTokenAddrColl, address _cTokenAddrBorrow) internal {\\n        address[] memory markets = new address[](2);\\n        markets[0] = _cTokenAddrColl;\\n        markets[1] = _cTokenAddrBorrow;\\n\\n        ComptrollerInterface(COMPTROLLER).enterMarkets(markets);\\n    }\\n\\n    /// @notice Approves CToken contract to pull underlying tokens from the DSProxy\\n    /// @param _tokenAddr Token we are trying to approve\\n    /// @param _cTokenAddr Address which will gain the approval\\n    function approveCToken(address _tokenAddr, address _cTokenAddr) internal {\\n        if (_tokenAddr != ETH_ADDRESS) {\\n            ERC20(_tokenAddr).safeApprove(_cTokenAddr, uint(-1));\\n        }\\n    }\\n\\n    /// @notice Returns the underlying address of the cToken asset\\n    /// @param _cTokenAddress cToken address\\n    /// @return Token address of the cToken specified\\n    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\\n        if (_cTokenAddress == CETH_ADDRESS) {\\n            return ETH_ADDRESS;\\n        } else {\\n            return CTokenInterface(_cTokenAddress).underlying();\\n        }\\n    }\\n\\n    /// @notice Returns the owner of the DSProxy that called the contract\\n    function getUserAddress() internal view returns (address) {\\n        DSProxy proxy = DSProxy(uint160(address(this)));\\n\\n        return proxy.owner();\\n    }\\n\\n    /// @notice Returns the maximum amount of collateral available to withdraw\\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\\n    /// @param _cCollAddress Collateral we are getting the max value of\\n    /// @param _account Users account\\n    /// @return Returns the max. collateral amount in that token\\n    function getMaxCollateral(address _cCollAddress, address _account) public returns (uint) {\\n        (, uint liquidityInEth, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\\n        uint usersBalance = CTokenInterface(_cCollAddress).balanceOfUnderlying(_account);\\n        address oracle = ComptrollerInterface(COMPTROLLER).oracle();\\n\\n        if (liquidityInEth == 0) return usersBalance;\\n\\n        CTokenInterface(_cCollAddress).accrueInterest();\\n\\n         if (_cCollAddress == CETH_ADDRESS) {\\n             if (liquidityInEth > usersBalance) return usersBalance;\\n\\n             return sub(liquidityInEth, (liquidityInEth / 100));\\n         }\\n\\n        uint ethPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cCollAddress);\\n        uint liquidityInToken = wdiv(liquidityInEth, ethPrice);\\n\\n        if (liquidityInToken > usersBalance) return usersBalance;\\n\\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\\n    }\\n\\n    /// @notice Returns the maximum amount of borrow amount available\\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\\n    /// @param _cBorrowAddress Borrow token we are getting the max value of\\n    /// @param _account Users account\\n    /// @return Returns the max. borrow amount in that token\\n    function getMaxBorrow(address _cBorrowAddress, address _account) public returns (uint) {\\n        (, uint liquidityInEth, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\\n        address oracle = ComptrollerInterface(COMPTROLLER).oracle();\\n\\n        CTokenInterface(_cBorrowAddress).accrueInterest();\\n\\n        if (_cBorrowAddress == CETH_ADDRESS) return sub(liquidityInEth, (liquidityInEth / 100));\\n\\n        uint ethPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cBorrowAddress);\\n        uint liquidityInToken = wdiv(liquidityInEth, ethPrice);\\n\\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/CEtherInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract CEtherInterface {\\n    function mint() external virtual payable;\\n    function repayBorrow() external virtual payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/CompoundOracleInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract CompoundOracleInterface {\\n    function getUnderlyingPrice(address cToken) external view virtual returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/cream/saver/CreamSaverFlashProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../exchange/SaverExchangeCore.sol\\\";\\nimport \\\"../../interfaces/CTokenInterface.sol\\\";\\nimport \\\"../../utils/Discount.sol\\\";\\nimport \\\"../helpers/CreamSaverHelper.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\n\\n/// @title Implements the actual logic of Repay/Boost with FL\\ncontract CreamSaverFlashProxy is SaverExchangeCore, CreamSaverHelper  {\\n\\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\\n\\n    using SafeERC20 for ERC20;\\n\\n    /// @notice Repays the position and sends tokens back for FL\\n    /// @param _exData Exchange data\\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]\\n    /// @param _gasCost Gas cost for transaction\\n    /// @param _flashLoanData Data about FL [amount, fee]\\n    function flashRepay(\\n        ExchangeData memory _exData,\\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\\n        uint256 _gasCost,\\n        uint[2] memory _flashLoanData // amount, fee\\n    ) public payable {\\n        enterMarket(_cAddresses[0], _cAddresses[1]);\\n\\n        address payable user = payable(getUserAddress());\\n        uint flashBorrowed = _flashLoanData[0] + _flashLoanData[1];\\n\\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\\n\\n        // draw max coll\\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(maxColl) == 0);\\n\\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\\n\\n        uint swapAmount = 0;\\n\\n        if (collToken != borrowToken) {\\n            // swap max coll + loanAmount\\n            _exData.srcAmount = maxColl + _flashLoanData[0];\\n            (,swapAmount) = _sell(_exData);\\n\\n            // get fee\\n            swapAmount -= getFee(swapAmount, user, _gasCost, _cAddresses[1]);\\n        } else {\\n            swapAmount = (maxColl + _flashLoanData[0]);\\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\\n        }\\n\\n        // payback debt\\n        paybackDebt(swapAmount, _cAddresses[1], borrowToken, user);\\n\\n        // draw collateral for loanAmount + loanFee\\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(flashBorrowed) == 0);\\n\\n        // repay flash loan\\n        returnFlashLoan(collToken, flashBorrowed);\\n\\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \\\"CreamRepay\\\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\\n    }\\n\\n    /// @notice Boosts the position and sends tokens back for FL\\n    /// @param _exData Exchange data\\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]\\n    /// @param _gasCost Gas cost for specific transaction\\n    /// @param _flashLoanData Data about FL [amount, fee]\\n    function flashBoost(\\n        ExchangeData memory _exData,\\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\\n        uint256 _gasCost,\\n        uint[2] memory _flashLoanData // amount, fee\\n    ) public payable {\\n        enterMarket(_cAddresses[0], _cAddresses[1]);\\n\\n        address payable user = payable(getUserAddress());\\n        uint flashBorrowed = _flashLoanData[0] + _flashLoanData[1];\\n\\n        // borrow max amount\\n        uint borrowAmount = getMaxBorrow(_cAddresses[1], address(this));\\n        require(CTokenInterface(_cAddresses[1]).borrow(borrowAmount) == 0);\\n\\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\\n\\n        uint swapAmount = 0;\\n\\n        if (collToken != borrowToken) {\\n            // get dfs fee\\n            borrowAmount -= getFee((borrowAmount + _flashLoanData[0]), user, _gasCost, _cAddresses[1]);\\n            _exData.srcAmount = (borrowAmount + _flashLoanData[0]);\\n\\n            (,swapAmount) = _sell(_exData);\\n        } else {\\n            swapAmount = (borrowAmount + _flashLoanData[0]);\\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\\n        }\\n\\n        // deposit swaped collateral\\n        depositCollateral(collToken, _cAddresses[0], swapAmount);\\n\\n        // borrow token to repay flash loan\\n        require(CTokenInterface(_cAddresses[1]).borrow(flashBorrowed) == 0);\\n\\n        // repay flash loan\\n        returnFlashLoan(borrowToken, flashBorrowed);\\n\\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \\\"CreamBoost\\\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\\n    }\\n\\n    /// @notice Helper method to deposit tokens in Compound\\n    /// @param _collToken Token address of the collateral\\n    /// @param _cCollToken CToken address of the collateral\\n    /// @param _depositAmount Amount to deposit\\n    function depositCollateral(address _collToken, address _cCollToken, uint _depositAmount) internal {\\n        approveCToken(_collToken, _cCollToken);\\n\\n        if (_collToken != ETH_ADDRESS) {\\n            require(CTokenInterface(_cCollToken).mint(_depositAmount) == 0);\\n        } else {\\n            CEtherInterface(_cCollToken).mint{value: _depositAmount}(); // reverts on fail\\n        }\\n    }\\n\\n    /// @notice Returns the tokens/ether to the msg.sender which is the FL contract\\n    /// @param _tokenAddr Address of token which we return\\n    /// @param _amount Amount to return\\n    function returnFlashLoan(address _tokenAddr, uint _amount) internal {\\n        if (_tokenAddr != ETH_ADDRESS) {\\n            ERC20(_tokenAddr).safeTransfer(msg.sender, _amount);\\n        }\\n\\n        msg.sender.transfer(address(this).balance);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/SaverExchangeCore.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../DS/DSMath.sol\\\";\\nimport \\\"../interfaces/TokenInterface.sol\\\";\\nimport \\\"../interfaces/ExchangeInterfaceV2.sol\\\";\\nimport \\\"../utils/ZrxAllowlist.sol\\\";\\nimport \\\"./SaverExchangeHelper.sol\\\";\\nimport \\\"./SaverExchangeRegistry.sol\\\";\\n\\ncontract SaverExchangeCore is SaverExchangeHelper, DSMath {\\n\\n    // first is empty to keep the legacy order in place\\n    enum ExchangeType { _, OASIS, KYBER, UNISWAP, ZEROX }\\n\\n    enum ActionType { SELL, BUY }\\n\\n    struct ExchangeData {\\n        address srcAddr;\\n        address destAddr;\\n        uint srcAmount;\\n        uint destAmount;\\n        uint minPrice;\\n        address wrapper;\\n        address exchangeAddr;\\n        bytes callData;\\n        uint256 price0x;\\n    }\\n\\n    /// @notice Internal method that preforms a sell on 0x/on-chain\\n    /// @dev Usefull for other DFS contract to integrate for exchanging\\n    /// @param exData Exchange data struct\\n    /// @return (address, uint) Address of the wrapper used and destAmount\\n    function _sell(ExchangeData memory exData) internal returns (address, uint) {\\n\\n        address wrapper;\\n        uint swapedTokens;\\n        bool success;\\n        uint tokensLeft = exData.srcAmount;\\n\\n        // if selling eth, convert to weth\\n        if (exData.srcAddr == KYBER_ETH_ADDRESS) {\\n            exData.srcAddr = ethToWethAddr(exData.srcAddr);\\n            TokenInterface(WETH_ADDRESS).deposit.value(exData.srcAmount)();\\n        }\\n\\n        // Try 0x first and then fallback on specific wrapper\\n        if (exData.price0x > 0) {\\n            approve0xProxy(exData.srcAddr, exData.srcAmount);\\n\\n            uint ethAmount = getProtocolFee(exData.srcAddr, exData.srcAmount);\\n            (success, swapedTokens, tokensLeft) = takeOrder(exData, ethAmount, ActionType.SELL);\\n\\n            if (success) {\\n                wrapper = exData.exchangeAddr;\\n            }\\n        }\\n\\n        // fallback to desired wrapper if 0x failed\\n        if (!success) {\\n            swapedTokens = saverSwap(exData, ActionType.SELL);\\n            wrapper = exData.wrapper;\\n        }\\n\\n        require(getBalance(exData.destAddr) >= wmul(exData.minPrice, exData.srcAmount), \\\"Final amount isn't correct\\\");\\n\\n        // if anything is left in weth, pull it to user as eth\\n        if (getBalance(WETH_ADDRESS) > 0) {\\n            TokenInterface(WETH_ADDRESS).withdraw(\\n                TokenInterface(WETH_ADDRESS).balanceOf(address(this))\\n            );\\n        }\\n\\n        return (wrapper, swapedTokens);\\n    }\\n\\n    /// @notice Internal method that preforms a buy on 0x/on-chain\\n    /// @dev Usefull for other DFS contract to integrate for exchanging\\n    /// @param exData Exchange data struct\\n    /// @return (address, uint) Address of the wrapper used and srcAmount\\n    function _buy(ExchangeData memory exData) internal returns (address, uint) {\\n\\n        address wrapper;\\n        uint swapedTokens;\\n        bool success;\\n\\n        require(exData.destAmount != 0, \\\"Dest amount must be specified\\\");\\n\\n        // if selling eth, convert to weth\\n        if (exData.srcAddr == KYBER_ETH_ADDRESS) {\\n            exData.srcAddr = ethToWethAddr(exData.srcAddr);\\n            TokenInterface(WETH_ADDRESS).deposit.value(exData.srcAmount)();\\n        }\\n\\n        if (exData.price0x > 0) {\\n            approve0xProxy(exData.srcAddr, exData.srcAmount);\\n\\n            uint ethAmount = getProtocolFee(exData.srcAddr, exData.srcAmount);\\n            (success, swapedTokens,) = takeOrder(exData, ethAmount, ActionType.BUY);\\n\\n            if (success) {\\n                wrapper = exData.exchangeAddr;\\n            }\\n        }\\n\\n        // fallback to desired wrapper if 0x failed\\n        if (!success) {\\n            swapedTokens = saverSwap(exData, ActionType.BUY);\\n            wrapper = exData.wrapper;\\n        }\\n\\n        require(getBalance(exData.destAddr) >= exData.destAmount, \\\"Final amount isn't correct\\\");\\n\\n        // if anything is left in weth, pull it to user as eth\\n        if (getBalance(WETH_ADDRESS) > 0) {\\n            TokenInterface(WETH_ADDRESS).withdraw(\\n                TokenInterface(WETH_ADDRESS).balanceOf(address(this))\\n            );\\n        }\\n\\n        return (wrapper, getBalance(exData.destAddr));\\n    }\\n\\n    /// @notice Takes order from 0x and returns bool indicating if it is successful\\n    /// @param _exData Exchange data\\n    /// @param _ethAmount Ether fee needed for 0x order\\n    function takeOrder(\\n        ExchangeData memory _exData,\\n        uint256 _ethAmount,\\n        ActionType _type\\n    ) private returns (bool success, uint256, uint256) {\\n\\n        // write in the exact amount we are selling/buing in an order\\n        if (_type == ActionType.SELL) {\\n            writeUint256(_exData.callData, 36, _exData.srcAmount);\\n        } else {\\n            writeUint256(_exData.callData, 36, _exData.destAmount);\\n        }\\n\\n        if (ZrxAllowlist(ZRX_ALLOWLIST_ADDR).isNonPayableAddr(_exData.exchangeAddr)) {\\n            _ethAmount = 0;\\n        }\\n\\n        uint256 tokensBefore = getBalance(_exData.destAddr);\\n\\n        if (ZrxAllowlist(ZRX_ALLOWLIST_ADDR).isZrxAddr(_exData.exchangeAddr)) {\\n            (success, ) = _exData.exchangeAddr.call{value: _ethAmount}(_exData.callData);\\n        } else {\\n            success = false;\\n        }\\n\\n        uint256 tokensSwaped = 0;\\n        uint256 tokensLeft = _exData.srcAmount;\\n\\n        if (success) {\\n            // check to see if any _src tokens are left over after exchange\\n            tokensLeft = getBalance(_exData.srcAddr);\\n\\n            // convert weth -> eth if needed\\n            if (_exData.destAddr == KYBER_ETH_ADDRESS) {\\n                TokenInterface(WETH_ADDRESS).withdraw(\\n                    TokenInterface(WETH_ADDRESS).balanceOf(address(this))\\n                );\\n            }\\n\\n            // get the current balance of the swaped tokens\\n            tokensSwaped = getBalance(_exData.destAddr) - tokensBefore;\\n        }\\n\\n        return (success, tokensSwaped, tokensLeft);\\n    }\\n\\n    /// @notice Calls wraper contract for exchage to preform an on-chain swap\\n    /// @param _exData Exchange data struct\\n    /// @param _type Type of action SELL|BUY\\n    /// @return swapedTokens For Sell that the destAmount, for Buy thats the srcAmount\\n    function saverSwap(ExchangeData memory _exData, ActionType _type) internal returns (uint swapedTokens) {\\n        require(SaverExchangeRegistry(SAVER_EXCHANGE_REGISTRY).isWrapper(_exData.wrapper), \\\"Wrapper is not valid\\\");\\n\\n        uint ethValue = 0;\\n\\n        ERC20(_exData.srcAddr).safeTransfer(_exData.wrapper, _exData.srcAmount);\\n\\n        if (_type == ActionType.SELL) {\\n            swapedTokens = ExchangeInterfaceV2(_exData.wrapper).\\n                    sell{value: ethValue}(_exData.srcAddr, _exData.destAddr, _exData.srcAmount);\\n        } else {\\n            swapedTokens = ExchangeInterfaceV2(_exData.wrapper).\\n                    buy{value: ethValue}(_exData.srcAddr, _exData.destAddr, _exData.destAmount);\\n        }\\n    }\\n\\n    function writeUint256(bytes memory _b, uint256 _index, uint _input) internal pure {\\n        if (_b.length < _index + 32) {\\n            revert(\\\"Incorrent lengt while writting bytes32\\\");\\n        }\\n\\n        bytes32 input = bytes32(_input);\\n\\n        _index += 32;\\n\\n        // Read the bytes32 from array memory\\n        assembly {\\n            mstore(add(_b, _index), input)\\n        }\\n    }\\n\\n    /// @notice Converts Kybers Eth address -> Weth\\n    /// @param _src Input address\\n    function ethToWethAddr(address _src) internal pure returns (address) {\\n        return _src == KYBER_ETH_ADDRESS ? WETH_ADDRESS : _src;\\n    }\\n\\n    /// @notice Calculates protocol fee\\n    /// @param _srcAddr selling token address (if eth should be WETH)\\n    /// @param _srcAmount amount we are selling\\n    function getProtocolFee(address _srcAddr, uint256 _srcAmount) internal view returns(uint256) {\\n        // if we are not selling ETH msg value is always the protocol fee\\n        if (_srcAddr != WETH_ADDRESS) return address(this).balance;\\n\\n        // if msg value is larger than srcAmount, that means that msg value is protocol fee + srcAmount, so we subsctract srcAmount from msg value\\n        // we have an edge case here when protocol fee is higher than selling amount\\n        if (address(this).balance > _srcAmount) return address(this).balance - _srcAmount;\\n\\n        // if msg value is lower than src amount, that means that srcAmount isn't included in msg value, so we return msg value\\n        return address(this).balance;\\n    }\\n\\n    function packExchangeData(ExchangeData memory _exData) public pure returns(bytes memory) {\\n        // splitting in two different bytes and encoding all because of stack too deep in decoding part\\n\\n        bytes memory part1 = abi.encode(\\n            _exData.srcAddr,\\n            _exData.destAddr,\\n            _exData.srcAmount,\\n            _exData.destAmount\\n        );\\n\\n        bytes memory part2 = abi.encode(\\n            _exData.minPrice,\\n            _exData.wrapper,\\n            _exData.exchangeAddr,\\n            _exData.callData,\\n            _exData.price0x\\n        );\\n\\n\\n        return abi.encode(part1, part2);\\n    }\\n\\n    function unpackExchangeData(bytes memory _data) public pure returns(ExchangeData memory _exData) {\\n        (\\n            bytes memory part1,\\n            bytes memory part2\\n        ) = abi.decode(_data, (bytes,bytes));\\n\\n        (\\n            _exData.srcAddr,\\n            _exData.destAddr,\\n            _exData.srcAmount,\\n            _exData.destAmount\\n        ) = abi.decode(part1, (address,address,uint256,uint256));\\n\\n        (\\n            _exData.minPrice,\\n            _exData.wrapper,\\n            _exData.exchangeAddr,\\n            _exData.callData,\\n            _exData.price0x\\n        )\\n        = abi.decode(part2, (uint256,address,address,bytes,uint256));\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external virtual payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ExchangeInterfaceV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface ExchangeInterfaceV2 {\\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external payable returns (uint);\\n\\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external payable returns(uint);\\n\\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) external view returns (uint);\\n\\n    function getBuyRate(address _srcAddr, address _destAddr, uint _srcAmount) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/SaverExchangeHelper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../utils/SafeERC20.sol\\\";\\nimport \\\"../utils/Discount.sol\\\";\\n\\ncontract SaverExchangeHelper {\\n\\n    using SafeERC20 for ERC20;\\n\\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    address public constant DISCOUNT_ADDRESS = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\\n    address public constant SAVER_EXCHANGE_REGISTRY = 0x25dd3F51e0C3c3Ff164DDC02A8E4D65Bb9cBB12D;\\n\\n    address public constant ERC20_PROXY_0X = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;\\n    address public constant ZRX_ALLOWLIST_ADDR = 0x4BA1f38427b33B8ab7Bb0490200dAE1F1C36823F;\\n\\n\\n    function getDecimals(address _token) internal view returns (uint256) {\\n        if (_token == KYBER_ETH_ADDRESS) return 18;\\n\\n        return ERC20(_token).decimals();\\n    }\\n\\n    function getBalance(address _tokenAddr) internal view returns (uint balance) {\\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\\n            balance = address(this).balance;\\n        } else {\\n            balance = ERC20(_tokenAddr).balanceOf(address(this));\\n        }\\n    }\\n\\n    function approve0xProxy(address _tokenAddr, uint _amount) internal {\\n        if (_tokenAddr != KYBER_ETH_ADDRESS) {\\n            ERC20(_tokenAddr).safeApprove(address(ERC20_PROXY_0X), _amount);\\n        }\\n    }\\n\\n    function sendLeftover(address _srcAddr, address _destAddr, address payable _to) internal {\\n        // send back any leftover ether or tokens\\n        if (address(this).balance > 0) {\\n            _to.transfer(address(this).balance);\\n        }\\n\\n        if (getBalance(_srcAddr) > 0) {\\n            ERC20(_srcAddr).safeTransfer(_to, getBalance(_srcAddr));\\n        }\\n\\n        if (getBalance(_destAddr) > 0) {\\n            ERC20(_destAddr).safeTransfer(_to, getBalance(_destAddr));\\n        }\\n    }\\n\\n    function sliceUint(bytes memory bs, uint256 start) internal pure returns (uint256) {\\n        require(bs.length >= start + 32, \\\"slicing out of range\\\");\\n\\n        uint256 x;\\n        assembly {\\n            x := mload(add(bs, add(0x20, start)))\\n        }\\n\\n        return x;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/saver/MCDSaverProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../utils/Discount.sol\\\";\\n\\nimport \\\"../../interfaces/Spotter.sol\\\";\\nimport \\\"../../interfaces/Jug.sol\\\";\\nimport \\\"../../interfaces/DaiJoin.sol\\\";\\nimport \\\"../../interfaces/Join.sol\\\";\\n\\nimport \\\"./MCDSaverProxyHelper.sol\\\";\\nimport \\\"../../utils/BotRegistry.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeCore.sol\\\";\\n\\n/// @title Implements Boost and Repay for MCD CDPs\\ncontract MCDSaverProxy is DFSExchangeCore, MCDSaverProxyHelper {\\n\\n    uint public constant MANUAL_SERVICE_FEE = 400; // 0.25% Fee\\n    uint public constant AUTOMATIC_SERVICE_FEE = 333; // 0.3% Fee\\n\\n    bytes32 public constant ETH_ILK = 0x4554482d41000000000000000000000000000000000000000000000000000000;\\n\\n    address public constant VAT_ADDRESS = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\\n    address public constant SPOTTER_ADDRESS = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;\\n    address public constant DAI_JOIN_ADDRESS = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\\n    address public constant JUG_ADDRESS = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n\\n    address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;\\n\\n    Vat public constant vat = Vat(VAT_ADDRESS);\\n    DaiJoin public constant daiJoin = DaiJoin(DAI_JOIN_ADDRESS);\\n    Spotter public constant spotter = Spotter(SPOTTER_ADDRESS);\\n\\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\\n\\n    /// @notice Repay - draws collateral, converts to Dai and repays the debt\\n    /// @dev Must be called by the DSProxy contract that owns the CDP\\n    function repay(\\n        ExchangeData memory _exchangeData,\\n        uint _cdpId,\\n        uint _gasCost,\\n        address _joinAddr,\\n        ManagerType _managerType\\n    ) public payable {\\n\\n        address managerAddr = getManagerAddr(_managerType);\\n\\n        address user = getOwner(Manager(managerAddr), _cdpId);\\n        bytes32 ilk = Manager(managerAddr).ilks(_cdpId);\\n\\n        drawCollateral(managerAddr, _cdpId, _joinAddr, _exchangeData.srcAmount);\\n\\n        _exchangeData.user = user;\\n        _exchangeData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\\n        (, uint daiAmount) = _sell(_exchangeData);\\n\\n        daiAmount -= takeFee(_gasCost, daiAmount);\\n\\n        paybackDebt(managerAddr, _cdpId, ilk, daiAmount, user);\\n\\n        // if there is some eth left (0x fee), return it to user\\n        if (address(this).balance > 0) {\\n            tx.origin.transfer(address(this).balance);\\n        }\\n\\n        logger.Log(address(this), msg.sender, \\\"MCDRepay\\\", abi.encode(_cdpId, user, _exchangeData.srcAmount, daiAmount));\\n\\n    }\\n\\n    /// @notice Boost - draws Dai, converts to collateral and adds to CDP\\n    /// @dev Must be called by the DSProxy contract that owns the CDP\\n    function boost(\\n        ExchangeData memory _exchangeData,\\n        uint _cdpId,\\n        uint _gasCost,\\n        address _joinAddr,\\n        ManagerType _managerType\\n    ) public payable {\\n\\n        address managerAddr = getManagerAddr(_managerType);\\n\\n        address user = getOwner(Manager(managerAddr), _cdpId);\\n        bytes32 ilk = Manager(managerAddr).ilks(_cdpId);\\n\\n        uint daiDrawn = drawDai(managerAddr, _cdpId, ilk, _exchangeData.srcAmount);\\n\\n        _exchangeData.user = user;\\n        _exchangeData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\\n        _exchangeData.srcAmount = daiDrawn - takeFee(_gasCost, daiDrawn);\\n        (, uint swapedColl) = _sell(_exchangeData);\\n\\n        addCollateral(managerAddr, _cdpId, _joinAddr, swapedColl);\\n\\n        // if there is some eth left (0x fee), return it to user\\n        if (address(this).balance > 0) {\\n            tx.origin.transfer(address(this).balance);\\n        }\\n\\n        logger.Log(address(this), msg.sender, \\\"MCDBoost\\\", abi.encode(_cdpId, user, _exchangeData.srcAmount, swapedColl));\\n    }\\n\\n    /// @notice Draws Dai from the CDP\\n    /// @dev If _daiAmount is bigger than max available we'll draw max\\n    /// @param _managerAddr Address of the CDP Manager\\n    /// @param _cdpId Id of the CDP\\n    /// @param _ilk Ilk of the CDP\\n    /// @param _daiAmount Amount of Dai to draw\\n    function drawDai(address _managerAddr, uint _cdpId, bytes32 _ilk, uint _daiAmount) internal returns (uint) {\\n        uint rate = Jug(JUG_ADDRESS).drip(_ilk);\\n        uint daiVatBalance = vat.dai(Manager(_managerAddr).urns(_cdpId));\\n\\n        uint maxAmount = getMaxDebt(_managerAddr, _cdpId, _ilk);\\n\\n        if (_daiAmount >= maxAmount) {\\n            _daiAmount = sub(maxAmount, 1);\\n        }\\n\\n        Manager(_managerAddr).frob(_cdpId, int(0), normalizeDrawAmount(_daiAmount, rate, daiVatBalance));\\n        Manager(_managerAddr).move(_cdpId, address(this), toRad(_daiAmount));\\n\\n        if (vat.can(address(this), address(DAI_JOIN_ADDRESS)) == 0) {\\n            vat.hope(DAI_JOIN_ADDRESS);\\n        }\\n\\n        DaiJoin(DAI_JOIN_ADDRESS).exit(address(this), _daiAmount);\\n\\n        return _daiAmount;\\n    }\\n\\n    /// @notice Adds collateral to the CDP\\n    /// @param _managerAddr Address of the CDP Manager\\n    /// @param _cdpId Id of the CDP\\n    /// @param _joinAddr Address of the join contract for the CDP collateral\\n    /// @param _amount Amount of collateral to add\\n    function addCollateral(address _managerAddr, uint _cdpId, address _joinAddr, uint _amount) internal {\\n        int convertAmount = 0;\\n\\n        if (isEthJoinAddr(_joinAddr)) {\\n            Join(_joinAddr).gem().deposit{value: _amount}();\\n            convertAmount = toPositiveInt(_amount);\\n        } else {\\n            convertAmount = toPositiveInt(convertTo18(_joinAddr, _amount));\\n        }\\n\\n        ERC20(address(Join(_joinAddr).gem())).safeApprove(_joinAddr, _amount);\\n\\n        Join(_joinAddr).join(address(this), _amount);\\n\\n        vat.frob(\\n            Manager(_managerAddr).ilks(_cdpId),\\n            Manager(_managerAddr).urns(_cdpId),\\n            address(this),\\n            address(this),\\n            convertAmount,\\n            0\\n        );\\n\\n    }\\n\\n    /// @notice Draws collateral and returns it to DSProxy\\n    /// @param _managerAddr Address of the CDP Manager\\n    /// @dev If _amount is bigger than max available we'll draw max\\n    /// @param _cdpId Id of the CDP\\n    /// @param _joinAddr Address of the join contract for the CDP collateral\\n    /// @param _amount Amount of collateral to draw\\n    function drawCollateral(address _managerAddr, uint _cdpId, address _joinAddr, uint _amount) internal returns (uint) {\\n        uint frobAmount = _amount;\\n\\n        if (Join(_joinAddr).dec() != 18) {\\n            frobAmount = _amount * (10 ** (18 - Join(_joinAddr).dec()));\\n        }\\n\\n        Manager(_managerAddr).frob(_cdpId, -toPositiveInt(frobAmount), 0);\\n        Manager(_managerAddr).flux(_cdpId, address(this), frobAmount);\\n\\n        Join(_joinAddr).exit(address(this), _amount);\\n\\n        if (isEthJoinAddr(_joinAddr)) {\\n            Join(_joinAddr).gem().withdraw(_amount); // Weth -> Eth\\n        }\\n\\n        return _amount;\\n    }\\n\\n    /// @notice Paybacks Dai debt\\n    /// @param _managerAddr Address of the CDP Manager\\n    /// @dev If the _daiAmount is bigger than the whole debt, returns extra Dai\\n    /// @param _cdpId Id of the CDP\\n    /// @param _ilk Ilk of the CDP\\n    /// @param _daiAmount Amount of Dai to payback\\n    /// @param _owner Address that owns the DSProxy that owns the CDP\\n    function paybackDebt(address _managerAddr, uint _cdpId, bytes32 _ilk, uint _daiAmount, address _owner) internal {\\n        address urn = Manager(_managerAddr).urns(_cdpId);\\n\\n        uint wholeDebt = getAllDebt(VAT_ADDRESS, urn, urn, _ilk);\\n\\n        if (_daiAmount > wholeDebt) {\\n            ERC20(DAI_ADDRESS).transfer(_owner, sub(_daiAmount, wholeDebt));\\n            _daiAmount = wholeDebt;\\n        }\\n\\n        if (ERC20(DAI_ADDRESS).allowance(address(this), DAI_JOIN_ADDRESS) == 0) {\\n            ERC20(DAI_ADDRESS).approve(DAI_JOIN_ADDRESS, uint(-1));\\n        }\\n\\n        daiJoin.join(urn, _daiAmount);\\n\\n        Manager(_managerAddr).frob(_cdpId, 0, normalizePaybackAmount(VAT_ADDRESS, urn, _ilk));\\n    }\\n\\n    /// @notice Gets the maximum amount of collateral available to draw\\n    /// @param _managerAddr Address of the CDP Manager\\n    /// @param _cdpId Id of the CDP\\n    /// @param _ilk Ilk of the CDP\\n    /// @param _joinAddr Joind address of collateral\\n    /// @dev Substracts 10 wei to aviod rounding error later on\\n    function getMaxCollateral(address _managerAddr, uint _cdpId, bytes32 _ilk, address _joinAddr) public view returns (uint) {\\n        uint price = getPrice(_ilk);\\n\\n        (uint collateral, uint debt) = getCdpInfo(Manager(_managerAddr), _cdpId, _ilk);\\n\\n        (, uint mat) = Spotter(SPOTTER_ADDRESS).ilks(_ilk);\\n\\n        uint maxCollateral = sub(collateral, (div(mul(mat, debt), price)));\\n\\n        uint normalizeMaxCollateral = maxCollateral / (10 ** (18 - Join(_joinAddr).dec()));\\n\\n        // take one percent due to precision issues\\n        return normalizeMaxCollateral * 99 / 100;\\n    }\\n\\n    /// @notice Gets the maximum amount of debt available to generate\\n    /// @param _managerAddr Address of the CDP Manager\\n    /// @param _cdpId Id of the CDP\\n    /// @param _ilk Ilk of the CDP\\n    /// @dev Substracts 10 wei to aviod rounding error later on\\n    function getMaxDebt(address _managerAddr, uint _cdpId, bytes32 _ilk) public virtual view returns (uint) {\\n        uint price = getPrice(_ilk);\\n\\n        (, uint mat) = spotter.ilks(_ilk);\\n        (uint collateral, uint debt) = getCdpInfo(Manager(_managerAddr), _cdpId, _ilk);\\n\\n        return sub(sub(div(mul(collateral, price), mat), debt), 10);\\n    }\\n\\n    /// @notice Gets a price of the asset\\n    /// @param _ilk Ilk of the CDP\\n    function getPrice(bytes32 _ilk) public view returns (uint) {\\n        (, uint mat) = spotter.ilks(_ilk);\\n        (,,uint spot,,) = vat.ilks(_ilk);\\n\\n        return rmul(rmul(spot, spotter.par()), mat);\\n    }\\n\\n    function isAutomation() internal view returns(bool) {\\n        return BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin);\\n    }\\n\\n    function takeFee(uint256 _gasCost, uint _amount) internal returns(uint) {\\n        if (_gasCost > 0) {\\n            uint ethDaiPrice = getPrice(ETH_ILK);\\n            uint feeAmount = rmul(_gasCost, ethDaiPrice);\\n\\n            if (feeAmount > _amount / 5) {\\n                feeAmount = _amount / 5;\\n            }\\n\\n            address walletAddr = _feeRecipient.getFeeAddr();\\n\\n            ERC20(DAI_ADDRESS).transfer(walletAddr, feeAmount);\\n\\n            return feeAmount;\\n        }\\n\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Spotter.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./PipInterface.sol\\\";\\n\\nabstract contract Spotter {\\n    struct Ilk {\\n        PipInterface pip;\\n        uint256 mat;\\n    }\\n\\n    mapping (bytes32 => Ilk) public ilks;\\n\\n    uint256 public par;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Jug.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract Jug {\\n    struct Ilk {\\n        uint256 duty;\\n        uint256  rho;\\n    }\\n\\n    mapping (bytes32 => Ilk) public ilks;\\n\\n    function drip(bytes32) public virtual returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/DaiJoin.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./Vat.sol\\\";\\nimport \\\"./Gem.sol\\\";\\n\\nabstract contract DaiJoin {\\n    function vat() public virtual returns (Vat);\\n    function dai() public virtual returns (Gem);\\n    function join(address, uint) public virtual payable;\\n    function exit(address, uint) public virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/saver/MCDSaverProxyHelper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../DS/DSProxy.sol\\\";\\nimport \\\"../../interfaces/Manager.sol\\\";\\nimport \\\"../../interfaces/Join.sol\\\";\\nimport \\\"../../interfaces/Vat.sol\\\";\\n\\n/// @title Helper methods for MCDSaverProxy\\ncontract MCDSaverProxyHelper is DSMath {\\n\\n    enum ManagerType { MCD, BPROTOCOL }\\n\\n    /// @notice Returns a normalized debt _amount based on the current rate\\n    /// @param _amount Amount of dai to be normalized\\n    /// @param _rate Current rate of the stability fee\\n    /// @param _daiVatBalance Balance od Dai in the Vat for that CDP\\n    function normalizeDrawAmount(uint _amount, uint _rate, uint _daiVatBalance) internal pure returns (int dart) {\\n        if (_daiVatBalance < mul(_amount, RAY)) {\\n            dart = toPositiveInt(sub(mul(_amount, RAY), _daiVatBalance) / _rate);\\n            dart = mul(uint(dart), _rate) < mul(_amount, RAY) ? dart + 1 : dart;\\n        }\\n    }\\n\\n    /// @notice Converts a number to Rad percision\\n    /// @param _wad The input number in wad percision\\n    function toRad(uint _wad) internal pure returns (uint) {\\n        return mul(_wad, 10 ** 27);\\n    }\\n\\n    /// @notice Converts a number to 18 decimal percision\\n    /// @param _joinAddr Join address of the collateral\\n    /// @param _amount Number to be converted\\n    function convertTo18(address _joinAddr, uint256 _amount) internal view returns (uint256) {\\n        return mul(_amount, 10 ** (18 - Join(_joinAddr).dec()));\\n    }\\n\\n    /// @notice Converts a uint to int and checks if positive\\n    /// @param _x Number to be converted\\n    function toPositiveInt(uint _x) internal pure returns (int y) {\\n        y = int(_x);\\n        require(y >= 0, \\\"int-overflow\\\");\\n    }\\n\\n    /// @notice Gets Dai amount in Vat which can be added to Cdp\\n    /// @param _vat Address of Vat contract\\n    /// @param _urn Urn of the Cdp\\n    /// @param _ilk Ilk of the Cdp\\n    function normalizePaybackAmount(address _vat, address _urn, bytes32 _ilk) internal view returns (int amount) {\\n        uint dai = Vat(_vat).dai(_urn);\\n\\n        (, uint rate,,,) = Vat(_vat).ilks(_ilk);\\n        (, uint art) = Vat(_vat).urns(_ilk, _urn);\\n\\n        amount = toPositiveInt(dai / rate);\\n        amount = uint(amount) <= art ? - amount : - toPositiveInt(art);\\n    }\\n\\n    /// @notice Gets the whole debt of the CDP\\n    /// @param _vat Address of Vat contract\\n    /// @param _usr Address of the Dai holder\\n    /// @param _urn Urn of the Cdp\\n    /// @param _ilk Ilk of the Cdp\\n    function getAllDebt(address _vat, address _usr, address _urn, bytes32 _ilk) internal view returns (uint daiAmount) {\\n        (, uint rate,,,) = Vat(_vat).ilks(_ilk);\\n        (, uint art) = Vat(_vat).urns(_ilk, _urn);\\n        uint dai = Vat(_vat).dai(_usr);\\n\\n        uint rad = sub(mul(art, rate), dai);\\n        daiAmount = rad / RAY;\\n\\n        daiAmount = mul(daiAmount, RAY) < rad ? daiAmount + 1 : daiAmount;\\n    }\\n\\n    /// @notice Gets the token address from the Join contract\\n    /// @param _joinAddr Address of the Join contract\\n    function getCollateralAddr(address _joinAddr) internal view returns (address) {\\n        return address(Join(_joinAddr).gem());\\n    }\\n\\n    /// @notice Checks if the join address is one of the Ether coll. types\\n    /// @param _joinAddr Join address to check\\n    function isEthJoinAddr(address _joinAddr) internal view returns (bool) {\\n        // if it's dai_join_addr don't check gem() it will fail\\n        if (_joinAddr == 0x9759A6Ac90977b93B58547b4A71c78317f391A28) return false;\\n\\n        // if coll is weth it's and eth type coll\\n        if (address(Join(_joinAddr).gem()) == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Gets CDP info (collateral, debt)\\n    /// @param _manager Manager contract\\n    /// @param _cdpId Id of the CDP\\n    /// @param _ilk Ilk of the CDP\\n    function getCdpInfo(Manager _manager, uint _cdpId, bytes32 _ilk) public view returns (uint, uint) {\\n        address vat = _manager.vat();\\n        address urn = _manager.urns(_cdpId);\\n\\n        (uint collateral, uint debt) = Vat(vat).urns(_ilk, urn);\\n        (,uint rate,,,) = Vat(vat).ilks(_ilk);\\n\\n        return (collateral, rmul(debt, rate));\\n    }\\n\\n    /// @notice Address that owns the DSProxy that owns the CDP\\n    /// @param _manager Manager contract\\n    /// @param _cdpId Id of the CDP\\n    function getOwner(Manager _manager, uint _cdpId) public view returns (address) {\\n        DSProxy proxy = DSProxy(uint160(_manager.owns(_cdpId)));\\n\\n        return proxy.owner();\\n    }\\n\\n    /// @notice Based on the manager type returns the address\\n    /// @param _managerType Type of vault manager to use\\n    function getManagerAddr(ManagerType _managerType) public pure returns (address) {\\n        if (_managerType == ManagerType.MCD) {\\n            return 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\\n        } else if (_managerType == ManagerType.BPROTOCOL) {\\n            return 0x3f30c2381CD8B917Dd96EB2f1A4F96D91324BBed;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/PipInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\nabstract contract PipInterface {\\n    function read() public virtual returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/shifter/protocols/McdShifter.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../interfaces/ILoanShifter.sol\\\";\\nimport \\\"../../mcd/saver/MCDSaverProxy.sol\\\";\\nimport \\\"../../mcd/create/MCDCreateProxyActions.sol\\\";\\n\\ncontract McdShifter is MCDSaverProxy {\\n\\n    using SafeERC20 for ERC20;\\n\\n    Manager manager = Manager(0x5ef30b9986345249bc32d8928B7ee64DE9435E39);\\n\\n    address public constant OPEN_PROXY_ACTIONS = 0x6d0984E80a86f26c0dd564ca0CF74a8E9Da03305;\\n\\n    function getLoanAmount(uint _cdpId, address _joinAddr) public view virtual returns(uint loanAmount) {\\n        bytes32 ilk = manager.ilks(_cdpId);\\n\\n        (, uint rate,,,) = vat.ilks(ilk);\\n        (, uint art) = vat.urns(ilk, manager.urns(_cdpId));\\n        uint dai = vat.dai(manager.urns(_cdpId));\\n\\n        uint rad = sub(mul(art, rate), dai);\\n        loanAmount = rad / RAY;\\n\\n        loanAmount = mul(loanAmount, RAY) < rad ? loanAmount + 1 : loanAmount;\\n    }\\n\\n    function close(\\n        uint _cdpId,\\n        address _joinAddr,\\n        uint _loanAmount,\\n        uint _collateral\\n    ) public {\\n        address owner = getOwner(manager, _cdpId);\\n        bytes32 ilk = manager.ilks(_cdpId);\\n        (uint maxColl, ) = getCdpInfo(manager, _cdpId, ilk);\\n\\n        // repay dai debt cdp\\n        paybackDebt(address(manager), _cdpId, ilk, _loanAmount, owner);\\n\\n        maxColl = _collateral > maxColl ? maxColl : _collateral;\\n\\n        // withdraw collateral from cdp\\n        drawCollateral(address(manager), _cdpId, _joinAddr, maxColl);\\n\\n        // send back to msg.sender\\n        if (isEthJoinAddr(_joinAddr)) {\\n            msg.sender.transfer(address(this).balance);\\n        } else {\\n            ERC20 collToken = ERC20(getCollateralAddr(_joinAddr));\\n            collToken.safeTransfer(msg.sender, collToken.balanceOf(address(this)));\\n        }\\n    }\\n\\n    function open(\\n        uint _cdpId,\\n        address _joinAddr,\\n        uint _debtAmount\\n    ) public {\\n\\n        uint collAmount = 0;\\n\\n        if (isEthJoinAddr(_joinAddr)) {\\n            collAmount = address(this).balance;\\n        } else {\\n            collAmount = ERC20(address(Join(_joinAddr).gem())).balanceOf(address(this));\\n        }\\n\\n        if (_cdpId == 0) {\\n            openAndWithdraw(collAmount, _debtAmount, address(this), _joinAddr);\\n        } else {\\n            // add collateral\\n            addCollateral(address(manager), _cdpId, _joinAddr, collAmount);\\n            // draw debt\\n            drawDai(address(manager), _cdpId, manager.ilks(_cdpId), _debtAmount);\\n        }\\n\\n        // transfer to repay FL\\n        ERC20(DAI_ADDRESS).transfer(msg.sender, ERC20(DAI_ADDRESS).balanceOf(address(this)));\\n\\n        if (address(this).balance > 0) {\\n            tx.origin.transfer(address(this).balance);\\n        }\\n    }\\n\\n    function openAndWithdraw(uint _collAmount, uint _debtAmount, address _proxy, address _joinAddrTo) internal {\\n        bytes32 ilk = Join(_joinAddrTo).ilk();\\n\\n        if (isEthJoinAddr(_joinAddrTo)) {\\n            MCDCreateProxyActions(OPEN_PROXY_ACTIONS).openLockETHAndDraw{value: address(this).balance}(\\n                address(manager),\\n                JUG_ADDRESS,\\n                _joinAddrTo,\\n                DAI_JOIN_ADDRESS,\\n                ilk,\\n                _debtAmount,\\n                _proxy\\n            );\\n        } else {\\n            ERC20(getCollateralAddr(_joinAddrTo)).approve(OPEN_PROXY_ACTIONS, uint256(-1));\\n\\n            MCDCreateProxyActions(OPEN_PROXY_ACTIONS).openLockGemAndDraw(\\n                address(manager),\\n                JUG_ADDRESS,\\n                _joinAddrTo,\\n                DAI_JOIN_ADDRESS,\\n                ilk,\\n                _collAmount,\\n                _debtAmount,\\n                true,\\n                _proxy\\n            );\\n        }\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/create/MCDCreateProxyActions.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\nabstract contract GemLike {\\n    function approve(address, uint256) public virtual;\\n\\n    function transfer(address, uint256) public virtual;\\n\\n    function transferFrom(address, address, uint256) public virtual;\\n\\n    function deposit() public virtual payable;\\n\\n    function withdraw(uint256) public virtual;\\n}\\n\\n\\nabstract contract ManagerLike {\\n    function cdpCan(address, uint256, address) public virtual view returns (uint256);\\n\\n    function ilks(uint256) public virtual view returns (bytes32);\\n\\n    function owns(uint256) public virtual view returns (address);\\n\\n    function urns(uint256) public virtual view returns (address);\\n\\n    function vat() public virtual view returns (address);\\n\\n    function open(bytes32, address) public virtual returns (uint256);\\n\\n    function give(uint256, address) public virtual;\\n\\n    function cdpAllow(uint256, address, uint256) public virtual;\\n\\n    function urnAllow(address, uint256) public virtual;\\n\\n    function frob(uint256, int256, int256) public virtual;\\n\\n    function flux(uint256, address, uint256) public virtual;\\n\\n    function move(uint256, address, uint256) public virtual;\\n\\n    function exit(address, uint256, address, uint256) public virtual;\\n\\n    function quit(uint256, address) public virtual;\\n\\n    function enter(address, uint256) public virtual;\\n\\n    function shift(uint256, uint256) public virtual;\\n}\\n\\n\\nabstract contract VatLike {\\n    function can(address, address) public virtual view returns (uint256);\\n\\n    function ilks(bytes32) public virtual view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n    function dai(address) public virtual view returns (uint256);\\n\\n    function urns(bytes32, address) public virtual view returns (uint256, uint256);\\n\\n    function frob(bytes32, address, address, address, int256, int256) public virtual;\\n\\n    function hope(address) public virtual;\\n\\n    function move(address, address, uint256) public virtual;\\n}\\n\\n\\nabstract contract GemJoinLike {\\n    function dec() public virtual returns (uint256);\\n\\n    function gem() public virtual returns (GemLike);\\n\\n    function join(address, uint256) public virtual payable;\\n\\n    function exit(address, uint256) public virtual;\\n}\\n\\n\\nabstract contract GNTJoinLike {\\n    function bags(address) public virtual view returns (address);\\n\\n    function make(address) public virtual returns (address);\\n}\\n\\n\\nabstract contract DaiJoinLike {\\n    function vat() public virtual returns (VatLike);\\n\\n    function dai() public virtual returns (GemLike);\\n\\n    function join(address, uint256) public virtual payable;\\n\\n    function exit(address, uint256) public virtual;\\n}\\n\\n\\nabstract contract HopeLike {\\n    function hope(address) public virtual;\\n\\n    function nope(address) public virtual;\\n}\\n\\n\\nabstract contract ProxyRegistryInterface {\\n    function build(address) public virtual returns (address);\\n}\\n\\n\\nabstract contract EndLike {\\n    function fix(bytes32) public virtual view returns (uint256);\\n\\n    function cash(bytes32, uint256) public virtual;\\n\\n    function free(bytes32) public virtual;\\n\\n    function pack(uint256) public virtual;\\n\\n    function skim(bytes32, address) public virtual;\\n}\\n\\n\\nabstract contract JugLike {\\n    function drip(bytes32) public virtual returns (uint256);\\n}\\n\\n\\nabstract contract PotLike {\\n    function pie(address) public virtual view returns (uint256);\\n\\n    function drip() public virtual returns (uint256);\\n\\n    function join(uint256) public virtual;\\n\\n    function exit(uint256) public virtual;\\n}\\n\\n\\nabstract contract ProxyRegistryLike {\\n    function proxies(address) public virtual view returns (address);\\n\\n    function build(address) public virtual returns (address);\\n}\\n\\n\\nabstract contract ProxyLike {\\n    function owner() public virtual view returns (address);\\n}\\n\\n\\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n// WARNING: These functions meant to be used as a a library for a DSProxy. Some are unsafe if you call them directly.\\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\ncontract Common {\\n    uint256 constant RAY = 10**27;\\n\\n    // Internal functions\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"mul-overflow\\\");\\n    }\\n\\n    // Public functions\\n    // solhint-disable-next-line func-name-mixedcase\\n    function daiJoin_join(address apt, address urn, uint256 wad) public {\\n        // Gets DAI from the user's wallet\\n        DaiJoinLike(apt).dai().transferFrom(msg.sender, address(this), wad);\\n        // Approves adapter to take the DAI amount\\n        DaiJoinLike(apt).dai().approve(apt, wad);\\n        // Joins DAI into the vat\\n        DaiJoinLike(apt).join(urn, wad);\\n    }\\n}\\n\\n\\ncontract MCDCreateProxyActions is Common {\\n    // Internal functions\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, \\\"sub-overflow\\\");\\n    }\\n\\n    function toInt(uint256 x) internal pure returns (int256 y) {\\n        y = int256(x);\\n        require(y >= 0, \\\"int-overflow\\\");\\n    }\\n\\n    function toRad(uint256 wad) internal pure returns (uint256 rad) {\\n        rad = mul(wad, 10**27);\\n    }\\n\\n    function convertTo18(address gemJoin, uint256 amt) internal returns (uint256 wad) {\\n        // For those collaterals that have less than 18 decimals precision we need to do the conversion before passing to frob function\\n        // Adapters will automatically handle the difference of precision\\n        wad = mul(amt, 10**(18 - GemJoinLike(gemJoin).dec()));\\n    }\\n\\n    function _getDrawDart(address vat, address jug, address urn, bytes32 ilk, uint256 wad)\\n        internal\\n        returns (int256 dart)\\n    {\\n        // Updates stability fee rate\\n        uint256 rate = JugLike(jug).drip(ilk);\\n\\n        // Gets DAI balance of the urn in the vat\\n        uint256 dai = VatLike(vat).dai(urn);\\n\\n        // If there was already enough DAI in the vat balance, just exits it without adding more debt\\n        if (dai < mul(wad, RAY)) {\\n            // Calculates the needed dart so together with the existing dai in the vat is enough to exit wad amount of DAI tokens\\n            dart = toInt(sub(mul(wad, RAY), dai) / rate);\\n            // This is neeeded due lack of precision. It might need to sum an extra dart wei (for the given DAI wad amount)\\n            dart = mul(uint256(dart), rate) < mul(wad, RAY) ? dart + 1 : dart;\\n        }\\n    }\\n\\n    function _getWipeDart(address vat, uint256 dai, address urn, bytes32 ilk)\\n        internal\\n        view\\n        returns (int256 dart)\\n    {\\n        // Gets actual rate from the vat\\n        (, uint256 rate, , , ) = VatLike(vat).ilks(ilk);\\n        // Gets actual art value of the urn\\n        (, uint256 art) = VatLike(vat).urns(ilk, urn);\\n\\n        // Uses the whole dai balance in the vat to reduce the debt\\n        dart = toInt(dai / rate);\\n        // Checks the calculated dart is not higher than urn.art (total debt), otherwise uses its value\\n        dart = uint256(dart) <= art ? -dart : -toInt(art);\\n    }\\n\\n    function _getWipeAllWad(address vat, address usr, address urn, bytes32 ilk)\\n        internal\\n        view\\n        returns (uint256 wad)\\n    {\\n        // Gets actual rate from the vat\\n        (, uint256 rate, , , ) = VatLike(vat).ilks(ilk);\\n        // Gets actual art value of the urn\\n        (, uint256 art) = VatLike(vat).urns(ilk, urn);\\n        // Gets actual dai amount in the urn\\n        uint256 dai = VatLike(vat).dai(usr);\\n\\n        uint256 rad = sub(mul(art, rate), dai);\\n        wad = rad / RAY;\\n\\n        // If the rad precision has some dust, it will need to request for 1 extra wad wei\\n        wad = mul(wad, RAY) < rad ? wad + 1 : wad;\\n    }\\n\\n    // Public functions\\n\\n    function transfer(address gem, address dst, uint256 wad) public {\\n        GemLike(gem).transfer(dst, wad);\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function ethJoin_join(address apt, address urn) public payable {\\n        // Wraps ETH in WETH\\n        GemJoinLike(apt).gem().deposit{value: msg.value}();\\n        // Approves adapter to take the WETH amount\\n        GemJoinLike(apt).gem().approve(address(apt), msg.value);\\n        // Joins WETH collateral into the vat\\n        GemJoinLike(apt).join(urn, msg.value);\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function gemJoin_join(address apt, address urn, uint256 wad, bool transferFrom) public {\\n        // Only executes for tokens that have approval/transferFrom implementation\\n        if (transferFrom) {\\n            // Gets token from the user's wallet\\n            GemJoinLike(apt).gem().transferFrom(msg.sender, address(this), wad);\\n            // Approves adapter to take the token amount\\n            GemJoinLike(apt).gem().approve(apt, 0);\\n            GemJoinLike(apt).gem().approve(apt, wad);\\n        }\\n        // Joins token collateral into the vat\\n        GemJoinLike(apt).join(urn, wad);\\n    }\\n\\n    function hope(address obj, address usr) public {\\n        HopeLike(obj).hope(usr);\\n    }\\n\\n    function nope(address obj, address usr) public {\\n        HopeLike(obj).nope(usr);\\n    }\\n\\n    function open(address manager, bytes32 ilk, address usr) public returns (uint256 cdp) {\\n        cdp = ManagerLike(manager).open(ilk, usr);\\n    }\\n\\n    function give(address manager, uint256 cdp, address usr) public {\\n        ManagerLike(manager).give(cdp, usr);\\n    }\\n\\n    function move(address manager, uint256 cdp, address dst, uint256 rad) public {\\n        ManagerLike(manager).move(cdp, dst, rad);\\n    }\\n\\n    function frob(address manager, uint256 cdp, int256 dink, int256 dart) public {\\n        ManagerLike(manager).frob(cdp, dink, dart);\\n    }\\n\\n    function lockETH(address manager, address ethJoin, uint256 cdp) public payable {\\n        // Receives ETH amount, converts it to WETH and joins it into the vat\\n        ethJoin_join(ethJoin, address(this));\\n        // Locks WETH amount into the CDP\\n        VatLike(ManagerLike(manager).vat()).frob(\\n            ManagerLike(manager).ilks(cdp),\\n            ManagerLike(manager).urns(cdp),\\n            address(this),\\n            address(this),\\n            toInt(msg.value),\\n            0\\n        );\\n    }\\n\\n    function lockGem(address manager, address gemJoin, uint256 cdp, uint256 wad, bool transferFrom)\\n        public\\n    {\\n        // Takes token amount from user's wallet and joins into the vat\\n        gemJoin_join(gemJoin, address(this), wad, transferFrom);\\n        // Locks token amount into the CDP\\n        VatLike(ManagerLike(manager).vat()).frob(\\n            ManagerLike(manager).ilks(cdp),\\n            ManagerLike(manager).urns(cdp),\\n            address(this),\\n            address(this),\\n            toInt(convertTo18(gemJoin, wad)),\\n            0\\n        );\\n    }\\n\\n    function draw(address manager, address jug, address daiJoin, uint256 cdp, uint256 wad) public {\\n        address urn = ManagerLike(manager).urns(cdp);\\n        address vat = ManagerLike(manager).vat();\\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\\n        // Generates debt in the CDP\\n        frob(manager, cdp, 0, _getDrawDart(vat, jug, urn, ilk, wad));\\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\\n        move(manager, cdp, address(this), toRad(wad));\\n        // Allows adapter to access to proxy's DAI balance in the vat\\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\\n            VatLike(vat).hope(daiJoin);\\n        }\\n        // Exits DAI to the user's wallet as a token\\n        DaiJoinLike(daiJoin).exit(msg.sender, wad);\\n    }\\n\\n    function lockETHAndDraw(\\n        address manager,\\n        address jug,\\n        address ethJoin,\\n        address daiJoin,\\n        uint256 cdp,\\n        uint256 wadD\\n    ) public payable {\\n        address urn = ManagerLike(manager).urns(cdp);\\n        address vat = ManagerLike(manager).vat();\\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\\n        // Receives ETH amount, converts it to WETH and joins it into the vat\\n        ethJoin_join(ethJoin, urn);\\n        // Locks WETH amount into the CDP and generates debt\\n        frob(manager, cdp, toInt(msg.value), _getDrawDart(vat, jug, urn, ilk, wadD));\\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\\n        move(manager, cdp, address(this), toRad(wadD));\\n        // Allows adapter to access to proxy's DAI balance in the vat\\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\\n            VatLike(vat).hope(daiJoin);\\n        }\\n        // Exits DAI to the user's wallet as a token\\n        DaiJoinLike(daiJoin).exit(msg.sender, wadD);\\n    }\\n\\n    function openLockETHAndDraw(\\n        address manager,\\n        address jug,\\n        address ethJoin,\\n        address daiJoin,\\n        bytes32 ilk,\\n        uint256 wadD,\\n        address owner\\n    ) public payable returns (uint256 cdp) {\\n        cdp = open(manager, ilk, address(this));\\n        lockETHAndDraw(manager, jug, ethJoin, daiJoin, cdp, wadD);\\n        give(manager, cdp, owner);\\n    }\\n\\n    function lockGemAndDraw(\\n        address manager,\\n        address jug,\\n        address gemJoin,\\n        address daiJoin,\\n        uint256 cdp,\\n        uint256 wadC,\\n        uint256 wadD,\\n        bool transferFrom\\n    ) public {\\n        address urn = ManagerLike(manager).urns(cdp);\\n        address vat = ManagerLike(manager).vat();\\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\\n        // Takes token amount from user's wallet and joins into the vat\\n        gemJoin_join(gemJoin, urn, wadC, transferFrom);\\n        // Locks token amount into the CDP and generates debt\\n        frob(\\n            manager,\\n            cdp,\\n            toInt(convertTo18(gemJoin, wadC)),\\n            _getDrawDart(vat, jug, urn, ilk, wadD)\\n        );\\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\\n        move(manager, cdp, address(this), toRad(wadD));\\n        // Allows adapter to access to proxy's DAI balance in the vat\\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\\n            VatLike(vat).hope(daiJoin);\\n        }\\n        // Exits DAI to the user's wallet as a token\\n        DaiJoinLike(daiJoin).exit(msg.sender, wadD);\\n    }\\n\\n    function openLockGemAndDraw(\\n        address manager,\\n        address jug,\\n        address gemJoin,\\n        address daiJoin,\\n        bytes32 ilk,\\n        uint256 wadC,\\n        uint256 wadD,\\n        bool transferFrom,\\n        address owner\\n    ) public returns (uint256 cdp) {\\n        cdp = open(manager, ilk, address(this));\\n        lockGemAndDraw(manager, jug, gemJoin, daiJoin, cdp, wadC, wadD, transferFrom);\\n        give(manager, cdp, owner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/create/MCDCreateFlashLoan.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../exchangeV3/DFSExchangeCore.sol\\\";\\nimport \\\"./MCDCreateProxyActions.sol\\\";\\nimport \\\"../../utils/FlashLoanReceiverBase.sol\\\";\\nimport \\\"../../interfaces/Manager.sol\\\";\\nimport \\\"../../interfaces/Join.sol\\\";\\nimport \\\"../../DS/DSProxy.sol\\\";\\nimport \\\"./MCDCreateTaker.sol\\\";\\n\\ncontract MCDCreateFlashLoan is DFSExchangeCore, AdminAuth, FlashLoanReceiverBase {\\n    address public constant CREATE_PROXY_ACTIONS = 0x6d0984E80a86f26c0dd564ca0CF74a8E9Da03305;\\n\\n    uint public constant SERVICE_FEE = 400; // 0.25% Fee\\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n\\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\\n\\n    address public constant DAI_JOIN_ADDRESS = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\\n    address public constant JUG_ADDRESS = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\\n    address public constant MANAGER_ADDRESS = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\\n\\n    constructor() FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER) public {}\\n\\n    function executeOperation(\\n        address _reserve,\\n        uint256 _amount,\\n        uint256 _fee,\\n        bytes calldata _params)\\n    external override {\\n\\n        //check the contract has the specified balance\\n        require(_amount <= getBalanceInternal(address(this), _reserve),\\n            \\\"Invalid balance for the contract\\\");\\n\\n        (address proxy, bytes memory packedData) = abi.decode(_params, (address,bytes));\\n        (MCDCreateTaker.CreateData memory createData, ExchangeData memory exchangeData) = abi.decode(packedData, (MCDCreateTaker.CreateData,ExchangeData));\\n\\n        exchangeData.dfsFeeDivider = SERVICE_FEE;\\n        exchangeData.user = DSProxy(payable(proxy)).owner();\\n\\n        openAndLeverage(createData.collAmount, createData.daiAmount + _fee, createData.joinAddr, proxy, exchangeData);\\n\\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\\n\\n        // if there is some eth left (0x fee), return it to user\\n        if (address(this).balance > 0) {\\n            tx.origin.transfer(address(this).balance);\\n        }\\n    }\\n\\n    function openAndLeverage(\\n        uint _collAmount,\\n        uint _daiAmountAndFee,\\n        address _joinAddr,\\n        address _proxy,\\n        ExchangeData memory _exchangeData\\n    ) public {\\n        (, uint256 collSwaped) = _sell(_exchangeData);\\n\\n        bytes32 ilk = Join(_joinAddr).ilk();\\n\\n        if (isEthJoinAddr(_joinAddr)) {\\n            MCDCreateProxyActions(CREATE_PROXY_ACTIONS).openLockETHAndDraw{value: address(this).balance}(\\n                MANAGER_ADDRESS,\\n                JUG_ADDRESS,\\n                _joinAddr,\\n                DAI_JOIN_ADDRESS,\\n                ilk,\\n                _daiAmountAndFee,\\n                _proxy\\n            );\\n        } else {\\n            ERC20(address(Join(_joinAddr).gem())).safeApprove(CREATE_PROXY_ACTIONS, (_collAmount + collSwaped));\\n\\n            MCDCreateProxyActions(CREATE_PROXY_ACTIONS).openLockGemAndDraw(\\n                MANAGER_ADDRESS,\\n                JUG_ADDRESS,\\n                _joinAddr,\\n                DAI_JOIN_ADDRESS,\\n                ilk,\\n                (_collAmount + collSwaped),\\n                _daiAmountAndFee,\\n                true,\\n                _proxy\\n            );\\n        }\\n    }\\n\\n    /// @notice Checks if the join address is one of the Ether coll. types\\n    /// @param _joinAddr Join address to check\\n    function isEthJoinAddr(address _joinAddr) internal view returns (bool) {\\n        // if it's dai_join_addr don't check gem() it will fail\\n        if (_joinAddr == 0x9759A6Ac90977b93B58547b4A71c78317f391A28) return false;\\n\\n        // if coll is weth it's and eth type coll\\n        if (address(Join(_joinAddr).gem()) == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    receive() external override(FlashLoanReceiverBase, DFSExchangeCore) payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/create/MCDCreateTaker.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../mcd/saver/MCDSaverProxy.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../interfaces/ILendingPool.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeData.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../utils/GasBurner.sol\\\";\\n\\ncontract MCDCreateTaker is GasBurner {\\n\\n    using SafeERC20 for ERC20;\\n\\n    address payable public constant MCD_CREATE_FLASH_LOAN = 0x409F216aa8034a12135ab6b74Bf6444335004BBd;\\n\\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n\\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\\n\\n    // solhint-disable-next-line const-name-snakecase\\n    Manager public constant manager = Manager(0x5ef30b9986345249bc32d8928B7ee64DE9435E39);\\n\\n    // solhint-disable-next-line const-name-snakecase\\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\\n\\n    struct CreateData {\\n        uint collAmount;\\n        uint daiAmount;\\n        address joinAddr;\\n    }\\n\\n    function openWithLoan(\\n        DFSExchangeData.ExchangeData memory _exchangeData,\\n        CreateData memory _createData\\n    ) public payable burnGas(20) {\\n\\n        MCD_CREATE_FLASH_LOAN.transfer(msg.value); //0x fee\\n\\n\\n        if (!isEthJoinAddr(_createData.joinAddr)) {\\n            ERC20(getCollateralAddr(_createData.joinAddr)).safeTransferFrom(msg.sender, address(this), _createData.collAmount);\\n            ERC20(getCollateralAddr(_createData.joinAddr)).safeTransfer(MCD_CREATE_FLASH_LOAN, _createData.collAmount);\\n        }\\n\\n        bytes memory packedData = _packData(_createData, _exchangeData);\\n        bytes memory paramsData = abi.encode(address(this), packedData);\\n\\n        lendingPool.flashLoan(MCD_CREATE_FLASH_LOAN, DAI_ADDRESS, _createData.daiAmount, paramsData);\\n\\n        logger.Log(address(this), msg.sender, \\\"MCDCreate\\\", abi.encode(manager.last(address(this)), _createData.collAmount, _createData.daiAmount));\\n    }\\n\\n    function getCollateralAddr(address _joinAddr) internal view returns (address) {\\n        return address(Join(_joinAddr).gem());\\n    }\\n\\n    /// @notice Checks if the join address is one of the Ether coll. types\\n    /// @param _joinAddr Join address to check\\n    function isEthJoinAddr(address _joinAddr) internal view returns (bool) {\\n        // if it's dai_join_addr don't check gem() it will fail\\n        if (_joinAddr == 0x9759A6Ac90977b93B58547b4A71c78317f391A28) return false;\\n\\n        // if coll is weth it's and eth type coll\\n        if (address(Join(_joinAddr).gem()) == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function _packData(\\n        CreateData memory _createData,\\n        DFSExchangeData.ExchangeData memory _exchangeData\\n    ) internal pure returns (bytes memory) {\\n\\n        return abi.encode(_createData, _exchangeData);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/saver/MCDSaverTaker.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../saver/MCDSaverProxy.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeData.sol\\\";\\nimport \\\"../../utils/GasBurner.sol\\\";\\nimport \\\"../../interfaces/ILendingPool.sol\\\";\\n\\ncontract MCDSaverTaker is MCDSaverProxy, GasBurner {\\n\\n    address payable public constant MCD_SAVER_FLASH_LOAN = 0xcBb5DbBCcFbf6aF8AF75d0cbD5646C73d847cd15;\\n    address public constant AAVE_POOL_CORE = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\\n\\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\\n\\n    function boostWithLoan(\\n        ExchangeData memory _exchangeData,\\n        uint _cdpId,\\n        uint _gasCost,\\n        address _joinAddr,\\n        ManagerType _managerType\\n    ) public payable burnGas(25) {\\n        address managerAddr = getManagerAddr(_managerType);\\n\\n        uint256 maxDebt = getMaxDebt(managerAddr, _cdpId, Manager(managerAddr).ilks(_cdpId));\\n\\n        uint maxLiq = getAvailableLiquidity(DAI_JOIN_ADDRESS);\\n\\n        if (maxDebt >= _exchangeData.srcAmount || maxLiq == 0) {\\n            if (_exchangeData.srcAmount > maxDebt) {\\n                _exchangeData.srcAmount = maxDebt;\\n            }\\n\\n            boost(_exchangeData, _cdpId, _gasCost, _joinAddr, _managerType);\\n            return;\\n        }\\n\\n        uint256 loanAmount = sub(_exchangeData.srcAmount, maxDebt);\\n        loanAmount = loanAmount > maxLiq ? maxLiq : loanAmount;\\n\\n        MCD_SAVER_FLASH_LOAN.transfer(msg.value); // 0x fee\\n\\n        Manager(managerAddr).cdpAllow(_cdpId, MCD_SAVER_FLASH_LOAN, 1);\\n\\n        bytes memory paramsData = abi.encode(packExchangeData(_exchangeData), _cdpId, _gasCost, _joinAddr, false, uint8(_managerType));\\n\\n        lendingPool.flashLoan(MCD_SAVER_FLASH_LOAN, DAI_ADDRESS, loanAmount, paramsData);\\n\\n        Manager(managerAddr).cdpAllow(_cdpId, MCD_SAVER_FLASH_LOAN, 0);\\n    }\\n\\n    function repayWithLoan(\\n        ExchangeData memory _exchangeData,\\n        uint _cdpId,\\n        uint _gasCost,\\n        address _joinAddr,\\n        ManagerType _managerType\\n    ) public payable burnGas(25) {\\n        address managerAddr = getManagerAddr(_managerType);\\n\\n        uint256 maxColl = getMaxCollateral(managerAddr, _cdpId, Manager(managerAddr).ilks(_cdpId), _joinAddr);\\n\\n        uint maxLiq = getAvailableLiquidity(_joinAddr);\\n\\n        if (maxColl >= _exchangeData.srcAmount || maxLiq == 0) {\\n            if (_exchangeData.srcAmount > maxColl) {\\n                _exchangeData.srcAmount = maxColl;\\n            }\\n\\n            repay(_exchangeData, _cdpId, _gasCost, _joinAddr, _managerType);\\n            return;\\n        }\\n\\n        uint256 loanAmount = sub(_exchangeData.srcAmount, maxColl);\\n        loanAmount = loanAmount > maxLiq ? maxLiq : loanAmount;\\n\\n        MCD_SAVER_FLASH_LOAN.transfer(msg.value); // 0x fee\\n\\n        Manager(managerAddr).cdpAllow(_cdpId, MCD_SAVER_FLASH_LOAN, 1);\\n\\n        bytes memory paramsData = abi.encode(packExchangeData(_exchangeData), _cdpId, _gasCost, _joinAddr, true, uint8(_managerType));\\n\\n        lendingPool.flashLoan(MCD_SAVER_FLASH_LOAN, getAaveCollAddr(_joinAddr), loanAmount, paramsData);\\n\\n        Manager(managerAddr).cdpAllow(_cdpId, MCD_SAVER_FLASH_LOAN, 0);\\n    }\\n\\n\\n    /// @notice Gets the maximum amount of debt available to generate\\n    /// @param _managerAddr Address of the CDP Manager\\n    /// @param _cdpId Id of the CDP\\n    /// @param _ilk Ilk of the CDP\\n    function getMaxDebt(address _managerAddr, uint256 _cdpId, bytes32 _ilk) public override view returns (uint256) {\\n        uint256 price = getPrice(_ilk);\\n\\n        (, uint256 mat) = spotter.ilks(_ilk);\\n        (uint256 collateral, uint256 debt) = getCdpInfo(Manager(_managerAddr), _cdpId, _ilk);\\n\\n        return sub(wdiv(wmul(collateral, price), mat), debt);\\n    }\\n\\n    function getAaveCollAddr(address _joinAddr) internal view returns (address) {\\n        if (isEthJoinAddr(_joinAddr)\\n            || _joinAddr == 0x775787933e92b709f2a3C70aa87999696e74A9F8) {\\n            return KYBER_ETH_ADDRESS;\\n        } else if (_joinAddr == DAI_JOIN_ADDRESS) {\\n            return DAI_ADDRESS;\\n        } else\\n         {\\n            return getCollateralAddr(_joinAddr);\\n        }\\n    }\\n\\n    function getAvailableLiquidity(address _joinAddr) internal view returns (uint liquidity) {\\n        address tokenAddr = getAaveCollAddr(_joinAddr);\\n\\n        if (tokenAddr == KYBER_ETH_ADDRESS) {\\n            liquidity = AAVE_POOL_CORE.balance;\\n        } else {\\n            liquidity = ERC20(tokenAddr).balanceOf(AAVE_POOL_CORE);\\n        }\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/savings/aave/AaveSavingsProtocol.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../ProtocolInterface.sol\\\";\\nimport \\\"../../interfaces/IAToken.sol\\\";\\nimport \\\"../../interfaces/ILendingPool.sol\\\";\\nimport \\\"../../interfaces/ERC20.sol\\\";\\nimport \\\"../../DS/DSAuth.sol\\\";\\n\\n\\ncontract AaveSavingsProtocol is ProtocolInterface, DSAuth {\\n\\n    address public constant ADAI_ADDRESS = 0xfC1E690f61EFd961294b3e1Ce3313fBD8aa4f85d;\\n    address public constant AAVE_LENDING_POOL = 0x398eC7346DcD622eDc5ae82352F02bE94C62d119;\\n    address public constant AAVE_LENDING_POOL_CORE = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n\\n    function deposit(address _user, uint _amount) public override {\\n        require(msg.sender == _user);\\n        // get dai from user\\n        require(ERC20(DAI_ADDRESS).transferFrom(_user, address(this), _amount));\\n\\n        ERC20(DAI_ADDRESS).approve(AAVE_LENDING_POOL_CORE, uint(-1));\\n        ILendingPool(AAVE_LENDING_POOL).deposit(DAI_ADDRESS, _amount, 0);\\n\\n        ERC20(ADAI_ADDRESS).transfer(_user, ERC20(ADAI_ADDRESS).balanceOf(address(this)));\\n    }\\n\\n    function withdraw(address _user, uint _amount) public override {\\n        require(msg.sender == _user);\\n        require(ERC20(ADAI_ADDRESS).transferFrom(_user, address(this), _amount));\\n\\n        IAToken(ADAI_ADDRESS).redeem(_amount);\\n\\n        // return dai we have to user\\n        ERC20(DAI_ADDRESS).transfer(_user, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/savings/fulcrum/FulcrumSavingsProtocol.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../ProtocolInterface.sol\\\";\\nimport \\\"../../interfaces/ERC20.sol\\\";\\nimport \\\"../../interfaces/ITokenInterface.sol\\\";\\nimport \\\"../../DS/DSAuth.sol\\\";\\n\\ncontract FulcrumSavingsProtocol is ProtocolInterface, DSAuth {\\n\\n    address public constant NEW_IDAI_ADDRESS = 0x493C57C4763932315A328269E1ADaD09653B9081;\\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n\\n    address public savingsProxy;\\n    uint public decimals = 10 ** 18;\\n\\n    function addSavingsProxy(address _savingsProxy) public auth {\\n        savingsProxy = _savingsProxy;\\n    }\\n\\n    function deposit(address _user, uint _amount) public override {\\n        require(msg.sender == _user);\\n\\n        // get dai from user\\n        require(ERC20(DAI_ADDRESS).transferFrom(_user, address(this), _amount));\\n\\n        // approve dai to Fulcrum\\n        ERC20(DAI_ADDRESS).approve(NEW_IDAI_ADDRESS, uint(-1));\\n\\n        // mint iDai\\n        ITokenInterface(NEW_IDAI_ADDRESS).mint(_user, _amount);\\n    }\\n\\n    function withdraw(address _user, uint _amount) public override {\\n        require(msg.sender == _user);\\n\\n        // transfer all users tokens to our contract\\n        require(ERC20(NEW_IDAI_ADDRESS).transferFrom(_user, address(this), ITokenInterface(NEW_IDAI_ADDRESS).balanceOf(_user)));\\n\\n        // approve iDai to that contract\\n        ERC20(NEW_IDAI_ADDRESS).approve(NEW_IDAI_ADDRESS, uint(-1));\\n        uint tokenPrice = ITokenInterface(NEW_IDAI_ADDRESS).tokenPrice();\\n\\n        // get dai from iDai contract\\n        ITokenInterface(NEW_IDAI_ADDRESS).burn(_user, _amount * decimals / tokenPrice);\\n\\n        // return all remaining tokens back to user\\n        require(ERC20(NEW_IDAI_ADDRESS).transfer(_user, ITokenInterface(NEW_IDAI_ADDRESS).balanceOf(address(this))));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/savings/dydx/DydxSavingsProtocol.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../ProtocolInterface.sol\\\";\\nimport \\\"./ISoloMargin.sol\\\";\\nimport \\\"../../interfaces/ERC20.sol\\\";\\nimport \\\"../../DS/DSAuth.sol\\\";\\n\\ncontract DydxSavingsProtocol is ProtocolInterface, DSAuth {\\n    address public constant SOLO_MARGIN_ADDRESS = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\\n\\n    ISoloMargin public soloMargin;\\n    address public savingsProxy;\\n\\n    uint daiMarketId = 3;\\n\\n    constructor() public {\\n        soloMargin = ISoloMargin(SOLO_MARGIN_ADDRESS);\\n    }\\n\\n    function addSavingsProxy(address _savingsProxy) public auth {\\n        savingsProxy = _savingsProxy;\\n    }\\n\\n    function deposit(address _user, uint _amount) public override {\\n        require(msg.sender == _user);\\n\\n        Account.Info[] memory accounts = new Account.Info[](1);\\n        accounts[0] = getAccount(_user, 0);\\n\\n        Actions.ActionArgs[] memory actions = new Actions.ActionArgs[](1);\\n        Types.AssetAmount memory amount = Types.AssetAmount({\\n            sign: true,\\n            denomination: Types.AssetDenomination.Wei,\\n            ref: Types.AssetReference.Delta,\\n            value: _amount\\n        });\\n\\n        actions[0] = Actions.ActionArgs({\\n            actionType: Actions.ActionType.Deposit,\\n            accountId: 0,\\n            amount: amount,\\n            primaryMarketId: daiMarketId,\\n            otherAddress: _user,\\n            secondaryMarketId: 0, //not used\\n            otherAccountId: 0, //not used\\n            data: \\\"\\\" //not used\\n        });\\n\\n        soloMargin.operate(accounts, actions);\\n    }\\n\\n    function withdraw(address _user, uint _amount) public override {\\n        require(msg.sender == _user);\\n\\n        Account.Info[] memory accounts = new Account.Info[](1);\\n        accounts[0] = getAccount(_user, 0);\\n\\n        Actions.ActionArgs[] memory actions = new Actions.ActionArgs[](1);\\n        Types.AssetAmount memory amount = Types.AssetAmount({\\n            sign: false,\\n            denomination: Types.AssetDenomination.Wei,\\n            ref: Types.AssetReference.Delta,\\n            value: _amount\\n        });\\n\\n        actions[0] = Actions.ActionArgs({\\n            actionType: Actions.ActionType.Withdraw,\\n            accountId: 0,\\n            amount: amount,\\n            primaryMarketId: daiMarketId,\\n            otherAddress: _user,\\n            secondaryMarketId: 0, //not used\\n            otherAccountId: 0, //not used\\n            data: \\\"\\\" //not used\\n        });\\n\\n        soloMargin.operate(accounts, actions);\\n    }\\n\\n    function getWeiBalance(address _user, uint _index) public view returns(Types.Wei memory) {\\n\\n        Types.Wei[] memory weiBalances;\\n        (,,weiBalances) = soloMargin.getAccountBalances(getAccount(_user, _index));\\n\\n        return weiBalances[daiMarketId];\\n    }\\n\\n    function getParBalance(address _user, uint _index) public view returns(Types.Par memory) {\\n        Types.Par[] memory parBalances;\\n        (,parBalances,) = soloMargin.getAccountBalances(getAccount(_user, _index));\\n\\n        return parBalances[daiMarketId];\\n    }\\n\\n    function getAccount(address _user, uint _index) public pure returns(Account.Info memory) {\\n        Account.Info memory account = Account.Info({\\n            owner: _user,\\n            number: _index\\n        });\\n\\n        return account;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/reflexer/saver/RAISaverFlashLoan.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./RAISaverTaker.sol\\\";\\nimport \\\"../saver/RAISaverProxy.sol\\\";\\nimport \\\"../../savings/dydx/ISoloMargin.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeCore.sol\\\";\\n\\ncontract RAISaverFlashLoan is RAISaverProxy, AdminAuth {\\n\\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    function callFunction(\\n        address,\\n        Account.Info memory,\\n        bytes memory _params\\n    ) public {\\n\\n        (\\n            bytes memory exDataBytes ,\\n            RAISaverTaker.SaverData memory saverData\\n        )\\n         = abi.decode(_params, (bytes, RAISaverTaker.SaverData));\\n\\n\\n        ExchangeData memory exchangeData = unpackExchangeData(exDataBytes);\\n\\n        address managerAddr = getManagerAddr(saverData.managerType);\\n        address userProxy = ISAFEManager(managerAddr).ownsSAFE(saverData.safeId);\\n\\n        if (saverData.isRepay) {\\n            repayWithLoan(exchangeData, saverData);\\n        } else {\\n            boostWithLoan(exchangeData, saverData);\\n        }\\n\\n        // payback FL, assumes we have weth\\n        TokenInterface(WETH_ADDR).deposit{value: (address(this).balance)}();\\n        ERC20(WETH_ADDR).safeTransfer(userProxy, (saverData.flAmount + 2));\\n    }\\n\\n    function boostWithLoan(\\n        ExchangeData memory _exchangeData,\\n        RAISaverTaker.SaverData memory _saverData\\n    ) internal {\\n\\n        address managerAddr = getManagerAddr(_saverData.managerType);\\n        address user = getOwner(ISAFEManager(managerAddr), _saverData.safeId);\\n        bytes32 collType = ISAFEManager(managerAddr).collateralTypes(_saverData.safeId);\\n\\n        addCollateral(managerAddr, _saverData.safeId, _saverData.joinAddr, _saverData.flAmount, false);\\n\\n        // Draw users Rai\\n        uint raiDrawn = drawRai(managerAddr, _saverData.safeId, collType, _exchangeData.srcAmount);\\n\\n        // Swap\\n        _exchangeData.srcAmount = raiDrawn - takeFee(_saverData.gasCost, raiDrawn);\\n        _exchangeData.user = user;\\n        _exchangeData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\\n\\n        (, uint swapedAmount) = _sell(_exchangeData);\\n\\n        // Return collateral\\n        addCollateral(managerAddr, _saverData.safeId, _saverData.joinAddr, swapedAmount, true);\\n        // Draw collateral to repay the flash loan\\n        drawCollateral(managerAddr, _saverData.safeId, _saverData.joinAddr, _saverData.flAmount, false);\\n\\n        logger.Log(address(this), msg.sender, \\\"RAIFlashBoost\\\", abi.encode(_saverData.safeId, user, _exchangeData.srcAmount, swapedAmount));\\n    }\\n\\n    function repayWithLoan(\\n        ExchangeData memory _exchangeData,\\n        RAISaverTaker.SaverData memory _saverData\\n    ) internal {\\n\\n        TokenInterface(WETH_ADDR).withdraw(_saverData.flAmount);\\n\\n        address managerAddr = getManagerAddr(_saverData.managerType);\\n\\n        address user = getOwner(ISAFEManager(managerAddr), _saverData.safeId);\\n        bytes32 collType = ISAFEManager(managerAddr).collateralTypes(_saverData.safeId);\\n\\n        // Swap\\n        _exchangeData.srcAmount = _saverData.flAmount;\\n        _exchangeData.user = user;\\n\\n        _exchangeData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\\n\\n        (, uint paybackAmount) = _sell(_exchangeData);\\n\\n        paybackAmount -= takeFee(_saverData.gasCost, paybackAmount);\\n        paybackAmount = limitLoanAmount(managerAddr, _saverData.safeId, collType, paybackAmount, user);\\n\\n        // Payback the debt\\n        paybackDebt(managerAddr, _saverData.safeId, collType, paybackAmount, user);\\n\\n        // Draw collateral to repay the flash loan\\n        drawCollateral(managerAddr, _saverData.safeId, _saverData.joinAddr, _saverData.flAmount, false);\\n\\n        logger.Log(address(this), msg.sender, \\\"RAIFlashRepay\\\", abi.encode(_saverData.safeId, user, _exchangeData.srcAmount, paybackAmount));\\n    }\\n\\n    /// @notice Handles that the amount is not bigger than cdp debt and not dust\\n    function limitLoanAmount(address _managerAddr, uint _safeId, bytes32 _collType, uint _paybackAmount, address _owner) internal returns (uint256) {\\n        uint debt = getAllDebt(address(safeEngine), ISAFEManager(_managerAddr).safes(_safeId), ISAFEManager(_managerAddr).safes(_safeId), _collType);\\n\\n        if (_paybackAmount > debt) {\\n            ERC20(RAI_ADDRESS).transfer(_owner, (_paybackAmount - debt));\\n            return debt;\\n        }\\n\\n        uint debtLeft = debt - _paybackAmount;\\n\\n        (,,,, uint dust,) = safeEngine.collateralTypes(_collType);\\n        dust = dust / 10**27;\\n\\n        // Less than dust value\\n        if (debtLeft < dust) {\\n            uint amountOverDust = (dust - debtLeft);\\n\\n            ERC20(RAI_ADDRESS).transfer(_owner, amountOverDust);\\n\\n            return (_paybackAmount - amountOverDust);\\n        }\\n\\n        return _paybackAmount;\\n    }\\n\\n    receive() external override(DFSExchangeCore) payable {}\\n\\n}\\n\"\r\n    },\r\n    \"contracts/aaveV2/saver/AaveSaverReceiverV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../savings/dydx/ISoloMargin.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../interfaces/TokenInterface.sol\\\";\\nimport \\\"../../DS/DSProxy.sol\\\";\\nimport \\\"../AaveHelperV2.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeData.sol\\\";\\n\\n/// @title Import Aave position from account to wallet\\ncontract AaveSaverReceiverV2 is AaveHelperV2, AdminAuth, DFSExchangeData {\\n\\n    using SafeERC20 for ERC20;\\n\\n    address public constant AAVE_SAVER_PROXY = 0xBBCD23145Ab10C369c9e5D3b1D58506B0cD2ab44;\\n    address public constant AAVE_BASIC_PROXY = 0xc17c8eB12Ba24D62E69fd57cbd504EEf418867f9;\\n    address public constant AETH_ADDRESS = 0x030bA81f1c18d280636F32af80b9AAd02Cf0854e;\\n\\n    function callFunction(\\n        address sender,\\n        Account.Info memory account,\\n        bytes memory data\\n    ) public {\\n        (\\n            bytes memory exchangeDataBytes,\\n            address market,\\n            uint256 rateMode,\\n            uint256 gasCost,\\n            bool isRepay,\\n            uint256 ethAmount,\\n            uint256 txValue,\\n            address user,\\n            address proxy\\n        )\\n        = abi.decode(data, (bytes,address,uint256,uint256,bool,uint256,uint256,address,address));\\n\\n        // withdraw eth\\n        TokenInterface(WETH_ADDRESS).withdraw(ethAmount);\\n\\n        // deposit eth on behalf of proxy\\n        DSProxy(payable(proxy)).execute{value: ethAmount}(AAVE_BASIC_PROXY, abi.encodeWithSignature(\\\"deposit(address,address,uint256)\\\", market, ETH_ADDR, ethAmount));\\n\\n        bytes memory functionData = packFunctionCall(market, exchangeDataBytes, rateMode, gasCost, isRepay);\\n        DSProxy(payable(proxy)).execute{value: txValue}(AAVE_SAVER_PROXY, functionData);\\n\\n        // withdraw deposited eth\\n        DSProxy(payable(proxy)).execute(AAVE_BASIC_PROXY, abi.encodeWithSignature(\\\"withdraw(address,address,uint256)\\\", market, ETH_ADDR, ethAmount));\\n\\n        // deposit eth, get weth and return to sender\\n        TokenInterface(WETH_ADDRESS).deposit.value(address(this).balance)();\\n        ERC20(WETH_ADDRESS).safeTransfer(proxy, ethAmount+2);\\n    }\\n\\n    function packFunctionCall(address _market, bytes memory _exchangeDataBytes, uint256 _rateMode, uint256 _gasCost, bool _isRepay) internal returns (bytes memory) {\\n        ExchangeData memory exData = unpackExchangeData(_exchangeDataBytes);\\n\\n        bytes memory functionData;\\n\\n        if (_isRepay) {\\n            functionData = abi.encodeWithSignature(\\\"repay(address,(address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256,uint256)\\\", _market, exData, _rateMode, _gasCost);\\n        } else {\\n            functionData = abi.encodeWithSignature(\\\"boost(address,(address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256,uint256)\\\", _market, exData, _rateMode, _gasCost);\\n        }\\n\\n        return functionData;\\n    }\\n\\n    /// @dev if contract receive eth, convert it to WETH\\n    receive() external payable {\\n        // deposit eth and get weth\\n        if (msg.sender == owner) {\\n            TokenInterface(WETH_ADDRESS).deposit.value(address(this).balance)();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/aaveV2/AaveHelperV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../DS/DSMath.sol\\\";\\nimport \\\"../DS/DSProxy.sol\\\";\\nimport \\\"../utils/Discount.sol\\\";\\nimport \\\"../interfaces/IFeeRecipient.sol\\\";\\nimport \\\"../interfaces/IAToken.sol\\\";\\nimport \\\"../interfaces/ILendingPoolV2.sol\\\";\\nimport \\\"../interfaces/IPriceOracleGetterAave.sol\\\";\\nimport \\\"../interfaces/IAaveProtocolDataProviderV2.sol\\\";\\n\\nimport \\\"../utils/SafeERC20.sol\\\";\\nimport \\\"../utils/BotRegistry.sol\\\";\\n\\ncontract AaveHelperV2 is DSMath {\\n\\n    using SafeERC20 for ERC20;\\n\\n    IFeeRecipient public constant feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);\\n\\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // mainnet\\n\\n    uint public constant MANUAL_SERVICE_FEE = 400; // 0.25% Fee\\n    uint public constant AUTOMATIC_SERVICE_FEE = 333; // 0.3% Fee\\n\\n    address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;\\n\\n\\taddress public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    uint public constant NINETY_NINE_PERCENT_WEI = 990000000000000000;\\n    uint16 public constant AAVE_REFERRAL_CODE = 64;\\n\\n    uint public constant STABLE_ID = 1;\\n    uint public constant VARIABLE_ID = 2;\\n\\n    /// @notice Calculates the gas cost for transaction\\n    /// @param _oracleAddress address of oracle used\\n    /// @param _amount Amount that is converted\\n    /// @param _user Actuall user addr not DSProxy\\n    /// @param _gasCost Ether amount of gas we are spending for tx\\n    /// @param _tokenAddr token addr. of token we are getting for the fee\\n    /// @return gasCost The amount we took for the gas cost\\n    function getGasCost(address _oracleAddress, uint _amount, address _user, uint _gasCost, address _tokenAddr) internal returns (uint gasCost) {\\n        if (_gasCost == 0) return 0;\\n\\n        // in case its ETH, we need to get price for WETH\\n        // everywhere else  we still use ETH as thats the token we have in this moment\\n        address priceToken = _tokenAddr == ETH_ADDR ? WETH_ADDRESS : _tokenAddr;\\n        uint256 price = IPriceOracleGetterAave(_oracleAddress).getAssetPrice(priceToken);\\n        _gasCost = wdiv(_gasCost, price) / (10 ** (18 - _getDecimals(_tokenAddr)));\\n        gasCost = _gasCost;\\n\\n        // gas cost can't go over 20% of the whole amount\\n        if (gasCost > (_amount / 5)) {\\n            gasCost = _amount / 5;\\n        }\\n\\n        address walletAddr = feeRecipient.getFeeAddr();\\n\\n        if (_tokenAddr == ETH_ADDR) {\\n            payable(walletAddr).transfer(gasCost);\\n        } else {\\n            ERC20(_tokenAddr).safeTransfer(walletAddr, gasCost);\\n        }\\n    }\\n\\n\\n    /// @notice Returns the owner of the DSProxy that called the contract\\n    function getUserAddress() internal view returns (address) {\\n        DSProxy proxy = DSProxy(payable(address(this)));\\n\\n        return proxy.owner();\\n    }\\n\\n    /// @notice Approves token contract to pull underlying tokens from the DSProxy\\n    /// @param _tokenAddr Token we are trying to approve\\n    /// @param _caller Address which will gain the approval\\n    function approveToken(address _tokenAddr, address _caller) internal {\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeApprove(_caller, uint256(-1));\\n        }\\n    }\\n\\n    /// @notice Send specific amount from contract to specific user\\n    /// @param _token Token we are trying to send\\n    /// @param _user User that should receive funds\\n    /// @param _amount Amount that should be sent\\n    function sendContractBalance(address _token, address _user, uint _amount) internal {\\n        if (_amount == 0) return;\\n\\n        if (_token == ETH_ADDR) {\\n            payable(_user).transfer(_amount);\\n        } else {\\n            ERC20(_token).safeTransfer(_user, _amount);\\n        }\\n    }\\n\\n    function sendFullContractBalance(address _token, address _user) internal {\\n        if (_token == ETH_ADDR) {\\n            sendContractBalance(_token, _user, address(this).balance);\\n        } else {\\n            sendContractBalance(_token, _user, ERC20(_token).balanceOf(address(this)));\\n        }\\n    }\\n\\n    function _getDecimals(address _token) internal view returns (uint256) {\\n        if (_token == ETH_ADDR) return 18;\\n\\n        return ERC20(_token).decimals();\\n    }\\n\\n    function getDataProvider(address _market) internal view returns(IAaveProtocolDataProviderV2) {\\n        return IAaveProtocolDataProviderV2(ILendingPoolAddressesProviderV2(_market).getAddress(0x0100000000000000000000000000000000000000000000000000000000000000));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingPoolV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title LendingPoolAddressesProvider contract\\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\\n * - Owned by the Aave Governance\\n * @author Aave\\n **/\\ninterface ILendingPoolAddressesProviderV2 {\\n  event LendingPoolUpdated(address indexed newAddress);\\n  event ConfigurationAdminUpdated(address indexed newAddress);\\n  event EmergencyAdminUpdated(address indexed newAddress);\\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\\n  event PriceOracleUpdated(address indexed newAddress);\\n  event LendingRateOracleUpdated(address indexed newAddress);\\n  event ProxyCreated(bytes32 id, address indexed newAddress);\\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\\n\\n  function setAddress(bytes32 id, address newAddress) external;\\n\\n  function setAddressAsProxy(bytes32 id, address impl) external;\\n\\n  function getAddress(bytes32 id) external view returns (address);\\n\\n  function getLendingPool() external view returns (address);\\n\\n  function setLendingPoolImpl(address pool) external;\\n\\n  function getLendingPoolConfigurator() external view returns (address);\\n\\n  function setLendingPoolConfiguratorImpl(address configurator) external;\\n\\n  function getLendingPoolCollateralManager() external view returns (address);\\n\\n  function setLendingPoolCollateralManager(address manager) external;\\n\\n  function getPoolAdmin() external view returns (address);\\n\\n  function setPoolAdmin(address admin) external;\\n\\n  function getEmergencyAdmin() external view returns (address);\\n\\n  function setEmergencyAdmin(address admin) external;\\n\\n  function getPriceOracle() external view returns (address);\\n\\n  function setPriceOracle(address priceOracle) external;\\n\\n  function getLendingRateOracle() external view returns (address);\\n\\n  function setLendingRateOracle(address lendingRateOracle) external;\\n}\\n\\nlibrary DataTypes {\\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\n  struct ReserveData {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    //the liquidity index. Expressed in ray\\n    uint128 liquidityIndex;\\n    //variable borrow index. Expressed in ray\\n    uint128 variableBorrowIndex;\\n    //the current supply rate. Expressed in ray\\n    uint128 currentLiquidityRate;\\n    //the current variable borrow rate. Expressed in ray\\n    uint128 currentVariableBorrowRate;\\n    //the current stable borrow rate. Expressed in ray\\n    uint128 currentStableBorrowRate;\\n    uint40 lastUpdateTimestamp;\\n    //tokens addresses\\n    address aTokenAddress;\\n    address stableDebtTokenAddress;\\n    address variableDebtTokenAddress;\\n    //address of the interest rate strategy\\n    address interestRateStrategyAddress;\\n    //the id of the reserve. Represents the position in the list of the active reserves\\n    uint8 id;\\n  }\\n\\n  struct ReserveConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 48-55: Decimals\\n    //bit 56: Reserve is active\\n    //bit 57: reserve is frozen\\n    //bit 58: borrowing is enabled\\n    //bit 59: stable rate borrowing enabled\\n    //bit 60-63: reserved\\n    //bit 64-79: reserve factor\\n    uint256 data;\\n  }\\n\\n  struct UserConfigurationMap {\\n    uint256 data;\\n  }\\n\\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\\n}\\n\\ninterface ILendingPoolV2 {\\n  /**\\n   * @dev Emitted on deposit()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address initiating the deposit\\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\\n   * @param amount The amount deposited\\n   * @param referral The referral code used\\n   **/\\n  event Deposit(\\n    address indexed reserve,\\n    address user,\\n    address indexed onBehalfOf,\\n    uint256 amount,\\n    uint16 indexed referral\\n  );\\n\\n  /**\\n   * @dev Emitted on withdraw()\\n   * @param reserve The address of the underlyng asset being withdrawn\\n   * @param user The address initiating the withdrawal, owner of aTokens\\n   * @param to Address that will receive the underlying\\n   * @param amount The amount to be withdrawn\\n   **/\\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\\n\\n  /**\\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\\n   * @param reserve The address of the underlying asset being borrowed\\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\\n   * initiator of the transaction on flashLoan()\\n   * @param onBehalfOf The address that will be getting the debt\\n   * @param amount The amount borrowed out\\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\\n   * @param borrowRate The numeric rate at which the user has borrowed\\n   * @param referral The referral code used\\n   **/\\n  event Borrow(\\n    address indexed reserve,\\n    address user,\\n    address indexed onBehalfOf,\\n    uint256 amount,\\n    uint256 borrowRateMode,\\n    uint256 borrowRate,\\n    uint16 indexed referral\\n  );\\n\\n  /**\\n   * @dev Emitted on repay()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The beneficiary of the repayment, getting his debt reduced\\n   * @param repayer The address of the user initiating the repay(), providing the funds\\n   * @param amount The amount repaid\\n   **/\\n  event Repay(\\n    address indexed reserve,\\n    address indexed user,\\n    address indexed repayer,\\n    uint256 amount\\n  );\\n\\n  /**\\n   * @dev Emitted on swapBorrowRateMode()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address of the user swapping his rate mode\\n   * @param rateMode The rate mode that the user wants to swap to\\n   **/\\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\\n\\n  /**\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address of the user enabling the usage as collateral\\n   **/\\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\\n\\n  /**\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address of the user enabling the usage as collateral\\n   **/\\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\\n\\n  /**\\n   * @dev Emitted on rebalanceStableBorrowRate()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address of the user for which the rebalance has been executed\\n   **/\\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\\n\\n  /**\\n   * @dev Emitted on flashLoan()\\n   * @param target The address of the flash loan receiver contract\\n   * @param initiator The address initiating the flash loan\\n   * @param asset The address of the asset being flash borrowed\\n   * @param amount The amount flash borrowed\\n   * @param premium The fee flash borrowed\\n   * @param referralCode The referral code used\\n   **/\\n  event FlashLoan(\\n    address indexed target,\\n    address indexed initiator,\\n    address indexed asset,\\n    uint256 amount,\\n    uint256 premium,\\n    uint16 referralCode\\n  );\\n\\n  /**\\n   * @dev Emitted when the pause is triggered.\\n   */\\n  event Paused();\\n\\n  /**\\n   * @dev Emitted when the pause is lifted.\\n   */\\n  event Unpaused();\\n\\n  /**\\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\\n   * LendingPoolCollateral manager using a DELEGATECALL\\n   * This allows to have the events in the generated ABI for LendingPool.\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\n   * @param user The address of the borrower getting liquidated\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\\n   * @param liquidator The address of the liquidator\\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\\n   * to receive the underlying collateral asset directly\\n   **/\\n  event LiquidationCall(\\n    address indexed collateralAsset,\\n    address indexed debtAsset,\\n    address indexed user,\\n    uint256 debtToCover,\\n    uint256 liquidatedCollateralAmount,\\n    address liquidator,\\n    bool receiveAToken\\n  );\\n\\n  /**\\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\\n   * gets added to the LendingPool ABI\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param liquidityRate The new liquidity rate\\n   * @param stableBorrowRate The new stable borrow rate\\n   * @param variableBorrowRate The new variable borrow rate\\n   * @param liquidityIndex The new liquidity index\\n   * @param variableBorrowIndex The new variable borrow index\\n   **/\\n  event ReserveDataUpdated(\\n    address indexed reserve,\\n    uint256 liquidityRate,\\n    uint256 stableBorrowRate,\\n    uint256 variableBorrowRate,\\n    uint256 liquidityIndex,\\n    uint256 variableBorrowIndex\\n  );\\n\\n  /**\\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\n   * @param asset The address of the underlying asset to deposit\\n   * @param amount The amount to be deposited\\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n   *   is a different wallet\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   **/\\n  function deposit(\\n    address asset,\\n    uint256 amount,\\n    address onBehalfOf,\\n    uint16 referralCode\\n  ) external;\\n\\n  /**\\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n   * @param asset The address of the underlying asset to withdraw\\n   * @param amount The underlying amount to be withdrawn\\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n   * @param to Address that will receive the underlying, same as msg.sender if the user\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n   *   different wallet\\n   **/\\n  function withdraw(\\n    address asset,\\n    uint256 amount,\\n    address to\\n  ) external;\\n\\n  /**\\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\\n   * @param asset The address of the underlying asset to borrow\\n   * @param amount The amount to be borrowed\\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\n   * if he has been given credit delegation allowance\\n   **/\\n  function borrow(\\n    address asset,\\n    uint256 amount,\\n    uint256 interestRateMode,\\n    uint16 referralCode,\\n    address onBehalfOf\\n  ) external;\\n\\n  /**\\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\\n   * @param asset The address of the borrowed underlying asset previously borrowed\\n   * @param amount The amount to repay\\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\n   * other borrower whose debt should be removed\\n   **/\\n  function repay(\\n    address asset,\\n    uint256 amount,\\n    uint256 rateMode,\\n    address onBehalfOf\\n  ) external;\\n\\n  /**\\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\\n   * @param asset The address of the underlying asset borrowed\\n   * @param rateMode The rate mode that the user wants to swap to\\n   **/\\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\\n\\n  /**\\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\\n   * - Users can be rebalanced if the following conditions are satisfied:\\n   *     1. Usage ratio is above 95%\\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\\n   *        borrowed at a stable rate and depositors are not earning enough\\n   * @param asset The address of the underlying asset borrowed\\n   * @param user The address of the user to be rebalanced\\n   **/\\n  function rebalanceStableBorrowRate(address asset, address user) external;\\n\\n  /**\\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\\n   * @param asset The address of the underlying asset deposited\\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\\n   **/\\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\\n\\n  /**\\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\n   * @param user The address of the borrower getting liquidated\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\\n   * to receive the underlying collateral asset directly\\n   **/\\n  function liquidationCall(\\n    address collateralAsset,\\n    address debtAsset,\\n    address user,\\n    uint256 debtToCover,\\n    bool receiveAToken\\n  ) external;\\n\\n  /**\\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\\n   * as long as the amount taken plus a fee is returned.\\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\\n   * For further details please visit https://developers.aave.com\\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\\n   * @param assets The addresses of the assets being flash-borrowed\\n   * @param amounts The amounts amounts being flash-borrowed\\n   * @param modes Types of the debt to open if the flash loan is not returned:\\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\\n   * @param params Variadic packed params to pass to the receiver as extra information\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   **/\\n  function flashLoan(\\n    address receiverAddress,\\n    address[] calldata assets,\\n    uint256[] calldata amounts,\\n    uint256[] calldata modes,\\n    address onBehalfOf,\\n    bytes calldata params,\\n    uint16 referralCode\\n  ) external;\\n\\n  /**\\n   * @dev Returns the user account data across all the reserves\\n   * @param user The address of the user\\n   * @return totalCollateralETH the total collateral in ETH of the user\\n   * @return totalDebtETH the total debt in ETH of the user\\n   * @return availableBorrowsETH the borrowing power left of the user\\n   * @return currentLiquidationThreshold the liquidation threshold of the user\\n   * @return ltv the loan to value of the user\\n   * @return healthFactor the current health factor of the user\\n   **/\\n  function getUserAccountData(address user)\\n    external\\n    view\\n    returns (\\n      uint256 totalCollateralETH,\\n      uint256 totalDebtETH,\\n      uint256 availableBorrowsETH,\\n      uint256 currentLiquidationThreshold,\\n      uint256 ltv,\\n      uint256 healthFactor\\n    );\\n\\n  function initReserve(\\n    address reserve,\\n    address aTokenAddress,\\n    address stableDebtAddress,\\n    address variableDebtAddress,\\n    address interestRateStrategyAddress\\n  ) external;\\n\\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\\n    external;\\n\\n  function setConfiguration(address reserve, uint256 configuration) external;\\n\\n  /**\\n   * @dev Returns the configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The configuration of the reserve\\n   **/\\n  function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\\n\\n  /**\\n   * @dev Returns the configuration of the user across all the reserves\\n   * @param user The user address\\n   * @return The configuration of the user\\n   **/\\n  function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\\n\\n  /**\\n   * @dev Returns the normalized income normalized income of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve's normalized income\\n   */\\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the normalized variable debt per unit of asset\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve normalized variable debt\\n   */\\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the state and configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The state of the reserve\\n   **/\\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\\n\\n  function finalizeTransfer(\\n    address asset,\\n    address from,\\n    address to,\\n    uint256 amount,\\n    uint256 balanceFromAfter,\\n    uint256 balanceToBefore\\n  ) external;\\n\\n  function getReservesList() external view returns (address[] memory);\\n\\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProviderV2);\\n\\n  function setPause(bool val) external;\\n\\n  function paused() external view returns (bool);\\n}\\n\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceOracleGetterAave.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/************\\n@title IPriceOracleGetterAave interface\\n@notice Interface for the Aave price oracle.*/\\nabstract contract IPriceOracleGetterAave {\\n    function getAssetPrice(address _asset) external virtual view returns (uint256);\\n    function getAssetsPrices(address[] calldata _assets) external virtual view returns(uint256[] memory);\\n    function getSourceOfAsset(address _asset) external virtual view returns(address);\\n    function getFallbackOracle() external virtual view returns(address);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IAaveProtocolDataProviderV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nabstract contract IAaveProtocolDataProviderV2 {\\n\\n  struct TokenData {\\n    string symbol;\\n    address tokenAddress;\\n  }\\n\\n  function getAllReservesTokens() external virtual view returns (TokenData[] memory);\\n\\n  function getAllATokens() external virtual view returns (TokenData[] memory);\\n\\n  function getReserveConfigurationData(address asset)\\n    external virtual\\n    view\\n    returns (\\n      uint256 decimals,\\n      uint256 ltv,\\n      uint256 liquidationThreshold,\\n      uint256 liquidationBonus,\\n      uint256 reserveFactor,\\n      bool usageAsCollateralEnabled,\\n      bool borrowingEnabled,\\n      bool stableBorrowRateEnabled,\\n      bool isActive,\\n      bool isFrozen\\n    );\\n\\n  function getReserveData(address asset)\\n    external virtual\\n    view\\n    returns (\\n      uint256 availableLiquidity,\\n      uint256 totalStableDebt,\\n      uint256 totalVariableDebt,\\n      uint256 liquidityRate,\\n      uint256 variableBorrowRate,\\n      uint256 stableBorrowRate,\\n      uint256 averageStableBorrowRate,\\n      uint256 liquidityIndex,\\n      uint256 variableBorrowIndex,\\n      uint40 lastUpdateTimestamp\\n    );\\n\\n  function getUserReserveData(address asset, address user)\\n    external virtual\\n    view\\n    returns (\\n      uint256 currentATokenBalance,\\n      uint256 currentStableDebt,\\n      uint256 currentVariableDebt,\\n      uint256 principalStableDebt,\\n      uint256 scaledVariableDebt,\\n      uint256 stableBorrowRate,\\n      uint256 liquidityRate,\\n      uint40 stableRateLastUpdated,\\n      bool usageAsCollateralEnabled\\n    );\\n\\n  function getReserveTokensAddresses(address asset)\\n    external virtual\\n    view\\n    returns (\\n      address aTokenAddress,\\n      address stableDebtTokenAddress,\\n      address variableDebtTokenAddress\\n    );\\n}\"\r\n    },\r\n    \"contracts/aaveV2/saver/optimized/AaveSaverTakerOV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../AaveHelperV2.sol\\\";\\nimport \\\"../../../utils/GasBurner.sol\\\";\\nimport \\\"../../../auth/AdminAuth.sol\\\";\\nimport \\\"../../../auth/ProxyPermission.sol\\\";\\nimport \\\"../../../utils/DydxFlashLoanBase.sol\\\";\\nimport \\\"../../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../../interfaces/ProxyRegistryInterface.sol\\\";\\nimport \\\"../../../interfaces/TokenInterface.sol\\\";\\nimport \\\"../../../interfaces/ERC20.sol\\\";\\nimport \\\"../../../exchangeV3/DFSExchangeData.sol\\\";\\n\\n/// @title Import Aave position from account to wallet\\n/// @dev Contract needs to have enough wei in WETH for all transactions (2 WETH wei per transaction)\\ncontract AaveSaverTakerOV2 is ProxyPermission, GasBurner, DFSExchangeData, AaveHelperV2 {\\n\\n    address payable public constant AAVE_RECEIVER = 0xe71CAcE3655EB75d9eFeD9731a3a765dbF964004;\\n\\n    // leaving _flAmount to be the same as the older version\\n    function repay(address _market, ExchangeData memory _data, uint _rateMode, uint256 _gasCost, uint _flAmount) public payable burnGas(10) {\\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\\n\\n        // send msg.value for exchange to the receiver\\n        AAVE_RECEIVER.transfer(msg.value);\\n\\n        address[] memory assets = new address[](1);\\n        assets[0] = _data.srcAddr;\\n\\n        uint256[] memory amounts = new uint256[](1);\\n        amounts[0] = _data.srcAmount;\\n\\n        // for repay we are using regular flash loan with paying back the flash loan + premium\\n        uint256[] memory modes = new uint256[](1);\\n        modes[0] = 0;\\n\\n        // create data\\n        bytes memory encodedData = packExchangeData(_data);\\n        bytes memory data = abi.encode(encodedData, _market, _gasCost, _rateMode, true, address(this));\\n\\n        // give permission to receiver and execute tx\\n        givePermission(AAVE_RECEIVER);\\n        ILendingPoolV2(lendingPool).flashLoan(AAVE_RECEIVER, assets, amounts, modes, address(this), data, AAVE_REFERRAL_CODE);\\n        removePermission(AAVE_RECEIVER);\\n    }\\n\\n    // leaving _flAmount to be the same as the older version\\n    function boost(address _market, ExchangeData memory _data, uint _rateMode, uint256 _gasCost, uint _flAmount) public payable burnGas(10) {\\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\\n\\n        // send msg.value for exchange to the receiver\\n        AAVE_RECEIVER.transfer(msg.value);\\n\\n        address[] memory assets = new address[](1);\\n        assets[0] = _data.srcAddr;\\n\\n        uint256[] memory amounts = new uint256[](1);\\n        amounts[0] = _data.srcAmount;\\n\\n        uint256[] memory modes = new uint256[](1);\\n        modes[0] = _rateMode;\\n\\n        // create data\\n        bytes memory encodedData = packExchangeData(_data);\\n        bytes memory data = abi.encode(encodedData, _market, _gasCost, _rateMode, false, address(this));\\n\\n        // give permission to receiver and execute tx\\n        givePermission(AAVE_RECEIVER);\\n        ILendingPoolV2(lendingPool).flashLoan(AAVE_RECEIVER, assets, amounts, modes, address(this), data, AAVE_REFERRAL_CODE);\\n        removePermission(AAVE_RECEIVER);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ProxyRegistryInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./DSProxyInterface.sol\\\";\\n\\nabstract contract ProxyRegistryInterface {\\n    function proxies(address _owner) public virtual view returns (address);\\n    function build(address) public virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/exchangeV3/wrappersV3/OasisTradeWrapperV3.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../interfaces/ExchangeInterfaceV3.sol\\\";\\nimport \\\"../../interfaces/OasisInterface.sol\\\";\\nimport \\\"../../interfaces/TokenInterface.sol\\\";\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\ncontract OasisTradeWrapperV3 is DSMath, ExchangeInterfaceV3, AdminAuth {\\n\\n    using SafeERC20 for ERC20;\\n\\n    address public constant OTC_ADDRESS = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;\\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @notice Sells a _srcAmount of tokens at Oasis\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _srcAmount From amount\\n    /// @return uint Destination amount\\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) external override payable returns (uint) {\\n        address srcAddr = ethToWethAddr(_srcAddr);\\n        address destAddr = ethToWethAddr(_destAddr);\\n\\n        ERC20(srcAddr).safeApprove(OTC_ADDRESS, _srcAmount);\\n\\n        uint destAmount = OasisInterface(OTC_ADDRESS).sellAllAmount(srcAddr, _srcAmount, destAddr, 0);\\n\\n        // convert weth -> eth and send back\\n        if (destAddr == WETH_ADDRESS) {\\n            TokenInterface(WETH_ADDRESS).withdraw(destAmount);\\n            msg.sender.transfer(destAmount);\\n        } else {\\n            ERC20(destAddr).safeTransfer(msg.sender, destAmount);\\n        }\\n\\n        return destAmount;\\n    }\\n\\n    /// @notice Buys a _destAmount of tokens at Oasis\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _destAmount To amount\\n    /// @return uint srcAmount\\n    function buy(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) external override payable returns(uint) {\\n        address srcAddr = ethToWethAddr(_srcAddr);\\n        address destAddr = ethToWethAddr(_destAddr);\\n\\n        ERC20(srcAddr).safeApprove(OTC_ADDRESS, uint(-1));\\n\\n        uint srcAmount = OasisInterface(OTC_ADDRESS).buyAllAmount(destAddr, _destAmount, srcAddr, uint(-1));\\n\\n        // convert weth -> eth and send back\\n        if (destAddr == WETH_ADDRESS) {\\n            TokenInterface(WETH_ADDRESS).withdraw(_destAmount);\\n            msg.sender.transfer(_destAmount);\\n        } else {\\n            ERC20(destAddr).safeTransfer(msg.sender, _destAmount);\\n        }\\n\\n        // Send the leftover from the source token back\\n        sendLeftOver(srcAddr);\\n\\n        return srcAmount;\\n    }\\n\\n    /// @notice Return a rate for which we can sell an amount of tokens\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _srcAmount From amount\\n    /// @return uint Rate\\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) public override view returns (uint) {\\n        address srcAddr = ethToWethAddr(_srcAddr);\\n        address destAddr = ethToWethAddr(_destAddr);\\n\\n        return wdiv(OasisInterface(OTC_ADDRESS).getBuyAmount(destAddr, srcAddr, _srcAmount), _srcAmount);\\n    }\\n\\n\\n    /// @notice Return a rate for which we can buy an amount of tokens\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _destAmount To amount\\n    /// @return uint Rate\\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) public override view returns (uint) {\\n        address srcAddr = ethToWethAddr(_srcAddr);\\n        address destAddr = ethToWethAddr(_destAddr);\\n\\n        return wdiv(1 ether, wdiv(OasisInterface(OTC_ADDRESS).getPayAmount(srcAddr, destAddr, _destAmount), _destAmount));\\n    }\\n\\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\\n    /// @param _srcAddr Source token address\\n     function sendLeftOver(address _srcAddr) internal {\\n        msg.sender.transfer(address(this).balance);\\n\\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\\n            ERC20(_srcAddr).safeTransfer(msg.sender, ERC20(_srcAddr).balanceOf(address(this)));\\n        }\\n    }\\n\\n    /// @notice Converts Kybers Eth address -> Weth\\n    /// @param _src Input address\\n    function ethToWethAddr(address _src) internal pure returns (address) {\\n        return _src == KYBER_ETH_ADDRESS ? WETH_ADDRESS : _src;\\n    }\\n\\n\\n    receive() payable external {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/OasisInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract OasisInterface {\\n    function getBuyAmount(address tokenToBuy, address tokenToPay, uint256 amountToPay)\\n        external\\n        virtual\\n        view\\n        returns (uint256 amountBought);\\n\\n    function getPayAmount(address tokenToPay, address tokenToBuy, uint256 amountToBuy)\\n        public virtual\\n        view\\n        returns (uint256 amountPaid);\\n\\n    function sellAllAmount(address pay_gem, uint256 pay_amt, address buy_gem, uint256 min_fill_amount)\\n        public virtual\\n        returns (uint256 fill_amt);\\n\\n    function buyAllAmount(address buy_gem, uint256 buy_amt, address pay_gem, uint256 max_fill_amount)\\n        public virtual\\n        returns (uint256 fill_amt);\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/bids/BidProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../interfaces/Join.sol\\\";\\nimport \\\"../../interfaces/ERC20.sol\\\";\\nimport \\\"../../interfaces/Vat.sol\\\";\\nimport \\\"../../interfaces/Flipper.sol\\\";\\nimport \\\"../../interfaces/Gem.sol\\\";\\n\\ncontract BidProxy {\\n\\n    address public constant DAI_JOIN = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\\n\\n    address public constant VAT_ADDRESS = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n\\n    function daiBid(uint _bidId, uint _amount, address _flipper) public {\\n        uint tendAmount = _amount * (10 ** 27);\\n\\n        joinDai(_amount);\\n\\n        (, uint lot, , , , , , ) = Flipper(_flipper).bids(_bidId);\\n\\n        Vat(VAT_ADDRESS).hope(_flipper);\\n\\n        Flipper(_flipper).tend(_bidId, lot, tendAmount);\\n    }\\n\\n    function collateralBid(uint _bidId, uint _amount, address _flipper) public {\\n        (uint bid, , , , , , , ) = Flipper(_flipper).bids(_bidId);\\n\\n        joinDai(bid / (10**27));\\n\\n        Vat(VAT_ADDRESS).hope(_flipper);\\n\\n        Flipper(_flipper).dent(_bidId, _amount, bid);\\n    }\\n\\n    function closeBid(uint _bidId, address _flipper, address _joinAddr) public {\\n        bytes32 ilk = Join(_joinAddr).ilk();\\n\\n        Flipper(_flipper).deal(_bidId);\\n        uint amount = Vat(VAT_ADDRESS).gem(ilk, address(this));\\n\\n        Vat(VAT_ADDRESS).hope(_joinAddr);\\n        Gem(_joinAddr).exit(msg.sender, amount);\\n    }\\n\\n    function exitCollateral(address _joinAddr) public {\\n        bytes32 ilk = Join(_joinAddr).ilk();\\n\\n        uint amount = Vat(VAT_ADDRESS).gem(ilk, address(this));\\n\\n        if(Join(_joinAddr).dec() != 18) {\\n            amount = amount / (10**(18 - Join(_joinAddr).dec()));\\n        }\\n\\n        Vat(VAT_ADDRESS).hope(_joinAddr);\\n        Gem(_joinAddr).exit(msg.sender, amount);\\n    }\\n\\n    function exitDai() public {\\n        uint amount = Vat(VAT_ADDRESS).dai(address(this)) / (10**27);\\n\\n        Vat(VAT_ADDRESS).hope(DAI_JOIN);\\n        Gem(DAI_JOIN).exit(msg.sender, amount);\\n    }\\n\\n    function withdrawToken(address _token) public {\\n        uint balance = ERC20(_token).balanceOf(address(this));\\n        ERC20(_token).transfer(msg.sender, balance);\\n    }\\n\\n    function withdrawEth() public {\\n        uint balance = address(this).balance;\\n        msg.sender.transfer(balance);\\n    }\\n\\n    function joinDai(uint _amount) internal {\\n        uint amountInVat = Vat(VAT_ADDRESS).dai(address(this)) / (10**27);\\n\\n        if (_amount > amountInVat) {\\n            uint amountDiff = (_amount - amountInVat) + 1;\\n\\n            ERC20(DAI_ADDRESS).transferFrom(msg.sender, address(this), amountDiff);\\n            ERC20(DAI_ADDRESS).approve(DAI_JOIN, amountDiff);\\n            Join(DAI_JOIN).join(address(this), amountDiff);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Flipper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract Flipper {\\n    function bids(uint _bidId) public virtual returns (uint256, uint256, address, uint48, uint48, address, address, uint256);\\n    function tend(uint id, uint lot, uint bid) virtual external;\\n    function dent(uint id, uint lot, uint bid) virtual external;\\n    function deal(uint id) virtual external;\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/MCDLoanInfo.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./saver/MCDSaverProxyHelper.sol\\\";\\nimport \\\"../interfaces/Spotter.sol\\\";\\n\\ncontract MCDLoanInfo is MCDSaverProxyHelper {\\n\\n    Manager public constant manager = Manager(0x5ef30b9986345249bc32d8928B7ee64DE9435E39);\\n    Vat public constant vat = Vat(0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B);\\n    Spotter public constant spotter = Spotter(0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3);\\n\\n    struct VaultInfo {\\n        address owner;\\n        uint256 ratio;\\n    \\tuint256 collateral;\\n    \\tuint256 debt;\\n    \\tbytes32 ilk;\\n    \\taddress urn;\\n    }\\n\\n\\t/// @notice Gets a price of the asset\\n    /// @param _ilk Ilk of the CDP\\n    function getPrice(bytes32 _ilk) public view returns (uint) {\\n        (, uint mat) = spotter.ilks(_ilk);\\n        (,,uint spot,,) = vat.ilks(_ilk);\\n\\n        return rmul(rmul(spot, spotter.par()), mat);\\n    }\\n\\n    /// @notice Gets CDP ratio\\n    /// @param _cdpId Id of the CDP\\n    /// @param _ilk Ilk of the CDP\\n    function getRatio(uint _cdpId, bytes32 _ilk) public view returns (uint) {\\n        uint price = getPrice( _ilk);\\n\\n        (uint collateral, uint debt) = getCdpInfo(manager, _cdpId, _ilk);\\n\\n        if (debt == 0) return 0;\\n\\n        return rdiv(wmul(collateral, price), debt);\\n    }\\n\\n    /// @notice Gets CDP info (collateral, debt, price, ilk)\\n    /// @param _cdpId Id of the CDP\\n    function getVaultInfo(uint _cdpId) public view returns (VaultInfo memory vaultInfo) {\\n        address urn = manager.urns(_cdpId);\\n        bytes32 ilk = manager.ilks(_cdpId);\\n\\n        (uint256 collateral, uint256 debt) = vat.urns(ilk, urn);\\n        (,uint rate,,,) = vat.ilks(ilk);\\n\\n        debt = rmul(debt, rate);\\n\\n        vaultInfo = VaultInfo({\\n            owner: manager.owns(_cdpId),\\n            ratio: getRatio(_cdpId, ilk),\\n            collateral: collateral,\\n            debt: debt,\\n            ilk: ilk,\\n            urn: urn\\n        });\\n    }\\n\\n    function getVaultInfos(uint256[] memory _cdps) public view returns (VaultInfo[] memory vaultInfos) {\\n    \\tvaultInfos = new VaultInfo[](_cdps.length);\\n\\n    \\tfor (uint256 i = 0; i < _cdps.length; i++) {\\n    \\t\\tvaultInfos[i] = getVaultInfo(_cdps[i]);\\n    \\t}\\n    }\\n\\n    function getRatios(uint256[] memory _cdps) public view returns (uint[] memory ratios) {\\n    \\tratios = new uint256[](_cdps.length);\\n\\n    \\tfor (uint256 i = 0; i<_cdps.length; i++) {\\n    \\t\\tbytes32 ilk = manager.ilks(_cdps[i]);\\n\\n    \\t\\tratios[i] = getRatio(_cdps[i], ilk);\\n    \\t}\\n    }\\n}\"\r\n    },\r\n    \"contracts/mcd/automaticV2/SubscriptionsV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../interfaces/Manager.sol\\\";\\nimport \\\"./StaticV2.sol\\\";\\nimport \\\"../saver/MCDSaverProxy.sol\\\";\\nimport \\\"../../interfaces/Vat.sol\\\";\\nimport \\\"../../interfaces/Spotter.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\n/// @title Handles subscriptions for automatic monitoring\\ncontract SubscriptionsV2 is AdminAuth, StaticV2 {\\n\\n    bytes32 internal constant ETH_ILK = 0x4554482d41000000000000000000000000000000000000000000000000000000;\\n    bytes32 internal constant BAT_ILK = 0x4241542d41000000000000000000000000000000000000000000000000000000;\\n\\n    address public constant MANAGER_ADDRESS = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\\n    address public constant VAT_ADDRESS = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\\n    address public constant SPOTTER_ADDRESS = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;\\n\\n    CdpHolder[] public subscribers;\\n    mapping (uint => SubPosition) public subscribersPos;\\n\\n    mapping (bytes32 => uint) public minLimits;\\n\\n    uint public changeIndex;\\n\\n    Manager public manager = Manager(MANAGER_ADDRESS);\\n    Vat public vat = Vat(VAT_ADDRESS);\\n    Spotter public spotter = Spotter(SPOTTER_ADDRESS);\\n    MCDSaverProxy public saverProxy;\\n\\n    event Subscribed(address indexed owner, uint cdpId);\\n    event Unsubscribed(address indexed owner, uint cdpId);\\n    event Updated(address indexed owner, uint cdpId);\\n    event ParamUpdates(address indexed owner, uint cdpId, uint128, uint128, uint128, uint128, bool boostEnabled);\\n\\n    /// @param _saverProxy Address of the MCDSaverProxy contract\\n    constructor(address _saverProxy) public {\\n        saverProxy = MCDSaverProxy(payable(_saverProxy));\\n\\n        minLimits[ETH_ILK] = 1700000000000000000;\\n        minLimits[BAT_ILK] = 1700000000000000000;\\n    }\\n\\n    /// @dev Called by the DSProxy contract which owns the CDP\\n    /// @notice Adds the users CDP in the list of subscriptions so it can be monitored\\n    /// @param _cdpId Id of the CDP\\n    /// @param _minRatio Minimum ratio below which repay is triggered\\n    /// @param _maxRatio Maximum ratio after which boost is triggered\\n    /// @param _optimalBoost Ratio amount which boost should target\\n    /// @param _optimalRepay Ratio amount which repay should target\\n    /// @param _boostEnabled Boolean determing if boost is enabled\\n    /// @param _nextPriceEnabled Boolean determing if we can use nextPrice for this cdp\\n    function subscribe(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled, bool _nextPriceEnabled) external {\\n        require(isOwner(msg.sender, _cdpId), \\\"Must be called by Cdp owner\\\");\\n\\n        // if boost is not enabled, set max ratio to max uint\\n        uint128 localMaxRatio = _boostEnabled ? _maxRatio : uint128(-1);\\n        require(checkParams(manager.ilks(_cdpId), _minRatio, localMaxRatio), \\\"Must be correct params\\\");\\n\\n        SubPosition storage subInfo = subscribersPos[_cdpId];\\n\\n        CdpHolder memory subscription = CdpHolder({\\n                minRatio: _minRatio,\\n                maxRatio: localMaxRatio,\\n                optimalRatioBoost: _optimalBoost,\\n                optimalRatioRepay: _optimalRepay,\\n                owner: msg.sender,\\n                cdpId: _cdpId,\\n                boostEnabled: _boostEnabled,\\n                nextPriceEnabled: _nextPriceEnabled\\n            });\\n\\n        changeIndex++;\\n\\n        if (subInfo.subscribed) {\\n            subscribers[subInfo.arrPos] = subscription;\\n\\n            emit Updated(msg.sender, _cdpId);\\n            emit ParamUpdates(msg.sender, _cdpId, _minRatio, localMaxRatio, _optimalBoost, _optimalRepay, _boostEnabled);\\n        } else {\\n            subscribers.push(subscription);\\n\\n            subInfo.arrPos = subscribers.length - 1;\\n            subInfo.subscribed = true;\\n\\n            emit Subscribed(msg.sender, _cdpId);\\n        }\\n    }\\n\\n    /// @notice Called by the users DSProxy\\n    /// @dev Owner who subscribed cancels his subscription\\n    function unsubscribe(uint _cdpId) external {\\n        require(isOwner(msg.sender, _cdpId), \\\"Must be called by Cdp owner\\\");\\n\\n        _unsubscribe(_cdpId);\\n    }\\n\\n    /// @dev Checks if the _owner is the owner of the CDP\\n    function isOwner(address _owner, uint _cdpId) internal view returns (bool) {\\n        return getOwner(_cdpId) == _owner;\\n    }\\n\\n    /// @dev Checks limit for minimum ratio and if minRatio is bigger than max\\n    function checkParams(bytes32 _ilk, uint128 _minRatio, uint128 _maxRatio) internal view returns (bool) {\\n        if (_minRatio < minLimits[_ilk]) {\\n            return false;\\n        }\\n\\n        if (_minRatio > _maxRatio) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @dev Internal method to remove a subscriber from the list\\n    function _unsubscribe(uint _cdpId) internal {\\n        require(subscribers.length > 0, \\\"Must have subscribers in the list\\\");\\n\\n        SubPosition storage subInfo = subscribersPos[_cdpId];\\n\\n        require(subInfo.subscribed, \\\"Must first be subscribed\\\");\\n\\n        uint lastCdpId = subscribers[subscribers.length - 1].cdpId;\\n\\n        SubPosition storage subInfo2 = subscribersPos[lastCdpId];\\n        subInfo2.arrPos = subInfo.arrPos;\\n\\n        subscribers[subInfo.arrPos] = subscribers[subscribers.length - 1];\\n        subscribers.pop();\\n\\n        changeIndex++;\\n        subInfo.subscribed = false;\\n        subInfo.arrPos = 0;\\n\\n        emit Unsubscribed(msg.sender, _cdpId);\\n    }\\n\\n    /// @notice Returns an address that owns the CDP\\n    /// @param _cdpId Id of the CDP\\n    function getOwner(uint _cdpId) public view returns(address) {\\n        return manager.owns(_cdpId);\\n    }\\n\\n    /// @notice Helper method for the front to get all the info about the subscribed CDP\\n    function getSubscribedInfo(uint _cdpId) public view returns(bool, uint128, uint128, uint128, uint128, address, uint coll, uint debt) {\\n        SubPosition memory subInfo = subscribersPos[_cdpId];\\n\\n        if (!subInfo.subscribed) return (false, 0, 0, 0, 0, address(0), 0, 0);\\n\\n        (coll, debt) = saverProxy.getCdpInfo(manager, _cdpId, manager.ilks(_cdpId));\\n\\n        CdpHolder memory subscriber = subscribers[subInfo.arrPos];\\n\\n        return (\\n            true,\\n            subscriber.minRatio,\\n            subscriber.maxRatio,\\n            subscriber.optimalRatioRepay,\\n            subscriber.optimalRatioBoost,\\n            subscriber.owner,\\n            coll,\\n            debt\\n        );\\n    }\\n\\n    function getCdpHolder(uint _cdpId) public view returns (bool subscribed, CdpHolder memory) {\\n        SubPosition memory subInfo = subscribersPos[_cdpId];\\n\\n        if (!subInfo.subscribed) return (false, CdpHolder(0, 0, 0, 0, address(0), 0, false, false));\\n\\n        CdpHolder memory subscriber = subscribers[subInfo.arrPos];\\n\\n        return (true, subscriber);\\n    }\\n\\n    /// @notice Helper method for the front to get the information about the ilk of a CDP\\n    function getIlkInfo(bytes32 _ilk, uint _cdpId) public view returns(bytes32 ilk, uint art, uint rate, uint spot, uint line, uint dust, uint mat, uint par) {\\n        // send either ilk or cdpId\\n        if (_ilk == bytes32(0)) {\\n            _ilk = manager.ilks(_cdpId);\\n        }\\n\\n        ilk = _ilk;\\n        (,mat) = spotter.ilks(_ilk);\\n        par = spotter.par();\\n        (art, rate, spot, line, dust) = vat.ilks(_ilk);\\n    }\\n\\n    /// @notice Helper method to return all the subscribed CDPs\\n    function getSubscribers() public view returns (CdpHolder[] memory) {\\n        return subscribers;\\n    }\\n\\n    /// @notice Helper method to return all the subscribed CDPs\\n    function getSubscribersByPage(uint _page, uint _perPage) public view returns (CdpHolder[] memory) {\\n        CdpHolder[] memory holders = new CdpHolder[](_perPage);\\n\\n        uint start = _page * _perPage;\\n        uint end = start + _perPage;\\n\\n        uint count = 0;\\n        for (uint i=start; i<end; i++) {\\n            holders[count] = subscribers[i];\\n            count++;\\n        }\\n\\n        return holders;\\n    }\\n\\n    ////////////// ADMIN METHODS ///////////////////\\n\\n    /// @notice Admin function to change a min. limit for an asset\\n    function changeMinRatios(bytes32 _ilk, uint _newRatio) public onlyOwner {\\n        minLimits[_ilk] = _newRatio;\\n    }\\n\\n    /// @notice Admin function to unsubscribe a CDP\\n    function unsubscribeByAdmin(uint _cdpId) public onlyOwner {\\n        SubPosition storage subInfo = subscribersPos[_cdpId];\\n\\n        if (subInfo.subscribed) {\\n            _unsubscribe(_cdpId);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/automaticV2/StaticV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/// @title Implements enum Method\\nabstract contract StaticV2 {\\n\\n    enum Method { Boost, Repay }\\n\\n    struct CdpHolder {\\n        uint128 minRatio;\\n        uint128 maxRatio;\\n        uint128 optimalRatioBoost;\\n        uint128 optimalRatioRepay;\\n        address owner;\\n        uint cdpId;\\n        bool boostEnabled;\\n        bool nextPriceEnabled;\\n    }\\n\\n    struct SubPosition {\\n        uint arrPos;\\n        bool subscribed;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/automaticV2/MCDMonitorV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../interfaces/Manager.sol\\\";\\nimport \\\"../../interfaces/Vat.sol\\\";\\nimport \\\"../../interfaces/Spotter.sol\\\";\\n\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../utils/GasBurner.sol\\\";\\nimport \\\"../../utils/BotRegistry.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeData.sol\\\";\\n\\nimport \\\"./ISubscriptionsV2.sol\\\";\\nimport \\\"./StaticV2.sol\\\";\\nimport \\\"./MCDMonitorProxyV2.sol\\\";\\n\\n\\n/// @title Implements logic that allows bots to call Boost and Repay\\ncontract MCDMonitorV2 is DSMath, AdminAuth, GasBurner, StaticV2 {\\n\\n    uint public REPAY_GAS_TOKEN = 25;\\n    uint public BOOST_GAS_TOKEN = 25;\\n\\n    uint public MAX_GAS_PRICE = 800000000000; // 800 gwei\\n\\n    uint public REPAY_GAS_COST = 1000000;\\n    uint public BOOST_GAS_COST = 1000000;\\n\\n    bytes4 public REPAY_SELECTOR = 0xf360ce20;\\n    bytes4 public BOOST_SELECTOR = 0x8ec2ae25;\\n\\n    MCDMonitorProxyV2 public monitorProxyContract;\\n    ISubscriptionsV2 public subscriptionsContract;\\n    address public mcdSaverTakerAddress;\\n\\n    address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;\\n\\n    address public constant PROXY_PERMISSION_ADDR = 0x5a4f877CA808Cca3cB7c2A194F80Ab8588FAE26B;\\n\\n    Manager public manager = Manager(0x5ef30b9986345249bc32d8928B7ee64DE9435E39);\\n    Vat public vat = Vat(0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B);\\n    Spotter public spotter = Spotter(0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3);\\n\\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\\n\\n    modifier onlyApproved() {\\n        require(BotRegistry(BOT_REGISTRY_ADDRESS).botList(msg.sender), \\\"Not auth bot\\\");\\n        _;\\n    }\\n\\n    constructor(address _monitorProxy, address _subscriptions, address _mcdSaverTakerAddress) public {\\n        monitorProxyContract = MCDMonitorProxyV2(_monitorProxy);\\n        subscriptionsContract = ISubscriptionsV2(_subscriptions);\\n        mcdSaverTakerAddress = _mcdSaverTakerAddress;\\n    }\\n\\n    /// @notice Bots call this method to repay for user when conditions are met\\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\\n    function repayFor(\\n        DFSExchangeData.ExchangeData memory _exchangeData,\\n        uint _cdpId,\\n        uint _nextPrice,\\n        address _joinAddr\\n    ) public payable onlyApproved burnGas(REPAY_GAS_TOKEN) {\\n\\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Repay, _cdpId, _nextPrice);\\n        require(isAllowed);\\n\\n        uint gasCost = calcGasCost(REPAY_GAS_COST);\\n\\n        address owner = subscriptionsContract.getOwner(_cdpId);\\n\\n        monitorProxyContract.callExecute{value: msg.value}(\\n            owner,\\n            mcdSaverTakerAddress,\\n            abi.encodeWithSelector(REPAY_SELECTOR, _exchangeData, _cdpId, gasCost, _joinAddr, 0));\\n\\n\\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Repay, _cdpId, _nextPrice);\\n        require(isGoodRatio);\\n\\n        returnEth();\\n\\n        logger.Log(address(this), owner, \\\"AutomaticMCDRepay\\\", abi.encode(ratioBefore, ratioAfter));\\n    }\\n\\n    /// @notice Bots call this method to boost for user when conditions are met\\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\\n    function boostFor(\\n        DFSExchangeData.ExchangeData memory _exchangeData,\\n        uint _cdpId,\\n        uint _nextPrice,\\n        address _joinAddr\\n    ) public payable onlyApproved burnGas(BOOST_GAS_TOKEN)  {\\n\\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Boost, _cdpId, _nextPrice);\\n        require(isAllowed);\\n\\n        uint gasCost = calcGasCost(BOOST_GAS_COST);\\n\\n        address owner = subscriptionsContract.getOwner(_cdpId);\\n\\n        monitorProxyContract.callExecute{value: msg.value}(\\n            owner,\\n            mcdSaverTakerAddress,\\n            abi.encodeWithSelector(BOOST_SELECTOR, _exchangeData, _cdpId, gasCost, _joinAddr, 0));\\n\\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Boost, _cdpId, _nextPrice);\\n        require(isGoodRatio);\\n\\n        returnEth();\\n\\n        logger.Log(address(this), owner, \\\"AutomaticMCDBoost\\\", abi.encode(ratioBefore, ratioAfter));\\n    }\\n\\n/******************* INTERNAL METHODS ********************************/\\n    function returnEth() internal {\\n        // return if some eth left\\n        if (address(this).balance > 0) {\\n            msg.sender.transfer(address(this).balance);\\n        }\\n    }\\n\\n/******************* STATIC METHODS ********************************/\\n\\n    /// @notice Returns an address that owns the CDP\\n    /// @param _cdpId Id of the CDP\\n    function getOwner(uint _cdpId) public view returns(address) {\\n        return manager.owns(_cdpId);\\n    }\\n\\n    /// @notice Gets CDP info (collateral, debt)\\n    /// @param _cdpId Id of the CDP\\n    /// @param _ilk Ilk of the CDP\\n    function getCdpInfo(uint _cdpId, bytes32 _ilk) public view returns (uint, uint) {\\n        address urn = manager.urns(_cdpId);\\n\\n        (uint collateral, uint debt) = vat.urns(_ilk, urn);\\n        (,uint rate,,,) = vat.ilks(_ilk);\\n\\n        return (collateral, rmul(debt, rate));\\n    }\\n\\n    /// @notice Gets a price of the asset\\n    /// @param _ilk Ilk of the CDP\\n    function getPrice(bytes32 _ilk) public view returns (uint) {\\n        (, uint mat) = spotter.ilks(_ilk);\\n        (,,uint spot,,) = vat.ilks(_ilk);\\n\\n        return rmul(rmul(spot, spotter.par()), mat);\\n    }\\n\\n    /// @notice Gets CDP ratio\\n    /// @param _cdpId Id of the CDP\\n    /// @param _nextPrice Next price for user\\n    function getRatio(uint _cdpId, uint _nextPrice) public view returns (uint) {\\n        bytes32 ilk = manager.ilks(_cdpId);\\n        uint price = (_nextPrice == 0) ? getPrice(ilk) : _nextPrice;\\n\\n        (uint collateral, uint debt) = getCdpInfo(_cdpId, ilk);\\n\\n        if (debt == 0) return 0;\\n\\n        return rdiv(wmul(collateral, price), debt) / (10 ** 18);\\n    }\\n\\n    /// @notice Checks if Boost/Repay could be triggered for the CDP\\n    /// @dev Called by MCDMonitor to enforce the min/max check\\n    function canCall(Method _method, uint _cdpId, uint _nextPrice) public view returns(bool, uint) {\\n        bool subscribed;\\n        CdpHolder memory holder;\\n        (subscribed, holder) = subscriptionsContract.getCdpHolder(_cdpId);\\n\\n        // check if cdp is subscribed\\n        if (!subscribed) return (false, 0);\\n\\n        // check if using next price is allowed\\n        if (_nextPrice > 0 && !holder.nextPriceEnabled) return (false, 0);\\n\\n        // check if boost and boost allowed\\n        if (_method == Method.Boost && !holder.boostEnabled) return (false, 0);\\n\\n        // check if owner is still owner\\n        if (getOwner(_cdpId) != holder.owner) return (false, 0);\\n\\n        uint currRatio = getRatio(_cdpId, _nextPrice);\\n\\n        if (_method == Method.Repay) {\\n            return (currRatio < holder.minRatio, currRatio);\\n        } else if (_method == Method.Boost) {\\n            return (currRatio > holder.maxRatio, currRatio);\\n        }\\n    }\\n\\n    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call\\n    function ratioGoodAfter(Method _method, uint _cdpId, uint _nextPrice) public view returns(bool, uint) {\\n        CdpHolder memory holder;\\n\\n        (, holder) = subscriptionsContract.getCdpHolder(_cdpId);\\n\\n        uint currRatio = getRatio(_cdpId, _nextPrice);\\n\\n        if (_method == Method.Repay) {\\n            return (currRatio < holder.maxRatio, currRatio);\\n        } else if (_method == Method.Boost) {\\n            return (currRatio > holder.minRatio, currRatio);\\n        }\\n    }\\n\\n    /// @notice Calculates gas cost (in Eth) of tx\\n    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP\\n    /// @param _gasAmount Amount of gas used for the tx\\n    function calcGasCost(uint _gasAmount) public view returns (uint) {\\n        uint gasPrice = tx.gasprice <= MAX_GAS_PRICE ? tx.gasprice : MAX_GAS_PRICE;\\n\\n        return mul(gasPrice, _gasAmount);\\n    }\\n\\n/******************* OWNER ONLY OPERATIONS ********************************/\\n\\n    /// @notice Allows owner to change gas cost for boost operation, but only up to 3 millions\\n    /// @param _gasCost New gas cost for boost method\\n    function changeBoostGasCost(uint _gasCost) public onlyOwner {\\n        require(_gasCost < 3000000);\\n\\n        BOOST_GAS_COST = _gasCost;\\n    }\\n\\n    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions\\n    /// @param _gasCost New gas cost for repay method\\n    function changeRepayGasCost(uint _gasCost) public onlyOwner {\\n        require(_gasCost < 3000000);\\n\\n        REPAY_GAS_COST = _gasCost;\\n    }\\n\\n    /// @notice Allows owner to change max gas price\\n    /// @param _maxGasPrice New max gas price\\n    function changeMaxGasPrice(uint _maxGasPrice) public onlyOwner {\\n        require(_maxGasPrice < 1000000000000);\\n\\n        MAX_GAS_PRICE = _maxGasPrice;\\n    }\\n\\n    /// @notice Allows owner to change the amount of gas token burned per function call\\n    /// @param _gasAmount Amount of gas token\\n    /// @param _isRepay Flag to know for which function we are setting the gas token amount\\n    function changeGasTokenAmount(uint _gasAmount, bool _isRepay) public onlyOwner {\\n        if (_isRepay) {\\n            REPAY_GAS_TOKEN = _gasAmount;\\n        } else {\\n            BOOST_GAS_TOKEN = _gasAmount;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/automaticV2/ISubscriptionsV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./StaticV2.sol\\\";\\n\\nabstract contract ISubscriptionsV2 is StaticV2 {\\n\\n    function getOwner(uint _cdpId) external view virtual returns(address);\\n    function getSubscribedInfo(uint _cdpId) public view virtual returns(bool, uint128, uint128, uint128, uint128, address, uint coll, uint debt);\\n    function getCdpHolder(uint _cdpId) public view virtual returns (bool subscribed, CdpHolder memory);\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/automaticV2/MCDMonitorProxyV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../interfaces/DSProxyInterface.sol\\\";\\nimport \\\"../../interfaces/ERC20.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\n/// @title Implements logic for calling MCDSaverProxy always from same contract\\ncontract MCDMonitorProxyV2 is AdminAuth {\\n\\n    uint public CHANGE_PERIOD;\\n    uint public MIN_CHANGE_PERIOD = 6 * 1 hours;\\n    address public monitor;\\n    address public newMonitor;\\n    address public lastMonitor;\\n    uint public changeRequestedTimestamp;\\n\\n    event MonitorChangeInitiated(address oldMonitor, address newMonitor);\\n    event MonitorChangeCanceled();\\n    event MonitorChangeFinished(address monitor);\\n    event MonitorChangeReverted(address monitor);\\n\\n    modifier onlyMonitor() {\\n        require (msg.sender == monitor);\\n        _;\\n    }\\n\\n    constructor(uint _changePeriod) public {\\n        CHANGE_PERIOD = _changePeriod * 1 hours;\\n    }\\n\\n    /// @notice Only monitor contract is able to call execute on users proxy\\n    /// @param _owner Address of cdp owner (users DSProxy address)\\n    /// @param _saverProxy Address of MCDSaverProxy\\n    /// @param _data Data to send to MCDSaverProxy\\n    function callExecute(address _owner, address _saverProxy, bytes memory _data) public payable onlyMonitor {\\n        // execute reverts if calling specific method fails\\n        DSProxyInterface(_owner).execute{value: msg.value}(_saverProxy, _data);\\n\\n        // return if anything left\\n        if (address(this).balance > 0) {\\n            msg.sender.transfer(address(this).balance);\\n        }\\n    }\\n\\n    /// @notice Allowed users are able to set Monitor contract without any waiting period first time\\n    /// @param _monitor Address of Monitor contract\\n    function setMonitor(address _monitor) public onlyOwner {\\n        require(monitor == address(0));\\n        monitor = _monitor;\\n    }\\n\\n    /// @notice Allowed users are able to start procedure for changing monitor\\n    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change\\n    /// @param _newMonitor address of new monitor\\n    function changeMonitor(address _newMonitor) public onlyOwner {\\n        require(changeRequestedTimestamp == 0);\\n\\n        changeRequestedTimestamp = now;\\n        lastMonitor = monitor;\\n        newMonitor = _newMonitor;\\n\\n        emit MonitorChangeInitiated(lastMonitor, newMonitor);\\n    }\\n\\n    /// @notice At any point allowed users are able to cancel monitor change\\n    function cancelMonitorChange() public onlyOwner {\\n        require(changeRequestedTimestamp > 0);\\n\\n        changeRequestedTimestamp = 0;\\n        newMonitor = address(0);\\n\\n        emit MonitorChangeCanceled();\\n    }\\n\\n    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started\\n    function confirmNewMonitor() public onlyOwner {\\n        require((changeRequestedTimestamp + CHANGE_PERIOD) < now);\\n        require(changeRequestedTimestamp != 0);\\n        require(newMonitor != address(0));\\n\\n        monitor = newMonitor;\\n        newMonitor = address(0);\\n        changeRequestedTimestamp = 0;\\n\\n        emit MonitorChangeFinished(monitor);\\n    }\\n\\n    /// @notice Its possible to revert monitor to last used monitor\\n    function revertMonitor() public onlyOwner {\\n        require(lastMonitor != address(0));\\n\\n        monitor = lastMonitor;\\n\\n        emit MonitorChangeReverted(monitor);\\n    }\\n\\n    function setChangePeriod(uint _periodInHours) public onlyOwner {\\n        require(_periodInHours * 1 hours > MIN_CHANGE_PERIOD);\\n\\n        CHANGE_PERIOD = _periodInHours * 1 hours;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/compound/helpers/CompoundSaverHelper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../interfaces/CEtherInterface.sol\\\";\\nimport \\\"../../interfaces/CompoundOracleInterface.sol\\\";\\nimport \\\"../../interfaces/CTokenInterface.sol\\\";\\nimport \\\"../../interfaces/ComptrollerInterface.sol\\\";\\nimport \\\"../../interfaces/IFeeRecipient.sol\\\";\\n\\nimport \\\"../../utils/Discount.sol\\\";\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../DS/DSProxy.sol\\\";\\nimport \\\"./Exponential.sol\\\";\\nimport \\\"../../utils/BotRegistry.sol\\\";\\n\\nimport \\\"../../utils/SafeERC20.sol\\\";\\n\\n/// @title Utlity functions for Compound contracts\\ncontract CompoundSaverHelper is DSMath, Exponential {\\n\\n    using SafeERC20 for ERC20;\\n\\n    IFeeRecipient public constant feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);\\n\\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\\n\\n    uint public constant MANUAL_SERVICE_FEE = 400; // 0.25% Fee\\n    uint public constant AUTOMATIC_SERVICE_FEE = 333; // 0.3% Fee\\n\\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant CETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\\n    address public constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\\n\\n    address public constant COMPOUND_LOGGER = 0x3DD0CDf5fFA28C6847B4B276e2fD256046a44bb7;\\n\\n    address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;\\n\\n    /// @notice Helper method to payback the Compound debt\\n    /// @dev If amount is bigger it will repay the whole debt and send the extra to the _user\\n    /// @param _amount Amount of tokens we want to repay\\n    /// @param _cBorrowToken Ctoken address we are repaying\\n    /// @param _borrowToken Token address we are repaying\\n    /// @param _user Owner of the compound position we are paying back\\n    function paybackDebt(uint _amount, address _cBorrowToken, address _borrowToken, address payable _user) internal {\\n        uint wholeDebt = CTokenInterface(_cBorrowToken).borrowBalanceCurrent(address(this));\\n\\n        if (_amount > wholeDebt) {\\n            if (_borrowToken == ETH_ADDRESS) {\\n                _user.transfer((_amount - wholeDebt));\\n            } else {\\n                ERC20(_borrowToken).safeTransfer(_user, (_amount - wholeDebt));\\n            }\\n\\n            _amount = wholeDebt;\\n        }\\n\\n        approveCToken(_borrowToken, _cBorrowToken);\\n\\n        if (_borrowToken == ETH_ADDRESS) {\\n            CEtherInterface(_cBorrowToken).repayBorrow{value: _amount}();\\n        } else {\\n            require(CTokenInterface(_cBorrowToken).repayBorrow(_amount) == 0);\\n        }\\n    }\\n\\n    /// @notice Calculates the fee amount\\n    /// @param _amount Amount that is converted\\n    /// @param _user Actuall user addr not DSProxy\\n    /// @param _gasCost Ether amount of gas we are spending for tx\\n    /// @param _cTokenAddr CToken addr. of token we are getting for the fee\\n    /// @return feeAmount The amount we took for the fee\\n    function getFee(uint _amount, address _user, uint _gasCost, address _cTokenAddr) internal returns (uint feeAmount) {\\n        uint fee = MANUAL_SERVICE_FEE;\\n\\n        if (BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin)) {\\n            fee = AUTOMATIC_SERVICE_FEE;\\n        }\\n\\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\\n\\n        if (Discount(DISCOUNT_ADDR).isCustomFeeSet(_user)) {\\n            fee = Discount(DISCOUNT_ADDR).getCustomServiceFee(_user);\\n        }\\n\\n        feeAmount = (fee == 0) ? 0 : (_amount / fee);\\n\\n        if (_gasCost != 0) {\\n            address oracle = ComptrollerInterface(COMPTROLLER).oracle();\\n\\n            uint usdTokenPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cTokenAddr);\\n            uint ethPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(CETH_ADDRESS);\\n\\n            uint tokenPriceInEth = wdiv(usdTokenPrice, ethPrice);\\n\\n            _gasCost = wdiv(_gasCost, tokenPriceInEth);\\n\\n            feeAmount = add(feeAmount, _gasCost);\\n        }\\n\\n        // fee can't go over 20% of the whole amount\\n        if (feeAmount > (_amount / 5)) {\\n            feeAmount = _amount / 5;\\n        }\\n\\n        address walletAddr = feeRecipient.getFeeAddr();\\n\\n        if (tokenAddr == ETH_ADDRESS) {\\n            payable(walletAddr).transfer(feeAmount);\\n        } else {\\n            ERC20(tokenAddr).safeTransfer(walletAddr, feeAmount);\\n        }\\n    }\\n\\n    /// @notice Calculates the gas cost of transaction and send it to wallet\\n    /// @param _amount Amount that is converted\\n    /// @param _gasCost Ether amount of gas we are spending for tx\\n    /// @param _cTokenAddr CToken addr. of token we are getting for the fee\\n    /// @return feeAmount The amount we took for the fee\\n    function getGasCost(uint _amount, uint _gasCost, address _cTokenAddr) internal returns (uint feeAmount) {\\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\\n\\n        if (_gasCost != 0) {\\n            address oracle = ComptrollerInterface(COMPTROLLER).oracle();\\n\\n            uint usdTokenPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cTokenAddr);\\n            uint ethPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(CETH_ADDRESS);\\n\\n            uint tokenPriceInEth = wdiv(usdTokenPrice, ethPrice);\\n\\n            feeAmount = wdiv(_gasCost, tokenPriceInEth);\\n        }\\n\\n        // fee can't go over 20% of the whole amount\\n        if (feeAmount > (_amount / 5)) {\\n            feeAmount = _amount / 5;\\n        }\\n\\n        address walletAddr = feeRecipient.getFeeAddr();\\n\\n        if (tokenAddr == ETH_ADDRESS) {\\n            payable(walletAddr).transfer(feeAmount);\\n        } else {\\n            ERC20(tokenAddr).safeTransfer(walletAddr, feeAmount);\\n        }\\n    }\\n\\n    /// @notice Enters the market for the collatera and borrow tokens\\n    /// @param _cTokenAddrColl Collateral address we are entering the market in\\n    /// @param _cTokenAddrBorrow Borrow address we are entering the market in\\n    function enterMarket(address _cTokenAddrColl, address _cTokenAddrBorrow) internal {\\n        address[] memory markets = new address[](2);\\n        markets[0] = _cTokenAddrColl;\\n        markets[1] = _cTokenAddrBorrow;\\n\\n        ComptrollerInterface(COMPTROLLER).enterMarkets(markets);\\n    }\\n\\n    /// @notice Approves CToken contract to pull underlying tokens from the DSProxy\\n    /// @param _tokenAddr Token we are trying to approve\\n    /// @param _cTokenAddr Address which will gain the approval\\n    function approveCToken(address _tokenAddr, address _cTokenAddr) internal {\\n        if (_tokenAddr != ETH_ADDRESS) {\\n            ERC20(_tokenAddr).safeApprove(_cTokenAddr, uint(-1));\\n        }\\n    }\\n\\n    /// @notice Returns the underlying address of the cToken asset\\n    /// @param _cTokenAddress cToken address\\n    /// @return Token address of the cToken specified\\n    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\\n        if (_cTokenAddress == CETH_ADDRESS) {\\n            return ETH_ADDRESS;\\n        } else {\\n            return CTokenInterface(_cTokenAddress).underlying();\\n        }\\n    }\\n\\n    /// @notice Returns the owner of the DSProxy that called the contract\\n    function getUserAddress() internal view returns (address) {\\n        DSProxy proxy = DSProxy(uint160(address(this)));\\n\\n        return proxy.owner();\\n    }\\n\\n    /// @notice Returns the maximum amount of collateral available to withdraw\\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\\n    /// @param _cCollAddress Collateral we are getting the max value of\\n    /// @param _account Users account\\n    /// @return Returns the max. collateral amount in that token\\n    function getMaxCollateral(address _cCollAddress, address _account) public returns (uint) {\\n        (, uint liquidityInUsd, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\\n        uint usersBalance = CTokenInterface(_cCollAddress).balanceOfUnderlying(_account);\\n        address oracle = ComptrollerInterface(COMPTROLLER).oracle();\\n\\n        if (liquidityInUsd == 0) return usersBalance;\\n\\n        CTokenInterface(_cCollAddress).accrueInterest();\\n\\n        (, uint collFactorMantissa) = ComptrollerInterface(COMPTROLLER).markets(_cCollAddress);\\n        Exp memory collateralFactor = Exp({mantissa: collFactorMantissa});\\n\\n        (, uint tokensToUsd) = divScalarByExpTruncate(liquidityInUsd, collateralFactor);\\n\\n        uint usdPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cCollAddress);\\n        uint liqInToken = wdiv(tokensToUsd, usdPrice);\\n\\n        if (liqInToken > usersBalance) return usersBalance;\\n\\n        return sub(liqInToken, (liqInToken / 100)); // cut off 1% due to rounding issues\\n    }\\n\\n    /// @notice Returns the maximum amount of borrow amount available\\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\\n    /// @param _cBorrowAddress Borrow token we are getting the max value of\\n    /// @param _account Users account\\n    /// @return Returns the max. borrow amount in that token\\n    function getMaxBorrow(address _cBorrowAddress, address _account) public returns (uint) {\\n        (, uint liquidityInUsd, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\\n        address oracle = ComptrollerInterface(COMPTROLLER).oracle();\\n\\n        CTokenInterface(_cBorrowAddress).accrueInterest();\\n\\n        uint usdPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cBorrowAddress);\\n        uint liquidityInToken = wdiv(liquidityInUsd, usdPrice);\\n\\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\\n    }\\n\\n    function isAutomation() internal view returns(bool) {\\n        return BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/shifter/protocols/CompShifter.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../compound/helpers/CompoundSaverHelper.sol\\\";\\n\\ncontract CompShifter is CompoundSaverHelper {\\n\\n    using SafeERC20 for ERC20;\\n\\n    address public constant COMPTROLLER_ADDR = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\\n\\n    function getLoanAmount(uint _cdpId, address _joinAddr) public returns(uint loanAmount) {\\n        return getWholeDebt(_cdpId, _joinAddr);\\n    }\\n\\n    function getWholeDebt(uint _cdpId, address _joinAddr) public returns(uint loanAmount) {\\n        return CTokenInterface(_joinAddr).borrowBalanceCurrent(msg.sender);\\n    }\\n\\n    function close(\\n        address _cCollAddr,\\n        address _cBorrowAddr,\\n        uint _collAmount,\\n        uint _debtAmount\\n    ) public {\\n        address collAddr = getUnderlyingAddr(_cCollAddr);\\n\\n        // payback debt\\n        paybackDebt(_debtAmount, _cBorrowAddr, getUnderlyingAddr(_cBorrowAddr), tx.origin);\\n\\n        require(CTokenInterface(_cCollAddr).redeemUnderlying(_collAmount) == 0);\\n\\n        // Send back money to repay FL\\n        if (collAddr == ETH_ADDRESS) {\\n            msg.sender.transfer(address(this).balance);\\n        } else {\\n            ERC20(collAddr).safeTransfer(msg.sender, ERC20(collAddr).balanceOf(address(this)));\\n        }\\n    }\\n\\n    function changeDebt(\\n        address _cBorrowAddrOld,\\n        address _cBorrowAddrNew,\\n        uint _debtAmountOld,\\n        uint _debtAmountNew\\n    ) public {\\n\\n        address borrowAddrNew = getUnderlyingAddr(_cBorrowAddrNew);\\n\\n        // payback debt in one token\\n        paybackDebt(_debtAmountOld, _cBorrowAddrOld, getUnderlyingAddr(_cBorrowAddrOld), tx.origin);\\n\\n        // draw debt in another one\\n        borrowCompound(_cBorrowAddrNew, _debtAmountNew);\\n\\n        // Send back money to repay FL\\n        if (borrowAddrNew == ETH_ADDRESS) {\\n            msg.sender.transfer(address(this).balance);\\n        } else {\\n            ERC20(borrowAddrNew).safeTransfer(msg.sender, ERC20(borrowAddrNew).balanceOf(address(this)));\\n        }\\n    }\\n\\n    function open(\\n        address _cCollAddr,\\n        address _cBorrowAddr,\\n        uint _debtAmount\\n    ) public {\\n\\n        address collAddr = getUnderlyingAddr(_cCollAddr);\\n        address borrowAddr = getUnderlyingAddr(_cBorrowAddr);\\n\\n        uint collAmount = 0;\\n\\n        if (collAddr == ETH_ADDRESS) {\\n            collAmount = address(this).balance;\\n        } else {\\n            collAmount = ERC20(collAddr).balanceOf(address(this));\\n        }\\n\\n        depositCompound(collAddr, _cCollAddr, collAmount);\\n\\n        // draw debt\\n        borrowCompound(_cBorrowAddr, _debtAmount);\\n\\n        // Send back money to repay FL\\n        if (borrowAddr == ETH_ADDRESS) {\\n            msg.sender.transfer(address(this).balance);\\n        } else {\\n            ERC20(borrowAddr).safeTransfer(msg.sender, ERC20(borrowAddr).balanceOf(address(this)));\\n        }\\n\\n    }\\n\\n    function repayAll(address _cTokenAddr) public {\\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\\n        uint amount = ERC20(tokenAddr).balanceOf(address(this));\\n\\n        if (amount != 0) {\\n            paybackDebt(amount, _cTokenAddr, tokenAddr, tx.origin);\\n        }\\n    }\\n\\n    function depositCompound(address _tokenAddr, address _cTokenAddr, uint _amount) internal {\\n        approveCToken(_tokenAddr, _cTokenAddr);\\n\\n        enterMarket(_cTokenAddr);\\n\\n        if (_tokenAddr != ETH_ADDRESS) {\\n            require(CTokenInterface(_cTokenAddr).mint(_amount) == 0, \\\"mint error\\\");\\n        } else {\\n            CEtherInterface(_cTokenAddr).mint{value: _amount}();\\n        }\\n    }\\n\\n    function borrowCompound(address _cTokenAddr, uint _amount) internal {\\n        enterMarket(_cTokenAddr);\\n\\n        require(CTokenInterface(_cTokenAddr).borrow(_amount) == 0);\\n    }\\n\\n    function enterMarket(address _cTokenAddr) public {\\n        address[] memory markets = new address[](1);\\n        markets[0] = _cTokenAddr;\\n\\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/compound/saver/CompoundSaverFlashProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeCore.sol\\\";\\nimport \\\"../../interfaces/CTokenInterface.sol\\\";\\nimport \\\"../../utils/Discount.sol\\\";\\nimport \\\"../helpers/CompoundSaverHelper.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\n\\n/// @title Implements the actual logic of Repay/Boost with FL\\ncontract CompoundSaverFlashProxy is DFSExchangeCore, CompoundSaverHelper  {\\n\\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\\n\\n    using SafeERC20 for ERC20;\\n\\n    /// @notice Repays the position and sends tokens back for FL\\n    /// @param _exData Exchange data\\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]\\n    /// @param _gasCost Gas cost for transaction\\n    /// @param _flashLoanData Data about FL [amount, fee]\\n    function flashRepay(\\n        ExchangeData memory _exData,\\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\\n        uint256 _gasCost,\\n        uint[2] memory _flashLoanData // amount, fee\\n    ) public payable {\\n        enterMarket(_cAddresses[0], _cAddresses[1]);\\n\\n        address payable user = payable(getUserAddress());\\n        uint flashBorrowed = _flashLoanData[0] + _flashLoanData[1];\\n\\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\\n\\n        // draw max coll\\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(maxColl) == 0);\\n\\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\\n\\n        uint swapAmount = 0;\\n\\n        if (collToken != borrowToken) {\\n            // swap max coll + loanAmount\\n            _exData.srcAmount = maxColl + _flashLoanData[0];\\n            _exData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\\n            _exData.user = user;\\n\\n            (,swapAmount) = _sell(_exData);\\n\\n            // get fee\\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\\n        } else {\\n            swapAmount = (maxColl + _flashLoanData[0]);\\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\\n        }\\n\\n        // payback debt\\n        paybackDebt(swapAmount, _cAddresses[1], borrowToken, user);\\n\\n        // draw collateral for loanAmount + loanFee\\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(flashBorrowed) == 0);\\n\\n        // repay flash loan\\n        returnFlashLoan(collToken, flashBorrowed);\\n\\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \\\"CompoundRepay\\\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\\n    }\\n\\n    /// @notice Boosts the position and sends tokens back for FL\\n    /// @param _exData Exchange data\\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]\\n    /// @param _gasCost Gas cost for specific transaction\\n    /// @param _flashLoanData Data about FL [amount, fee]\\n    function flashBoost(\\n        ExchangeData memory _exData,\\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\\n        uint256 _gasCost,\\n        uint[2] memory _flashLoanData // amount, fee\\n    ) public payable {\\n        enterMarket(_cAddresses[0], _cAddresses[1]);\\n\\n        address payable user = payable(getUserAddress());\\n        uint flashBorrowed = _flashLoanData[0] + _flashLoanData[1];\\n\\n        // borrow max amount\\n        uint borrowAmount = getMaxBorrow(_cAddresses[1], address(this));\\n        require(CTokenInterface(_cAddresses[1]).borrow(borrowAmount) == 0);\\n\\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\\n\\n        uint swapAmount = 0;\\n\\n        if (collToken != borrowToken) {\\n            // get dfs fee\\n            _exData.srcAmount = (borrowAmount + _flashLoanData[0]);\\n            _exData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\\n            _exData.user = user;\\n\\n            (, swapAmount) = _sell(_exData);\\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[0]);\\n        } else {\\n            swapAmount = (borrowAmount + _flashLoanData[0]);\\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[0]);\\n        }\\n\\n        // deposit swaped collateral\\n        depositCollateral(collToken, _cAddresses[0], swapAmount);\\n\\n        // borrow token to repay flash loan\\n        require(CTokenInterface(_cAddresses[1]).borrow(flashBorrowed) == 0);\\n\\n        // repay flash loan\\n        returnFlashLoan(borrowToken, flashBorrowed);\\n\\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \\\"CompoundBoost\\\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\\n    }\\n\\n    /// @notice Helper method to deposit tokens in Compound\\n    /// @param _collToken Token address of the collateral\\n    /// @param _cCollToken CToken address of the collateral\\n    /// @param _depositAmount Amount to deposit\\n    function depositCollateral(address _collToken, address _cCollToken, uint _depositAmount) internal {\\n        approveCToken(_collToken, _cCollToken);\\n\\n        if (_collToken != ETH_ADDRESS) {\\n            require(CTokenInterface(_cCollToken).mint(_depositAmount) == 0);\\n        } else {\\n            CEtherInterface(_cCollToken).mint{value: _depositAmount}(); // reverts on fail\\n        }\\n    }\\n\\n    /// @notice Returns the tokens/ether to the msg.sender which is the FL contract\\n    /// @param _tokenAddr Address of token which we return\\n    /// @param _amount Amount to return\\n    function returnFlashLoan(address _tokenAddr, uint _amount) internal {\\n        if (_tokenAddr != ETH_ADDRESS) {\\n            ERC20(_tokenAddr).safeTransfer(msg.sender, _amount);\\n        }\\n\\n        msg.sender.transfer(address(this).balance);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/cream/import/CreamImportTaker.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../utils/GasBurner.sol\\\";\\nimport \\\"../../auth/ProxyPermission.sol\\\";\\n\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../interfaces/ILendingPool.sol\\\";\\nimport \\\"../../interfaces/CTokenInterface.sol\\\";\\nimport \\\"../../interfaces/ProxyRegistryInterface.sol\\\";\\n\\nimport \\\"../helpers/CreamSaverHelper.sol\\\";\\n\\n/// @title Imports cream position from the account to DSProxy\\ncontract CreamImportTaker is CreamSaverHelper, ProxyPermission, GasBurner {\\n\\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\\n\\n    address payable public constant CREAM_IMPORT_FLASH_LOAN = 0x24F4aC0Fe758c45cf8425D8Fbdd608cca9A7dBf8;\\n    address public constant PROXY_REGISTRY_ADDRESS = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\\n\\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\\n\\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\\n    /// @dev User must approve cream_IMPORT_FLASH_LOAN to pull _cCollateralToken\\n    /// @param _cCollateralToken Collateral we are moving to DSProxy\\n    /// @param _cBorrowToken Borrow token we are moving to DSProxy\\n    function importLoan(address _cCollateralToken, address _cBorrowToken) external burnGas(20) {\\n        address proxy = getProxy();\\n\\n        uint loanAmount = CTokenInterface(_cBorrowToken).borrowBalanceCurrent(msg.sender);\\n        bytes memory paramsData = abi.encode(_cCollateralToken, _cBorrowToken, msg.sender, proxy);\\n\\n        givePermission(CREAM_IMPORT_FLASH_LOAN);\\n\\n        lendingPool.flashLoan(CREAM_IMPORT_FLASH_LOAN, getUnderlyingAddr(_cBorrowToken), loanAmount, paramsData);\\n\\n        removePermission(CREAM_IMPORT_FLASH_LOAN);\\n\\n        logger.Log(address(this), msg.sender, \\\"CreamImport\\\", abi.encode(loanAmount, 0, _cCollateralToken));\\n    }\\n\\n    /// @notice Gets proxy address, if user doesn't has DSProxy build it\\n    /// @return proxy DsProxy address\\n    function getProxy() internal returns (address proxy) {\\n        proxy = ProxyRegistryInterface(PROXY_REGISTRY_ADDRESS).proxies(msg.sender);\\n\\n        if (proxy == address(0)) {\\n            proxy = ProxyRegistryInterface(PROXY_REGISTRY_ADDRESS).build(msg.sender);\\n        }\\n\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cream/import/CreamImportFlashLoan.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../utils/FlashLoanReceiverBase.sol\\\";\\nimport \\\"../../interfaces/ProxyRegistryInterface.sol\\\";\\nimport \\\"../../interfaces/CTokenInterface.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\n\\n/// @title Receives FL from Aave and imports the position to DSProxy\\ncontract CreamImportFlashLoan is FlashLoanReceiverBase {\\n\\n    using SafeERC20 for ERC20;\\n\\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\\n\\n    address public constant CREAM_BORROW_PROXY = 0x87F198Ef6116CdBC5f36B581d212ad950b7e2Ddd;\\n\\n    address public owner;\\n\\n    constructor()\\n        FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER)\\n        public {\\n            owner = msg.sender;\\n    }\\n\\n    /// @notice Called by Aave when sending back the FL amount\\n    /// @param _reserve The address of the borrowed token\\n    /// @param _amount Amount of FL tokens received\\n    /// @param _fee FL Aave fee\\n    /// @param _params The params that are sent from the original FL caller contract\\n    function executeOperation(\\n        address _reserve,\\n        uint256 _amount,\\n        uint256 _fee,\\n        bytes calldata _params)\\n    external override {\\n\\n        (\\n            address cCollateralToken,\\n            address cBorrowToken,\\n            address user,\\n            address proxy\\n        )\\n        = abi.decode(_params, (address,address,address,address));\\n\\n        // approve FL tokens so we can repay them\\n        ERC20(_reserve).safeApprove(cBorrowToken, uint(-1));\\n\\n        // repay cream debt\\n        require(CTokenInterface(cBorrowToken).repayBorrowBehalf(user, uint(-1)) == 0, \\\"Repay borrow behalf fail\\\");\\n\\n        // transfer cTokens to proxy\\n        uint cTokenBalance = CTokenInterface(cCollateralToken).balanceOf(user);\\n        require(CTokenInterface(cCollateralToken).transferFrom(user, proxy, cTokenBalance));\\n\\n        // borrow\\n        bytes memory proxyData = getProxyData(cCollateralToken, cBorrowToken, _reserve, (_amount + _fee));\\n        DSProxyInterface(proxy).execute(CREAM_BORROW_PROXY, proxyData);\\n\\n        // Repay the loan with the money DSProxy sent back\\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\\n    }\\n\\n    /// @notice Formats function data call so we can call it through DSProxy\\n    /// @param _cCollToken CToken address of collateral\\n    /// @param _cBorrowToken CToken address we will borrow\\n    /// @param _borrowToken Token address we will borrow\\n    /// @param _amount Amount that will be borrowed\\n    /// @return proxyData Formated function call data\\n    function getProxyData(address _cCollToken, address _cBorrowToken, address _borrowToken, uint _amount) internal pure returns (bytes memory proxyData) {\\n        proxyData = abi.encodeWithSignature(\\n            \\\"borrow(address,address,address,uint256)\\\",\\n            _cCollToken, _cBorrowToken, _borrowToken, _amount);\\n    }\\n\\n    function withdrawStuckFunds(address _tokenAddr, uint _amount) public {\\n        require(owner == msg.sender, \\\"Must be owner\\\");\\n\\n        if (_tokenAddr == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\\n            msg.sender.transfer(_amount);\\n        } else {\\n            ERC20(_tokenAddr).safeTransfer(owner, _amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/saver/MCDSaverFlashLoan.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../mcd/saver/MCDSaverProxy.sol\\\";\\nimport \\\"../../utils/FlashLoanReceiverBase.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeCore.sol\\\";\\n\\n/// @title Receiver of Dydx flash loan and performs the fl repay/boost logic\\n/// @notice Must have a dust amount of WETH on the contract for 2 wei dydx fee\\ncontract MCDSaverFlashLoan is MCDSaverProxy, AdminAuth, FlashLoanReceiverBase {\\n\\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\\n\\n    constructor() FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER) public {}\\n\\n    struct SaverData {\\n        uint cdpId;\\n        uint gasCost;\\n        uint loanAmount;\\n        uint fee;\\n        address joinAddr;\\n        ManagerType managerType;\\n    }\\n\\n    function executeOperation(\\n        address _reserve,\\n        uint256 _amount,\\n        uint256 _fee,\\n        bytes calldata _params)\\n    external override {\\n\\n        //check the contract has the specified balance\\n        require(_amount <= getBalanceInternal(address(this), _reserve),\\n            \\\"Invalid balance for the contract\\\");\\n\\n        (\\n            bytes memory exDataBytes,\\n            uint cdpId,\\n            uint gasCost,\\n            address joinAddr,\\n            bool isRepay,\\n            uint8 managerType\\n        )\\n         = abi.decode(_params, (bytes,uint256,uint256,address,bool,uint8));\\n\\n        ExchangeData memory exchangeData = unpackExchangeData(exDataBytes);\\n\\n        SaverData memory saverData = SaverData({\\n            cdpId: cdpId,\\n            gasCost: gasCost,\\n            loanAmount: _amount,\\n            fee: _fee,\\n            joinAddr: joinAddr,\\n            managerType: ManagerType(managerType)\\n        });\\n\\n        if (isRepay) {\\n            repayWithLoan(exchangeData, saverData);\\n        } else {\\n            boostWithLoan(exchangeData, saverData);\\n        }\\n\\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\\n\\n        // if there is some eth left (0x fee), return it to user\\n        if (address(this).balance > 0) {\\n            tx.origin.transfer(address(this).balance);\\n        }\\n    }\\n\\n    function boostWithLoan(\\n        ExchangeData memory _exchangeData,\\n        SaverData memory _saverData\\n    ) internal {\\n\\n        address managerAddr = getManagerAddr(_saverData.managerType);\\n\\n        address user = getOwner(Manager(managerAddr), _saverData.cdpId);\\n\\n        // Draw users Dai\\n        uint maxDebt = getMaxDebt(managerAddr, _saverData.cdpId, Manager(managerAddr).ilks(_saverData.cdpId));\\n        uint daiDrawn = drawDai(managerAddr, _saverData.cdpId, Manager(managerAddr).ilks(_saverData.cdpId), maxDebt);\\n\\n        // Swap\\n        _exchangeData.srcAmount = daiDrawn + _saverData.loanAmount - takeFee(_saverData.gasCost, daiDrawn + _saverData.loanAmount);\\n        _exchangeData.user = user;\\n        _exchangeData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\\n        (, uint swapedAmount) = _sell(_exchangeData);\\n\\n        // Return collateral\\n        addCollateral(managerAddr, _saverData.cdpId, _saverData.joinAddr, swapedAmount);\\n\\n        // Draw Dai to repay the flash loan\\n        drawDai(managerAddr, _saverData.cdpId,  Manager(managerAddr).ilks(_saverData.cdpId), (_saverData.loanAmount + _saverData.fee));\\n\\n        logger.Log(address(this), msg.sender, \\\"MCDFlashBoost\\\", abi.encode(_saverData.cdpId, user, _exchangeData.srcAmount, swapedAmount));\\n    }\\n\\n    function repayWithLoan(\\n        ExchangeData memory _exchangeData,\\n        SaverData memory _saverData\\n    ) internal {\\n\\n        address managerAddr = getManagerAddr(_saverData.managerType);\\n\\n        address user = getOwner(Manager(managerAddr), _saverData.cdpId);\\n        bytes32 ilk = Manager(managerAddr).ilks(_saverData.cdpId);\\n\\n        // Draw collateral\\n        uint maxColl = getMaxCollateral(managerAddr, _saverData.cdpId, ilk, _saverData.joinAddr);\\n        uint collDrawn = drawCollateral(managerAddr, _saverData.cdpId, _saverData.joinAddr, maxColl);\\n\\n        // Swap\\n        _exchangeData.srcAmount = (_saverData.loanAmount + collDrawn);\\n        _exchangeData.user = user;\\n        _exchangeData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\\n        (, uint paybackAmount) = _sell(_exchangeData);\\n\\n        paybackAmount -= takeFee(_saverData.gasCost, paybackAmount);\\n        paybackAmount = limitLoanAmount(managerAddr, _saverData.cdpId, ilk, paybackAmount, user);\\n\\n        // Payback the debt\\n        paybackDebt(managerAddr, _saverData.cdpId, ilk, paybackAmount, user);\\n\\n        // Draw collateral to repay the flash loan\\n        drawCollateral(managerAddr, _saverData.cdpId, _saverData.joinAddr, (_saverData.loanAmount + _saverData.fee));\\n\\n        logger.Log(address(this), msg.sender, \\\"MCDFlashRepay\\\", abi.encode(_saverData.cdpId, user, _exchangeData.srcAmount, paybackAmount));\\n    }\\n\\n    /// @notice Handles that the amount is not bigger than cdp debt and not dust\\n    function limitLoanAmount(address _managerAddr, uint _cdpId, bytes32 _ilk, uint _paybackAmount, address _owner) internal returns (uint256) {\\n        uint debt = getAllDebt(address(vat), Manager(_managerAddr).urns(_cdpId), Manager(_managerAddr).urns(_cdpId), _ilk);\\n\\n        if (_paybackAmount > debt) {\\n            ERC20(DAI_ADDRESS).transfer(_owner, (_paybackAmount - debt));\\n            return debt;\\n        }\\n\\n        uint debtLeft = debt - _paybackAmount;\\n\\n        (,,,, uint dust) = vat.ilks(_ilk);\\n        dust = dust / 10**27;\\n\\n        // Less than dust value\\n        if (debtLeft < dust) {\\n            uint amountOverDust = (dust - debtLeft);\\n\\n            ERC20(DAI_ADDRESS).transfer(_owner, amountOverDust);\\n\\n            return (_paybackAmount - amountOverDust);\\n        }\\n\\n        return _paybackAmount;\\n    }\\n\\n    receive() external override(FlashLoanReceiverBase, DFSExchangeCore) payable {}\\n\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/close/MCDCloseFlashLoan.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../mcd/saver/MCDSaverProxy.sol\\\";\\nimport \\\"../../utils/FlashLoanReceiverBase.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeCore.sol\\\";\\nimport \\\"../../mcd/saver/MCDSaverProxyHelper.sol\\\";\\nimport \\\"./MCDCloseTaker.sol\\\";\\n\\ncontract MCDCloseFlashLoan is DFSExchangeCore, MCDSaverProxyHelper, FlashLoanReceiverBase, AdminAuth {\\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\\n\\n    uint public constant SERVICE_FEE = 400; // 0.25% Fee\\n\\n    bytes32 internal constant ETH_ILK = 0x4554482d41000000000000000000000000000000000000000000000000000000;\\n\\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n    address public constant DAI_JOIN_ADDRESS = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\\n    address public constant SPOTTER_ADDRESS = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;\\n    address public constant VAT_ADDRESS = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\\n\\n    DaiJoin public constant daiJoin = DaiJoin(DAI_JOIN_ADDRESS);\\n    Spotter public constant spotter = Spotter(SPOTTER_ADDRESS);\\n    Vat public constant vat = Vat(VAT_ADDRESS);\\n\\n    struct CloseData {\\n        uint cdpId;\\n        uint collAmount;\\n        uint daiAmount;\\n        uint minAccepted;\\n        address joinAddr;\\n        address proxy;\\n        uint flFee;\\n        bool toDai;\\n        address reserve;\\n        uint amount;\\n    }\\n\\n    constructor() FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER) public {}\\n\\n    function executeOperation(\\n        address _reserve,\\n        uint256 _amount,\\n        uint256 _fee,\\n        bytes calldata _params)\\n    external override {\\n\\n        (address proxy, bytes memory packedData) = abi.decode(_params, (address,bytes));\\n\\n        (MCDCloseTaker.CloseData memory closeDataSent, ExchangeData memory exchangeData) = abi.decode(packedData, (MCDCloseTaker.CloseData,ExchangeData));\\n\\n        CloseData memory closeData = CloseData({\\n            cdpId: closeDataSent.cdpId,\\n            collAmount: closeDataSent.collAmount,\\n            daiAmount: closeDataSent.daiAmount,\\n            minAccepted: closeDataSent.minAccepted,\\n            joinAddr: closeDataSent.joinAddr,\\n            proxy: proxy,\\n            flFee: _fee,\\n            toDai: closeDataSent.toDai,\\n            reserve: _reserve,\\n            amount: _amount\\n        });\\n\\n        address user = DSProxy(payable(closeData.proxy)).owner();\\n\\n        exchangeData.dfsFeeDivider = SERVICE_FEE;\\n        exchangeData.user = user;\\n\\n        address managerAddr = getManagerAddr(closeDataSent.managerType);\\n\\n        closeCDP(closeData, exchangeData, user, managerAddr);\\n    }\\n\\n    function closeCDP(\\n        CloseData memory _closeData,\\n        ExchangeData memory _exchangeData,\\n        address _user,\\n        address _managerAddr\\n    ) internal {\\n\\n        paybackDebt(_managerAddr, _closeData.cdpId, Manager(_managerAddr).ilks(_closeData.cdpId), _closeData.daiAmount); // payback whole debt\\n        uint drawnAmount = drawMaxCollateral(_managerAddr, _closeData.cdpId, _closeData.joinAddr, _closeData.collAmount); // draw whole collateral\\n\\n        uint daiSwaped = 0;\\n\\n        if (_closeData.toDai) {\\n            _exchangeData.srcAmount = drawnAmount;\\n            (, daiSwaped) = _sell(_exchangeData);\\n        } else {\\n            _exchangeData.destAmount = (_closeData.daiAmount + _closeData.flFee);\\n            (, daiSwaped) = _buy(_exchangeData);\\n        }\\n\\n        address tokenAddr = getVaultCollAddr(_closeData.joinAddr);\\n\\n        if (_closeData.toDai) {\\n            tokenAddr = DAI_ADDRESS;\\n        }\\n\\n        require(getBalance(tokenAddr) >= _closeData.minAccepted, \\\"Below min. number of eth specified\\\");\\n\\n        transferFundsBackToPoolInternal(_closeData.reserve, _closeData.amount.add(_closeData.flFee));\\n\\n        sendLeftover(tokenAddr, DAI_ADDRESS, payable(_user));\\n\\n    }\\n\\n    function drawMaxCollateral(address _managerAddr, uint _cdpId, address _joinAddr, uint _amount) internal returns (uint) {\\n        Manager(_managerAddr).frob(_cdpId, -toPositiveInt(_amount), 0);\\n        Manager(_managerAddr).flux(_cdpId, address(this), _amount);\\n\\n        uint joinAmount = _amount;\\n\\n        if (Join(_joinAddr).dec() != 18) {\\n            joinAmount = _amount / (10 ** (18 - Join(_joinAddr).dec()));\\n        }\\n\\n        Join(_joinAddr).exit(address(this), joinAmount);\\n\\n        if (isEthJoinAddr(_joinAddr)) {\\n            Join(_joinAddr).gem().withdraw(joinAmount); // Weth -> Eth\\n        }\\n\\n        return joinAmount;\\n    }\\n\\n    function paybackDebt(address _managerAddr, uint _cdpId, bytes32 _ilk, uint _daiAmount) internal {\\n        address urn = Manager(_managerAddr).urns(_cdpId);\\n\\n        daiJoin.dai().approve(DAI_JOIN_ADDRESS, _daiAmount);\\n        daiJoin.join(urn, _daiAmount);\\n\\n        Manager(_managerAddr).frob(_cdpId, 0, normalizePaybackAmount(VAT_ADDRESS, urn, _ilk));\\n    }\\n\\n    function getVaultCollAddr(address _joinAddr) internal view returns (address) {\\n        address tokenAddr = address(Join(_joinAddr).gem());\\n\\n        if (tokenAddr == EXCHANGE_WETH_ADDRESS) {\\n            return KYBER_ETH_ADDRESS;\\n        }\\n\\n        return tokenAddr;\\n    }\\n\\n    function getPrice(bytes32 _ilk) public view returns (uint256) {\\n        (, uint256 mat) = spotter.ilks(_ilk);\\n        (, , uint256 spot, , ) = vat.ilks(_ilk);\\n\\n        return rmul(rmul(spot, spotter.par()), mat);\\n    }\\n\\n    receive() external override(FlashLoanReceiverBase, DFSExchangeCore) payable {}\\n\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/close/MCDCloseTaker.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../mcd/saver/MCDSaverProxy.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../interfaces/ILendingPool.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeData.sol\\\";\\nimport \\\"../../utils/GasBurner.sol\\\";\\n\\nabstract contract IMCDSubscriptions {\\n    function unsubscribe(uint256 _cdpId) external virtual ;\\n\\n    function subscribersPos(uint256 _cdpId) external virtual returns (uint256, bool);\\n}\\n\\n\\ncontract MCDCloseTaker is MCDSaverProxyHelper, GasBurner {\\n\\n    address public constant SUBSCRIPTION_ADDRESS_NEW = 0xC45d4f6B6bf41b6EdAA58B01c4298B8d9078269a;\\n\\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\\n\\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\\n\\n    address public constant SPOTTER_ADDRESS = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;\\n    address public constant VAT_ADDRESS = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n\\n    // solhint-disable-next-line const-name-snakecase\\n    DefisaverLogger public constant logger = DefisaverLogger(DEFISAVER_LOGGER);\\n\\n    struct CloseData {\\n        uint cdpId;\\n        address joinAddr;\\n        uint collAmount;\\n        uint daiAmount;\\n        uint minAccepted;\\n        bool wholeDebt;\\n        bool toDai;\\n        ManagerType managerType;\\n    }\\n\\n    Vat public constant vat = Vat(VAT_ADDRESS);\\n    Spotter public constant spotter = Spotter(SPOTTER_ADDRESS);\\n\\n    function closeWithLoan(\\n        DFSExchangeData.ExchangeData memory _exchangeData,\\n        CloseData memory _closeData,\\n        address payable mcdCloseFlashLoan\\n    ) public payable burnGas(20) {\\n        mcdCloseFlashLoan.transfer(msg.value); // 0x fee\\n\\n        address managerAddr = getManagerAddr(_closeData.managerType);\\n\\n        if (_closeData.wholeDebt) {\\n            _closeData.daiAmount = getAllDebt(\\n                VAT_ADDRESS,\\n                Manager(managerAddr).urns(_closeData.cdpId),\\n                Manager(managerAddr).urns(_closeData.cdpId),\\n                Manager(managerAddr).ilks(_closeData.cdpId)\\n            );\\n\\n            (_closeData.collAmount, )\\n                = getCdpInfo(Manager(managerAddr), _closeData.cdpId, Manager(managerAddr).ilks(_closeData.cdpId));\\n        }\\n\\n        Manager(managerAddr).cdpAllow(_closeData.cdpId, mcdCloseFlashLoan, 1);\\n\\n        bytes memory packedData  = _packData(_closeData, _exchangeData);\\n        bytes memory paramsData = abi.encode(address(this), packedData);\\n\\n        lendingPool.flashLoan(mcdCloseFlashLoan, DAI_ADDRESS, _closeData.daiAmount, paramsData);\\n\\n        Manager(managerAddr).cdpAllow(_closeData.cdpId, mcdCloseFlashLoan, 0);\\n\\n        // If sub. to automatic protection unsubscribe\\n        unsubscribe(SUBSCRIPTION_ADDRESS_NEW, _closeData.cdpId);\\n\\n        logger.Log(address(this), msg.sender, \\\"MCDClose\\\", abi.encode(_closeData.cdpId, _closeData.collAmount, _closeData.daiAmount, _closeData.toDai));\\n    }\\n\\n    /// @notice Gets the maximum amount of debt available to generate\\n    /// @param _managerAddr Address of the CDP Manager\\n    /// @param _cdpId Id of the CDP\\n    /// @param _ilk Ilk of the CDP\\n    function getMaxDebt(address _managerAddr, uint256 _cdpId, bytes32 _ilk) public view returns (uint256) {\\n        uint256 price = getPrice(_ilk);\\n\\n        (, uint256 mat) = spotter.ilks(_ilk);\\n        (uint256 collateral, uint256 debt) = getCdpInfo(Manager(_managerAddr), _cdpId, _ilk);\\n\\n        return sub(wdiv(wmul(collateral, price), mat), debt);\\n    }\\n\\n    /// @notice Gets a price of the asset\\n    /// @param _ilk Ilk of the CDP\\n    function getPrice(bytes32 _ilk) public view returns (uint256) {\\n        (, uint256 mat) = spotter.ilks(_ilk);\\n        (, , uint256 spot, , ) = vat.ilks(_ilk);\\n\\n        return rmul(rmul(spot, spotter.par()), mat);\\n    }\\n\\n    function unsubscribe(address _subContract, uint _cdpId) internal {\\n        (, bool isSubscribed) = IMCDSubscriptions(_subContract).subscribersPos(_cdpId);\\n\\n        if (isSubscribed) {\\n            IMCDSubscriptions(_subContract).unsubscribe(_cdpId);\\n        }\\n    }\\n\\n    function _packData(\\n        CloseData memory _closeData,\\n        DFSExchangeData.ExchangeData memory _exchangeData\\n    ) internal pure returns (bytes memory) {\\n\\n        return abi.encode(_closeData, _exchangeData);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/cream/saver/CreamSaverFlashLoan.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../utils/FlashLoanReceiverBase.sol\\\";\\nimport \\\"../../interfaces/DSProxyInterface.sol\\\";\\nimport \\\"../../exchange/SaverExchangeCore.sol\\\";\\n\\n/// @title Contract that receives the FL from Aave for Repays/Boost\\ncontract CreamSaverFlashLoan is FlashLoanReceiverBase, SaverExchangeCore {\\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\\n\\n    address payable public COMPOUND_SAVER_FLASH_PROXY = 0x1e012554891d271eDc80ba8eB146EA5FF596fA51;\\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    address public owner;\\n\\n    using SafeERC20 for ERC20;\\n\\n    constructor()\\n        FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER)\\n        public {\\n            owner = msg.sender;\\n    }\\n\\n    /// @notice Called by Aave when sending back the FL amount\\n    /// @param _reserve The address of the borrowed token\\n    /// @param _amount Amount of FL tokens received\\n    /// @param _fee FL Aave fee\\n    /// @param _params The params that are sent from the original FL caller contract\\n   function executeOperation(\\n        address _reserve,\\n        uint256 _amount,\\n        uint256 _fee,\\n        bytes calldata _params)\\n    external override {\\n        // Format the call data for DSProxy\\n        (bytes memory proxyData, address payable proxyAddr) = packFunctionCall(_amount, _fee, _params);\\n\\n        // Send Flash loan amount to DSProxy\\n        sendLoanToProxy(proxyAddr, _reserve, _amount);\\n\\n        // Execute the DSProxy call\\n        DSProxyInterface(proxyAddr).execute(COMPOUND_SAVER_FLASH_PROXY, proxyData);\\n\\n        // Repay the loan with the money DSProxy sent back\\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\\n\\n        // if there is some eth left (0x fee), return it to user\\n        if (address(this).balance > 0) {\\n            tx.origin.transfer(address(this).balance);\\n        }\\n    }\\n\\n    /// @notice Formats function data call so we can call it through DSProxy\\n    /// @param _amount Amount of FL\\n    /// @param _fee Fee of the FL\\n    /// @param _params Saver proxy params\\n    /// @return proxyData Formated function call data\\n    function packFunctionCall(uint _amount, uint _fee, bytes memory _params) internal pure returns (bytes memory proxyData, address payable) {\\n        (\\n            bytes memory exDataBytes,\\n            address[2] memory cAddresses, // cCollAddress, cBorrowAddress\\n            uint256 gasCost,\\n            bool isRepay,\\n            address payable proxyAddr\\n        )\\n        = abi.decode(_params, (bytes,address[2],uint256,bool,address));\\n\\n        ExchangeData memory _exData = unpackExchangeData(exDataBytes);\\n\\n        uint[2] memory flashLoanData = [_amount, _fee];\\n\\n        if (isRepay) {\\n            proxyData = abi.encodeWithSignature(\\\"flashRepay((address,address,uint256,uint256,uint256,address,address,bytes,uint256),address[2],uint256,uint256[2])\\\", _exData, cAddresses, gasCost, flashLoanData);\\n        } else {\\n            proxyData = abi.encodeWithSignature(\\\"flashBoost((address,address,uint256,uint256,uint256,address,address,bytes,uint256),address[2],uint256,uint256[2])\\\", _exData, cAddresses, gasCost, flashLoanData);\\n        }\\n\\n        return (proxyData, proxyAddr);\\n    }\\n\\n    /// @notice Send the FL funds received to DSProxy\\n    /// @param _proxy DSProxy address\\n    /// @param _reserve Token address\\n    /// @param _amount Amount of tokens\\n    function sendLoanToProxy(address payable _proxy, address _reserve, uint _amount) internal {\\n        if (_reserve != ETH_ADDRESS) {\\n            ERC20(_reserve).safeTransfer(_proxy, _amount);\\n        }\\n\\n        _proxy.transfer(address(this).balance);\\n    }\\n\\n    receive() external override(SaverExchangeCore, FlashLoanReceiverBase) payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ExchangeDataParser.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../exchange/SaverExchangeCore.sol\\\";\\n\\ncontract ExchangeDataParser {\\n     function decodeExchangeData(\\n        SaverExchangeCore.ExchangeData memory exchangeData\\n    ) internal pure returns (address[4] memory, uint[4] memory, bytes memory) {\\n        return (\\n         [exchangeData.srcAddr, exchangeData.destAddr, exchangeData.exchangeAddr, exchangeData.wrapper],\\n         [exchangeData.srcAmount, exchangeData.destAmount, exchangeData.minPrice, exchangeData.price0x],\\n         exchangeData.callData\\n        );\\n    }\\n\\n    function encodeExchangeData(\\n        address[4] memory exAddr, uint[4] memory exNum, bytes memory callData\\n    ) internal pure returns (SaverExchangeCore.ExchangeData memory) {\\n        return SaverExchangeCore.ExchangeData({\\n            srcAddr: exAddr[0],\\n            destAddr: exAddr[1],\\n            srcAmount: exNum[0],\\n            destAmount: exNum[1],\\n            minPrice: exNum[2],\\n            wrapper: exAddr[3],\\n            exchangeAddr: exAddr[2],\\n            callData: callData,\\n            price0x: exNum[3]\\n        });\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/SaverExchange.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/GasTokenInterface.sol\\\";\\nimport \\\"../interfaces/IFeeRecipient.sol\\\";\\nimport \\\"./SaverExchangeCore.sol\\\";\\nimport \\\"../DS/DSMath.sol\\\";\\nimport \\\"../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../auth/AdminAuth.sol\\\";\\nimport \\\"../utils/GasBurner.sol\\\";\\nimport \\\"../utils/SafeERC20.sol\\\";\\n\\ncontract SaverExchange is SaverExchangeCore, AdminAuth, GasBurner {\\n\\n    using SafeERC20 for ERC20;\\n\\n    uint256 public constant SERVICE_FEE = 800; // 0.125% Fee\\n\\n    IFeeRecipient public constant _feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);\\n\\n    // solhint-disable-next-line const-name-snakecase\\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\\n\\n    uint public burnAmount = 10;\\n\\n    /// @notice Takes a src amount of tokens and converts it into the dest token\\n    /// @dev Takes fee from the _srcAmount before the exchange\\n    /// @param exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]\\n    /// @param _user User address who called the exchange\\n    function sell(ExchangeData memory exData, address payable _user) public payable burnGas(burnAmount) {\\n\\n        // take fee\\n        uint dfsFee = getFee(exData.srcAmount, exData.srcAddr);\\n        exData.srcAmount = sub(exData.srcAmount, dfsFee);\\n\\n        // Perform the exchange\\n        (address wrapper, uint destAmount) = _sell(exData);\\n\\n        // send back any leftover ether or tokens\\n        sendLeftover(exData.srcAddr, exData.destAddr, _user);\\n\\n        // log the event\\n        logger.Log(address(this), msg.sender, \\\"ExchangeSell\\\", abi.encode(wrapper, exData.srcAddr, exData.destAddr, exData.srcAmount, destAmount));\\n    }\\n\\n    /// @notice Takes a dest amount of tokens and converts it from the src token\\n    /// @dev Send always more than needed for the swap, extra will be returned\\n    /// @param exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]\\n    /// @param _user User address who called the exchange\\n    function buy(ExchangeData memory exData, address payable _user) public payable burnGas(burnAmount){\\n\\n        uint dfsFee = getFee(exData.srcAmount, exData.srcAddr);\\n        exData.srcAmount = sub(exData.srcAmount, dfsFee);\\n\\n        // Perform the exchange\\n        (address wrapper, uint srcAmount) = _buy(exData);\\n\\n        // send back any leftover ether or tokens\\n        sendLeftover(exData.srcAddr, exData.destAddr, _user);\\n\\n        // log the event\\n        logger.Log(address(this), msg.sender, \\\"ExchangeBuy\\\", abi.encode(wrapper, exData.srcAddr, exData.destAddr, srcAmount, exData.destAmount));\\n\\n    }\\n\\n    /// @notice Takes a feePercentage and sends it to wallet\\n    /// @param _amount Dai amount of the whole trade\\n    /// @param _token Address of the token\\n    /// @return feeAmount Amount in Dai owner earned on the fee\\n    function getFee(uint256 _amount, address _token) internal returns (uint256 feeAmount) {\\n        uint256 fee = SERVICE_FEE;\\n\\n        if (Discount(DISCOUNT_ADDRESS).isCustomFeeSet(msg.sender)) {\\n            fee = Discount(DISCOUNT_ADDRESS).getCustomServiceFee(msg.sender);\\n        }\\n\\n        if (fee == 0) {\\n            feeAmount = 0;\\n        } else {\\n            address walletAddr = _feeRecipient.getFeeAddr();\\n\\n            feeAmount = _amount / fee;\\n            if (_token == KYBER_ETH_ADDRESS) {\\n                payable(walletAddr).transfer(feeAmount);\\n            } else {\\n                ERC20(_token).safeTransfer(walletAddr, feeAmount);\\n            }\\n        }\\n    }\\n\\n    /// @notice Changes the amount of gas token we burn for each call\\n    /// @dev Only callable by the owner\\n    /// @param _newBurnAmount New amount of gas tokens to be burned\\n    function changeBurnAmount(uint _newBurnAmount) public {\\n        require(owner == msg.sender);\\n\\n        burnAmount = _newBurnAmount;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/exchangeV3/wrappersV3/KyberWrapperV3.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../interfaces/KyberNetworkProxyInterface.sol\\\";\\nimport \\\"../../interfaces/IFeeRecipient.sol\\\";\\nimport \\\"../../interfaces/ExchangeInterfaceV3.sol\\\";\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\ncontract KyberWrapperV3 is DSMath, ExchangeInterfaceV3, AdminAuth {\\n\\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant KYBER_INTERFACE = 0x9AAb3f75489902f3a48495025729a0AF77d4b11e;\\n\\n    IFeeRecipient public constant feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);\\n\\n    using SafeERC20 for ERC20;\\n\\n    /// @notice Sells a _srcAmount of tokens at Kyber\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _srcAmount From amount\\n    /// @return uint Destination amount\\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) external override payable returns (uint) {\\n        ERC20 srcToken = ERC20(_srcAddr);\\n        ERC20 destToken = ERC20(_destAddr);\\n\\n        address walletAddr = feeRecipient.getFeeAddr();\\n\\n        KyberNetworkProxyInterface kyberNetworkProxy = KyberNetworkProxyInterface(KYBER_INTERFACE);\\n\\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\\n            srcToken.safeApprove(address(kyberNetworkProxy), _srcAmount);\\n        }\\n\\n        uint destAmount = kyberNetworkProxy.trade{value: msg.value}(\\n            srcToken,\\n            _srcAmount,\\n            destToken,\\n            msg.sender,\\n            uint(-1),\\n            0,\\n            walletAddr\\n        );\\n\\n        return destAmount;\\n    }\\n\\n    /// @notice Buys a _destAmount of tokens at Kyber\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _destAmount To amount\\n    /// @return uint srcAmount\\n    function buy(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) external override payable returns(uint) {\\n        ERC20 srcToken = ERC20(_srcAddr);\\n        ERC20 destToken = ERC20(_destAddr);\\n\\n        address walletAddr = feeRecipient.getFeeAddr();\\n\\n        uint srcAmount = 0;\\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\\n            srcAmount = srcToken.balanceOf(address(this));\\n        } else {\\n            srcAmount = msg.value;\\n        }\\n\\n        KyberNetworkProxyInterface kyberNetworkProxy = KyberNetworkProxyInterface(KYBER_INTERFACE);\\n\\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\\n            srcToken.safeApprove(address(kyberNetworkProxy), srcAmount);\\n        }\\n\\n        uint destAmount = kyberNetworkProxy.trade{value: msg.value}(\\n            srcToken,\\n            srcAmount,\\n            destToken,\\n            msg.sender,\\n            _destAmount,\\n            0,\\n            walletAddr\\n        );\\n\\n        require(destAmount == _destAmount, \\\"Wrong dest amount\\\");\\n\\n        uint srcAmountAfter = 0;\\n\\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\\n            srcAmountAfter = srcToken.balanceOf(address(this));\\n        } else {\\n            srcAmountAfter = address(this).balance;\\n        }\\n\\n        // Send the leftover from the source token back\\n        sendLeftOver(_srcAddr);\\n\\n        return (srcAmount - srcAmountAfter);\\n    }\\n\\n    /// @notice Return a rate for which we can sell an amount of tokens\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _srcAmount From amount\\n    /// @return rate Rate\\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) public override view returns (uint rate) {\\n        (rate, ) = KyberNetworkProxyInterface(KYBER_INTERFACE)\\n            .getExpectedRate(ERC20(_srcAddr), ERC20(_destAddr), _srcAmount);\\n\\n        // multiply with decimal difference in src token\\n        rate = rate * (10**(18 - getDecimals(_srcAddr)));\\n        // divide with decimal difference in dest token\\n        rate = rate / (10**(18 - getDecimals(_destAddr)));\\n    }\\n\\n    /// @notice Return a rate for which we can buy an amount of tokens\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _destAmount To amount\\n    /// @return rate Rate\\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) public override view returns (uint rate) {\\n        uint256 srcRate = getSellRate(_destAddr, _srcAddr, _destAmount, _additionalData);\\n        uint256 srcAmount = wmul(srcRate, _destAmount);\\n\\n        rate = getSellRate(_srcAddr, _destAddr, srcAmount, _additionalData);\\n\\n        // increase rate by 3% too account for inaccuracy between sell/buy conversion\\n        rate = rate + (rate / 30);\\n    }\\n\\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\\n    /// @param _srcAddr Source token address\\n    function sendLeftOver(address _srcAddr) internal {\\n        msg.sender.transfer(address(this).balance);\\n\\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\\n            ERC20(_srcAddr).safeTransfer(msg.sender, ERC20(_srcAddr).balanceOf(address(this)));\\n        }\\n    }\\n\\n    receive() payable external {}\\n\\n    function getDecimals(address _token) internal view returns (uint256) {\\n        if (_token == KYBER_ETH_ADDRESS) return 18;\\n\\n        return ERC20(_token).decimals();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/KyberNetworkProxyInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\nabstract contract KyberNetworkProxyInterface {\\n    function maxGasPrice() external virtual view returns (uint256);\\n\\n    function getUserCapInWei(address user) external virtual view returns (uint256);\\n\\n    function getUserCapInTokenWei(address user, ERC20 token) external virtual view returns (uint256);\\n\\n    function enabled() external virtual view returns (bool);\\n\\n    function info(bytes32 id) external virtual view returns (uint256);\\n\\n    function getExpectedRate(ERC20 src, ERC20 dest, uint256 srcQty)\\n        public virtual\\n        view\\n        returns (uint256 expectedRate, uint256 slippageRate);\\n\\n    function tradeWithHint(\\n        ERC20 src,\\n        uint256 srcAmount,\\n        ERC20 dest,\\n        address destAddress,\\n        uint256 maxDestAmount,\\n        uint256 minConversionRate,\\n        address walletId,\\n        bytes memory hint\\n    ) public virtual payable returns (uint256);\\n\\n    function trade(\\n        ERC20 src,\\n        uint256 srcAmount,\\n        ERC20 dest,\\n        address destAddress,\\n        uint256 maxDestAmount,\\n        uint256 minConversionRate,\\n        address walletId\\n    ) public virtual payable returns (uint256);\\n\\n    function swapEtherToToken(ERC20 token, uint256 minConversionRate)\\n        external virtual\\n        payable\\n        returns (uint256);\\n\\n    function swapTokenToEther(ERC20 token, uint256 tokenQty, uint256 minRate)\\n        external virtual\\n        payable\\n        returns (uint256);\\n\\n    function swapTokenToToken(ERC20 src, uint256 srcAmount, ERC20 dest, uint256 minConversionRate)\\n        public virtual\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/exchangeV3/wrappersV3/UniswapWrapperV3.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../interfaces/ExchangeInterfaceV3.sol\\\";\\nimport \\\"../../interfaces/UniswapRouterInterface.sol\\\";\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\n/// @title DFS exchange wrapper for UniswapV2\\ncontract UniswapWrapperV3 is DSMath, ExchangeInterfaceV3, AdminAuth {\\n\\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    UniswapRouterInterface public constant router = UniswapRouterInterface(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n\\n    using SafeERC20 for ERC20;\\n\\n    /// @notice Sells a _srcAmount of tokens at UniswapV2\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _srcAmount From amount\\n    /// @return uint Destination amount\\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) external payable override returns (uint) {\\n        _srcAddr = ethToWethAddr(_srcAddr);\\n        _destAddr = ethToWethAddr(_destAddr);\\n\\n        uint[] memory amounts;\\n        address[] memory path = abi.decode(_additionalData, (address[]));\\n\\n        ERC20(_srcAddr).safeApprove(address(router), _srcAmount);\\n\\n        // if we are buying ether\\n        if (_destAddr == WETH_ADDRESS) {\\n            amounts = router.swapExactTokensForETH(_srcAmount, 1, path, msg.sender, block.timestamp + 1);\\n        }\\n        // if we are selling token to token\\n        else {\\n            amounts = router.swapExactTokensForTokens(_srcAmount, 1, path, msg.sender, block.timestamp + 1);\\n        }\\n\\n        return amounts[amounts.length - 1];\\n    }\\n\\n    /// @notice Buys a _destAmount of tokens at UniswapV2\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _destAmount To amount\\n    /// @return uint srcAmount\\n    function buy(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) external override payable returns(uint) {\\n\\n        _srcAddr = ethToWethAddr(_srcAddr);\\n        _destAddr = ethToWethAddr(_destAddr);\\n\\n        uint[] memory amounts;\\n        address[] memory path = abi.decode(_additionalData, (address[]));\\n\\n        ERC20(_srcAddr).safeApprove(address(router), uint(-1));\\n\\n\\n         // if we are buying ether\\n        if (_destAddr == WETH_ADDRESS) {\\n            amounts = router.swapTokensForExactETH(_destAmount, uint(-1), path, msg.sender, block.timestamp + 1);\\n        }\\n        // if we are buying token to token\\n        else {\\n            amounts = router.swapTokensForExactTokens(_destAmount, uint(-1), path, msg.sender, block.timestamp + 1);\\n        }\\n\\n        // Send the leftover from the source token back\\n        sendLeftOver(_srcAddr);\\n\\n        return amounts[0];\\n    }\\n\\n    /// @notice Return a rate for which we can sell an amount of tokens\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _srcAmount From amount\\n    /// @return uint Rate\\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory _additionalData) public override view returns (uint) {\\n        _srcAddr = ethToWethAddr(_srcAddr);\\n        _destAddr = ethToWethAddr(_destAddr);\\n\\n        address[] memory path = abi.decode(_additionalData, (address[]));\\n\\n        uint[] memory amounts = router.getAmountsOut(_srcAmount, path);\\n        return wdiv(amounts[amounts.length - 1], _srcAmount);\\n    }\\n\\n    /// @notice Return a rate for which we can buy an amount of tokens\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _destAmount To amount\\n    /// @return uint Rate\\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) public override view returns (uint) {\\n        _srcAddr = ethToWethAddr(_srcAddr);\\n        _destAddr = ethToWethAddr(_destAddr);\\n\\n        address[] memory path = abi.decode(_additionalData, (address[]));\\n\\n        uint[] memory amounts = router.getAmountsIn(_destAmount, path);\\n        return wdiv(_destAmount, amounts[0]);\\n    }\\n\\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\\n    /// @param _srcAddr Source token address\\n    function sendLeftOver(address _srcAddr) internal {\\n        msg.sender.transfer(address(this).balance);\\n\\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\\n            ERC20(_srcAddr).safeTransfer(msg.sender, ERC20(_srcAddr).balanceOf(address(this)));\\n        }\\n    }\\n\\n    /// @notice Converts Kybers Eth address -> Weth\\n    /// @param _src Input address\\n    function ethToWethAddr(address _src) internal pure returns (address) {\\n        return _src == KYBER_ETH_ADDRESS ? WETH_ADDRESS : _src;\\n    }\\n\\n    function getDecimals(address _token) internal view returns (uint256) {\\n        if (_token == KYBER_ETH_ADDRESS) return 18;\\n\\n        return ERC20(_token).decimals();\\n    }\\n\\n    receive() payable external {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/UniswapRouterInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract UniswapRouterInterface {\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    virtual\\n    returns (uint[] memory amounts);\\n\\n  function swapExactTokensForTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n    ) external virtual returns (uint[] memory amounts);\\n\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n    external virtual\\n    returns (uint[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n    uint amountOut,\\n    uint amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n    ) external virtual returns (uint[] memory amounts);\\n\\n    function getAmountsOut(uint amountIn, address[] memory path) public virtual view returns (uint[] memory amounts);\\n\\n    function getAmountsIn(uint amountOut, address[] memory path) public virtual view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/wrappers/UniswapV2Wrapper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../interfaces/ExchangeInterfaceV2.sol\\\";\\nimport \\\"../../interfaces/UniswapRouterInterface.sol\\\";\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\n/// @title DFS exchange wrapper for UniswapV2\\ncontract UniswapV2Wrapper is DSMath, ExchangeInterfaceV2, AdminAuth {\\n\\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    UniswapRouterInterface public constant router = UniswapRouterInterface(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n\\n    using SafeERC20 for ERC20;\\n\\n    /// @notice Sells a _srcAmount of tokens at UniswapV2\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _srcAmount From amount\\n    /// @return uint Destination amount\\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external payable override returns (uint) {\\n        _srcAddr = ethToWethAddr(_srcAddr);\\n        _destAddr = ethToWethAddr(_destAddr);\\n\\n        uint[] memory amounts;\\n        address[] memory path = new address[](2);\\n        path[0] = _srcAddr;\\n        path[1] = _destAddr;\\n\\n        ERC20(_srcAddr).safeApprove(address(router), _srcAmount);\\n\\n        // if we are buying ether\\n        if (_destAddr == WETH_ADDRESS) {\\n            amounts = router.swapExactTokensForETH(_srcAmount, 1, path, msg.sender, block.timestamp + 1);\\n        }\\n        // if we are selling token to token\\n        else {\\n            amounts = router.swapExactTokensForTokens(_srcAmount, 1, path, msg.sender, block.timestamp + 1);\\n        }\\n\\n        return amounts[amounts.length - 1];\\n    }\\n\\n    /// @notice Buys a _destAmount of tokens at UniswapV2\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _destAmount To amount\\n    /// @return uint srcAmount\\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\\n\\n        _srcAddr = ethToWethAddr(_srcAddr);\\n        _destAddr = ethToWethAddr(_destAddr);\\n\\n        uint[] memory amounts;\\n        address[] memory path = new address[](2);\\n        path[0] = _srcAddr;\\n        path[1] = _destAddr;\\n\\n        ERC20(_srcAddr).safeApprove(address(router), uint(-1));\\n\\n\\n         // if we are buying ether\\n        if (_destAddr == WETH_ADDRESS) {\\n            amounts = router.swapTokensForExactETH(_destAmount, uint(-1), path, msg.sender, block.timestamp + 1);\\n        }\\n        // if we are buying token to token\\n        else {\\n            amounts = router.swapTokensForExactTokens(_destAmount, uint(-1), path, msg.sender, block.timestamp + 1);\\n        }\\n\\n        // Send the leftover from the source token back\\n        sendLeftOver(_srcAddr);\\n\\n        return amounts[0];\\n    }\\n\\n    /// @notice Return a rate for which we can sell an amount of tokens\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _srcAmount From amount\\n    /// @return uint Rate\\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint) {\\n        _srcAddr = ethToWethAddr(_srcAddr);\\n        _destAddr = ethToWethAddr(_destAddr);\\n\\n        address[] memory path = new address[](2);\\n        path[0] = _srcAddr;\\n        path[1] = _destAddr;\\n\\n        uint[] memory amounts = router.getAmountsOut(_srcAmount, path);\\n        return wdiv(amounts[amounts.length - 1], _srcAmount);\\n    }\\n\\n    /// @notice Return a rate for which we can buy an amount of tokens\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _destAmount To amount\\n    /// @return uint Rate\\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount) public override view returns (uint) {\\n        _srcAddr = ethToWethAddr(_srcAddr);\\n        _destAddr = ethToWethAddr(_destAddr);\\n\\n        address[] memory path = new address[](2);\\n        path[0] = _srcAddr;\\n        path[1] = _destAddr;\\n\\n        uint[] memory amounts = router.getAmountsIn(_destAmount, path);\\n        return wdiv(_destAmount, amounts[0]);\\n    }\\n\\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\\n    /// @param _srcAddr Source token address\\n    function sendLeftOver(address _srcAddr) internal {\\n        msg.sender.transfer(address(this).balance);\\n\\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\\n            ERC20(_srcAddr).safeTransfer(msg.sender, ERC20(_srcAddr).balanceOf(address(this)));\\n        }\\n    }\\n\\n    /// @notice Converts Kybers Eth address -> Weth\\n    /// @param _src Input address\\n    function ethToWethAddr(address _src) internal pure returns (address) {\\n        return _src == KYBER_ETH_ADDRESS ? WETH_ADDRESS : _src;\\n    }\\n\\n    function getDecimals(address _token) internal view returns (uint256) {\\n        if (_token == KYBER_ETH_ADDRESS) return 18;\\n\\n        return ERC20(_token).decimals();\\n    }\\n\\n    receive() payable external {}\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/wrappers/UniswapWrapper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../interfaces/KyberNetworkProxyInterface.sol\\\";\\nimport \\\"../../interfaces/ExchangeInterfaceV2.sol\\\";\\nimport \\\"../../interfaces/UniswapExchangeInterface.sol\\\";\\nimport \\\"../../interfaces/UniswapFactoryInterface.sol\\\";\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\ncontract UniswapWrapper is DSMath, ExchangeInterfaceV2, AdminAuth {\\n\\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant UNISWAP_FACTORY = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;\\n\\n    using SafeERC20 for ERC20;\\n\\n    /// @notice Sells a _srcAmount of tokens at Uniswap\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _srcAmount From amount\\n    /// @return uint Destination amount\\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external payable override returns (uint) {\\n        address uniswapExchangeAddr;\\n        uint destAmount;\\n\\n        _srcAddr = ethToWethAddr(_srcAddr);\\n        _destAddr = ethToWethAddr(_destAddr);\\n\\n        // if we are buying ether\\n        if (_destAddr == WETH_ADDRESS) {\\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\\n\\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, _srcAmount);\\n\\n            destAmount = UniswapExchangeInterface(uniswapExchangeAddr).\\n                tokenToEthTransferInput(_srcAmount, 1, block.timestamp + 1, msg.sender);\\n        }\\n        // if we are selling token to token\\n        else {\\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\\n\\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, _srcAmount);\\n\\n            destAmount = UniswapExchangeInterface(uniswapExchangeAddr).\\n                tokenToTokenTransferInput(_srcAmount, 1, 1, block.timestamp + 1, msg.sender, _destAddr);\\n        }\\n\\n        return destAmount;\\n    }\\n\\n    /// @notice Buys a _destAmount of tokens at Uniswap\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _destAmount To amount\\n    /// @return uint srcAmount\\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\\n        address uniswapExchangeAddr;\\n        uint srcAmount;\\n\\n        _srcAddr = ethToWethAddr(_srcAddr);\\n        _destAddr = ethToWethAddr(_destAddr);\\n\\n         // if we are buying ether\\n        if (_destAddr == WETH_ADDRESS) {\\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\\n\\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, uint(-1));\\n\\n            srcAmount = UniswapExchangeInterface(uniswapExchangeAddr).\\n                tokenToEthTransferOutput(_destAmount, uint(-1), block.timestamp + 1, msg.sender);\\n        }\\n        // if we are buying token to token\\n        else {\\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\\n\\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, uint(-1));\\n\\n            srcAmount = UniswapExchangeInterface(uniswapExchangeAddr).\\n                tokenToTokenTransferOutput(_destAmount, uint(-1), uint(-1), block.timestamp + 1, msg.sender, _destAddr);\\n        }\\n\\n        // Send the leftover from the source token back\\n        sendLeftOver(_srcAddr);\\n\\n        return srcAmount;\\n    }\\n\\n    /// @notice Return a rate for which we can sell an amount of tokens\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _srcAmount From amount\\n    /// @return uint Rate\\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint) {\\n        _srcAddr = ethToWethAddr(_srcAddr);\\n        _destAddr = ethToWethAddr(_destAddr);\\n\\n        if(_srcAddr == WETH_ADDRESS) {\\n            address uniswapTokenAddress = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr);\\n            return wdiv(UniswapExchangeInterface(uniswapTokenAddress).getEthToTokenInputPrice(_srcAmount), _srcAmount);\\n        } else if (_destAddr == WETH_ADDRESS) {\\n            address uniswapTokenAddress = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\\n            return wdiv(UniswapExchangeInterface(uniswapTokenAddress).getTokenToEthInputPrice(_srcAmount), _srcAmount);\\n        } else {\\n            uint ethBought = UniswapExchangeInterface(UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr)).getTokenToEthInputPrice(_srcAmount);\\n            return wdiv(UniswapExchangeInterface(UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr)).getEthToTokenInputPrice(ethBought), _srcAmount);\\n        }\\n    }\\n\\n    /// @notice Return a rate for which we can buy an amount of tokens\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _destAmount To amount\\n    /// @return uint Rate\\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount) public override view returns (uint) {\\n        _srcAddr = ethToWethAddr(_srcAddr);\\n        _destAddr = ethToWethAddr(_destAddr);\\n\\n        if(_srcAddr == WETH_ADDRESS) {\\n            address uniswapTokenAddress = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr);\\n            return wdiv(1 ether, wdiv(UniswapExchangeInterface(uniswapTokenAddress).getEthToTokenOutputPrice(_destAmount), _destAmount));\\n        } else if (_destAddr == WETH_ADDRESS) {\\n            address uniswapTokenAddress = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\\n            return wdiv(1 ether, wdiv(UniswapExchangeInterface(uniswapTokenAddress).getTokenToEthOutputPrice(_destAmount), _destAmount));\\n        } else {\\n            uint ethNeeded = UniswapExchangeInterface(UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr)).getTokenToEthOutputPrice(_destAmount);\\n            return wdiv(1 ether, wdiv(UniswapExchangeInterface(UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr)).getEthToTokenOutputPrice(ethNeeded), _destAmount));\\n        }\\n    }\\n\\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\\n    /// @param _srcAddr Source token address\\n    function sendLeftOver(address _srcAddr) internal {\\n        msg.sender.transfer(address(this).balance);\\n\\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\\n            ERC20(_srcAddr).safeTransfer(msg.sender, ERC20(_srcAddr).balanceOf(address(this)));\\n        }\\n    }\\n\\n    /// @notice Converts Kybers Eth address -> Weth\\n    /// @param _src Input address\\n    function ethToWethAddr(address _src) internal pure returns (address) {\\n        return _src == KYBER_ETH_ADDRESS ? WETH_ADDRESS : _src;\\n    }\\n\\n    receive() payable external {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/UniswapExchangeInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract UniswapExchangeInterface {\\n    function getEthToTokenInputPrice(uint256 eth_sold)\\n        external virtual\\n        view\\n        returns (uint256 tokens_bought);\\n\\n    function getEthToTokenOutputPrice(uint256 tokens_bought)\\n        external virtual\\n        view\\n        returns (uint256 eth_sold);\\n\\n    function getTokenToEthInputPrice(uint256 tokens_sold)\\n        external virtual\\n        view\\n        returns (uint256 eth_bought);\\n\\n    function getTokenToEthOutputPrice(uint256 eth_bought)\\n        external virtual\\n        view\\n        returns (uint256 tokens_sold);\\n\\n    function tokenToEthTransferInput(\\n        uint256 tokens_sold,\\n        uint256 min_eth,\\n        uint256 deadline,\\n        address recipient\\n    ) external virtual returns (uint256 eth_bought);\\n\\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient)\\n        external virtual\\n        payable\\n        returns (uint256 tokens_bought);\\n\\n    function tokenToTokenTransferInput(\\n        uint256 tokens_sold,\\n        uint256 min_tokens_bought,\\n        uint256 min_eth_bought,\\n        uint256 deadline,\\n        address recipient,\\n        address token_addr\\n    ) external virtual returns (uint256 tokens_bought);\\n\\n    function ethToTokenTransferOutput(\\n        uint256 tokens_bought,\\n        uint256 deadline,\\n        address recipient\\n    ) external virtual payable returns (uint256  eth_sold);\\n\\n    function tokenToEthTransferOutput(\\n        uint256 eth_bought,\\n        uint256 max_tokens,\\n        uint256 deadline,\\n        address recipient\\n    ) external virtual returns (uint256  tokens_sold);\\n\\n    function tokenToTokenTransferOutput(\\n        uint256 tokens_bought,\\n        uint256 max_tokens_sold,\\n        uint256 max_eth_sold,\\n        uint256 deadline,\\n        address recipient,\\n        address token_addr\\n    ) external virtual returns (uint256  tokens_sold);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/UniswapFactoryInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract UniswapFactoryInterface {\\n    function getExchange(address token) external view virtual returns (address exchange);\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/wrappers/KyberWrapper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../interfaces/KyberNetworkProxyInterface.sol\\\";\\nimport \\\"../../interfaces/ExchangeInterfaceV2.sol\\\";\\nimport \\\"../../interfaces/IFeeRecipient.sol\\\";\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\ncontract KyberWrapper is DSMath, ExchangeInterfaceV2, AdminAuth {\\n\\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant KYBER_INTERFACE = 0x9AAb3f75489902f3a48495025729a0AF77d4b11e;\\n\\n    IFeeRecipient public constant feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);\\n\\n    using SafeERC20 for ERC20;\\n\\n    /// @notice Sells a _srcAmount of tokens at Kyber\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _srcAmount From amount\\n    /// @return uint Destination amount\\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external override payable returns (uint) {\\n        ERC20 srcToken = ERC20(_srcAddr);\\n        ERC20 destToken = ERC20(_destAddr);\\n\\n        address walletAddr = feeRecipient.getFeeAddr();\\n\\n        KyberNetworkProxyInterface kyberNetworkProxy = KyberNetworkProxyInterface(KYBER_INTERFACE);\\n\\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\\n            srcToken.safeApprove(address(kyberNetworkProxy), _srcAmount);\\n        }\\n\\n        uint destAmount = kyberNetworkProxy.trade{value: msg.value}(\\n            srcToken,\\n            _srcAmount,\\n            destToken,\\n            msg.sender,\\n            uint(-1),\\n            0,\\n            walletAddr\\n        );\\n\\n        return destAmount;\\n    }\\n\\n    /// @notice Buys a _destAmount of tokens at Kyber\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _destAmount To amount\\n    /// @return uint srcAmount\\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\\n        ERC20 srcToken = ERC20(_srcAddr);\\n        ERC20 destToken = ERC20(_destAddr);\\n\\n        address walletAddr = feeRecipient.getFeeAddr();\\n\\n        uint srcAmount = 0;\\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\\n            srcAmount = srcToken.balanceOf(address(this));\\n        } else {\\n            srcAmount = msg.value;\\n        }\\n\\n        KyberNetworkProxyInterface kyberNetworkProxy = KyberNetworkProxyInterface(KYBER_INTERFACE);\\n\\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\\n            srcToken.safeApprove(address(kyberNetworkProxy), srcAmount);\\n        }\\n\\n        uint destAmount = kyberNetworkProxy.trade{value: msg.value}(\\n            srcToken,\\n            srcAmount,\\n            destToken,\\n            msg.sender,\\n            _destAmount,\\n            0,\\n            walletAddr\\n        );\\n\\n        require(destAmount == _destAmount, \\\"Wrong dest amount\\\");\\n\\n        uint srcAmountAfter = 0;\\n\\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\\n            srcAmountAfter = srcToken.balanceOf(address(this));\\n        } else {\\n            srcAmountAfter = address(this).balance;\\n        }\\n\\n        // Send the leftover from the source token back\\n        sendLeftOver(_srcAddr);\\n\\n        return (srcAmount - srcAmountAfter);\\n    }\\n\\n    /// @notice Return a rate for which we can sell an amount of tokens\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _srcAmount From amount\\n    /// @return rate Rate\\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint rate) {\\n        (rate, ) = KyberNetworkProxyInterface(KYBER_INTERFACE)\\n            .getExpectedRate(ERC20(_srcAddr), ERC20(_destAddr), _srcAmount);\\n\\n        // multiply with decimal difference in src token\\n        rate = rate * (10**(18 - getDecimals(_srcAddr)));\\n        // divide with decimal difference in dest token\\n        rate = rate / (10**(18 - getDecimals(_destAddr)));\\n    }\\n\\n    /// @notice Return a rate for which we can buy an amount of tokens\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _destAmount To amount\\n    /// @return rate Rate\\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount) public override view returns (uint rate) {\\n        uint256 srcRate = getSellRate(_destAddr, _srcAddr, _destAmount);\\n        uint256 srcAmount = wmul(srcRate, _destAmount);\\n\\n        rate = getSellRate(_srcAddr, _destAddr, srcAmount);\\n\\n        // increase rate by 3% too account for inaccuracy between sell/buy conversion\\n        rate = rate + (rate / 30);\\n    }\\n\\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\\n    /// @param _srcAddr Source token address\\n    function sendLeftOver(address _srcAddr) internal {\\n        msg.sender.transfer(address(this).balance);\\n\\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\\n            ERC20(_srcAddr).safeTransfer(msg.sender, ERC20(_srcAddr).balanceOf(address(this)));\\n        }\\n    }\\n\\n    receive() payable external {}\\n\\n    function getDecimals(address _token) internal view returns (uint256) {\\n        if (_token == KYBER_ETH_ADDRESS) return 18;\\n\\n        return ERC20(_token).decimals();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/wrappers/OasisTradeWrapper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../interfaces/ExchangeInterfaceV2.sol\\\";\\nimport \\\"../../interfaces/OasisInterface.sol\\\";\\nimport \\\"../../interfaces/TokenInterface.sol\\\";\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\ncontract OasisTradeWrapper is DSMath, ExchangeInterfaceV2, AdminAuth {\\n\\n    using SafeERC20 for ERC20;\\n\\n    address public constant OTC_ADDRESS = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;\\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @notice Sells a _srcAmount of tokens at Oasis\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _srcAmount From amount\\n    /// @return uint Destination amount\\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external override payable returns (uint) {\\n        address srcAddr = ethToWethAddr(_srcAddr);\\n        address destAddr = ethToWethAddr(_destAddr);\\n\\n        ERC20(srcAddr).safeApprove(OTC_ADDRESS, _srcAmount);\\n\\n        uint destAmount = OasisInterface(OTC_ADDRESS).sellAllAmount(srcAddr, _srcAmount, destAddr, 0);\\n\\n        // convert weth -> eth and send back\\n        if (destAddr == WETH_ADDRESS) {\\n            TokenInterface(WETH_ADDRESS).withdraw(destAmount);\\n            msg.sender.transfer(destAmount);\\n        } else {\\n            ERC20(destAddr).safeTransfer(msg.sender, destAmount);\\n        }\\n\\n        return destAmount;\\n    }\\n\\n    /// @notice Buys a _destAmount of tokens at Oasis\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _destAmount To amount\\n    /// @return uint srcAmount\\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\\n        address srcAddr = ethToWethAddr(_srcAddr);\\n        address destAddr = ethToWethAddr(_destAddr);\\n\\n        ERC20(srcAddr).safeApprove(OTC_ADDRESS, uint(-1));\\n\\n        uint srcAmount = OasisInterface(OTC_ADDRESS).buyAllAmount(destAddr, _destAmount, srcAddr, uint(-1));\\n\\n        // convert weth -> eth and send back\\n        if (destAddr == WETH_ADDRESS) {\\n            TokenInterface(WETH_ADDRESS).withdraw(_destAmount);\\n            msg.sender.transfer(_destAmount);\\n        } else {\\n            ERC20(destAddr).safeTransfer(msg.sender, _destAmount);\\n        }\\n\\n        // Send the leftover from the source token back\\n        sendLeftOver(srcAddr);\\n\\n        return srcAmount;\\n    }\\n\\n    /// @notice Return a rate for which we can sell an amount of tokens\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _srcAmount From amount\\n    /// @return uint Rate\\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint) {\\n        address srcAddr = ethToWethAddr(_srcAddr);\\n        address destAddr = ethToWethAddr(_destAddr);\\n\\n        return wdiv(OasisInterface(OTC_ADDRESS).getBuyAmount(destAddr, srcAddr, _srcAmount), _srcAmount);\\n    }\\n\\n\\n    /// @notice Return a rate for which we can buy an amount of tokens\\n    /// @param _srcAddr From token\\n    /// @param _destAddr To token\\n    /// @param _destAmount To amount\\n    /// @return uint Rate\\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount) public override view returns (uint) {\\n        address srcAddr = ethToWethAddr(_srcAddr);\\n        address destAddr = ethToWethAddr(_destAddr);\\n\\n        return wdiv(1 ether, wdiv(OasisInterface(OTC_ADDRESS).getPayAmount(srcAddr, destAddr, _destAmount), _destAmount));\\n    }\\n\\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\\n    /// @param _srcAddr Source token address\\n     function sendLeftOver(address _srcAddr) internal {\\n        msg.sender.transfer(address(this).balance);\\n\\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\\n            ERC20(_srcAddr).safeTransfer(msg.sender, ERC20(_srcAddr).balanceOf(address(this)));\\n        }\\n    }\\n\\n    /// @notice Converts Kybers Eth address -> Weth\\n    /// @param _src Input address\\n    function ethToWethAddr(address _src) internal pure returns (address) {\\n        return _src == KYBER_ETH_ADDRESS ? WETH_ADDRESS : _src;\\n    }\\n\\n\\n    receive() payable external {}\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/Prices.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../DS/DSMath.sol\\\";\\nimport \\\"../interfaces/TokenInterface.sol\\\";\\nimport \\\"../interfaces/ExchangeInterfaceV2.sol\\\";\\nimport \\\"./SaverExchangeHelper.sol\\\";\\n\\ncontract Prices is DSMath {\\n\\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    enum ActionType { SELL, BUY }\\n\\n\\n    /// @notice Returns the best estimated price from 2 exchanges\\n    /// @param _amount Amount of source tokens you want to exchange\\n    /// @param _srcToken Address of the source token\\n    /// @param _destToken Address of the destination token\\n    /// @param _type Type of action SELL|BUY\\n    /// @param _wrappers Array of wrapper addresses to compare\\n    /// @return (address, uint) The address of the best exchange and the exchange price\\n    function getBestPrice(\\n        uint256 _amount,\\n        address _srcToken,\\n        address _destToken,\\n        ActionType _type,\\n        address[] memory _wrappers\\n    ) public returns (address, uint256) {\\n\\n        uint256[] memory rates = new uint256[](_wrappers.length);\\n        for (uint i=0; i<_wrappers.length; i++) {\\n            rates[i] = getExpectedRate(_wrappers[i], _srcToken, _destToken, _amount, _type);\\n        }\\n\\n        return getBiggestRate(_wrappers, rates);\\n    }\\n\\n    /// @notice Return the expected rate from the exchange wrapper\\n    /// @dev In case of Oasis/Uniswap handles the different precision tokens\\n    /// @param _wrapper Address of exchange wrapper\\n    /// @param _srcToken From token\\n    /// @param _destToken To token\\n    /// @param _amount Amount to be exchanged\\n    /// @param _type Type of action SELL|BUY\\n    function getExpectedRate(\\n        address _wrapper,\\n        address _srcToken,\\n        address _destToken,\\n        uint256 _amount,\\n        ActionType _type\\n    ) public returns (uint256) {\\n        bool success;\\n        bytes memory result;\\n\\n        if (_type == ActionType.SELL) {\\n            (success, result) = _wrapper.call(abi.encodeWithSignature(\\n                \\\"getSellRate(address,address,uint256)\\\",\\n                _srcToken,\\n                _destToken,\\n                _amount\\n            ));\\n\\n        } else {\\n            (success, result) = _wrapper.call(abi.encodeWithSignature(\\n                \\\"getBuyRate(address,address,uint256)\\\",\\n                _srcToken,\\n                _destToken,\\n                _amount\\n            ));\\n        }\\n\\n        if (success) {\\n            return sliceUint(result, 0);\\n        }\\n\\n        return 0;\\n    }\\n\\n    /// @notice Finds the biggest rate between exchanges, needed for sell rate\\n    /// @param _wrappers Array of wrappers to compare\\n    /// @param _rates Array of rates to compare\\n    function getBiggestRate(\\n        address[] memory _wrappers,\\n        uint256[] memory _rates\\n    ) internal pure returns (address, uint) {\\n        uint256 maxIndex = 0;\\n\\n        // starting from 0 in case there is only one rate in array\\n        for (uint256 i=0; i<_rates.length; i++) {\\n            if (_rates[i] > _rates[maxIndex]) {\\n                maxIndex = i;\\n            }\\n        }\\n\\n        return (_wrappers[maxIndex], _rates[maxIndex]);\\n    }\\n\\n    function getDecimals(address _token) internal view returns (uint256) {\\n        if (_token == KYBER_ETH_ADDRESS) return 18;\\n\\n        return ERC20(_token).decimals();\\n    }\\n\\n    function sliceUint(bytes memory bs, uint256 start) internal pure returns (uint256) {\\n        require(bs.length >= start + 32, \\\"slicing out of range\\\");\\n\\n        uint256 x;\\n        assembly {\\n            x := mload(add(bs, add(0x20, start)))\\n        }\\n\\n        return x;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/exchangeV3/DFSPricesV3.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../DS/DSMath.sol\\\";\\nimport \\\"../interfaces/TokenInterface.sol\\\";\\nimport \\\"../interfaces/ExchangeInterfaceV3.sol\\\";\\nimport \\\"../utils/SafeERC20.sol\\\";\\n\\ncontract DFSPrices is DSMath {\\n\\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    enum ActionType { SELL, BUY }\\n\\n\\n    /// @notice Returns the best estimated price from 2 exchanges\\n    /// @param _amount Amount of source tokens you want to exchange\\n    /// @param _srcToken Address of the source token\\n    /// @param _destToken Address of the destination token\\n    /// @param _type Type of action SELL|BUY\\n    /// @param _wrappers Array of wrapper addresses to compare\\n    /// @return (address, uint) The address of the best exchange and the exchange price\\n    function getBestPrice(\\n        uint256 _amount,\\n        address _srcToken,\\n        address _destToken,\\n        ActionType _type,\\n        address[] memory _wrappers,\\n        bytes[] memory _additionalData\\n    ) public returns (address, uint256) {\\n\\n        uint256[] memory rates = new uint256[](_wrappers.length);\\n        for (uint i=0; i<_wrappers.length; i++) {\\n            rates[i] = getExpectedRate(_wrappers[i], _srcToken, _destToken, _amount, _type, _additionalData[i]);\\n        }\\n\\n        return getBiggestRate(_wrappers, rates);\\n    }\\n\\n    /// @notice Return the expected rate from the exchange wrapper\\n    /// @dev In case of Oasis/Uniswap handles the different precision tokens\\n    /// @param _wrapper Address of exchange wrapper\\n    /// @param _srcToken From token\\n    /// @param _destToken To token\\n    /// @param _amount Amount to be exchanged\\n    /// @param _type Type of action SELL|BUY\\n    function getExpectedRate(\\n        address _wrapper,\\n        address _srcToken,\\n        address _destToken,\\n        uint256 _amount,\\n        ActionType _type,\\n        bytes memory _additionalData\\n    ) public returns (uint256) {\\n        bool success;\\n        bytes memory result;\\n\\n        if (_type == ActionType.SELL) {\\n            (success, result) = _wrapper.call(abi.encodeWithSignature(\\n                \\\"getSellRate(address,address,uint256,bytes)\\\",\\n                _srcToken,\\n                _destToken,\\n                _amount,\\n                _additionalData\\n            ));\\n\\n        } else {\\n            (success, result) = _wrapper.call(abi.encodeWithSignature(\\n                \\\"getBuyRate(address,address,uint256,bytes)\\\",\\n                _srcToken,\\n                _destToken,\\n                _amount,\\n                _additionalData\\n            ));\\n        }\\n\\n        if (success) {\\n            return sliceUint(result, 0);\\n        }\\n\\n        return 0;\\n    }\\n\\n    /// @notice Finds the biggest rate between exchanges, needed for sell rate\\n    /// @param _wrappers Array of wrappers to compare\\n    /// @param _rates Array of rates to compare\\n    function getBiggestRate(\\n        address[] memory _wrappers,\\n        uint256[] memory _rates\\n    ) internal pure returns (address, uint) {\\n        uint256 maxIndex = 0;\\n\\n        // starting from 0 in case there is only one rate in array\\n        for (uint256 i=0; i<_rates.length; i++) {\\n            if (_rates[i] > _rates[maxIndex]) {\\n                maxIndex = i;\\n            }\\n        }\\n\\n        return (_wrappers[maxIndex], _rates[maxIndex]);\\n    }\\n\\n    function getDecimals(address _token) internal view returns (uint256) {\\n        if (_token == KYBER_ETH_ADDRESS) return 18;\\n\\n        return ERC20(_token).decimals();\\n    }\\n\\n    function sliceUint(bytes memory bs, uint256 start) internal pure returns (uint256) {\\n        require(bs.length >= start + 32, \\\"slicing out of range\\\");\\n\\n        uint256 x;\\n        assembly {\\n            x := mload(add(bs, add(0x20, start)))\\n        }\\n\\n        return x;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/exchangeV3/offchainWrappersV3/ZeroxWrapper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\nimport \\\"../DFSExchangeHelper.sol\\\";\\nimport \\\"../../interfaces/OffchainWrapperInterface.sol\\\";\\nimport \\\"../../interfaces/TokenInterface.sol\\\";\\n\\ncontract ZeroxWrapper is OffchainWrapperInterface, DFSExchangeHelper, AdminAuth, DSMath {\\n    string public constant ERR_SRC_AMOUNT = \\\"Not enough funds\\\";\\n    string public constant ERR_PROTOCOL_FEE = \\\"Not enough eth for protcol fee\\\";\\n    string public constant ERR_TOKENS_SWAPED_ZERO = \\\"Order success but amount 0\\\";\\n\\n    using SafeERC20 for ERC20;\\n\\n    /// @notice Takes order from 0x and returns bool indicating if it is successful\\n    /// @param _exData Exchange data\\n    /// @param _type Action type (buy or sell)\\n    function takeOrder(\\n        ExchangeData memory _exData,\\n        ActionType _type\\n    ) override public payable returns (bool success, uint256) {\\n        // check that contract have enough balance for exchange and protocol fee\\n        require(getBalance(_exData.srcAddr) >= _exData.srcAmount, ERR_SRC_AMOUNT);\\n        require(getBalance(KYBER_ETH_ADDRESS) >= _exData.offchainData.protocolFee, ERR_PROTOCOL_FEE);\\n\\n        /// @dev 0x always uses max approve in v1, so we approve the exact amount we want to sell\\n        /// @dev safeApprove is modified to always first set approval to 0, then to exact amount\\n        if (_type == ActionType.SELL) {\\n            ERC20(_exData.srcAddr).safeApprove(_exData.offchainData.allowanceTarget, _exData.srcAmount);\\n        } else {\\n            uint srcAmount = wdiv(_exData.destAmount, _exData.offchainData.price) + 1; // + 1 so we round up\\n            ERC20(_exData.srcAddr).safeApprove(_exData.offchainData.allowanceTarget, srcAmount);\\n        }\\n        // we know that it will be eth if dest addr is either weth or eth\\n        address destAddr = _exData.destAddr == KYBER_ETH_ADDRESS ? EXCHANGE_WETH_ADDRESS : _exData.destAddr;\\n\\n        uint256 tokensBefore = getBalance(destAddr);\\n        (success, ) = _exData.offchainData.exchangeAddr.call{value: _exData.offchainData.protocolFee}(_exData.offchainData.callData);\\n        uint256 tokensSwaped = 0;\\n\\n        if (success) {\\n            // get the current balance of the swaped tokens\\n            tokensSwaped = getBalance(destAddr) - tokensBefore;\\n            require(tokensSwaped > 0, ERR_TOKENS_SWAPED_ZERO);\\n        }\\n\\n        // returns all funds from src addr, dest addr and eth funds (protocol fee leftovers)\\n        sendLeftover(_exData.srcAddr, destAddr, msg.sender);\\n\\n        return (success, tokensSwaped);\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external virtual payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/exchangeV3/offchainWrappersV3/ScpWrapper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\nimport \\\"../DFSExchangeHelper.sol\\\";\\nimport \\\"../../interfaces/OffchainWrapperInterface.sol\\\";\\nimport \\\"../../interfaces/TokenInterface.sol\\\";\\n\\ncontract ScpWrapper is OffchainWrapperInterface, DFSExchangeHelper, AdminAuth, DSMath {\\n\\n    string public constant ERR_SRC_AMOUNT = \\\"Not enough funds\\\";\\n    string public constant ERR_PROTOCOL_FEE = \\\"Not enough eth for protcol fee\\\";\\n    string public constant ERR_TOKENS_SWAPED_ZERO = \\\"Order success but amount 0\\\";\\n\\n    using SafeERC20 for ERC20;\\n\\n    /// @notice Takes order from Scp and returns bool indicating if it is successful\\n    /// @param _exData Exchange data\\n    /// @param _type Action type (buy or sell)\\n    function takeOrder(\\n        ExchangeData memory _exData,\\n        ActionType _type\\n    ) override public payable returns (bool success, uint256) {\\n        // check that contract have enough balance for exchange and protocol fee\\n        require(getBalance(_exData.srcAddr) >= _exData.srcAmount, ERR_SRC_AMOUNT);\\n        require(getBalance(KYBER_ETH_ADDRESS) >= _exData.offchainData.protocolFee, ERR_PROTOCOL_FEE);\\n\\n        ERC20(_exData.srcAddr).safeApprove(_exData.offchainData.allowanceTarget, _exData.srcAmount);\\n\\n        // write in the exact amount we are selling/buing in an order\\n        if (_type == ActionType.SELL) {\\n            writeUint256(_exData.offchainData.callData, 36, _exData.srcAmount);\\n        } else {\\n            uint srcAmount = wdiv(_exData.destAmount, _exData.offchainData.price) + 1; // + 1 so we round up\\n            writeUint256(_exData.offchainData.callData, 36, srcAmount);\\n        }\\n\\n        // we know that it will be eth if dest addr is either weth or eth\\n        address destAddr = _exData.destAddr == KYBER_ETH_ADDRESS ? EXCHANGE_WETH_ADDRESS : _exData.destAddr;\\n\\n        uint256 tokensBefore = getBalance(destAddr);\\n        (success, ) = _exData.offchainData.exchangeAddr.call{value: _exData.offchainData.protocolFee}(_exData.offchainData.callData);\\n        uint256 tokensSwaped = 0;\\n\\n\\n        if (success) {\\n            // get the current balance of the swaped tokens\\n            tokensSwaped = getBalance(destAddr) - tokensBefore;\\n            require(tokensSwaped > 0, ERR_TOKENS_SWAPED_ZERO);\\n        }\\n\\n        // returns all funds from src addr, dest addr and eth funds (protocol fee leftovers)\\n        sendLeftover(_exData.srcAddr, destAddr, msg.sender);\\n\\n        return (success, tokensSwaped);\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external virtual payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/aave/AaveHelper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../DS/DSMath.sol\\\";\\nimport \\\"../DS/DSProxy.sol\\\";\\nimport \\\"../utils/Discount.sol\\\";\\nimport \\\"../interfaces/IFeeRecipient.sol\\\";\\nimport \\\"../interfaces/IAToken.sol\\\";\\nimport \\\"../interfaces/ILendingPool.sol\\\";\\nimport \\\"../interfaces/ILendingPoolAddressesProvider.sol\\\";\\nimport \\\"../interfaces/IPriceOracleGetterAave.sol\\\";\\n\\nimport \\\"../utils/SafeERC20.sol\\\";\\nimport \\\"../utils/BotRegistry.sol\\\";\\n\\ncontract AaveHelper is DSMath {\\n\\n    using SafeERC20 for ERC20;\\n\\n    IFeeRecipient public constant feeRecipient = IFeeRecipient(0x39C4a92Dc506300c3Ea4c67ca4CA611102ee6F2A);\\n\\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\\n\\n    uint public constant MANUAL_SERVICE_FEE = 400; // 0.25% Fee\\n    uint public constant AUTOMATIC_SERVICE_FEE = 333; // 0.3% Fee\\n\\n    address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;\\n\\n\\taddress public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant AAVE_LENDING_POOL_ADDRESSES = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\\n    uint public constant NINETY_NINE_PERCENT_WEI = 990000000000000000;\\n    uint16 public constant AAVE_REFERRAL_CODE = 64;\\n\\n    /// @param _collateralAddress underlying token address\\n    /// @param _user users address\\n\\tfunction getMaxCollateral(address _collateralAddress, address _user) public view returns (uint256) {\\n        address lendingPoolAddressDataProvider = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolDataProvider();\\n        address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\\n\\n        uint256 pow10 = 10 ** (18 - _getDecimals(_collateralAddress));\\n\\n        // fetch all needed data\\n        (,uint256 totalCollateralETH, uint256 totalBorrowsETH,,uint256 currentLTV,,,) = ILendingPool(lendingPoolAddressDataProvider).calculateUserGlobalData(_user);\\n        (,uint256 tokenLTV,,) = ILendingPool(lendingPoolCoreAddress).getReserveConfiguration(_collateralAddress);\\n        uint256 collateralPrice = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_collateralAddress);\\n        uint256 userTokenBalance = ILendingPool(lendingPoolCoreAddress).getUserUnderlyingAssetBalance(_collateralAddress, _user);\\n        uint256 userTokenBalanceEth = wmul(userTokenBalance * pow10, collateralPrice);\\n\\n\\t\\t// if borrow is 0, return whole user balance\\n        if (totalBorrowsETH == 0) {\\n        \\treturn userTokenBalance;\\n        }\\n\\n        uint256 maxCollateralEth = div(sub(mul(currentLTV, totalCollateralETH), mul(totalBorrowsETH, 100)), currentLTV);\\n\\t\\t/// @dev final amount can't be higher than users token balance\\n        maxCollateralEth = maxCollateralEth > userTokenBalanceEth ? userTokenBalanceEth : maxCollateralEth;\\n\\n        // might happen due to wmul precision\\n        if (maxCollateralEth >= totalCollateralETH) {\\n        \\treturn wdiv(totalCollateralETH, collateralPrice) / pow10;\\n        }\\n\\n        // get sum of all other reserves multiplied with their liquidation thresholds by reversing formula\\n        uint256 a = sub(wmul(currentLTV, totalCollateralETH), wmul(tokenLTV, userTokenBalanceEth));\\n        // add new collateral amount multiplied by its threshold, and then divide with new total collateral\\n        uint256 newLiquidationThreshold = wdiv(add(a, wmul(sub(userTokenBalanceEth, maxCollateralEth), tokenLTV)), sub(totalCollateralETH, maxCollateralEth));\\n\\n        // if new threshold is lower than first one, calculate new max collateral with newLiquidationThreshold\\n        if (newLiquidationThreshold < currentLTV) {\\n        \\tmaxCollateralEth = div(sub(mul(newLiquidationThreshold, totalCollateralETH), mul(totalBorrowsETH, 100)), newLiquidationThreshold);\\n        \\tmaxCollateralEth = maxCollateralEth > userTokenBalanceEth ? userTokenBalanceEth : maxCollateralEth;\\n        }\\n\\n\\t\\treturn wmul(wdiv(maxCollateralEth, collateralPrice) / pow10, NINETY_NINE_PERCENT_WEI);\\n\\t}\\n\\n\\t/// @param _borrowAddress underlying token address\\n\\t/// @param _user users address\\n\\tfunction getMaxBorrow(address _borrowAddress, address _user) public view returns (uint256) {\\n\\t\\taddress lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\\n\\t\\taddress priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\\n\\n\\t\\t(,,,,uint256 availableBorrowsETH,,,) = ILendingPool(lendingPoolAddress).getUserAccountData(_user);\\n\\n\\t\\tuint256 borrowPrice = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_borrowAddress);\\n\\n\\t\\treturn wmul(wdiv(availableBorrowsETH, borrowPrice) / (10 ** (18 - _getDecimals(_borrowAddress))), NINETY_NINE_PERCENT_WEI);\\n\\t}\\n\\n    function getMaxBoost(address _borrowAddress, address _collateralAddress, address _user) public view returns (uint256) {\\n        address lendingPoolAddressDataProvider = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolDataProvider();\\n        address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\\n\\n        (,uint256 totalCollateralETH, uint256 totalBorrowsETH,,uint256 currentLTV,,,) = ILendingPool(lendingPoolAddressDataProvider).calculateUserGlobalData(_user);\\n        (,uint256 tokenLTV,,) = ILendingPool(lendingPoolCoreAddress).getReserveConfiguration(_collateralAddress);\\n        totalCollateralETH = div(mul(totalCollateralETH, currentLTV), 100);\\n\\n        uint256 availableBorrowsETH = wmul(mul(div(sub(totalCollateralETH, totalBorrowsETH), sub(100, tokenLTV)), 100), NINETY_NINE_PERCENT_WEI);\\n        uint256 borrowPrice = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_borrowAddress);\\n\\n        return wdiv(availableBorrowsETH, borrowPrice) / (10 ** (18 - _getDecimals(_borrowAddress)));\\n    }\\n\\n    /// @notice Calculates the fee amount\\n    /// @param _amount Amount that is converted\\n    /// @param _user Actuall user addr not DSProxy\\n    /// @param _gasCost Ether amount of gas we are spending for tx\\n    /// @param _tokenAddr token addr. of token we are getting for the fee\\n    /// @return feeAmount The amount we took for the fee\\n    function getFee(uint _amount, address _user, uint _gasCost, address _tokenAddr) internal returns (uint feeAmount) {\\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\\n\\n        uint fee = MANUAL_SERVICE_FEE;\\n\\n        if (BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin)) {\\n            fee = AUTOMATIC_SERVICE_FEE;\\n        }\\n\\n        if (Discount(DISCOUNT_ADDR).isCustomFeeSet(_user)) {\\n            fee = Discount(DISCOUNT_ADDR).getCustomServiceFee(_user);\\n        }\\n\\n        feeAmount = (fee == 0) ? 0 : (_amount / fee);\\n\\n        if (_gasCost != 0) {\\n            uint256 price = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokenAddr);\\n\\n            _gasCost = wdiv(_gasCost, price) / (10 ** (18 - _getDecimals(_tokenAddr)));\\n\\n            feeAmount = add(feeAmount, _gasCost);\\n        }\\n\\n        // fee can't go over 20% of the whole amount\\n        if (feeAmount > (_amount / 5)) {\\n            feeAmount = _amount / 5;\\n        }\\n\\n        address walletAddr = feeRecipient.getFeeAddr();\\n\\n        if (_tokenAddr == ETH_ADDR) {\\n            payable(walletAddr).transfer(feeAmount);\\n        } else {\\n            ERC20(_tokenAddr).safeTransfer(walletAddr, feeAmount);\\n        }\\n    }\\n\\n    /// @notice Calculates the gas cost for transaction\\n    /// @param _amount Amount that is converted\\n    /// @param _user Actuall user addr not DSProxy\\n    /// @param _gasCost Ether amount of gas we are spending for tx\\n    /// @param _tokenAddr token addr. of token we are getting for the fee\\n    /// @return gasCost The amount we took for the gas cost\\n    function getGasCost(uint _amount, address _user, uint _gasCost, address _tokenAddr) internal returns (uint gasCost) {\\n\\n        if (_gasCost == 0) return 0;\\n\\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\\n        uint256 price = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokenAddr);\\n\\n        _gasCost = wmul(_gasCost, price);\\n        gasCost = _gasCost;\\n\\n        // fee can't go over 20% of the whole amount\\n        if (gasCost > (_amount / 5)) {\\n            gasCost = _amount / 5;\\n        }\\n\\n        address walletAddr = feeRecipient.getFeeAddr();\\n\\n        if (_tokenAddr == ETH_ADDR) {\\n            payable(walletAddr).transfer(gasCost);\\n        } else {\\n            ERC20(_tokenAddr).safeTransfer(walletAddr, gasCost);\\n        }\\n    }\\n\\n\\n    /// @notice Returns the owner of the DSProxy that called the contract\\n    function getUserAddress() internal view returns (address) {\\n        DSProxy proxy = DSProxy(payable(address(this)));\\n\\n        return proxy.owner();\\n    }\\n\\n    /// @notice Approves token contract to pull underlying tokens from the DSProxy\\n    /// @param _tokenAddr Token we are trying to approve\\n    /// @param _caller Address which will gain the approval\\n    function approveToken(address _tokenAddr, address _caller) internal {\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeApprove(_caller, uint256(-1));\\n        }\\n    }\\n\\n    /// @notice Send specific amount from contract to specific user\\n    /// @param _token Token we are trying to send\\n    /// @param _user User that should receive funds\\n    /// @param _amount Amount that should be sent\\n    function sendContractBalance(address _token, address _user, uint _amount) public {\\n        if (_amount == 0) return;\\n\\n        if (_token == ETH_ADDR) {\\n            payable(_user).transfer(_amount);\\n        } else {\\n            ERC20(_token).safeTransfer(_user, _amount);\\n        }\\n    }\\n\\n    function sendFullContractBalance(address _token, address _user) public {\\n        if (_token == ETH_ADDR) {\\n            sendContractBalance(_token, _user, address(this).balance);\\n        } else {\\n            sendContractBalance(_token, _user, ERC20(_token).balanceOf(address(this)));\\n        }\\n    }\\n\\n    function _getDecimals(address _token) internal view returns (uint256) {\\n        if (_token == ETH_ADDR) return 18;\\n\\n        return ERC20(_token).decimals();\\n    }\\n\\n    function isAutomation() internal view returns(bool) {\\n        return BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/aave/saver/AaveSaverReceiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../savings/dydx/ISoloMargin.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../interfaces/TokenInterface.sol\\\";\\nimport \\\"../../DS/DSProxy.sol\\\";\\nimport \\\"../AaveHelper.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeData.sol\\\";\\n\\n/// @title Import Aave position from account to wallet\\ncontract AaveSaverReceiver is AaveHelper, AdminAuth, DFSExchangeData {\\n\\n    using SafeERC20 for ERC20;\\n\\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address public constant AAVE_SAVER_PROXY = 0x2a3B273695A045EC263970e3C86c23800a0F04FC;\\n    address public constant AAVE_BASIC_PROXY = 0xd042D4E9B4186c545648c7FfFe87125c976D110B;\\n    address public constant AETH_ADDRESS = 0x3a3A65aAb0dd2A17E3F1947bA16138cd37d08c04;\\n\\n    function callFunction(\\n        address sender,\\n        Account.Info memory account,\\n        bytes memory data\\n    ) public {\\n\\n        (\\n            bytes memory exchangeDataBytes,\\n            uint256 gasCost,\\n            bool isRepay,\\n            uint256 ethAmount,\\n            uint256 txValue,\\n            address user,\\n            address proxy\\n        )\\n        = abi.decode(data, (bytes,uint256,bool,uint256,uint256,address,address));\\n\\n        // withdraw eth\\n        TokenInterface(WETH_ADDRESS).withdraw(ethAmount);\\n\\n        address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\\n        \\n        // deposit eth on behalf of proxy\\n        DSProxy(payable(proxy)).execute{value: ethAmount}(AAVE_BASIC_PROXY, abi.encodeWithSignature(\\\"deposit(address,uint256)\\\", ETH_ADDR, ethAmount));\\n        \\n        bytes memory functionData = packFunctionCall(exchangeDataBytes, gasCost, isRepay);\\n        DSProxy(payable(proxy)).execute{value: txValue}(AAVE_SAVER_PROXY, functionData);\\n\\n        // withdraw deposited eth\\n        DSProxy(payable(proxy)).execute(AAVE_BASIC_PROXY, abi.encodeWithSignature(\\\"withdraw(address,address,uint256,bool)\\\", ETH_ADDR, AETH_ADDRESS, ethAmount, false));\\n\\n        // deposit eth, get weth and return to sender\\n        TokenInterface(WETH_ADDRESS).deposit.value(address(this).balance)();\\n        ERC20(WETH_ADDRESS).safeTransfer(proxy, ethAmount+2);\\n    }\\n\\n    function packFunctionCall(bytes memory _exchangeDataBytes, uint256 _gasCost, bool _isRepay) internal returns (bytes memory) {\\n        ExchangeData memory exData = unpackExchangeData(_exchangeDataBytes);\\n\\n        bytes memory functionData;\\n\\n        if (_isRepay) {\\n            functionData = abi.encodeWithSignature(\\\"repay((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256)\\\", exData, _gasCost);\\n        } else {\\n            functionData = abi.encodeWithSignature(\\\"boost((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256)\\\", exData, _gasCost);\\n        }\\n\\n        return functionData;\\n    }\\n\\n    /// @dev if contract receive eth, convert it to WETH\\n    receive() external payable {\\n        // deposit eth and get weth \\n        if (msg.sender == owner) {\\n            TokenInterface(WETH_ADDRESS).deposit.value(address(this).balance)();\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/reflexer/RaiLoanInfo.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../DS/DSMath.sol\\\";\\nimport \\\"../interfaces/reflexer/IGetSafes.sol\\\";\\nimport \\\"../interfaces/reflexer/ISAFEEngine.sol\\\";\\nimport \\\"../interfaces/reflexer/ISAFEManager.sol\\\";\\nimport \\\"../interfaces/reflexer/IOracleRelayer.sol\\\";\\nimport \\\"../interfaces/reflexer/IMedianOracle.sol\\\";\\nimport \\\"../interfaces/reflexer/ITaxCollector.sol\\\";\\n\\ncontract RaiLoanInfo is DSMath {\\n    // mainnet\\n    address public constant GET_SAFES_ADDR = 0xdf4BC9aA98cC8eCd90Ba2BEe73aD4a1a9C8d202B;\\n    address public constant MANAGER_ADDR = 0xEfe0B4cA532769a3AE758fD82E1426a03A94F185;\\n    address public constant SAFE_ENGINE_ADDRESS = 0xCC88a9d330da1133Df3A7bD823B95e52511A6962;\\n    address public constant ORACLE_RELAYER_ADDRESS = 0x4ed9C0dCa0479bC64d8f4EB3007126D5791f7851;\\n    address public constant MEDIAN_ORACLE_ADDRESS = 0x12A5E1c81B10B264A575930aEae80681DDF595fe;\\n    address public constant TAX_COLLECTOR_ADDRESS = 0xcDB05aEda142a1B0D6044C09C64e4226c1a281EB;\\n\\n    // kovan\\n    // address public constant GET_SAFES_ADDR = 0x702dcf4a8C3bBBd243477D5704fc45F2762D3826;\\n    // address public constant MANAGER_ADDR = 0x807C8eCb73d9c8203d2b1369E678098B9370F2EA;\\n    // address public constant SAFE_ENGINE_ADDRESS = 0x7f63fE955fFF8EA474d990f1Fc8979f2C650edbE;\\n    // address public constant ORACLE_RELAYER_ADDRESS = 0xE5Ae4E49bEA485B5E5172EE6b1F99243cB15225c;\\n    // address public constant MEDIAN_ORACLE_ADDRESS = 0x82bEAd00751EFA3286c9Dd17e4Ea2570916B3944;\\n    // address public constant TAX_COLLECTOR_ADDRESS = 0xc1a94C5ad9FCD79b03F79B34d8C0B0C8192fdc16;\\n\\n    struct SafeInfo {\\n        uint256 safeId;\\n        uint256 coll;\\n        uint256 debt;\\n        address safeAddr;\\n        bytes32 collType;\\n    }\\n\\n    struct CollInfo {\\n        uint256 debtCeiling;\\n        uint256 currDebtAmount;\\n        uint256 currRate;\\n        uint256 dust;\\n        uint256 safetyPrice;\\n        uint256 liqPrice;\\n        uint256 assetPrice;\\n        uint256 liqRatio;\\n        uint256 stabilityFee;\\n    }\\n\\n    struct RaiInfo {\\n        uint256 redemptionPrice;\\n        uint256 currRaiPrice;\\n        uint256 redemptionRate;\\n    }\\n\\n    function getCollateralTypeInfo(bytes32 _collType)\\n        public\\n        returns (CollInfo memory collInfo)\\n    {\\n        (\\n            uint256 debtAmount,\\n            uint256 accumulatedRates,\\n            uint256 safetyPrice,\\n            uint256 debtCeiling,\\n            uint256 debtFloor,\\n            uint256 liquidationPrice\\n        ) = ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);\\n\\n        (, uint liqRatio) = IOracleRelayer(ORACLE_RELAYER_ADDRESS).collateralTypes(_collType);\\n\\n        (uint stabilityFee,) = ITaxCollector(TAX_COLLECTOR_ADDRESS).collateralTypes(_collType);\\n\\n\\n        collInfo = CollInfo({\\n            debtCeiling: debtCeiling,\\n            currDebtAmount: debtAmount,\\n            currRate: accumulatedRates,\\n            dust: debtFloor,\\n            safetyPrice: safetyPrice,\\n            liqPrice: liquidationPrice,\\n            assetPrice: getPrice(_collType),\\n            liqRatio: liqRatio,\\n            stabilityFee: stabilityFee\\n        });\\n    }\\n\\n    function getCollAndRaiInfo(bytes32 _collType)\\n        public\\n        returns (CollInfo memory collInfo, RaiInfo memory raiInfo) {\\n            collInfo = getCollateralTypeInfo(_collType);\\n            raiInfo = getRaiInfo();\\n        }\\n\\n    function getPrice(bytes32 _collType) public returns (uint256) {\\n        (, uint256 safetyCRatio) =\\n            IOracleRelayer(ORACLE_RELAYER_ADDRESS).collateralTypes(_collType);\\n        (, , uint256 safetyPrice, , , ) =\\n            ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);\\n\\n        uint256 redemptionPrice = IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionPrice();\\n\\n        return rmul(rmul(safetyPrice, redemptionPrice), safetyCRatio);\\n    }\\n\\n    function getRaiInfo() public returns (RaiInfo memory raiInfo) {\\n        raiInfo = RaiInfo({\\n            redemptionPrice: IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionPrice(),\\n            currRaiPrice: IMedianOracle(MEDIAN_ORACLE_ADDRESS).read(),\\n            redemptionRate: IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionRate()\\n        });\\n    }\\n\\n    function getSafeInfo(uint256 _safeId) public view returns (SafeInfo memory safeInfo) {\\n        address safeAddr = ISAFEManager(MANAGER_ADDR).safes(_safeId);\\n        bytes32 collType = ISAFEManager(MANAGER_ADDR).collateralTypes(_safeId);\\n\\n        (uint256 coll, uint256 debt) = ISAFEEngine(SAFE_ENGINE_ADDRESS).safes(collType, safeAddr);\\n\\n        safeInfo = SafeInfo({\\n            safeId: _safeId,\\n            coll: coll,\\n            debt: debt,\\n            safeAddr: safeAddr,\\n            collType: collType\\n        });\\n    }\\n\\n    function getUserSafes(address _user)\\n        public\\n        view\\n        returns (\\n            uint256[] memory ids,\\n            address[] memory safes,\\n            bytes32[] memory collateralTypes\\n        )\\n    {\\n        return IGetSafes(GET_SAFES_ADDR).getSafesAsc(MANAGER_ADDR, _user);\\n    }\\n\\n    function getUserSafesFullInfo(address _user) public view returns (SafeInfo[] memory safeInfos) {\\n        (uint256[] memory ids, , ) = getUserSafes(_user);\\n\\n        safeInfos = new SafeInfo[](ids.length);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            safeInfos[i] = getSafeInfo(ids[i]);\\n        }\\n    }\\n\\n    function getFullInfo(address _user, bytes32 _collType)\\n        public\\n        returns (\\n            CollInfo memory collInfo,\\n            RaiInfo memory raiInfo,\\n            SafeInfo[] memory safeInfos\\n        )\\n    {\\n        collInfo = getCollateralTypeInfo(_collType);\\n        raiInfo = getRaiInfo();\\n        safeInfos = getUserSafesFullInfo(_user);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/reflexer/IGetSafes.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract IGetSafes {\\n    function getSafesAsc(address manager, address guy) external virtual view returns (uint[] memory ids, address[] memory safes, bytes32[] memory collateralTypes);\\n    function getSafesDesc(address manager, address guy) external virtual view returns (uint[] memory ids, address[] memory safes, bytes32[] memory collateralTypes);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/reflexer/IMedianOracle.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract IMedianOracle {\\n    function read() external virtual view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/DS/DSProxyFactoryInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./DSProxy.sol\\\";\\n\\nabstract contract DSProxyFactoryInterface {\\n    function build(address owner) public virtual returns (DSProxy proxy);\\n}\\n\"\r\n    },\r\n    \"contracts/aaveV2/saver/optimized/AaveSaverReceiverOV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../../utils/SafeERC20.sol\\\";\\nimport \\\"../../../interfaces/TokenInterface.sol\\\";\\nimport \\\"../../../DS/DSProxy.sol\\\";\\nimport \\\"../../AaveHelperV2.sol\\\";\\nimport \\\"../../../auth/AdminAuth.sol\\\";\\nimport \\\"../../../exchangeV3/DFSExchangeCore.sol\\\";\\nimport \\\"../../../loggers/DefisaverLogger.sol\\\";\\n\\n/// @title Import Aave position from account to wallet\\ncontract AaveSaverReceiverOV2 is AaveHelperV2, AdminAuth, DFSExchangeCore {\\n    using SafeERC20 for ERC20;\\n\\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\\n\\n    address public constant AAVE_BASIC_PROXY = 0x234e8219f25F6AF4bE90d40C79DEdE31B1f21d4f;\\n\\n    function boost(\\n        ExchangeData memory _exchangeData,\\n        address _market,\\n        uint256 _gasCost,\\n        address _proxy\\n    ) internal {\\n        (, uint256 swappedAmount) = _sell(_exchangeData);\\n\\n        address user = DSAuth(_proxy).owner();\\n        swappedAmount -= getGasCost(\\n            ILendingPoolAddressesProviderV2(_market).getPriceOracle(),\\n            swappedAmount,\\n            user,\\n            _gasCost,\\n            _exchangeData.destAddr\\n        );\\n\\n        // if its eth we need to send it to the basic proxy, if not, we need to approve users proxy to pull tokens\\n        uint256 msgValue = 0;\\n        address token = _exchangeData.destAddr;\\n        // sell always return eth, but deposit differentiate eth vs weth, so we change weth address to eth when we are depoisting\\n        if (_exchangeData.destAddr == ETH_ADDR || _exchangeData.destAddr == WETH_ADDRESS) {\\n            msgValue = swappedAmount;\\n            token = ETH_ADDR;\\n        } else {\\n            ERC20(_exchangeData.destAddr).safeApprove(_proxy, swappedAmount);\\n        }\\n        // deposit collateral on behalf of user\\n        DSProxy(payable(_proxy)).execute{value: msgValue}(\\n            AAVE_BASIC_PROXY,\\n            abi.encodeWithSignature(\\n                \\\"deposit(address,address,uint256)\\\",\\n                _market,\\n                token,\\n                swappedAmount\\n            )\\n        );\\n\\n        logEvent(\\\"AaveV2Boost\\\", _exchangeData, swappedAmount);\\n    }\\n\\n    function repay(\\n        ExchangeData memory _exchangeData,\\n        address _market,\\n        uint256 _gasCost,\\n        address _proxy,\\n        uint256 _rateMode,\\n        uint256 _aaveFlashlLoanFee\\n    ) internal {\\n        // we will withdraw exactly the srcAmount, as fee we keep before selling\\n        uint256 valueToWithdraw = _exchangeData.srcAmount;\\n        // take out the fee wee need to pay and sell the rest\\n        _exchangeData.srcAmount = _exchangeData.srcAmount - _aaveFlashlLoanFee;\\n\\n        (, uint256 swappedAmount) = _sell(_exchangeData);\\n\\n        address user = DSAuth(_proxy).owner();\\n        swappedAmount -= getGasCost(\\n            ILendingPoolAddressesProviderV2(_market).getPriceOracle(),\\n            swappedAmount,\\n            user,\\n            _gasCost,\\n            _exchangeData.destAddr\\n        );\\n\\n        // set protocol fee left to eth balance of this address\\n        // but if destAddr is eth or weth, this also includes that value so we need to substract it\\n        // doing this after taking gas cost so it doesn't take it into account\\n        uint256 protocolFeeLeft = address(this).balance;\\n\\n        // if its eth we need to send it to the basic proxy, if not, we need to approve basic proxy to pull tokens\\n        uint256 msgValue = 0;\\n        if (_exchangeData.destAddr == ETH_ADDR || _exchangeData.destAddr == WETH_ADDRESS) {\\n            protocolFeeLeft -= swappedAmount;\\n            msgValue = swappedAmount;\\n        } else {\\n            ERC20(_exchangeData.destAddr).safeApprove(_proxy, swappedAmount);\\n        }\\n\\n        // first payback the loan with swapped amount\\n        DSProxy(payable(_proxy)).execute{value: msgValue}(\\n            AAVE_BASIC_PROXY,\\n            abi.encodeWithSignature(\\n                \\\"payback(address,address,uint256,uint256)\\\",\\n                _market,\\n                _exchangeData.destAddr,\\n                swappedAmount,\\n                _rateMode\\n            )\\n        );\\n\\n        // if some tokens left after payback (full repay) we need to return it back to the proxy owner\\n        require(user != address(0)); // be sure that we fetched the user correctly\\n        if (_exchangeData.destAddr == ETH_ADDR || _exchangeData.destAddr == WETH_ADDRESS) {\\n            // keep protocol fee for tx.origin, but the rest of the balance return to the user\\n            payable(user).transfer(address(this).balance - protocolFeeLeft);\\n        } else {\\n            // in case its a token, just return whole value back to the user, as protocol fee is always in eth\\n            uint256 amount = ERC20(_exchangeData.destAddr).balanceOf(address(this));\\n            ERC20(_exchangeData.destAddr).safeTransfer(user, amount);\\n        }\\n\\n        // pull the amount we flash loaned in collateral to be able to payback the debt\\n        DSProxy(payable(_proxy)).execute(\\n            AAVE_BASIC_PROXY,\\n            abi.encodeWithSignature(\\n                \\\"withdraw(address,address,uint256)\\\",\\n                _market,\\n                _exchangeData.srcAddr,\\n                valueToWithdraw\\n            )\\n        );\\n\\n        logEvent(\\\"AaveV2Repay\\\", _exchangeData, swappedAmount);\\n    }\\n\\n    function executeOperation(\\n        address[] calldata,\\n        uint256[] calldata amounts,\\n        uint256[] calldata premiums,\\n        address initiator,\\n        bytes calldata params\\n    ) public returns (bool) {\\n        (\\n            bytes memory exchangeDataBytes,\\n            address market,\\n            uint256 gasCost,\\n            uint256 rateMode,\\n            bool isRepay,\\n            address proxy\\n        ) = abi.decode(params, (bytes, address, uint256, uint256, bool, address));\\n\\n        address lendingPool = ILendingPoolAddressesProviderV2(market).getLendingPool();\\n\\n        require(msg.sender == lendingPool, \\\"Callbacks only allowed from Aave\\\");\\n        require(initiator == proxy, \\\"initiator isn't proxy\\\");\\n\\n        ExchangeData memory exData = unpackExchangeData(exchangeDataBytes);\\n        exData.user = DSAuth(proxy).owner();\\n        exData.dfsFeeDivider = MANUAL_SERVICE_FEE;\\n        if (BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin)) {\\n            exData.dfsFeeDivider = AUTOMATIC_SERVICE_FEE;\\n        }\\n\\n        // this is to avoid stack too deep\\n        uint256 fee = premiums[0];\\n        uint256 totalValueToReturn = exData.srcAmount + fee;\\n\\n        // if its repay, we are using regular flash loan and payback the premiums\\n        if (isRepay) {\\n            repay(exData, market, gasCost, proxy, rateMode, fee);\\n\\n            address token = exData.srcAddr;\\n            if (token == ETH_ADDR || token == WETH_ADDRESS) {\\n                // deposit eth, get weth and return to sender\\n                TokenInterface(WETH_ADDRESS).deposit.value(totalValueToReturn)();\\n                token = WETH_ADDRESS;\\n            }\\n\\n            ERC20(token).safeApprove(lendingPool, totalValueToReturn);\\n        } else {\\n            boost(exData, market, gasCost, proxy);\\n        }\\n\\n        tx.origin.transfer(address(this).balance);\\n\\n        return true;\\n    }\\n\\n    function logEvent(string memory _name, ExchangeData memory _exchangeData, uint _swappedAmount) internal {\\n        DefisaverLogger(DEFISAVER_LOGGER).Log(\\n            address(this),\\n            msg.sender,\\n            _name,\\n            abi.encode(_exchangeData.srcAddr, _exchangeData.destAddr, _exchangeData.srcAmount, _swappedAmount)\\n        );\\n    }\\n\\n    /// @dev allow contract to receive eth from sell\\n    receive() external payable override {}\\n}\\n\"\r\n    },\r\n    \"contracts/aaveV2/import/AaveImportV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../savings/dydx/ISoloMargin.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../interfaces/TokenInterface.sol\\\";\\nimport \\\"../../DS/DSProxy.sol\\\";\\nimport \\\"../AaveHelperV2.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\n// weth->eth\\n// deposit eth for users proxy\\n// borrow users token from proxy\\n// repay on behalf of user\\n// pull user supply\\n// take eth amount from supply (if needed more, borrow it?)\\n// return eth to sender\\n\\n/// @title Import Aave position from account to wallet\\ncontract AaveImportV2 is AaveHelperV2, AdminAuth {\\n\\n    using SafeERC20 for ERC20;\\n\\n    address public constant BASIC_PROXY = 0xc17c8eB12Ba24D62E69fd57cbd504EEf418867f9;\\n    address public constant PULL_TOKENS_PROXY = 0x45431b79F783e0BF0fe7eF32D06A3e061780bfc4;\\n\\n    function callFunction(\\n        address,\\n        Account.Info memory,\\n        bytes memory data\\n    ) public {\\n\\n        (\\n            address market,\\n            address collateralToken,\\n            address borrowToken,\\n            uint256 ethAmount,\\n            address proxy\\n        )\\n        = abi.decode(data, (address,address,address,uint256,address));\\n\\n        address user = DSProxy(payable(proxy)).owner();\\n\\n        // withdraw eth\\n        TokenInterface(WETH_ADDRESS).withdraw(ethAmount);\\n\\n        IAaveProtocolDataProviderV2 dataProvider = getDataProvider(market);\\n\\n        uint256 globalBorrowAmountStable = 0;\\n        uint256 globalBorrowAmountVariable = 0;\\n\\n        { // avoid stack too deep\\n            // deposit eth on behalf of proxy\\n            DSProxy(payable(proxy)).execute{value: ethAmount}(BASIC_PROXY, abi.encodeWithSignature(\\\"deposit(address,address,uint256)\\\", market, ETH_ADDR, ethAmount));\\n            // borrow needed amount to repay users borrow\\n            (, uint256 borrowsStable, uint256 borrowsVariable,,,,,,) = dataProvider.getUserReserveData(borrowToken, user);\\n\\n            if (borrowsStable > 0) {\\n                DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\\\"borrow(address,address,uint256,uint256)\\\", market, borrowToken, borrowsStable, STABLE_ID));\\n                globalBorrowAmountStable = borrowsStable;\\n            }\\n\\n            if (borrowsVariable > 0) {\\n                DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\\\"borrow(address,address,uint256,uint256)\\\", market, borrowToken, borrowsVariable, VARIABLE_ID));\\n                globalBorrowAmountVariable = borrowsVariable;\\n            }\\n        }\\n\\n        if (globalBorrowAmountVariable > 0) {\\n            paybackOnBehalf(market, proxy, globalBorrowAmountVariable, borrowToken, user, VARIABLE_ID);\\n        }\\n\\n        if (globalBorrowAmountStable > 0) {\\n            paybackOnBehalf(market, proxy, globalBorrowAmountStable, borrowToken, user, STABLE_ID);\\n        }\\n\\n        (address aToken,,) = dataProvider.getReserveTokensAddresses(collateralToken);\\n\\n        // pull coll tokens\\n        DSProxy(payable(proxy)).execute(PULL_TOKENS_PROXY, abi.encodeWithSignature(\\\"pullTokens(address,uint256)\\\", aToken, ERC20(aToken).balanceOf(user)));\\n\\n        // enable as collateral\\n        DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\\\"setUserUseReserveAsCollateralIfNeeded(address,address)\\\", market, collateralToken));\\n\\n        // withdraw deposited eth\\n        DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\\\"withdraw(address,address,uint256)\\\", market, ETH_ADDR, ethAmount));\\n\\n        // deposit eth, get weth and return to sender\\n        TokenInterface(WETH_ADDRESS).deposit{value: (address(this).balance)}();\\n        ERC20(WETH_ADDRESS).safeTransfer(proxy, ethAmount+2);\\n    }\\n\\n    function paybackOnBehalf(address _market, address _proxy, uint _amount, address _token, address _onBehalf, uint _rateMode) internal {\\n        // payback on behalf of user\\n        if (_token != ETH_ADDR) {\\n            ERC20(_token).safeApprove(_proxy, _amount);\\n            DSProxy(payable(_proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\\\"paybackOnBehalf(address,address,uint256,uint256,address)\\\", _market, _token, _amount, _rateMode, _onBehalf));\\n        } else {\\n            DSProxy(payable(_proxy)).execute{value: _amount}(BASIC_PROXY, abi.encodeWithSignature(\\\"paybackOnBehalf(address,address,uint256,uint256,address)\\\", _market, _token, _amount, _rateMode, _onBehalf));\\n        }\\n    }\\n\\n    /// @dev if contract receive eth, convert it to WETH\\n    receive() external payable {\\n        // deposit eth and get weth\\n        if (msg.sender == owner) {\\n            TokenInterface(WETH_ADDRESS).deposit{value: (address(this).balance)}();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/aave/import/AaveImport.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../savings/dydx/ISoloMargin.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../interfaces/TokenInterface.sol\\\";\\nimport \\\"../../DS/DSProxy.sol\\\";\\nimport \\\"../AaveHelper.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\n// weth->eth\\n// deposit eth for users proxy\\n// borrow users token from proxy\\n// repay on behalf of user\\n// pull user supply\\n// take eth amount from supply (if needed more, borrow it?)\\n// return eth to sender\\n\\n/// @title Import Aave position from account to wallet\\ncontract AaveImport is AaveHelper, AdminAuth {\\n\\n    using SafeERC20 for ERC20;\\n\\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address public constant BASIC_PROXY = 0xF499FB2feb3351aEA373723a6A0e8F6BE6fBF616;\\n    address public constant AETH_ADDRESS = 0x3a3A65aAb0dd2A17E3F1947bA16138cd37d08c04;\\n\\n    address public constant PULL_TOKENS_PROXY = 0x45431b79F783e0BF0fe7eF32D06A3e061780bfc4;\\n\\n    function callFunction(\\n        address,\\n        Account.Info memory,\\n        bytes memory data\\n    ) public {\\n\\n        (\\n            address collateralToken,\\n            address borrowToken,\\n            uint256 ethAmount,\\n            address proxy\\n        )\\n        = abi.decode(data, (address,address,uint256,address));\\n\\n        address user = DSProxy(payable(proxy)).owner();\\n\\n        // withdraw eth\\n        TokenInterface(WETH_ADDRESS).withdraw(ethAmount);\\n\\n        address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\\n        address aCollateralToken = ILendingPool(lendingPoolCoreAddress).getReserveATokenAddress(collateralToken);\\n        address aBorrowToken = ILendingPool(lendingPoolCoreAddress).getReserveATokenAddress(borrowToken);\\n        uint256 globalBorrowAmount = 0;\\n\\n        { // avoid stack too deep\\n            // deposit eth on behalf of proxy\\n            DSProxy(payable(proxy)).execute{value: ethAmount}(BASIC_PROXY, abi.encodeWithSignature(\\\"deposit(address,uint256)\\\", ETH_ADDR, ethAmount));\\n            // borrow needed amount to repay users borrow\\n            (,uint256 borrowAmount,,uint256 borrowRateMode,,,uint256 originationFee,,,) = ILendingPool(lendingPool).getUserReserveData(borrowToken, user);\\n            borrowAmount += originationFee;\\n            DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\\\"borrow(address,uint256,uint256)\\\", borrowToken, borrowAmount, borrowRateMode));\\n            globalBorrowAmount = borrowAmount;\\n        }\\n\\n        // payback on behalf of user\\n        if (borrowToken != ETH_ADDR) {\\n            ERC20(borrowToken).safeApprove(proxy, globalBorrowAmount);\\n            DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\\\"paybackOnBehalf(address,address,uint256,bool,address)\\\", borrowToken, aBorrowToken, 0, true, user));\\n        } else {\\n            DSProxy(payable(proxy)).execute{value: globalBorrowAmount}(BASIC_PROXY, abi.encodeWithSignature(\\\"paybackOnBehalf(address,address,uint256,bool,address)\\\", borrowToken, aBorrowToken, 0, true, user));\\n        }\\n\\n         // pull coll tokens\\n        DSProxy(payable(proxy)).execute(PULL_TOKENS_PROXY, abi.encodeWithSignature(\\\"pullTokens(address,uint256)\\\", aCollateralToken, ERC20(aCollateralToken).balanceOf(user)));\\n\\n\\n        // enable as collateral\\n        DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\\\"setUserUseReserveAsCollateralIfNeeded(address)\\\", collateralToken));\\n\\n        // withdraw deposited eth\\n        DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\\\"withdraw(address,address,uint256,bool)\\\", ETH_ADDR, AETH_ADDRESS, ethAmount, false));\\n\\n\\n        // deposit eth, get weth and return to sender\\n        TokenInterface(WETH_ADDRESS).deposit{value: (address(this).balance)}();\\n        ERC20(WETH_ADDRESS).safeTransfer(proxy, ethAmount+2);\\n    }\\n\\n    /// @dev if contract receive eth, convert it to WETH\\n    receive() external payable {\\n        // deposit eth and get weth\\n        if (msg.sender == owner) {\\n            TokenInterface(WETH_ADDRESS).deposit{value: (address(this).balance)}();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/aave/saver/AaveSaverProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../AaveHelper.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeCore.sol\\\";\\nimport \\\"../../interfaces/IAToken.sol\\\";\\nimport \\\"../../interfaces/ILendingPool.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../utils/GasBurner.sol\\\";\\n\\ncontract AaveSaverProxy is GasBurner, DFSExchangeCore, AaveHelper {\\n\\n\\taddress public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\\n\\n    uint public constant VARIABLE_RATE = 2;\\n\\n\\tfunction repay(ExchangeData memory _data, uint _gasCost) public payable burnGas(20) {\\n\\n\\t\\taddress lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\\n\\t\\taddress lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\\n\\t\\taddress payable user = payable(getUserAddress());\\n\\n\\t\\t// redeem collateral\\n\\t\\taddress aTokenCollateral = ILendingPool(lendingPoolCore).getReserveATokenAddress(_data.srcAddr);\\n\\t\\t// uint256 maxCollateral = IAToken(aTokenCollateral).balanceOf(address(this));\\n\\t\\t// don't swap more than maxCollateral\\n\\t\\t// _data.srcAmount = _data.srcAmount > maxCollateral ? maxCollateral : _data.srcAmount;\\n\\t\\tIAToken(aTokenCollateral).redeem(_data.srcAmount);\\n\\n\\t\\tuint256 destAmount = _data.srcAmount;\\n\\t\\tif (_data.srcAddr != _data.destAddr) {\\n            _data.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\\n            _data.user = user;\\n\\t\\t\\t// swap\\n\\t\\t\\t(, destAmount) = _sell(_data);\\n\\t\\t\\tdestAmount -= getGasCost(destAmount, user, _gasCost, _data.destAddr);\\n\\t\\t} else {\\n\\t\\t\\tdestAmount -= getGasCost(destAmount, user, _gasCost, _data.destAddr);\\n\\t\\t}\\n\\n\\t\\t// payback\\n\\t\\tif (_data.destAddr == ETH_ADDR) {\\n\\t\\t\\tILendingPool(lendingPool).repay{value: destAmount}(_data.destAddr, destAmount, payable(address(this)));\\n\\t\\t} else {\\n\\t\\t\\tapproveToken(_data.destAddr, lendingPoolCore);\\n\\t\\t\\tILendingPool(lendingPool).repay(_data.destAddr, destAmount, payable(address(this)));\\n\\t\\t}\\n\\n\\t\\t// first return 0x fee to msg.sender as it is the address that actually sent 0x fee\\n\\t\\tsendContractBalance(ETH_ADDR, tx.origin, min(address(this).balance, msg.value));\\n\\t\\t// send all leftovers from dest addr to proxy owner\\n\\t\\tsendFullContractBalance(_data.destAddr, user);\\n\\n\\t\\tDefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \\\"AaveRepay\\\", abi.encode(_data.srcAddr, _data.destAddr, _data.srcAmount, destAmount));\\n\\t}\\n\\n\\tfunction boost(ExchangeData memory _data, uint _gasCost) public payable burnGas(20) {\\n\\t\\taddress lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\\n\\t\\taddress lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\\n\\t\\t(,,,uint256 borrowRateMode,,,,,,bool collateralEnabled) = ILendingPool(lendingPool).getUserReserveData(_data.destAddr, address(this));\\n\\t\\taddress payable user = payable(getUserAddress());\\n\\n\\t\\t// skipping this check as its too expensive\\n\\t\\t// uint256 maxBorrow = getMaxBoost(_data.srcAddr, _data.destAddr, address(this));\\n\\t\\t// _data.srcAmount = _data.srcAmount > maxBorrow ? maxBorrow : _data.srcAmount;\\n\\n\\t\\t// borrow amount\\n\\t\\tILendingPool(lendingPool).borrow(_data.srcAddr, _data.srcAmount, borrowRateMode == 0 ? VARIABLE_RATE : borrowRateMode, AAVE_REFERRAL_CODE);\\n\\n\\t\\tuint256 destAmount;\\n\\t\\tif (_data.destAddr != _data.srcAddr) {\\n            _data.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\\n            _data.user = user;\\n\\n\\t\\t\\t// swap\\n\\t\\t\\t(, destAmount) = _sell(_data);\\n            destAmount -= getGasCost(_data.destAmount, user, _gasCost, _data.destAddr);\\n\\n\\t\\t} else {\\n\\t\\t\\tdestAmount = _data.srcAmount;\\n            destAmount -= getGasCost(_data.destAmount, user, _gasCost, _data.destAddr);\\n\\n\\t\\t}\\n\\n\\t\\tif (_data.destAddr == ETH_ADDR) {\\n\\t\\t\\tILendingPool(lendingPool).deposit{value: destAmount}(_data.destAddr, destAmount, AAVE_REFERRAL_CODE);\\n\\t\\t} else {\\n\\t\\t\\tapproveToken(_data.destAddr, lendingPoolCore);\\n\\t\\t\\tILendingPool(lendingPool).deposit(_data.destAddr, destAmount, AAVE_REFERRAL_CODE);\\n\\t\\t}\\n\\n\\t\\tif (!collateralEnabled) {\\n            ILendingPool(lendingPool).setUserUseReserveAsCollateral(_data.destAddr, true);\\n        }\\n\\n\\t\\t// returning to msg.sender as it is the address that actually sent 0x fee\\n\\t\\tsendContractBalance(ETH_ADDR, tx.origin, min(address(this).balance, msg.value));\\n\\t\\t// send all leftovers from dest addr to proxy owner\\n\\t\\tsendFullContractBalance(_data.destAddr, user);\\n\\n\\t\\tDefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \\\"AaveBoost\\\", abi.encode(_data.srcAddr, _data.destAddr, _data.srcAmount, destAmount));\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/aaveV2/saver/AaveSaverProxyV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../AaveHelperV2.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeCore.sol\\\";\\nimport \\\"../../interfaces/IAToken.sol\\\";\\nimport \\\"../../interfaces/TokenInterface.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../utils/GasBurner.sol\\\";\\n\\ncontract AaveSaverProxyV2 is DFSExchangeCore, AaveHelperV2, GasBurner {\\n\\n\\taddress public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\\n\\n\\tfunction repay(address _market, ExchangeData memory _data, uint _rateMode, uint _gasCost) public payable burnGas(20) {\\n\\t\\taddress lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\\n\\t\\tIAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\\n\\t\\taddress payable user = payable(getUserAddress());\\n\\n\\t\\tILendingPoolV2(lendingPool).withdraw(_data.srcAddr, _data.srcAmount, address(this));\\n\\n\\t\\tuint256 destAmount = _data.srcAmount;\\n\\t\\tif (_data.srcAddr != _data.destAddr) {\\n\\t\\t\\t_data.user = user;\\n\\t\\t\\t\\n\\t\\t\\t_data.dfsFeeDivider = MANUAL_SERVICE_FEE;\\n\\t\\t\\tif (BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin)) {\\n            \\t_data.dfsFeeDivider = AUTOMATIC_SERVICE_FEE;\\n        \\t}\\n\\t\\t\\t\\n\\t\\t\\t// swap\\n\\t\\t\\t(, destAmount) = _sell(_data);\\n\\t\\t}\\n\\n\\t\\t// take gas cost at the end\\n\\t\\tdestAmount -= getGasCost(ILendingPoolAddressesProviderV2(_market).getPriceOracle(), destAmount, user, _gasCost, _data.destAddr);\\n\\n\\t\\t// payback\\n\\t\\tif (_data.destAddr == WETH_ADDRESS) {\\n\\t\\t\\tTokenInterface(WETH_ADDRESS).deposit.value(destAmount)();\\n\\t\\t}\\n\\n\\t\\tapproveToken(_data.destAddr, lendingPool);\\n\\n\\t\\t// if destAmount higher than borrow repay whole debt\\n\\t\\tuint borrow;\\n\\t\\tif (_rateMode == STABLE_ID) {\\n\\t\\t\\t(,borrow,,,,,,,) = dataProvider.getUserReserveData(_data.destAddr, address(this));\\t\\n\\t\\t} else {\\n\\t\\t\\t(,,borrow,,,,,,) = dataProvider.getUserReserveData(_data.destAddr, address(this));\\n\\t\\t}\\n\\t\\tILendingPoolV2(lendingPool).repay(_data.destAddr, destAmount > borrow ? borrow : destAmount, _rateMode, payable(address(this)));\\n\\n\\t\\t// first return 0x fee to tx.origin as it is the address that actually sent 0x fee\\n\\t\\tsendContractBalance(ETH_ADDR, tx.origin, min(address(this).balance, msg.value));\\n\\t\\t// send all leftovers from dest addr to proxy owner\\n\\t\\tsendFullContractBalance(_data.destAddr, user);\\n\\n\\t\\tDefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \\\"AaveV2Repay\\\", abi.encode(_data.srcAddr, _data.destAddr, _data.srcAmount, destAmount));\\n\\t}\\n\\n\\tfunction boost(address _market, ExchangeData memory _data, uint _rateMode, uint _gasCost) public payable burnGas(20) {\\n\\t\\taddress lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\\n\\t\\tIAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\\n\\t\\taddress payable user = payable(getUserAddress());\\n\\n\\t\\t// borrow amount\\n\\t\\tILendingPoolV2(lendingPool).borrow(_data.srcAddr, _data.srcAmount, _rateMode, AAVE_REFERRAL_CODE, address(this));\\n\\n\\t\\t// take gas cost at the beginning\\n\\t\\t_data.srcAmount -= getGasCost(ILendingPoolAddressesProviderV2(_market).getPriceOracle(), _data.srcAmount, user, _gasCost, _data.srcAddr);\\n\\n\\t\\tuint256 destAmount;\\n\\t\\tif (_data.destAddr != _data.srcAddr) {\\n\\t\\t\\t_data.user = user;\\n\\t\\t\\t\\n\\t\\t\\t_data.dfsFeeDivider = MANUAL_SERVICE_FEE;\\n\\t\\t\\tif (BotRegistry(BOT_REGISTRY_ADDRESS).botList(tx.origin)) {\\n            \\t_data.dfsFeeDivider = AUTOMATIC_SERVICE_FEE;\\n        \\t}\\n        \\t\\n\\t\\t\\t(, destAmount) = _sell(_data);\\n\\t\\t} else {\\n\\t\\t\\tdestAmount = _data.srcAmount;\\n\\t\\t}\\n\\n\\t\\tif (_data.destAddr == WETH_ADDRESS) {\\n\\t\\t\\tTokenInterface(WETH_ADDRESS).deposit.value(destAmount)();\\n\\t\\t}\\n\\n\\t\\tapproveToken(_data.destAddr, lendingPool);\\n\\t\\tILendingPoolV2(lendingPool).deposit(_data.destAddr, destAmount, address(this), AAVE_REFERRAL_CODE);\\n\\n\\n\\t\\t(,,,,,,,,bool collateralEnabled) = dataProvider.getUserReserveData(_data.destAddr, address(this));\\n\\t\\tif (!collateralEnabled) {\\n            ILendingPoolV2(lendingPool).setUserUseReserveAsCollateral(_data.destAddr, true);\\n        }\\n\\n\\t\\t// returning to msg.sender as it is the address that actually sent 0x fee\\n\\t\\tsendContractBalance(ETH_ADDR, tx.origin, min(address(this).balance, msg.value));\\n\\t\\t// send all leftovers from dest addr to proxy owner\\n\\t\\tsendFullContractBalance(_data.destAddr, user);\\n\\n\\t\\tDefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \\\"AaveV2Boost\\\", abi.encode(_data.srcAddr, _data.destAddr, _data.srcAmount, destAmount));\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/aaveV2/AaveBasicProxyV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../utils/GasBurner.sol\\\";\\nimport \\\"../interfaces/TokenInterface.sol\\\";\\nimport \\\"../interfaces/IAToken.sol\\\";\\nimport \\\"../interfaces/ILendingPoolV2.sol\\\";\\nimport \\\"./AaveHelperV2.sol\\\";\\n\\nimport \\\"../utils/SafeERC20.sol\\\";\\n\\n/// @title Basic compound interactions through the DSProxy\\ncontract AaveBasicProxyV2 is GasBurner, AaveHelperV2 {\\n\\n    using SafeERC20 for ERC20;\\n\\n    /// @notice User deposits tokens to the Aave protocol\\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\\n    /// @param _market address provider for specific market\\n    /// @param _tokenAddr The address of the token to be deposited\\n    /// @param _amount Amount of tokens to be deposited\\n    function deposit(address _market, address _tokenAddr, uint256 _amount) public burnGas(5) payable {\\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\\n\\n        if (_tokenAddr == ETH_ADDR) {\\n            require(msg.value == _amount);\\n            TokenInterface(WETH_ADDRESS).deposit{value: _amount}();\\n            _tokenAddr = WETH_ADDRESS;\\n        } else {\\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\\n        }\\n\\n        approveToken(_tokenAddr, lendingPool);\\n        ILendingPoolV2(lendingPool).deposit(_tokenAddr, _amount, address(this), AAVE_REFERRAL_CODE);\\n\\n        setUserUseReserveAsCollateralIfNeeded(_market, _tokenAddr);\\n    }\\n\\n    /// @notice User withdraws tokens from the Aave protocol\\n    /// @param _market address provider for specific market\\n    /// @param _tokenAddr The address of the token to be withdrawn\\n    /// @param _amount Amount of tokens to be withdrawn -> send -1 for whole amount\\n    function withdraw(address _market, address _tokenAddr, uint256 _amount) public burnGas(8) {\\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\\n        _tokenAddr = changeToWeth(_tokenAddr);\\n\\n        if (_tokenAddr == WETH_ADDRESS) {\\n            // if weth, pull to proxy and return ETH to user\\n            ILendingPoolV2(lendingPool).withdraw(_tokenAddr, _amount, address(this));\\n            // needs to use balance of in case that amount is -1 for whole debt\\n            TokenInterface(WETH_ADDRESS).withdraw(TokenInterface(WETH_ADDRESS).balanceOf(address(this)));\\n            msg.sender.transfer(address(this).balance);\\n        } else {\\n            // if not eth send directly to user\\n            ILendingPoolV2(lendingPool).withdraw(_tokenAddr, _amount, msg.sender);\\n        }\\n    }\\n\\n    /// @notice User borrows tokens to the Aave protocol\\n    /// @param _market address provider for specific market\\n    /// @param _tokenAddr The address of the token to be borrowed\\n    /// @param _amount Amount of tokens to be borrowed\\n    /// @param _type Send 1 for stable rate and 2 for variable\\n    function borrow(address _market, address _tokenAddr, uint256 _amount, uint256 _type) public burnGas(8) {\\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\\n        _tokenAddr = changeToWeth(_tokenAddr);\\n\\n        ILendingPoolV2(lendingPool).borrow(_tokenAddr, _amount, _type, AAVE_REFERRAL_CODE, address(this));\\n\\n        if (_tokenAddr == WETH_ADDRESS) {\\n            // we do this so the user gets eth instead of weth\\n            TokenInterface(WETH_ADDRESS).withdraw(_amount);\\n            _tokenAddr = ETH_ADDR;\\n        }\\n\\n        withdrawTokens(_tokenAddr);\\n    }\\n\\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\\n    /// @notice User paybacks tokens to the Aave protocol\\n    /// @param _market address provider for specific market\\n    /// @param _tokenAddr The address of the token to be paybacked\\n    /// @param _amount Amount of tokens to be payed back\\n    function payback(address _market, address _tokenAddr, uint256 _amount, uint256 _rateMode) public burnGas(3) payable {\\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\\n        _tokenAddr = changeToWeth(_tokenAddr);\\n\\n        if (_tokenAddr == WETH_ADDRESS) {\\n            TokenInterface(WETH_ADDRESS).deposit{value: msg.value}();\\n        } else {\\n            uint amountToPull = min(_amount, ERC20(_tokenAddr).balanceOf(msg.sender));\\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), amountToPull);\\n        }\\n\\n        approveToken(_tokenAddr, lendingPool);\\n        ILendingPoolV2(lendingPool).repay(_tokenAddr, _amount, _rateMode, payable(address(this)));\\n\\n        if (_tokenAddr == WETH_ADDRESS) {\\n            // Pull if we have any eth leftover\\n            TokenInterface(WETH_ADDRESS).withdraw(ERC20(WETH_ADDRESS).balanceOf(address(this)));\\n            _tokenAddr = ETH_ADDR;\\n        }\\n\\n        withdrawTokens(_tokenAddr);\\n    }\\n\\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\\n    /// @notice User paybacks tokens to the Aave protocol\\n    /// @param _market address provider for specific market\\n    /// @param _tokenAddr The address of the token to be paybacked\\n    /// @param _amount Amount of tokens to be payed back\\n    function paybackOnBehalf(address _market, address _tokenAddr, uint256 _amount, uint256 _rateMode, address _onBehalf) public burnGas(3) payable {\\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\\n        _tokenAddr = changeToWeth(_tokenAddr);\\n\\n        if (_tokenAddr == WETH_ADDRESS) {\\n            TokenInterface(WETH_ADDRESS).deposit{value: msg.value}();\\n        } else {\\n            uint amountToPull = min(_amount, ERC20(_tokenAddr).allowance(msg.sender, address(this)));\\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), amountToPull);\\n        }\\n\\n        approveToken(_tokenAddr, lendingPool);\\n        ILendingPoolV2(lendingPool).repay(_tokenAddr, _amount, _rateMode, _onBehalf);\\n\\n        if (_tokenAddr == WETH_ADDRESS) {\\n            // we do this so the user gets eth instead of weth\\n            TokenInterface(WETH_ADDRESS).withdraw(_amount);\\n            _tokenAddr = ETH_ADDR;\\n        }\\n\\n        withdrawTokens(_tokenAddr);\\n    }\\n\\n\\n    /// @notice Helper method to withdraw tokens from the DSProxy\\n    /// @param _tokenAddr Address of the token to be withdrawn\\n    function withdrawTokens(address _tokenAddr) public {\\n        uint256 amount = _tokenAddr == ETH_ADDR ? address(this).balance : ERC20(_tokenAddr).balanceOf(address(this));\\n\\n        if (amount > 0) {\\n            if (_tokenAddr != ETH_ADDR) {\\n                ERC20(_tokenAddr).safeTransfer(msg.sender, amount);\\n            } else {\\n                msg.sender.transfer(amount);\\n            }\\n        }\\n    }\\n\\n    function setUserUseReserveAsCollateralIfNeeded(address _market, address _tokenAddr) public {\\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\\n        IAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\\n\\n        (,,,,,,,,bool collateralEnabled) = dataProvider.getUserReserveData(_tokenAddr, address(this));\\n\\n        if (!collateralEnabled) {\\n            ILendingPoolV2(lendingPool).setUserUseReserveAsCollateral(_tokenAddr, true);\\n        }\\n    }\\n\\n    function setUserUseReserveAsCollateral(address _market, address _tokenAddr, bool _true) public {\\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\\n\\n        ILendingPoolV2(lendingPool).setUserUseReserveAsCollateral(_tokenAddr, _true);\\n    }\\n\\n    // stable = 1, variable = 2\\n    function swapBorrowRateMode(address _market, address _reserve, uint _rateMode) public {\\n        address lendingPool = ILendingPoolAddressesProviderV2(_market).getLendingPool();\\n\\n        ILendingPoolV2(lendingPool).swapBorrowRateMode(_reserve, _rateMode);\\n    }\\n\\n    function changeToWeth(address _token) private view returns(address) {\\n        if (_token == ETH_ADDR) {\\n            return WETH_ADDRESS;\\n        }\\n\\n        return _token;\\n    }\\n\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external virtual payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/aaveV2/AaveSafetyRatioV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./AaveHelperV2.sol\\\";\\nimport \\\"../interfaces/ILendingPoolV2.sol\\\";\\n\\ncontract AaveSafetyRatioV2 is AaveHelperV2 {\\n\\n    function getSafetyRatio(address _market, address _user) public view returns(uint256) {\\n        ILendingPoolV2 lendingPool = ILendingPoolV2(ILendingPoolAddressesProviderV2(_market).getLendingPool());\\n        \\n        (,uint256 totalDebtETH,uint256 availableBorrowsETH,,,) = lendingPool.getUserAccountData(_user);\\n\\n        if (totalDebtETH == 0) return uint256(0);\\n\\n        return wdiv(add(totalDebtETH, availableBorrowsETH), totalDebtETH);\\n    }\\n}\"\r\n    },\r\n    \"contracts/aaveV2/automatic/AaveMonitorV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../utils/GasBurner.sol\\\";\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeData.sol\\\";\\nimport \\\"./AaveMonitorProxyV2.sol\\\";\\nimport \\\"./AaveSubscriptionsV2.sol\\\";\\nimport \\\"../AaveSafetyRatioV2.sol\\\";\\n\\n/// @title Contract implements logic of calling boost/repay in the automatic system\\ncontract AaveMonitorV2 is AdminAuth, DSMath, AaveSafetyRatioV2, GasBurner {\\n\\n    using SafeERC20 for ERC20;\\n\\n    string public constant NAME = \\\"AaveMonitorV2\\\";\\n\\n    enum Method { Boost, Repay }\\n\\n    uint public REPAY_GAS_TOKEN = 20;\\n    uint public BOOST_GAS_TOKEN = 20;\\n\\n    uint public MAX_GAS_PRICE = 400000000000; // 400 gwei\\n\\n    uint public REPAY_GAS_COST = 2000000;\\n    uint public BOOST_GAS_COST = 2000000;\\n\\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\\n    address public constant AAVE_MARKET_ADDRESS = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;\\n\\n    AaveMonitorProxyV2 public aaveMonitorProxy;\\n    AaveSubscriptionsV2 public subscriptionsContract;\\n    address public aaveSaverProxy;\\n\\n    DefisaverLogger public logger = DefisaverLogger(DEFISAVER_LOGGER);\\n\\n    modifier onlyApproved() {\\n        require(BotRegistry(BOT_REGISTRY_ADDRESS).botList(msg.sender), \\\"Not auth bot\\\");\\n        _;\\n    }\\n\\n    /// @param _aaveMonitorProxy Proxy contracts that actually is authorized to call DSProxy\\n    /// @param _subscriptions Subscriptions contract for Aave positions\\n    /// @param _aaveSaverProxy Contract that actually performs Repay/Boost\\n    constructor(address _aaveMonitorProxy, address _subscriptions, address _aaveSaverProxy) public {\\n        aaveMonitorProxy = AaveMonitorProxyV2(_aaveMonitorProxy);\\n        subscriptionsContract = AaveSubscriptionsV2(_subscriptions);\\n        aaveSaverProxy = _aaveSaverProxy;\\n    }\\n\\n    /// @notice Bots call this method to repay for user when conditions are met\\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\\n    /// @param _exData Exchange data\\n    /// @param _user The actual address that owns the Aave position\\n    function repayFor(\\n        DFSExchangeData.ExchangeData memory _exData,\\n        address _user,\\n        uint256 _rateMode,\\n        uint256 _flAmount\\n    ) public payable onlyApproved burnGas(REPAY_GAS_TOKEN) {\\n\\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Repay, _user);\\n        require(isAllowed); // check if conditions are met\\n\\n        uint256 gasCost = calcGasCost(REPAY_GAS_COST);\\n\\n        aaveMonitorProxy.callExecute{value: msg.value}(\\n            _user,\\n            aaveSaverProxy,\\n            abi.encodeWithSignature(\\n                \\\"repay(address,(address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256,uint256,uint256)\\\",\\n                AAVE_MARKET_ADDRESS,\\n                _exData,\\n                _rateMode,\\n                gasCost,\\n                _flAmount\\n            )\\n        );\\n\\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Repay, _user);\\n        require(isGoodRatio); // check if the after result of the actions is good\\n\\n        returnEth();\\n\\n        logger.Log(address(this), _user, \\\"AutomaticAaveRepayV2\\\", abi.encode(ratioBefore, ratioAfter));\\n    }\\n\\n    /// @notice Bots call this method to boost for user when conditions are met\\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\\n    /// @param _exData Exchange data\\n    /// @param _user The actual address that owns the Aave position\\n    function boostFor(\\n        DFSExchangeData.ExchangeData memory _exData,\\n        address _user,\\n        uint256 _rateMode,\\n        uint256 _flAmount\\n    ) public payable onlyApproved burnGas(BOOST_GAS_TOKEN) {\\n\\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Boost, _user);\\n        require(isAllowed); // check if conditions are met\\n\\n        uint256 gasCost = calcGasCost(BOOST_GAS_COST);\\n\\n        aaveMonitorProxy.callExecute{value: msg.value}(\\n            _user,\\n            aaveSaverProxy,\\n            abi.encodeWithSignature(\\n                \\\"boost(address,(address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256,uint256,uint256)\\\",\\n                AAVE_MARKET_ADDRESS,\\n                _exData,\\n                _rateMode,\\n                gasCost,\\n                _flAmount\\n            )\\n        );\\n\\n\\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Boost, _user);\\n        require(isGoodRatio);  // check if the after result of the actions is good\\n\\n        returnEth();\\n\\n        logger.Log(address(this), _user, \\\"AutomaticAaveBoostV2\\\", abi.encode(ratioBefore, ratioAfter));\\n    }\\n\\n/******************* INTERNAL METHODS ********************************/\\n    function returnEth() internal {\\n        // return if some eth left\\n        if (address(this).balance > 0) {\\n            msg.sender.transfer(address(this).balance);\\n        }\\n    }\\n\\n/******************* STATIC METHODS ********************************/\\n\\n    /// @notice Checks if Boost/Repay could be triggered for the CDP\\n    /// @dev Called by AaveMonitor to enforce the min/max check\\n    /// @param _method Type of action to be called\\n    /// @param _user The actual address that owns the Aave position\\n    /// @return Boolean if it can be called and the ratio\\n    function canCall(Method _method, address _user) public view returns(bool, uint) {\\n        bool subscribed = subscriptionsContract.isSubscribed(_user);\\n        AaveSubscriptionsV2.AaveHolder memory holder = subscriptionsContract.getHolder(_user);\\n\\n        // check if cdp is subscribed\\n        if (!subscribed) return (false, 0);\\n\\n        // check if boost and boost allowed\\n        if (_method == Method.Boost && !holder.boostEnabled) return (false, 0);\\n\\n        uint currRatio = getSafetyRatio(AAVE_MARKET_ADDRESS, _user);\\n\\n        if (_method == Method.Repay) {\\n            return (currRatio < holder.minRatio, currRatio);\\n        } else if (_method == Method.Boost) {\\n            return (currRatio > holder.maxRatio, currRatio);\\n        }\\n    }\\n\\n    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call\\n    /// @param _method Type of action to be called\\n    /// @param _user The actual address that owns the Aave position\\n    /// @return Boolean if the recent action preformed correctly and the ratio\\n    function ratioGoodAfter(Method _method, address _user) public view returns(bool, uint) {\\n        AaveSubscriptionsV2.AaveHolder memory holder;\\n\\n        holder = subscriptionsContract.getHolder(_user);\\n\\n        uint currRatio = getSafetyRatio(AAVE_MARKET_ADDRESS, _user);\\n\\n        if (_method == Method.Repay) {\\n            return (currRatio < holder.maxRatio, currRatio);\\n        } else if (_method == Method.Boost) {\\n            return (currRatio > holder.minRatio, currRatio);\\n        }\\n    }\\n\\n    /// @notice Calculates gas cost (in Eth) of tx\\n    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP\\n    /// @param _gasAmount Amount of gas used for the tx\\n    function calcGasCost(uint _gasAmount) public view returns (uint) {\\n        uint gasPrice = tx.gasprice <= MAX_GAS_PRICE ? tx.gasprice : MAX_GAS_PRICE;\\n\\n        return mul(gasPrice, _gasAmount);\\n    }\\n\\n/******************* OWNER ONLY OPERATIONS ********************************/\\n\\n    /// @notice As the code is new, have a emergancy admin saver proxy change\\n    function changeAaveSaverProxy(address _newAaveSaverProxy) public onlyAdmin {\\n        aaveSaverProxy = _newAaveSaverProxy;\\n    }\\n\\n    /// @notice Allows owner to change gas cost for boost operation, but only up to 3 millions\\n    /// @param _gasCost New gas cost for boost method\\n    function changeBoostGasCost(uint _gasCost) public onlyOwner {\\n        require(_gasCost < 3000000);\\n\\n        BOOST_GAS_COST = _gasCost;\\n    }\\n\\n    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions\\n    /// @param _gasCost New gas cost for repay method\\n    function changeRepayGasCost(uint _gasCost) public onlyOwner {\\n        require(_gasCost < 3000000);\\n\\n        REPAY_GAS_COST = _gasCost;\\n    }\\n\\n    /// @notice Allows owner to change max gas price\\n    /// @param _maxGasPrice New max gas price\\n    function changeMaxGasPrice(uint _maxGasPrice) public onlyOwner {\\n        require(_maxGasPrice < 500000000000);\\n\\n        MAX_GAS_PRICE = _maxGasPrice;\\n    }\\n\\n    /// @notice Allows owner to change gas token amount\\n    /// @param _gasTokenAmount New gas token amount\\n    /// @param _repay true if repay gas token, false if boost gas token\\n    function changeGasTokenAmount(uint _gasTokenAmount, bool _repay) public onlyOwner {\\n        if (_repay) {\\n            REPAY_GAS_TOKEN = _gasTokenAmount;\\n        } else {\\n            BOOST_GAS_TOKEN = _gasTokenAmount;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/aaveV2/automatic/AaveMonitorProxyV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../interfaces/DSProxyInterface.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\n/// @title Contract with the actuall DSProxy permission calls the automation operations\\ncontract AaveMonitorProxyV2 is AdminAuth {\\n\\n    using SafeERC20 for ERC20;\\n\\n    string public constant NAME = \\\"AaveMonitorProxyV2\\\";\\n\\n    uint public CHANGE_PERIOD;\\n    address public monitor;\\n    address public newMonitor;\\n    address public lastMonitor;\\n    uint public changeRequestedTimestamp;\\n\\n    event MonitorChangeInitiated(address oldMonitor, address newMonitor);\\n    event MonitorChangeCanceled();\\n    event MonitorChangeFinished(address monitor);\\n    event MonitorChangeReverted(address monitor);\\n\\n\\n    modifier onlyMonitor() {\\n        require (msg.sender == monitor);\\n        _;\\n    }\\n\\n    constructor(uint _changePeriod) public {\\n        CHANGE_PERIOD = _changePeriod * 1 hours;\\n    }\\n\\n    /// @notice Only monitor contract is able to call execute on users proxy\\n    /// @param _owner Address of cdp owner (users DSProxy address)\\n    /// @param _aaveSaverProxy Address of AaveSaverProxy\\n    /// @param _data Data to send to AaveSaverProxy\\n    function callExecute(address _owner, address _aaveSaverProxy, bytes memory _data) public payable onlyMonitor {\\n        // execute reverts if calling specific method fails\\n        DSProxyInterface(_owner).execute{value: msg.value}(_aaveSaverProxy, _data);\\n\\n        // return if anything left\\n        if (address(this).balance > 0) {\\n            msg.sender.transfer(address(this).balance);\\n        }\\n    }\\n\\n    /// @notice Owner is able to set Monitor contract without any waiting period first time\\n    /// @param _monitor Address of Monitor contract\\n    function setMonitor(address _monitor) public onlyOwner {\\n        require(monitor == address(0));\\n        monitor = _monitor;\\n    }\\n\\n    /// @notice Owner is able to start procedure for changing monitor\\n    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change\\n    /// @param _newMonitor address of new monitor\\n    function changeMonitor(address _newMonitor) public onlyOwner {\\n        require(changeRequestedTimestamp == 0);\\n\\n        changeRequestedTimestamp = now;\\n        lastMonitor = monitor;\\n        newMonitor = _newMonitor;\\n\\n        emit MonitorChangeInitiated(lastMonitor, newMonitor);\\n    }\\n\\n    /// @notice At any point owner is able to cancel monitor change\\n    function cancelMonitorChange() public onlyOwner {\\n        require(changeRequestedTimestamp > 0);\\n\\n        changeRequestedTimestamp = 0;\\n        newMonitor = address(0);\\n\\n        emit MonitorChangeCanceled();\\n    }\\n\\n    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started\\n    function confirmNewMonitor() public onlyOwner {\\n        require((changeRequestedTimestamp + CHANGE_PERIOD) < now);\\n        require(changeRequestedTimestamp != 0);\\n        require(newMonitor != address(0));\\n\\n        monitor = newMonitor;\\n        newMonitor = address(0);\\n        changeRequestedTimestamp = 0;\\n\\n        emit MonitorChangeFinished(monitor);\\n    }\\n\\n    /// @notice Its possible to revert monitor to last used monitor\\n    function revertMonitor() public onlyOwner {\\n        require(lastMonitor != address(0));\\n\\n        monitor = lastMonitor;\\n\\n        emit MonitorChangeReverted(monitor);\\n    }\\n\\n    function setChangePeriod(uint _periodInHours) public onlyOwner {\\n        require(_periodInHours * 1 hours > CHANGE_PERIOD);\\n\\n        CHANGE_PERIOD = _periodInHours * 1 hours;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/aaveV2/automatic/AaveSubscriptionsV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\n/// @title Stores subscription information for Aave automatization\\ncontract AaveSubscriptionsV2 is AdminAuth {\\n\\n    string public constant NAME = \\\"AaveSubscriptionsV2\\\";\\n\\n    struct AaveHolder {\\n        address user;\\n        uint128 minRatio;\\n        uint128 maxRatio;\\n        uint128 optimalRatioBoost;\\n        uint128 optimalRatioRepay;\\n        bool boostEnabled;\\n    }\\n\\n    struct SubPosition {\\n        uint arrPos;\\n        bool subscribed;\\n    }\\n\\n    AaveHolder[] public subscribers;\\n    mapping (address => SubPosition) public subscribersPos;\\n\\n    uint public changeIndex;\\n\\n    event Subscribed(address indexed user);\\n    event Unsubscribed(address indexed user);\\n    event Updated(address indexed user);\\n    event ParamUpdates(address indexed user, uint128, uint128, uint128, uint128, bool);\\n\\n    /// @dev Called by the DSProxy contract which owns the Aave position\\n    /// @notice Adds the users Aave poistion in the list of subscriptions so it can be monitored\\n    /// @param _minRatio Minimum ratio below which repay is triggered\\n    /// @param _maxRatio Maximum ratio after which boost is triggered\\n    /// @param _optimalBoost Ratio amount which boost should target\\n    /// @param _optimalRepay Ratio amount which repay should target\\n    /// @param _boostEnabled Boolean determing if boost is enabled\\n    function subscribe(uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled) external {\\n\\n        // if boost is not enabled, set max ratio to max uint\\n        uint128 localMaxRatio = _boostEnabled ? _maxRatio : uint128(-1);\\n        require(checkParams(_minRatio, localMaxRatio), \\\"Must be correct params\\\");\\n\\n        SubPosition storage subInfo = subscribersPos[msg.sender];\\n\\n        AaveHolder memory subscription = AaveHolder({\\n                minRatio: _minRatio,\\n                maxRatio: localMaxRatio,\\n                optimalRatioBoost: _optimalBoost,\\n                optimalRatioRepay: _optimalRepay,\\n                user: msg.sender,\\n                boostEnabled: _boostEnabled\\n            });\\n\\n        changeIndex++;\\n\\n        if (subInfo.subscribed) {\\n            subscribers[subInfo.arrPos] = subscription;\\n\\n            emit Updated(msg.sender);\\n            emit ParamUpdates(msg.sender, _minRatio, localMaxRatio, _optimalBoost, _optimalRepay, _boostEnabled);\\n        } else {\\n            subscribers.push(subscription);\\n\\n            subInfo.arrPos = subscribers.length - 1;\\n            subInfo.subscribed = true;\\n\\n            emit Subscribed(msg.sender);\\n        }\\n    }\\n\\n    /// @notice Called by the users DSProxy\\n    /// @dev Owner who subscribed cancels his subscription\\n    function unsubscribe() external {\\n        _unsubscribe(msg.sender);\\n    }\\n\\n    /// @dev Checks limit if minRatio is bigger than max\\n    /// @param _minRatio Minimum ratio, bellow which repay can be triggered\\n    /// @param _maxRatio Maximum ratio, over which boost can be triggered\\n    /// @return Returns bool if the params are correct\\n    function checkParams(uint128 _minRatio, uint128 _maxRatio) internal pure returns (bool) {\\n\\n        if (_minRatio > _maxRatio) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @dev Internal method to remove a subscriber from the list\\n    /// @param _user The actual address that owns the Aave position\\n    function _unsubscribe(address _user) internal {\\n        require(subscribers.length > 0, \\\"Must have subscribers in the list\\\");\\n\\n        SubPosition storage subInfo = subscribersPos[_user];\\n\\n        require(subInfo.subscribed, \\\"Must first be subscribed\\\");\\n\\n        address lastOwner = subscribers[subscribers.length - 1].user;\\n\\n        SubPosition storage subInfo2 = subscribersPos[lastOwner];\\n        subInfo2.arrPos = subInfo.arrPos;\\n\\n        subscribers[subInfo.arrPos] = subscribers[subscribers.length - 1];\\n        subscribers.pop(); // remove last element and reduce arr length\\n\\n        changeIndex++;\\n        subInfo.subscribed = false;\\n        subInfo.arrPos = 0;\\n\\n        emit Unsubscribed(msg.sender);\\n    }\\n\\n    /// @dev Checks if the user is subscribed\\n    /// @param _user The actual address that owns the Aave position\\n    /// @return If the user is subscribed\\n    function isSubscribed(address _user) public view returns (bool) {\\n        SubPosition storage subInfo = subscribersPos[_user];\\n\\n        return subInfo.subscribed;\\n    }\\n\\n    /// @dev Returns subscribtion information about a user\\n    /// @param _user The actual address that owns the Aave position\\n    /// @return Subscription information about the user if exists\\n    function getHolder(address _user) public view returns (AaveHolder memory) {\\n        SubPosition storage subInfo = subscribersPos[_user];\\n\\n        return subscribers[subInfo.arrPos];\\n    }\\n\\n    /// @notice Helper method to return all the subscribed CDPs\\n    /// @return List of all subscribers\\n    function getSubscribers() public view returns (AaveHolder[] memory) {\\n        return subscribers;\\n    }\\n\\n    /// @notice Helper method for the frontend, returns all the subscribed CDPs paginated\\n    /// @param _page What page of subscribers you want\\n    /// @param _perPage Number of entries per page\\n    /// @return List of all subscribers for that page\\n    function getSubscribersByPage(uint _page, uint _perPage) public view returns (AaveHolder[] memory) {\\n        AaveHolder[] memory holders = new AaveHolder[](_perPage);\\n\\n        uint start = _page * _perPage;\\n        uint end = start + _perPage;\\n\\n        end = (end > holders.length) ? holders.length : end;\\n\\n        uint count = 0;\\n        for (uint i = start; i < end; i++) {\\n            holders[count] = subscribers[i];\\n            count++;\\n        }\\n\\n        return holders;\\n    }\\n\\n    ////////////// ADMIN METHODS ///////////////////\\n\\n    /// @notice Admin function to unsubscribe a position\\n    /// @param _user The actual address that owns the Aave position\\n    function unsubscribeByAdmin(address _user) public onlyOwner {\\n        SubPosition storage subInfo = subscribersPos[_user];\\n\\n        if (subInfo.subscribed) {\\n            _unsubscribe(_user);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/aaveV2/AaveLoanInfoV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./AaveSafetyRatioV2.sol\\\";\\nimport \\\"../interfaces/IAaveProtocolDataProviderV2.sol\\\";\\n\\ncontract AaveLoanInfoV2 is AaveSafetyRatioV2 {\\n\\n    struct LoanData {\\n        address user;\\n        uint128 ratio;\\n        address[] collAddr;\\n        address[] borrowAddr;\\n        uint256[] collAmounts;\\n        uint256[] borrowStableAmounts;\\n        uint256[] borrowVariableAmounts;\\n    }\\n\\n    struct TokenInfo {\\n        address aTokenAddress;\\n        address underlyingTokenAddress;\\n        uint256 collateralFactor;\\n        uint256 price;\\n    }\\n\\n    struct TokenInfoFull {\\n        address aTokenAddress;\\n        address underlyingTokenAddress;\\n        uint256 supplyRate;\\n        uint256 borrowRateVariable;\\n        uint256 borrowRateStable;\\n        uint256 totalSupply;\\n        uint256 availableLiquidity;\\n        uint256 totalBorrow;\\n        uint256 collateralFactor;\\n        uint256 liquidationRatio;\\n        uint256 price;\\n        bool usageAsCollateralEnabled;\\n        bool borrowinEnabled;\\n        bool stableBorrowRateEnabled;\\n    }\\n\\n    struct ReserveData {\\n        uint256 availableLiquidity;\\n        uint256 totalStableDebt;\\n        uint256 totalVariableDebt;\\n        uint256 liquidityRate;\\n        uint256 variableBorrowRate;\\n        uint256 stableBorrowRate;\\n    }\\n\\n    struct UserToken {\\n        address token;\\n        uint256 balance;\\n        uint256 borrowsStable;\\n        uint256 borrowsVariable;\\n        uint256 stableBorrowRate;\\n        bool enabledAsCollateral;\\n    }\\n\\n    /// @notice Calcualted the ratio of coll/debt for a compound user\\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\\n    /// @param _user Address of the user\\n    function getRatio(address _market, address _user) public view returns (uint256) {\\n        // For each asset the account is in\\n        return getSafetyRatio(_market, _user);\\n    }\\n\\n    /// @notice Fetches Aave prices for tokens\\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\\n    /// @param _tokens Arr. of tokens for which to get the prices\\n    /// @return prices Array of prices\\n    function getPrices(address _market, address[] memory _tokens) public view returns (uint256[] memory prices) {\\n        address priceOracleAddress = ILendingPoolAddressesProviderV2(_market).getPriceOracle();\\n        prices = IPriceOracleGetterAave(priceOracleAddress).getAssetsPrices(_tokens);\\n    }\\n\\n    /// @notice Fetches Aave collateral factors for tokens\\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\\n    /// @param _tokens Arr. of tokens for which to get the coll. factors\\n    /// @return collFactors Array of coll. factors\\n    function getCollFactors(address _market, address[] memory _tokens) public view returns (uint256[] memory collFactors) {\\n        IAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\\n        collFactors = new uint256[](_tokens.length);\\n\\n        for (uint256 i = 0; i < _tokens.length; ++i) {\\n            (,collFactors[i],,,,,,,,) = dataProvider.getReserveConfigurationData(_tokens[i]);\\n        }\\n    }\\n\\n    function getTokenBalances(address _market, address _user, address[] memory _tokens) public view returns (UserToken[] memory userTokens) {\\n        IAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\\n\\n        userTokens = new UserToken[](_tokens.length);\\n\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            address asset = _tokens[i];\\n            userTokens[i].token = asset;\\n\\n            (userTokens[i].balance, userTokens[i].borrowsStable, userTokens[i].borrowsVariable,,,userTokens[i].stableBorrowRate,,,userTokens[i].enabledAsCollateral) = dataProvider.getUserReserveData(asset, _user);\\n        }\\n    }\\n\\n    /// @notice Calcualted the ratio of coll/debt for an aave user\\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\\n    /// @param _users Addresses of the user\\n    /// @return ratios Array of ratios\\n    function getRatios(address _market, address[] memory _users) public view returns (uint256[] memory ratios) {\\n        ratios = new uint256[](_users.length);\\n\\n        for (uint256 i = 0; i < _users.length; ++i) {\\n            ratios[i] = getSafetyRatio(_market, _users[i]);\\n        }\\n    }\\n\\n    /// @notice Information about reserves\\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\\n    /// @param _tokenAddresses Array of tokens addresses\\n    /// @return tokens Array of reserves infomartion\\n    function getTokensInfo(address _market, address[] memory _tokenAddresses) public view returns(TokenInfo[] memory tokens) {\\n        IAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\\n        address priceOracleAddress = ILendingPoolAddressesProviderV2(_market).getPriceOracle();\\n\\n        tokens = new TokenInfo[](_tokenAddresses.length);\\n\\n        for (uint256 i = 0; i < _tokenAddresses.length; ++i) {\\n            (,uint256 ltv,,,,,,,,) = dataProvider.getReserveConfigurationData(_tokenAddresses[i]);\\n            (address aToken,,) = dataProvider.getReserveTokensAddresses(_tokenAddresses[i]);\\n\\n            tokens[i] = TokenInfo({\\n                aTokenAddress: aToken,\\n                underlyingTokenAddress: _tokenAddresses[i],\\n                collateralFactor: ltv,\\n                price: IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokenAddresses[i])\\n            });\\n        }\\n    }\\n\\n    function getTokenInfoFull(IAaveProtocolDataProviderV2 _dataProvider, address _priceOracleAddress, address _token) private view returns(TokenInfoFull memory _tokenInfo) {\\n        (\\n            , // uint256 decimals\\n            uint256 ltv,\\n            uint256 liquidationThreshold,\\n            , //   uint256 liquidationBonus\\n            , //   uint256 reserveFactor\\n            bool usageAsCollateralEnabled,\\n            bool borrowinEnabled,\\n            bool stableBorrowRateEnabled,\\n            , //   bool isActive\\n            //   bool isFrozen\\n        ) = _dataProvider.getReserveConfigurationData(_token);\\n\\n        ReserveData memory t;\\n\\n        (\\n            t.availableLiquidity,\\n            t.totalStableDebt,\\n            t.totalVariableDebt,\\n            t.liquidityRate,\\n            t.variableBorrowRate,\\n            t.stableBorrowRate,\\n            ,\\n            ,\\n            ,\\n\\n        ) = _dataProvider.getReserveData(_token);\\n\\n        (address aToken,,) = _dataProvider.getReserveTokensAddresses(_token);\\n\\n        uint price = IPriceOracleGetterAave(_priceOracleAddress).getAssetPrice(_token);\\n\\n        _tokenInfo = TokenInfoFull({\\n            aTokenAddress: aToken,\\n            underlyingTokenAddress: _token,\\n            supplyRate: t.liquidityRate,\\n            borrowRateVariable: t.variableBorrowRate,\\n            borrowRateStable: t.stableBorrowRate,\\n            totalSupply: ERC20(aToken).totalSupply(),\\n            availableLiquidity: t.availableLiquidity,\\n            totalBorrow: t.totalVariableDebt+t.totalStableDebt,\\n            collateralFactor: ltv,\\n            liquidationRatio: liquidationThreshold,\\n            price: price,\\n            usageAsCollateralEnabled: usageAsCollateralEnabled,\\n            borrowinEnabled: borrowinEnabled,\\n            stableBorrowRateEnabled: stableBorrowRateEnabled\\n        });\\n    }\\n\\n    /// @notice Information about reserves\\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\\n    /// @param _tokenAddresses Array of token addresses\\n    /// @return tokens Array of reserves infomartion\\n    function getFullTokensInfo(address _market, address[] memory _tokenAddresses) public view returns(TokenInfoFull[] memory tokens) {\\n        IAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\\n        address priceOracleAddress = ILendingPoolAddressesProviderV2(_market).getPriceOracle();\\n\\n        tokens = new TokenInfoFull[](_tokenAddresses.length);\\n\\n        for (uint256 i = 0; i < _tokenAddresses.length; ++i) {\\n            tokens[i] = getTokenInfoFull(dataProvider, priceOracleAddress, _tokenAddresses[i]);\\n        }\\n    }\\n\\n\\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether\\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\\n    /// @param _user Address of the user\\n    /// @return data LoanData information\\n    function getLoanData(address _market, address _user) public view returns (LoanData memory data) {\\n        IAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\\n        address priceOracleAddress = ILendingPoolAddressesProviderV2(_market).getPriceOracle();\\n\\n        IAaveProtocolDataProviderV2.TokenData[] memory reserves = dataProvider.getAllReservesTokens();\\n\\n        data = LoanData({\\n            user: _user,\\n            ratio: 0,\\n            collAddr: new address[](reserves.length),\\n            borrowAddr: new address[](reserves.length),\\n            collAmounts: new uint[](reserves.length),\\n            borrowStableAmounts: new uint[](reserves.length),\\n            borrowVariableAmounts: new uint[](reserves.length)\\n        });\\n\\n        uint64 collPos = 0;\\n        uint64 borrowPos = 0;\\n        \\n        for (uint64 i = 0; i < reserves.length; i++) {\\n            address reserve = reserves[i].tokenAddress;\\n\\n            (uint256 aTokenBalance, uint256 borrowsStable, uint256 borrowsVariable,,,,,,) = dataProvider.getUserReserveData(reserve, _user);\\n            uint256 price = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(reserve);\\n\\n            if (aTokenBalance > 0) {\\n                uint256 userTokenBalanceEth = wmul(aTokenBalance, price) * (10 ** (18 - _getDecimals(reserve)));\\n                data.collAddr[collPos] = reserve;\\n                data.collAmounts[collPos] = userTokenBalanceEth;\\n                collPos++;\\n            }\\n\\n            // Sum up debt in Eth\\n            if (borrowsStable > 0) {\\n                uint256 userBorrowBalanceEth = wmul(borrowsStable, price) * (10 ** (18 - _getDecimals(reserve)));\\n                data.borrowAddr[borrowPos] = reserve;\\n                data.borrowStableAmounts[borrowPos] = userBorrowBalanceEth;\\n            }\\n\\n            // Sum up debt in Eth\\n            if (borrowsVariable > 0) {\\n                uint256 userBorrowBalanceEth = wmul(borrowsVariable, price) * (10 ** (18 - _getDecimals(reserve)));\\n                data.borrowAddr[borrowPos] = reserve;\\n                data.borrowVariableAmounts[borrowPos] = userBorrowBalanceEth;\\n            }\\n\\n            if (borrowsStable > 0 || borrowsVariable > 0) {\\n                borrowPos++;\\n            }\\n        }\\n\\n        data.ratio = uint128(getSafetyRatio(_market, _user));\\n\\n        return data;\\n    }\\n\\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether\\n    /// @param _market Address of LendingPoolAddressesProvider for specific market\\n    /// @param _users Addresses of the user\\n    /// @return loans Array of LoanData information\\n    function getLoanDataArr(address _market, address[] memory _users) public view returns (LoanData[] memory loans) {\\n        loans = new LoanData[](_users.length);\\n\\n        for (uint i = 0; i < _users.length; ++i) {\\n            loans[i] = getLoanData(_market, _users[i]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/aave/AaveSafetyRatio.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./AaveHelper.sol\\\";\\n\\ncontract AaveSafetyRatio is AaveHelper {\\n\\n    function getSafetyRatio(address _user) public view returns(uint256) {\\n        address lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\\n        (,,uint256 totalBorrowsETH,,uint256 availableBorrowsETH,,,) = ILendingPool(lendingPoolAddress).getUserAccountData(_user);\\n\\n        if (totalBorrowsETH == 0) return uint256(0);\\n\\n        return wdiv(add(totalBorrowsETH, availableBorrowsETH), totalBorrowsETH);\\n    }\\n}\"\r\n    },\r\n    \"contracts/aave/automatic/AaveMonitor.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../utils/GasBurner.sol\\\";\\nimport \\\"./AaveMonitorProxy.sol\\\";\\nimport \\\"./AaveSubscriptions.sol\\\";\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../AaveSafetyRatio.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeData.sol\\\";\\n\\n/// @title Contract implements logic of calling boost/repay in the automatic system\\ncontract AaveMonitor is AdminAuth, DSMath, AaveSafetyRatio, GasBurner {\\n\\n    using SafeERC20 for ERC20;\\n\\n    enum Method { Boost, Repay }\\n\\n    uint public REPAY_GAS_TOKEN = 20;\\n    uint public BOOST_GAS_TOKEN = 20;\\n\\n    uint public MAX_GAS_PRICE = 400000000000; // 400 gwei\\n\\n    uint public REPAY_GAS_COST = 2000000;\\n    uint public BOOST_GAS_COST = 2000000;\\n\\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\\n\\n    AaveMonitorProxy public aaveMonitorProxy;\\n    AaveSubscriptions public subscriptionsContract;\\n    address public aaveSaverProxy;\\n\\n    DefisaverLogger public logger = DefisaverLogger(DEFISAVER_LOGGER);\\n\\n    modifier onlyApproved() {\\n        require(BotRegistry(BOT_REGISTRY_ADDRESS).botList(msg.sender), \\\"Not auth bot\\\");\\n        _;\\n    }\\n\\n    /// @param _aaveMonitorProxy Proxy contracts that actually is authorized to call DSProxy\\n    /// @param _subscriptions Subscriptions contract for Aave positions\\n    /// @param _aaveSaverProxy Contract that actually performs Repay/Boost\\n    constructor(address _aaveMonitorProxy, address _subscriptions, address _aaveSaverProxy) public {\\n        aaveMonitorProxy = AaveMonitorProxy(_aaveMonitorProxy);\\n        subscriptionsContract = AaveSubscriptions(_subscriptions);\\n        aaveSaverProxy = _aaveSaverProxy;\\n    }\\n\\n    /// @notice Bots call this method to repay for user when conditions are met\\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\\n    /// @param _exData Exchange data\\n    /// @param _user The actual address that owns the Aave position\\n    function repayFor(\\n        DFSExchangeData.ExchangeData memory _exData,\\n        address _user\\n    ) public payable onlyApproved burnGas(REPAY_GAS_TOKEN) {\\n\\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Repay, _user);\\n        require(isAllowed); // check if conditions are met\\n\\n        uint256 gasCost = calcGasCost(REPAY_GAS_COST);\\n\\n        aaveMonitorProxy.callExecute{value: msg.value}(\\n            _user,\\n            aaveSaverProxy,\\n            abi.encodeWithSignature(\\n                \\\"repay((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256)\\\",\\n                _exData,\\n                gasCost\\n            )\\n        );\\n\\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Repay, _user);\\n        require(isGoodRatio); // check if the after result of the actions is good\\n\\n        returnEth();\\n\\n        logger.Log(address(this), _user, \\\"AutomaticAaveRepay\\\", abi.encode(ratioBefore, ratioAfter));\\n    }\\n\\n    /// @notice Bots call this method to boost for user when conditions are met\\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\\n    /// @param _exData Exchange data\\n    /// @param _user The actual address that owns the Aave position\\n    function boostFor(\\n        DFSExchangeData.ExchangeData memory _exData,\\n        address _user\\n    ) public payable onlyApproved burnGas(BOOST_GAS_TOKEN) {\\n\\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Boost, _user);\\n        require(isAllowed); // check if conditions are met\\n\\n        uint256 gasCost = calcGasCost(BOOST_GAS_COST);\\n\\n        aaveMonitorProxy.callExecute{value: msg.value}(\\n            _user,\\n            aaveSaverProxy,\\n            abi.encodeWithSignature(\\n                \\\"boost((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256)\\\",\\n                _exData,\\n                gasCost\\n            )\\n        );\\n\\n\\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Boost, _user);\\n        require(isGoodRatio);  // check if the after result of the actions is good\\n\\n        returnEth();\\n\\n        logger.Log(address(this), _user, \\\"AutomaticAaveBoost\\\", abi.encode(ratioBefore, ratioAfter));\\n    }\\n\\n/******************* INTERNAL METHODS ********************************/\\n    function returnEth() internal {\\n        // return if some eth left\\n        if (address(this).balance > 0) {\\n            msg.sender.transfer(address(this).balance);\\n        }\\n    }\\n\\n/******************* STATIC METHODS ********************************/\\n\\n    /// @notice Checks if Boost/Repay could be triggered for the CDP\\n    /// @dev Called by AaveMonitor to enforce the min/max check\\n    /// @param _method Type of action to be called\\n    /// @param _user The actual address that owns the Aave position\\n    /// @return Boolean if it can be called and the ratio\\n    function canCall(Method _method, address _user) public view returns(bool, uint) {\\n        bool subscribed = subscriptionsContract.isSubscribed(_user);\\n        AaveSubscriptions.AaveHolder memory holder = subscriptionsContract.getHolder(_user);\\n\\n        // check if cdp is subscribed\\n        if (!subscribed) return (false, 0);\\n\\n        // check if boost and boost allowed\\n        if (_method == Method.Boost && !holder.boostEnabled) return (false, 0);\\n\\n        uint currRatio = getSafetyRatio(_user);\\n\\n        if (_method == Method.Repay) {\\n            return (currRatio < holder.minRatio, currRatio);\\n        } else if (_method == Method.Boost) {\\n            return (currRatio > holder.maxRatio, currRatio);\\n        }\\n    }\\n\\n    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call\\n    /// @param _method Type of action to be called\\n    /// @param _user The actual address that owns the Aave position\\n    /// @return Boolean if the recent action preformed correctly and the ratio\\n    function ratioGoodAfter(Method _method, address _user) public view returns(bool, uint) {\\n        AaveSubscriptions.AaveHolder memory holder;\\n\\n        holder= subscriptionsContract.getHolder(_user);\\n\\n        uint currRatio = getSafetyRatio(_user);\\n\\n        if (_method == Method.Repay) {\\n            return (currRatio < holder.maxRatio, currRatio);\\n        } else if (_method == Method.Boost) {\\n            return (currRatio > holder.minRatio, currRatio);\\n        }\\n    }\\n\\n    /// @notice Calculates gas cost (in Eth) of tx\\n    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP\\n    /// @param _gasAmount Amount of gas used for the tx\\n    function calcGasCost(uint _gasAmount) public view returns (uint) {\\n        uint gasPrice = tx.gasprice <= MAX_GAS_PRICE ? tx.gasprice : MAX_GAS_PRICE;\\n\\n        return mul(gasPrice, _gasAmount);\\n    }\\n\\n/******************* OWNER ONLY OPERATIONS ********************************/\\n\\n    /// @notice As the code is new, have a emergancy admin saver proxy change\\n    function changeAaveSaverProxy(address _newAaveSaverProxy) public onlyAdmin {\\n        aaveSaverProxy = _newAaveSaverProxy;\\n    }\\n\\n    /// @notice Allows owner to change gas cost for boost operation, but only up to 3 millions\\n    /// @param _gasCost New gas cost for boost method\\n    function changeBoostGasCost(uint _gasCost) public onlyOwner {\\n        require(_gasCost < 3000000);\\n\\n        BOOST_GAS_COST = _gasCost;\\n    }\\n\\n    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions\\n    /// @param _gasCost New gas cost for repay method\\n    function changeRepayGasCost(uint _gasCost) public onlyOwner {\\n        require(_gasCost < 3000000);\\n\\n        REPAY_GAS_COST = _gasCost;\\n    }\\n\\n    /// @notice Allows owner to change max gas price\\n    /// @param _maxGasPrice New max gas price\\n    function changeMaxGasPrice(uint _maxGasPrice) public onlyOwner {\\n        require(_maxGasPrice < 500000000000);\\n\\n        MAX_GAS_PRICE = _maxGasPrice;\\n    }\\n\\n    /// @notice Allows owner to change gas token amount\\n    /// @param _gasTokenAmount New gas token amount\\n    /// @param _repay true if repay gas token, false if boost gas token\\n    function changeGasTokenAmount(uint _gasTokenAmount, bool _repay) public onlyOwner {\\n        if (_repay) {\\n            REPAY_GAS_TOKEN = _gasTokenAmount;\\n        } else {\\n            BOOST_GAS_TOKEN = _gasTokenAmount;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/aave/automatic/AaveMonitorProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../interfaces/DSProxyInterface.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\n/// @title Contract with the actuall DSProxy permission calls the automation operations\\ncontract AaveMonitorProxy is AdminAuth {\\n\\n    using SafeERC20 for ERC20;\\n\\n    uint public CHANGE_PERIOD;\\n    address public monitor;\\n    address public newMonitor;\\n    address public lastMonitor;\\n    uint public changeRequestedTimestamp;\\n\\n    mapping(address => bool) public allowed;\\n\\n    event MonitorChangeInitiated(address oldMonitor, address newMonitor);\\n    event MonitorChangeCanceled();\\n    event MonitorChangeFinished(address monitor);\\n    event MonitorChangeReverted(address monitor);\\n\\n    // if someone who is allowed become malicious, owner can't be changed\\n    modifier onlyAllowed() {\\n        require(allowed[msg.sender] || msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyMonitor() {\\n        require (msg.sender == monitor);\\n        _;\\n    }\\n\\n    constructor(uint _changePeriod) public {\\n        CHANGE_PERIOD = _changePeriod * 1 days;\\n    }\\n\\n    /// @notice Only monitor contract is able to call execute on users proxy\\n    /// @param _owner Address of cdp owner (users DSProxy address)\\n    /// @param _aaveSaverProxy Address of AaveSaverProxy\\n    /// @param _data Data to send to AaveSaverProxy\\n    function callExecute(address _owner, address _aaveSaverProxy, bytes memory _data) public payable onlyMonitor {\\n        // execute reverts if calling specific method fails\\n        DSProxyInterface(_owner).execute{value: msg.value}(_aaveSaverProxy, _data);\\n\\n        // return if anything left\\n        if (address(this).balance > 0) {\\n            msg.sender.transfer(address(this).balance);\\n        }\\n    }\\n\\n    /// @notice Allowed users are able to set Monitor contract without any waiting period first time\\n    /// @param _monitor Address of Monitor contract\\n    function setMonitor(address _monitor) public onlyAllowed {\\n        require(monitor == address(0));\\n        monitor = _monitor;\\n    }\\n\\n    /// @notice Allowed users are able to start procedure for changing monitor\\n    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change\\n    /// @param _newMonitor address of new monitor\\n    function changeMonitor(address _newMonitor) public onlyAllowed {\\n        require(changeRequestedTimestamp == 0);\\n\\n        changeRequestedTimestamp = now;\\n        lastMonitor = monitor;\\n        newMonitor = _newMonitor;\\n\\n        emit MonitorChangeInitiated(lastMonitor, newMonitor);\\n    }\\n\\n    /// @notice At any point allowed users are able to cancel monitor change\\n    function cancelMonitorChange() public onlyAllowed {\\n        require(changeRequestedTimestamp > 0);\\n\\n        changeRequestedTimestamp = 0;\\n        newMonitor = address(0);\\n\\n        emit MonitorChangeCanceled();\\n    }\\n\\n    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started\\n    function confirmNewMonitor() public onlyAllowed {\\n        require((changeRequestedTimestamp + CHANGE_PERIOD) < now);\\n        require(changeRequestedTimestamp != 0);\\n        require(newMonitor != address(0));\\n\\n        monitor = newMonitor;\\n        newMonitor = address(0);\\n        changeRequestedTimestamp = 0;\\n\\n        emit MonitorChangeFinished(monitor);\\n    }\\n\\n    /// @notice Its possible to revert monitor to last used monitor\\n    function revertMonitor() public onlyAllowed {\\n        require(lastMonitor != address(0));\\n\\n        monitor = lastMonitor;\\n\\n        emit MonitorChangeReverted(monitor);\\n    }\\n\\n\\n    /// @notice Allowed users are able to add new allowed user\\n    /// @param _user Address of user that will be allowed\\n    function addAllowed(address _user) public onlyAllowed {\\n        allowed[_user] = true;\\n    }\\n\\n    /// @notice Allowed users are able to remove allowed user\\n    /// @dev owner is always allowed even if someone tries to remove it from allowed mapping\\n    /// @param _user Address of allowed user\\n    function removeAllowed(address _user) public onlyAllowed {\\n        allowed[_user] = false;\\n    }\\n\\n    function setChangePeriod(uint _periodInDays) public onlyAllowed {\\n        require(_periodInDays * 1 days > CHANGE_PERIOD);\\n\\n        CHANGE_PERIOD = _periodInDays * 1 days;\\n    }\\n\\n    /// @notice In case something is left in contract, owner is able to withdraw it\\n    /// @param _token address of token to withdraw balance\\n    function withdrawToken(address _token) public onlyOwner {\\n        uint balance = ERC20(_token).balanceOf(address(this));\\n        ERC20(_token).safeTransfer(msg.sender, balance);\\n    }\\n\\n    /// @notice In case something is left in contract, owner is able to withdraw it\\n    function withdrawEth() public onlyOwner {\\n        uint balance = address(this).balance;\\n        msg.sender.transfer(balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/aave/automatic/AaveSubscriptions.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\n/// @title Stores subscription information for Aave automatization\\ncontract AaveSubscriptions is AdminAuth {\\n\\n    struct AaveHolder {\\n        address user;\\n        uint128 minRatio;\\n        uint128 maxRatio;\\n        uint128 optimalRatioBoost;\\n        uint128 optimalRatioRepay;\\n        bool boostEnabled;\\n    }\\n\\n    struct SubPosition {\\n        uint arrPos;\\n        bool subscribed;\\n    }\\n\\n    AaveHolder[] public subscribers;\\n    mapping (address => SubPosition) public subscribersPos;\\n\\n    uint public changeIndex;\\n\\n    event Subscribed(address indexed user);\\n    event Unsubscribed(address indexed user);\\n    event Updated(address indexed user);\\n    event ParamUpdates(address indexed user, uint128, uint128, uint128, uint128, bool);\\n\\n    /// @dev Called by the DSProxy contract which owns the Aave position\\n    /// @notice Adds the users Aave poistion in the list of subscriptions so it can be monitored\\n    /// @param _minRatio Minimum ratio below which repay is triggered\\n    /// @param _maxRatio Maximum ratio after which boost is triggered\\n    /// @param _optimalBoost Ratio amount which boost should target\\n    /// @param _optimalRepay Ratio amount which repay should target\\n    /// @param _boostEnabled Boolean determing if boost is enabled\\n    function subscribe(uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled) external {\\n\\n        // if boost is not enabled, set max ratio to max uint\\n        uint128 localMaxRatio = _boostEnabled ? _maxRatio : uint128(-1);\\n        require(checkParams(_minRatio, localMaxRatio), \\\"Must be correct params\\\");\\n\\n        SubPosition storage subInfo = subscribersPos[msg.sender];\\n\\n        AaveHolder memory subscription = AaveHolder({\\n                minRatio: _minRatio,\\n                maxRatio: localMaxRatio,\\n                optimalRatioBoost: _optimalBoost,\\n                optimalRatioRepay: _optimalRepay,\\n                user: msg.sender,\\n                boostEnabled: _boostEnabled\\n            });\\n\\n        changeIndex++;\\n\\n        if (subInfo.subscribed) {\\n            subscribers[subInfo.arrPos] = subscription;\\n\\n            emit Updated(msg.sender);\\n            emit ParamUpdates(msg.sender, _minRatio, localMaxRatio, _optimalBoost, _optimalRepay, _boostEnabled);\\n        } else {\\n            subscribers.push(subscription);\\n\\n            subInfo.arrPos = subscribers.length - 1;\\n            subInfo.subscribed = true;\\n\\n            emit Subscribed(msg.sender);\\n        }\\n    }\\n\\n    /// @notice Called by the users DSProxy\\n    /// @dev Owner who subscribed cancels his subscription\\n    function unsubscribe() external {\\n        _unsubscribe(msg.sender);\\n    }\\n\\n    /// @dev Checks limit if minRatio is bigger than max\\n    /// @param _minRatio Minimum ratio, bellow which repay can be triggered\\n    /// @param _maxRatio Maximum ratio, over which boost can be triggered\\n    /// @return Returns bool if the params are correct\\n    function checkParams(uint128 _minRatio, uint128 _maxRatio) internal pure returns (bool) {\\n\\n        if (_minRatio > _maxRatio) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @dev Internal method to remove a subscriber from the list\\n    /// @param _user The actual address that owns the Aave position\\n    function _unsubscribe(address _user) internal {\\n        require(subscribers.length > 0, \\\"Must have subscribers in the list\\\");\\n\\n        SubPosition storage subInfo = subscribersPos[_user];\\n\\n        require(subInfo.subscribed, \\\"Must first be subscribed\\\");\\n\\n        address lastOwner = subscribers[subscribers.length - 1].user;\\n\\n        SubPosition storage subInfo2 = subscribersPos[lastOwner];\\n        subInfo2.arrPos = subInfo.arrPos;\\n\\n        subscribers[subInfo.arrPos] = subscribers[subscribers.length - 1];\\n        subscribers.pop(); // remove last element and reduce arr length\\n\\n        changeIndex++;\\n        subInfo.subscribed = false;\\n        subInfo.arrPos = 0;\\n\\n        emit Unsubscribed(msg.sender);\\n    }\\n\\n    /// @dev Checks if the user is subscribed\\n    /// @param _user The actual address that owns the Aave position\\n    /// @return If the user is subscribed\\n    function isSubscribed(address _user) public view returns (bool) {\\n        SubPosition storage subInfo = subscribersPos[_user];\\n\\n        return subInfo.subscribed;\\n    }\\n\\n    /// @dev Returns subscribtion information about a user\\n    /// @param _user The actual address that owns the Aave position\\n    /// @return Subscription information about the user if exists\\n    function getHolder(address _user) public view returns (AaveHolder memory) {\\n        SubPosition storage subInfo = subscribersPos[_user];\\n\\n        return subscribers[subInfo.arrPos];\\n    }\\n\\n    /// @notice Helper method to return all the subscribed CDPs\\n    /// @return List of all subscribers\\n    function getSubscribers() public view returns (AaveHolder[] memory) {\\n        return subscribers;\\n    }\\n\\n    /// @notice Helper method for the frontend, returns all the subscribed CDPs paginated\\n    /// @param _page What page of subscribers you want\\n    /// @param _perPage Number of entries per page\\n    /// @return List of all subscribers for that page\\n    function getSubscribersByPage(uint _page, uint _perPage) public view returns (AaveHolder[] memory) {\\n        AaveHolder[] memory holders = new AaveHolder[](_perPage);\\n\\n        uint start = _page * _perPage;\\n        uint end = start + _perPage;\\n\\n        end = (end > holders.length) ? holders.length : end;\\n\\n        uint count = 0;\\n        for (uint i = start; i < end; i++) {\\n            holders[count] = subscribers[i];\\n            count++;\\n        }\\n\\n        return holders;\\n    }\\n\\n    ////////////// ADMIN METHODS ///////////////////\\n\\n    /// @notice Admin function to unsubscribe a position\\n    /// @param _user The actual address that owns the Aave position\\n    function unsubscribeByAdmin(address _user) public onlyOwner {\\n        SubPosition storage subInfo = subscribersPos[_user];\\n\\n        if (subInfo.subscribed) {\\n            _unsubscribe(_user);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/aave/AaveLoanInfo.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./AaveSafetyRatio.sol\\\";\\n\\ncontract AaveLoanInfo is AaveSafetyRatio {\\n\\n\\tstruct LoanData {\\n        address user;\\n        uint128 ratio;\\n        address[] collAddr;\\n        address[] borrowAddr;\\n        uint256[] collAmounts;\\n        uint256[] borrowAmounts;\\n    }\\n\\n    struct TokenInfo {\\n        address aTokenAddress;\\n        address underlyingTokenAddress;\\n        uint256 collateralFactor;\\n        uint256 price;\\n    }\\n\\n    struct TokenInfoFull {\\n    \\taddress aTokenAddress;\\n        address underlyingTokenAddress;\\n        uint256 supplyRate;\\n        uint256 borrowRate;\\n        uint256 borrowRateStable;\\n        uint256 totalSupply;\\n        uint256 availableLiquidity;\\n        uint256 totalBorrow;\\n        uint256 collateralFactor;\\n        uint256 liquidationRatio;\\n        uint256 price;\\n        bool usageAsCollateralEnabled;\\n    }\\n\\n    struct UserToken {\\n        address token;\\n        uint256 balance;\\n        uint256 borrows;\\n        uint256 borrowRateMode;\\n        uint256 borrowRate;\\n        bool enabledAsCollateral;\\n    }\\n\\n    /// @notice Calcualted the ratio of coll/debt for a compound user\\n    /// @param _user Address of the user\\n    function getRatio(address _user) public view returns (uint256) {\\n        // For each asset the account is in\\n        return getSafetyRatio(_user);\\n    }\\n\\n    /// @notice Fetches Aave prices for tokens\\n    /// @param _tokens Arr. of tokens for which to get the prices\\n    /// @return prices Array of prices\\n    function getPrices(address[] memory _tokens) public view returns (uint256[] memory prices) {\\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\\n        prices = new uint[](_tokens.length);\\n\\n        for (uint256 i = 0; i < _tokens.length; ++i) {\\n            prices[i] = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokens[i]);\\n        }\\n    }\\n\\n    /// @notice Fetches Aave collateral factors for tokens\\n    /// @param _tokens Arr. of tokens for which to get the coll. factors\\n    /// @return collFactors Array of coll. factors\\n    function getCollFactors(address[] memory _tokens) public view returns (uint256[] memory collFactors) {\\n    \\taddress lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\\n        collFactors = new uint256[](_tokens.length);\\n\\n        for (uint256 i = 0; i < _tokens.length; ++i) {\\n        \\t(,collFactors[i],,) = ILendingPool(lendingPoolCoreAddress).getReserveConfiguration(_tokens[i]);\\n        }\\n    }\\n\\n    function getTokenBalances(address _user, address[] memory _tokens) public view returns (UserToken[] memory userTokens) {\\n    \\taddress lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\\n\\n        userTokens = new UserToken[](_tokens.length);\\n\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            address asset = _tokens[i];\\n            userTokens[i].token = asset;\\n\\n            (userTokens[i].balance, userTokens[i].borrows,,userTokens[i].borrowRateMode,userTokens[i].borrowRate,,,,,userTokens[i].enabledAsCollateral) = ILendingPool(lendingPoolAddress).getUserReserveData(asset, _user);\\n        }\\n    }\\n\\n    /// @notice Calcualted the ratio of coll/debt for an aave user\\n    /// @param _users Addresses of the user\\n    /// @return ratios Array of ratios\\n    function getRatios(address[] memory _users) public view returns (uint256[] memory ratios) {\\n        ratios = new uint256[](_users.length);\\n\\n        for (uint256 i = 0; i < _users.length; ++i) {\\n            ratios[i] = getSafetyRatio(_users[i]);\\n        }\\n    }\\n\\n    /// @notice Information about reserves\\n    /// @param _tokenAddresses Array of tokens addresses\\n    /// @return tokens Array of reserves infomartion\\n    function getTokensInfo(address[] memory _tokenAddresses) public view returns(TokenInfo[] memory tokens) {\\n    \\taddress lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\\n    \\taddress priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\\n\\n        tokens = new TokenInfo[](_tokenAddresses.length);\\n\\n        for (uint256 i = 0; i < _tokenAddresses.length; ++i) {\\n        \\t(,uint256 ltv,,) = ILendingPool(lendingPoolCoreAddress).getReserveConfiguration(_tokenAddresses[i]);\\n\\n            tokens[i] = TokenInfo({\\n                aTokenAddress: ILendingPool(lendingPoolCoreAddress).getReserveATokenAddress(_tokenAddresses[i]),\\n                underlyingTokenAddress: _tokenAddresses[i],\\n                collateralFactor: ltv,\\n                price: IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokenAddresses[i])\\n            });\\n        }\\n    }\\n\\n    /// @notice Information about reserves\\n    /// @param _tokenAddresses Array of token addresses\\n    /// @return tokens Array of reserves infomartion\\n    function getFullTokensInfo(address[] memory _tokenAddresses) public view returns(TokenInfoFull[] memory tokens) {\\n    \\taddress lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\\n        address lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\\n    \\taddress priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\\n\\n        tokens = new TokenInfoFull[](_tokenAddresses.length);\\n\\n        for (uint256 i = 0; i < _tokenAddresses.length; ++i) {\\n        \\t(uint256 ltv, uint256 liqRatio,,, bool usageAsCollateralEnabled, bool borrowingEnabled, bool stableBorrowingEnabled,) = ILendingPool(lendingPoolAddress).getReserveConfigurationData(_tokenAddresses[i]);\\n\\n            tokens[i] = TokenInfoFull({\\n            \\taTokenAddress: ILendingPool(lendingPoolCoreAddress).getReserveATokenAddress(_tokenAddresses[i]),\\n                underlyingTokenAddress: _tokenAddresses[i],\\n                supplyRate: ILendingPool(lendingPoolCoreAddress).getReserveCurrentLiquidityRate(_tokenAddresses[i]),\\n                borrowRate: borrowingEnabled ? ILendingPool(lendingPoolCoreAddress).getReserveCurrentVariableBorrowRate(_tokenAddresses[i]) : 0,\\n                borrowRateStable: stableBorrowingEnabled ? ILendingPool(lendingPoolCoreAddress).getReserveCurrentStableBorrowRate(_tokenAddresses[i]) : 0,\\n                totalSupply: ILendingPool(lendingPoolCoreAddress).getReserveTotalLiquidity(_tokenAddresses[i]),\\n                availableLiquidity: ILendingPool(lendingPoolCoreAddress).getReserveAvailableLiquidity(_tokenAddresses[i]),\\n                totalBorrow: ILendingPool(lendingPoolCoreAddress).getReserveTotalBorrowsVariable(_tokenAddresses[i]) + ILendingPool(lendingPoolCoreAddress).getReserveTotalBorrowsStable(_tokenAddresses[i]),\\n                collateralFactor: ltv,\\n                liquidationRatio: liqRatio,\\n                price: IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokenAddresses[i]),\\n                usageAsCollateralEnabled: usageAsCollateralEnabled\\n            });\\n        }\\n    }\\n\\n\\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether\\n    /// @param _user Address of the user\\n    /// @return data LoanData information\\n    function getLoanData(address _user) public view returns (LoanData memory data) {\\n        address lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\\n\\n        address[] memory reserves = ILendingPool(lendingPoolAddress).getReserves();\\n\\n        data = LoanData({\\n            user: _user,\\n            ratio: 0,\\n            collAddr: new address[](reserves.length),\\n            borrowAddr: new address[](reserves.length),\\n            collAmounts: new uint[](reserves.length),\\n            borrowAmounts: new uint[](reserves.length)\\n        });\\n\\n        uint64 collPos = 0;\\n        uint64 borrowPos = 0;\\n\\n        for (uint64 i = 0; i < reserves.length; i++) {\\n            address reserve = reserves[i];\\n\\n            (uint256 aTokenBalance, uint256 borrowBalance,,,,,,,,) = ILendingPool(lendingPoolAddress).getUserReserveData(reserve, _user);\\n            uint256 price = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(reserves[i]);\\n\\n            if (aTokenBalance > 0) {\\n            \\tuint256 userTokenBalanceEth = wmul(aTokenBalance, price) * (10 ** (18 - _getDecimals(reserve)));\\n            \\tdata.collAddr[collPos] = reserve;\\n                data.collAmounts[collPos] = userTokenBalanceEth;\\n                collPos++;\\n        \\t}\\n\\n            // Sum up debt in Eth\\n            if (borrowBalance > 0) {\\n            \\tuint256 userBorrowBalanceEth = wmul(borrowBalance, price) * (10 ** (18 - _getDecimals(reserve)));\\n                data.borrowAddr[borrowPos] = reserve;\\n                data.borrowAmounts[borrowPos] = userBorrowBalanceEth;\\n                borrowPos++;\\n            }\\n        }\\n\\n        data.ratio = uint128(getSafetyRatio(_user));\\n\\n        return data;\\n    }\\n\\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether\\n    /// @param _users Addresses of the user\\n    /// @return loans Array of LoanData information\\n    function getLoanDataArr(address[] memory _users) public view returns (LoanData[] memory loans) {\\n        loans = new LoanData[](_users.length);\\n\\n        for (uint i = 0; i < _users.length; ++i) {\\n            loans[i] = getLoanData(_users[i]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/exchangeV3/DFSExchange.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/GasTokenInterface.sol\\\";\\nimport \\\"./DFSExchangeCore.sol\\\";\\nimport \\\"../DS/DSMath.sol\\\";\\nimport \\\"../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../auth/AdminAuth.sol\\\";\\nimport \\\"../utils/GasBurner.sol\\\";\\nimport \\\"../utils/SafeERC20.sol\\\";\\n\\ncontract DFSExchange is DFSExchangeCore, AdminAuth, GasBurner {\\n\\n    using SafeERC20 for ERC20;\\n\\n    uint256 public constant SERVICE_FEE = 800; // 0.125% Fee\\n\\n    // solhint-disable-next-line const-name-snakecase\\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\\n\\n    uint public burnAmount = 10;\\n\\n    /// @notice Takes a src amount of tokens and converts it into the dest token\\n    /// @dev Takes fee from the _srcAmount before the exchange\\n    /// @param exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]\\n    /// @param _user User address who called the exchange\\n    function sell(ExchangeData memory exData, address payable _user) public payable burnGas(burnAmount) {\\n\\n        exData.dfsFeeDivider = SERVICE_FEE;\\n        exData.user = _user;\\n\\n        // Perform the exchange\\n        (address wrapper, uint destAmount) = _sell(exData);\\n\\n        // send back any leftover ether or tokens\\n        sendLeftover(exData.srcAddr, exData.destAddr, _user);\\n\\n        // log the event\\n        logger.Log(address(this), msg.sender, \\\"ExchangeSell\\\", abi.encode(wrapper, exData.srcAddr, exData.destAddr, exData.srcAmount, destAmount));\\n    }\\n\\n    /// @notice Takes a dest amount of tokens and converts it from the src token\\n    /// @dev Send always more than needed for the swap, extra will be returned\\n    /// @param exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]\\n    /// @param _user User address who called the exchange\\n    function buy(ExchangeData memory exData, address payable _user) public payable burnGas(burnAmount){\\n\\n        exData.dfsFeeDivider = SERVICE_FEE;\\n        exData.user = _user;\\n\\n        // Perform the exchange\\n        (address wrapper, uint srcAmount) = _buy(exData);\\n\\n        // send back any leftover ether or tokens\\n        sendLeftover(exData.srcAddr, exData.destAddr, _user);\\n\\n        // log the event\\n        logger.Log(address(this), msg.sender, \\\"ExchangeBuy\\\", abi.encode(wrapper, exData.srcAddr, exData.destAddr, srcAmount, exData.destAmount));\\n\\n    }\\n\\n    /// @notice Changes the amount of gas token we burn for each call\\n    /// @dev Only callable by the owner\\n    /// @param _newBurnAmount New amount of gas tokens to be burned\\n    function changeBurnAmount(uint _newBurnAmount) public {\\n        require(owner == msg.sender);\\n\\n        burnAmount = _newBurnAmount;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/exchangeV3/AllowanceProxyV3.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../auth/AdminAuth.sol\\\";\\nimport \\\"./DFSExchange.sol\\\";\\nimport \\\"../utils/SafeERC20.sol\\\";\\n\\ncontract AllowanceProxy is AdminAuth {\\n\\n    using SafeERC20 for ERC20;\\n\\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    DFSExchange dfsExchange = DFSExchange(0xc2Ce04e2FB4DD20964b4410FcE718b95963a1587);\\n\\n    function callSell(DFSExchangeCore.ExchangeData memory exData) public payable {\\n        pullAndSendTokens(exData.srcAddr, exData.srcAmount);\\n\\n        dfsExchange.sell{value: msg.value}(exData, msg.sender);\\n    }\\n\\n    function callBuy(DFSExchangeCore.ExchangeData memory exData) public payable {\\n        pullAndSendTokens(exData.srcAddr, exData.srcAmount);\\n\\n        dfsExchange.buy{value: msg.value}(exData, msg.sender);\\n    }\\n\\n    function pullAndSendTokens(address _tokenAddr, uint _amount) internal {\\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\\n            require(msg.value >= _amount, \\\"msg.value smaller than amount\\\");\\n        } else {\\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(dfsExchange), _amount);\\n        }\\n    }\\n\\n    function ownerChangeExchange(address payable _newExchange) public onlyOwner {\\n        dfsExchange = DFSExchange(_newExchange);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/compound/automatic/CompoundMonitor.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../utils/BotRegistry.sol\\\";\\nimport \\\"../../utils/GasBurner.sol\\\";\\nimport \\\"./CompoundMonitorProxy.sol\\\";\\nimport \\\"./CompoundSubscriptions.sol\\\";\\nimport \\\"../../interfaces/GasTokenInterface.sol\\\";\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../CompoundSafetyRatio.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeData.sol\\\";\\n\\n/// @title Contract implements logic of calling boost/repay in the automatic system\\ncontract CompoundMonitor is AdminAuth, DSMath, CompoundSafetyRatio, GasBurner {\\n\\n    using SafeERC20 for ERC20;\\n\\n    enum Method { Boost, Repay }\\n\\n    uint public REPAY_GAS_TOKEN = 20;\\n    uint public BOOST_GAS_TOKEN = 20;\\n\\n    uint constant public MAX_GAS_PRICE = 500000000000; // 500 gwei\\n\\n    uint public REPAY_GAS_COST = 1500000;\\n    uint public BOOST_GAS_COST = 1000000;\\n\\n    address public constant GAS_TOKEN_INTERFACE_ADDRESS = 0x0000000000b3F879cb30FE243b4Dfee438691c04;\\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\\n    address public constant BOT_REGISTRY_ADDRESS = 0x637726f8b08a7ABE3aE3aCaB01A80E2d8ddeF77B;\\n\\n    CompoundMonitorProxy public compoundMonitorProxy;\\n    CompoundSubscriptions public subscriptionsContract;\\n    address public compoundFlashLoanTakerAddress;\\n\\n    DefisaverLogger public logger = DefisaverLogger(DEFISAVER_LOGGER);\\n\\n    modifier onlyApproved() {\\n        require(BotRegistry(BOT_REGISTRY_ADDRESS).botList(msg.sender), \\\"Not auth bot\\\");\\n        _;\\n    }\\n\\n    /// @param _compoundMonitorProxy Proxy contracts that actually is authorized to call DSProxy\\n    /// @param _subscriptions Subscriptions contract for Compound positions\\n    /// @param _compoundFlashLoanTaker Contract that actually performs Repay/Boost\\n    constructor(address _compoundMonitorProxy, address _subscriptions, address _compoundFlashLoanTaker) public {\\n        compoundMonitorProxy = CompoundMonitorProxy(_compoundMonitorProxy);\\n        subscriptionsContract = CompoundSubscriptions(_subscriptions);\\n        compoundFlashLoanTakerAddress = _compoundFlashLoanTaker;\\n    }\\n\\n    /// @notice Bots call this method to repay for user when conditions are met\\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\\n    /// @param _exData Exchange data\\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\\n    /// @param _user The actual address that owns the Compound position\\n    function repayFor(\\n        DFSExchangeData.ExchangeData memory _exData,\\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\\n        address _user\\n    ) public payable onlyApproved burnGas(REPAY_GAS_TOKEN) {\\n\\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Repay, _user);\\n        require(isAllowed); // check if conditions are met\\n\\n        uint256 gasCost = calcGasCost(REPAY_GAS_COST);\\n\\n        compoundMonitorProxy.callExecute{value: msg.value}(\\n            _user,\\n            compoundFlashLoanTakerAddress,\\n            abi.encodeWithSignature(\\n                \\\"repayWithLoan((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),address[2],uint256)\\\",\\n                _exData,\\n                _cAddresses,\\n                gasCost\\n            )\\n        );\\n\\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Repay, _user);\\n        require(isGoodRatio); // check if the after result of the actions is good\\n\\n        returnEth();\\n\\n        logger.Log(address(this), _user, \\\"AutomaticCompoundRepay\\\", abi.encode(ratioBefore, ratioAfter));\\n    }\\n\\n    /// @notice Bots call this method to boost for user when conditions are met\\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\\n    /// @param _exData Exchange data\\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\\n    /// @param _user The actual address that owns the Compound position\\n    function boostFor(\\n        DFSExchangeData.ExchangeData memory _exData,\\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\\n        address _user\\n    ) public payable onlyApproved burnGas(BOOST_GAS_TOKEN) {\\n\\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Boost, _user);\\n        require(isAllowed); // check if conditions are met\\n\\n        uint256 gasCost = calcGasCost(BOOST_GAS_COST);\\n\\n        compoundMonitorProxy.callExecute{value: msg.value}(\\n            _user,\\n            compoundFlashLoanTakerAddress,\\n            abi.encodeWithSignature(\\n                \\\"boostWithLoan((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),address[2],uint256)\\\",\\n                _exData,\\n                _cAddresses,\\n                gasCost\\n            )\\n        );\\n\\n\\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Boost, _user);\\n        require(isGoodRatio);  // check if the after result of the actions is good\\n\\n        returnEth();\\n\\n        logger.Log(address(this), _user, \\\"AutomaticCompoundBoost\\\", abi.encode(ratioBefore, ratioAfter));\\n    }\\n\\n/******************* INTERNAL METHODS ********************************/\\n    function returnEth() internal {\\n        // return if some eth left\\n        if (address(this).balance > 0) {\\n            msg.sender.transfer(address(this).balance);\\n        }\\n    }\\n\\n/******************* STATIC METHODS ********************************/\\n\\n    /// @notice Checks if Boost/Repay could be triggered for the CDP\\n    /// @dev Called by MCDMonitor to enforce the min/max check\\n    /// @param _method Type of action to be called\\n    /// @param _user The actual address that owns the Compound position\\n    /// @return Boolean if it can be called and the ratio\\n    function canCall(Method _method, address _user) public view returns(bool, uint) {\\n        bool subscribed = subscriptionsContract.isSubscribed(_user);\\n        CompoundSubscriptions.CompoundHolder memory holder = subscriptionsContract.getHolder(_user);\\n\\n        // check if cdp is subscribed\\n        if (!subscribed) return (false, 0);\\n\\n        // check if boost and boost allowed\\n        if (_method == Method.Boost && !holder.boostEnabled) return (false, 0);\\n\\n        uint currRatio = getSafetyRatio(_user);\\n\\n        if (_method == Method.Repay) {\\n            return (currRatio < holder.minRatio, currRatio);\\n        } else if (_method == Method.Boost) {\\n            return (currRatio > holder.maxRatio, currRatio);\\n        }\\n    }\\n\\n    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call\\n    /// @param _method Type of action to be called\\n    /// @param _user The actual address that owns the Compound position\\n    /// @return Boolean if the recent action preformed correctly and the ratio\\n    function ratioGoodAfter(Method _method, address _user) public view returns(bool, uint) {\\n        CompoundSubscriptions.CompoundHolder memory holder;\\n\\n        holder= subscriptionsContract.getHolder(_user);\\n\\n        uint currRatio = getSafetyRatio(_user);\\n\\n        if (_method == Method.Repay) {\\n            return (currRatio < holder.maxRatio, currRatio);\\n        } else if (_method == Method.Boost) {\\n            return (currRatio > holder.minRatio, currRatio);\\n        }\\n    }\\n\\n    /// @notice Calculates gas cost (in Eth) of tx\\n    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP\\n    /// @param _gasAmount Amount of gas used for the tx\\n    function calcGasCost(uint _gasAmount) public view returns (uint) {\\n        uint gasPrice = tx.gasprice <= MAX_GAS_PRICE ? tx.gasprice : MAX_GAS_PRICE;\\n\\n        return mul(gasPrice, _gasAmount);\\n    }\\n\\n/******************* OWNER ONLY OPERATIONS ********************************/\\n\\n    /// @notice As the code is new, have a emergancy admin saver proxy change\\n    function changeCompoundFlashLoanTaker(address _newCompoundFlashLoanTakerAddress) public onlyAdmin {\\n        compoundFlashLoanTakerAddress = _newCompoundFlashLoanTakerAddress;\\n    }\\n\\n    /// @notice Allows owner to change gas cost for boost operation, but only up to 3 millions\\n    /// @param _gasCost New gas cost for boost method\\n    function changeBoostGasCost(uint _gasCost) public onlyOwner {\\n        require(_gasCost < 3000000);\\n\\n        BOOST_GAS_COST = _gasCost;\\n    }\\n\\n    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions\\n    /// @param _gasCost New gas cost for repay method\\n    function changeRepayGasCost(uint _gasCost) public onlyOwner {\\n        require(_gasCost < 3000000);\\n\\n        REPAY_GAS_COST = _gasCost;\\n    }\\n\\n    /// @notice If any tokens gets stuck in the contract owner can withdraw it\\n    /// @param _tokenAddress Address of the ERC20 token\\n    /// @param _to Address of the receiver\\n    /// @param _amount The amount to be sent\\n    function transferERC20(address _tokenAddress, address _to, uint _amount) public onlyOwner {\\n        ERC20(_tokenAddress).safeTransfer(_to, _amount);\\n    }\\n\\n    /// @notice If any Eth gets stuck in the contract owner can withdraw it\\n    /// @param _to Address of the receiver\\n    /// @param _amount The amount to be sent\\n    function transferEth(address payable _to, uint _amount) public onlyOwner {\\n        _to.transfer(_amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/compound/automatic/CompoundMonitorProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../interfaces/DSProxyInterface.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\n/// @title Contract with the actuall DSProxy permission calls the automation operations\\ncontract CompoundMonitorProxy is AdminAuth {\\n\\n    using SafeERC20 for ERC20;\\n\\n    uint public CHANGE_PERIOD;\\n    address public monitor;\\n    address public newMonitor;\\n    address public lastMonitor;\\n    uint public changeRequestedTimestamp;\\n\\n    mapping(address => bool) public allowed;\\n\\n    event MonitorChangeInitiated(address oldMonitor, address newMonitor);\\n    event MonitorChangeCanceled();\\n    event MonitorChangeFinished(address monitor);\\n    event MonitorChangeReverted(address monitor);\\n\\n    // if someone who is allowed become malicious, owner can't be changed\\n    modifier onlyAllowed() {\\n        require(allowed[msg.sender] || msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyMonitor() {\\n        require (msg.sender == monitor);\\n        _;\\n    }\\n\\n    constructor(uint _changePeriod) public {\\n        CHANGE_PERIOD = _changePeriod * 1 days;\\n    }\\n\\n    /// @notice Only monitor contract is able to call execute on users proxy\\n    /// @param _owner Address of cdp owner (users DSProxy address)\\n    /// @param _compoundSaverProxy Address of CompoundSaverProxy\\n    /// @param _data Data to send to CompoundSaverProxy\\n    function callExecute(address _owner, address _compoundSaverProxy, bytes memory _data) public payable onlyMonitor {\\n        // execute reverts if calling specific method fails\\n        DSProxyInterface(_owner).execute{value: msg.value}(_compoundSaverProxy, _data);\\n\\n        // return if anything left\\n        if (address(this).balance > 0) {\\n            msg.sender.transfer(address(this).balance);\\n        }\\n    }\\n\\n    /// @notice Allowed users are able to set Monitor contract without any waiting period first time\\n    /// @param _monitor Address of Monitor contract\\n    function setMonitor(address _monitor) public onlyAllowed {\\n        require(monitor == address(0));\\n        monitor = _monitor;\\n    }\\n\\n    /// @notice Allowed users are able to start procedure for changing monitor\\n    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change\\n    /// @param _newMonitor address of new monitor\\n    function changeMonitor(address _newMonitor) public onlyAllowed {\\n        require(changeRequestedTimestamp == 0);\\n\\n        changeRequestedTimestamp = now;\\n        lastMonitor = monitor;\\n        newMonitor = _newMonitor;\\n\\n        emit MonitorChangeInitiated(lastMonitor, newMonitor);\\n    }\\n\\n    /// @notice At any point allowed users are able to cancel monitor change\\n    function cancelMonitorChange() public onlyAllowed {\\n        require(changeRequestedTimestamp > 0);\\n\\n        changeRequestedTimestamp = 0;\\n        newMonitor = address(0);\\n\\n        emit MonitorChangeCanceled();\\n    }\\n\\n    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started\\n    function confirmNewMonitor() public onlyAllowed {\\n        require((changeRequestedTimestamp + CHANGE_PERIOD) < now);\\n        require(changeRequestedTimestamp != 0);\\n        require(newMonitor != address(0));\\n\\n        monitor = newMonitor;\\n        newMonitor = address(0);\\n        changeRequestedTimestamp = 0;\\n\\n        emit MonitorChangeFinished(monitor);\\n    }\\n\\n    /// @notice Its possible to revert monitor to last used monitor\\n    function revertMonitor() public onlyAllowed {\\n        require(lastMonitor != address(0));\\n\\n        monitor = lastMonitor;\\n\\n        emit MonitorChangeReverted(monitor);\\n    }\\n\\n\\n    /// @notice Allowed users are able to add new allowed user\\n    /// @param _user Address of user that will be allowed\\n    function addAllowed(address _user) public onlyAllowed {\\n        allowed[_user] = true;\\n    }\\n\\n    /// @notice Allowed users are able to remove allowed user\\n    /// @dev owner is always allowed even if someone tries to remove it from allowed mapping\\n    /// @param _user Address of allowed user\\n    function removeAllowed(address _user) public onlyAllowed {\\n        allowed[_user] = false;\\n    }\\n\\n    function setChangePeriod(uint _periodInDays) public onlyAllowed {\\n        require(_periodInDays * 1 days > CHANGE_PERIOD);\\n\\n        CHANGE_PERIOD = _periodInDays * 1 days;\\n    }\\n\\n    /// @notice In case something is left in contract, owner is able to withdraw it\\n    /// @param _token address of token to withdraw balance\\n    function withdrawToken(address _token) public onlyOwner {\\n        uint balance = ERC20(_token).balanceOf(address(this));\\n        ERC20(_token).safeTransfer(msg.sender, balance);\\n    }\\n\\n    /// @notice In case something is left in contract, owner is able to withdraw it\\n    function withdrawEth() public onlyOwner {\\n        uint balance = address(this).balance;\\n        msg.sender.transfer(balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/compound/automatic/CompoundSubscriptions.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../auth/AdminAuth.sol\\\";\\n\\n/// @title Stores subscription information for Compound automatization\\ncontract CompoundSubscriptions is AdminAuth {\\n\\n    struct CompoundHolder {\\n        address user;\\n        uint128 minRatio;\\n        uint128 maxRatio;\\n        uint128 optimalRatioBoost;\\n        uint128 optimalRatioRepay;\\n        bool boostEnabled;\\n    }\\n\\n    struct SubPosition {\\n        uint arrPos;\\n        bool subscribed;\\n    }\\n\\n    CompoundHolder[] public subscribers;\\n    mapping (address => SubPosition) public subscribersPos;\\n\\n    uint public changeIndex;\\n\\n    event Subscribed(address indexed user);\\n    event Unsubscribed(address indexed user);\\n    event Updated(address indexed user);\\n    event ParamUpdates(address indexed user, uint128, uint128, uint128, uint128, bool);\\n\\n    /// @dev Called by the DSProxy contract which owns the Compound position\\n    /// @notice Adds the users Compound poistion in the list of subscriptions so it can be monitored\\n    /// @param _minRatio Minimum ratio below which repay is triggered\\n    /// @param _maxRatio Maximum ratio after which boost is triggered\\n    /// @param _optimalBoost Ratio amount which boost should target\\n    /// @param _optimalRepay Ratio amount which repay should target\\n    /// @param _boostEnabled Boolean determing if boost is enabled\\n    function subscribe(uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled) external {\\n\\n        // if boost is not enabled, set max ratio to max uint\\n        uint128 localMaxRatio = _boostEnabled ? _maxRatio : uint128(-1);\\n        require(checkParams(_minRatio, localMaxRatio), \\\"Must be correct params\\\");\\n\\n        SubPosition storage subInfo = subscribersPos[msg.sender];\\n\\n        CompoundHolder memory subscription = CompoundHolder({\\n                minRatio: _minRatio,\\n                maxRatio: localMaxRatio,\\n                optimalRatioBoost: _optimalBoost,\\n                optimalRatioRepay: _optimalRepay,\\n                user: msg.sender,\\n                boostEnabled: _boostEnabled\\n            });\\n\\n        changeIndex++;\\n\\n        if (subInfo.subscribed) {\\n            subscribers[subInfo.arrPos] = subscription;\\n\\n            emit Updated(msg.sender);\\n            emit ParamUpdates(msg.sender, _minRatio, localMaxRatio, _optimalBoost, _optimalRepay, _boostEnabled);\\n        } else {\\n            subscribers.push(subscription);\\n\\n            subInfo.arrPos = subscribers.length - 1;\\n            subInfo.subscribed = true;\\n\\n            emit Subscribed(msg.sender);\\n        }\\n    }\\n\\n    /// @notice Called by the users DSProxy\\n    /// @dev Owner who subscribed cancels his subscription\\n    function unsubscribe() external {\\n        _unsubscribe(msg.sender);\\n    }\\n\\n    /// @dev Checks limit if minRatio is bigger than max\\n    /// @param _minRatio Minimum ratio, bellow which repay can be triggered\\n    /// @param _maxRatio Maximum ratio, over which boost can be triggered\\n    /// @return Returns bool if the params are correct\\n    function checkParams(uint128 _minRatio, uint128 _maxRatio) internal pure returns (bool) {\\n\\n        if (_minRatio > _maxRatio) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @dev Internal method to remove a subscriber from the list\\n    /// @param _user The actual address that owns the Compound position\\n    function _unsubscribe(address _user) internal {\\n        require(subscribers.length > 0, \\\"Must have subscribers in the list\\\");\\n\\n        SubPosition storage subInfo = subscribersPos[_user];\\n\\n        require(subInfo.subscribed, \\\"Must first be subscribed\\\");\\n\\n        address lastOwner = subscribers[subscribers.length - 1].user;\\n\\n        SubPosition storage subInfo2 = subscribersPos[lastOwner];\\n        subInfo2.arrPos = subInfo.arrPos;\\n\\n        subscribers[subInfo.arrPos] = subscribers[subscribers.length - 1];\\n        subscribers.pop(); // remove last element and reduce arr length\\n\\n        changeIndex++;\\n        subInfo.subscribed = false;\\n        subInfo.arrPos = 0;\\n\\n        emit Unsubscribed(msg.sender);\\n    }\\n\\n    /// @dev Checks if the user is subscribed\\n    /// @param _user The actual address that owns the Compound position\\n    /// @return If the user is subscribed\\n    function isSubscribed(address _user) public view returns (bool) {\\n        SubPosition storage subInfo = subscribersPos[_user];\\n\\n        return subInfo.subscribed;\\n    }\\n\\n    /// @dev Returns subscribtion information about a user\\n    /// @param _user The actual address that owns the Compound position\\n    /// @return Subscription information about the user if exists\\n    function getHolder(address _user) public view returns (CompoundHolder memory) {\\n        SubPosition storage subInfo = subscribersPos[_user];\\n\\n        return subscribers[subInfo.arrPos];\\n    }\\n\\n    /// @notice Helper method to return all the subscribed CDPs\\n    /// @return List of all subscribers\\n    function getSubscribers() public view returns (CompoundHolder[] memory) {\\n        return subscribers;\\n    }\\n\\n    /// @notice Helper method for the frontend, returns all the subscribed CDPs paginated\\n    /// @param _page What page of subscribers you want\\n    /// @param _perPage Number of entries per page\\n    /// @return List of all subscribers for that page\\n    function getSubscribersByPage(uint _page, uint _perPage) public view returns (CompoundHolder[] memory) {\\n        CompoundHolder[] memory holders = new CompoundHolder[](_perPage);\\n\\n        uint start = _page * _perPage;\\n        uint end = start + _perPage;\\n\\n        end = (end > holders.length) ? holders.length : end;\\n\\n        uint count = 0;\\n        for (uint i = start; i < end; i++) {\\n            holders[count] = subscribers[i];\\n            count++;\\n        }\\n\\n        return holders;\\n    }\\n\\n    ////////////// ADMIN METHODS ///////////////////\\n\\n    /// @notice Admin function to unsubscribe a CDP\\n    /// @param _user The actual address that owns the Compound position\\n    function unsubscribeByAdmin(address _user) public onlyOwner {\\n        SubPosition storage subInfo = subscribersPos[_user];\\n\\n        if (subInfo.subscribed) {\\n            _unsubscribe(_user);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/compound/CompoundSafetyRatio.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../DS/DSMath.sol\\\";\\nimport \\\"../interfaces/CompoundOracleInterface.sol\\\";\\nimport \\\"../interfaces/ComptrollerInterface.sol\\\";\\nimport \\\"../interfaces/CTokenInterface.sol\\\";\\nimport \\\"./helpers/Exponential.sol\\\";\\n\\n\\ncontract CompoundSafetyRatio is Exponential, DSMath {\\n    // solhint-disable-next-line const-name-snakecase\\n    ComptrollerInterface public constant comp = ComptrollerInterface(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\\n\\n    /// @notice Calcualted the ratio of debt / adjusted collateral\\n    /// @param _user Address of the user\\n    function getSafetyRatio(address _user) public view returns (uint) {\\n        // For each asset the account is in\\n        address[] memory assets = comp.getAssetsIn(_user);\\n        address oracleAddr = comp.oracle();\\n\\n\\n        uint sumCollateral = 0;\\n        uint sumBorrow = 0;\\n\\n        for (uint i = 0; i < assets.length; i++) {\\n            address asset = assets[i];\\n\\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\\n\\n            Exp memory oraclePrice;\\n\\n            if (cTokenBalance != 0 || borrowBalance != 0) {\\n                oraclePrice = Exp({mantissa: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(asset)});\\n            }\\n\\n            // Sum up collateral in Usd\\n            if (cTokenBalance != 0) {\\n\\n                (, uint collFactorMantissa) = comp.markets(address(asset));\\n\\n                Exp memory collateralFactor = Exp({mantissa: collFactorMantissa});\\n                Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\\n\\n                (, Exp memory tokensToUsd) = mulExp3(collateralFactor, exchangeRate, oraclePrice);\\n\\n                (, sumCollateral) = mulScalarTruncateAddUInt(tokensToUsd, cTokenBalance, sumCollateral);\\n            }\\n\\n            // Sum up debt in Usd\\n            if (borrowBalance != 0) {\\n                (, sumBorrow) = mulScalarTruncateAddUInt(oraclePrice, borrowBalance, sumBorrow);\\n            }\\n        }\\n\\n        if (sumBorrow == 0) return uint(-1);\\n\\n        uint borrowPowerUsed = (sumBorrow * 10**18) / sumCollateral;\\n        return wdiv(1e18, borrowPowerUsed);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/compound/CompoundLoanInfo.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./CompoundSafetyRatio.sol\\\";\\nimport \\\"./helpers/CompoundSaverHelper.sol\\\";\\n\\n\\n/// @title Gets data about Compound positions\\ncontract CompoundLoanInfo is CompoundSafetyRatio {\\n\\n    struct LoanData {\\n        address user;\\n        uint128 ratio;\\n        address[] collAddr;\\n        address[] borrowAddr;\\n        uint[] collAmounts;\\n        uint[] borrowAmounts;\\n    }\\n\\n    struct TokenInfo {\\n        address cTokenAddress;\\n        address underlyingTokenAddress;\\n        uint collateralFactor;\\n        uint price;\\n    }\\n\\n    struct TokenInfoFull {\\n        address underlyingTokenAddress;\\n        uint supplyRate;\\n        uint borrowRate;\\n        uint exchangeRate;\\n        uint marketLiquidity;\\n        uint totalSupply;\\n        uint totalBorrow;\\n        uint collateralFactor;\\n        uint price;\\n        uint borrowCap;\\n    }\\n\\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant CETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\\n\\n\\n    /// @notice Calcualted the ratio of coll/debt for a compound user\\n    /// @param _user Address of the user\\n    function getRatio(address _user) public view returns (uint) {\\n        // For each asset the account is in\\n        return getSafetyRatio(_user);\\n    }\\n\\n    /// @notice Fetches Compound prices for tokens\\n    /// @param _cTokens Arr. of cTokens for which to get the prices\\n    /// @return prices Array of prices\\n    function getPrices(address[] memory _cTokens) public view returns (uint[] memory prices) {\\n        prices = new uint[](_cTokens.length);\\n        address oracleAddr = comp.oracle();\\n\\n        for (uint i = 0; i < _cTokens.length; ++i) {\\n            prices[i] = CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokens[i]);\\n        }\\n    }\\n\\n    /// @notice Fetches Compound collateral factors for tokens\\n    /// @param _cTokens Arr. of cTokens for which to get the coll. factors\\n    /// @return collFactors Array of coll. factors\\n    function getCollFactors(address[] memory _cTokens) public view returns (uint[] memory collFactors) {\\n        collFactors = new uint[](_cTokens.length);\\n\\n        for (uint i = 0; i < _cTokens.length; ++i) {\\n            (, collFactors[i]) = comp.markets(_cTokens[i]);\\n        }\\n    }\\n\\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in usd\\n    /// @param _user Address of the user\\n    /// @return data LoanData information\\n    function getLoanData(address _user) public view returns (LoanData memory data) {\\n        address[] memory assets = comp.getAssetsIn(_user);\\n        address oracleAddr = comp.oracle();\\n\\n        data = LoanData({\\n            user: _user,\\n            ratio: 0,\\n            collAddr: new address[](assets.length),\\n            borrowAddr: new address[](assets.length),\\n            collAmounts: new uint[](assets.length),\\n            borrowAmounts: new uint[](assets.length)\\n        });\\n\\n        uint collPos = 0;\\n        uint borrowPos = 0;\\n\\n        for (uint i = 0; i < assets.length; i++) {\\n            address asset = assets[i];\\n\\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\\n\\n            Exp memory oraclePrice;\\n\\n            if (cTokenBalance != 0 || borrowBalance != 0) {\\n                oraclePrice = Exp({mantissa: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(asset)});\\n            }\\n\\n            // Sum up collateral in Usd\\n            if (cTokenBalance != 0) {\\n                Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\\n                (, Exp memory tokensToUsd) = mulExp(exchangeRate, oraclePrice);\\n\\n                data.collAddr[collPos] = asset;\\n                (, data.collAmounts[collPos]) = mulScalarTruncate(tokensToUsd, cTokenBalance);\\n                collPos++;\\n            }\\n\\n            // Sum up debt in Usd\\n            if (borrowBalance != 0) {\\n                data.borrowAddr[borrowPos] = asset;\\n                (, data.borrowAmounts[borrowPos]) = mulScalarTruncate(oraclePrice, borrowBalance);\\n                borrowPos++;\\n            }\\n        }\\n\\n        data.ratio = uint128(getSafetyRatio(_user));\\n\\n        return data;\\n    }\\n\\n    function getTokenBalances(address _user, address[] memory _cTokens) public view returns (uint[] memory balances, uint[] memory borrows) {\\n        balances = new uint[](_cTokens.length);\\n        borrows = new uint[](_cTokens.length);\\n\\n        for (uint i = 0; i < _cTokens.length; i++) {\\n            address asset = _cTokens[i];\\n\\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\\n\\n            Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\\n            (, balances[i]) = mulScalarTruncate(exchangeRate, cTokenBalance);\\n\\n            borrows[i] = borrowBalance;\\n        }\\n\\n    }\\n\\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in usd\\n    /// @param _users Addresses of the user\\n    /// @return loans Array of LoanData information\\n    function getLoanDataArr(address[] memory _users) public view returns (LoanData[] memory loans) {\\n        loans = new LoanData[](_users.length);\\n\\n        for (uint i = 0; i < _users.length; ++i) {\\n            loans[i] = getLoanData(_users[i]);\\n        }\\n    }\\n\\n    /// @notice Calcualted the ratio of coll/debt for a compound user\\n    /// @param _users Addresses of the user\\n    /// @return ratios Array of ratios\\n    function getRatios(address[] memory _users) public view returns (uint[] memory ratios) {\\n        ratios = new uint[](_users.length);\\n\\n        for (uint i = 0; i < _users.length; ++i) {\\n            ratios[i] = getSafetyRatio(_users[i]);\\n        }\\n    }\\n\\n    /// @notice Information about cTokens\\n    /// @param _cTokenAddresses Array of cTokens addresses\\n    /// @return tokens Array of cTokens infomartion\\n    function getTokensInfo(address[] memory _cTokenAddresses) public returns(TokenInfo[] memory tokens) {\\n        tokens = new TokenInfo[](_cTokenAddresses.length);\\n        address oracleAddr = comp.oracle();\\n\\n        for (uint i = 0; i < _cTokenAddresses.length; ++i) {\\n            (, uint collFactor) = comp.markets(_cTokenAddresses[i]);\\n\\n            tokens[i] = TokenInfo({\\n                cTokenAddress: _cTokenAddresses[i],\\n                underlyingTokenAddress: getUnderlyingAddr(_cTokenAddresses[i]),\\n                collateralFactor: collFactor,\\n                price: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokenAddresses[i])\\n            });\\n        }\\n    }\\n\\n    /// @notice Information about cTokens\\n    /// @param _cTokenAddresses Array of cTokens addresses\\n    /// @return tokens Array of cTokens infomartion\\n    function getFullTokensInfo(address[] memory _cTokenAddresses) public returns(TokenInfoFull[] memory tokens) {\\n        tokens = new TokenInfoFull[](_cTokenAddresses.length);\\n        address oracleAddr = comp.oracle();\\n\\n        for (uint i = 0; i < _cTokenAddresses.length; ++i) {\\n            (, uint collFactor) = comp.markets(_cTokenAddresses[i]);\\n            CTokenInterface cToken = CTokenInterface(_cTokenAddresses[i]);\\n\\n            tokens[i] = TokenInfoFull({\\n                underlyingTokenAddress: getUnderlyingAddr(_cTokenAddresses[i]),\\n                supplyRate: cToken.supplyRatePerBlock(),\\n                borrowRate: cToken.borrowRatePerBlock(),\\n                exchangeRate: cToken.exchangeRateCurrent(),\\n                marketLiquidity: cToken.getCash(),\\n                totalSupply: cToken.totalSupply(),\\n                totalBorrow: cToken.totalBorrowsCurrent(),\\n                collateralFactor: collFactor,\\n                price: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokenAddresses[i]),\\n                borrowCap: comp.borrowCaps(_cTokenAddresses[i])\\n            });\\n        }\\n    }\\n\\n    /// @notice Returns the underlying address of the cToken asset\\n    /// @param _cTokenAddress cToken address\\n    /// @return Token address of the cToken specified\\n    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\\n        if (_cTokenAddress == CETH_ADDRESS) {\\n            return ETH_ADDRESS;\\n        } else {\\n            return CTokenInterface(_cTokenAddress).underlying();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cream/import/CreamBorrowProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../interfaces/CTokenInterface.sol\\\";\\nimport \\\"../../interfaces/ComptrollerInterface.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\n\\ncontract CreamBorrowProxy {\\n\\n    using SafeERC20 for ERC20;\\n\\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant COMPTROLLER_ADDR = 0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258;\\n\\n    function borrow(address _cCollToken, address _cBorrowToken, address _borrowToken, uint _amount) public {\\n        address[] memory markets = new address[](2);\\n        markets[0] = _cCollToken;\\n        markets[1] = _cBorrowToken;\\n\\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\\n\\n        require(CTokenInterface(_cBorrowToken).borrow(_amount) == 0);\\n\\n        // withdraw funds to msg.sender\\n        if (_borrowToken != ETH_ADDR) {\\n            ERC20(_borrowToken).safeTransfer(msg.sender, ERC20(_borrowToken).balanceOf(address(this)));\\n        } else {\\n            msg.sender.transfer(address(this).balance);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cream/CreamSafetyRatio.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../DS/DSMath.sol\\\";\\nimport \\\"../interfaces/CompoundOracleInterface.sol\\\";\\nimport \\\"../interfaces/ComptrollerInterface.sol\\\";\\nimport \\\"../interfaces/CTokenInterface.sol\\\";\\nimport \\\"../compound/helpers/Exponential.sol\\\";\\n\\n\\ncontract CreamSafetyRatio is Exponential, DSMath {\\n    // solhint-disable-next-line const-name-snakecase\\n    ComptrollerInterface public constant comp = ComptrollerInterface(0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258);\\n\\n    /// @notice Calcualted the ratio of debt / adjusted collateral\\n    /// @param _user Address of the user\\n    function getSafetyRatio(address _user) public view returns (uint) {\\n        // For each asset the account is in\\n        address[] memory assets = comp.getAssetsIn(_user);\\n        address oracleAddr = comp.oracle();\\n\\n\\n        uint sumCollateral = 0;\\n        uint sumBorrow = 0;\\n\\n        for (uint i = 0; i < assets.length; i++) {\\n            address asset = assets[i];\\n\\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\\n\\n            Exp memory oraclePrice;\\n\\n            if (cTokenBalance != 0 || borrowBalance != 0) {\\n                oraclePrice = Exp({mantissa: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(asset)});\\n            }\\n\\n            // Sum up collateral in Eth\\n            if (cTokenBalance != 0) {\\n\\n                (, uint collFactorMantissa) = comp.markets(address(asset));\\n\\n                Exp memory collateralFactor = Exp({mantissa: collFactorMantissa});\\n                Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\\n\\n                (, Exp memory tokensToEther) = mulExp3(collateralFactor, exchangeRate, oraclePrice);\\n\\n                (, sumCollateral) = mulScalarTruncateAddUInt(tokensToEther, cTokenBalance, sumCollateral);\\n            }\\n\\n            // Sum up debt in Eth\\n            if (borrowBalance != 0) {\\n                (, sumBorrow) = mulScalarTruncateAddUInt(oraclePrice, borrowBalance, sumBorrow);\\n            }\\n        }\\n\\n        if (sumBorrow == 0) return uint(-1);\\n\\n        uint borrowPowerUsed = (sumBorrow * 10**18) / sumCollateral;\\n        return wdiv(1e18, borrowPowerUsed);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cream/CreamLoanInfo.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./CreamSafetyRatio.sol\\\";\\nimport \\\"./helpers/CreamSaverHelper.sol\\\";\\n\\n\\n/// @title Gets data about cream positions\\ncontract CreamLoanInfo is CreamSafetyRatio {\\n\\n    struct LoanData {\\n        address user;\\n        uint128 ratio;\\n        address[] collAddr;\\n        address[] borrowAddr;\\n        uint[] collAmounts;\\n        uint[] borrowAmounts;\\n    }\\n\\n    struct TokenInfo {\\n        address cTokenAddress;\\n        address underlyingTokenAddress;\\n        uint collateralFactor;\\n        uint price;\\n    }\\n\\n    struct TokenInfoFull {\\n        address underlyingTokenAddress;\\n        uint supplyRate;\\n        uint borrowRate;\\n        uint exchangeRate;\\n        uint marketLiquidity;\\n        uint totalSupply;\\n        uint totalBorrow;\\n        uint collateralFactor;\\n        uint price;\\n    }\\n\\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant CETH_ADDRESS = 0xD06527D5e56A3495252A528C4987003b712860eE;\\n\\n\\n    /// @notice Calcualted the ratio of coll/debt for a cream user\\n    /// @param _user Address of the user\\n    function getRatio(address _user) public view returns (uint) {\\n        // For each asset the account is in\\n        return getSafetyRatio(_user);\\n    }\\n\\n    /// @notice Fetches cream prices for tokens\\n    /// @param _cTokens Arr. of cTokens for which to get the prices\\n    /// @return prices Array of prices\\n    function getPrices(address[] memory _cTokens) public view returns (uint[] memory prices) {\\n        prices = new uint[](_cTokens.length);\\n        address oracleAddr = comp.oracle();\\n\\n        for (uint i = 0; i < _cTokens.length; ++i) {\\n            prices[i] = CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokens[i]);\\n        }\\n    }\\n\\n    /// @notice Fetches cream collateral factors for tokens\\n    /// @param _cTokens Arr. of cTokens for which to get the coll. factors\\n    /// @return collFactors Array of coll. factors\\n    function getCollFactors(address[] memory _cTokens) public view returns (uint[] memory collFactors) {\\n        collFactors = new uint[](_cTokens.length);\\n\\n        for (uint i = 0; i < _cTokens.length; ++i) {\\n            (, collFactors[i]) = comp.markets(_cTokens[i]);\\n        }\\n    }\\n\\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in eth\\n    /// @param _user Address of the user\\n    /// @return data LoanData information\\n    function getLoanData(address _user) public view returns (LoanData memory data) {\\n        address[] memory assets = comp.getAssetsIn(_user);\\n        address oracleAddr = comp.oracle();\\n\\n        data = LoanData({\\n            user: _user,\\n            ratio: 0,\\n            collAddr: new address[](assets.length),\\n            borrowAddr: new address[](assets.length),\\n            collAmounts: new uint[](assets.length),\\n            borrowAmounts: new uint[](assets.length)\\n        });\\n\\n        uint collPos = 0;\\n        uint borrowPos = 0;\\n\\n        for (uint i = 0; i < assets.length; i++) {\\n            address asset = assets[i];\\n\\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\\n\\n            Exp memory oraclePrice;\\n\\n            if (cTokenBalance != 0 || borrowBalance != 0) {\\n                oraclePrice = Exp({mantissa: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(asset)});\\n            }\\n\\n            // Sum up collateral in eth\\n            if (cTokenBalance != 0) {\\n                Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\\n                (, Exp memory tokensToEth) = mulExp(exchangeRate, oraclePrice);\\n\\n                data.collAddr[collPos] = asset;\\n                (, data.collAmounts[collPos]) = mulScalarTruncate(tokensToEth, cTokenBalance);\\n                collPos++;\\n            }\\n\\n            // Sum up debt in eth\\n            if (borrowBalance != 0) {\\n                data.borrowAddr[borrowPos] = asset;\\n                (, data.borrowAmounts[borrowPos]) = mulScalarTruncate(oraclePrice, borrowBalance);\\n                borrowPos++;\\n            }\\n        }\\n\\n        data.ratio = uint128(getSafetyRatio(_user));\\n\\n        return data;\\n    }\\n\\n    function getTokenBalances(address _user, address[] memory _cTokens) public view returns (uint[] memory balances, uint[] memory borrows) {\\n        balances = new uint[](_cTokens.length);\\n        borrows = new uint[](_cTokens.length);\\n\\n        for (uint i = 0; i < _cTokens.length; i++) {\\n            address asset = _cTokens[i];\\n\\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\\n\\n            Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\\n            (, balances[i]) = mulScalarTruncate(exchangeRate, cTokenBalance);\\n\\n            borrows[i] = borrowBalance;\\n        }\\n\\n    }\\n\\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in eth\\n    /// @param _users Addresses of the user\\n    /// @return loans Array of LoanData information\\n    function getLoanDataArr(address[] memory _users) public view returns (LoanData[] memory loans) {\\n        loans = new LoanData[](_users.length);\\n\\n        for (uint i = 0; i < _users.length; ++i) {\\n            loans[i] = getLoanData(_users[i]);\\n        }\\n    }\\n\\n    /// @notice Calcualted the ratio of coll/debt for a cream user\\n    /// @param _users Addresses of the user\\n    /// @return ratios Array of ratios\\n    function getRatios(address[] memory _users) public view returns (uint[] memory ratios) {\\n        ratios = new uint[](_users.length);\\n\\n        for (uint i = 0; i < _users.length; ++i) {\\n            ratios[i] = getSafetyRatio(_users[i]);\\n        }\\n    }\\n\\n    /// @notice Information about cTokens\\n    /// @param _cTokenAddresses Array of cTokens addresses\\n    /// @return tokens Array of cTokens infomartion\\n    function getTokensInfo(address[] memory _cTokenAddresses) public returns(TokenInfo[] memory tokens) {\\n        tokens = new TokenInfo[](_cTokenAddresses.length);\\n        address oracleAddr = comp.oracle();\\n\\n        for (uint i = 0; i < _cTokenAddresses.length; ++i) {\\n            (, uint collFactor) = comp.markets(_cTokenAddresses[i]);\\n\\n            tokens[i] = TokenInfo({\\n                cTokenAddress: _cTokenAddresses[i],\\n                underlyingTokenAddress: getUnderlyingAddr(_cTokenAddresses[i]),\\n                collateralFactor: collFactor,\\n                price: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokenAddresses[i])\\n            });\\n        }\\n    }\\n\\n    /// @notice Information about cTokens\\n    /// @param _cTokenAddresses Array of cTokens addresses\\n    /// @return tokens Array of cTokens infomartion\\n    function getFullTokensInfo(address[] memory _cTokenAddresses) public returns(TokenInfoFull[] memory tokens) {\\n        tokens = new TokenInfoFull[](_cTokenAddresses.length);\\n        address oracleAddr = comp.oracle();\\n\\n        for (uint i = 0; i < _cTokenAddresses.length; ++i) {\\n            (, uint collFactor) = comp.markets(_cTokenAddresses[i]);\\n            CTokenInterface cToken = CTokenInterface(_cTokenAddresses[i]);\\n\\n            tokens[i] = TokenInfoFull({\\n                underlyingTokenAddress: getUnderlyingAddr(_cTokenAddresses[i]),\\n                supplyRate: cToken.supplyRatePerBlock(),\\n                borrowRate: cToken.borrowRatePerBlock(),\\n                exchangeRate: cToken.exchangeRateCurrent(),\\n                marketLiquidity: cToken.getCash(),\\n                totalSupply: cToken.totalSupply(),\\n                totalBorrow: cToken.totalBorrowsCurrent(),\\n                collateralFactor: collFactor,\\n                price: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokenAddresses[i])\\n            });\\n        }\\n    }\\n\\n    /// @notice Returns the underlying address of the cToken asset\\n    /// @param _cTokenAddress cToken address\\n    /// @return Token address of the cToken specified\\n    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\\n        if (_cTokenAddress == CETH_ADDRESS) {\\n            return ETH_ADDRESS;\\n        } else {\\n            return CTokenInterface(_cTokenAddress).underlying();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cream/CreamBasicProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../utils/GasBurner.sol\\\";\\nimport \\\"../utils/SafeERC20.sol\\\";\\nimport \\\"../interfaces/CTokenInterface.sol\\\";\\nimport \\\"../interfaces/CEtherInterface.sol\\\";\\nimport \\\"../interfaces/ComptrollerInterface.sol\\\";\\n\\n/// @title Basic cream interactions through the DSProxy\\ncontract CreamBasicProxy is GasBurner {\\n\\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant COMPTROLLER_ADDR = 0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258;\\n\\n    using SafeERC20 for ERC20;\\n\\n    /// @notice User deposits tokens to the cream protocol\\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\\n    /// @param _tokenAddr The address of the token to be deposited\\n    /// @param _cTokenAddr CTokens to be deposited\\n    /// @param _amount Amount of tokens to be deposited\\n    /// @param _inMarket True if the token is already in market for that address\\n    function deposit(address _tokenAddr, address _cTokenAddr, uint _amount, bool _inMarket) public burnGas(5) payable {\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\\n        }\\n\\n        approveToken(_tokenAddr, _cTokenAddr);\\n\\n        if (!_inMarket) {\\n            enterMarket(_cTokenAddr);\\n        }\\n\\n        if (_tokenAddr != ETH_ADDR) {\\n            require(CTokenInterface(_cTokenAddr).mint(_amount) == 0);\\n        } else {\\n            CEtherInterface(_cTokenAddr).mint{value: msg.value}(); // reverts on fail\\n        }\\n    }\\n\\n    /// @notice User withdraws tokens to the cream protocol\\n    /// @param _tokenAddr The address of the token to be withdrawn\\n    /// @param _cTokenAddr CTokens to be withdrawn\\n    /// @param _amount Amount of tokens to be withdrawn\\n    /// @param _isCAmount If true _amount is cTokens if falls _amount is underlying tokens\\n    function withdraw(address _tokenAddr, address _cTokenAddr, uint _amount, bool _isCAmount) public burnGas(5) {\\n\\n        if (_isCAmount) {\\n            require(CTokenInterface(_cTokenAddr).redeem(_amount) == 0);\\n        } else {\\n            require(CTokenInterface(_cTokenAddr).redeemUnderlying(_amount) == 0);\\n        }\\n\\n        // withdraw funds to msg.sender\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\\n        } else {\\n            msg.sender.transfer(address(this).balance);\\n        }\\n\\n    }\\n\\n    /// @notice User borrows tokens to the cream protocol\\n    /// @param _tokenAddr The address of the token to be borrowed\\n    /// @param _cTokenAddr CTokens to be borrowed\\n    /// @param _amount Amount of tokens to be borrowed\\n    /// @param _inMarket True if the token is already in market for that address\\n    function borrow(address _tokenAddr, address _cTokenAddr, uint _amount, bool _inMarket) public burnGas(8) {\\n        if (!_inMarket) {\\n            enterMarket(_cTokenAddr);\\n        }\\n\\n        require(CTokenInterface(_cTokenAddr).borrow(_amount) == 0);\\n\\n        // withdraw funds to msg.sender\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\\n        } else {\\n            msg.sender.transfer(address(this).balance);\\n        }\\n    }\\n\\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\\n    /// @notice User paybacks tokens to the cream protocol\\n    /// @param _tokenAddr The address of the token to be paybacked\\n    /// @param _cTokenAddr CTokens to be paybacked\\n    /// @param _amount Amount of tokens to be payedback\\n    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt\\n    function payback(address _tokenAddr, address _cTokenAddr, uint _amount, bool _wholeDebt) public burnGas(5) payable {\\n        approveToken(_tokenAddr, _cTokenAddr);\\n\\n        if (_wholeDebt) {\\n            _amount = CTokenInterface(_cTokenAddr).borrowBalanceCurrent(address(this));\\n        }\\n\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\\n\\n            require(CTokenInterface(_cTokenAddr).repayBorrow(_amount) == 0);\\n        } else {\\n            CEtherInterface(_cTokenAddr).repayBorrow{value: msg.value}();\\n            msg.sender.transfer(address(this).balance); // send back the extra eth\\n        }\\n    }\\n\\n    /// @notice Helper method to withdraw tokens from the DSProxy\\n    /// @param _tokenAddr Address of the token to be withdrawn\\n    function withdrawTokens(address _tokenAddr) public {\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\\n        } else {\\n            msg.sender.transfer(address(this).balance);\\n        }\\n    }\\n\\n    /// @notice Enters the cream market so it can be deposited/borrowed\\n    /// @param _cTokenAddr CToken address of the token\\n    function enterMarket(address _cTokenAddr) public {\\n        address[] memory markets = new address[](1);\\n        markets[0] = _cTokenAddr;\\n\\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\\n    }\\n\\n    /// @notice Exits the cream market so it can't be deposited/borrowed\\n    /// @param _cTokenAddr CToken address of the token\\n    function exitMarket(address _cTokenAddr) public {\\n        ComptrollerInterface(COMPTROLLER_ADDR).exitMarket(_cTokenAddr);\\n    }\\n\\n    /// @notice Approves CToken contract to pull underlying tokens from the DSProxy\\n    /// @param _tokenAddr Token we are trying to approve\\n    /// @param _cTokenAddr Address which will gain the approval\\n    function approveToken(address _tokenAddr, address _cTokenAddr) internal {\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeApprove(_cTokenAddr, uint(-1));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/compound/CompoundBasicProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../utils/GasBurner.sol\\\";\\nimport \\\"../utils/SafeERC20.sol\\\";\\nimport \\\"../interfaces/CTokenInterface.sol\\\";\\nimport \\\"../interfaces/CEtherInterface.sol\\\";\\nimport \\\"../interfaces/ComptrollerInterface.sol\\\";\\n\\n/// @title Basic compound interactions through the DSProxy\\ncontract CompoundBasicProxy is GasBurner {\\n\\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant COMPTROLLER_ADDR = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\\n\\n    using SafeERC20 for ERC20;\\n\\n    /// @notice User deposits tokens to the Compound protocol\\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\\n    /// @param _tokenAddr The address of the token to be deposited\\n    /// @param _cTokenAddr CTokens to be deposited\\n    /// @param _amount Amount of tokens to be deposited\\n    /// @param _inMarket True if the token is already in market for that address\\n    function deposit(address _tokenAddr, address _cTokenAddr, uint _amount, bool _inMarket) public burnGas(5) payable {\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\\n        }\\n\\n        approveToken(_tokenAddr, _cTokenAddr);\\n\\n        if (!_inMarket) {\\n            enterMarket(_cTokenAddr);\\n        }\\n\\n        if (_tokenAddr != ETH_ADDR) {\\n            require(CTokenInterface(_cTokenAddr).mint(_amount) == 0);\\n        } else {\\n            CEtherInterface(_cTokenAddr).mint{value: msg.value}(); // reverts on fail\\n        }\\n    }\\n\\n    /// @notice User withdraws tokens to the Compound protocol\\n    /// @param _tokenAddr The address of the token to be withdrawn\\n    /// @param _cTokenAddr CTokens to be withdrawn\\n    /// @param _amount Amount of tokens to be withdrawn\\n    /// @param _isCAmount If true _amount is cTokens if falls _amount is underlying tokens\\n    function withdraw(address _tokenAddr, address _cTokenAddr, uint _amount, bool _isCAmount) public burnGas(5) {\\n\\n        if (_isCAmount) {\\n            require(CTokenInterface(_cTokenAddr).redeem(_amount) == 0);\\n        } else {\\n            require(CTokenInterface(_cTokenAddr).redeemUnderlying(_amount) == 0);\\n        }\\n\\n        // withdraw funds to msg.sender\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\\n        } else {\\n            msg.sender.transfer(address(this).balance);\\n        }\\n\\n    }\\n\\n    /// @notice User borrows tokens to the Compound protocol\\n    /// @param _tokenAddr The address of the token to be borrowed\\n    /// @param _cTokenAddr CTokens to be borrowed\\n    /// @param _amount Amount of tokens to be borrowed\\n    /// @param _inMarket True if the token is already in market for that address\\n    function borrow(address _tokenAddr, address _cTokenAddr, uint _amount, bool _inMarket) public burnGas(8) {\\n        if (!_inMarket) {\\n            enterMarket(_cTokenAddr);\\n        }\\n\\n        require(CTokenInterface(_cTokenAddr).borrow(_amount) == 0);\\n\\n        // withdraw funds to msg.sender\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\\n        } else {\\n            msg.sender.transfer(address(this).balance);\\n        }\\n    }\\n\\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\\n    /// @notice User paybacks tokens to the Compound protocol\\n    /// @param _tokenAddr The address of the token to be paybacked\\n    /// @param _cTokenAddr CTokens to be paybacked\\n    /// @param _amount Amount of tokens to be payedback\\n    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt\\n    function payback(address _tokenAddr, address _cTokenAddr, uint _amount, bool _wholeDebt) public burnGas(5) payable {\\n        approveToken(_tokenAddr, _cTokenAddr);\\n\\n        if (_wholeDebt) {\\n            _amount = CTokenInterface(_cTokenAddr).borrowBalanceCurrent(address(this));\\n        }\\n\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\\n\\n            require(CTokenInterface(_cTokenAddr).repayBorrow(_amount) == 0);\\n        } else {\\n            CEtherInterface(_cTokenAddr).repayBorrow{value: msg.value}();\\n            msg.sender.transfer(address(this).balance); // send back the extra eth\\n        }\\n    }\\n\\n    /// @notice Helper method to withdraw tokens from the DSProxy\\n    /// @param _tokenAddr Address of the token to be withdrawn\\n    function withdrawTokens(address _tokenAddr) public {\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\\n        } else {\\n            msg.sender.transfer(address(this).balance);\\n        }\\n    }\\n\\n    /// @notice Enters the Compound market so it can be deposited/borrowed\\n    /// @param _cTokenAddr CToken address of the token\\n    function enterMarket(address _cTokenAddr) public {\\n        address[] memory markets = new address[](1);\\n        markets[0] = _cTokenAddr;\\n\\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\\n    }\\n\\n    /// @notice Exits the Compound market so it can't be deposited/borrowed\\n    /// @param _cTokenAddr CToken address of the token\\n    function exitMarket(address _cTokenAddr) public {\\n        ComptrollerInterface(COMPTROLLER_ADDR).exitMarket(_cTokenAddr);\\n    }\\n\\n    /// @notice Approves CToken contract to pull underlying tokens from the DSProxy\\n    /// @param _tokenAddr Token we are trying to approve\\n    /// @param _cTokenAddr Address which will gain the approval\\n    function approveToken(address _tokenAddr, address _cTokenAddr) internal {\\n        if (_tokenAddr != ETH_ADDR) {\\n            ERC20(_tokenAddr).safeApprove(_cTokenAddr, uint(-1));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/compound/comp/CompLeverage.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./CompBalance.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeCore.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../interfaces/DSProxyInterface.sol\\\";\\nimport \\\"../CompoundBasicProxy.sol\\\";\\n\\ncontract CompLeverage is DFSExchangeCore, CompBalance {\\n    address public constant C_COMP_ADDR = 0x70e36f6BF80a52b3B46b3aF8e106CC0ed743E8e4;\\n\\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant CETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\\n    address public constant COMPTROLLER_ADDR = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\\n\\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\\n\\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\\n\\n    /// @notice Should claim COMP and sell it to the specified token and deposit it back\\n    /// @param exchangeData Standard Exchange struct\\n    /// @param _cTokensSupply List of cTokens user is supplying\\n    /// @param _cTokensBorrow List of cTokens user is borrowing\\n    /// @param _cDepositAddr The cToken address of the asset you want to deposit\\n    /// @param _inMarket Flag if the cToken is used as collateral\\n    function claimAndSell(\\n        ExchangeData memory exchangeData,\\n        address[] memory _cTokensSupply,\\n        address[] memory _cTokensBorrow,\\n        address _cDepositAddr,\\n        bool _inMarket\\n    ) public payable {\\n        // Claim COMP token\\n        _claim(address(this), _cTokensSupply, _cTokensBorrow);\\n\\n        uint compBalance = ERC20(COMP_ADDR).balanceOf(address(this));\\n        uint depositAmount = 0;\\n\\n        // Exchange COMP\\n        if (exchangeData.srcAddr != address(0)) {\\n            exchangeData.user = msg.sender;\\n            exchangeData.dfsFeeDivider = 400; // 0.25%\\n            exchangeData.srcAmount = compBalance;\\n\\n            (, depositAmount) = _sell(exchangeData);\\n\\n            // if we have no deposit after, send back tokens to the user\\n            if (_cDepositAddr == address(0)) {\\n                if (exchangeData.destAddr != ETH_ADDRESS) {\\n                    ERC20(exchangeData.destAddr).safeTransfer(msg.sender, depositAmount);\\n                } else {\\n                    msg.sender.transfer(address(this).balance);\\n                }\\n            }\\n        }\\n\\n        // Deposit back a token\\n        if (_cDepositAddr != address(0)) {\\n            // if we are just depositing COMP without a swap\\n            if (_cDepositAddr == C_COMP_ADDR) {\\n                depositAmount = compBalance;\\n            }\\n\\n            address tokenAddr = getUnderlyingAddr(_cDepositAddr);\\n            deposit(tokenAddr, _cDepositAddr, depositAmount, _inMarket);\\n        }\\n\\n        logger.Log(address(this), msg.sender, \\\"CompLeverage\\\", abi.encode(compBalance, depositAmount, _cDepositAddr, exchangeData.destAmount));\\n    }\\n\\n    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\\n        if (_cTokenAddress == CETH_ADDRESS) {\\n            return ETH_ADDRESS;\\n        } else {\\n            return CTokenInterface(_cTokenAddress).underlying();\\n        }\\n    }\\n\\n    function deposit(address _tokenAddr, address _cTokenAddr, uint _amount, bool _inMarket) public burnGas(5) payable {\\n        approveToken(_tokenAddr, _cTokenAddr);\\n\\n        if (!_inMarket) {\\n            enterMarket(_cTokenAddr);\\n        }\\n\\n        if (_tokenAddr != ETH_ADDRESS) {\\n            require(CTokenInterface(_cTokenAddr).mint(_amount) == 0);\\n        } else {\\n            CEtherInterface(_cTokenAddr).mint{value: _amount}(); // reverts on fail\\n        }\\n    }\\n\\n     function enterMarket(address _cTokenAddr) public {\\n        address[] memory markets = new address[](1);\\n        markets[0] = _cTokenAddr;\\n\\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\\n    }\\n\\n    function approveToken(address _tokenAddr, address _cTokenAddr) internal {\\n        if (_tokenAddr != ETH_ADDRESS) {\\n            ERC20(_tokenAddr).safeApprove(_cTokenAddr, uint(-1));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/compound/comp/CompBalance.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../helpers/Exponential.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../utils/GasBurner.sol\\\";\\nimport \\\"../../interfaces/CTokenInterface.sol\\\";\\nimport \\\"../../interfaces/ComptrollerInterface.sol\\\";\\n\\ncontract CompBalance is Exponential, GasBurner {\\n    ComptrollerInterface public constant comp = ComptrollerInterface(\\n        0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B\\n    );\\n    address public constant COMP_ADDR = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\\n    uint224 public constant compInitialIndex = 1e36;\\n\\n    function claimComp(\\n        address _user,\\n        address[] memory _cTokensSupply,\\n        address[] memory _cTokensBorrow\\n    ) public burnGas(8) {\\n        _claim(_user, _cTokensSupply, _cTokensBorrow);\\n\\n        ERC20(COMP_ADDR).transfer(msg.sender, ERC20(COMP_ADDR).balanceOf(address(this)));\\n    }\\n\\n    function _claim(\\n        address _user,\\n        address[] memory _cTokensSupply,\\n        address[] memory _cTokensBorrow\\n    ) internal {\\n        address[] memory u = new address[](1);\\n        u[0] = _user;\\n\\n        comp.claimComp(u, _cTokensSupply, false, true);\\n        comp.claimComp(u, _cTokensBorrow, true, false);\\n    }\\n\\n    function getBalance(address _user, address[] memory _cTokens) public view returns (uint256) {\\n        uint256 compBalance = 0;\\n\\n        for (uint256 i = 0; i < _cTokens.length; ++i) {\\n            compBalance += getSuppyBalance(_cTokens[i], _user);\\n            compBalance += getBorrowBalance(_cTokens[i], _user);\\n        }\\n\\n        compBalance = add_(comp.compAccrued(_user), compBalance);\\n\\n        compBalance += ERC20(COMP_ADDR).balanceOf(_user);\\n\\n        return compBalance;\\n    }\\n\\n    function getClaimableAssets(address[] memory _cTokens, address _user)\\n        public\\n        view\\n        returns (bool[] memory supplyClaims, bool[] memory borrowClaims)\\n    {\\n        supplyClaims = new bool[](_cTokens.length);\\n        borrowClaims = new bool[](_cTokens.length);\\n\\n        for (uint256 i = 0; i < _cTokens.length; ++i) {\\n            supplyClaims[i] = getSuppyBalance(_cTokens[i], _user) > 0;\\n            borrowClaims[i] = getBorrowBalance(_cTokens[i], _user) > 0;\\n        }\\n    }\\n\\n    function getSuppyBalance(address _cToken, address _supplier)\\n        public\\n        view\\n        returns (uint256 supplierAccrued)\\n    {\\n        ComptrollerInterface.CompMarketState memory supplyState = comp.compSupplyState(_cToken);\\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\\n        Double memory supplierIndex = Double({\\n            mantissa: comp.compSupplierIndex(_cToken, _supplier)\\n        });\\n\\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\\n            supplierIndex.mantissa = compInitialIndex;\\n        }\\n\\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\\n        uint256 supplierTokens = CTokenInterface(_cToken).balanceOf(_supplier);\\n        uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\\n        supplierAccrued = supplierDelta;\\n    }\\n\\n    function getBorrowBalance(address _cToken, address _borrower)\\n        public\\n        view\\n        returns (uint256 borrowerAccrued)\\n    {\\n        ComptrollerInterface.CompMarketState memory borrowState = comp.compBorrowState(_cToken);\\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\\n        Double memory borrowerIndex = Double({\\n            mantissa: comp.compBorrowerIndex(_cToken, _borrower)\\n        });\\n\\n        Exp memory marketBorrowIndex = Exp({mantissa: CTokenInterface(_cToken).borrowIndex()});\\n\\n        if (borrowerIndex.mantissa > 0) {\\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\\n            uint256 borrowerAmount = div_(\\n                CTokenInterface(_cToken).borrowBalanceStored(_borrower),\\n                marketBorrowIndex\\n            );\\n            uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);\\n            borrowerAccrued = borrowerDelta;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/compound/import/CompoundBorrowProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../interfaces/ERC20.sol\\\";\\nimport \\\"../../interfaces/CTokenInterface.sol\\\";\\nimport \\\"../../interfaces/ComptrollerInterface.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\n\\ncontract CompoundBorrowProxy {\\n\\n    using SafeERC20 for ERC20;\\n\\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant COMPTROLLER_ADDR = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\\n\\n    function borrow(address _cCollToken, address _cBorrowToken, address _borrowToken, uint _amount) public {\\n        address[] memory markets = new address[](2);\\n        markets[0] = _cCollToken;\\n        markets[1] = _cBorrowToken;\\n\\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\\n\\n        require(CTokenInterface(_cBorrowToken).borrow(_amount) == 0);\\n\\n        // withdraw funds to msg.sender\\n        if (_borrowToken != ETH_ADDR) {\\n            ERC20(_borrowToken).safeTransfer(msg.sender, ERC20(_borrowToken).balanceOf(address(this)));\\n        } else {\\n            msg.sender.transfer(address(this).balance);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/AllowanceProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../auth/AdminAuth.sol\\\";\\nimport \\\"./SaverExchange.sol\\\";\\nimport \\\"../utils/SafeERC20.sol\\\";\\n\\ncontract AllowanceProxy is AdminAuth {\\n\\n    using SafeERC20 for ERC20;\\n\\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    // TODO: Real saver exchange address\\n    SaverExchange saverExchange = SaverExchange(0x235abFAd01eb1BDa28Ef94087FBAA63E18074926);\\n\\n    function callSell(SaverExchangeCore.ExchangeData memory exData) public payable {\\n        pullAndSendTokens(exData.srcAddr, exData.srcAmount);\\n\\n        saverExchange.sell{value: msg.value}(exData, msg.sender);\\n    }\\n\\n    function callBuy(SaverExchangeCore.ExchangeData memory exData) public payable {\\n        pullAndSendTokens(exData.srcAddr, exData.srcAmount);\\n\\n        saverExchange.buy{value: msg.value}(exData, msg.sender);\\n    }\\n\\n    function pullAndSendTokens(address _tokenAddr, uint _amount) internal {\\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\\n            require(msg.value >= _amount, \\\"msg.value smaller than amount\\\");\\n        } else {\\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(saverExchange), _amount);\\n        }\\n    }\\n\\n    function ownerChangeExchange(address payable _newExchange) public onlyOwner {\\n        saverExchange = SaverExchange(_newExchange);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cream/saver/CreamSaverProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../exchange/SaverExchangeCore.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../helpers/CreamSaverHelper.sol\\\";\\n\\n/// @title Contract that implements repay/boost functionality\\ncontract CreamSaverProxy is CreamSaverHelper, SaverExchangeCore {\\n\\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\\n\\n    /// @notice Withdraws collateral, converts to borrowed token and repays debt\\n    /// @dev Called through the DSProxy\\n    /// @param _exData Exchange data\\n    /// @param _cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]\\n    /// @param _gasCost Gas cost for specific transaction\\n    function repay(\\n        ExchangeData memory _exData,\\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\\n        uint256 _gasCost\\n    ) public payable {\\n        enterMarket(_cAddresses[0], _cAddresses[1]);\\n\\n        address payable user = payable(getUserAddress());\\n\\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\\n\\n        uint collAmount = (_exData.srcAmount > maxColl) ? maxColl : _exData.srcAmount;\\n\\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(collAmount) == 0);\\n\\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\\n\\n        uint swapAmount = 0;\\n\\n        if (collToken != borrowToken) {\\n            (, swapAmount) = _sell(_exData);\\n            swapAmount -= getFee(swapAmount, user, _gasCost, _cAddresses[1]);\\n        } else {\\n            swapAmount = collAmount;\\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\\n        }\\n\\n        paybackDebt(swapAmount, _cAddresses[1], borrowToken, user);\\n\\n        // handle 0x fee\\n        tx.origin.transfer(address(this).balance);\\n\\n        // log amount, collToken, borrowToken\\n        logger.Log(address(this), msg.sender, \\\"CreamRepay\\\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\\n    }\\n\\n    /// @notice Borrows token, converts to collateral, and adds to position\\n    /// @dev Called through the DSProxy\\n    /// @param _exData Exchange data\\n    /// @param _cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]\\n    /// @param _gasCost Gas cost for specific transaction\\n    function boost(\\n        ExchangeData memory _exData,\\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\\n        uint256 _gasCost\\n    ) public payable {\\n        enterMarket(_cAddresses[0], _cAddresses[1]);\\n\\n        address payable user = payable(getUserAddress());\\n\\n        uint maxBorrow = getMaxBorrow(_cAddresses[1], address(this));\\n        uint borrowAmount = (_exData.srcAmount > maxBorrow) ? maxBorrow : _exData.srcAmount;\\n\\n        require(CTokenInterface(_cAddresses[1]).borrow(borrowAmount) == 0);\\n\\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\\n\\n        uint swapAmount = 0;\\n\\n        if (collToken != borrowToken) {\\n            borrowAmount -= getFee(borrowAmount, user, _gasCost, _cAddresses[1]);\\n\\n            _exData.srcAmount = borrowAmount;\\n            (,swapAmount) = _sell(_exData);\\n        } else {\\n            swapAmount = borrowAmount;\\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\\n        }\\n\\n        approveCToken(collToken, _cAddresses[0]);\\n\\n        if (collToken != ETH_ADDRESS) {\\n            require(CTokenInterface(_cAddresses[0]).mint(swapAmount) == 0);\\n        } else {\\n            CEtherInterface(_cAddresses[0]).mint{value: swapAmount}(); // reverts on fail\\n        }\\n\\n        // handle 0x fee\\n        tx.origin.transfer(address(this).balance);\\n\\n        // log amount, collToken, borrowToken\\n        logger.Log(address(this), msg.sender, \\\"CreamBoost\\\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/cream/saver/CreamFlashLoanTaker.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../utils/GasBurner.sol\\\";\\nimport \\\"../../interfaces/ILendingPool.sol\\\";\\nimport \\\"./CreamSaverProxy.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../auth/ProxyPermission.sol\\\";\\n\\n/// @title Entry point for the FL Repay Boosts, called by DSProxy\\ncontract CreamFlashLoanTaker is CreamSaverProxy, ProxyPermission, GasBurner {\\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\\n\\n    address payable public constant COMPOUND_SAVER_FLASH_LOAN = 0x3ceD2067c0B057611e4E2686Dbe40028962Cc625;\\n    address public constant AAVE_POOL_CORE = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\\n\\n    /// @notice Repays the position with it's own fund or with FL if needed\\n    /// @param _exData Exchange data\\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\\n    /// @param _gasCost Gas cost for specific transaction\\n    function repayWithLoan(\\n        ExchangeData memory _exData,\\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\\n        uint256 _gasCost\\n    ) public payable burnGas(25) {\\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\\n        uint availableLiquidity = getAvailableLiquidity(_exData.srcAddr);\\n\\n        if (_exData.srcAmount <= maxColl || availableLiquidity == 0) {\\n            repay(_exData, _cAddresses, _gasCost);\\n        } else {\\n            // 0x fee\\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\\n\\n            uint loanAmount = (_exData.srcAmount - maxColl);\\n            bytes memory encoded = packExchangeData(_exData);\\n            bytes memory paramsData = abi.encode(encoded, _cAddresses, _gasCost, true, address(this));\\n\\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\\n\\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_cAddresses[0]), loanAmount, paramsData);\\n\\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\\n\\n            logger.Log(address(this), msg.sender, \\\"CreamFlashRepay\\\", abi.encode(loanAmount, _exData.srcAmount, _cAddresses[0]));\\n        }\\n    }\\n\\n    /// @notice Boosts the position with it's own fund or with FL if needed\\n    /// @param _exData Exchange data\\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\\n    /// @param _gasCost Gas cost for specific transaction\\n    function boostWithLoan(\\n        ExchangeData memory _exData,\\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\\n        uint256 _gasCost\\n    ) public payable burnGas(20) {\\n        uint maxBorrow = getMaxBorrow(_cAddresses[1], address(this));\\n        uint availableLiquidity = getAvailableLiquidity(_exData.srcAddr);\\n\\n        if (_exData.srcAmount <= maxBorrow || availableLiquidity == 0) {\\n            boost(_exData, _cAddresses, _gasCost);\\n        } else {\\n            // 0x fee\\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\\n\\n            uint loanAmount = (_exData.srcAmount - maxBorrow);\\n            bytes memory paramsData = abi.encode(packExchangeData(_exData), _cAddresses, _gasCost, false, address(this));\\n\\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\\n\\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_cAddresses[1]), loanAmount, paramsData);\\n\\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\\n\\n            logger.Log(address(this), msg.sender, \\\"CreamFlashBoost\\\", abi.encode(loanAmount, _exData.srcAmount, _cAddresses[1]));\\n        }\\n\\n    }\\n\\n    function getAvailableLiquidity(address _tokenAddr) internal view returns (uint liquidity) {\\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\\n            liquidity = AAVE_POOL_CORE.balance;\\n        } else {\\n            liquidity = ERC20(_tokenAddr).balanceOf(AAVE_POOL_CORE);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/compound/saver/CompoundFlashLoanTaker.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../utils/GasBurner.sol\\\";\\nimport \\\"../../interfaces/ILendingPool.sol\\\";\\nimport \\\"./CompoundSaverProxy.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../auth/ProxyPermission.sol\\\";\\n\\n/// @title Entry point for the FL Repay Boosts, called by DSProxy\\ncontract CompoundFlashLoanTaker is CompoundSaverProxy, ProxyPermission, GasBurner {\\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\\n\\n    address payable public constant COMPOUND_SAVER_FLASH_LOAN = 0xAd9b95B3C3645df1008118FA118195C446F967e8;\\n    address public constant AAVE_POOL_CORE = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\\n\\n    /// @notice Repays the position with it's own fund or with FL if needed\\n    /// @param _exData Exchange data\\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\\n    /// @param _gasCost Gas cost for specific transaction\\n    function repayWithLoan(\\n        ExchangeData memory _exData,\\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\\n        uint256 _gasCost\\n    ) public payable burnGas(25) {\\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\\n        uint availableLiquidity = getAvailableLiquidity(_exData.srcAddr);\\n\\n        if (_exData.srcAmount <= maxColl || availableLiquidity == 0) {\\n            repay(_exData, _cAddresses, _gasCost);\\n        } else {\\n            // 0x fee\\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\\n\\n            uint loanAmount = (_exData.srcAmount - maxColl);\\n            if (loanAmount > availableLiquidity) loanAmount = availableLiquidity;\\n            bytes memory encoded = packExchangeData(_exData);\\n            bytes memory paramsData = abi.encode(encoded, _cAddresses, _gasCost, true, address(this));\\n\\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\\n\\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_cAddresses[0]), loanAmount, paramsData);\\n\\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\\n\\n            logger.Log(address(this), msg.sender, \\\"CompoundFlashRepay\\\", abi.encode(loanAmount, _exData.srcAmount, _cAddresses[0]));\\n        }\\n    }\\n\\n    /// @notice Boosts the position with it's own fund or with FL if needed\\n    /// @param _exData Exchange data\\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\\n    /// @param _gasCost Gas cost for specific transaction\\n    function boostWithLoan(\\n        ExchangeData memory _exData,\\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\\n        uint256 _gasCost\\n    ) public payable burnGas(20) {\\n        uint maxBorrow = getMaxBorrow(_cAddresses[1], address(this));\\n        uint availableLiquidity = getAvailableLiquidity(_exData.srcAddr);\\n\\n        if (_exData.srcAmount <= maxBorrow || availableLiquidity == 0) {\\n            boost(_exData, _cAddresses, _gasCost);\\n        } else {\\n            // 0x fee\\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\\n\\n            uint loanAmount = (_exData.srcAmount - maxBorrow);\\n            if (loanAmount > availableLiquidity) loanAmount = availableLiquidity;\\n            bytes memory paramsData = abi.encode(packExchangeData(_exData), _cAddresses, _gasCost, false, address(this));\\n\\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\\n\\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_cAddresses[1]), loanAmount, paramsData);\\n\\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\\n\\n            logger.Log(address(this), msg.sender, \\\"CompoundFlashBoost\\\", abi.encode(loanAmount, _exData.srcAmount, _cAddresses[1]));\\n        }\\n\\n    }\\n\\n    function getAvailableLiquidity(address _tokenAddr) internal view returns (uint liquidity) {\\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\\n            liquidity = AAVE_POOL_CORE.balance;\\n        } else {\\n            liquidity = ERC20(_tokenAddr).balanceOf(AAVE_POOL_CORE);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/compound/saver/CompoundSaverProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../exchangeV3/DFSExchangeCore.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../helpers/CompoundSaverHelper.sol\\\";\\n\\n/// @title Contract that implements repay/boost functionality\\ncontract CompoundSaverProxy is CompoundSaverHelper, DFSExchangeCore {\\n\\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\\n\\n    /// @notice Withdraws collateral, converts to borrowed token and repays debt\\n    /// @dev Called through the DSProxy\\n    /// @param _exData Exchange data\\n    /// @param _cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]\\n    /// @param _gasCost Gas cost for specific transaction\\n    function repay(\\n        ExchangeData memory _exData,\\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\\n        uint256 _gasCost\\n    ) public payable {\\n        enterMarket(_cAddresses[0], _cAddresses[1]);\\n\\n        address payable user = payable(getUserAddress());\\n\\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\\n\\n        uint collAmount = (_exData.srcAmount > maxColl) ? maxColl : _exData.srcAmount;\\n\\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(collAmount) == 0);\\n\\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\\n\\n        uint swapAmount = 0;\\n\\n        if (collToken != borrowToken) {\\n            _exData.srcAmount = collAmount;\\n            _exData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\\n            _exData.user = user;\\n\\n            (, swapAmount) = _sell(_exData);\\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[0]);\\n        } else {\\n            swapAmount = collAmount;\\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[0]);\\n        }\\n\\n        paybackDebt(swapAmount, _cAddresses[1], borrowToken, user);\\n\\n        // handle 0x fee\\n        tx.origin.transfer(address(this).balance);\\n\\n        // log amount, collToken, borrowToken\\n        logger.Log(address(this), msg.sender, \\\"CompoundRepay\\\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\\n    }\\n\\n    /// @notice Borrows token, converts to collateral, and adds to position\\n    /// @dev Called through the DSProxy\\n    /// @param _exData Exchange data\\n    /// @param _cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]\\n    /// @param _gasCost Gas cost for specific transaction\\n    function boost(\\n        ExchangeData memory _exData,\\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\\n        uint256 _gasCost\\n    ) public payable {\\n        enterMarket(_cAddresses[0], _cAddresses[1]);\\n\\n        address payable user = payable(getUserAddress());\\n\\n        uint maxBorrow = getMaxBorrow(_cAddresses[1], address(this));\\n        uint borrowAmount = (_exData.srcAmount > maxBorrow) ? maxBorrow : _exData.srcAmount;\\n\\n        require(CTokenInterface(_cAddresses[1]).borrow(borrowAmount) == 0);\\n\\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\\n\\n        uint swapAmount = 0;\\n\\n        if (collToken != borrowToken) {\\n            _exData.dfsFeeDivider = isAutomation() ? AUTOMATIC_SERVICE_FEE : MANUAL_SERVICE_FEE;\\n            _exData.user = user;\\n\\n            _exData.srcAmount = borrowAmount;\\n            (, swapAmount) = _sell(_exData);\\n\\n             swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\\n        } else {\\n            swapAmount = borrowAmount;\\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\\n        }\\n\\n        approveCToken(collToken, _cAddresses[0]);\\n\\n        if (collToken != ETH_ADDRESS) {\\n            require(CTokenInterface(_cAddresses[0]).mint(swapAmount) == 0);\\n        } else {\\n            CEtherInterface(_cAddresses[0]).mint{value: swapAmount}(); // reverts on fail\\n        }\\n\\n        // handle 0x fee\\n        tx.origin.transfer(address(this).balance);\\n\\n        // log amount, collToken, borrowToken\\n        logger.Log(address(this), msg.sender, \\\"CompoundBoost\\\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/compound/import/CompoundImportTaker.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../utils/GasBurner.sol\\\";\\nimport \\\"../../auth/ProxyPermission.sol\\\";\\n\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../interfaces/ILendingPool.sol\\\";\\nimport \\\"../../interfaces/CTokenInterface.sol\\\";\\nimport \\\"../../interfaces/ProxyRegistryInterface.sol\\\";\\n\\nimport \\\"../helpers/CompoundSaverHelper.sol\\\";\\n\\n/// @title Imports Compound position from the account to DSProxy\\ncontract CompoundImportTaker is CompoundSaverHelper, ProxyPermission, GasBurner {\\n\\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\\n\\n    address payable public constant COMPOUND_IMPORT_FLASH_LOAN = 0x2634e5D477B80B4578dADC2962336929B5E9Ee3A;\\n    address public constant PROXY_REGISTRY_ADDRESS = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\\n\\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\\n\\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\\n    /// @dev User must approve DSProxy to pull _cCollateralToken\\n    /// @param _cCollateralToken Collateral we are moving to DSProxy\\n    /// @param _cBorrowToken Borrow token we are moving to DSProxy\\n    function importLoan(address _cCollateralToken, address _cBorrowToken) external burnGas(20) {\\n        uint loanAmount = CTokenInterface(_cBorrowToken).borrowBalanceCurrent(msg.sender);\\n        bytes memory paramsData = abi.encode(_cCollateralToken, _cBorrowToken, address(this));\\n\\n        givePermission(COMPOUND_IMPORT_FLASH_LOAN);\\n\\n        lendingPool.flashLoan(COMPOUND_IMPORT_FLASH_LOAN, getUnderlyingAddr(_cBorrowToken), loanAmount, paramsData);\\n\\n        removePermission(COMPOUND_IMPORT_FLASH_LOAN);\\n\\n        logger.Log(address(this), msg.sender, \\\"CompoundImport\\\", abi.encode(loanAmount, 0, _cCollateralToken));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/compound/automatic/CompoundSubscriptionsProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../auth/ProxyPermission.sol\\\";\\nimport \\\"../../interfaces/ICompoundSubscription.sol\\\";\\n\\n/// @title SubscriptionsProxy handles authorization and interaction with the Subscriptions contract\\ncontract CompoundSubscriptionsProxy is ProxyPermission {\\n\\n    address public constant COMPOUND_SUBSCRIPTION_ADDRESS = 0x52015EFFD577E08f498a0CCc11905925D58D6207;\\n    address public constant COMPOUND_MONITOR_PROXY = 0xB1cF8DE8e791E4Ed1Bd86c03E2fc1f14389Cb10a;\\n\\n    /// @notice Calls subscription contract and creates a DSGuard if non existent\\n    /// @param _minRatio Minimum ratio below which repay is triggered\\n    /// @param _maxRatio Maximum ratio after which boost is triggered\\n    /// @param _optimalRatioBoost Ratio amount which boost should target\\n    /// @param _optimalRatioRepay Ratio amount which repay should target\\n    /// @param _boostEnabled Boolean determing if boost is enabled\\n    function subscribe(\\n        uint128 _minRatio,\\n        uint128 _maxRatio,\\n        uint128 _optimalRatioBoost,\\n        uint128 _optimalRatioRepay,\\n        bool _boostEnabled\\n    ) public {\\n        givePermission(COMPOUND_MONITOR_PROXY);\\n        ICompoundSubscription(COMPOUND_SUBSCRIPTION_ADDRESS).subscribe(\\n            _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\\n    }\\n\\n    /// @notice Calls subscription contract and updated existing parameters\\n    /// @dev If subscription is non existent this will create one\\n    /// @param _minRatio Minimum ratio below which repay is triggered\\n    /// @param _maxRatio Maximum ratio after which boost is triggered\\n    /// @param _optimalRatioBoost Ratio amount which boost should target\\n    /// @param _optimalRatioRepay Ratio amount which repay should target\\n    /// @param _boostEnabled Boolean determing if boost is enabled\\n    function update(\\n        uint128 _minRatio,\\n        uint128 _maxRatio,\\n        uint128 _optimalRatioBoost,\\n        uint128 _optimalRatioRepay,\\n        bool _boostEnabled\\n    ) public {\\n        ICompoundSubscription(COMPOUND_SUBSCRIPTION_ADDRESS).subscribe(_minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\\n    }\\n\\n    /// @notice Calls the subscription contract to unsubscribe the caller\\n    function unsubscribe() public {\\n        removePermission(COMPOUND_MONITOR_PROXY);\\n        ICompoundSubscription(COMPOUND_SUBSCRIPTION_ADDRESS).unsubscribe();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICompoundSubscription.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract ICompoundSubscription {\\n    function subscribe(uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled) public virtual;\\n    function unsubscribe() public virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/aaveV2/saver/AaveSaverTakerV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../utils/GasBurner.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\nimport \\\"../../auth/ProxyPermission.sol\\\";\\nimport \\\"../../utils/DydxFlashLoanBase.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../interfaces/ProxyRegistryInterface.sol\\\";\\nimport \\\"../../interfaces/TokenInterface.sol\\\";\\nimport \\\"../../interfaces/ERC20.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeData.sol\\\";\\n\\n/// @title Import Aave position from account to wallet\\n/// @dev Contract needs to have enough wei in WETH for all transactions (2 WETH wei per transaction)\\ncontract AaveSaverTakerV2 is DydxFlashLoanBase, ProxyPermission, GasBurner, DFSExchangeData {\\n\\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address payable public constant AAVE_RECEIVER = 0x5a7689F1452d57E92878e0c0Be47cA3525e8Fcc9;\\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\\n    address public constant PROXY_REGISTRY_ADDRESS = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\\n\\n    function repay(address _market, ExchangeData memory _data, uint _rateMode, uint256 _gasCost, uint _flAmount) public payable {\\n        _flashLoan(_market, _data, _rateMode,_gasCost, true, _flAmount);\\n    }\\n\\n    function boost(address _market, ExchangeData memory _data, uint _rateMode, uint256 _gasCost, uint _flAmount) public payable {\\n        _flashLoan(_market, _data, _rateMode, _gasCost, false, _flAmount);\\n    }\\n\\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\\n    /// @dev User must send 2 wei with this transaction\\n    function _flashLoan(address _market, ExchangeData memory _data, uint _rateMode, uint _gasCost, bool _isRepay, uint _flAmount) internal {\\n        ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\\n\\n        uint256 ethAmount = _flAmount;\\n\\n        // Get marketId from token address\\n        uint256 marketId = _getMarketIdFromTokenAddress(WETH_ADDR);\\n\\n        // Calculate repay amount (_amount + (2 wei))\\n        // Approve transfer from\\n        uint256 repayAmount = _getRepaymentAmountInternal(ethAmount);\\n        ERC20(WETH_ADDR).approve(SOLO_MARGIN_ADDRESS, repayAmount);\\n\\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\\n\\n        operations[0] = _getWithdrawAction(marketId, ethAmount, AAVE_RECEIVER);\\n        AAVE_RECEIVER.transfer(msg.value);\\n        bytes memory encodedData = packExchangeData(_data);\\n        operations[1] = _getCallAction(\\n            abi.encode(encodedData, _market, _rateMode, _gasCost, _isRepay, ethAmount, msg.value, proxyOwner(), address(this)),\\n            AAVE_RECEIVER\\n        );\\n        operations[2] = _getDepositAction(marketId, repayAmount, address(this));\\n\\n        Account.Info[] memory accountInfos = new Account.Info[](1);\\n        accountInfos[0] = _getAccountInfo();\\n\\n        givePermission(AAVE_RECEIVER);\\n        solo.operate(accountInfos, operations);\\n        removePermission(AAVE_RECEIVER);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/aaveV2/import/AaveImportTakerV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../utils/GasBurner.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\nimport \\\"../../auth/ProxyPermission.sol\\\";\\nimport \\\"../../utils/DydxFlashLoanBase.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../interfaces/ProxyRegistryInterface.sol\\\";\\nimport \\\"../../interfaces/TokenInterface.sol\\\";\\nimport \\\"../../interfaces/ERC20.sol\\\";\\n\\n\\n/// @title Import Aave position from account to wallet\\n/// @dev Contract needs to have enough wei in WETH for all transactions (2 WETH wei per transaction)\\ncontract AaveImportTakerV2 is DydxFlashLoanBase, ProxyPermission {\\n\\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    address payable public constant AAVE_IMPORT = 0x1C9B7FBD410Adcd213C5d6CBA12e651300061eaD;\\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\\n    address public constant PROXY_REGISTRY_ADDRESS = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\\n\\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\\n    /// @dev User must send 2 wei with this transaction\\n    /// @dev User must approve DSProxy to pull _aCollateralToken\\n    /// @param _market Market in which we want to import\\n    /// @param _collateralToken Collateral token we are moving to DSProxy\\n    /// @param _borrowToken Borrow token we are moving to DSProxy\\n    /// @param _ethAmount ETH amount that needs to be pulled from dydx\\n    function importLoan(address _market, address _collateralToken, address _borrowToken, uint _ethAmount) public {\\n        ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\\n\\n        // Get marketId from token address\\n        uint256 marketId = _getMarketIdFromTokenAddress(WETH_ADDR);\\n\\n        // Calculate repay amount (_amount + (2 wei))\\n        // Approve transfer from\\n        uint256 repayAmount = _getRepaymentAmountInternal(_ethAmount);\\n        ERC20(WETH_ADDR).approve(SOLO_MARGIN_ADDRESS, repayAmount);\\n\\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\\n\\n        operations[0] = _getWithdrawAction(marketId, _ethAmount, AAVE_IMPORT);\\n        operations[1] = _getCallAction(\\n            abi.encode(_market, _collateralToken, _borrowToken, _ethAmount, address(this)),\\n            AAVE_IMPORT\\n        );\\n        operations[2] = _getDepositAction(marketId, repayAmount, address(this));\\n\\n        Account.Info[] memory accountInfos = new Account.Info[](1);\\n        accountInfos[0] = _getAccountInfo();\\n\\n        givePermission(AAVE_IMPORT);\\n        solo.operate(accountInfos, operations);\\n        removePermission(AAVE_IMPORT);\\n\\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \\\"AaveImport\\\", abi.encode(_collateralToken, _borrowToken));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/aaveV2/automatic/AaveSubscriptionsProxyV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../auth/ProxyPermission.sol\\\";\\nimport \\\"../../interfaces/IAaveSubscription.sol\\\";\\n\\n/// @title SubscriptionsProxy handles authorization and interaction with the Subscriptions contract\\ncontract AaveSubscriptionsProxyV2 is ProxyPermission {\\n\\n    string public constant NAME = \\\"AaveSubscriptionsProxyV2\\\";\\n\\n    address public constant AAVE_SUBSCRIPTION_ADDRESS = 0x6B25043BF08182d8e86056C6548847aF607cd7CD;\\n    address public constant AAVE_MONITOR_PROXY = 0x380982902872836ceC629171DaeAF42EcC02226e;\\n\\n    /// @notice Calls subscription contract and creates a DSGuard if non existent\\n    /// @param _minRatio Minimum ratio below which repay is triggered\\n    /// @param _maxRatio Maximum ratio after which boost is triggered\\n    /// @param _optimalRatioBoost Ratio amount which boost should target\\n    /// @param _optimalRatioRepay Ratio amount which repay should target\\n    /// @param _boostEnabled Boolean determing if boost is enabled\\n    function subscribe(\\n        uint128 _minRatio,\\n        uint128 _maxRatio,\\n        uint128 _optimalRatioBoost,\\n        uint128 _optimalRatioRepay,\\n        bool _boostEnabled\\n    ) public {\\n        givePermission(AAVE_MONITOR_PROXY);\\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).subscribe(\\n            _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\\n    }\\n\\n    /// @notice Calls subscription contract and updated existing parameters\\n    /// @dev If subscription is non existent this will create one\\n    /// @param _minRatio Minimum ratio below which repay is triggered\\n    /// @param _maxRatio Maximum ratio after which boost is triggered\\n    /// @param _optimalRatioBoost Ratio amount which boost should target\\n    /// @param _optimalRatioRepay Ratio amount which repay should target\\n    /// @param _boostEnabled Boolean determing if boost is enabled\\n    function update(\\n        uint128 _minRatio,\\n        uint128 _maxRatio,\\n        uint128 _optimalRatioBoost,\\n        uint128 _optimalRatioRepay,\\n        bool _boostEnabled\\n    ) public {\\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).subscribe(_minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\\n    }\\n\\n    /// @notice Calls the subscription contract to unsubscribe the caller\\n    function unsubscribe() public {\\n        removePermission(AAVE_MONITOR_PROXY);\\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).unsubscribe();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveSubscription.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract IAaveSubscription {\\n    function subscribe(uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled) public virtual;\\n    function unsubscribe() public virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/aave/automatic/AaveSubscriptionsProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../auth/ProxyPermission.sol\\\";\\nimport \\\"../../interfaces/IAaveSubscription.sol\\\";\\n\\n/// @title SubscriptionsProxy handles authorization and interaction with the Subscriptions contract\\ncontract AaveSubscriptionsProxy is ProxyPermission {\\n\\n    address public constant AAVE_SUBSCRIPTION_ADDRESS = 0xe08ff7A2BADb634F0b581E675E6B3e583De086FC;\\n    address public constant AAVE_MONITOR_PROXY = 0xfA560Dba3a8D0B197cA9505A2B98120DD89209AC;\\n\\n    /// @notice Calls subscription contract and creates a DSGuard if non existent\\n    /// @param _minRatio Minimum ratio below which repay is triggered\\n    /// @param _maxRatio Maximum ratio after which boost is triggered\\n    /// @param _optimalRatioBoost Ratio amount which boost should target\\n    /// @param _optimalRatioRepay Ratio amount which repay should target\\n    /// @param _boostEnabled Boolean determing if boost is enabled\\n    function subscribe(\\n        uint128 _minRatio,\\n        uint128 _maxRatio,\\n        uint128 _optimalRatioBoost,\\n        uint128 _optimalRatioRepay,\\n        bool _boostEnabled\\n    ) public {\\n        givePermission(AAVE_MONITOR_PROXY);\\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).subscribe(\\n            _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\\n    }\\n\\n    /// @notice Calls subscription contract and updated existing parameters\\n    /// @dev If subscription is non existent this will create one\\n    /// @param _minRatio Minimum ratio below which repay is triggered\\n    /// @param _maxRatio Maximum ratio after which boost is triggered\\n    /// @param _optimalRatioBoost Ratio amount which boost should target\\n    /// @param _optimalRatioRepay Ratio amount which repay should target\\n    /// @param _boostEnabled Boolean determing if boost is enabled\\n    function update(\\n        uint128 _minRatio,\\n        uint128 _maxRatio,\\n        uint128 _optimalRatioBoost,\\n        uint128 _optimalRatioRepay,\\n        bool _boostEnabled\\n    ) public {\\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).subscribe(_minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\\n    }\\n\\n    /// @notice Calls the subscription contract to unsubscribe the caller\\n    function unsubscribe() public {\\n        removePermission(AAVE_MONITOR_PROXY);\\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).unsubscribe();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/aave/saver/AaveSaverTaker.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../utils/GasBurner.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\nimport \\\"../../auth/ProxyPermission.sol\\\";\\nimport \\\"../../utils/DydxFlashLoanBase.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../interfaces/ProxyRegistryInterface.sol\\\";\\nimport \\\"../../interfaces/TokenInterface.sol\\\";\\nimport \\\"../../interfaces/ERC20.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeData.sol\\\";\\n\\n/// @title Import Aave position from account to wallet\\n/// @dev Contract needs to have enough wei in WETH for all transactions (2 WETH wei per transaction)\\ncontract AaveSaverTaker is DydxFlashLoanBase, ProxyPermission, GasBurner, DFSExchangeData {\\n\\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address payable public constant AAVE_RECEIVER = 0xf5AE5851288365CAB81283716575Ea6685FD0545;\\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\\n    address public constant PROXY_REGISTRY_ADDRESS = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\\n\\n    function repay(ExchangeData memory _data, uint256 _gasCost) public payable {\\n        _flashLoan(_data, _gasCost, true);\\n    }\\n\\n    function boost(ExchangeData memory _data, uint256 _gasCost) public payable {\\n        _flashLoan(_data, _gasCost, false);\\n    }\\n\\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\\n    /// @dev User must send 2 wei with this transaction\\n    function _flashLoan(ExchangeData memory _data, uint _gasCost, bool _isRepay) internal {\\n        ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\\n\\n        uint256 ethAmount = ERC20(WETH_ADDR).balanceOf(SOLO_MARGIN_ADDRESS);\\n\\n        // Get marketId from token address\\n        uint256 marketId = _getMarketIdFromTokenAddress(WETH_ADDR);\\n\\n        // Calculate repay amount (_amount + (2 wei))\\n        // Approve transfer from\\n        uint256 repayAmount = _getRepaymentAmountInternal(ethAmount);\\n        ERC20(WETH_ADDR).approve(SOLO_MARGIN_ADDRESS, repayAmount);\\n\\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\\n\\n        operations[0] = _getWithdrawAction(marketId, ethAmount, AAVE_RECEIVER);\\n        AAVE_RECEIVER.transfer(msg.value);\\n        bytes memory encodedData = packExchangeData(_data);\\n        operations[1] = _getCallAction(\\n            abi.encode(encodedData, _gasCost, _isRepay, ethAmount, msg.value, proxyOwner(), address(this)),\\n            AAVE_RECEIVER\\n        );\\n        operations[2] = _getDepositAction(marketId, repayAmount, address(this));\\n\\n        Account.Info[] memory accountInfos = new Account.Info[](1);\\n        accountInfos[0] = _getAccountInfo();\\n\\n        givePermission(AAVE_RECEIVER);\\n        solo.operate(accountInfos, operations);\\n        removePermission(AAVE_RECEIVER);\\n    }\\n}\"\r\n    },\r\n    \"contracts/aave/import/AaveImportTaker.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../utils/GasBurner.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\nimport \\\"../../auth/ProxyPermission.sol\\\";\\nimport \\\"../../utils/DydxFlashLoanBase.sol\\\";\\nimport \\\"../../loggers/DefisaverLogger.sol\\\";\\nimport \\\"../../interfaces/ProxyRegistryInterface.sol\\\";\\nimport \\\"../../interfaces/TokenInterface.sol\\\";\\nimport \\\"../../interfaces/ERC20.sol\\\";\\n\\n\\n/// @title Import Aave position from account to wallet\\n/// @dev Contract needs to have enough wei in WETH for all transactions (2 WETH wei per transaction)\\ncontract AaveImportTaker is DydxFlashLoanBase, ProxyPermission {\\n\\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    address payable public constant AAVE_IMPORT = 0x5cD4239D2AA5b487bA87c3715127eA53685B4926;\\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\\n    address public constant PROXY_REGISTRY_ADDRESS = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\\n\\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\\n    /// @dev User must send 2 wei with this transaction\\n    /// @dev User must approve DSProxy to pull _aCollateralToken\\n    /// @param _collateralToken Collateral token we are moving to DSProxy\\n    /// @param _borrowToken Borrow token we are moving to DSProxy\\n    /// @param _ethAmount ETH amount that needs to be pulled from dydx\\n    function importLoan(address _collateralToken, address _borrowToken, uint _ethAmount) public {\\n        ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\\n\\n        // Get marketId from token address\\n        uint256 marketId = _getMarketIdFromTokenAddress(WETH_ADDR);\\n\\n        // Calculate repay amount (_amount + (2 wei))\\n        // Approve transfer from\\n        uint256 repayAmount = _getRepaymentAmountInternal(_ethAmount);\\n        ERC20(WETH_ADDR).approve(SOLO_MARGIN_ADDRESS, repayAmount);\\n\\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\\n\\n        operations[0] = _getWithdrawAction(marketId, _ethAmount, AAVE_IMPORT);\\n        operations[1] = _getCallAction(\\n            abi.encode(_collateralToken, _borrowToken, _ethAmount, address(this)),\\n            AAVE_IMPORT\\n        );\\n        operations[2] = _getDepositAction(marketId, repayAmount, address(this));\\n\\n        Account.Info[] memory accountInfos = new Account.Info[](1);\\n        accountInfos[0] = _getAccountInfo();\\n\\n        givePermission(AAVE_IMPORT);\\n        solo.operate(accountInfos, operations);\\n        removePermission(AAVE_IMPORT);\\n\\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \\\"AaveImport\\\", abi.encode(_collateralToken, _borrowToken));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/automaticV2/SubscriptionsProxyV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../DS/DSGuard.sol\\\";\\nimport \\\"../../DS/DSAuth.sol\\\";\\n\\ncontract SubscriptionsInterfaceV2 {\\n    function subscribe(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled, bool _nextPriceEnabled) external {}\\n    function unsubscribe(uint _cdpId) external {}\\n}\\n\\n/// @title SubscriptionsProxy handles authorization and interaction with the Subscriptions contract\\ncontract SubscriptionsProxyV2 {\\n\\n    address public constant MONITOR_PROXY_ADDRESS = 0x1816A86C4DA59395522a42b871bf11A4E96A1C7a;\\n    address public constant OLD_SUBSCRIPTION = 0x83152CAA0d344a2Fd428769529e2d490A88f4393;\\n    address public constant FACTORY_ADDRESS = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;\\n\\n    function migrate(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalRatioBoost, uint128 _optimalRatioRepay, bool _boostEnabled, bool _nextPriceEnabled, address _subscriptions) public {\\n        SubscriptionsInterfaceV2(OLD_SUBSCRIPTION).unsubscribe(_cdpId);\\n\\n        subscribe(_cdpId, _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled, _nextPriceEnabled, _subscriptions);\\n    }\\n\\n    function subscribe(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalRatioBoost, uint128 _optimalRatioRepay, bool _boostEnabled, bool _nextPriceEnabled, address _subscriptions) public {\\n\\n        address currAuthority = address(DSAuth(address(this)).authority());\\n        DSGuard guard = DSGuard(currAuthority);\\n\\n        if (currAuthority == address(0)) {\\n            guard = DSGuardFactory(FACTORY_ADDRESS).newGuard();\\n            DSAuth(address(this)).setAuthority(DSAuthority(address(guard)));\\n        }\\n\\n        guard.permit(MONITOR_PROXY_ADDRESS, address(this), bytes4(keccak256(\\\"execute(address,bytes)\\\")));\\n\\n        SubscriptionsInterfaceV2(_subscriptions).subscribe(_cdpId, _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled, _nextPriceEnabled);\\n    }\\n\\n    function update(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalRatioBoost, uint128 _optimalRatioRepay, bool _boostEnabled, bool _nextPriceEnabled, address _subscriptions) public {\\n        SubscriptionsInterfaceV2(_subscriptions).subscribe(_cdpId, _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled, _nextPriceEnabled);\\n    }\\n\\n    function unsubscribe(uint _cdpId, address _subscriptions) public {\\n        SubscriptionsInterfaceV2(_subscriptions).unsubscribe(_cdpId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/compound/saver/CompoundSaverFlashLoan.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../utils/FlashLoanReceiverBase.sol\\\";\\nimport \\\"../../interfaces/DSProxyInterface.sol\\\";\\nimport \\\"../../exchangeV3/DFSExchangeData.sol\\\";\\n\\n/// @title Contract that receives the FL from Aave for Repays/Boost\\ncontract CompoundSaverFlashLoan is FlashLoanReceiverBase, DFSExchangeData {\\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\\n\\n    address payable public COMPOUND_SAVER_FLASH_PROXY = 0x70093eCADfE1AE5feCd9ecC6E1B010169f9902f3;\\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    address public owner;\\n\\n    using SafeERC20 for ERC20;\\n\\n    constructor()\\n        FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER)\\n        public {\\n            owner = msg.sender;\\n    }\\n\\n    /// @notice Called by Aave when sending back the FL amount\\n    /// @param _reserve The address of the borrowed token\\n    /// @param _amount Amount of FL tokens received\\n    /// @param _fee FL Aave fee\\n    /// @param _params The params that are sent from the original FL caller contract\\n   function executeOperation(\\n        address _reserve,\\n        uint256 _amount,\\n        uint256 _fee,\\n        bytes calldata _params)\\n    external override {\\n        // Format the call data for DSProxy\\n        (bytes memory proxyData, address payable proxyAddr) = packFunctionCall(_amount, _fee, _params);\\n\\n        // Send Flash loan amount to DSProxy\\n        sendLoanToProxy(proxyAddr, _reserve, _amount);\\n\\n        // Execute the DSProxy call\\n        DSProxyInterface(proxyAddr).execute(COMPOUND_SAVER_FLASH_PROXY, proxyData);\\n\\n        // Repay the loan with the money DSProxy sent back\\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\\n\\n        // if there is some eth left (0x fee), return it to user\\n        if (address(this).balance > 0) {\\n            tx.origin.transfer(address(this).balance);\\n        }\\n    }\\n\\n    /// @notice Formats function data call so we can call it through DSProxy\\n    /// @param _amount Amount of FL\\n    /// @param _fee Fee of the FL\\n    /// @param _params Saver proxy params\\n    /// @return proxyData Formated function call data\\n    function packFunctionCall(uint _amount, uint _fee, bytes memory _params) internal pure returns (bytes memory proxyData, address payable) {\\n        (\\n            bytes memory exDataBytes,\\n            address[2] memory cAddresses, // cCollAddress, cBorrowAddress\\n            uint256 gasCost,\\n            bool isRepay,\\n            address payable proxyAddr\\n        )\\n        = abi.decode(_params, (bytes,address[2],uint256,bool,address));\\n\\n        ExchangeData memory _exData = unpackExchangeData(exDataBytes);\\n\\n        uint[2] memory flashLoanData = [_amount, _fee];\\n\\n        if (isRepay) {\\n            proxyData = abi.encodeWithSignature(\\\"flashRepay((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),address[2],uint256,uint256[2])\\\", _exData, cAddresses, gasCost, flashLoanData);\\n        } else {\\n            proxyData = abi.encodeWithSignature(\\\"flashBoost((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),address[2],uint256,uint256[2])\\\", _exData, cAddresses, gasCost, flashLoanData);\\n        }\\n\\n        return (proxyData, proxyAddr);\\n    }\\n\\n    /// @notice Send the FL funds received to DSProxy\\n    /// @param _proxy DSProxy address\\n    /// @param _reserve Token address\\n    /// @param _amount Amount of tokens\\n    function sendLoanToProxy(address payable _proxy, address _reserve, uint _amount) internal {\\n        if (_reserve != ETH_ADDRESS) {\\n            ERC20(_reserve).safeTransfer(_proxy, _amount);\\n        }\\n\\n        _proxy.transfer(address(this).balance);\\n    }\\n\\n    receive() external override(FlashLoanReceiverBase) payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/compound/import/CompoundImportFlashLoan.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../auth/AdminAuth.sol\\\";\\nimport \\\"../../utils/FlashLoanReceiverBase.sol\\\";\\nimport \\\"../../interfaces/ProxyRegistryInterface.sol\\\";\\nimport \\\"../../interfaces/CTokenInterface.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\n\\n/// @title Receives FL from Aave and imports the position to DSProxy\\ncontract CompoundImportFlashLoan is FlashLoanReceiverBase, AdminAuth {\\n    using SafeERC20 for ERC20;\\n\\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER =\\n        ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\\n\\n    address public constant COMPOUND_BORROW_PROXY = 0xb7EDC39bE76107e2Cc645f0f6a3D164f5e173Ee2;\\n    address public constant PULL_TOKENS_PROXY = 0x45431b79F783e0BF0fe7eF32D06A3e061780bfc4;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor() public FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER) {}\\n\\n    /// @notice Called by Aave when sending back the FL amount\\n    /// @param _reserve The address of the borrowed token\\n    /// @param _amount Amount of FL tokens received\\n    /// @param _fee FL Aave fee\\n    /// @param _params The params that are sent from the original FL caller contract\\n    function executeOperation(\\n        address _reserve,\\n        uint256 _amount,\\n        uint256 _fee,\\n        bytes calldata _params\\n    ) external override {\\n        (address cCollAddr, address cBorrowAddr, address proxy) =\\n            abi.decode(_params, (address, address, address));\\n\\n        address user = DSProxyInterface(proxy).owner();\\n        uint256 usersCTokenBalance = CTokenInterface(cCollAddr).balanceOf(user);\\n\\n        if (_reserve != EthAddressLib.ethAddress()) {\\n            // approve FL tokens so we can repay them\\n            ERC20(_reserve).safeApprove(cBorrowAddr, _amount);\\n\\n            // repay compound debt on behalf of the user\\n            require(\\n                CTokenInterface(cBorrowAddr).repayBorrowBehalf(user, uint256(-1)) == 0,\\n                \\\"Repay borrow behalf fail\\\"\\n            );\\n        } else {\\n            CTokenInterface(cBorrowAddr).repayBorrowBehalf{value: _amount}(user); // reverts on fail\\n        }\\n\\n        bytes memory depositProxyCallData = formatDSProxyPullTokensCall(cCollAddr, usersCTokenBalance);\\n        DSProxyInterface(proxy).execute(PULL_TOKENS_PROXY, depositProxyCallData);\\n\\n        // borrow debt now on ds proxy\\n        bytes memory borrowProxyCallData =\\n            formatDSProxyBorrowCall(cCollAddr, cBorrowAddr, _reserve, (_amount + _fee));\\n        DSProxyInterface(proxy).execute(COMPOUND_BORROW_PROXY, borrowProxyCallData);\\n\\n        // repay the loan with the money DSProxy sent back\\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\\n    }\\n\\n    /// @notice Formats function data call to pull tokens to DSProxy\\n    /// @param _cTokenAddr CToken address of the collateral\\n    /// @param _amount Amount of cTokens to pull\\n    function formatDSProxyPullTokensCall(\\n        address _cTokenAddr,\\n        uint256 _amount\\n    ) internal pure returns (bytes memory) {\\n        return abi.encodeWithSignature(\\n            \\\"pullTokens(address,uint256)\\\",\\n            _cTokenAddr,\\n            _amount\\n        );\\n    }\\n\\n    /// @notice Formats function data call borrow through DSProxy\\n    /// @param _cCollToken CToken address of collateral\\n    /// @param _cBorrowToken CToken address we will borrow\\n    /// @param _borrowToken Token address we will borrow\\n    /// @param _amount Amount that will be borrowed\\n    function formatDSProxyBorrowCall(\\n        address _cCollToken,\\n        address _cBorrowToken,\\n        address _borrowToken,\\n        uint256 _amount\\n    ) internal pure returns (bytes memory) {\\n        return abi.encodeWithSignature(\\n            \\\"borrow(address,address,address,uint256)\\\",\\n            _cCollToken,\\n            _cBorrowToken,\\n            _borrowToken,\\n            _amount\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mcd/automaticV2/MCDPriceVerifier.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../interfaces/OsmMom.sol\\\";\\nimport \\\"../../interfaces/Osm.sol\\\";\\nimport \\\"../../auth/AdminAuth.sol\\\";\\nimport \\\"../../interfaces/Manager.sol\\\";\\n\\ncontract MCDPriceVerifier is AdminAuth {\\n\\n    OsmMom public osmMom = OsmMom(0x76416A4d5190d071bfed309861527431304aA14f);\\n    Manager public manager = Manager(0x5ef30b9986345249bc32d8928B7ee64DE9435E39);\\n\\n    mapping(address => bool) public authorized;\\n\\n    function verifyVaultNextPrice(uint _nextPrice, uint _cdpId) public view returns(bool) {\\n        require(authorized[msg.sender]);\\n\\n        bytes32 ilk = manager.ilks(_cdpId);\\n\\n        return verifyNextPrice(_nextPrice, ilk);\\n    }\\n\\n    function verifyNextPrice(uint _nextPrice, bytes32 _ilk) public view returns(bool) {\\n        require(authorized[msg.sender]);\\n\\n        address osmAddress = osmMom.osms(_ilk);\\n\\n        uint whitelisted = Osm(osmAddress).bud(address(this));\\n        // If contracts doesn't have access return true\\n        if (whitelisted != 1) return true;\\n\\n        (bytes32 price, bool has) = Osm(osmAddress).peep();\\n\\n        return has ? uint(price) == _nextPrice : false;\\n    }\\n\\n    function setAuthorized(address _address, bool _allowed) public onlyOwner {\\n        authorized[_address] = _allowed;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/OsmMom.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\nabstract contract OsmMom {\\n    mapping (bytes32 => address) public osms;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Osm.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\nabstract contract Osm {\\n    mapping(address => uint256) public bud;\\n\\n    function peep() external view virtual returns (bytes32, bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ExchangeInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\n//TODO: currenlty only adjusted to kyber, but should be genric interfaces for more dec. exchanges\\ninterface ExchangeInterface {\\n    function swapEtherToToken(uint256 _ethAmount, address _tokenAddress, uint256 _maxAmount)\\n        external\\n        payable\\n        returns (uint256, uint256);\\n\\n    function swapTokenToEther(address _tokenAddress, uint256 _amount, uint256 _maxAmount)\\n        external\\n        returns (uint256);\\n\\n    function swapTokenToToken(address _src, address _dest, uint256 _amount)\\n        external\\n        payable\\n        returns (uint256);\\n\\n    function getExpectedRate(address src, address dest, uint256 srcQty)\\n        external\\n        view\\n        returns (uint256 expectedRate);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"AAVE_BASIC_PROXY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AAVE_REFERRAL_CODE\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AUTOMATIC_SERVICE_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOT_REGISTRY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFISAVER_LOGGER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DISCOUNT_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DISCOUNT_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERR_DEST_AMOUNT_MISSING\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERR_NOT_ZEROX_EXCHANGE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERR_OFFCHAIN_DATA_INVALID\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERR_SLIPPAGE_HIT\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERR_WRAPPER_INVALID\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETH_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXCHANGE_WETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"KYBER_ETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANUAL_SERVICE_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NINETY_NINE_PERCENT_WEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SAVER_EXCHANGE_REGISTRY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STABLE_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VARIABLE_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZRX_ALLOWLIST_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_feeRecipient\",\"outputs\":[{\"internalType\":\"contract IFeeRecipient\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"premiums\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"executeOperation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"contract IFeeRecipient\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"srcAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dfsFeeDivider\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"wrapperData\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchangeAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"allowanceTarget\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct DFSExchangeData.OffchainData\",\"name\":\"offchainData\",\"type\":\"tuple\"}],\"internalType\":\"struct DFSExchangeData.ExchangeData\",\"name\":\"_exData\",\"type\":\"tuple\"}],\"name\":\"packExchangeData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdminByAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdminByOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwnerByAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"unpackExchangeData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"srcAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dfsFeeDivider\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"wrapperData\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchangeAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"allowanceTarget\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct DFSExchangeData.OffchainData\",\"name\":\"offchainData\",\"type\":\"tuple\"}],\"internalType\":\"struct DFSExchangeData.ExchangeData\",\"name\":\"_exData\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStuckFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"AaveSaverReceiverOV2","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://41212c4755bd9b96eebb0d2880a1cbdb4a68c04ff7e8d9d3181a5784cec9f642"}]}