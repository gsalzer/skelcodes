{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/rickierao/IdeaProjects/kine-oracle/contracts/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/rickierao/IdeaProjects/kine-oracle/contracts/ICompoundOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./UniswapConfig.sol\\\";\\n\\ninterface ICompoundOracle {\\n    function price(string memory symbol) external view returns (uint);\\n    function getUnderlyingPrice(address cToken) external view returns (uint);\\n    function getTokenConfigBySymbolHash(bytes32 symbolHash) external view returns (UniswapConfig.TokenConfig memory);\\n}\"\r\n    },\r\n    \"/Users/rickierao/IdeaProjects/kine-oracle/contracts/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\ninterface IUniswapV2Pair {\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n}\"\r\n    },\r\n    \"/Users/rickierao/IdeaProjects/kine-oracle/contracts/KineOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./OpenOraclePriceData.sol\\\";\\nimport \\\"./ICompoundOracle.sol\\\";\\nimport \\\"./PriceConfig.sol\\\";\\nimport \\\"./UniswapConfig.sol\\\";\\n\\n/// @title Oracle for Kine Protocol\\n/// @author Kine Technology\\ncontract KineOracle is PriceConfig {\\n    struct Observation {\\n        uint timestamp;\\n        uint acc;\\n    }\\n\\n    struct KineOracleConfig{\\n        address reporter; // The reporter that signs the price\\n        address kaptain; // The kine kaptain contract\\n        address uniswapFactory; // The uniswap factory address\\n        address wrappedETHAddress; // The WETH contract address\\n        uint anchorToleranceMantissa; // The percentage tolerance that the reporter may deviate from the uniswap anchor\\n        uint anchorPeriod; // The minimum amount of time required for the old uniswap price accumulator to be replaced\\n    }\\n\\n    using FixedPoint for *;\\n\\n    /// @notice The Open Oracle Price Data contract\\n    OpenOraclePriceData public immutable priceData;\\n\\n    /// @notice The Compound Oracle Price contract\\n    ICompoundOracle public compoundOracle;\\n\\n    /// @notice The number of wei in 1 ETH\\n    uint public constant ethBaseUnit = 1e18;\\n\\n    /// @notice A common scaling factor to maintain precision\\n    uint public constant expScale = 1e18;\\n\\n    /// @notice The Open Oracle Reporter\\n    address public reporter;\\n\\n    /// @notice The Kaptain contract address that steers the MCD price and kUSD minter\\n    address public kaptain;\\n\\n    /// @notice The mcd last update timestamp\\n    uint public mcdLastUpdatedAt;\\n\\n    /// @notice The highest ratio of the new price to the anchor price that will still trigger the price to be updated\\n    uint public immutable upperBoundAnchorRatio;\\n\\n    /// @notice The lowest ratio of the new price to the anchor price that will still trigger the price to be updated\\n    uint public immutable lowerBoundAnchorRatio;\\n\\n    /// @notice The minimum amount of time in seconds required for the old uniswap price accumulator to be replaced\\n    uint public immutable anchorPeriod;\\n\\n    /// @notice Official prices by symbol hash\\n    mapping(bytes32 => uint) public prices;\\n\\n    /// @notice Circuit breaker for using anchor price oracle directly, ignoring reporter\\n    bool public reporterInvalidated;\\n\\n    /// @notice The old observation for each symbolHash\\n    mapping(bytes32 => Observation) public oldObservations;\\n\\n    /// @notice The new observation for each symbolHash\\n    mapping(bytes32 => Observation) public newObservations;\\n\\n    /// @notice The event emitted when new prices are posted but the stored price is not updated due to the anchor\\n    event PriceGuarded(string symbol, uint reporter, uint anchor);\\n\\n    /// @notice The event emitted when the stored price is updated\\n    event PriceUpdated(string symbol, uint price);\\n\\n    /// @notice The event emitted when anchor price is updated\\n    event AnchorPriceUpdated(string symbol, uint anchorPrice, uint oldTimestamp, uint newTimestamp);\\n\\n    /// @notice The event emitted when the uniswap window changes\\n    event UniswapWindowUpdated(bytes32 indexed symbolHash, uint oldTimestamp, uint newTimestamp, uint oldPrice, uint newPrice);\\n\\n    /// @notice The event emitted when reporter invalidates itself\\n    event ReporterInvalidated(address reporter);\\n\\n    /// @notice The event emitted when reporter is updated\\n    event ReporterUpdated(address oldReporter, address newReporter);\\n\\n    /// @notice The event emitted when compound oracle is updated\\n    event CompoundOracleUpdated(address fromAddress, address toAddress);\\n\\n    /// @notice The event emitted when Kaptain is updated\\n    event KaptainUpdated(address fromAddress, address toAddress);\\n\\n    /// @notice The event emitted when new config added\\n    event TokenConfigAdded(address kToken, address underlying, bytes32 symbolHash,\\n        uint baseUnit, KPriceSource priceSource, uint fixedPrice, address uniswapMarket, bool isUniswapReversed);\\n\\n    /// @notice The event emitted when config removed\\n    event TokenConfigRemoved(address kToken, address underlying, bytes32 symbolHash,\\n        uint baseUnit, KPriceSource priceSource, uint fixedPrice, address uniswapMarket, bool isUniswapReversed);\\n\\n    bytes32 constant ethHash = keccak256(abi.encodePacked(\\\"ETH\\\"));\\n    bytes32 constant mcdHash = keccak256(abi.encodePacked(\\\"MCD\\\"));\\n    bytes32 constant rotateHash = keccak256(abi.encodePacked(\\\"rotate\\\"));\\n\\n    /**\\n     * @dev Throws if called by any account other than the Kaptain.\\n     */\\n    modifier onlyKaptain() {\\n        require(kaptain == _msgSender(), \\\"caller is not the Kaptain\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Construct a uniswap anchored view for a set of token configurations\\n     * @dev Note that to avoid immature TWAPs, the system must run for at least a single anchorPeriod before using.\\n     * @param priceData_ The open oracle price data contract\\n     * @param kineOracleConfig_ The configurations for kine oracle init\\n     * @param configs The static token configurations which define what prices are supported and how\\n     * @param compoundOracle_ The address of compound oracle\\n     */\\n    constructor(OpenOraclePriceData priceData_,\\n        KineOracleConfig memory kineOracleConfig_,\\n        KTokenConfig[] memory configs,\\n        ICompoundOracle compoundOracle_) public {\\n        priceData = priceData_;\\n        reporter = kineOracleConfig_.reporter;\\n        kaptain = kineOracleConfig_.kaptain;\\n        uniswapFactory = kineOracleConfig_.uniswapFactory;\\n        wrappedETHAddress = kineOracleConfig_.wrappedETHAddress;\\n        anchorPeriod = kineOracleConfig_.anchorPeriod;\\n        compoundOracle = compoundOracle_;\\n        emit CompoundOracleUpdated(address(0), address(compoundOracle_));\\n\\n        uint anchorToleranceMantissa = kineOracleConfig_.anchorToleranceMantissa;\\n        // Allow the tolerance to be whatever the deployer chooses, but prevent under/overflow (and prices from being 0)\\n        upperBoundAnchorRatio = anchorToleranceMantissa > uint(-1) - 100e16 ? uint(-1) : 100e16 + anchorToleranceMantissa;\\n        lowerBoundAnchorRatio = anchorToleranceMantissa < 100e16 ? 100e16 - anchorToleranceMantissa : 1;\\n\\n        for (uint i = 0; i < configs.length; i++) {\\n            KTokenConfig memory config = configs[i];\\n\\n            // configuration integrity check\\n            if(config.symbolHash != ethHash && config.priceSource == KPriceSource.REPORTER){\\n                checkConfig(config);\\n            }\\n\\n            kTokenConfigs.push(config);\\n            emit TokenConfigAdded(config.kToken, config.underlying, config.symbolHash, config.baseUnit,\\n                config.priceSource, config.fixedPrice, config.uniswapMarket, config.isUniswapReversed);\\n\\n            require(config.baseUnit > 0, \\\"baseUnit must be greater than zero\\\");\\n            address uniswapMarket = config.uniswapMarket;\\n            if (config.priceSource == KPriceSource.REPORTER || config.symbolHash == ethHash) {\\n                require(uniswapMarket != address(0), \\\"prices must have an anchor\\\");\\n                bytes32 symbolHash = config.symbolHash;\\n                uint cumulativePrice = currentCumulativePrice(config);\\n                oldObservations[symbolHash].timestamp = block.timestamp;\\n                newObservations[symbolHash].timestamp = block.timestamp;\\n                oldObservations[symbolHash].acc = cumulativePrice;\\n                newObservations[symbolHash].acc = cumulativePrice;\\n                emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);\\n            } else {\\n                require(uniswapMarket == address(0), \\\"only reported prices utilize an anchor\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the official price for a symbol\\n     * @param symbol The symbol to fetch the price of\\n     * @return Price denominated in USD, with 6 decimals\\n     */\\n    function price(string memory symbol) external view returns (uint) {\\n        KTokenConfig memory config = getKTokenConfigBySymbol(symbol);\\n        // not kine configuration, redirect to compound oracle\\n        if(config.underlying == address(0)){\\n            return compoundOracle.price(symbol);\\n        }\\n        return priceInternal(config);\\n    }\\n\\n    function priceInternal(KTokenConfig memory config) internal view returns (uint) {\\n        if (config.priceSource == KPriceSource.KAPTAIN || config.priceSource == KPriceSource.REPORTER) {\\n            return prices[config.symbolHash];\\n        }\\n        if (config.priceSource == KPriceSource.FIXED_USD) return config.fixedPrice;\\n        if (config.priceSource == KPriceSource.FIXED_ETH) {\\n            uint usdPerEth = prices[ethHash];\\n            require(usdPerEth > 0, \\\"ETH price not set, cannot convert to dollars\\\");\\n            return mul(usdPerEth, config.fixedPrice) / ethBaseUnit;\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the underlying price of a kToken\\n     * @dev Implements the PriceOracle interface for Kine.\\n     * @param kToken The kToken address for price retrieval\\n     * @return Price denominated in USD, with 18 decimals, for the given kToken address\\n     */\\n    function getUnderlyingPrice(address kToken) external view returns (uint) {\\n        // check if this is kinedPrice\\n        KTokenConfig memory config = getKConfigByKToken(kToken);\\n        // is not kine owned price token, fetch compound config and use cToken to get compound price\\n        // ETH underlying is also address(0), so logic still works\\n        if (config.underlying == address(0)) {\\n            UniswapConfig.TokenConfig memory cConfig = compoundOracle.getTokenConfigBySymbolHash(config.symbolHash);\\n            require(cConfig.cToken != address(0), \\\"token config not found in compound\\\");\\n            return compoundOracle.getUnderlyingPrice(cConfig.cToken);\\n        }\\n\\n        // Controller needs prices in the format: ${raw price} * 1e(36 - baseUnit)\\n        // Since the prices in this view have 6 decimals, we must scale them by 1e(36 - 6 - baseUnit)\\n        return mul(1e30, priceInternal(config)) / config.baseUnit;\\n    }\\n\\n    /**\\n     * @notice Post kine supported prices, and recalculate stored reporter price by comparing to anchor\\n     * @dev only priceSource not configured as \\\"COMPOUND\\\"  will be stored in the view.\\n     * @param messages The messages to post to the oracle\\n     * @param signatures The signatures for the corresponding messages\\n     * @param symbols The symbols to compare to anchor for authoritative reading\\n     */\\n    function postPrices(bytes[] calldata messages, bytes[] calldata signatures, string[] calldata symbols) external onlyKaptain{\\n        require(messages.length == signatures.length, \\\"messages and signatures must be 1:1\\\");\\n\\n        // Save the prices\\n        for (uint i = 0; i < messages.length; i++) {\\n            priceData.put(messages[i], signatures[i]);\\n        }\\n\\n        uint ethPrice = fetchEthPrice();\\n\\n        // Try to update the view storage\\n        for (uint i = 0; i < symbols.length; i++) {\\n            KTokenConfig memory config = getKTokenConfigBySymbol(symbols[i]);\\n            require(config.symbolHash != mcdHash, \\\"MCD price goes to postMcdPrice\\\");\\n            // skip for non-kine config, which should have valid underlying address\\n            if(config.underlying != address(0)){\\n                uint reporterPrice = priceData.getPrice(reporter, symbols[i]);\\n                if(config.priceSource != KPriceSource.COMPOUND)\\n                    postPriceInternal(symbols[i], ethPrice, config, reporterPrice);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev MCD price can only come from Kaptain\\n     */\\n    function postMcdPrice(uint mcdPrice) external onlyKaptain{\\n        require(!reporterInvalidated, \\\"reporter invalidated\\\");\\n        require(mcdPrice != 0, \\\"MCD price cannot be 0\\\");\\n        mcdLastUpdatedAt = block.timestamp;\\n        prices[mcdHash] = mcdPrice;\\n        emit PriceUpdated(\\\"MCD\\\", mcdPrice);\\n    }\\n\\n    function postReporterOnlyPriceInternal(string memory symbol, KTokenConfig memory config, uint reporterPrice) internal {\\n        require(!reporterInvalidated, \\\"reporter invalidated\\\");\\n        require(reporterPrice != 0, \\\"price cannot be 0\\\");\\n        prices[config.symbolHash] = reporterPrice;\\n        emit PriceUpdated(symbol, reporterPrice);\\n    }\\n\\n    function postPriceInternal(string memory symbol, uint ethPrice, KTokenConfig memory config, uint reporterPrice) internal {\\n        require(config.priceSource == KPriceSource.REPORTER, \\\"only reporter prices get posted\\\");\\n\\n        uint anchorPrice;\\n\\n        if (config.symbolHash == ethHash) {\\n            anchorPrice = ethPrice;\\n        } else {\\n            anchorPrice = fetchAnchorPrice(symbol, config, ethPrice);\\n        }\\n\\n        if (reporterInvalidated) {\\n            prices[config.symbolHash] = anchorPrice;\\n            emit PriceUpdated(symbol, anchorPrice);\\n        } else if (isWithinAnchor(reporterPrice, anchorPrice)) {\\n            prices[config.symbolHash] = reporterPrice;\\n            emit PriceUpdated(symbol, reporterPrice);\\n        } else {\\n            emit PriceGuarded(symbol, reporterPrice, anchorPrice);\\n        }\\n    }\\n\\n    /**\\n     * @dev Check if the reported price is within the range allowed by anchor ratio and anchor price from uniswap.\\n     */\\n    function isWithinAnchor(uint reporterPrice, uint anchorPrice) internal view returns (bool) {\\n        if (reporterPrice > 0) {\\n            uint anchorRatio = mul(reporterPrice, 100e16) / anchorPrice;\\n            return anchorRatio <= upperBoundAnchorRatio && anchorRatio >= lowerBoundAnchorRatio;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @dev Fetches the current token/eth price accumulator from uniswap.\\n     */\\n    function currentCumulativePrice(KTokenConfig memory config) internal view returns (uint) {\\n        (uint cumulativePrice0, uint cumulativePrice1,) = UniswapV2OracleLibrary.currentCumulativePrices(config.uniswapMarket);\\n        if (config.isUniswapReversed) {\\n            return cumulativePrice1;\\n        } else {\\n            return cumulativePrice0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Fetches the current eth/usd price from uniswap, with 6 decimals of precision.\\n     *  Conversion factor is 1e18 for eth/usdc market, since we decode uniswap price statically with 18 decimals.\\n     */\\n    function fetchEthPrice() internal returns (uint) {\\n        return fetchAnchorPrice(\\\"ETH\\\", getKTokenConfigBySymbolHash(ethHash), ethBaseUnit);\\n    }\\n\\n    /**\\n     * @dev Fetches the current token/usd price from uniswap, with 6 decimals of precision.\\n     * @param conversionFactor 1e18 if seeking the ETH price, and a 6 decimal ETH-USDC price in the case of other assets\\n     */\\n    function fetchAnchorPrice(string memory symbol, KTokenConfig memory config, uint conversionFactor) internal virtual returns (uint) {\\n        (uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp) = pokeWindowValues(config);\\n\\n        // This should be impossible, but better safe than sorry\\n        require(block.timestamp > oldTimestamp, \\\"now must come after before\\\");\\n        uint timeElapsed = block.timestamp - oldTimestamp;\\n\\n        // Calculate uniswap time-weighted average price\\n        // Underflow is a property of the accumulators: https://uniswap.org/audit.html#orgc9b3190\\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed));\\n        uint rawUniswapPriceMantissa = priceAverage.decode112with18();\\n        uint unscaledPriceMantissa = mul(rawUniswapPriceMantissa, conversionFactor);\\n        uint anchorPrice;\\n\\n        // Adjust rawUniswapPrice according to the units of the non-ETH asset\\n        // In the case of ETH, we would have to scale by 1e6 / USDC_UNITS, but since baseUnit2 is 1e6 (USDC), it cancels\\n\\n        // In the case of non-ETH tokens\\n        // a. pokeWindowValues already handled uniswap reversed cases, so priceAverage will always be Token/ETH TWAP price.\\n        // b. conversionFactor = ETH price * 1e6\\n        // unscaledPriceMantissa = priceAverage(token/ETH TWAP price) * expScale * conversionFactor\\n        // so ->\\n        // anchorPrice = priceAverage * tokenBaseUnit / ethBaseUnit * ETH_price * 1e6\\n        //             = priceAverage * conversionFactor * tokenBaseUnit / ethBaseUnit\\n        //             = unscaledPriceMantissa / expScale * tokenBaseUnit / ethBaseUnit\\n        anchorPrice = mul(unscaledPriceMantissa, config.baseUnit) / ethBaseUnit / expScale;\\n\\n        emit AnchorPriceUpdated(symbol, anchorPrice, oldTimestamp, block.timestamp);\\n\\n        return anchorPrice;\\n    }\\n\\n    /**\\n     * @dev Get time-weighted average prices for a token at the current timestamp.\\n     *  Update new and old observations of lagging window if period elapsed.\\n     */\\n    function pokeWindowValues(KTokenConfig memory config) internal returns (uint, uint, uint) {\\n        bytes32 symbolHash = config.symbolHash;\\n        uint cumulativePrice = currentCumulativePrice(config);\\n\\n        Observation memory newObservation = newObservations[symbolHash];\\n\\n        // Update new and old observations if elapsed time is greater than or equal to anchor period\\n        uint timeElapsed = block.timestamp - newObservation.timestamp;\\n        if (timeElapsed >= anchorPeriod) {\\n            oldObservations[symbolHash].timestamp = newObservation.timestamp;\\n            oldObservations[symbolHash].acc = newObservation.acc;\\n\\n            newObservations[symbolHash].timestamp = block.timestamp;\\n            newObservations[symbolHash].acc = cumulativePrice;\\n            emit UniswapWindowUpdated(config.symbolHash, newObservation.timestamp, block.timestamp, newObservation.acc, cumulativePrice);\\n        }\\n        return (cumulativePrice, oldObservations[symbolHash].acc, oldObservations[symbolHash].timestamp);\\n    }\\n\\n    /**\\n     * @notice Invalidate the reporter, and fall back to using anchor directly in all cases\\n     * @dev Only the reporter may sign a message which allows it to invalidate itself.\\n     *  To be used in cases of emergency, if the reporter thinks their key may be compromised.\\n     * @param message The data that was presumably signed\\n     * @param signature The fingerprint of the data + private key\\n     */\\n    function invalidateReporter(bytes memory message, bytes memory signature) external {\\n        (string memory decodedMessage,) = abi.decode(message, (string, address));\\n        require(keccak256(abi.encodePacked(decodedMessage)) == rotateHash, \\\"invalid message must be 'rotate'\\\");\\n        require(source(message, signature) == reporter, \\\"invalidation message must come from the reporter\\\");\\n        if(!reporterInvalidated){\\n            reporterInvalidated = true;\\n            emit ReporterInvalidated(reporter);\\n        }\\n    }\\n\\n    /**\\n     * @notice Recovers the source address which signed a message\\n     * @dev Comparing to a claimed address would add nothing,\\n     *  as the caller could simply perform the recover and claim that address.\\n     * @param message The data that was presumably signed\\n     * @param signature The fingerprint of the data + private key\\n     * @return The source address which signed the message, presumably\\n     */\\n    function source(bytes memory message, bytes memory signature) public pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = abi.decode(signature, (bytes32, bytes32, uint8));\\n        bytes32 hash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", keccak256(message)));\\n        return ecrecover(hash, v, r, s);\\n    }\\n\\n    /// @dev Overflow proof multiplication\\n    function mul(uint a, uint b) internal pure returns (uint) {\\n        if (a == 0) return 0;\\n        uint c = a * b;\\n        require(c / a == b, \\\"multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev The admin function used to redirect to new compound oracle\\n     */\\n    function setCompoundOracle(address oracleAddress) public onlyOwner {\\n        address oldCompoundOracle = address(compoundOracle);\\n        compoundOracle = ICompoundOracle(oracleAddress);\\n        emit CompoundOracleUpdated(oldCompoundOracle, oracleAddress);\\n    }\\n\\n    /// @dev The admin function to add config for supporting more token prices\\n    function addConfig(address kToken_, address underlying_, bytes32 symbolHash_, uint baseUnit_,\\n        KPriceSource priceSource_, uint fixedPrice_, address uniswapMarket_, bool isUniswapReversed_) public onlyOwner {\\n        KTokenConfig memory config =\\n        KTokenConfig({\\n        kToken: kToken_,\\n        underlying: underlying_,\\n        symbolHash: symbolHash_,\\n        baseUnit: baseUnit_,\\n        priceSource: priceSource_,\\n        fixedPrice: fixedPrice_,\\n        uniswapMarket: uniswapMarket_,\\n        isUniswapReversed: isUniswapReversed_\\n        });\\n        require(config.baseUnit > 0, \\\"baseUnit must be greater than zero\\\");\\n\\n        // configuration integrity check\\n        if(config.symbolHash != ethHash && config.priceSource == KPriceSource.REPORTER){\\n            checkConfig(config);\\n        }\\n\\n        address uniswapMarket = config.uniswapMarket;\\n        if (config.priceSource == KPriceSource.REPORTER || config.symbolHash == ethHash) {\\n            require(uniswapMarket != address(0), \\\"prices must have an anchor\\\");\\n            bytes32 symbolHash = config.symbolHash;\\n            uint cumulativePrice = currentCumulativePrice(config);\\n            oldObservations[symbolHash].timestamp = block.timestamp;\\n            newObservations[symbolHash].timestamp = block.timestamp;\\n            oldObservations[symbolHash].acc = cumulativePrice;\\n            newObservations[symbolHash].acc = cumulativePrice;\\n            emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);\\n        } else {\\n            require(uniswapMarket == address(0), \\\"only reported prices utilize an anchor\\\");\\n        }\\n        kTokenConfigs.push(config);\\n        emit TokenConfigAdded(config.kToken, config.underlying, config.symbolHash, config.baseUnit,\\n            config.priceSource, config.fixedPrice, config.uniswapMarket, config.isUniswapReversed);\\n    }\\n\\n    /// @dev The admin function to remove config by its kToken address\\n    function removeConfigByKToken(address kToken) public onlyOwner {\\n        uint index = getKConfigIndexByKToken(kToken);\\n        if (index == uint(-1)) {\\n            revert(\\\"not found\\\");\\n        }\\n        KTokenConfig memory tmpConfig = kTokenConfigs[index];\\n        kTokenConfigs[index] = kTokenConfigs[kTokenConfigs.length - 1];\\n\\n        // remove all token related information\\n        delete oldObservations[tmpConfig.symbolHash];\\n        delete newObservations[tmpConfig.symbolHash];\\n        delete prices[tmpConfig.symbolHash];\\n\\n        kTokenConfigs.pop();\\n        emit TokenConfigRemoved(tmpConfig.kToken, tmpConfig.underlying, tmpConfig.symbolHash, tmpConfig.baseUnit,\\n            tmpConfig.priceSource, tmpConfig.fixedPrice, tmpConfig.uniswapMarket, tmpConfig.isUniswapReversed);\\n    }\\n\\n    /**\\n     * @dev The admin function to change price reporter\\n     * This function will set the new price reporter and set the reporterInvalidated flag to false\\n     */\\n    function changeReporter(address reporter_) public onlyOwner{\\n        require(reporter_ != reporter, \\\"same reporter\\\");\\n        address oldReporter = reporter;\\n        reporter = reporter_;\\n        if(reporterInvalidated){\\n            reporterInvalidated = false;\\n        }\\n        emit ReporterUpdated(oldReporter, reporter_);\\n    }\\n\\n    /**\\n     * @dev The admin function to change the kaptain contract address\\n     */\\n    function changeKaptain(address kaptain_) public onlyOwner{\\n        require(kaptain != kaptain_, \\\"same kaptain\\\");\\n        address oldKaptain = kaptain;\\n        kaptain = kaptain_;\\n        emit KaptainUpdated(oldKaptain, kaptain_);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/rickierao/IdeaProjects/kine-oracle/contracts/OpenOracleData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title The Open Oracle Data Base Contract\\n * @author Compound Labs, Inc.\\n */\\ncontract OpenOracleData {\\n    /**\\n     * @notice The event emitted when a source writes to its storage\\n     */\\n    //event Write(address indexed source, <Key> indexed key, string kind, uint64 timestamp, <Value> value);\\n\\n    /**\\n     * @notice Write a bunch of signed datum to the authenticated storage mapping\\n     * @param message The payload containing the timestamp, and (key, value) pairs\\n     * @param signature The cryptographic signature of the message payload, authorizing the source to write\\n     * @return The keys that were written\\n     */\\n    //function put(bytes calldata message, bytes calldata signature) external returns (<Key> memory);\\n\\n    /**\\n     * @notice Read a single key with a pre-defined type signature from an authenticated source\\n     * @param source The verifiable author of the data\\n     * @param key The selector for the value to return\\n     * @return The claimed Unix timestamp for the data and the encoded value (defaults to (0, 0x))\\n     */\\n    //function get(address source, <Key> key) external view returns (uint, <Value>);\\n\\n    /**\\n     * @notice Recovers the source address which signed a message\\n     * @dev Comparing to a claimed address would add nothing,\\n     *  as the caller could simply perform the recover and claim that address.\\n     * @param message The data that was presumably signed\\n     * @param signature The fingerprint of the data + private key\\n     * @return The source address which signed the message, presumably\\n     */\\n    function source(bytes memory message, bytes memory signature) public pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = abi.decode(signature, (bytes32, bytes32, uint8));\\n        bytes32 hash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", keccak256(message)));\\n        return ecrecover(hash, v, r, s);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/rickierao/IdeaProjects/kine-oracle/contracts/OpenOraclePriceData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.6.10;\\n\\nimport \\\"./OpenOracleData.sol\\\";\\n\\n/**\\n * @title The Open Oracle Price Data Contract\\n * @notice Values stored in this contract should represent a USD price with 6 decimals precision\\n * @author Compound Labs, Inc.\\n */\\ncontract OpenOraclePriceData is OpenOracleData {\\n    ///@notice The event emitted when a source writes to its storage\\n    event Write(address indexed source, string key, uint64 timestamp, uint64 value);\\n    ///@notice The event emitted when the timestamp on a price is invalid and it is not written to storage\\n    event NotWritten(uint64 priorTimestamp, uint256 messageTimestamp, uint256 blockTimestamp);\\n\\n    ///@notice The fundamental unit of storage for a reporter source\\n    struct Datum {\\n        uint64 timestamp;\\n        uint64 value;\\n    }\\n\\n    /**\\n     * @dev The most recent authenticated data from all sources.\\n     *  This is private because dynamic mapping keys preclude auto-generated getters.\\n     */\\n    mapping(address => mapping(string => Datum)) private data;\\n\\n    /**\\n     * @notice Write a bunch of signed datum to the authenticated storage mapping\\n     * @param message The payload containing the timestamp, and (key, value) pairs\\n     * @param signature The cryptographic signature of the message payload, authorizing the source to write\\n     * @return The keys that were written\\n     */\\n    function put(bytes calldata message, bytes calldata signature) external returns (string memory) {\\n        (address source, uint64 timestamp, string memory key, uint64 value) = decodeMessage(message, signature);\\n        return putInternal(source, timestamp, key, value);\\n    }\\n\\n    function putInternal(address source, uint64 timestamp, string memory key, uint64 value) internal returns (string memory) {\\n        // Only update if newer than stored, according to source\\n        Datum storage prior = data[source][key];\\n        if (timestamp > prior.timestamp && timestamp < block.timestamp + 60 minutes && source != address(0)) {\\n            data[source][key] = Datum(timestamp, value);\\n            emit Write(source, key, timestamp, value);\\n        } else {\\n            emit NotWritten(prior.timestamp, timestamp, block.timestamp);\\n        }\\n        return key;\\n    }\\n\\n    function decodeMessage(bytes calldata message, bytes calldata signature) internal pure returns (address, uint64, string memory, uint64) {\\n        // Recover the source address\\n        address source = source(message, signature);\\n\\n        // Decode the message and check the kind\\n        (string memory kind, uint64 timestamp, string memory key, uint64 value) = abi.decode(message, (string, uint64, string, uint64));\\n        require(keccak256(abi.encodePacked(kind)) == keccak256(abi.encodePacked(\\\"prices\\\")), \\\"Kind of data must be 'prices'\\\");\\n        return (source, timestamp, key, value);\\n    }\\n\\n    /**\\n     * @notice Read a single key from an authenticated source\\n     * @param source The verifiable author of the data\\n     * @param key The selector for the value to return\\n     * @return The claimed Unix timestamp for the data and the price value (defaults to (0, 0))\\n     */\\n    function get(address source, string calldata key) external view returns (uint64, uint64) {\\n        Datum storage datum = data[source][key];\\n        return (datum.timestamp, datum.value);\\n    }\\n\\n    /**\\n     * @notice Read only the value for a single key from an authenticated source\\n     * @param source The verifiable author of the data\\n     * @param key The selector for the value to return\\n     * @return The price value (defaults to 0)\\n     */\\n    function getPrice(address source, string calldata key) external view returns (uint64) {\\n        return data[source][key].value;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/rickierao/IdeaProjects/kine-oracle/contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/rickierao/IdeaProjects/kine-oracle/contracts/PriceConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.6.10;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./UniswapLib.sol\\\";\\n\\n/// @title Oracle config for Kine Oracle\\n/// @author Kine\\ncontract PriceConfig is Ownable {\\n    /// @dev Describe how to interpret the fixedPrice in the TokenConfig.\\n    enum KPriceSource {\\n        FIXED_ETH, /// implies the fixedPrice is a constant multiple of the ETH price (which varies)\\n        FIXED_USD, /// implies the fixedPrice is a constant multiple of the USD price (which is 1)\\n        REPORTER, /// implies the price is set by the reporter,\\n        KAPTAIN, /// implies the price is not anchored and rely on kaptain post\\n        COMPOUND /// implies the price only comes from compound oracle\\n    }\\n\\n    /// @notice Describe how the USD price should be determined for an asset.\\n    /**\\n      * @dev There should be 1 KTokenConfig object for each supported asset, passed in the constructor.\\n      * if the underlying is not priced in KineOracle (i.e. is from compound oracle), this should be address(0)\\n      */\\n    struct KTokenConfig {\\n        address kToken;\\n        address underlying;\\n        bytes32 symbolHash;\\n        uint baseUnit;\\n        KPriceSource priceSource;\\n        uint fixedPrice;\\n        address uniswapMarket;\\n        bool isUniswapReversed;\\n    }\\n\\n    /// @dev The dynamic config array\\n    KTokenConfig[] public kTokenConfigs;\\n\\n    // @notice Uniswap factory address for pair address check\\n    address public uniswapFactory;\\n\\n    // @notice WETH address for pair address and token order check\\n    address public wrappedETHAddress;\\n\\n    function getKConfigIndexByKToken(address kToken) public view returns (uint){\\n        for (uint i = 0; i < kTokenConfigs.length; i++) {\\n            KTokenConfig memory config = kTokenConfigs[i];\\n            if (config.kToken == kToken) {\\n                return i;\\n            }\\n        }\\n        return uint(-1);\\n    }\\n\\n    function getKConfigIndexByUnderlying(address underlying) public view returns (uint){\\n        for (uint i = 0; i < kTokenConfigs.length; i++) {\\n            KTokenConfig memory config = kTokenConfigs[i];\\n            if (config.underlying == underlying) {\\n                return i;\\n            }\\n        }\\n        return uint(-1);\\n    }\\n\\n    function getKConfigIndexBySymbolHash(bytes32 symbolHash) public view returns (uint){\\n        for (uint i = 0; i < kTokenConfigs.length; i++) {\\n            KTokenConfig memory config = kTokenConfigs[i];\\n            if (config.symbolHash == symbolHash) {\\n                return i;\\n            }\\n        }\\n        return uint(-1);\\n    }\\n\\n\\n    // This should only be called before getting the compound price\\n    // so that if config not found in compound later, compound will revert\\n    function getKConfigByKToken(address kToken) public view returns (KTokenConfig memory) {\\n        uint index = getKConfigIndexByKToken(kToken);\\n        if (index != uint(-1)) {\\n            return kTokenConfigs[index];\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the config for symbol\\n     * @param symbol The symbol of the config to get\\n     * @return The config object\\n     */\\n    function getKTokenConfigBySymbol(string memory symbol) public view returns (KTokenConfig memory) {\\n        return getKTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));\\n    }\\n\\n    /**\\n     * @notice Get the config for the symbolHash\\n     * @param symbolHash The keccack256 of the symbol of the config to get\\n     * @return The config object\\n     */\\n    function getKTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (KTokenConfig memory) {\\n        uint index = getKConfigIndexBySymbolHash(symbolHash);\\n        if (index != uint(-1)) {\\n            return kTokenConfigs[index];\\n        }\\n    }\\n\\n    /**\\n     * @notice Check the KTokenConfig integrity\\n     */\\n    function checkConfig(KTokenConfig memory config) public view {\\n        address pair = UniswapV2OracleLibrary.pairFor(uniswapFactory, wrappedETHAddress, config.underlying);\\n        // wrong uniswapFactory address, or wrong WETH address, or wrong underlying address\\n        require(pair == config.uniswapMarket, \\\"kTokenConfig uniswap market check failed\\\");\\n\\n        // check isUniswapReversed flag\\n        bool isUniswapReversed = config.underlying < wrappedETHAddress ? false : true;\\n        require(isUniswapReversed == config.isUniswapReversed, \\\"kTokenConfig pair order check failed\\\");\\n    }\\n}\"\r\n    },\r\n    \"/Users/rickierao/IdeaProjects/kine-oracle/contracts/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n}\"\r\n    },\r\n    \"/Users/rickierao/IdeaProjects/kine-oracle/contracts/UniswapConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\ninterface CErc20 {\\n    function underlying() external view returns (address);\\n}\\n\\ncontract UniswapConfig {\\n    /// @dev Describe how to interpret the fixedPrice in the TokenConfig.\\n    enum PriceSource {\\n        FIXED_ETH, /// implies the fixedPrice is a constant multiple of the ETH price (which varies)\\n        FIXED_USD, /// implies the fixedPrice is a constant multiple of the USD price (which is 1)\\n        REPORTER   /// implies the price is set by the reporter\\n    }\\n\\n    /// @dev Describe how the USD price should be determined for an asset.\\n    ///  There should be 1 TokenConfig object for each supported asset, passed in the constructor.\\n    struct TokenConfig {\\n        address cToken;\\n        address underlying;\\n        bytes32 symbolHash;\\n        uint256 baseUnit;\\n        PriceSource priceSource;\\n        uint256 fixedPrice;\\n        address uniswapMarket;\\n        bool isUniswapReversed;\\n    }\\n\\n    /// @notice The max number of tokens this contract is hardcoded to support\\n    /// @dev Do not change this variable without updating all the fields throughout the contract.\\n    uint public constant maxTokens = 30;\\n\\n    /// @notice The number of tokens this contract actually supports\\n    uint public immutable numTokens;\\n\\n    address internal immutable cToken00;\\n    address internal immutable cToken01;\\n    address internal immutable cToken02;\\n    address internal immutable cToken03;\\n    address internal immutable cToken04;\\n    address internal immutable cToken05;\\n    address internal immutable cToken06;\\n    address internal immutable cToken07;\\n    address internal immutable cToken08;\\n    address internal immutable cToken09;\\n    address internal immutable cToken10;\\n    address internal immutable cToken11;\\n    address internal immutable cToken12;\\n    address internal immutable cToken13;\\n    address internal immutable cToken14;\\n    address internal immutable cToken15;\\n    address internal immutable cToken16;\\n    address internal immutable cToken17;\\n    address internal immutable cToken18;\\n    address internal immutable cToken19;\\n    address internal immutable cToken20;\\n    address internal immutable cToken21;\\n    address internal immutable cToken22;\\n    address internal immutable cToken23;\\n    address internal immutable cToken24;\\n    address internal immutable cToken25;\\n    address internal immutable cToken26;\\n    address internal immutable cToken27;\\n    address internal immutable cToken28;\\n    address internal immutable cToken29;\\n\\n    address internal immutable underlying00;\\n    address internal immutable underlying01;\\n    address internal immutable underlying02;\\n    address internal immutable underlying03;\\n    address internal immutable underlying04;\\n    address internal immutable underlying05;\\n    address internal immutable underlying06;\\n    address internal immutable underlying07;\\n    address internal immutable underlying08;\\n    address internal immutable underlying09;\\n    address internal immutable underlying10;\\n    address internal immutable underlying11;\\n    address internal immutable underlying12;\\n    address internal immutable underlying13;\\n    address internal immutable underlying14;\\n    address internal immutable underlying15;\\n    address internal immutable underlying16;\\n    address internal immutable underlying17;\\n    address internal immutable underlying18;\\n    address internal immutable underlying19;\\n    address internal immutable underlying20;\\n    address internal immutable underlying21;\\n    address internal immutable underlying22;\\n    address internal immutable underlying23;\\n    address internal immutable underlying24;\\n    address internal immutable underlying25;\\n    address internal immutable underlying26;\\n    address internal immutable underlying27;\\n    address internal immutable underlying28;\\n    address internal immutable underlying29;\\n\\n    bytes32 internal immutable symbolHash00;\\n    bytes32 internal immutable symbolHash01;\\n    bytes32 internal immutable symbolHash02;\\n    bytes32 internal immutable symbolHash03;\\n    bytes32 internal immutable symbolHash04;\\n    bytes32 internal immutable symbolHash05;\\n    bytes32 internal immutable symbolHash06;\\n    bytes32 internal immutable symbolHash07;\\n    bytes32 internal immutable symbolHash08;\\n    bytes32 internal immutable symbolHash09;\\n    bytes32 internal immutable symbolHash10;\\n    bytes32 internal immutable symbolHash11;\\n    bytes32 internal immutable symbolHash12;\\n    bytes32 internal immutable symbolHash13;\\n    bytes32 internal immutable symbolHash14;\\n    bytes32 internal immutable symbolHash15;\\n    bytes32 internal immutable symbolHash16;\\n    bytes32 internal immutable symbolHash17;\\n    bytes32 internal immutable symbolHash18;\\n    bytes32 internal immutable symbolHash19;\\n    bytes32 internal immutable symbolHash20;\\n    bytes32 internal immutable symbolHash21;\\n    bytes32 internal immutable symbolHash22;\\n    bytes32 internal immutable symbolHash23;\\n    bytes32 internal immutable symbolHash24;\\n    bytes32 internal immutable symbolHash25;\\n    bytes32 internal immutable symbolHash26;\\n    bytes32 internal immutable symbolHash27;\\n    bytes32 internal immutable symbolHash28;\\n    bytes32 internal immutable symbolHash29;\\n\\n    uint256 internal immutable baseUnit00;\\n    uint256 internal immutable baseUnit01;\\n    uint256 internal immutable baseUnit02;\\n    uint256 internal immutable baseUnit03;\\n    uint256 internal immutable baseUnit04;\\n    uint256 internal immutable baseUnit05;\\n    uint256 internal immutable baseUnit06;\\n    uint256 internal immutable baseUnit07;\\n    uint256 internal immutable baseUnit08;\\n    uint256 internal immutable baseUnit09;\\n    uint256 internal immutable baseUnit10;\\n    uint256 internal immutable baseUnit11;\\n    uint256 internal immutable baseUnit12;\\n    uint256 internal immutable baseUnit13;\\n    uint256 internal immutable baseUnit14;\\n    uint256 internal immutable baseUnit15;\\n    uint256 internal immutable baseUnit16;\\n    uint256 internal immutable baseUnit17;\\n    uint256 internal immutable baseUnit18;\\n    uint256 internal immutable baseUnit19;\\n    uint256 internal immutable baseUnit20;\\n    uint256 internal immutable baseUnit21;\\n    uint256 internal immutable baseUnit22;\\n    uint256 internal immutable baseUnit23;\\n    uint256 internal immutable baseUnit24;\\n    uint256 internal immutable baseUnit25;\\n    uint256 internal immutable baseUnit26;\\n    uint256 internal immutable baseUnit27;\\n    uint256 internal immutable baseUnit28;\\n    uint256 internal immutable baseUnit29;\\n\\n    PriceSource internal immutable priceSource00;\\n    PriceSource internal immutable priceSource01;\\n    PriceSource internal immutable priceSource02;\\n    PriceSource internal immutable priceSource03;\\n    PriceSource internal immutable priceSource04;\\n    PriceSource internal immutable priceSource05;\\n    PriceSource internal immutable priceSource06;\\n    PriceSource internal immutable priceSource07;\\n    PriceSource internal immutable priceSource08;\\n    PriceSource internal immutable priceSource09;\\n    PriceSource internal immutable priceSource10;\\n    PriceSource internal immutable priceSource11;\\n    PriceSource internal immutable priceSource12;\\n    PriceSource internal immutable priceSource13;\\n    PriceSource internal immutable priceSource14;\\n    PriceSource internal immutable priceSource15;\\n    PriceSource internal immutable priceSource16;\\n    PriceSource internal immutable priceSource17;\\n    PriceSource internal immutable priceSource18;\\n    PriceSource internal immutable priceSource19;\\n    PriceSource internal immutable priceSource20;\\n    PriceSource internal immutable priceSource21;\\n    PriceSource internal immutable priceSource22;\\n    PriceSource internal immutable priceSource23;\\n    PriceSource internal immutable priceSource24;\\n    PriceSource internal immutable priceSource25;\\n    PriceSource internal immutable priceSource26;\\n    PriceSource internal immutable priceSource27;\\n    PriceSource internal immutable priceSource28;\\n    PriceSource internal immutable priceSource29;\\n\\n    uint256 internal immutable fixedPrice00;\\n    uint256 internal immutable fixedPrice01;\\n    uint256 internal immutable fixedPrice02;\\n    uint256 internal immutable fixedPrice03;\\n    uint256 internal immutable fixedPrice04;\\n    uint256 internal immutable fixedPrice05;\\n    uint256 internal immutable fixedPrice06;\\n    uint256 internal immutable fixedPrice07;\\n    uint256 internal immutable fixedPrice08;\\n    uint256 internal immutable fixedPrice09;\\n    uint256 internal immutable fixedPrice10;\\n    uint256 internal immutable fixedPrice11;\\n    uint256 internal immutable fixedPrice12;\\n    uint256 internal immutable fixedPrice13;\\n    uint256 internal immutable fixedPrice14;\\n    uint256 internal immutable fixedPrice15;\\n    uint256 internal immutable fixedPrice16;\\n    uint256 internal immutable fixedPrice17;\\n    uint256 internal immutable fixedPrice18;\\n    uint256 internal immutable fixedPrice19;\\n    uint256 internal immutable fixedPrice20;\\n    uint256 internal immutable fixedPrice21;\\n    uint256 internal immutable fixedPrice22;\\n    uint256 internal immutable fixedPrice23;\\n    uint256 internal immutable fixedPrice24;\\n    uint256 internal immutable fixedPrice25;\\n    uint256 internal immutable fixedPrice26;\\n    uint256 internal immutable fixedPrice27;\\n    uint256 internal immutable fixedPrice28;\\n    uint256 internal immutable fixedPrice29;\\n\\n    address internal immutable uniswapMarket00;\\n    address internal immutable uniswapMarket01;\\n    address internal immutable uniswapMarket02;\\n    address internal immutable uniswapMarket03;\\n    address internal immutable uniswapMarket04;\\n    address internal immutable uniswapMarket05;\\n    address internal immutable uniswapMarket06;\\n    address internal immutable uniswapMarket07;\\n    address internal immutable uniswapMarket08;\\n    address internal immutable uniswapMarket09;\\n    address internal immutable uniswapMarket10;\\n    address internal immutable uniswapMarket11;\\n    address internal immutable uniswapMarket12;\\n    address internal immutable uniswapMarket13;\\n    address internal immutable uniswapMarket14;\\n    address internal immutable uniswapMarket15;\\n    address internal immutable uniswapMarket16;\\n    address internal immutable uniswapMarket17;\\n    address internal immutable uniswapMarket18;\\n    address internal immutable uniswapMarket19;\\n    address internal immutable uniswapMarket20;\\n    address internal immutable uniswapMarket21;\\n    address internal immutable uniswapMarket22;\\n    address internal immutable uniswapMarket23;\\n    address internal immutable uniswapMarket24;\\n    address internal immutable uniswapMarket25;\\n    address internal immutable uniswapMarket26;\\n    address internal immutable uniswapMarket27;\\n    address internal immutable uniswapMarket28;\\n    address internal immutable uniswapMarket29;\\n\\n    bool internal immutable isUniswapReversed00;\\n    bool internal immutable isUniswapReversed01;\\n    bool internal immutable isUniswapReversed02;\\n    bool internal immutable isUniswapReversed03;\\n    bool internal immutable isUniswapReversed04;\\n    bool internal immutable isUniswapReversed05;\\n    bool internal immutable isUniswapReversed06;\\n    bool internal immutable isUniswapReversed07;\\n    bool internal immutable isUniswapReversed08;\\n    bool internal immutable isUniswapReversed09;\\n    bool internal immutable isUniswapReversed10;\\n    bool internal immutable isUniswapReversed11;\\n    bool internal immutable isUniswapReversed12;\\n    bool internal immutable isUniswapReversed13;\\n    bool internal immutable isUniswapReversed14;\\n    bool internal immutable isUniswapReversed15;\\n    bool internal immutable isUniswapReversed16;\\n    bool internal immutable isUniswapReversed17;\\n    bool internal immutable isUniswapReversed18;\\n    bool internal immutable isUniswapReversed19;\\n    bool internal immutable isUniswapReversed20;\\n    bool internal immutable isUniswapReversed21;\\n    bool internal immutable isUniswapReversed22;\\n    bool internal immutable isUniswapReversed23;\\n    bool internal immutable isUniswapReversed24;\\n    bool internal immutable isUniswapReversed25;\\n    bool internal immutable isUniswapReversed26;\\n    bool internal immutable isUniswapReversed27;\\n    bool internal immutable isUniswapReversed28;\\n    bool internal immutable isUniswapReversed29;\\n\\n    /**\\n     * @notice Construct an immutable store of configs into the contract data\\n     * @param configs The configs for the supported assets\\n     */\\n    constructor(TokenConfig[] memory configs) public {\\n        require(configs.length <= maxTokens, \\\"too many configs\\\");\\n        numTokens = configs.length;\\n\\n        cToken00 = get(configs, 0).cToken;\\n        cToken01 = get(configs, 1).cToken;\\n        cToken02 = get(configs, 2).cToken;\\n        cToken03 = get(configs, 3).cToken;\\n        cToken04 = get(configs, 4).cToken;\\n        cToken05 = get(configs, 5).cToken;\\n        cToken06 = get(configs, 6).cToken;\\n        cToken07 = get(configs, 7).cToken;\\n        cToken08 = get(configs, 8).cToken;\\n        cToken09 = get(configs, 9).cToken;\\n        cToken10 = get(configs, 10).cToken;\\n        cToken11 = get(configs, 11).cToken;\\n        cToken12 = get(configs, 12).cToken;\\n        cToken13 = get(configs, 13).cToken;\\n        cToken14 = get(configs, 14).cToken;\\n        cToken15 = get(configs, 15).cToken;\\n        cToken16 = get(configs, 16).cToken;\\n        cToken17 = get(configs, 17).cToken;\\n        cToken18 = get(configs, 18).cToken;\\n        cToken19 = get(configs, 19).cToken;\\n        cToken20 = get(configs, 20).cToken;\\n        cToken21 = get(configs, 21).cToken;\\n        cToken22 = get(configs, 22).cToken;\\n        cToken23 = get(configs, 23).cToken;\\n        cToken24 = get(configs, 24).cToken;\\n        cToken25 = get(configs, 25).cToken;\\n        cToken26 = get(configs, 26).cToken;\\n        cToken27 = get(configs, 27).cToken;\\n        cToken28 = get(configs, 28).cToken;\\n        cToken29 = get(configs, 29).cToken;\\n\\n        underlying00 = get(configs, 0).underlying;\\n        underlying01 = get(configs, 1).underlying;\\n        underlying02 = get(configs, 2).underlying;\\n        underlying03 = get(configs, 3).underlying;\\n        underlying04 = get(configs, 4).underlying;\\n        underlying05 = get(configs, 5).underlying;\\n        underlying06 = get(configs, 6).underlying;\\n        underlying07 = get(configs, 7).underlying;\\n        underlying08 = get(configs, 8).underlying;\\n        underlying09 = get(configs, 9).underlying;\\n        underlying10 = get(configs, 10).underlying;\\n        underlying11 = get(configs, 11).underlying;\\n        underlying12 = get(configs, 12).underlying;\\n        underlying13 = get(configs, 13).underlying;\\n        underlying14 = get(configs, 14).underlying;\\n        underlying15 = get(configs, 15).underlying;\\n        underlying16 = get(configs, 16).underlying;\\n        underlying17 = get(configs, 17).underlying;\\n        underlying18 = get(configs, 18).underlying;\\n        underlying19 = get(configs, 19).underlying;\\n        underlying20 = get(configs, 20).underlying;\\n        underlying21 = get(configs, 21).underlying;\\n        underlying22 = get(configs, 22).underlying;\\n        underlying23 = get(configs, 23).underlying;\\n        underlying24 = get(configs, 24).underlying;\\n        underlying25 = get(configs, 25).underlying;\\n        underlying26 = get(configs, 26).underlying;\\n        underlying27 = get(configs, 27).underlying;\\n        underlying28 = get(configs, 28).underlying;\\n        underlying29 = get(configs, 29).underlying;\\n\\n        symbolHash00 = get(configs, 0).symbolHash;\\n        symbolHash01 = get(configs, 1).symbolHash;\\n        symbolHash02 = get(configs, 2).symbolHash;\\n        symbolHash03 = get(configs, 3).symbolHash;\\n        symbolHash04 = get(configs, 4).symbolHash;\\n        symbolHash05 = get(configs, 5).symbolHash;\\n        symbolHash06 = get(configs, 6).symbolHash;\\n        symbolHash07 = get(configs, 7).symbolHash;\\n        symbolHash08 = get(configs, 8).symbolHash;\\n        symbolHash09 = get(configs, 9).symbolHash;\\n        symbolHash10 = get(configs, 10).symbolHash;\\n        symbolHash11 = get(configs, 11).symbolHash;\\n        symbolHash12 = get(configs, 12).symbolHash;\\n        symbolHash13 = get(configs, 13).symbolHash;\\n        symbolHash14 = get(configs, 14).symbolHash;\\n        symbolHash15 = get(configs, 15).symbolHash;\\n        symbolHash16 = get(configs, 16).symbolHash;\\n        symbolHash17 = get(configs, 17).symbolHash;\\n        symbolHash18 = get(configs, 18).symbolHash;\\n        symbolHash19 = get(configs, 19).symbolHash;\\n        symbolHash20 = get(configs, 20).symbolHash;\\n        symbolHash21 = get(configs, 21).symbolHash;\\n        symbolHash22 = get(configs, 22).symbolHash;\\n        symbolHash23 = get(configs, 23).symbolHash;\\n        symbolHash24 = get(configs, 24).symbolHash;\\n        symbolHash25 = get(configs, 25).symbolHash;\\n        symbolHash26 = get(configs, 26).symbolHash;\\n        symbolHash27 = get(configs, 27).symbolHash;\\n        symbolHash28 = get(configs, 28).symbolHash;\\n        symbolHash29 = get(configs, 29).symbolHash;\\n\\n        baseUnit00 = get(configs, 0).baseUnit;\\n        baseUnit01 = get(configs, 1).baseUnit;\\n        baseUnit02 = get(configs, 2).baseUnit;\\n        baseUnit03 = get(configs, 3).baseUnit;\\n        baseUnit04 = get(configs, 4).baseUnit;\\n        baseUnit05 = get(configs, 5).baseUnit;\\n        baseUnit06 = get(configs, 6).baseUnit;\\n        baseUnit07 = get(configs, 7).baseUnit;\\n        baseUnit08 = get(configs, 8).baseUnit;\\n        baseUnit09 = get(configs, 9).baseUnit;\\n        baseUnit10 = get(configs, 10).baseUnit;\\n        baseUnit11 = get(configs, 11).baseUnit;\\n        baseUnit12 = get(configs, 12).baseUnit;\\n        baseUnit13 = get(configs, 13).baseUnit;\\n        baseUnit14 = get(configs, 14).baseUnit;\\n        baseUnit15 = get(configs, 15).baseUnit;\\n        baseUnit16 = get(configs, 16).baseUnit;\\n        baseUnit17 = get(configs, 17).baseUnit;\\n        baseUnit18 = get(configs, 18).baseUnit;\\n        baseUnit19 = get(configs, 19).baseUnit;\\n        baseUnit20 = get(configs, 20).baseUnit;\\n        baseUnit21 = get(configs, 21).baseUnit;\\n        baseUnit22 = get(configs, 22).baseUnit;\\n        baseUnit23 = get(configs, 23).baseUnit;\\n        baseUnit24 = get(configs, 24).baseUnit;\\n        baseUnit25 = get(configs, 25).baseUnit;\\n        baseUnit26 = get(configs, 26).baseUnit;\\n        baseUnit27 = get(configs, 27).baseUnit;\\n        baseUnit28 = get(configs, 28).baseUnit;\\n        baseUnit29 = get(configs, 29).baseUnit;\\n\\n        priceSource00 = get(configs, 0).priceSource;\\n        priceSource01 = get(configs, 1).priceSource;\\n        priceSource02 = get(configs, 2).priceSource;\\n        priceSource03 = get(configs, 3).priceSource;\\n        priceSource04 = get(configs, 4).priceSource;\\n        priceSource05 = get(configs, 5).priceSource;\\n        priceSource06 = get(configs, 6).priceSource;\\n        priceSource07 = get(configs, 7).priceSource;\\n        priceSource08 = get(configs, 8).priceSource;\\n        priceSource09 = get(configs, 9).priceSource;\\n        priceSource10 = get(configs, 10).priceSource;\\n        priceSource11 = get(configs, 11).priceSource;\\n        priceSource12 = get(configs, 12).priceSource;\\n        priceSource13 = get(configs, 13).priceSource;\\n        priceSource14 = get(configs, 14).priceSource;\\n        priceSource15 = get(configs, 15).priceSource;\\n        priceSource16 = get(configs, 16).priceSource;\\n        priceSource17 = get(configs, 17).priceSource;\\n        priceSource18 = get(configs, 18).priceSource;\\n        priceSource19 = get(configs, 19).priceSource;\\n        priceSource20 = get(configs, 20).priceSource;\\n        priceSource21 = get(configs, 21).priceSource;\\n        priceSource22 = get(configs, 22).priceSource;\\n        priceSource23 = get(configs, 23).priceSource;\\n        priceSource24 = get(configs, 24).priceSource;\\n        priceSource25 = get(configs, 25).priceSource;\\n        priceSource26 = get(configs, 26).priceSource;\\n        priceSource27 = get(configs, 27).priceSource;\\n        priceSource28 = get(configs, 28).priceSource;\\n        priceSource29 = get(configs, 29).priceSource;\\n\\n        fixedPrice00 = get(configs, 0).fixedPrice;\\n        fixedPrice01 = get(configs, 1).fixedPrice;\\n        fixedPrice02 = get(configs, 2).fixedPrice;\\n        fixedPrice03 = get(configs, 3).fixedPrice;\\n        fixedPrice04 = get(configs, 4).fixedPrice;\\n        fixedPrice05 = get(configs, 5).fixedPrice;\\n        fixedPrice06 = get(configs, 6).fixedPrice;\\n        fixedPrice07 = get(configs, 7).fixedPrice;\\n        fixedPrice08 = get(configs, 8).fixedPrice;\\n        fixedPrice09 = get(configs, 9).fixedPrice;\\n        fixedPrice10 = get(configs, 10).fixedPrice;\\n        fixedPrice11 = get(configs, 11).fixedPrice;\\n        fixedPrice12 = get(configs, 12).fixedPrice;\\n        fixedPrice13 = get(configs, 13).fixedPrice;\\n        fixedPrice14 = get(configs, 14).fixedPrice;\\n        fixedPrice15 = get(configs, 15).fixedPrice;\\n        fixedPrice16 = get(configs, 16).fixedPrice;\\n        fixedPrice17 = get(configs, 17).fixedPrice;\\n        fixedPrice18 = get(configs, 18).fixedPrice;\\n        fixedPrice19 = get(configs, 19).fixedPrice;\\n        fixedPrice20 = get(configs, 20).fixedPrice;\\n        fixedPrice21 = get(configs, 21).fixedPrice;\\n        fixedPrice22 = get(configs, 22).fixedPrice;\\n        fixedPrice23 = get(configs, 23).fixedPrice;\\n        fixedPrice24 = get(configs, 24).fixedPrice;\\n        fixedPrice25 = get(configs, 25).fixedPrice;\\n        fixedPrice26 = get(configs, 26).fixedPrice;\\n        fixedPrice27 = get(configs, 27).fixedPrice;\\n        fixedPrice28 = get(configs, 28).fixedPrice;\\n        fixedPrice29 = get(configs, 29).fixedPrice;\\n\\n        uniswapMarket00 = get(configs, 0).uniswapMarket;\\n        uniswapMarket01 = get(configs, 1).uniswapMarket;\\n        uniswapMarket02 = get(configs, 2).uniswapMarket;\\n        uniswapMarket03 = get(configs, 3).uniswapMarket;\\n        uniswapMarket04 = get(configs, 4).uniswapMarket;\\n        uniswapMarket05 = get(configs, 5).uniswapMarket;\\n        uniswapMarket06 = get(configs, 6).uniswapMarket;\\n        uniswapMarket07 = get(configs, 7).uniswapMarket;\\n        uniswapMarket08 = get(configs, 8).uniswapMarket;\\n        uniswapMarket09 = get(configs, 9).uniswapMarket;\\n        uniswapMarket10 = get(configs, 10).uniswapMarket;\\n        uniswapMarket11 = get(configs, 11).uniswapMarket;\\n        uniswapMarket12 = get(configs, 12).uniswapMarket;\\n        uniswapMarket13 = get(configs, 13).uniswapMarket;\\n        uniswapMarket14 = get(configs, 14).uniswapMarket;\\n        uniswapMarket15 = get(configs, 15).uniswapMarket;\\n        uniswapMarket16 = get(configs, 16).uniswapMarket;\\n        uniswapMarket17 = get(configs, 17).uniswapMarket;\\n        uniswapMarket18 = get(configs, 18).uniswapMarket;\\n        uniswapMarket19 = get(configs, 19).uniswapMarket;\\n        uniswapMarket20 = get(configs, 20).uniswapMarket;\\n        uniswapMarket21 = get(configs, 21).uniswapMarket;\\n        uniswapMarket22 = get(configs, 22).uniswapMarket;\\n        uniswapMarket23 = get(configs, 23).uniswapMarket;\\n        uniswapMarket24 = get(configs, 24).uniswapMarket;\\n        uniswapMarket25 = get(configs, 25).uniswapMarket;\\n        uniswapMarket26 = get(configs, 26).uniswapMarket;\\n        uniswapMarket27 = get(configs, 27).uniswapMarket;\\n        uniswapMarket28 = get(configs, 28).uniswapMarket;\\n        uniswapMarket29 = get(configs, 29).uniswapMarket;\\n\\n        isUniswapReversed00 = get(configs, 0).isUniswapReversed;\\n        isUniswapReversed01 = get(configs, 1).isUniswapReversed;\\n        isUniswapReversed02 = get(configs, 2).isUniswapReversed;\\n        isUniswapReversed03 = get(configs, 3).isUniswapReversed;\\n        isUniswapReversed04 = get(configs, 4).isUniswapReversed;\\n        isUniswapReversed05 = get(configs, 5).isUniswapReversed;\\n        isUniswapReversed06 = get(configs, 6).isUniswapReversed;\\n        isUniswapReversed07 = get(configs, 7).isUniswapReversed;\\n        isUniswapReversed08 = get(configs, 8).isUniswapReversed;\\n        isUniswapReversed09 = get(configs, 9).isUniswapReversed;\\n        isUniswapReversed10 = get(configs, 10).isUniswapReversed;\\n        isUniswapReversed11 = get(configs, 11).isUniswapReversed;\\n        isUniswapReversed12 = get(configs, 12).isUniswapReversed;\\n        isUniswapReversed13 = get(configs, 13).isUniswapReversed;\\n        isUniswapReversed14 = get(configs, 14).isUniswapReversed;\\n        isUniswapReversed15 = get(configs, 15).isUniswapReversed;\\n        isUniswapReversed16 = get(configs, 16).isUniswapReversed;\\n        isUniswapReversed17 = get(configs, 17).isUniswapReversed;\\n        isUniswapReversed18 = get(configs, 18).isUniswapReversed;\\n        isUniswapReversed19 = get(configs, 19).isUniswapReversed;\\n        isUniswapReversed20 = get(configs, 20).isUniswapReversed;\\n        isUniswapReversed21 = get(configs, 21).isUniswapReversed;\\n        isUniswapReversed22 = get(configs, 22).isUniswapReversed;\\n        isUniswapReversed23 = get(configs, 23).isUniswapReversed;\\n        isUniswapReversed24 = get(configs, 24).isUniswapReversed;\\n        isUniswapReversed25 = get(configs, 25).isUniswapReversed;\\n        isUniswapReversed26 = get(configs, 26).isUniswapReversed;\\n        isUniswapReversed27 = get(configs, 27).isUniswapReversed;\\n        isUniswapReversed28 = get(configs, 28).isUniswapReversed;\\n        isUniswapReversed29 = get(configs, 29).isUniswapReversed;\\n    }\\n\\n    function get(TokenConfig[] memory configs, uint i) internal pure returns (TokenConfig memory) {\\n        if (i < configs.length)\\n            return configs[i];\\n        return TokenConfig({\\n            cToken: address(0),\\n            underlying: address(0),\\n            symbolHash: bytes32(0),\\n            baseUnit: uint256(0),\\n            priceSource: PriceSource(0),\\n            fixedPrice: uint256(0),\\n            uniswapMarket: address(0),\\n            isUniswapReversed: false\\n        });\\n    }\\n\\n    function getCTokenIndex(address cToken) internal view returns (uint) {\\n        if (cToken == cToken00) return 0;\\n        if (cToken == cToken01) return 1;\\n        if (cToken == cToken02) return 2;\\n        if (cToken == cToken03) return 3;\\n        if (cToken == cToken04) return 4;\\n        if (cToken == cToken05) return 5;\\n        if (cToken == cToken06) return 6;\\n        if (cToken == cToken07) return 7;\\n        if (cToken == cToken08) return 8;\\n        if (cToken == cToken09) return 9;\\n        if (cToken == cToken10) return 10;\\n        if (cToken == cToken11) return 11;\\n        if (cToken == cToken12) return 12;\\n        if (cToken == cToken13) return 13;\\n        if (cToken == cToken14) return 14;\\n        if (cToken == cToken15) return 15;\\n        if (cToken == cToken16) return 16;\\n        if (cToken == cToken17) return 17;\\n        if (cToken == cToken18) return 18;\\n        if (cToken == cToken19) return 19;\\n        if (cToken == cToken20) return 20;\\n        if (cToken == cToken21) return 21;\\n        if (cToken == cToken22) return 22;\\n        if (cToken == cToken23) return 23;\\n        if (cToken == cToken24) return 24;\\n        if (cToken == cToken25) return 25;\\n        if (cToken == cToken26) return 26;\\n        if (cToken == cToken27) return 27;\\n        if (cToken == cToken28) return 28;\\n        if (cToken == cToken29) return 29;\\n\\n        return uint(-1);\\n    }\\n\\n    function getUnderlyingIndex(address underlying) internal view returns (uint) {\\n        if (underlying == underlying00) return 0;\\n        if (underlying == underlying01) return 1;\\n        if (underlying == underlying02) return 2;\\n        if (underlying == underlying03) return 3;\\n        if (underlying == underlying04) return 4;\\n        if (underlying == underlying05) return 5;\\n        if (underlying == underlying06) return 6;\\n        if (underlying == underlying07) return 7;\\n        if (underlying == underlying08) return 8;\\n        if (underlying == underlying09) return 9;\\n        if (underlying == underlying10) return 10;\\n        if (underlying == underlying11) return 11;\\n        if (underlying == underlying12) return 12;\\n        if (underlying == underlying13) return 13;\\n        if (underlying == underlying14) return 14;\\n        if (underlying == underlying15) return 15;\\n        if (underlying == underlying16) return 16;\\n        if (underlying == underlying17) return 17;\\n        if (underlying == underlying18) return 18;\\n        if (underlying == underlying19) return 19;\\n        if (underlying == underlying20) return 20;\\n        if (underlying == underlying21) return 21;\\n        if (underlying == underlying22) return 22;\\n        if (underlying == underlying23) return 23;\\n        if (underlying == underlying24) return 24;\\n        if (underlying == underlying25) return 25;\\n        if (underlying == underlying26) return 26;\\n        if (underlying == underlying27) return 27;\\n        if (underlying == underlying28) return 28;\\n        if (underlying == underlying29) return 29;\\n\\n        return uint(-1);\\n    }\\n\\n    function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {\\n        if (symbolHash == symbolHash00) return 0;\\n        if (symbolHash == symbolHash01) return 1;\\n        if (symbolHash == symbolHash02) return 2;\\n        if (symbolHash == symbolHash03) return 3;\\n        if (symbolHash == symbolHash04) return 4;\\n        if (symbolHash == symbolHash05) return 5;\\n        if (symbolHash == symbolHash06) return 6;\\n        if (symbolHash == symbolHash07) return 7;\\n        if (symbolHash == symbolHash08) return 8;\\n        if (symbolHash == symbolHash09) return 9;\\n        if (symbolHash == symbolHash10) return 10;\\n        if (symbolHash == symbolHash11) return 11;\\n        if (symbolHash == symbolHash12) return 12;\\n        if (symbolHash == symbolHash13) return 13;\\n        if (symbolHash == symbolHash14) return 14;\\n        if (symbolHash == symbolHash15) return 15;\\n        if (symbolHash == symbolHash16) return 16;\\n        if (symbolHash == symbolHash17) return 17;\\n        if (symbolHash == symbolHash18) return 18;\\n        if (symbolHash == symbolHash19) return 19;\\n        if (symbolHash == symbolHash20) return 20;\\n        if (symbolHash == symbolHash21) return 21;\\n        if (symbolHash == symbolHash22) return 22;\\n        if (symbolHash == symbolHash23) return 23;\\n        if (symbolHash == symbolHash24) return 24;\\n        if (symbolHash == symbolHash25) return 25;\\n        if (symbolHash == symbolHash26) return 26;\\n        if (symbolHash == symbolHash27) return 27;\\n        if (symbolHash == symbolHash28) return 28;\\n        if (symbolHash == symbolHash29) return 29;\\n\\n        return uint(-1);\\n    }\\n\\n    /**\\n     * @notice Get the i-th config, according to the order they were passed in originally\\n     * @param i The index of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfig(uint i) public view returns (TokenConfig memory) {\\n        require(i < numTokens, \\\"token config not found\\\");\\n\\n        if (i == 0) return TokenConfig({cToken: cToken00, underlying: underlying00, symbolHash: symbolHash00, baseUnit: baseUnit00, priceSource: priceSource00, fixedPrice: fixedPrice00, uniswapMarket: uniswapMarket00, isUniswapReversed: isUniswapReversed00});\\n        if (i == 1) return TokenConfig({cToken: cToken01, underlying: underlying01, symbolHash: symbolHash01, baseUnit: baseUnit01, priceSource: priceSource01, fixedPrice: fixedPrice01, uniswapMarket: uniswapMarket01, isUniswapReversed: isUniswapReversed01});\\n        if (i == 2) return TokenConfig({cToken: cToken02, underlying: underlying02, symbolHash: symbolHash02, baseUnit: baseUnit02, priceSource: priceSource02, fixedPrice: fixedPrice02, uniswapMarket: uniswapMarket02, isUniswapReversed: isUniswapReversed02});\\n        if (i == 3) return TokenConfig({cToken: cToken03, underlying: underlying03, symbolHash: symbolHash03, baseUnit: baseUnit03, priceSource: priceSource03, fixedPrice: fixedPrice03, uniswapMarket: uniswapMarket03, isUniswapReversed: isUniswapReversed03});\\n        if (i == 4) return TokenConfig({cToken: cToken04, underlying: underlying04, symbolHash: symbolHash04, baseUnit: baseUnit04, priceSource: priceSource04, fixedPrice: fixedPrice04, uniswapMarket: uniswapMarket04, isUniswapReversed: isUniswapReversed04});\\n        if (i == 5) return TokenConfig({cToken: cToken05, underlying: underlying05, symbolHash: symbolHash05, baseUnit: baseUnit05, priceSource: priceSource05, fixedPrice: fixedPrice05, uniswapMarket: uniswapMarket05, isUniswapReversed: isUniswapReversed05});\\n        if (i == 6) return TokenConfig({cToken: cToken06, underlying: underlying06, symbolHash: symbolHash06, baseUnit: baseUnit06, priceSource: priceSource06, fixedPrice: fixedPrice06, uniswapMarket: uniswapMarket06, isUniswapReversed: isUniswapReversed06});\\n        if (i == 7) return TokenConfig({cToken: cToken07, underlying: underlying07, symbolHash: symbolHash07, baseUnit: baseUnit07, priceSource: priceSource07, fixedPrice: fixedPrice07, uniswapMarket: uniswapMarket07, isUniswapReversed: isUniswapReversed07});\\n        if (i == 8) return TokenConfig({cToken: cToken08, underlying: underlying08, symbolHash: symbolHash08, baseUnit: baseUnit08, priceSource: priceSource08, fixedPrice: fixedPrice08, uniswapMarket: uniswapMarket08, isUniswapReversed: isUniswapReversed08});\\n        if (i == 9) return TokenConfig({cToken: cToken09, underlying: underlying09, symbolHash: symbolHash09, baseUnit: baseUnit09, priceSource: priceSource09, fixedPrice: fixedPrice09, uniswapMarket: uniswapMarket09, isUniswapReversed: isUniswapReversed09});\\n\\n        if (i == 10) return TokenConfig({cToken: cToken10, underlying: underlying10, symbolHash: symbolHash10, baseUnit: baseUnit10, priceSource: priceSource10, fixedPrice: fixedPrice10, uniswapMarket: uniswapMarket10, isUniswapReversed: isUniswapReversed10});\\n        if (i == 11) return TokenConfig({cToken: cToken11, underlying: underlying11, symbolHash: symbolHash11, baseUnit: baseUnit11, priceSource: priceSource11, fixedPrice: fixedPrice11, uniswapMarket: uniswapMarket11, isUniswapReversed: isUniswapReversed11});\\n        if (i == 12) return TokenConfig({cToken: cToken12, underlying: underlying12, symbolHash: symbolHash12, baseUnit: baseUnit12, priceSource: priceSource12, fixedPrice: fixedPrice12, uniswapMarket: uniswapMarket12, isUniswapReversed: isUniswapReversed12});\\n        if (i == 13) return TokenConfig({cToken: cToken13, underlying: underlying13, symbolHash: symbolHash13, baseUnit: baseUnit13, priceSource: priceSource13, fixedPrice: fixedPrice13, uniswapMarket: uniswapMarket13, isUniswapReversed: isUniswapReversed13});\\n        if (i == 14) return TokenConfig({cToken: cToken14, underlying: underlying14, symbolHash: symbolHash14, baseUnit: baseUnit14, priceSource: priceSource14, fixedPrice: fixedPrice14, uniswapMarket: uniswapMarket14, isUniswapReversed: isUniswapReversed14});\\n        if (i == 15) return TokenConfig({cToken: cToken15, underlying: underlying15, symbolHash: symbolHash15, baseUnit: baseUnit15, priceSource: priceSource15, fixedPrice: fixedPrice15, uniswapMarket: uniswapMarket15, isUniswapReversed: isUniswapReversed15});\\n        if (i == 16) return TokenConfig({cToken: cToken16, underlying: underlying16, symbolHash: symbolHash16, baseUnit: baseUnit16, priceSource: priceSource16, fixedPrice: fixedPrice16, uniswapMarket: uniswapMarket16, isUniswapReversed: isUniswapReversed16});\\n        if (i == 17) return TokenConfig({cToken: cToken17, underlying: underlying17, symbolHash: symbolHash17, baseUnit: baseUnit17, priceSource: priceSource17, fixedPrice: fixedPrice17, uniswapMarket: uniswapMarket17, isUniswapReversed: isUniswapReversed17});\\n        if (i == 18) return TokenConfig({cToken: cToken18, underlying: underlying18, symbolHash: symbolHash18, baseUnit: baseUnit18, priceSource: priceSource18, fixedPrice: fixedPrice18, uniswapMarket: uniswapMarket18, isUniswapReversed: isUniswapReversed18});\\n        if (i == 19) return TokenConfig({cToken: cToken19, underlying: underlying19, symbolHash: symbolHash19, baseUnit: baseUnit19, priceSource: priceSource19, fixedPrice: fixedPrice19, uniswapMarket: uniswapMarket19, isUniswapReversed: isUniswapReversed19});\\n\\n        if (i == 20) return TokenConfig({cToken: cToken20, underlying: underlying20, symbolHash: symbolHash20, baseUnit: baseUnit20, priceSource: priceSource20, fixedPrice: fixedPrice20, uniswapMarket: uniswapMarket20, isUniswapReversed: isUniswapReversed20});\\n        if (i == 21) return TokenConfig({cToken: cToken21, underlying: underlying21, symbolHash: symbolHash21, baseUnit: baseUnit21, priceSource: priceSource21, fixedPrice: fixedPrice21, uniswapMarket: uniswapMarket21, isUniswapReversed: isUniswapReversed21});\\n        if (i == 22) return TokenConfig({cToken: cToken22, underlying: underlying22, symbolHash: symbolHash22, baseUnit: baseUnit22, priceSource: priceSource22, fixedPrice: fixedPrice22, uniswapMarket: uniswapMarket22, isUniswapReversed: isUniswapReversed22});\\n        if (i == 23) return TokenConfig({cToken: cToken23, underlying: underlying23, symbolHash: symbolHash23, baseUnit: baseUnit23, priceSource: priceSource23, fixedPrice: fixedPrice23, uniswapMarket: uniswapMarket23, isUniswapReversed: isUniswapReversed23});\\n        if (i == 24) return TokenConfig({cToken: cToken24, underlying: underlying24, symbolHash: symbolHash24, baseUnit: baseUnit24, priceSource: priceSource24, fixedPrice: fixedPrice24, uniswapMarket: uniswapMarket24, isUniswapReversed: isUniswapReversed24});\\n        if (i == 25) return TokenConfig({cToken: cToken25, underlying: underlying25, symbolHash: symbolHash25, baseUnit: baseUnit25, priceSource: priceSource25, fixedPrice: fixedPrice25, uniswapMarket: uniswapMarket25, isUniswapReversed: isUniswapReversed25});\\n        if (i == 26) return TokenConfig({cToken: cToken26, underlying: underlying26, symbolHash: symbolHash26, baseUnit: baseUnit26, priceSource: priceSource26, fixedPrice: fixedPrice26, uniswapMarket: uniswapMarket26, isUniswapReversed: isUniswapReversed26});\\n        if (i == 27) return TokenConfig({cToken: cToken27, underlying: underlying27, symbolHash: symbolHash27, baseUnit: baseUnit27, priceSource: priceSource27, fixedPrice: fixedPrice27, uniswapMarket: uniswapMarket27, isUniswapReversed: isUniswapReversed27});\\n        if (i == 28) return TokenConfig({cToken: cToken28, underlying: underlying28, symbolHash: symbolHash28, baseUnit: baseUnit28, priceSource: priceSource28, fixedPrice: fixedPrice28, uniswapMarket: uniswapMarket28, isUniswapReversed: isUniswapReversed28});\\n        if (i == 29) return TokenConfig({cToken: cToken29, underlying: underlying29, symbolHash: symbolHash29, baseUnit: baseUnit29, priceSource: priceSource29, fixedPrice: fixedPrice29, uniswapMarket: uniswapMarket29, isUniswapReversed: isUniswapReversed29});\\n    }\\n\\n    /**\\n     * @notice Get the config for symbol\\n     * @param symbol The symbol of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfigBySymbol(string memory symbol) public view returns (TokenConfig memory) {\\n        return getTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));\\n    }\\n\\n    /**\\n     * @notice Get the config for the symbolHash\\n     * @param symbolHash The keccack256 of the symbol of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {\\n        uint index = getSymbolHashIndex(symbolHash);\\n        if (index != uint(-1)) {\\n            return getTokenConfig(index);\\n        }\\n\\n        revert(\\\"token config not found\\\");\\n    }\\n\\n    /**\\n     * @notice Get the config for the cToken\\n     * @dev If a config for the cToken is not found, falls back to searching for the underlying.\\n     * @param cToken The address of the cToken of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfigByCToken(address cToken) public view returns (TokenConfig memory) {\\n        uint index = getCTokenIndex(cToken);\\n        if (index != uint(-1)) {\\n            return getTokenConfig(index);\\n        }\\n\\n        return getTokenConfigByUnderlying(CErc20(cToken).underlying());\\n    }\\n\\n    /**\\n     * @notice Get the config for an underlying asset\\n     * @param underlying The address of the underlying asset of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {\\n        uint index = getUnderlyingIndex(underlying);\\n        if (index != uint(-1)) {\\n            return getTokenConfig(index);\\n        }\\n\\n        revert(\\\"token config not found\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/rickierao/IdeaProjects/kine-oracle/contracts/UniswapLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.6.10;\\n\\nimport './IUniswapV2Pair.sol';\\n\\n// Based on code from https://github.com/Uniswap/uniswap-v2-periphery\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // returns a uq112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << 112) / denominator);\\n    }\\n\\n    // decode a uq112x112 into a uint with 18 decimals of precision\\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\\n        // we only have 256 - 224 = 32 bits to spare, so scaling up by ~60 bits is dangerous\\n        // instead, get close to:\\n        //  (x * 1e18) >> 112\\n        // without risk of overflowing, e.g.:\\n        //  (x) / 2 ** (112 - lg(1e18))\\n        return uint(self._x) / 5192296858534827;\\n    }\\n}\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2 ** 32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(\\n        address pair\\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n        }\\n    }\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(uint(keccak256(abi.encodePacked(\\n                hex'ff',\\n                factory,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\\n            ))));\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/rickierao/IdeaProjects/kine-oracle/contracts/UniswapV2Library.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport './SafeMath.sol';\\nimport './IUniswapV2Pair.sol';\\n\\nlibrary UniswapV2Library {\\n    using SafeMath for uint;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(uint(keccak256(abi.encodePacked(\\n                hex'ff',\\n                factory,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\\n            ))));\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\\n        (address token0,) = sortTokens(tokenA, tokenB);\\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        uint amountInWithFee = amountIn.mul(997);\\n        uint numerator = amountInWithFee.mul(reserveOut);\\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\\n        uint denominator = reserveOut.sub(amountOut).mul(997);\\n        amountIn = (numerator / denominator).add(1);\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\\n        amounts = new uint[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint i; i < path.length - 1; i++) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\\n        amounts = new uint[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint i = path.length - 1; i > 0; i--) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/Users/rickierao/IdeaProjects/kine-oracle/sideContracts/contracts/KineOracleHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../contracts/KineOracle.sol';\\nimport '../../contracts/SafeMath.sol';\\nimport '../../contracts/UniswapV2Library.sol';\\n\\ncontract KineOracleHelper is Ownable {\\n    using SafeMath for uint;\\n    using FixedPoint for *;\\n\\n    address public factory;\\n    bytes32 constant ethHash = keccak256(abi.encodePacked(\\\"ETH\\\"));\\n    bytes32 constant mcdHash = keccak256(abi.encodePacked(\\\"MCD\\\"));\\n\\n    constructor(address factory_) public {\\n        factory = factory_;\\n    }\\n\\n    function setNewFactory(address factory_) public onlyOwner {\\n        factory = factory_;\\n    }\\n\\n    function getPairAddress(address tokenA, address tokenB) public view returns (address){\\n        return UniswapV2Library.pairFor(factory, tokenA, tokenB);\\n    }\\n\\n    function getCurrentCumulativePrices(address pair) public view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp){\\n        return UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\\n    }\\n\\n    function currentCumulativePriceInOracleCal(address oracle, string memory symbol) public view returns (uint) {\\n        KineOracle oracleInstance = KineOracle(oracle);\\n        bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\\n        PriceConfig.KTokenConfig memory config = oracleInstance.getKTokenConfigBySymbolHash(symbolHash);\\n        (uint cumulativePrice0, uint cumulativePrice1,) = UniswapV2OracleLibrary.currentCumulativePrices(config.uniswapMarket);\\n        if (config.isUniswapReversed) {\\n            return cumulativePrice1;\\n        } else {\\n            return cumulativePrice0;\\n        }\\n    }\\n\\n    function pokeWindowValuesView(address oracle, string memory symbol) public view returns (uint, uint, uint, uint){\\n        KineOracle oracleInstance = KineOracle(oracle);\\n        bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\\n        uint cumulativePrice = currentCumulativePriceInOracleCal(oracle, symbol);\\n\\n        (uint timestamp, uint acc) = oracleInstance.newObservations(symbolHash);\\n        KineOracle.Observation memory newObservation = KineOracle.Observation(timestamp, acc);\\n\\n        (uint oldObservationTs, uint oldObservationAcc) = oracleInstance.oldObservations(symbolHash);\\n\\n        uint timeElapsed = block.timestamp - newObservation.timestamp;\\n        uint anchorPeriod = oracleInstance.anchorPeriod();\\n        if (timeElapsed >= anchorPeriod) {\\n            (oldObservationTs, oldObservationAcc) = oracleInstance.newObservations(symbolHash);\\n        }\\n        return (cumulativePrice, oldObservationAcc, oldObservationTs, timeElapsed);\\n    }\\n\\n    function fetchEthPrice(address oracle) public view returns (uint){\\n        KineOracle oracleInstance = KineOracle(oracle);\\n        bytes32 symbolHash = keccak256(abi.encodePacked('ETH'));\\n        PriceConfig.KTokenConfig memory config = oracleInstance.getKTokenConfigBySymbolHash(symbolHash);\\n        (uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp,) = pokeWindowValuesView(oracle, 'ETH');\\n\\n        // This should be impossible, but better safe than sorry\\n        require(block.timestamp > oldTimestamp, \\\"now must come after before\\\");\\n        uint timeElapsed = block.timestamp - oldTimestamp;\\n\\n        // Calculate uniswap time-weighted average price\\n        // Underflow is a property of the accumulators: https://uniswap.org/audit.html#orgc9b3190\\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed));\\n        uint rawUniswapPriceMantissa = priceAverage.decode112with18();\\n        uint unscaledPriceMantissa = SafeMath.mul(rawUniswapPriceMantissa, oracleInstance.ethBaseUnit());\\n        uint anchorPrice;\\n\\n        // Adjust rawUniswapPrice according to the units of the non-ETH asset\\n        // In the case of ETH, we would have to scale by 1e6 / USDC_UNITS, but since baseUnit2 is 1e6 (USDC), it cancels\\n        anchorPrice = SafeMath.mul(unscaledPriceMantissa, config.baseUnit) / oracleInstance.ethBaseUnit() / oracleInstance.expScale();\\n        return anchorPrice;\\n    }\\n\\n    function fetchAnchorPriceView(address oracle, string memory symbol) public view returns (uint, uint, uint, uint){\\n        KineOracle oracleInstance = KineOracle(oracle);\\n        uint rawUniswapPriceMantissa;\\n        uint timeElapsed;\\n        bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\\n        PriceConfig.KTokenConfig memory config = oracleInstance.getKTokenConfigBySymbolHash(symbolHash);\\n        {\\n            (uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp,) = pokeWindowValuesView(oracle, symbol);\\n            timeElapsed = block.timestamp - oldTimestamp;\\n            FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed));\\n            rawUniswapPriceMantissa = priceAverage.decode112with18();\\n        }\\n\\n        uint conversionFactor;\\n        if (symbolHash == ethHash) {\\n            conversionFactor = oracleInstance.ethBaseUnit();\\n        } else {\\n            conversionFactor = fetchEthPrice(oracle);\\n        }\\n        uint unscaledPriceMantissa = SafeMath.mul(rawUniswapPriceMantissa, conversionFactor);\\n\\n        uint anchorPrice;\\n        // Adjust rawUniswapPrice according to the units of the non-ETH asset\\n        // In the case of ETH, we would have to scale by 1e6 / USDC_UNITS, but since baseUnit2 is 1e6 (USDC), it cancels\\n        anchorPrice = SafeMath.mul(unscaledPriceMantissa, config.baseUnit) / oracleInstance.ethBaseUnit() / oracleInstance.expScale();\\n\\n        return (timeElapsed, rawUniswapPriceMantissa, conversionFactor, anchorPrice);\\n    }\\n\\n    // returns the timestamp, symbol and price\\n    function fetchOwnedPriceAndTs(address oracle, string memory symbol) public view returns (uint, string memory, uint){\\n        KineOracle oracleInstance = KineOracle(oracle);\\n        uint timestamp = oracleInstance.mcdLastUpdatedAt();\\n        uint price = oracleInstance.price(symbol);\\n        return (timestamp, symbol, price);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"currentCumulativePriceInOracleCal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"fetchAnchorPriceView\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"fetchEthPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"fetchOwnedPriceAndTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getCurrentCumulativePrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price0Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price1Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"blockTimestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getPairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"pokeWindowValuesView\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"}],\"name\":\"setNewFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KineOracleHelper","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}