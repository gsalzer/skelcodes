{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LiquidityMiningView.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./ILiquidityMining.sol\\\";\\nimport \\\"./IERC20Metadata.sol\\\";\\n\\ncontract LiquidityMiningView {\\n\\n    struct PoolInfo {\\n        uint256 pid;\\n        address token;\\n        uint8 decimals;\\n        uint256 totalStaked;\\n        uint256 accRewardPerShare;\\n        uint256 allocPoint;\\n        uint256 lastRewardBlock;\\n\\n    }\\n\\n    struct LiquidityMining {\\n        address rewardToken;\\n        uint8 rewardTokenDecimals;\\n        address reservoir;\\n        uint256 rewardPerBlock;\\n        uint256 startBlock;\\n        uint256 endBlock;\\n        uint256 currentBlock;\\n        uint256 currentTimestamp;\\n        PoolInfo[] pools;\\n        ILiquidityMining.UnlockInfo[] unlocks;\\n    }\\n\\n    function getLiquidityMiningInfo(address _liquidityMining)\\n    external view\\n    returns (\\n        LiquidityMining memory liquidityMiningData\\n    )\\n    {\\n        ILiquidityMining liquidityMining = ILiquidityMining(_liquidityMining);\\n\\n        ILiquidityMining.PoolInfo[] memory poolInfos = liquidityMining.getAllPools();\\n        PoolInfo[] memory pools = new PoolInfo[](poolInfos.length);\\n        uint256 i;\\n        for(i = 0; i < poolInfos.length; i++) {\\n            ILiquidityMining.PoolInfo memory pi = poolInfos[i];\\n            PoolInfo memory info = PoolInfo(\\n                i,\\n                pi.token,\\n                IERC20Metadata(pi.token).decimals(),\\n                IERC20(pi.token).balanceOf(_liquidityMining),\\n                pi.accRewardPerShare,\\n                pi.allocPoint,\\n                pi.lastRewardBlock\\n            );\\n            pools[i] = info;\\n        }\\n\\n        liquidityMiningData = LiquidityMining(\\n            liquidityMining.rewardToken(),\\n            IERC20Metadata(liquidityMining.rewardToken()).decimals(),\\n            liquidityMining.reservoir(),\\n            liquidityMining.rewardPerBlock(),\\n            liquidityMining.startBlock(),\\n            liquidityMining.endBlock(),\\n            block.number,\\n            block.timestamp,\\n            pools,\\n            liquidityMining.getAllUnlocks()\\n        );\\n    }\\n\\n    struct UserCommonRewardInfo {\\n        uint256 reward;\\n        uint256 claimedReward;\\n        uint256 unlockedReward;\\n        uint8 rewardTokenDecimals;\\n    }\\n\\n    struct UserPoolRewardInfo {\\n        uint256 pid;\\n        address poolToken;\\n        uint8   poolTokenDecimals;\\n        uint256 unlockedReward;\\n        uint256 totalReward;\\n        uint256 staked;\\n        uint256 balance;\\n    }\\n\\n    function getUserRewardInfos(address _liquidityMining, address _staker)\\n    external view\\n    returns (\\n        UserCommonRewardInfo memory userCommonRewardInfo,\\n        UserPoolRewardInfo[] memory userPoolRewardInfos\\n    )\\n    {\\n        ILiquidityMining liquidityMining = ILiquidityMining(_liquidityMining);\\n\\n        userCommonRewardInfo = UserCommonRewardInfo(\\n            liquidityMining.rewards(_staker),\\n            liquidityMining.claimedRewards(_staker),\\n            liquidityMining.calcUnlocked(liquidityMining.rewards(_staker)),\\n            IERC20Metadata(liquidityMining.rewardToken()).decimals()\\n        );\\n\\n        ILiquidityMining.PoolInfo[] memory pools = liquidityMining.getAllPools();\\n        userPoolRewardInfos = new UserPoolRewardInfo[](pools.length);\\n        uint256 i;\\n        for(i = 0; i < pools.length; i++) {\\n            uint256 pid = liquidityMining.poolPidByAddress(pools[i].token);\\n            (uint256 total, uint256 unlocked) = liquidityMining.getPendingReward(pid, _staker);\\n\\n            UserPoolRewardInfo memory info = UserPoolRewardInfo(\\n                pid,\\n                pools[i].token,\\n                IERC20Metadata(pools[i].token).decimals(),\\n                unlocked,\\n                total,\\n                liquidityMining.userPoolInfo(pid, _staker).amount,\\n                IERC20(pools[i].token).balanceOf(msg.sender)\\n            );\\n            userPoolRewardInfos[i] = info;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/ILiquidityMining.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\ninterface ILiquidityMining {\\n    struct UnlockInfo {\\n        uint256 block;\\n        uint256 quota;\\n    }\\n    function getAllUnlocks() external view returns (UnlockInfo[] memory);\\n    function unlocksTotalQuotation() external view returns(uint256);\\n\\n    struct PoolInfo {\\n        address token;\\n        uint256 accRewardPerShare;\\n        uint256 allocPoint;\\n        uint256 lastRewardBlock;\\n    }\\n    function getAllPools() external view returns (PoolInfo[] memory);\\n    function totalAllocPoint() external returns(uint256);\\n\\n    function deposit(uint256 _pid, uint256 _amount) external;\\n    function withdraw(uint256 _pid, uint256 _amount) external;\\n    function claim() external;\\n    function getPendingReward(uint256 _pid, address _user)\\n    external view\\n    returns(uint256 total, uint256 available);\\n\\n    function rewardToken() external view returns(address);\\n    function reservoir() external view returns(address);\\n    function rewardPerBlock() external view returns(uint256);\\n    function startBlock() external view returns(uint256);\\n    function endBlock() external view returns(uint256);\\n\\n    function rewards(address) external view returns(uint256);\\n    function claimedRewards(address) external view returns(uint256);\\n    function poolPidByAddress(address) external view returns(uint256);\\n    function isTokenAdded(address _token) external view returns (bool);\\n    function calcUnlocked(uint256 reward) external view returns(uint256 claimable);\\n\\n    struct UserPoolInfo {\\n        uint256 amount;\\n        uint256 accruedReward;\\n    }\\n    function userPoolInfo(uint256, address) external view returns(UserPoolInfo memory);\\n}\\n\"\r\n    },\r\n    \"contracts/IERC20Metadata.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\ninterface IERC20Metadata {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityMining\",\"type\":\"address\"}],\"name\":\"getLiquidityMiningInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"reservoir\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentTimestamp\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct LiquidityMiningView.PoolInfo[]\",\"name\":\"pools\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quota\",\"type\":\"uint256\"}],\"internalType\":\"struct ILiquidityMining.UnlockInfo[]\",\"name\":\"unlocks\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LiquidityMiningView.LiquidityMining\",\"name\":\"liquidityMiningData\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityMining\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getUserRewardInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct LiquidityMiningView.UserCommonRewardInfo\",\"name\":\"userCommonRewardInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"poolToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"poolTokenDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"unlockedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"staked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct LiquidityMiningView.UserPoolRewardInfo[]\",\"name\":\"userPoolRewardInfos\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LiquidityMiningView","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}