{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/dependencies/open-zeppelin/AccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport './Context.sol';\\nimport './Strings.sol';\\nimport './ERC165.sol';\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n  function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n  function grantRole(bytes32 role, address account) external;\\n\\n  function revokeRole(bytes32 role, address account) external;\\n\\n  function renounceRole(bytes32 role, address account) external;\\n}\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControlUpgradeable is Context, IAccessControlUpgradeable, ERC165 {\\n  struct RoleData {\\n    mapping(address => bool) members;\\n    bytes32 adminRole;\\n  }\\n\\n  mapping(bytes32 => RoleData) private _roles;\\n\\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n  /**\\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n   *\\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n   * {RoleAdminChanged} not being emitted signaling this.\\n   *\\n   * _Available since v3.1._\\n   */\\n  event RoleAdminChanged(\\n    bytes32 indexed role,\\n    bytes32 indexed previousAdminRole,\\n    bytes32 indexed newAdminRole\\n  );\\n\\n  /**\\n   * @dev Emitted when `account` is granted `role`.\\n   *\\n   * `sender` is the account that originated the contract call, an admin role\\n   * bearer except when using {_setupRole}.\\n   */\\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n  /**\\n   * @dev Emitted when `account` is revoked `role`.\\n   *\\n   * `sender` is the account that originated the contract call:\\n   *   - if using `revokeRole`, it is the admin role bearer\\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n   */\\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n  /**\\n   * @dev Modifier that checks that an account has a specific role. Reverts\\n   * with a standardized message including the required role.\\n   *\\n   * The format of the revert reason is given by the following regular expression:\\n   *\\n   *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n   *\\n   * _Available since v4.1._\\n   */\\n  modifier onlyRole(bytes32 role) {\\n    _checkRole(role, _msgSender());\\n    _;\\n  }\\n\\n  /**\\n   * @dev See {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return\\n      interfaceId == type(IAccessControlUpgradeable).interfaceId ||\\n      super.supportsInterface(interfaceId);\\n  }\\n\\n  /**\\n   * @dev Returns `true` if `account` has been granted `role`.\\n   */\\n  function hasRole(bytes32 role, address account) public view override returns (bool) {\\n    return _roles[role].members[account];\\n  }\\n\\n  /**\\n   * @dev Revert with a standard message if `account` is missing `role`.\\n   *\\n   * The format of the revert reason is given by the following regular expression:\\n   *\\n   *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n   */\\n  function _checkRole(bytes32 role, address account) internal view {\\n    if (!hasRole(role, account)) {\\n      revert(\\n        string(\\n          abi.encodePacked(\\n            'AccessControl: account ',\\n            Strings.toHexString(uint160(account), 20),\\n            ' is missing role ',\\n            Strings.toHexString(uint256(role), 32)\\n          )\\n        )\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\\n   * {revokeRole}.\\n   *\\n   * To change a role's admin, use {_setRoleAdmin}.\\n   */\\n  function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n    return _roles[role].adminRole;\\n  }\\n\\n  /**\\n   * @dev Grants `role` to `account`.\\n   *\\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\\n   * event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have ``role``'s admin role.\\n   */\\n  function grantRole(bytes32 role, address account)\\n    public\\n    virtual\\n    override\\n    onlyRole(getRoleAdmin(role))\\n  {\\n    _grantRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Revokes `role` from `account`.\\n   *\\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have ``role``'s admin role.\\n   */\\n  function revokeRole(bytes32 role, address account)\\n    public\\n    virtual\\n    override\\n    onlyRole(getRoleAdmin(role))\\n  {\\n    _revokeRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Revokes `role` from the calling account.\\n   *\\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n   * purpose is to provide a mechanism for accounts to lose their privileges\\n   * if they are compromised (such as when a trusted device is misplaced).\\n   *\\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\\n   * event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must be `account`.\\n   */\\n  function renounceRole(bytes32 role, address account) public virtual override {\\n    require(account == _msgSender(), 'AccessControl: can only renounce roles for self');\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Grants `role` to `account`.\\n   *\\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\\n   * event. Note that unlike {grantRole}, this function doesn't perform any\\n   * checks on the calling account.\\n   *\\n   * [WARNING]\\n   * ====\\n   * This function should only be called from the constructor when setting\\n   * up the initial roles for the system.\\n   *\\n   * Using this function in any other way is effectively circumventing the admin\\n   * system imposed by {AccessControl}.\\n   * ====\\n   */\\n  function _setupRole(bytes32 role, address account) internal virtual {\\n    _grantRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Sets `adminRole` as ``role``'s admin role.\\n   *\\n   * Emits a {RoleAdminChanged} event.\\n   */\\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n    emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n    _roles[role].adminRole = adminRole;\\n  }\\n\\n  function _grantRole(bytes32 role, address account) private {\\n    if (!hasRole(role, account)) {\\n      _roles[role].members[account] = true;\\n      emit RoleGranted(role, account, _msgSender());\\n    }\\n  }\\n\\n  function _revokeRole(bytes32 role, address account) private {\\n    if (hasRole(role, account)) {\\n      _roles[role].members[account] = false;\\n      emit RoleRevoked(role, account, _msgSender());\\n    }\\n  }\\n\\n  uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n  bytes16 private constant alphabet = '0123456789abcdef';\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n   */\\n  function toString(uint256 value) internal pure returns (string memory) {\\n    // Inspired by OraclizeAPI's implementation - MIT licence\\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n    if (value == 0) {\\n      return '0';\\n    }\\n    uint256 temp = value;\\n    uint256 digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n      digits -= 1;\\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n      value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n   */\\n  function toHexString(uint256 value) internal pure returns (string memory) {\\n    if (value == 0) {\\n      return '0x00';\\n    }\\n    uint256 temp = value;\\n    uint256 length = 0;\\n    while (temp != 0) {\\n      length++;\\n      temp >>= 8;\\n    }\\n    return toHexString(value, length);\\n  }\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n   */\\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n    bytes memory buffer = new bytes(2 * length + 2);\\n    buffer[0] = '0';\\n    buffer[1] = 'x';\\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\\n      buffer[i] = alphabet[value & 0xf];\\n      value >>= 4;\\n    }\\n    require(value == 0, 'Strings: hex length insufficient');\\n    return string(buffer);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport './IERC165.sol';\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n  /**\\n   * @dev See {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return interfaceId == type(IERC165).interfaceId;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/impl/MD1Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n  AccessControlUpgradeable\\n} from '../../../dependencies/open-zeppelin/AccessControlUpgradeable.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { IRewardsOracle } from '../../../interfaces/IRewardsOracle.sol';\\nimport { ReentrancyGuard } from '../../../utils/ReentrancyGuard.sol';\\nimport { VersionedInitializable } from '../../../utils/VersionedInitializable.sol';\\nimport { MD1Types } from '../lib/MD1Types.sol';\\n\\n/**\\n * @title MD1Storage\\n * @author dYdX\\n *\\n * @dev Storage contract. Contains or inherits from all contract with storage.\\n */\\nabstract contract MD1Storage is\\n  AccessControlUpgradeable,\\n  ReentrancyGuard,\\n  VersionedInitializable\\n{\\n  // ============ Configuration ============\\n\\n  /// @dev The oracle which provides Merkle root updates.\\n  IRewardsOracle internal _REWARDS_ORACLE_;\\n\\n  /// @dev The IPNS name to which trader and market maker exchange statistics are published.\\n  string internal _IPNS_NAME_;\\n\\n  /// @dev Period of time after the epoch end after which the new epoch exchange statistics should\\n  ///  be available on IPFS via the IPNS name. This can be used as a trigger for “keepers” who are\\n  ///  incentivized to call the proposeRoot() and updateRoot() functions as needed.\\n  uint256 internal _IPFS_UPDATE_PERIOD_;\\n\\n  /// @dev Max rewards distributed per epoch as market maker incentives.\\n  uint256 internal _MARKET_MAKER_REWARDS_AMOUNT_;\\n\\n  /// @dev Max rewards distributed per epoch as trader incentives.\\n  uint256 internal _TRADER_REWARDS_AMOUNT_;\\n\\n  /// @dev Parameter affecting the calculation of trader rewards. This is a value\\n  ///  between 0 and 1, represented here in units out of 10^18.\\n  uint256 internal _TRADER_SCORE_ALPHA_;\\n\\n  // ============ Epoch Schedule ============\\n\\n  /// @dev The parameters specifying the function from timestamp to epoch number.\\n  MD1Types.EpochParameters internal _EPOCH_PARAMETERS_;\\n\\n  // ============ Root Updates ============\\n\\n  /// @dev The active Merkle root and associated parameters.\\n  MD1Types.MerkleRoot internal _ACTIVE_ROOT_;\\n\\n  /// @dev The proposed Merkle root and associated parameters.\\n  MD1Types.MerkleRoot internal _PROPOSED_ROOT_;\\n\\n  /// @dev The time at which the proposed root may become active.\\n  uint256 internal _WAITING_PERIOD_END_;\\n\\n  /// @dev Whether root updates are currently paused.\\n  bool internal _ARE_ROOT_UPDATES_PAUSED_;\\n\\n  // ============ Claims ============\\n\\n  /// @dev Mapping of (user address) => (number of tokens claimed).\\n  mapping(address => uint256) internal _CLAIMED_;\\n\\n  /// @dev Whether the user has opted into allowing anyone to trigger a claim on their behalf.\\n  mapping(address => bool) internal _ALWAYS_ALLOW_CLAIMS_FOR_;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n* @dev Interface of the ERC20 standard as defined in the EIP.\\n*/\\ninterface IERC20 {\\n  /**\\n    * @dev Returns the amount of tokens in existence.\\n    */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n    * @dev Returns the amount of tokens owned by `account`.\\n    */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n    *\\n    * Returns a boolean value indicating whether the operation succeeded.\\n    *\\n    * Emits a {Transfer} event.\\n    */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n    * @dev Returns the remaining number of tokens that `spender` will be\\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n    * zero by default.\\n    *\\n    * This value changes when {approve} or {transferFrom} are called.\\n    */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n    * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    *\\n    * Returns a boolean value indicating whether the operation succeeded.\\n    *\\n    * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n    * that someone may use both the old and the new allowance by unfortunate\\n    * transaction ordering. One possible solution to mitigate this race\\n    * condition is to first reduce the spender's allowance to 0 and set the\\n    * desired value afterwards:\\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    *\\n    * Emits an {Approval} event.\\n    */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n    * allowance mechanism. `amount` is then deducted from the caller's\\n    * allowance.\\n    *\\n    * Returns a boolean value indicating whether the operation succeeded.\\n    *\\n    * Emits a {Transfer} event.\\n    */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n    * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n    * another (`to`).\\n    *\\n    * Note that `value` may be zero.\\n    */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n    * a call to {approve}. `value` is the new allowance.\\n    */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRewardsOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\ninterface IRewardsOracle {\\n\\n  /**\\n   * @notice Returns the oracle value, agreed upon by all oracle signers. If the signers have not\\n   *  agreed upon a value, should return zero for all return values.\\n   *\\n   * @return  merkleRoot  The Merkle root for the next Merkle distributor update.\\n   * @return  epoch       The epoch number corresponding to the new Merkle root.\\n   * @return  ipfsCid     An IPFS CID pointing to the Merkle tree data.\\n   */\\n  function read()\\n    external\\n    virtual\\n    view\\n    returns (bytes32 merkleRoot, uint256 epoch, bytes memory ipfsCid);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\n/**\\n * @title ReentrancyGuard\\n * @author dYdX\\n *\\n * @dev Updated ReentrancyGuard library designed to be used with Proxy Contracts.\\n */\\nabstract contract ReentrancyGuard {\\n  uint256 private constant NOT_ENTERED = 1;\\n  uint256 private constant ENTERED = uint256(int256(-1));\\n\\n  uint256 private _STATUS_;\\n\\n  constructor()\\n    internal\\n  {\\n    _STATUS_ = NOT_ENTERED;\\n  }\\n\\n  modifier nonReentrant() {\\n    require(_STATUS_ != ENTERED, 'ReentrancyGuard: reentrant call');\\n    _STATUS_ = ENTERED;\\n    _;\\n    _STATUS_ = NOT_ENTERED;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/VersionedInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\n\\n/**\\n * @title VersionedInitializable\\n * @author Aave, inspired by the OpenZeppelin Initializable contract\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n *\\n */\\nabstract contract VersionedInitializable {\\n    /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n    uint256 internal lastInitializedRevision = 0;\\n\\n   /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n    modifier initializer() {\\n        uint256 revision = getRevision();\\n        require(revision > lastInitializedRevision, \\\"Contract instance has already been initialized\\\");\\n\\n        lastInitializedRevision = revision;\\n\\n        _;\\n\\n    }\\n\\n    /// @dev returns the revision number of the contract.\\n    /// Needs to be defined in the inherited class as a constant.\\n    function getRevision() internal pure virtual returns(uint256);\\n\\n\\n    // Reserved storage space to allow for layout changes in the future.\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/lib/MD1Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nlibrary MD1Types {\\n\\n  /**\\n   * @dev The parameters used to convert a timestamp to an epoch number.\\n   */\\n  struct EpochParameters {\\n    uint128 interval;\\n    uint128 offset;\\n  }\\n\\n  /**\\n   * @dev The parameters related to a certain version of the Merkle root.\\n   */\\n  struct MerkleRoot {\\n    bytes32 merkleRoot;\\n    uint256 epoch;\\n    bytes ipfsCid;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/impl/MD1Getters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { IRewardsOracle } from '../../../interfaces/IRewardsOracle.sol';\\nimport { MD1Types } from '../lib/MD1Types.sol';\\nimport { MD1Storage } from './MD1Storage.sol';\\n\\n/**\\n * @title MD1Getters\\n * @author dYdX\\n *\\n * @notice Simple getter functions.\\n */\\nabstract contract MD1Getters is\\n  MD1Storage\\n{\\n  /**\\n   * @notice Get the address of the oracle which provides Merkle root updates.\\n   *\\n   * @return The address of the oracle.\\n   */\\n  function getRewardsOracle()\\n    external\\n    view\\n    returns (IRewardsOracle)\\n  {\\n    return _REWARDS_ORACLE_;\\n  }\\n\\n  /**\\n   * @notice Get the IPNS name to which trader and market maker exchange statistics are published.\\n   *\\n   * @return The IPNS name.\\n   */\\n  function getIpnsName()\\n    external\\n    view\\n    returns (string memory)\\n  {\\n    return _IPNS_NAME_;\\n  }\\n\\n  /**\\n   * @notice Get the period of time after the epoch end after which the new epoch exchange\\n   *  statistics should be available on IPFS via the IPNS name.\\n   *\\n   * @return The IPFS update period, in seconds.\\n   */\\n  function getIpfsUpdatePeriod()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _IPFS_UPDATE_PERIOD_;\\n  }\\n\\n  /**\\n   * @notice Get the rewards formula parameters.\\n   *\\n   * @return Max rewards distributed per epoch as market maker incentives.\\n   * @return Max rewards distributed per epoch as trader incentives.\\n   * @return The alpha parameter between 0 and 1, in units out of 10^18.\\n   */\\n  function getRewardsParameters()\\n    external\\n    view\\n    returns (uint256, uint256, uint256)\\n  {\\n    return (\\n      _MARKET_MAKER_REWARDS_AMOUNT_,\\n      _TRADER_REWARDS_AMOUNT_,\\n      _TRADER_SCORE_ALPHA_\\n    );\\n  }\\n\\n  /**\\n   * @notice Get the parameters specifying the function from timestamp to epoch number.\\n   *\\n   * @return The parameters struct with `interval` and `offset` fields.\\n   */\\n  function getEpochParameters()\\n    external\\n    view\\n    returns (MD1Types.EpochParameters memory)\\n  {\\n    return _EPOCH_PARAMETERS_;\\n  }\\n\\n  /**\\n   * @notice Get the active Merkle root and associated parameters.\\n   *\\n   * @return  merkleRoot  The active Merkle root.\\n   * @return  epoch       The epoch number corresponding to this Merkle tree.\\n   * @return  ipfsCid     An IPFS CID pointing to the Merkle tree data.\\n   */\\n  function getActiveRoot()\\n    external\\n    view\\n    returns (bytes32 merkleRoot, uint256 epoch, bytes memory ipfsCid)\\n  {\\n    merkleRoot = _ACTIVE_ROOT_.merkleRoot;\\n    epoch = _ACTIVE_ROOT_.epoch;\\n    ipfsCid = _ACTIVE_ROOT_.ipfsCid;\\n  }\\n\\n  /**\\n   * @notice Get the proposed Merkle root and associated parameters.\\n   *\\n   * @return  merkleRoot  The active Merkle root.\\n   * @return  epoch       The epoch number corresponding to this Merkle tree.\\n   * @return  ipfsCid     An IPFS CID pointing to the Merkle tree data.\\n   */\\n  function getProposedRoot()\\n    external\\n    view\\n    returns (bytes32 merkleRoot, uint256 epoch, bytes memory ipfsCid)\\n  {\\n    merkleRoot = _PROPOSED_ROOT_.merkleRoot;\\n    epoch = _PROPOSED_ROOT_.epoch;\\n    ipfsCid = _PROPOSED_ROOT_.ipfsCid;\\n  }\\n\\n  /**\\n   * @notice Get the time at which the proposed root may become active.\\n   *\\n   * @return The time at which the proposed root may become active, in epoch seconds.\\n   */\\n  function getWaitingPeriodEnd()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _WAITING_PERIOD_END_;\\n  }\\n\\n  /**\\n   * @notice Check whether root updates are currently paused.\\n   *\\n   * @return Boolean `true` if root updates are currently paused, otherwise, `false`.\\n   */\\n  function getAreRootUpdatesPaused()\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return _ARE_ROOT_UPDATES_PAUSED_;\\n  }\\n\\n  /**\\n   * @notice Get the tokens claimed so far by a given user.\\n   *\\n   * @param  user  The address of the user.\\n   *\\n   * @return The tokens claimed so far by that user.\\n   */\\n  function getClaimed(address user)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _CLAIMED_[user];\\n  }\\n\\n  /**\\n   * @notice Check whether the user opted into allowing anyone to trigger a claim on their behalf.\\n   *\\n   * @param  user  The address of the user.\\n   *\\n   * @return Boolean `true` if any address may trigger claims for the user, otherwise `false`.\\n   */\\n  function getAlwaysAllowClaimsFor(address user)\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return _ALWAYS_ALLOW_CLAIMS_FOR_[user];\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/MerkleDistributorV1.sol\": {\r\n      \"content\": \"// Contracts by dYdX Foundation. Individual files are released under different licenses.\\n//\\n// https://dydx.community\\n// https://github.com/dydxfoundation/governance-contracts\\n//\\n// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { SafeMath } from '../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { Ownable } from '../../dependencies/open-zeppelin/Ownable.sol';\\nimport { MerkleProof } from '../../dependencies/open-zeppelin/MerkleProof.sol';\\nimport { IERC20 } from '../../interfaces/IERC20.sol';\\nimport { IRewardsOracle } from '../../interfaces/IRewardsOracle.sol';\\nimport { MD1Claims } from './impl/MD1Claims.sol';\\nimport { MD1RootUpdates } from './impl/MD1RootUpdates.sol';\\nimport { MD1Configuration } from './impl/MD1Configuration.sol';\\nimport { MD1Getters } from './impl/MD1Getters.sol';\\n\\n/**\\n * @title MerkleDistributorV1\\n * @author dYdX\\n *\\n * @notice Distributes DYDX token rewards according to a Merkle tree of balances. The tree can be\\n *  updated periodially with each user's cumulative rewards balance, allowing new rewards to be\\n *  distributed to users over time.\\n *\\n *  An update is performed by setting the proposed Merkle root to the latest value returned by\\n *  the oracle contract. The proposed Merkle root can be made active after a waiting period has\\n *  elapsed. During the waiting period, dYdX governance has the opportunity to freeze the Merkle\\n *  root, in case the proposed root is incorrect or malicious.\\n */\\ncontract MerkleDistributorV1 is\\n  MD1RootUpdates,\\n  MD1Claims,\\n  MD1Configuration,\\n  MD1Getters\\n{\\n  // ============ Constructor ============\\n\\n  constructor(\\n    address rewardsToken,\\n    address rewardsTreasury\\n  )\\n    MD1Claims(rewardsToken, rewardsTreasury)\\n    {}\\n\\n  // ============ External Functions ============\\n\\n  function initialize(\\n    address rewardsOracle,\\n    string calldata ipnsName,\\n    uint256 ipfsUpdatePeriod,\\n    uint256 marketMakerRewardsAmount,\\n    uint256 traderRewardsAmount,\\n    uint256 traderScoreAlpha,\\n    uint256 epochInterval,\\n    uint256 epochOffset\\n  )\\n    external\\n    initializer\\n  {\\n    __MD1Roles_init();\\n    __MD1Configuration_init(\\n      rewardsOracle,\\n      ipnsName,\\n      ipfsUpdatePeriod,\\n      marketMakerRewardsAmount,\\n      traderRewardsAmount,\\n      traderScoreAlpha\\n    );\\n    __MD1EpochSchedule_init(epochInterval, epochOffset);\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  /**\\n   * @dev Returns the revision of the implementation contract. Used by VersionedInitializable.\\n   *\\n   * @return The revision number.\\n   */\\n  function getRevision()\\n    internal\\n    pure\\n    override\\n    returns (uint256)\\n  {\\n    return 1;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts with custom message when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport './Context.sol';\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    address msgSender = _msgSender();\\n    _owner = msgSender;\\n    emit OwnershipTransferred(address(0), msgSender);\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\\n    _;\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    emit OwnershipTransferred(_owner, address(0));\\n    _owner = address(0);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/impl/MD1Claims.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { SafeERC20 } from '../../../dependencies/open-zeppelin/SafeERC20.sol';\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { MerkleProof } from '../../../dependencies/open-zeppelin/MerkleProof.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { MD1Types } from '../lib/MD1Types.sol';\\nimport { MD1Roles } from './MD1Roles.sol';\\n\\n/**\\n * @title MD1Claims\\n * @author dYdX\\n *\\n * @notice Allows rewards to be claimed by providing a Merkle proof of the rewards amount.\\n */\\nabstract contract MD1Claims is\\n  MD1Roles\\n{\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint256;\\n\\n  // ============ Constants ============\\n\\n  /// @notice The token distributed as rewards.\\n  IERC20 public immutable REWARDS_TOKEN;\\n\\n  /// @notice Address to pull rewards from. Must have provided an allowance to this contract.\\n  address public immutable REWARDS_TREASURY;\\n\\n  // ============ Events ============\\n\\n  /// @notice Emitted when a user claims rewards.\\n  event RewardsClaimed(\\n    address account,\\n    uint256 amount\\n  );\\n\\n  /// @notice Emitted when a user opts into or out of the claim-for allowlist.\\n  event AlwaysAllowClaimForUpdated(\\n    address user,\\n    bool allow\\n  );\\n\\n  // ============ Constructor ============\\n\\n  constructor(\\n    address rewardsToken,\\n    address rewardsTreasury\\n  ) {\\n    REWARDS_TOKEN = IERC20(rewardsToken);\\n    REWARDS_TREASURY = rewardsTreasury;\\n  }\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Claim the remaining unclaimed rewards for the sender.\\n   *\\n   *  Reverts if the provided Merkle proof is invalid.\\n   *\\n   * @param  cumulativeAmount  The total all-time rewards this user has earned.\\n   * @param  merkleProof       The Merkle proof for the user and cumulative amount.\\n   *\\n   * @return The number of rewards tokens claimed.\\n   */\\n  function claimRewards(\\n    uint256 cumulativeAmount,\\n    bytes32[] calldata merkleProof\\n  )\\n    external\\n    nonReentrant\\n    returns (uint256)\\n  {\\n    return _claimRewards(msg.sender, cumulativeAmount, merkleProof);\\n  }\\n\\n  /**\\n   * @notice Claim the remaining unclaimed rewards for a user, and send them to that user.\\n   *\\n   *  The caller must be authorized with CLAIM_OPERATOR_ROLE unless the specified user has opted\\n   *  into the claim-for allowlist. In any case, rewards are transfered to the original user\\n   *  specified in the Merkle tree.\\n   *\\n   *  Reverts if the provided Merkle proof is invalid.\\n   *\\n   * @param  user              Address of the user on whose behalf to trigger a claim.\\n   * @param  cumulativeAmount  The total all-time rewards this user has earned.\\n   * @param  merkleProof       The Merkle proof for the user and cumulative amount.\\n   *\\n   * @return The number of rewards tokens claimed.\\n   */\\n  function claimRewardsFor(\\n    address user,\\n    uint256 cumulativeAmount,\\n    bytes32[] calldata merkleProof\\n  )\\n    external\\n    nonReentrant\\n    returns (uint256)\\n  {\\n    require(\\n      (\\n        hasRole(CLAIM_OPERATOR_ROLE, msg.sender) ||\\n        _ALWAYS_ALLOW_CLAIMS_FOR_[user]\\n      ),\\n      'MD1Claims: Do not have permission to claim for this user'\\n    );\\n    return _claimRewards(user, cumulativeAmount, merkleProof);\\n  }\\n\\n  /**\\n   * @notice Opt into allowing anyone to claim on the sender's behalf.\\n   *\\n   *  Note that this does not affect who receives the funds. The user specified in the Merkle tree\\n   *  receives those rewards regardless of who issues the claim.\\n   *\\n   *  Note that addresses with the CLAIM_OPERATOR_ROLE ignore this allowlist when triggering claims.\\n   *\\n   * @param  allow  Whether or not to allow claims on the sender's behalf.\\n   */\\n  function setAlwaysAllowClaimsFor(\\n    bool allow\\n  )\\n    external\\n    nonReentrant\\n  {\\n    _ALWAYS_ALLOW_CLAIMS_FOR_[msg.sender] = allow;\\n    emit AlwaysAllowClaimForUpdated(msg.sender, allow);\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  /**\\n   * @notice Claim the remaining unclaimed rewards for a user, and send them to that user.\\n   *\\n   *  Reverts if the provided Merkle proof is invalid.\\n   *\\n   * @param  user              Address of the user.\\n   * @param  cumulativeAmount  The total all-time rewards this user has earned.\\n   * @param  merkleProof       The Merkle proof for the user and cumulative amount.\\n   *\\n   * @return The number of rewards tokens claimed.\\n   */\\n  function _claimRewards(\\n    address user,\\n    uint256 cumulativeAmount,\\n    bytes32[] calldata merkleProof\\n  )\\n    internal\\n    returns (uint256)\\n  {\\n    // Get the active Merkle root.\\n    bytes32 merkleRoot = _ACTIVE_ROOT_.merkleRoot;\\n\\n    // Verify the Merkle proof.\\n    bytes32 node = keccak256(abi.encodePacked(user, cumulativeAmount));\\n    require(MerkleProof.verify(merkleProof, merkleRoot, node), 'MD1Claims: Invalid Merkle proof');\\n\\n    // Get the claimable amount.\\n    //\\n    // Note: If this reverts, then there was an error in the Merkle tree, since the cumulative\\n    // amount for a given user should never decrease over time.\\n    uint256 claimable = cumulativeAmount.sub(_CLAIMED_[user]);\\n\\n    if (claimable == 0) {\\n      return 0;\\n    }\\n\\n    // Mark the user as having claimed the full amount.\\n    _CLAIMED_[user] = cumulativeAmount;\\n\\n    // Send the user the claimable amount.\\n    REWARDS_TOKEN.safeTransferFrom(REWARDS_TREASURY, user, claimable);\\n\\n    emit RewardsClaimed(user, claimable);\\n\\n    return claimable;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/impl/MD1RootUpdates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { MerkleProof } from '../../../dependencies/open-zeppelin/MerkleProof.sol';\\nimport { MD1Types } from '../lib/MD1Types.sol';\\nimport { MD1Pausable } from './MD1Pausable.sol';\\n\\n/**\\n * @title MD1RootUpdates\\n * @author dYdX\\n *\\n * @notice Handles updates to the Merkle root.\\n */\\nabstract contract MD1RootUpdates is\\n  MD1Pausable\\n{\\n  using SafeMath for uint256;\\n\\n  // ============ Constants ============\\n\\n  /// @notice The waiting period before a proposed Merkle root can become active, in seconds.\\n  uint256 public constant WAITING_PERIOD = 7 days;\\n\\n  // ============ Events ============\\n\\n  /// @notice Emitted when a new Merkle root is proposed and the waiting period begins.\\n  event RootProposed(\\n    bytes32 merkleRoot,\\n    uint256 epoch,\\n    bytes ipfsCid,\\n    uint256 waitingPeriodEnd\\n  );\\n\\n  /// @notice Emitted when a new Merkle root becomes active.\\n  event RootUpdated(\\n    bytes32 merkleRoot,\\n    uint256 epoch,\\n    bytes ipfsCid\\n  );\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Set the proposed root parameters to the values returned by the oracle, and start the\\n   *  waiting period. Anyone may call this function.\\n   *\\n   *  Reverts if the oracle root is bytes32(0).\\n   *  Reverts if the oracle root parameters are equal to the proposed root parameters.\\n   *  Reverts if the oracle root epoch is not equal to the next root epoch.\\n   */\\n  function proposeRoot()\\n    external\\n    nonReentrant\\n  {\\n    // Read the latest values from the oracle.\\n    (\\n      bytes32 merkleRoot,\\n      uint256 epoch,\\n      bytes memory ipfsCid\\n    ) = _REWARDS_ORACLE_.read();\\n\\n    require(merkleRoot != bytes32(0), 'MD1RootUpdates: Oracle root is zero (unset)');\\n    require(\\n      (\\n        merkleRoot != _PROPOSED_ROOT_.merkleRoot ||\\n        epoch != _PROPOSED_ROOT_.epoch ||\\n        keccak256(ipfsCid) != keccak256(_PROPOSED_ROOT_.ipfsCid)\\n      ),\\n      'MD1RootUpdates: Oracle root was already proposed'\\n    );\\n    require(epoch == getNextRootEpoch(), 'MD1RootUpdates: Oracle epoch is not next root epoch');\\n\\n    // Set the proposed root and the waiting period for the proposed root to become active.\\n    _PROPOSED_ROOT_ = MD1Types.MerkleRoot({\\n      merkleRoot: merkleRoot,\\n      epoch: epoch,\\n      ipfsCid: ipfsCid\\n    });\\n    uint256 waitingPeriodEnd = block.timestamp.add(WAITING_PERIOD);\\n    _WAITING_PERIOD_END_ = waitingPeriodEnd;\\n\\n    emit RootProposed(merkleRoot, epoch, ipfsCid, waitingPeriodEnd);\\n  }\\n\\n  /**\\n   * @notice Set the active root parameters to the proposed root parameters.\\n   *\\n   *  Reverts if root updates are paused.\\n   *  Reverts if the proposed root is bytes32(0).\\n   *  Reverts if the proposed root epoch is not equal to the next root epoch.\\n   *  Reverts if the waiting period for the proposed root has not elapsed.\\n   */\\n  function updateRoot()\\n    external\\n    nonReentrant\\n    whenNotPaused\\n  {\\n    // Get the proposed root parameters.\\n    bytes32 merkleRoot = _PROPOSED_ROOT_.merkleRoot;\\n    uint256 epoch = _PROPOSED_ROOT_.epoch;\\n    bytes memory ipfsCid = _PROPOSED_ROOT_.ipfsCid;\\n\\n    require(merkleRoot != bytes32(0), 'MD1RootUpdates: Proposed root is zero (unset)');\\n    require(epoch == getNextRootEpoch(), 'MD1RootUpdates: Proposed epoch is not next root epoch');\\n    require(\\n      block.timestamp >= _WAITING_PERIOD_END_,\\n      'MD1RootUpdates: Waiting period has not elapsed'\\n    );\\n\\n    // Set the active root.\\n    _ACTIVE_ROOT_.merkleRoot = merkleRoot;\\n    _ACTIVE_ROOT_.epoch = epoch;\\n    _ACTIVE_ROOT_.ipfsCid = ipfsCid;\\n\\n    emit RootUpdated(merkleRoot, epoch, ipfsCid);\\n  }\\n\\n  /**\\n   * @notice Returns true if there is a proposed root waiting to become active, the waiting period\\n   *  for that root has elapsed, and root updates are not paused.\\n   *\\n   * @return Boolean `true` if the active root can be updated to the proposed root, else `false`.\\n   */\\n  function canUpdateRoot()\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return (\\n      hasPendingRoot() &&\\n      block.timestamp >= _WAITING_PERIOD_END_ &&\\n      !_ARE_ROOT_UPDATES_PAUSED_\\n    );\\n  }\\n\\n  // ============ Public Functions ============\\n\\n  /**\\n   * @notice Returns true if there is a proposed root waiting to become active. This is the case if\\n   *  and only if the proposed root is not zero and the proposed root epoch is equal to the next\\n   *  root epoch.\\n   */\\n  function hasPendingRoot()\\n    public\\n    view\\n    returns (bool)\\n  {\\n    // Get the proposed parameters.\\n    bytes32 merkleRoot = _PROPOSED_ROOT_.merkleRoot;\\n    uint256 epoch = _PROPOSED_ROOT_.epoch;\\n\\n    if (merkleRoot == bytes32(0)) {\\n      return false;\\n    }\\n    return epoch == getNextRootEpoch();\\n  }\\n\\n  /**\\n   * @notice Get the next root epoch. If the active root is zero, then the next root epoch is zero,\\n   *  otherwise, it is equal to the active root epoch plus one.\\n   */\\n  function getNextRootEpoch()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    bytes32 merkleRoot = _ACTIVE_ROOT_.merkleRoot;\\n\\n    if (merkleRoot == bytes32(0)) {\\n      return 0;\\n    }\\n\\n    return _ACTIVE_ROOT_.epoch.add(1);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/impl/MD1Configuration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { IRewardsOracle } from '../../../interfaces/IRewardsOracle.sol';\\nimport { MD1EpochSchedule } from './MD1EpochSchedule.sol';\\nimport { MD1Roles } from './MD1Roles.sol';\\nimport { MD1Types } from '../lib/MD1Types.sol';\\n\\n/**\\n * @title MD1Configuration\\n * @author dYdX\\n *\\n * @notice Functions for modifying the Merkle distributor rewards configuration.\\n *\\n *  The more sensitive configuration values, which potentially give full control over the contents\\n *  of the Merkle tree, may only be updated by the OWNER_ROLE. Other values may be configured by\\n *  the CONFIG_UPDATER_ROLE.\\n *\\n *  Note that these configuration values are made available externally but are not used internally\\n *  within this contract, with the exception of the IPFS update period which is used by\\n *  the getIpfsEpoch() function.\\n */\\nabstract contract MD1Configuration is\\n  MD1EpochSchedule,\\n  MD1Roles\\n{\\n  // ============ Constants ============\\n\\n  uint256 public constant TRADER_SCORE_ALPHA_BASE = 10 ** 18;\\n\\n  // ============ Events ============\\n\\n  event RewardsOracleChanged(\\n    address rewardsOracle\\n  );\\n\\n  event IpnsNameUpdated(\\n    string ipnsName\\n  );\\n\\n  event IpfsUpdatePeriodUpdated(\\n    uint256 ipfsUpdatePeriod\\n  );\\n\\n  event RewardsParametersUpdated(\\n    uint256 marketMakerRewardsAmount,\\n    uint256 traderRewardsAmount,\\n    uint256 traderScoreAlpha\\n  );\\n\\n  // ============ Initializer ============\\n\\n  function __MD1Configuration_init(\\n    address rewardsOracle,\\n    string calldata ipnsName,\\n    uint256 ipfsUpdatePeriod,\\n    uint256 marketMakerRewardsAmount,\\n    uint256 traderRewardsAmount,\\n    uint256 traderScoreAlpha\\n  )\\n    internal\\n  {\\n    _setRewardsOracle(rewardsOracle);\\n    _setIpnsName(ipnsName);\\n    _setIpfsUpdatePeriod(ipfsUpdatePeriod);\\n    _setRewardsParameters(\\n      marketMakerRewardsAmount,\\n      traderRewardsAmount,\\n      traderScoreAlpha\\n    );\\n  }\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Set the address of the oracle which provides Merkle root updates.\\n   *\\n   * @param  rewardsOracle  The new oracle address.\\n   */\\n  function setRewardsOracle(\\n    address rewardsOracle\\n  )\\n    external\\n    onlyRole(OWNER_ROLE)\\n    nonReentrant\\n  {\\n    _setRewardsOracle(rewardsOracle);\\n  }\\n\\n  /**\\n   * @notice Set the IPNS name to which trader and market maker exchange statistics are published.\\n   *\\n   * @param  ipnsName  The new IPNS name.\\n   */\\n  function setIpnsName(\\n    string calldata ipnsName\\n  )\\n    external\\n    onlyRole(OWNER_ROLE)\\n    nonReentrant\\n  {\\n    _setIpnsName(ipnsName);\\n  }\\n\\n  /**\\n   * @notice Set the period of time after the epoch end after which the new epoch exchange\\n   *  statistics should be available on IPFS via the IPNS name.\\n   *\\n   *  This can be used as a trigger for “keepers” who are incentivized to call the proposeRoot()\\n   *  and updateRoot() functions as needed.\\n   *\\n   * @param  ipfsUpdatePeriod  The new IPFS update period, in seconds.\\n   */\\n  function setIpfsUpdatePeriod(\\n    uint256 ipfsUpdatePeriod\\n  )\\n    external\\n    onlyRole(CONFIG_UPDATER_ROLE)\\n    nonReentrant\\n  {\\n    _setIpfsUpdatePeriod(ipfsUpdatePeriod);\\n  }\\n\\n  /**\\n   * @notice Set the rewards formula parameters.\\n   *\\n   * @param  marketMakerRewardsAmount  Max rewards distributed per epoch as market maker incentives.\\n   * @param  traderRewardsAmount       Max rewards distributed per epoch as trader incentives.\\n   * @param  traderScoreAlpha          The alpha parameter between 0 and 1, in units out of 10^18.\\n   */\\n  function setRewardsParameters(\\n    uint256 marketMakerRewardsAmount,\\n    uint256 traderRewardsAmount,\\n    uint256 traderScoreAlpha\\n  )\\n    external\\n    onlyRole(CONFIG_UPDATER_ROLE)\\n    nonReentrant\\n  {\\n    _setRewardsParameters(marketMakerRewardsAmount, traderRewardsAmount, traderScoreAlpha);\\n  }\\n\\n  /**\\n   * @notice Set the parameters defining the function from timestamp to epoch number.\\n   *\\n   * @param  interval  The length of an epoch, in seconds.\\n   * @param  offset    The start of epoch zero, in seconds.\\n   */\\n  function setEpochParameters(\\n    uint256 interval,\\n    uint256 offset\\n  )\\n    external\\n    onlyRole(CONFIG_UPDATER_ROLE)\\n    nonReentrant\\n  {\\n    _setEpochParameters(interval, offset);\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  function _setRewardsOracle(\\n    address rewardsOracle\\n  )\\n    internal\\n  {\\n    _REWARDS_ORACLE_ = IRewardsOracle(rewardsOracle);\\n    emit RewardsOracleChanged(rewardsOracle);\\n  }\\n\\n  function _setIpnsName(\\n    string calldata ipnsName\\n  )\\n    internal\\n  {\\n    _IPNS_NAME_ = ipnsName;\\n    emit IpnsNameUpdated(ipnsName);\\n  }\\n\\n  function _setIpfsUpdatePeriod(\\n    uint256 ipfsUpdatePeriod\\n  )\\n    internal\\n  {\\n    _IPFS_UPDATE_PERIOD_ = ipfsUpdatePeriod;\\n    emit IpfsUpdatePeriodUpdated(ipfsUpdatePeriod);\\n  }\\n\\n  function _setRewardsParameters(\\n    uint256 marketMakerRewardsAmount,\\n    uint256 traderRewardsAmount,\\n    uint256 traderScoreAlpha\\n  )\\n    internal\\n  {\\n    require(\\n      traderScoreAlpha <= TRADER_SCORE_ALPHA_BASE,\\n      'MD1Configuration: Invalid traderScoreAlpha'\\n    );\\n\\n    _MARKET_MAKER_REWARDS_AMOUNT_ = marketMakerRewardsAmount;\\n    _TRADER_REWARDS_AMOUNT_ = traderRewardsAmount;\\n    _TRADER_SCORE_ALPHA_ = traderScoreAlpha;\\n\\n    emit RewardsParametersUpdated(\\n      marketMakerRewardsAmount,\\n      traderRewardsAmount,\\n      traderScoreAlpha\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport { IERC20 } from '../../interfaces/IERC20.sol';\\nimport { SafeMath } from './SafeMath.sol';\\nimport { Address } from './Address.sol';\\n\\n/**\\n * @title SafeERC20\\n * @dev From https://github.com/OpenZeppelin/openzeppelin-contracts\\n * Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\n    );\\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = address(token).call(data);\\n    require(success, 'SafeERC20: low-level call failed');\\n\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      // solhint-disable-next-line max-line-length\\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/impl/MD1Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { MD1Storage } from './MD1Storage.sol';\\n\\n/**\\n * @title MD1Roles\\n * @author dYdX\\n *\\n * @notice Defines roles used in the MerkleDistributorV1 contract. The hierarchy of roles and\\n *  powers of each role are described below.\\n *\\n *  Roles:\\n *\\n *    OWNER_ROLE\\n *      | -> May add or remove addresses from any of the below roles it manages.\\n *      | -> May update the rewards oracle address.\\n *      | -> May update the IPNS name.\\n *      |\\n *      +-- CONFIG_UPDATER_ROLE\\n *      |     -> May update parameters affecting the formulae used to calculate rewards.\\n *      |     -> May update the epoch schedule.\\n *      |     -> May update the IPFS update period.\\n *      |\\n *      +-- PAUSER_ROLE\\n *      |     -> May pause updates to the Merkle root.\\n *      |\\n *      +-- UNPAUSER_ROLE\\n *      |     -> May unpause updates to the Merkle root.\\n *      |\\n *      +-- CLAIM_OPERATOR_ROLE\\n *            -> May trigger a claim on behalf of a user (but the recipient is always the user).\\n */\\nabstract contract MD1Roles is\\n  MD1Storage\\n{\\n  bytes32 public constant OWNER_ROLE = keccak256('OWNER_ROLE');\\n  bytes32 public constant CONFIG_UPDATER_ROLE = keccak256('CONFIG_UPDATER_ROLE');\\n  bytes32 public constant PAUSER_ROLE = keccak256('PAUSER_ROLE');\\n  bytes32 public constant UNPAUSER_ROLE = keccak256('UNPAUSER_ROLE');\\n  bytes32 public constant CLAIM_OPERATOR_ROLE = keccak256('CLAIM_OPERATOR_ROLE');\\n\\n  function __MD1Roles_init()\\n    internal\\n  {\\n    // Assign the OWNER_ROLE to the sender.\\n    _setupRole(OWNER_ROLE, msg.sender);\\n\\n    // Set OWNER_ROLE as the admin of all roles.\\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(CONFIG_UPDATER_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(UNPAUSER_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(CLAIM_OPERATOR_ROLE, OWNER_ROLE);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256('')`\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      codehash := extcodehash(account)\\n    }\\n    return (codehash != accountHash && codehash != 0x0);\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(success, 'Address: unable to send value, recipient may have reverted');\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/impl/MD1Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { MD1Roles } from './MD1Roles.sol';\\n\\n/**\\n * @title MD1Pausable\\n * @author dYdX\\n *\\n * @notice Allows authorized addresses to pause updates to the Merkle root.\\n *\\n *  For the Merkle root to be updated, the root must first be set on the oracle contract, then\\n *  proposed on this contract, at which point the waiting period begins. During the waiting period,\\n *  the root should be verified, and updates should be paused by the PAUSER_ROLE if the root is\\n *  found to be incorrect.\\n */\\nabstract contract MD1Pausable is\\n  MD1Roles\\n{\\n  // ============ Events ============\\n\\n  /// @notice Emitted when root updates are paused.\\n  event RootUpdatesPaused();\\n\\n  /// @notice Emitted when root updates are unpaused.\\n  event RootUpdatesUnpaused();\\n\\n  // ============ Modifiers ============\\n\\n  /**\\n   * @dev Enforce that a function may be called only while root updates are not paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!_ARE_ROOT_UPDATES_PAUSED_, 'MD1Pausable: Updates paused');\\n    _;\\n  }\\n\\n  /**\\n   * @dev Enforce that a function may be called only while root updates are paused.\\n   */\\n  modifier whenPaused() {\\n    require(_ARE_ROOT_UPDATES_PAUSED_, 'MD1Pausable: Updates not paused');\\n    _;\\n  }\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @dev Called by PAUSER_ROLE to prevent proposed Merkle roots from becoming active.\\n   */\\n  function pauseRootUpdates()\\n    onlyRole(PAUSER_ROLE)\\n    whenNotPaused\\n    nonReentrant\\n    external\\n  {\\n    _ARE_ROOT_UPDATES_PAUSED_ = true;\\n    emit RootUpdatesPaused();\\n  }\\n\\n  /**\\n   * @dev Called by UNPAUSER_ROLE to resume allowing proposed Merkle roots to become active.\\n   */\\n  function unpauseRootUpdates()\\n    onlyRole(UNPAUSER_ROLE)\\n    whenPaused\\n    nonReentrant\\n    external\\n  {\\n    _ARE_ROOT_UPDATES_PAUSED_ = false;\\n    emit RootUpdatesUnpaused();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/impl/MD1EpochSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { MD1Types } from '../lib/MD1Types.sol';\\nimport { SafeCast } from '../lib/SafeCast.sol';\\nimport { MD1Storage } from './MD1Storage.sol';\\n\\n/**\\n * @title MD1EpochSchedule\\n * @author dYdX\\n *\\n * @dev Defines a function from block timestamp to epoch number.\\n *\\n *  Note that the current and IPFS epoch numbers are made available externally but are not used\\n *  internally within this contract.\\n *\\n *  The formula used is `n = floor((t - b) / a)` where:\\n *    - `n` is the epoch number\\n *    - `t` is the timestamp (in seconds)\\n *    - `b` is a non-negative offset, indicating the start of epoch zero (in seconds)\\n *    - `a` is the length of an epoch, a.k.a. the interval (in seconds)\\n */\\nabstract contract MD1EpochSchedule is\\n  MD1Storage\\n{\\n  using SafeCast for uint256;\\n  using SafeMath for uint256;\\n\\n  // ============ Events ============\\n\\n  event EpochScheduleUpdated(\\n    MD1Types.EpochParameters epochParameters\\n  );\\n\\n  // ============ Initializer ============\\n\\n  function __MD1EpochSchedule_init(\\n    uint256 interval,\\n    uint256 offset\\n  )\\n    internal\\n  {\\n    _setEpochParameters(interval, offset);\\n  }\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Get the epoch at the current block timestamp.\\n   *\\n   *  Reverts if epoch zero has not started.\\n   *\\n   * @return The current epoch number.\\n   */\\n  function getCurrentEpoch()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _getEpochAtTimestamp(\\n      block.timestamp,\\n      'MD1EpochSchedule: Epoch zero has not started'\\n    );\\n  }\\n\\n  /**\\n   * @notice Get the latest epoch number for which we expect to have data available on IPFS.\\n   *  This is equal to the current epoch number, delayed by the IPFS update period.\\n   *\\n   *  Reverts if epoch zero did not begin at least `_IPFS_UPDATE_PERIOD_` seconds ago.\\n   *\\n   * @return The latest epoch number for which we expect to have data available on IPFS.\\n   */\\n  function getIpfsEpoch()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _getEpochAtTimestamp(\\n      block.timestamp.sub(_IPFS_UPDATE_PERIOD_),\\n      'MD1EpochSchedule: IPFS epoch zero has not started'\\n    );\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  function _getEpochAtTimestamp(\\n    uint256 timestamp,\\n    string memory revertReason\\n  )\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    MD1Types.EpochParameters memory epochParameters = _EPOCH_PARAMETERS_;\\n\\n    uint256 interval = uint256(epochParameters.interval);\\n    uint256 offset = uint256(epochParameters.offset);\\n\\n    require(timestamp >= offset, revertReason);\\n\\n    return timestamp.sub(offset).div(interval);\\n  }\\n\\n  function _setEpochParameters(\\n    uint256 interval,\\n    uint256 offset\\n  )\\n    internal\\n  {\\n    require(interval != 0, 'MD1EpochSchedule: Interval cannot be zero');\\n\\n    MD1Types.EpochParameters memory epochParameters = MD1Types.EpochParameters({\\n      interval: interval.toUint128(),\\n      offset: offset.toUint128()\\n    });\\n\\n    _EPOCH_PARAMETERS_ = epochParameters;\\n\\n    emit EpochScheduleUpdated(epochParameters);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/merkle-distributor/v1/lib/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @dev Methods for downcasting unsigned integers, reverting on overflow.\\n */\\nlibrary SafeCast {\\n\\n  /**\\n   * @dev Downcast to a uint128, reverting on overflow.\\n   */\\n  function toUint128(uint256 a) internal pure returns (uint128) {\\n    uint128 b = uint128(a);\\n    require(uint256(b) == a, 'SafeCast: toUint128 overflow');\\n    return b;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardsToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardsTreasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allow\",\"type\":\"bool\"}],\"name\":\"AlwaysAllowClaimForUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"interval\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"offset\",\"type\":\"uint128\"}],\"indexed\":false,\"internalType\":\"struct MD1Types.EpochParameters\",\"name\":\"epochParameters\",\"type\":\"tuple\"}],\"name\":\"EpochScheduleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ipfsUpdatePeriod\",\"type\":\"uint256\"}],\"name\":\"IpfsUpdatePeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ipnsName\",\"type\":\"string\"}],\"name\":\"IpnsNameUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardsOracle\",\"type\":\"address\"}],\"name\":\"RewardsOracleChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketMakerRewardsAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"traderRewardsAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"traderScoreAlpha\",\"type\":\"uint256\"}],\"name\":\"RewardsParametersUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"ipfsCid\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"waitingPeriodEnd\",\"type\":\"uint256\"}],\"name\":\"RootProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"ipfsCid\",\"type\":\"bytes\"}],\"name\":\"RootUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RootUpdatesPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RootUpdatesUnpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CLAIM_OPERATOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONFIG_UPDATER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OWNER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARDS_TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARDS_TREASURY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRADER_SCORE_ALPHA_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNPAUSER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAITING_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canUpdateRoot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cumulativeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claimRewardsFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ipfsCid\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAlwaysAllowClaimsFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAreRootUpdatesPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEpochParameters\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"interval\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"offset\",\"type\":\"uint128\"}],\"internalType\":\"struct MD1Types.EpochParameters\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIpfsEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIpfsUpdatePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIpnsName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextRootEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProposedRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ipfsCid\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardsOracle\",\"outputs\":[{\"internalType\":\"contract IRewardsOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardsParameters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWaitingPeriodEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasPendingRoot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardsOracle\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"ipnsName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"ipfsUpdatePeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketMakerRewardsAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"traderRewardsAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"traderScoreAlpha\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochOffset\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseRootUpdates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposeRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"allow\",\"type\":\"bool\"}],\"name\":\"setAlwaysAllowClaimsFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"setEpochParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ipfsUpdatePeriod\",\"type\":\"uint256\"}],\"name\":\"setIpfsUpdatePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ipnsName\",\"type\":\"string\"}],\"name\":\"setIpnsName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardsOracle\",\"type\":\"address\"}],\"name\":\"setRewardsOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketMakerRewardsAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"traderRewardsAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"traderScoreAlpha\",\"type\":\"uint256\"}],\"name\":\"setRewardsParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseRootUpdates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MerkleDistributorV1","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000092d6c1e31e14520e676a687f0a93788b716beff5000000000000000000000000639192d54431f8c816368d3fb4107bc168d0e871","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}