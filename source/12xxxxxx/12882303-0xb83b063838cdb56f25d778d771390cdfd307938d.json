{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/metapriest/code/my_code/dotvote/contracts/contracts/MerkleLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\nlibrary MerkleLib {\\n\\n    function verifyProof(bytes32 root, bytes32 leaf, bytes32[] memory proof) public pure returns (bool) {\\n        bytes32 currentHash = leaf;\\n\\n        for (uint i = 0; i < proof.length; i += 1) {\\n            currentHash = parentHash(currentHash, proof[i]);\\n        }\\n\\n        return currentHash == root;\\n    }\\n\\n    function parentHash(bytes32 a, bytes32 b) public pure returns (bytes32) {\\n        if (a < b) {\\n            return keccak256(abi.encode(a, b));\\n        } else {\\n            return keccak256(abi.encode(b, a));\\n        }\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"/home/metapriest/code/my_code/dotvote/contracts/contracts/identity/GatedMerkleIdentity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\nimport \\\"../interfaces/IVotingIdentity.sol\\\";\\nimport \\\"../interfaces/IGate.sol\\\";\\nimport \\\"../MerkleLib.sol\\\";\\n\\ncontract GatedMerkleIdentity {\\n    using MerkleLib for *;\\n\\n    struct MerkleTree {\\n        bytes32 addressMerkleRoot;\\n        bytes32 metadataMerkleRoot;\\n        bytes32 leafHash;\\n        address nftAddress;\\n        address gateAddress;\\n    }\\n\\n    mapping (uint => MerkleTree) public merkleTrees;\\n    uint public numTrees;\\n\\n    address public management;\\n\\n    mapping (uint => mapping(address => bool)) public withdrawn;\\n\\n    event ManagementUpdated(address oldManagement, address newManagement);\\n    event MerkleTreeAdded(uint indexed index, address indexed nftAddress);\\n\\n    modifier managementOnly() {\\n        require (msg.sender == management, 'Only management may call this');\\n        _;\\n    }\\n\\n    constructor(address _mgmt) {\\n        management = _mgmt;\\n    }\\n\\n    // change the management key\\n    function setManagement(address newMgmt) external managementOnly {\\n        address oldMgmt =  management;\\n        management = newMgmt;\\n        emit ManagementUpdated(oldMgmt, newMgmt);\\n    }\\n\\n    function addMerkleTree(bytes32 addressMerkleRoot, bytes32 metadataMerkleRoot, bytes32 leafHash, address nftAddress, address gateAddress) external managementOnly {\\n        MerkleTree storage tree = merkleTrees[++numTrees];\\n        tree.addressMerkleRoot = addressMerkleRoot;\\n        tree.metadataMerkleRoot = metadataMerkleRoot;\\n        tree.leafHash = leafHash;\\n        tree.nftAddress = nftAddress;\\n        tree.gateAddress = gateAddress;\\n        emit MerkleTreeAdded(numTrees, nftAddress);\\n    }\\n\\n    function withdraw(uint merkleIndex, string memory uri, bytes32[] memory addressProof, bytes32[] memory metadataProof) external payable {\\n        MerkleTree storage tree = merkleTrees[merkleIndex];\\n        IVotingIdentity id = IVotingIdentity(tree.nftAddress);\\n        uint tokenId = id.numIdentities() + 1;\\n\\n        require(merkleIndex <= numTrees, 'merkleIndex out of range');\\n        require(verifyEntitled(tree.addressMerkleRoot, msg.sender, addressProof), \\\"The address proof could not be verified.\\\");\\n        require(verifyMetadata(tree.metadataMerkleRoot, tokenId, uri, metadataProof), \\\"The metadata proof could not be verified\\\");\\n        require(!withdrawn[merkleIndex][msg.sender], \\\"You have already withdrawn your nft from this merkle tree.\\\");\\n\\n        // close re-entrance gate, prevent double withdrawals\\n        withdrawn[merkleIndex][msg.sender] = true;\\n\\n        // pass thru the gate\\n        IGate(tree.gateAddress).passThruGate{value: msg.value}();\\n\\n        // mint an identity\\n        id.createIdentityFor(msg.sender, tokenId, uri);\\n    }\\n\\n    function getNextTokenId(uint merkleIndex) public view returns (uint) {\\n        MerkleTree memory tree = merkleTrees[merkleIndex];\\n        IVotingIdentity id = IVotingIdentity(tree.nftAddress);\\n        uint tokenId = id.totalSupply() + 1;\\n        return tokenId;\\n    }\\n\\n    function getPrice(uint merkleIndex) public view returns (uint) {\\n        MerkleTree memory tree = merkleTrees[merkleIndex];\\n        uint ethCost = IGate(tree.gateAddress).getCost();\\n        return ethCost;\\n    }\\n\\n    // mostly for debugging\\n    function getLeaf(address data1, string memory data2) external pure returns (bytes memory) {\\n        return abi.encode(data1, data2);\\n    }\\n\\n    // mostly for debugging\\n    function getHash(address data1, string memory data2) external pure returns (bytes32) {\\n        return keccak256(abi.encode(data1, data2));\\n    }\\n\\n    function verifyEntitled(bytes32 root, address recipient, bytes32[] memory proof) public pure returns (bool) {\\n        // We need to pack the 20 bytes address to the 32 bytes value\\n        bytes32 leaf = keccak256(abi.encode(recipient));\\n        return root.verifyProof(leaf, proof);\\n    }\\n\\n    function verifyMetadata(bytes32 root, uint tokenId, string memory uri, bytes32[] memory proof) public pure returns (bool) {\\n        bytes32 leaf = keccak256(abi.encode(tokenId, uri));\\n        return root.verifyProof(leaf, proof);\\n    }\\n\\n}\"\r\n    },\r\n    \"/home/metapriest/code/my_code/dotvote/contracts/contracts/interfaces/IGate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\ninterface IGate {\\n\\n    function getCost() external view returns (uint ethCost);\\n\\n    function passThruGate() external payable;\\n}\\n\"\r\n    },\r\n    \"/home/metapriest/code/my_code/dotvote/contracts/contracts/interfaces/IVotingIdentity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IVotingIdentity {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address, address) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n        Minting function\\n    */\\n    function createIdentityFor(address newId, uint tokenId, string memory uri) external;\\n\\n    /**\\n        Who's in charge around here\\n    */\\n    function owner() external view returns (address);\\n\\n    function numIdentities() external view returns (uint);\\n\\n    function totalSupply() external view returns (uint);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"/home/metapriest/code/my_code/dotvote/contracts/contracts/MerkleLib.sol\": {\r\n        \"MerkleLib\": \"0x8196D6264BB667908dC106D855Bf53E03816e725\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mgmt\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldManagement\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManagement\",\"type\":\"address\"}],\"name\":\"ManagementUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"}],\"name\":\"MerkleTreeAdded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"addressMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"metadataMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"leafHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gateAddress\",\"type\":\"address\"}],\"name\":\"addMerkleTree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"data1\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"data2\",\"type\":\"string\"}],\"name\":\"getHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"data1\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"data2\",\"type\":\"string\"}],\"name\":\"getLeaf\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"}],\"name\":\"getNextTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"merkleTrees\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"addressMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"metadataMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"leafHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gateAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTrees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMgmt\",\"type\":\"address\"}],\"name\":\"setManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyEntitled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyMetadata\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"bytes32[]\",\"name\":\"addressProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"metadataProof\",\"type\":\"bytes32[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GatedMerkleIdentity","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000288fe43139741f91a8cbb6f4add83811c794851b","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}