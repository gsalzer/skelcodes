{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title The interface for the Uniswap V3 Factory\\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\\ninterface IUniswapV3Factory {\\n    /// @notice Emitted when the owner of the factory is changed\\n    /// @param oldOwner The owner before the owner was changed\\n    /// @param newOwner The owner after the owner was changed\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @notice Emitted when a pool is created\\n    /// @param token0 The first token of the pool by address sort order\\n    /// @param token1 The second token of the pool by address sort order\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\\n    /// @param pool The address of the created pool\\n    event PoolCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        uint24 indexed fee,\\n        int24 tickSpacing,\\n        address pool\\n    );\\n\\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\\n    /// @param fee The enabled fee, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\\n\\n    /// @notice Returns the current owner of the factory\\n    /// @dev Can be changed by the current owner via setOwner\\n    /// @return The address of the factory owner\\n    function owner() external view returns (address);\\n\\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\\n    /// @return The tick spacing\\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\\n\\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\\n    /// @param tokenA The contract address of either token0 or token1\\n    /// @param tokenB The contract address of the other token\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @return pool The pool address\\n    function getPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external view returns (address pool);\\n\\n    /// @notice Creates a pool for the given two tokens and fee\\n    /// @param tokenA One of the two tokens in the desired pool\\n    /// @param tokenB The other of the two tokens in the desired pool\\n    /// @param fee The desired fee for the pool\\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\\n    /// are invalid.\\n    /// @return pool The address of the newly created pool\\n    function createPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external returns (address pool);\\n\\n    /// @notice Updates the owner of the factory\\n    /// @dev Must be called by the current owner\\n    /// @param _owner The new owner of the factory\\n    function setOwner(address _owner) external;\\n\\n    /// @notice Enables a fee amount with the given tickSpacing\\n    /// @dev Fee amounts may never be removed once enabled\\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\\n}\\n\"\r\n    },\r\n    \"contracts/GUniFactory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport {\\n    IUniswapV3Factory\\n} from \\\"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\\\";\\nimport {IGUniFactory} from \\\"./interfaces/IGUniFactory.sol\\\";\\nimport {IGUniPoolStorage} from \\\"./interfaces/IGUniPoolStorage.sol\\\";\\nimport {GUniFactoryStorage} from \\\"./abstract/GUniFactoryStorage.sol\\\";\\nimport {EIP173Proxy} from \\\"./vendor/proxy/EIP173Proxy.sol\\\";\\nimport {IEIP173Proxy} from \\\"./interfaces/IEIP173Proxy.sol\\\";\\nimport {\\n    IERC20Metadata\\n} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {\\n    EnumerableSet\\n} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\ncontract GUniFactory is GUniFactoryStorage, IGUniFactory {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    constructor(address _uniswapV3Factory)\\n        GUniFactoryStorage(_uniswapV3Factory)\\n    {} // solhint-disable-line no-empty-blocks\\n\\n    /// @notice createPool creates a new instance of a G-UNI token on a specified\\n    /// UniswapV3 pool. The msg.sender is the initial manager of the pool and will\\n    /// forever be associated with the G-UNI pool as it's `deployer`\\n    /// @param tokenA one of the tokens in the uniswap pair\\n    /// @param tokenB the other token in the uniswap pair\\n    /// @param uniFee fee tier of the uniswap pair\\n    /// @param managerFee proportion of earned fees that go to pool manager in Basis Points\\n    /// @param lowerTick initial lower bound of the Uniswap V3 position\\n    /// @param upperTick initial upper bound of the Uniswap V3 position\\n    /// @return pool the address of the newly created G-UNI pool (proxy)\\n    // solhint-disable-next-line function-max-lines\\n    function createPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 uniFee,\\n        uint16 managerFee,\\n        int24 lowerTick,\\n        int24 upperTick\\n    ) external override returns (address pool) {\\n        (address token0, address token1) = _getTokenOrder(tokenA, tokenB);\\n\\n        pool = address(new EIP173Proxy(poolImplementation, address(this), \\\"\\\"));\\n\\n        string memory name = \\\"Gelato Uniswap LP\\\";\\n        try this.getTokenName(token0, token1) returns (string memory result) {\\n            name = result;\\n        } catch {} // solhint-disable-line no-empty-blocks\\n\\n        address uniPool =\\n            IUniswapV3Factory(factory).getPool(token0, token1, uniFee);\\n\\n        require(uniPool != address(0), \\\"uniswap pool does not exist\\\");\\n\\n        IGUniPoolStorage(pool).initialize(\\n            name,\\n            \\\"G-UNI\\\",\\n            uniPool,\\n            managerFee,\\n            lowerTick,\\n            upperTick,\\n            msg.sender\\n        );\\n        _deployers.add(msg.sender);\\n        _pools[msg.sender].add(pool);\\n        emit PoolCreated(uniPool, msg.sender, pool);\\n    }\\n\\n    function getTokenName(address token0, address token1)\\n        external\\n        view\\n        returns (string memory)\\n    {\\n        string memory symbol0 = IERC20Metadata(token0).symbol();\\n        string memory symbol1 = IERC20Metadata(token1).symbol();\\n\\n        return _append(\\\"Gelato Uniswap \\\", symbol0, \\\"/\\\", symbol1, \\\" LP\\\");\\n    }\\n\\n    function upgradePools(address[] memory pools) external onlyManager {\\n        for (uint256 i = 0; i < pools.length; i++) {\\n            IEIP173Proxy(pools[i]).upgradeTo(poolImplementation);\\n        }\\n    }\\n\\n    function upgradePoolsAndCall(address[] memory pools, bytes[] calldata datas)\\n        external\\n        onlyManager\\n    {\\n        require(pools.length == datas.length, \\\"mismatching array length\\\");\\n        for (uint256 i = 0; i < pools.length; i++) {\\n            IEIP173Proxy(pools[i]).upgradeToAndCall(\\n                poolImplementation,\\n                datas[i]\\n            );\\n        }\\n    }\\n\\n    function makePoolsImmutable(address[] memory pools) external onlyManager {\\n        for (uint256 i = 0; i < pools.length; i++) {\\n            IEIP173Proxy(pools[i]).transferProxyAdmin(address(0));\\n        }\\n    }\\n\\n    /// @notice isPoolImmutable checks if a certain G-UNI pool is \\\"immutable\\\" i.e. that the\\n    /// proxyAdmin is the zero address and thus the underlying implementation cannot be upgraded\\n    /// @param pool address of the G-UNI pool\\n    /// @return bool signaling if pool is immutable (true) or not (false)\\n    function isPoolImmutable(address pool) external view returns (bool) {\\n        return address(0) == getProxyAdmin(pool);\\n    }\\n\\n    /// @notice getGelatoPools gets all the G-UNI pools deployed by Gelato's\\n    /// default deployer address (since anyone can deploy and manage G-UNI pools)\\n    /// @return list of Gelato managed G-UNI pool addresses\\n    function getGelatoPools() external view returns (address[] memory) {\\n        return getPools(gelatoDeployer);\\n    }\\n\\n    /// @notice getDeployers fetches all addresses that have deployed a G-UNI pool\\n    /// @return deployers the list of deployer addresses\\n    function getDeployers() public view returns (address[] memory) {\\n        uint256 length = numDeployers();\\n        address[] memory deployers = new address[](length);\\n        for (uint256 i = 0; i < length; i++) {\\n            deployers[i] = _getDeployer(i);\\n        }\\n\\n        return deployers;\\n    }\\n\\n    /// @notice getPools fetches all the G-UNI pool addresses deployed by `deployer`\\n    /// @param deployer address that has potentially deployed G-UNI pools (can return empty array)\\n    /// @return pools the list of G-UNI pool addresses deployed by `deployer`\\n    function getPools(address deployer) public view returns (address[] memory) {\\n        uint256 length = numPools(deployer);\\n        address[] memory pools = new address[](length);\\n        for (uint256 i = 0; i < length; i++) {\\n            pools[i] = _getPool(deployer, i);\\n        }\\n\\n        return pools;\\n    }\\n\\n    /// @notice numPools counts the total number of G-UNI pools in existence\\n    /// @return result total number of G-UNI pools deployed\\n    function numPools() public view returns (uint256 result) {\\n        address[] memory deployers = getDeployers();\\n        for (uint256 i = 0; i < deployers.length; i++) {\\n            result += numPools(deployers[i]);\\n        }\\n    }\\n\\n    /// @notice numDeployers counts the total number of G-UNI pool deployer addresses\\n    /// @return total number of G-UNI pool deployer addresses\\n    function numDeployers() public view returns (uint256) {\\n        return _deployers.length();\\n    }\\n\\n    /// @notice numPools counts the total number of G-UNI pools deployed by `deployer`\\n    /// @param deployer deployer address\\n    /// @return total number of G-UNI pools deployed by `deployer`\\n    function numPools(address deployer) public view returns (uint256) {\\n        return _pools[deployer].length();\\n    }\\n\\n    /// @notice getProxyAdmin gets the current address who controls the underlying implementation\\n    /// of a G-UNI pool. For most all pools either this contract address or the zero address will\\n    /// be the proxyAdmin. If the admin is the zero address the pool's implementation is naturally\\n    /// no longer upgradable (no one owns the zero address).\\n    /// @param pool address of the G-UNI pool\\n    /// @return address that controls the G-UNI implementation (has power to upgrade it)\\n    function getProxyAdmin(address pool) public view returns (address) {\\n        return IEIP173Proxy(pool).proxyAdmin();\\n    }\\n\\n    function _getDeployer(uint256 index) internal view returns (address) {\\n        return _deployers.at(index);\\n    }\\n\\n    function _getPool(address deployer, uint256 index)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        return _pools[deployer].at(index);\\n    }\\n\\n    function _getTokenOrder(address tokenA, address tokenB)\\n        internal\\n        pure\\n        returns (address token0, address token1)\\n    {\\n        require(tokenA != tokenB, \\\"same token\\\");\\n        (token0, token1) = tokenA < tokenB\\n            ? (tokenA, tokenB)\\n            : (tokenB, tokenA);\\n        require(token0 != address(0), \\\"no address zero\\\");\\n    }\\n\\n    function _append(\\n        string memory a,\\n        string memory b,\\n        string memory c,\\n        string memory d,\\n        string memory e\\n    ) internal pure returns (string memory) {\\n        return string(abi.encodePacked(a, b, c, d, e));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/GUniFactoryStorage.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport {OwnableUninitialized} from \\\"./OwnableUninitialized.sol\\\";\\nimport {\\n    Initializable\\n} from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport {\\n    EnumerableSet\\n} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\n// solhint-disable-next-line max-states-count\\ncontract GUniFactoryStorage is\\n    OwnableUninitialized, /* XXXX DONT MODIFY ORDERING XXXX */\\n    Initializable\\n    // APPEND ADDITIONAL BASE WITH STATE VARS BELOW:\\n    // XXXX DONT MODIFY ORDERING XXXX\\n{\\n    // XXXXXXXX DO NOT MODIFY ORDERING XXXXXXXX\\n    // solhint-disable-next-line const-name-snakecase\\n    string public constant version = \\\"1.0.0\\\";\\n    address public immutable factory;\\n    address public poolImplementation;\\n    address public gelatoDeployer;\\n    EnumerableSet.AddressSet internal _deployers;\\n    mapping(address => EnumerableSet.AddressSet) internal _pools;\\n    // APPPEND ADDITIONAL STATE VARS BELOW:\\n    // XXXXXXXX DO NOT MODIFY ORDERING XXXXXXXX\\n\\n    event UpdatePoolImplementation(\\n        address previousImplementation,\\n        address newImplementation\\n    );\\n\\n    event UpdateGelatoDeployer(\\n        address previosGelatoDeployer,\\n        address newGelatoDeployer\\n    );\\n\\n    constructor(address _uniswapV3Factory) {\\n        factory = _uniswapV3Factory;\\n    }\\n\\n    function initialize(\\n        address _implementation,\\n        address _gelatoDeployer,\\n        address _manager_\\n    ) external initializer {\\n        poolImplementation = _implementation;\\n        gelatoDeployer = _gelatoDeployer;\\n        _manager = _manager_;\\n    }\\n\\n    function setPoolImplementation(address nextImplementation)\\n        external\\n        onlyManager\\n    {\\n        emit UpdatePoolImplementation(poolImplementation, nextImplementation);\\n        poolImplementation = nextImplementation;\\n    }\\n\\n    function setGelatoDeployer(address nextGelatoDeployer)\\n        external\\n        onlyManager\\n    {\\n        emit UpdateGelatoDeployer(gelatoDeployer, nextGelatoDeployer);\\n        gelatoDeployer = nextGelatoDeployer;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/OwnableUninitialized.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an manager) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the manager account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyManager`, which can be applied to your functions to restrict their use to\\n * the manager.\\n */\\n/// @dev DO NOT ADD STATE VARIABLES - APPEND THEM TO GelatoUniV3PoolStorage\\n/// @dev DO NOT ADD BASE CONTRACTS WITH STATE VARS - APPEND THEM TO GelatoUniV3PoolStorage\\nabstract contract OwnableUninitialized {\\n    address internal _manager;\\n\\n    event OwnershipTransferred(\\n        address indexed previousManager,\\n        address indexed newManager\\n    );\\n\\n    /// @dev Initializes the contract setting the deployer as the initial manager.\\n    /// CONSTRUCTOR EMPTY - USE INITIALIZIABLE INSTEAD\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor() {}\\n\\n    /**\\n     * @dev Returns the address of the current manager.\\n     */\\n    function manager() public view virtual returns (address) {\\n        return _manager;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the manager.\\n     */\\n    modifier onlyManager() {\\n        require(manager() == msg.sender, \\\"Ownable: caller is not the manager\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without manager. It will not be possible to call\\n     * `onlyManager` functions anymore. Can only be called by the current manager.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an manager,\\n     * thereby removing any functionality that is only available to the manager.\\n     */\\n    function renounceOwnership() public virtual onlyManager {\\n        emit OwnershipTransferred(_manager, address(0));\\n        _manager = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current manager.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyManager {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new manager is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_manager, newOwner);\\n        _manager = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEIP173Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.4;\\n\\ninterface IEIP173Proxy {\\n    function proxyAdmin() external view returns (address);\\n\\n    function transferProxyAdmin(address newAdmin) external;\\n\\n    function upgradeTo(address newImplementation) external;\\n\\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\\n        external\\n        payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGUniFactory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\ninterface IGUniFactory {\\n    event PoolCreated(\\n        address indexed uniPool,\\n        address indexed manager,\\n        address indexed pool\\n    );\\n\\n    function createPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 uniFee,\\n        uint16 managerFee,\\n        int24 lowerTick,\\n        int24 upperTick\\n    ) external returns (address pool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGUniPoolStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.4;\\n\\ninterface IGUniPoolStorage {\\n    function initialize(\\n        string memory _name,\\n        string memory _symbol,\\n        address _pool,\\n        uint16 _managerFeeBPS,\\n        int24 _lowerTick,\\n        int24 _upperTick,\\n        address _manager_\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/proxy/EIP173Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.4;\\n\\nimport \\\"./Proxy.sol\\\";\\n\\ninterface ERC165 {\\n    function supportsInterface(bytes4 id) external view returns (bool);\\n}\\n\\n///@notice Proxy implementing EIP173 for ownership management\\ncontract EIP173Proxy is Proxy {\\n    // ////////////////////////// EVENTS ///////////////////////////////////////////////////////////////////////\\n\\n    event ProxyAdminTransferred(\\n        address indexed previousAdmin,\\n        address indexed newAdmin\\n    );\\n\\n    // /////////////////////// CONSTRUCTOR //////////////////////////////////////////////////////////////////////\\n\\n    constructor(\\n        address implementationAddress,\\n        address adminAddress,\\n        bytes memory data\\n    ) payable {\\n        _setImplementation(implementationAddress, data);\\n        _setProxyAdmin(adminAddress);\\n    }\\n\\n    // ///////////////////// EXTERNAL ///////////////////////////////////////////////////////////////////////////\\n\\n    function proxyAdmin() external view returns (address) {\\n        return _proxyAdmin();\\n    }\\n\\n    function supportsInterface(bytes4 id) external view returns (bool) {\\n        if (id == 0x01ffc9a7 || id == 0x7f5828d0) {\\n            return true;\\n        }\\n        if (id == 0xFFFFFFFF) {\\n            return false;\\n        }\\n\\n        ERC165 implementation;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            implementation := sload(\\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\\n            )\\n        }\\n\\n        // Technically this is not standard compliant as ERC-165 require 30,000 gas which that call cannot ensure\\n        // because it is itself inside `supportsInterface` that might only get 30,000 gas.\\n        // In practise this is unlikely to be an issue.\\n        try implementation.supportsInterface(id) returns (bool support) {\\n            return support;\\n        } catch {\\n            return false;\\n        }\\n    }\\n\\n    function transferProxyAdmin(address newAdmin) external onlyProxyAdmin {\\n        _setProxyAdmin(newAdmin);\\n    }\\n\\n    function upgradeTo(address newImplementation) external onlyProxyAdmin {\\n        _setImplementation(newImplementation, \\\"\\\");\\n    }\\n\\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\\n        external\\n        payable\\n        onlyProxyAdmin\\n    {\\n        _setImplementation(newImplementation, data);\\n    }\\n\\n    // /////////////////////// MODIFIERS ////////////////////////////////////////////////////////////////////////\\n\\n    modifier onlyProxyAdmin() {\\n        require(msg.sender == _proxyAdmin(), \\\"NOT_AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    // ///////////////////////// INTERNAL //////////////////////////////////////////////////////////////////////\\n\\n    function _proxyAdmin() internal view returns (address adminAddress) {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            adminAddress := sload(\\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\\n            )\\n        }\\n    }\\n\\n    function _setProxyAdmin(address newAdmin) internal {\\n        address previousAdmin = _proxyAdmin();\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            sstore(\\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                newAdmin\\n            )\\n        }\\n        emit ProxyAdminTransferred(previousAdmin, newAdmin);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.4;\\n\\n// EIP-1967\\nabstract contract Proxy {\\n    // /////////////////////// EVENTS ///////////////////////////////////////////////////////////////////////////\\n\\n    event ProxyImplementationUpdated(\\n        address indexed previousImplementation,\\n        address indexed newImplementation\\n    );\\n\\n    // ///////////////////// EXTERNAL ///////////////////////////////////////////////////////////////////////////\\n\\n    // prettier-ignore\\n    receive() external payable virtual {\\n        revert(\\\"ETHER_REJECTED\\\"); // explicit reject by default\\n    }\\n\\n    fallback() external payable {\\n        _fallback();\\n    }\\n\\n    // ///////////////////////// INTERNAL //////////////////////////////////////////////////////////////////////\\n\\n    function _fallback() internal {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            let implementationAddress := sload(\\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\\n            )\\n            calldatacopy(0x0, 0x0, calldatasize())\\n            let success := delegatecall(\\n                gas(),\\n                implementationAddress,\\n                0x0,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            let retSz := returndatasize()\\n            returndatacopy(0, 0, retSz)\\n            switch success\\n                case 0 {\\n                    revert(0, retSz)\\n                }\\n                default {\\n                    return(0, retSz)\\n                }\\n        }\\n    }\\n\\n    function _setImplementation(address newImplementation, bytes memory data)\\n        internal\\n    {\\n        address previousImplementation;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            previousImplementation := sload(\\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\\n            )\\n        }\\n\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            sstore(\\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\\n                newImplementation\\n            )\\n        }\\n\\n        emit ProxyImplementationUpdated(\\n            previousImplementation,\\n            newImplementation\\n        );\\n\\n        if (data.length > 0) {\\n            (bool success, ) = newImplementation.delegatecall(data);\\n            if (!success) {\\n                assembly {\\n                    // This assembly ensure the revert contains the exact string data\\n                    let returnDataSize := returndatasize()\\n                    returndatacopy(0, 0, returnDataSize)\\n                    revert(0, returnDataSize)\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapV3Factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"uniPool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previosGelatoDeployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGelatoDeployer\",\"type\":\"address\"}],\"name\":\"UpdateGelatoDeployer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"UpdatePoolImplementation\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"uniFee\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"managerFee\",\"type\":\"uint16\"},{\"internalType\":\"int24\",\"name\":\"lowerTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick\",\"type\":\"int24\"}],\"name\":\"createPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gelatoDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDeployers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGelatoPools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"name\":\"getPools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getProxyAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"name\":\"getTokenName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gelatoDeployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_manager_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"isPoolImmutable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"name\":\"makePoolsImmutable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numDeployers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"name\":\"numPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextGelatoDeployer\",\"type\":\"address\"}],\"name\":\"setGelatoDeployer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextImplementation\",\"type\":\"address\"}],\"name\":\"setPoolImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"name\":\"upgradePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"datas\",\"type\":\"bytes[]\"}],\"name\":\"upgradePoolsAndCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GUniFactory","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"0000000000000000000000001f98431c8ad98523631ae4a59f267346ea31f984","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}