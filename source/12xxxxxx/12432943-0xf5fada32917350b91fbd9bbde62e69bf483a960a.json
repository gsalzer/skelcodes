{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/BColor.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.7.0;\r\n\r\nabstract contract BColor {\r\n    function getColor()\r\n        external virtual view\r\n        returns (bytes32);\r\n}\r\n\r\ncontract BBronze is BColor {\r\n    function getColor()\r\n        external override view\r\n        returns (bytes32) {\r\n            return bytes32(\"BRONZE\");\r\n        }\r\n}\r\n\r\n// File: contracts/BConst.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.7.0;\r\n\r\n\r\ncontract BConst is BBronze {\r\n    uint public constant BONE              = 10**18;\r\n\r\n    uint public constant MIN_BOUND_TOKENS  = 2;\r\n    uint public constant MAX_BOUND_TOKENS  = 8;\r\n\r\n    uint public constant MIN_FEE           = BONE / 10**6;\r\n    uint public constant MAX_FEE           = BONE / 10;\r\n    uint public constant EXIT_FEE          = 0;\r\n\r\n    uint public constant MIN_WEIGHT        = BONE;\r\n    uint public constant MAX_WEIGHT        = BONE * 50;\r\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\r\n    uint public constant MIN_BALANCE       = BONE / 10**12;\r\n\r\n    uint public constant INIT_POOL_SUPPLY  = BONE * 100;\r\n\r\n    uint public constant MIN_BPOW_BASE     = 1 wei;\r\n    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;\r\n    uint public constant BPOW_PRECISION    = BONE / 10**10;\r\n\r\n    uint public constant MAX_IN_RATIO      = BONE / 2;\r\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\r\n}\r\n\r\n// File: contracts/BNum.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.7.0;\r\n\r\n\r\ncontract BNum is BConst {\r\n\r\n    function btoi(uint a)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        return a / BONE;\r\n    }\r\n\r\n    function bfloor(uint a)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        return btoi(a) * BONE;\r\n    }\r\n\r\n    function badd(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsub(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        (uint c, bool flag) = bsubSign(a, b);\r\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsubSign(uint a, uint b)\r\n        internal pure\r\n        returns (uint, bool)\r\n    {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    function bmul(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n        uint c1 = c0 + (BONE / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint c2 = c1 / BONE;\r\n        return c2;\r\n    }\r\n\r\n    function bdiv(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        require(b != 0, \"ERR_DIV_ZERO\");\r\n        uint c0 = a * BONE;\r\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n        uint c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n        uint c2 = c1 / b;\r\n        return c2;\r\n    }\r\n\r\n    // DSMath.wpow\r\n    function bpowi(uint a, uint n)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint z = n % 2 != 0 ? a : BONE;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            a = bmul(a, a);\r\n\r\n            if (n % 2 != 0) {\r\n                z = bmul(z, a);\r\n            }\r\n        }\r\n        return z;\r\n    }\r\n\r\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\r\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\r\n    // of approximation of b^0.w\r\n    function bpow(uint base, uint exp)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\r\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\r\n\r\n        uint whole  = bfloor(exp);\r\n        uint remain = bsub(exp, whole);\r\n\r\n        uint wholePow = bpowi(base, btoi(whole));\r\n\r\n        if (remain == 0) {\r\n            return wholePow;\r\n        }\r\n\r\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\r\n        return bmul(wholePow, partialResult);\r\n    }\r\n\r\n    function bpowApprox(uint base, uint exp, uint precision)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        // term 0:\r\n        uint a     = exp;\r\n        (uint x, bool xneg)  = bsubSign(base, BONE);\r\n        uint term = BONE;\r\n        uint sum   = term;\r\n        bool negative = false;\r\n\r\n\r\n        // term(k) = numer / denom\r\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\r\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\r\n        // continue until term is less than precision\r\n        for (uint i = 1; term >= precision; i++) {\r\n            uint bigK = i * BONE;\r\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\r\n            term = bmul(term, bmul(c, x));\r\n            term = bdiv(term, bigK);\r\n            if (term == 0) break;\r\n\r\n            if (xneg) negative = !negative;\r\n            if (cneg) negative = !negative;\r\n            if (negative) {\r\n                sum = bsub(sum, term);\r\n            } else {\r\n                sum = badd(sum, term);\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/IERC20.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.7.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address whom) external view returns (uint);\r\n    function allowance(address src, address dst) external view returns (uint);\r\n\r\n    function approve(address dst, uint amt) external returns (bool);\r\n    function transfer(address dst, uint amt) external returns (bool);\r\n    function transferFrom(\r\n        address src, address dst, uint amt\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/proxy/Initializable.sol\r\n\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity >=0.4.24 <0.8.0;\r\n\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function _isConstructor() private view returns (bool) {\r\n        return !Address.isContract(address(this));\r\n    }\r\n}\r\n\r\n// File: contracts/BToken.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.7.0;\r\n\r\n\r\n\r\n\r\nabstract contract BTokenBase is BNum {\r\n\r\n    mapping(address => uint)                   internal _balance;\r\n    mapping(address => mapping(address=>uint)) internal _allowance;\r\n    uint internal _totalSupply;\r\n\r\n    event Approval(address indexed src, address indexed dst, uint amt);\r\n    event Transfer(address indexed src, address indexed dst, uint amt);\r\n\r\n    function _mint(uint amt) internal {\r\n        _balance[address(this)] = badd(_balance[address(this)], amt);\r\n        _totalSupply = badd(_totalSupply, amt);\r\n        emit Transfer(address(0), address(this), amt);\r\n    }\r\n\r\n    function _burn(uint amt) internal {\r\n        require(_balance[address(this)] >= amt, \"ERR_INSUFFICIENT_BAL\");\r\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\r\n        _totalSupply = bsub(_totalSupply, amt);\r\n        emit Transfer(address(this), address(0), amt);\r\n    }\r\n\r\n    function _move(address src, address dst, uint amt) internal {\r\n        require(_balance[src] >= amt, \"ERR_INSUFFICIENT_BAL\");\r\n        _balance[src] = bsub(_balance[src], amt);\r\n        _balance[dst] = badd(_balance[dst], amt);\r\n        emit Transfer(src, dst, amt);\r\n    }\r\n\r\n    function _push(address to, uint amt) internal {\r\n        _move(address(this), to, amt);\r\n    }\r\n\r\n    function _pull(address from, uint amt) internal {\r\n        _move(from, address(this), amt);\r\n    }\r\n}\r\n\r\nabstract contract BToken is Initializable, BTokenBase, IERC20 {\r\n    string  private _name;\r\n    string  private _symbol;\r\n    uint8   private _decimals;\r\n\r\n    function __BToken_init_unchained() internal initializer {\r\n        _name     = \"Swarm Markets Pool Token\";\r\n        _symbol   = \"SPT\";\r\n        _decimals = 18;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns(uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function allowance(address src, address dst) external override view returns (uint) {\r\n        return _allowance[src][dst];\r\n    }\r\n\r\n    function balanceOf(address whom) external override view returns (uint) {\r\n        return _balance[whom];\r\n    }\r\n\r\n    function totalSupply() public override view returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function approve(address dst, uint amt) external override returns (bool) {\r\n        _allowance[msg.sender][dst] = amt;\r\n        emit Approval(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address dst, uint amt) external returns (bool) {\r\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\r\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\r\n        uint oldValue = _allowance[msg.sender][dst];\r\n        if (amt > oldValue) {\r\n            _allowance[msg.sender][dst] = 0;\r\n        } else {\r\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\r\n        }\r\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint amt) external override returns (bool) {\r\n        _move(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint amt) external override returns (bool) {\r\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \"ERR_BTOKEN_BAD_CALLER\");\r\n        _move(src, dst, amt);\r\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\r\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\r\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/BMath.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.7.0;\r\n\r\n\r\ncontract BMath is BBronze, BConst, BNum {\r\n    /**********************************************************************************************\r\n    // calcSpotPrice                                                                             //\r\n    // sP = spotPrice                                                                            //\r\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\r\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\r\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\r\n    // wO = tokenWeightOut                                                                       //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcSpotPrice(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint spotPrice)\r\n    {\r\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\r\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\r\n        uint ratio = bdiv(numer, denom);\r\n        uint scale = bdiv(BONE, bsub(BONE, swapFee));\r\n        return  (spotPrice = bmul(ratio, scale));\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcOutGivenIn                                                                            //\r\n    // aO = tokenAmountOut                                                                       //\r\n    // bO = tokenBalanceOut                                                                      //\r\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\r\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\r\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\r\n    // wO = tokenWeightOut                                                                       //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcOutGivenIn(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint tokenAmountIn,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint tokenAmountOut)\r\n    {\r\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\r\n        uint adjustedIn = bsub(BONE, swapFee);\r\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\r\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\r\n        uint foo = bpow(y, weightRatio);\r\n        uint bar = bsub(BONE, foo);\r\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcInGivenOut                                                                            //\r\n    // aI = tokenAmountIn                                                                        //\r\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\r\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\r\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\r\n    // wI = tokenWeightIn           --------------------------------------------                 //\r\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcInGivenOut(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint tokenAmountOut,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint tokenAmountIn)\r\n    {\r\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\r\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\r\n        uint y = bdiv(tokenBalanceOut, diff);\r\n        uint foo = bpow(y, weightRatio);\r\n        foo = bsub(foo, BONE);\r\n        tokenAmountIn = bsub(BONE, swapFee);\r\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcPoolOutGivenSingleIn                                                                  //\r\n    // pAo = poolAmountOut         /                                              \\              //\r\n    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\r\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\r\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\r\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\r\n    // pS = poolSupply            \\\\                    tBi               /        /             //\r\n    // sF = swapFee                \\                                              /              //\r\n    **********************************************************************************************/\r\n    function calcPoolOutGivenSingleIn(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint tokenAmountIn,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint poolAmountOut)\r\n    {\r\n        // Charge the trading fee for the proportion of tokenAi\r\n        // which is implicitly traded to the other pool tokens.\r\n        // That proportion is (1- weightTokenIn)\r\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\r\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\r\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\r\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\r\n\r\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\r\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\r\n\r\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\r\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\r\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\r\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\r\n        return poolAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcSingleInGivenPoolOut                                                                  //\r\n    // tAi = tokenAmountIn              //(pS + pAo)\\     /    1    \\\\                           //\r\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\r\n    // pAo = poolAmountOut              \\\\    pS    /     \\(wI / tW)//                           //\r\n    // bI = balanceIn          tAi =  --------------------------------------------               //\r\n    // wI = weightIn                              /      wI  \\                                   //\r\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\r\n    // sF = swapFee                               \\      tW  /                                   //\r\n    **********************************************************************************************/\r\n    function calcSingleInGivenPoolOut(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint poolAmountOut,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint tokenAmountIn)\r\n    {\r\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\r\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\r\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\r\n\r\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\r\n        uint boo = bdiv(BONE, normalizedWeight);\r\n        uint tokenInRatio = bpow(poolRatio, boo);\r\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\r\n        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\r\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\r\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\r\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\r\n        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);\r\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcSingleOutGivenPoolIn                                                                  //\r\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\r\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\r\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\r\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\r\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\r\n    // tW = totalWeight                    /     /      wO \\       \\                             //\r\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\r\n    // eF = exitFee                        \\     \\      tW /       /                             //\r\n    **********************************************************************************************/\r\n    function calcSingleOutGivenPoolIn(\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint poolAmountIn,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint tokenAmountOut)\r\n    {\r\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\r\n        // charge exit fee on the pool token side\r\n        // pAiAfterExitFee = pAi*(1-exitFee)\r\n        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\r\n        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\r\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\r\n\r\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\r\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\r\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\r\n\r\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\r\n\r\n        // charge swap fee on the output token side\r\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\r\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\r\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcPoolInGivenSingleOut                                                                  //\r\n    // pAi = poolAmountIn               // /               tAo             \\\\     / wO \\     \\   //\r\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\   | ---- |     \\  //\r\n    // tAo = tokenAmountOut      pS - ||   \\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\ tW /  * pS | //\r\n    // ps = poolSupply                 \\\\ -----------------------------------/                /  //\r\n    // wO = tokenWeightOut  pAi =       \\\\               bO                 /                /   //\r\n    // tW = totalWeight           -------------------------------------------------------------  //\r\n    // sF = swapFee                                        ( 1 - eF )                            //\r\n    // eF = exitFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcPoolInGivenSingleOut(\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint tokenAmountOut,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint poolAmountIn)\r\n    {\r\n\r\n        // charge swap fee on the output token side\r\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\r\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\r\n        uint zoo = bsub(BONE, normalizedWeight);\r\n        uint zar = bmul(zoo, swapFee);\r\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\r\n\r\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\r\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\r\n\r\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\r\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\r\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\r\n        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\r\n\r\n        // charge exit fee on the pool token side\r\n        // pAi = pAiAfterExitFee/(1-exitFee)\r\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\r\n        return poolAmountIn;\r\n    }\r\n\r\n\r\n}\r\n\r\n// File: contracts/BPool.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.7.0;\r\n\r\n\r\n\r\ncontract BPool is BBronze, BToken, BMath {\r\n\r\n    struct Record {\r\n        bool bound;   // is token bound to pool\r\n        uint index;   // private\r\n        uint denorm;  // denormalized weight\r\n        uint balance;\r\n    }\r\n\r\n    event LOG_SWAP(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        address indexed tokenOut,\r\n        uint256         tokenAmountIn,\r\n        uint256         tokenAmountOut\r\n    );\r\n\r\n    event LOG_JOIN(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        uint256         tokenAmountIn\r\n    );\r\n\r\n    event LOG_EXIT(\r\n        address indexed caller,\r\n        address indexed tokenOut,\r\n        uint256         tokenAmountOut\r\n    );\r\n\r\n    event LOG_CALL(\r\n        bytes4  indexed sig,\r\n        address indexed caller,\r\n        bytes           data\r\n    ) anonymous;\r\n\r\n    modifier _logs_() {\r\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\r\n        _;\r\n    }\r\n\r\n    modifier _lock_() {\r\n        require(!_mutex, \"ERR_REENTRY\");\r\n        _mutex = true;\r\n        _;\r\n        _mutex = false;\r\n    }\r\n\r\n    modifier _viewlock_() {\r\n        require(!_mutex, \"ERR_REENTRY\");\r\n        _;\r\n    }\r\n\r\n    bool private _mutex;\r\n\r\n    address private _factory;    // BFactory address to push token exitFee to\r\n    address private _controller; // has CONTROL role\r\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\r\n\r\n    // `setSwapFee` and `finalize` require CONTROL\r\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\r\n    uint private _swapFee;\r\n    bool private _finalized;\r\n\r\n    address[] private _tokens;\r\n    mapping(address=>Record) private  _records;\r\n    uint private _totalWeight;\r\n\r\n    function initialize() public initializer {\r\n        _controller = msg.sender;\r\n        _factory = msg.sender;\r\n        _swapFee = MIN_FEE;\r\n        _publicSwap = false;\r\n        _finalized = false;\r\n        __BToken_init_unchained();\r\n    }\r\n\r\n    function isPublicSwap()\r\n        external view\r\n        returns (bool)\r\n    {\r\n        return _publicSwap;\r\n    }\r\n\r\n    function isFinalized()\r\n        external view\r\n        returns (bool)\r\n    {\r\n        return _finalized;\r\n    }\r\n\r\n    function isBound(address t)\r\n        external view\r\n        returns (bool)\r\n    {\r\n        return _records[t].bound;\r\n    }\r\n\r\n    function getNumTokens()\r\n        external view\r\n        returns (uint)\r\n    {\r\n        return _tokens.length;\r\n    }\r\n\r\n    function getCurrentTokens()\r\n        external view _viewlock_\r\n        returns (address[] memory tokens)\r\n    {\r\n        return _tokens;\r\n    }\r\n\r\n    function getFinalTokens()\r\n        external view\r\n        _viewlock_\r\n        returns (address[] memory tokens)\r\n    {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n        return _tokens;\r\n    }\r\n\r\n    function getDenormalizedWeight(address token)\r\n        external view\r\n        _viewlock_\r\n        returns (uint)\r\n    {\r\n\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        return _records[token].denorm;\r\n    }\r\n\r\n    function getTotalDenormalizedWeight()\r\n        external view\r\n        _viewlock_\r\n        returns (uint)\r\n    {\r\n        return _totalWeight;\r\n    }\r\n\r\n    function getNormalizedWeight(address token)\r\n        external view\r\n        _viewlock_\r\n        returns (uint)\r\n    {\r\n\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        uint denorm = _records[token].denorm;\r\n        return bdiv(denorm, _totalWeight);\r\n    }\r\n\r\n    function getBalance(address token)\r\n        external view\r\n        _viewlock_\r\n        returns (uint)\r\n    {\r\n\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        return _records[token].balance;\r\n    }\r\n\r\n    function getSwapFee()\r\n        external view\r\n        _viewlock_\r\n        returns (uint)\r\n    {\r\n        return _swapFee;\r\n    }\r\n\r\n    function getController()\r\n        external view\r\n        _viewlock_\r\n        returns (address)\r\n    {\r\n        return _controller;\r\n    }\r\n\r\n    function setSwapFee(uint swapFee)\r\n        external\r\n        _logs_\r\n        _lock_\r\n    {\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        require(swapFee >= MIN_FEE, \"ERR_MIN_FEE\");\r\n        require(swapFee <= MAX_FEE, \"ERR_MAX_FEE\");\r\n        _swapFee = swapFee;\r\n    }\r\n\r\n    function setController(address manager)\r\n        external\r\n        _logs_\r\n        _lock_\r\n    {\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        _controller = manager;\r\n    }\r\n\r\n    function setPublicSwap(bool public_)\r\n        external\r\n        _logs_\r\n        _lock_\r\n    {\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        _publicSwap = public_;\r\n    }\r\n\r\n    function finalize()\r\n        external\r\n        _logs_\r\n        _lock_\r\n    {\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n        require(_tokens.length >= MIN_BOUND_TOKENS, \"ERR_MIN_TOKENS\");\r\n\r\n        _finalized = true;\r\n        _publicSwap = true;\r\n\r\n        _mintPoolShare(INIT_POOL_SUPPLY);\r\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\r\n    }\r\n\r\n\r\n    function bind(address token, uint balance, uint denorm)\r\n        external\r\n        _logs_\r\n        // _lock_  Bind does not lock because it jumps to `rebind`, which does\r\n    {\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        require(!_records[token].bound, \"ERR_IS_BOUND\");\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n\r\n        require(_tokens.length < MAX_BOUND_TOKENS, \"ERR_MAX_TOKENS\");\r\n\r\n        _records[token] = Record({\r\n            bound: true,\r\n            index: _tokens.length,\r\n            denorm: 0,    // balance and denorm will be validated\r\n            balance: 0   // and set by `rebind`\r\n        });\r\n        _tokens.push(token);\r\n        rebind(token, balance, denorm);\r\n    }\r\n\r\n    function rebind(address token, uint balance, uint denorm)\r\n        public\r\n        _logs_\r\n        _lock_\r\n    {\r\n\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n\r\n        require(denorm >= MIN_WEIGHT, \"ERR_MIN_WEIGHT\");\r\n        require(denorm <= MAX_WEIGHT, \"ERR_MAX_WEIGHT\");\r\n        require(balance >= MIN_BALANCE, \"ERR_MIN_BALANCE\");\r\n\r\n        // Adjust the denorm and totalWeight\r\n        uint oldWeight = _records[token].denorm;\r\n        if (denorm > oldWeight) {\r\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\r\n            require(_totalWeight <= MAX_TOTAL_WEIGHT, \"ERR_MAX_TOTAL_WEIGHT\");\r\n        } else if (denorm < oldWeight) {\r\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\r\n        }\r\n        _records[token].denorm = denorm;\r\n\r\n        // Adjust the balance record and actual token balance\r\n        uint oldBalance = _records[token].balance;\r\n        _records[token].balance = balance;\r\n        if (balance > oldBalance) {\r\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\r\n        } else if (balance < oldBalance) {\r\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE\r\n            uint tokenBalanceWithdrawn = bsub(oldBalance, balance);\r\n            uint tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\r\n            _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\r\n            _pushUnderlying(token, _factory, tokenExitFee);\r\n        }\r\n    }\r\n\r\n    function unbind(address token)\r\n        external\r\n        _logs_\r\n        _lock_\r\n    {\r\n\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n\r\n        uint tokenBalance = _records[token].balance;\r\n        uint tokenExitFee = bmul(tokenBalance, EXIT_FEE);\r\n\r\n        _totalWeight = bsub(_totalWeight, _records[token].denorm);\r\n\r\n        // Swap the token-to-unbind with the last token,\r\n        // then delete the last token\r\n        uint index = _records[token].index;\r\n        uint last = _tokens.length - 1;\r\n        _tokens[index] = _tokens[last];\r\n        _records[_tokens[index]].index = index;\r\n        _tokens.pop();\r\n        _records[token] = Record({\r\n            bound: false,\r\n            index: 0,\r\n            denorm: 0,\r\n            balance: 0\r\n        });\r\n\r\n        _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));\r\n        _pushUnderlying(token, _factory, tokenExitFee);\r\n    }\r\n\r\n    // Absorb any tokens that have been sent to this contract into the pool\r\n    function gulp(address token)\r\n        external\r\n        _logs_\r\n        _lock_\r\n    {\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        _records[token].balance = IERC20(token).balanceOf(address(this));\r\n    }\r\n\r\n    function getSpotPrice(address tokenIn, address tokenOut)\r\n        external view\r\n        _viewlock_\r\n        returns (uint spotPrice)\r\n    {\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        Record storage inRecord = _records[tokenIn];\r\n        Record storage outRecord = _records[tokenOut];\r\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\r\n    }\r\n\r\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\r\n        external view\r\n        _viewlock_\r\n        returns (uint spotPrice)\r\n    {\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        Record storage inRecord = _records[tokenIn];\r\n        Record storage outRecord = _records[tokenOut];\r\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\r\n    }\r\n\r\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)\r\n        external\r\n        _logs_\r\n        _lock_\r\n    {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n\r\n        uint poolTotal = totalSupply();\r\n        uint ratio = bdiv(poolAmountOut, poolTotal);\r\n        require(ratio != 0, \"ERR_MATH_APPROX\");\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint bal = _records[t].balance;\r\n            uint tokenAmountIn = bmul(ratio, bal);\r\n            require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\r\n            require(tokenAmountIn <= maxAmountsIn[i], \"ERR_LIMIT_IN\");\r\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\r\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\r\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\r\n        }\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n    }\r\n\r\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\r\n        external\r\n        _logs_\r\n        _lock_\r\n    {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n\r\n        uint poolTotal = totalSupply();\r\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\r\n        uint pAiAfterExitFee = bsub(poolAmountIn, exitFee);\r\n        uint ratio = bdiv(pAiAfterExitFee, poolTotal);\r\n        require(ratio != 0, \"ERR_MATH_APPROX\");\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _pushPoolShare(_factory, exitFee);\r\n        _burnPoolShare(pAiAfterExitFee);\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint bal = _records[t].balance;\r\n            uint tokenAmountOut = bmul(ratio, bal);\r\n            require(tokenAmountOut != 0, \"ERR_MATH_APPROX\");\r\n            require(tokenAmountOut >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\r\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\r\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\r\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function swapExactAmountIn(\r\n        address tokenIn,\r\n        uint tokenAmountIn,\r\n        address tokenOut,\r\n        uint minAmountOut,\r\n        uint maxPrice\r\n    )\r\n        external\r\n        _logs_\r\n        _lock_\r\n        returns (uint tokenAmountOut, uint spotPriceAfter)\r\n    {\r\n\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\r\n\r\n        Record storage inRecord = _records[address(tokenIn)];\r\n        Record storage outRecord = _records[address(tokenOut)];\r\n\r\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\r\n\r\n        uint spotPriceBefore = calcSpotPrice(\r\n                                    inRecord.balance,\r\n                                    inRecord.denorm,\r\n                                    outRecord.balance,\r\n                                    outRecord.denorm,\r\n                                    _swapFee\r\n                                );\r\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\r\n\r\n        tokenAmountOut = calcOutGivenIn(\r\n                            inRecord.balance,\r\n                            inRecord.denorm,\r\n                            outRecord.balance,\r\n                            outRecord.denorm,\r\n                            tokenAmountIn,\r\n                            _swapFee\r\n                        );\r\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\r\n\r\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\r\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\r\n\r\n        spotPriceAfter = calcSpotPrice(\r\n                                inRecord.balance,\r\n                                inRecord.denorm,\r\n                                outRecord.balance,\r\n                                outRecord.denorm,\r\n                                _swapFee\r\n                            );\r\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\r\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\r\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\r\n\r\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\r\n\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return (tokenAmountOut, spotPriceAfter);\r\n    }\r\n\r\n    function swapExactAmountOut(\r\n        address tokenIn,\r\n        uint maxAmountIn,\r\n        address tokenOut,\r\n        uint tokenAmountOut,\r\n        uint maxPrice\r\n    )\r\n        external\r\n        _logs_\r\n        _lock_\r\n        returns (uint tokenAmountIn, uint spotPriceAfter)\r\n    {\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\r\n\r\n        Record storage inRecord = _records[address(tokenIn)];\r\n        Record storage outRecord = _records[address(tokenOut)];\r\n\r\n        require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\r\n\r\n        uint spotPriceBefore = calcSpotPrice(\r\n                                    inRecord.balance,\r\n                                    inRecord.denorm,\r\n                                    outRecord.balance,\r\n                                    outRecord.denorm,\r\n                                    _swapFee\r\n                                );\r\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\r\n\r\n        tokenAmountIn = calcInGivenOut(\r\n                            inRecord.balance,\r\n                            inRecord.denorm,\r\n                            outRecord.balance,\r\n                            outRecord.denorm,\r\n                            tokenAmountOut,\r\n                            _swapFee\r\n                        );\r\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\r\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\r\n\r\n        spotPriceAfter = calcSpotPrice(\r\n                                inRecord.balance,\r\n                                inRecord.denorm,\r\n                                outRecord.balance,\r\n                                outRecord.denorm,\r\n                                _swapFee\r\n                            );\r\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\r\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\r\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\r\n\r\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\r\n\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return (tokenAmountIn, spotPriceAfter);\r\n    }\r\n\r\n\r\n    function joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\r\n        external\r\n        _logs_\r\n        _lock_\r\n        returns (uint poolAmountOut)\r\n\r\n    {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\r\n\r\n        Record storage inRecord = _records[tokenIn];\r\n\r\n        poolAmountOut = calcPoolOutGivenSingleIn(\r\n                            inRecord.balance,\r\n                            inRecord.denorm,\r\n                            _totalSupply,\r\n                            _totalWeight,\r\n                            tokenAmountIn,\r\n                            _swapFee\r\n                        );\r\n\r\n        require(poolAmountOut >= minPoolAmountOut, \"ERR_LIMIT_OUT\");\r\n\r\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\r\n\r\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\r\n\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n\r\n        return poolAmountOut;\r\n    }\r\n\r\n    function joinswapPoolAmountOut(address tokenIn, uint poolAmountOut, uint maxAmountIn)\r\n        external\r\n        _logs_\r\n        _lock_\r\n        returns (uint tokenAmountIn)\r\n    {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n\r\n        Record storage inRecord = _records[tokenIn];\r\n\r\n        tokenAmountIn = calcSingleInGivenPoolOut(\r\n                            inRecord.balance,\r\n                            inRecord.denorm,\r\n                            _totalSupply,\r\n                            _totalWeight,\r\n                            poolAmountOut,\r\n                            _swapFee\r\n                        );\r\n\r\n        require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\r\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\r\n\r\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\r\n\r\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\r\n\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut)\r\n        external\r\n        _logs_\r\n        _lock_\r\n        returns (uint tokenAmountOut)\r\n    {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n\r\n        Record storage outRecord = _records[tokenOut];\r\n\r\n        tokenAmountOut = calcSingleOutGivenPoolIn(\r\n                            outRecord.balance,\r\n                            outRecord.denorm,\r\n                            _totalSupply,\r\n                            _totalWeight,\r\n                            poolAmountIn,\r\n                            _swapFee\r\n                        );\r\n\r\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\r\n\r\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\r\n\r\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\r\n\r\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\r\n\r\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\r\n        _pushPoolShare(_factory, exitFee);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    function exitswapExternAmountOut(address tokenOut, uint tokenAmountOut, uint maxPoolAmountIn)\r\n        external\r\n        _logs_\r\n        _lock_\r\n        returns (uint poolAmountIn)\r\n    {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\r\n\r\n        Record storage outRecord = _records[tokenOut];\r\n\r\n        poolAmountIn = calcPoolInGivenSingleOut(\r\n                            outRecord.balance,\r\n                            outRecord.denorm,\r\n                            _totalSupply,\r\n                            _totalWeight,\r\n                            tokenAmountOut,\r\n                            _swapFee\r\n                        );\r\n\r\n        require(poolAmountIn != 0, \"ERR_MATH_APPROX\");\r\n        require(poolAmountIn <= maxPoolAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\r\n\r\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\r\n\r\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\r\n        _pushPoolShare(_factory, exitFee);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return poolAmountIn;\r\n    }\r\n\r\n\r\n    // ==\r\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\r\n    // You must `_lock_` or otherwise ensure reentry-safety\r\n\r\n    function _pullUnderlying(address erc20, address from, uint amount)\r\n        internal\r\n    {\r\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n    }\r\n\r\n    function _pushUnderlying(address erc20, address to, uint amount)\r\n        internal\r\n    {\r\n        bool xfer = IERC20(erc20).transfer(to, amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n    }\r\n\r\n    function _pullPoolShare(address from, uint amount)\r\n        internal\r\n    {\r\n        _pull(from, amount);\r\n    }\r\n\r\n    function _pushPoolShare(address to, uint amount)\r\n        internal\r\n    {\r\n        _push(to, amount);\r\n    }\r\n\r\n    function _mintPoolShare(uint amount)\r\n        internal\r\n    {\r\n        _mint(amount);\r\n    }\r\n\r\n    function _burnPoolShare(uint amount)\r\n        internal\r\n    {\r\n        _burn(amount);\r\n    }\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LOG_CALL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"LOG_JOIN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_SWAP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BPOW_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXIT_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INIT_POOL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TOTAL_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denorm\",\"type\":\"uint256\"}],\"name\":\"bind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcInGivenOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcOutGivenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcPoolInGivenSingleOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcPoolOutGivenSingleIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSingleInGivenPoolOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSingleOutGivenPoolIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPoolAmountIn\",\"type\":\"uint256\"}],\"name\":\"exitswapExternAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"exitswapPoolAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getColor\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFinalTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getNormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPriceSansFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"gulp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"isBound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPublicSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPoolAmountOut\",\"type\":\"uint256\"}],\"name\":\"joinswapExternAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"}],\"name\":\"joinswapPoolAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denorm\",\"type\":\"uint256\"}],\"name\":\"rebind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"public_\",\"type\":\"bool\"}],\"name\":\"setPublicSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unbind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BPool","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a1a905095ed3c482eae5bc18bd5efccda7806fc764713863fbf0b67378698229"}]}