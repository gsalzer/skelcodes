{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/GenesisSale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: NO-LICENSE\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./utils/Context.sol\\\";\\nimport \\\"./security/ReentrancyGuard.sol\\\";\\nimport \\\"./interfaces/IGenesisSale.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IWhitelist.sol\\\";\\nimport \\\"./interfaces/AggregatorV3Interface.sol\\\";\\n\\n/**\\n * Implementation of the {IGenesisSale} Interface.\\n *\\n * Used for the sale of EDGEX tokens at a constant price\\n * with a lock tenure of 365 days.\\n *\\n * 2 Level Governance Model with admin and governor previlages.\\n *\\n * Token Price is stored as 8 precision variables.\\n */\\n\\ncontract GenesisSale is ReentrancyGuard, Context, IGenesisSale {\\n    mapping(address => uint256) public allocated;\\n    mapping(address => uint256) public purchases;\\n    mapping(address => mapping(uint256 => Purchase)) public purchase;\\n    mapping(uint8 => uint256) public poolCap;\\n    mapping(uint8 => uint256) public poolSold;\\n    mapping(uint8 => uint256) public poolLock;\\n    mapping(address => uint256) public balanceOf;\\n\\n    address public organisation;\\n    address payable public ethWallet;\\n    address public governor;\\n    address public admin;\\n\\n    address public edgexContract;\\n    address public ethPriceSource;\\n    address public whitelistOracle;\\n\\n    uint256 public presalePrice;\\n\\n    uint256 public maxCap;\\n    uint256 public minCap;\\n\\n    /**\\n     * @dev stores the sale history as individual structs.\\n     *\\n     * Mapped to an account with individual identifier.\\n     */\\n    struct Purchase {\\n        uint256 time;\\n        uint256 amount;\\n        uint256 price;\\n        uint256 lock;\\n        uint8 method;\\n        bool isSettled;\\n    }\\n\\n    /**\\n     * @dev Emitted when there is a purchase of EDGEX tokens.\\n     *\\n     * Can be used for storing off-chain history events.\\n     */\\n    event PurchaseEvent(address indexed to, uint256 amount);\\n\\n    /**\\n     * @dev Emitted when the governor role state changes.\\n     *\\n     * Based on the event we can predict the role of governor.\\n     */\\n    event UpdateGovernor(address indexed _governor);\\n\\n    /**\\n     * @dev Emittee when the ownership of the contract changes.\\n     */\\n    event RevokeOwnership(address indexed _newOwner);\\n\\n    /**\\n     * @dev Emitted when the pool parameters changes.\\n     */\\n    event PoolCapChange(uint256 newCap, uint8 poolId);\\n\\n    /**\\n     * @dev Emitted when the pool lock duration changes.\\n     */\\n    event PoolLockChange(uint256 lockTime, uint8 poolId);\\n\\n    /**\\n     * @dev sets the initial params.\\n     *\\n     * {_ethWallet} - Address to which the funds are directed to.\\n     * {_organisation} - Address to which % of sale tokens are sent to.\\n     * {_governor} - Address to be configured in the server for off-chain settlement.\\n     * {_admin} - Owner of this contract.\\n     * {_ethSource} - Chainlink ETH/USD price source.\\n     * {_whitelistOracle} - Oracle to fetch whitelisting info from.\\n     * {_edgexContract} - Address of the EDGEX token.\\n     * {_presalePrice} - Price of Each EDGEX token (8 precision).\\n     */\\n    constructor(\\n        address _ethWallet,\\n        address _organisation,\\n        address _governor,\\n        address _admin,\\n        address _ethSource,\\n        address _whitelistOracle,\\n        address _edgexContract,\\n        uint256 _presalePrice\\n    ) {\\n        organisation = _organisation;\\n        ethWallet = payable(_ethWallet);\\n        governor = _governor;\\n        whitelistOracle = _whitelistOracle;\\n        admin = _admin;\\n        edgexContract = _edgexContract;\\n        ethPriceSource = _ethSource;\\n        presalePrice = _presalePrice;\\n    }\\n\\n    /**\\n     * @dev sanity checks the caller.\\n     * If the caller is not admin, the transaction is reverted.\\n     *\\n     * keeps the security of the platform and prevents bad actors\\n     * from executing sensitive functions / state changes.\\n     */\\n    modifier onlyAdmin() {\\n        require(_msgSender() == admin, \\\"Error: caller not admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev sanity checks the caller.\\n     * If the caller is not governor, the transaction is reverted.\\n     *\\n     * keeps the security of the platform and prevents bad actors\\n     * from executing sensitive functions / state changes.\\n     */\\n    modifier onlyGovernor() {\\n        require(_msgSender() == governor, \\\"Error: caller not Governor\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev checks whether the address is a valid one.\\n     *\\n     * If it's a zero address returns an error.\\n     */\\n    modifier isZero(address _address) {\\n        require(_address != address(0), \\\"Error: zero address\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev checks whether the `_user` is whitelisted and verified his KYC.\\n     *\\n     * Requirements:\\n     * `_user` cannot be a zero address,\\n     *\\n     * Proxies calls to the whitelist contract address.\\n     */\\n    function isWhitelisted(address _user) public view virtual returns (bool) {\\n        require(_user != address(0), \\\"Error: zero address cannot buy\\\");\\n        return IWhiteList(whitelistOracle).whitelisted(_user);\\n    }\\n\\n    /**\\n     * @dev sends in `eth` in the transaction as `value`\\n     *\\n     * The function calculates the price of the ETH send\\n     * in value to equivalent amount in USD using chainlink\\n     * oracle and transfer the equivalent amount of tokens back to the user.\\n     *\\n     * Requirements:\\n     * `_reciever` address has to be whitelisted.\\n     */\\n    function buyEdgex(address _reciever, uint8 poolId)\\n        public\\n        payable\\n        virtual\\n        override\\n        nonReentrant\\n        returns (bool)\\n    {\\n        uint256 tokens = calculate(msg.value);\\n\\n        require(tokens >= minCap, \\\"Error: amount less than minimum\\\");\\n        require(tokens <= maxCap, \\\"Error: amount greater than maximum\\\");\\n\\n        require(poolCap[poolId] >= poolSold[poolId] + tokens, \\\"Error: pool cap reached\\\");\\n        require(    \\n            isWhitelisted(_reciever),\\n            \\\"Error: account not elligible to puchase\\\"\\n        );\\n\\n        purchases[_reciever] += 1;\\n        balanceOf[_reciever] += tokens;\\n\\n        Purchase storage p = purchase[_reciever][purchases[_reciever]];\\n        p.time = block.timestamp;\\n        p.lock = poolLock[poolId];\\n        p.method = 1;\\n        p.price = presalePrice;\\n        p.amount = tokens;\\n\\n        poolSold[poolId] += tokens;\\n\\n        ethWallet.transfer(msg.value);\\n    \\n        emit PurchaseEvent(_reciever, tokens);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev returns the amount of EDGEX tokens\\n     * for the input eth value.\\n     *\\n     * EDGEX tokens are returned in 18-decimal precision.\\n     */\\n\\n    function calculate(uint256 _amount) private view returns (uint256) {\\n        require(_amount > 0, \\\"Error: amount should not be zero\\\");\\n        uint256 value = uint256(fetchEthPrice());\\n        value = _amount * value;\\n        uint256 tokens = value / presalePrice;\\n        return tokens;\\n    }\\n\\n    function allocate(\\n        uint256 _tokens,\\n        address _user,\\n        uint8 _method,\\n        uint8 _poolId\\n    ) public virtual override onlyGovernor nonReentrant returns (bool) {\\n        require(_tokens >= minCap, \\\"Error: amount less than minimum\\\");\\n        require(_tokens <= maxCap, \\\"Error: amount greater than maximum\\\");\\n\\n        require(\\n            isWhitelisted(_user),\\n            \\\"Error: account not elligible to puchase\\\"\\n        );\\n\\n        require(\\n            poolCap[_poolId] >= poolSold[_poolId] + _tokens, \\n            \\\"Error: pool cap reached\\\"\\n        );\\n\\n        purchases[_user] += 1;\\n        balanceOf[_user] += _tokens;\\n\\n        Purchase storage p = purchase[_user][purchases[_user]];\\n        p.time = block.timestamp;\\n        p.lock = poolLock[_poolId];\\n        p.method = _method;\\n        p.price = presalePrice;\\n        p.amount = _tokens;\\n\\n        poolSold[_poolId] += _tokens;\\n\\n        emit PurchaseEvent(_user, _tokens);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev transfers the edgex tokens to the user's wallet after the\\n     * 365-day lock time.\\n     *\\n     * Requirements:\\n     * `caller` shoul have a valid token balance > 0;\\n     */\\n    function claim(uint256 _purchaseId)\\n        public\\n        virtual\\n        override\\n        nonReentrant\\n        returns (bool)\\n    {\\n        Purchase storage p = purchase[_msgSender()][_purchaseId];\\n        uint256 lockedTill = p.lock;\\n        uint256 orgAmount = p.amount / 100;\\n        balanceOf[_msgSender()] -= p.amount;\\n\\n        require(!p.isSettled, \\\"Error: amount already claimed\\\");\\n        require(block.timestamp >= lockedTill, \\\"Error: lock time till not yet reached\\\");\\n\\n        p.isSettled = true;\\n        bool status = IERC20(edgexContract).transfer(_msgSender(), p.amount);\\n        bool status2 = IERC20(edgexContract).transfer(organisation, orgAmount);\\n\\n        return (status && status2);\\n    }\\n\\n    /**\\n     * @dev transfer the control of genesis sale to another account.\\n     *\\n     * Onwers can add governors.\\n     *\\n     * Requirements:\\n     * `_newOwner` cannot be a zero address.\\n     *\\n     * CAUTION: EXECUTE THIS FUNCTION WITH CARE.\\n     */\\n\\n    function revokeOwnership(address _newOwner)\\n        public\\n        virtual\\n        override\\n        onlyAdmin\\n        isZero(_newOwner)\\n        returns (bool)\\n    {\\n        admin = payable(_newOwner);\\n        emit RevokeOwnership(_newOwner);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev fetches the price of Ethereum from chainlink oracle\\n     *\\n     * Real-time onchain price is fetched.\\n     */\\n\\n    function fetchEthPrice() public view virtual returns (int256) {\\n        (, int256 price, , , ) =\\n            AggregatorV3Interface(ethPriceSource).latestRoundData();\\n        return price;\\n    }\\n\\n    /**\\n     * @dev can change the minimum and maximum purchase value of edgex tokens\\n     * per transaction.\\n     *\\n     * Requirements:\\n     * `_maxCap` can never be zero.\\n     *\\n     * `caller` should have governor role.\\n     */\\n    function updateCap(uint256 _minCap, uint256 _maxCap)\\n        public\\n        virtual\\n        override\\n        onlyGovernor\\n        returns (bool)\\n    {\\n        // solhint-ig\\n        require(_maxCap > 0, \\\"Error: maximum amount cannot be zero\\\");\\n        maxCap = _maxCap;\\n        minCap = _minCap;\\n        return false;\\n    }\\n\\n    /**\\n     * @dev add an account with governor level previlages.\\n     *\\n     * Requirements:\\n     * `caller` should have admin role.\\n     * `_newGovernor` should not be a zero wallet.\\n     */\\n    function updateGovernor(address _newGovernor)\\n        public\\n        virtual\\n        override\\n        onlyGovernor\\n        isZero(_newGovernor)\\n        returns (bool)\\n    {\\n        governor = _newGovernor;\\n\\n        emit UpdateGovernor(_newGovernor);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev can change the contract address of EDGEX tokens.\\n     *\\n     * Requirements:\\n     * `_contract` cannot be a zero address.\\n     */\\n    function updateContract(address _contract)\\n        public\\n        virtual\\n        override\\n        onlyAdmin\\n        isZero(_contract)\\n        returns (bool)\\n    {\\n        edgexContract = _contract;\\n        return true;\\n    }\\n\\n    /**\\n     * @dev can change the Chainlink ETH Source.\\n     *\\n     * Requirements:\\n     * `_ethSource` cannot be a zero address.\\n     */\\n    function updateEthSource(address _ethSource)\\n        public\\n        virtual\\n        override\\n        onlyAdmin\\n        isZero(_ethSource)\\n        returns (bool)\\n    {\\n        ethPriceSource = _ethSource;\\n        return true;\\n    }\\n\\n    /**\\n     * @dev can change the address to which all paybale ethers are sent to.\\n     *\\n     * Requirements:\\n     * `_caller` should be admin.\\n     * `_newEthSource` cannot be a zero address.\\n     */\\n    function updateEthWallet(address _newEthWallet)\\n        public\\n        virtual\\n        override\\n        onlyAdmin\\n        isZero(_newEthWallet)\\n        returns (bool)\\n    {\\n        ethWallet = payable(_newEthWallet);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev can change the address to which a part of sold tokens are paid to.\\n     *\\n     * Requirements:\\n     * `_caller` should be admin.\\n     * `_newOrgWallet` cannot be a zero address.\\n     */\\n    function updateOrgWallet(address _newOrgWallet)\\n        public\\n        virtual\\n        override\\n        onlyAdmin\\n        isZero(_newOrgWallet)\\n        returns (bool)\\n    {\\n        organisation = _newOrgWallet;\\n        return true;\\n    }\\n\\n    /**\\n     * @dev can update the locktime for each poolId in number of days.\\n     *\\n     * Requirements:\\n     * `caller` should be admin.\\n     * `poolId` should be a valid one\\n     */\\n    function updatePoolLock(uint8 poolId, uint256 lockDays)\\n       public\\n       virtual\\n       override\\n       onlyAdmin\\n       returns (bool)\\n    {\\n       require(lockDays > 0, \\\"Error: lock days cannot be zero\\\");\\n       poolLock[poolId] = lockDays * 1 days;\\n\\n       emit PoolLockChange(lockDays, poolId);\\n       return true;\\n    }\\n\\n    /**\\n     * @dev can update the cap for each poolId in number of edgex tokens.\\n     *\\n     * Requirements:\\n     * `caller` should be admin.\\n     * `poolId` should be a valid one\\n     */\\n    function updatePoolCap(uint8 poolId, uint256 _poolCap)\\n        public \\n        virtual \\n        override\\n        onlyAdmin\\n        returns (bool) \\n    {\\n        require(_poolCap > 0, \\\"Error: cap cannot be zero\\\");\\n        poolCap[poolId] = _poolCap;\\n\\n        emit PoolCapChange(_poolCap, poolId);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev can allows admin to take out the unsold tokens from the smart contract.\\n     *\\n     * Requirements:\\n     * `_caller` should be admin.\\n     * `_to` cannot be a zero address.\\n     * `_amount` should be less than the current EDGEX token balance.\\n     *\\n     * Prevents the tokens from getting locked within the smart contract.\\n     */\\n    function drain(address _to, uint256 _amount)\\n        public\\n        virtual\\n        override\\n        onlyAdmin\\n        isZero(_to)\\n        returns (bool)\\n    {\\n        return IERC20(edgexContract).transfer(_to, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: NO-LICENSE\\n\\npragma solidity ^0.8.4;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this;\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: NO-LICENSE\\n\\npragma solidity ^0.8.4;\\n\\nabstract contract ReentrancyGuard {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrant() {\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        _status = _ENTERED;\\n        _;\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGenesisSale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: NO-LICENSE\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of the Genesis Sale Smart Contract.\\n *\\n * Selling EDGEX tokens at a fixed price\\n * with a 365-day lock period.\\n */\\n\\ninterface IGenesisSale {\\n    /**\\n     * @dev sends in `eth` in the transaction as `value`\\n     *\\n     * The function calculates the price of the ETH send\\n     * in value to equivalent amount in USD using chainlink\\n     * oracle and transfer the equivalent amount of tokens back to the user.\\n     *\\n     * Requirements:\\n     * `_reciever` address has to be whitelisted.\\n     */\\n    function buyEdgex(address _reciever, uint8 poolId) external payable returns (bool);\\n\\n    /**\\n     * @dev allocate the amount of tokens (`EDGEX`) to a specific account.\\n     *\\n     * Requirements:\\n     * `caller` should have governor role previlages.\\n     * `_user` should've to be whitelisted.\\n     *\\n     * Used for off-chain purchases with on-chain settlements.\\n     */\\n    function allocate(\\n        uint256 _tokens,\\n        address _user,\\n        uint8 _method,\\n        uint8 poolId\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev transfer the control of genesis sale to another account.\\n     *\\n     * Onwers can add governors.\\n     *\\n     * Requirements:\\n     * `_newOwner` cannot be a zero address.\\n     *\\n     * CAUTION: EXECUTE THIS FUNCTION WITH CARE.\\n     */\\n    function revokeOwnership(address _newOwner) external returns (bool);\\n\\n    /**\\n     * @dev transfers the edgex tokens to the user's wallet after the\\n     * 365-day lock time.\\n     *\\n     * Requirements:\\n     * `caller` should have a valid token balance > 0;\\n     * `_purchaseId` should be valid.\\n     */\\n    function claim(uint256 _purchaseId) external returns (bool);\\n\\n    /**\\n     * @dev can change the minimum and maximum purchase value of edgex tokens\\n     * per transaction.\\n     *\\n     * Requirements:\\n     *  `_maxCap` can never be zero.\\n     *\\n     * `caller` should have governor role.\\n     */\\n    function updateCap(uint256 _minCap, uint256 _maxCap)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev add an account with governor level previlages.\\n     *\\n     * Requirements:\\n     * `caller` should have admin role.\\n     * `_newGovernor` should not be a zero wallet.\\n     */\\n    function updateGovernor(address _newGovernor) external returns (bool);\\n\\n    /**\\n     * @dev can change the contract address of EDGEX tokens.\\n     *\\n     * Requirements:\\n     * `_contract` cannot be a zero address.\\n     */\\n    function updateContract(address _contract) external returns (bool);\\n\\n    /**\\n     * @dev can change the Chainlink ETH Source.\\n     *\\n     * Requirements:\\n     * `_ethSource` cannot be a zero address.\\n     */\\n    function updateEthSource(address _ethSource) external returns (bool);\\n\\n    /**\\n     * @dev can change the address to which all paybale ethers are sent to.\\n     *\\n     * Requirements:\\n     * `_caller` should be admin.\\n     * `_newEthSource` cannot be a zero address.\\n     */\\n    function updateEthWallet(address _newEthWallet) external returns (bool);\\n\\n    /**\\n     * @dev can change the address to which a part of sold tokens are paid to.\\n     *\\n     * Requirements:\\n     * `_caller` should be admin.\\n     * `_newOrgWallet` cannot be a zero address.\\n     */\\n    function updateOrgWallet(address _newOrgWallet) external returns (bool);\\n\\n    /**\\n     * @dev can update the locktime for each poolId in number of days.\\n     *\\n     * Requirements:\\n     * `caller` should be admin.\\n     * `poolId` should be a valid one\\n     */\\n    function updatePoolLock(uint8 poolId, uint256 lockDays) external returns (bool);\\n\\n    /**\\n     * @dev can update the cap for each poolId in number of edgex tokens.\\n     *\\n     * Requirements:\\n     * `caller` should be admin.\\n     * `poolId` should be a valid one\\n     */\\n    function updatePoolCap(uint8 poolId, uint256 poolCap) external returns (bool);\\n\\n    /**\\n     * @dev can allows admin to take out the unsold tokens from the smart contract.\\n     *\\n     * Requirements:\\n     * `_caller` should be admin.\\n     * `_to` cannot be a zero address.\\n     * `_amount` should be less than the current EDGEX token balance.\\n     *\\n     * Prevents the tokens from getting locked within the smart contract.\\n     */\\n    function drain(address _to, uint256 _amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: NO-LICENSE\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev interface of Whitelist Contract.\\n */\\n\\ninterface IWhiteList {\\n    /**\\n     * @dev whitelist the `_user` for purchase.\\n     *\\n     * Requirements:\\n     * `_user` should not be a zero address.\\n     * `_user` should not be already whitelisted.\\n     *\\n     * returns a bool to represent the status of the transaction.\\n     */\\n    function whitelist(address _user) external returns (bool);\\n\\n    /**\\n     * @dev blacklists the `user` from sale.\\n     *\\n     * Requirements:\\n     * `_user` should be whitelisted before.\\n     * `_user` cannot be a zero address.\\n     *\\n     * returns a bool to represent the status of the transaction.\\n     */\\n    function blacklist(address _user) external returns (bool);\\n\\n    /**\\n     * @dev transfers the control of whitelisting to another wallet.\\n     *\\n     * Requirements:\\n     * `_newGovernor` should not be a zero address.\\n     * `caller` should be the current governor.\\n     *\\n     * returns a bool to represent the status of the transaction.\\n     */\\n    function transferGovernor(address _newGovernor) external returns (bool);\\n\\n    /**\\n     * @dev returns a bool to represent the whitelisting status of a wallet.\\n     *\\n     * true - address is whitelisted and can purchase tokens.\\n     * false - prevented from sale.\\n     */\\n    function whitelisted(address _user) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: NO-LICENSE\\n\\npragma solidity ^0.8.4;\\n\\ninterface AggregatorV3Interface {\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint256);\\n\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ethWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_organisation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ethSource\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whitelistOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_edgexContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_presalePrice\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"poolId\",\"type\":\"uint8\"}],\"name\":\"PoolCapChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"poolId\",\"type\":\"uint8\"}],\"name\":\"PoolLockChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PurchaseEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"RevokeOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"}],\"name\":\"UpdateGovernor\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_method\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_poolId\",\"type\":\"uint8\"}],\"name\":\"allocate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allocated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reciever\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"poolId\",\"type\":\"uint8\"}],\"name\":\"buyEdgex\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_purchaseId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"drain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"edgexContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethPriceSource\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchEthPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"organisation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"poolCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"poolLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"poolSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presalePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lock\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"method\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isSettled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"purchases\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"revokeOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxCap\",\"type\":\"uint256\"}],\"name\":\"updateCap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"updateContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ethSource\",\"type\":\"address\"}],\"name\":\"updateEthSource\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newEthWallet\",\"type\":\"address\"}],\"name\":\"updateEthWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernor\",\"type\":\"address\"}],\"name\":\"updateGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOrgWallet\",\"type\":\"address\"}],\"name\":\"updateOrgWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"poolId\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_poolCap\",\"type\":\"uint256\"}],\"name\":\"updatePoolCap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"poolId\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"lockDays\",\"type\":\"uint256\"}],\"name\":\"updatePoolLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GenesisSale","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000080ca65b74d1b9fad4ff796565d78ca1da558d1930000000000000000000000003d749c4be39a38658e36719925b6a791f5dee9df000000000000000000000000cd57634625e89af44ae43222f823fb62efcd098e000000000000000000000000bfe109a573722ca13758798cd3752982f40a44dc0000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b84190000000000000000000000007adbe9c5dc7165c1418b3a6b91adc30b947b0839000000000000000000000000d61f493d18ed4c5aad0b2763d9a9b421c8da006a0000000000000000000000000000000000000000000000000000000000989680","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}