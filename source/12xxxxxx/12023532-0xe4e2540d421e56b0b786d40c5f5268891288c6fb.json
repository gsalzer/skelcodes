{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n// Version 11-Mar-2021\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.1.0\r\n// License-Identifier: MIT\r\n\r\n/// @notice A library for performing overflow-/underflow-safe math,\r\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\r\nlibrary BoringMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\r\n    }\r\n}\r\n\r\n// File @sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol@v1.4.2\r\n// License-Identifier: GPL-3.0\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\n// File @sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol@v1.4.2\r\n// License-Identifier: GPL-3.0\r\ninterface IUniswapV2Pair {\r\n    function token0() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.1.0\r\n// License-Identifier: MIT\r\ninterface IERC20 {\r\n\r\n}\r\n\r\n// File @sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol@v1.0.0\r\n// License-Identifier: MIT\r\ninterface IBentoBoxV1 {\r\n    function deposit(\r\n        IERC20 token_,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\r\n\r\n    function toAmount(\r\n        IERC20 token,\r\n        uint256 share,\r\n        bool roundUp\r\n    ) external view returns (uint256 amount);\r\n\r\n    function toShare(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        bool roundUp\r\n    ) external view returns (uint256 share);\r\n\r\n    function transfer(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 share\r\n    ) external;\r\n\r\n    function withdraw(\r\n        IERC20 token_,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256 amountOut, uint256 shareOut);\r\n}\r\n\r\n// File contracts/swappers/SushiSwapSwapper.sol\r\n// License-Identifier: MIT\r\ncontract SushiSwapSwapperV1 {\r\n    using BoringMath for uint256;\r\n\r\n    // Local variables\r\n    IBentoBoxV1 public immutable bentoBox;\r\n    IUniswapV2Factory public immutable factory;\r\n    bytes32 public pairCodeHash;\r\n\r\n    constructor(\r\n        IBentoBoxV1 bentoBox_,\r\n        IUniswapV2Factory factory_,\r\n        bytes32 pairCodeHash_\r\n    ) public {\r\n        bentoBox = bentoBox_;\r\n        factory = factory_;\r\n        pairCodeHash = pairCodeHash_;\r\n    }\r\n\r\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountOut) {\r\n        uint256 amountInWithFee = amountIn.mul(997);\r\n        uint256 numerator = amountInWithFee.mul(reserveOut);\r\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountIn) {\r\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // Swaps to a flexible amount, from an exact input amount\r\n    /// @notice Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\r\n    /// Swaps it for at least 'amountToMin' of token 'to'.\r\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\r\n    /// Returns the amount of tokens 'to' transferred to BentoBox.\r\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\r\n    function swap(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\r\n        (IERC20 token0, IERC20 token1) = fromToken < toToken ? (fromToken, toToken) : (toToken, fromToken);\r\n        IUniswapV2Pair pair =\r\n            IUniswapV2Pair(\r\n                uint256(\r\n                    keccak256(abi.encodePacked(hex\"ff\", factory, keccak256(abi.encodePacked(address(token0), address(token1))), pairCodeHash))\r\n                )\r\n            );\r\n\r\n        (uint256 amountFrom, ) = bentoBox.withdraw(fromToken, address(this), address(pair), 0, shareFrom);\r\n\r\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\r\n        uint256 amountTo;\r\n        if (toToken > fromToken) {\r\n            amountTo = getAmountOut(amountFrom, reserve0, reserve1);\r\n            pair.swap(0, amountTo, address(bentoBox), new bytes(0));\r\n        } else {\r\n            amountTo = getAmountOut(amountFrom, reserve1, reserve0);\r\n            pair.swap(amountTo, 0, address(bentoBox), new bytes(0));\r\n        }\r\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\r\n        extraShare = shareReturned.sub(shareToMin);\r\n    }\r\n\r\n    // Swaps to an exact amount, from a flexible input amount\r\n    /// @notice Calculates the amount of token 'from' needed to complete the swap (amountFrom),\r\n    /// this should be less than or equal to amountFromMax.\r\n    /// Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\r\n    /// Swaps it for exactly 'exactAmountTo' of token 'to'.\r\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\r\n    /// Transfers allocated, but unused 'from' tokens within the BentoBox to 'refundTo' (amountFromMax - amountFrom).\r\n    /// Returns the amount of 'from' tokens withdrawn from BentoBox (amountFrom).\r\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\r\n    function swapExact(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        address recipient,\r\n        address refundTo,\r\n        uint256 shareFromSupplied,\r\n        uint256 shareToExact\r\n    ) public returns (uint256 shareUsed, uint256 shareReturned) {\r\n        IUniswapV2Pair pair;\r\n        {\r\n            (IERC20 token0, IERC20 token1) = fromToken < toToken ? (fromToken, toToken) : (toToken, fromToken);\r\n            pair = IUniswapV2Pair(\r\n                uint256(\r\n                    keccak256(abi.encodePacked(hex\"ff\", factory, keccak256(abi.encodePacked(address(token0), address(token1))), pairCodeHash))\r\n                )\r\n            );\r\n        }\r\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\r\n\r\n        uint256 amountToExact = bentoBox.toAmount(toToken, shareToExact, true);\r\n\r\n        uint256 amountFrom;\r\n        if (toToken > fromToken) {\r\n            amountFrom = getAmountIn(amountToExact, reserve0, reserve1);\r\n            (, shareUsed) = bentoBox.withdraw(fromToken, address(this), address(pair), amountFrom, 0);\r\n            pair.swap(0, amountToExact, address(bentoBox), \"\");\r\n        } else {\r\n            amountFrom = getAmountIn(amountToExact, reserve1, reserve0);\r\n            (, shareUsed) = bentoBox.withdraw(fromToken, address(this), address(pair), amountFrom, 0);\r\n            pair.swap(amountToExact, 0, address(bentoBox), \"\");\r\n        }\r\n        bentoBox.deposit(toToken, address(bentoBox), recipient, 0, shareToExact);\r\n        shareReturned = shareFromSupplied.sub(shareUsed);\r\n        if (shareReturned > 0) {\r\n            bentoBox.transfer(fromToken, address(this), refundTo, shareReturned);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IBentoBoxV1\",\"name\":\"bentoBox_\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"factory_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"pairCodeHash_\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"bentoBox\",\"outputs\":[{\"internalType\":\"contract IBentoBoxV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairCodeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shareToMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shareFrom\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"extraShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shareReturned\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refundTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shareFromSupplied\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shareToExact\",\"type\":\"uint256\"}],\"name\":\"swapExact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shareUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shareReturned\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SushiSwapSwapperV1","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"50000","ConstructorArguments":"000000000000000000000000b5891167796722331b7ea7824f036b3bdcb4531c000000000000000000000000c0aee478e3658e2610c5f7a4a2e1777ce9e4f2ace18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://53020d6b80f5fe4245d0a6c711ccae2d8b0daa7678f89b2d92c468977708e796"}]}