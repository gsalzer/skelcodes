{"status":"1","message":"OK","result":[{"SourceCode":"/* Projekt Green, by The Fair Token Project\r\n * 100% LP Lock\r\n * 0% burn\r\n * Projekt Telegram: t.me/projektgreen\r\n * FTP Telegram: t.me/fairtokenproject\r\n */ \r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nabstract contract Context {\r\n    function _mS() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _o;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = _mS();\r\n        _o = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function o() public view returns (address) {\r\n        return _o;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_o == _mS(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n}  \r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n}\r\n\r\ncontract ProjektGreen is Context, IERC20, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private _oR;\r\n    mapping (address => uint256) private _q;\r\n    mapping (address => uint256) private _p;\r\n    mapping (address => mapping (address => uint256)) private _aT;\r\n    mapping (address => bool) private _xF;\r\n    uint256 private constant Q = ~uint256(0);\r\n    uint256 private constant _T = 100000000000000 * 10**9;\r\n    uint256 private _R = (Q - (Q % _T));\r\n    uint256 private _xA;\r\n    \r\n    string private _name = unicode\"Projekt Green ðŸŸ¢ðŸ’µðŸ’µ\";\r\n    string private _symbol = 'GREEN';\r\n    uint8 private _decimals = 9;\r\n    uint8 private _d = 4;\r\n    uint256 private _c = 0;\r\n    \r\n    uint256 private _tQ;\r\n    uint256 private _t;\r\n    address payable private _f;\r\n    IUniswapV2Router02 private uR;\r\n    address private uP;\r\n    bool private tO;\r\n    bool private iS = false;\r\n    bool private sE = false;\r\n    uint256 private m  = 500000000000 * 10**9;\r\n    uint256 private sM  = m;\r\n    uint256 private xM = sM.mul(4);\r\n    event nM(uint m);\r\n    modifier lS {\r\n        iS = true;\r\n        _;\r\n        iS = false;\r\n    }\r\n    constructor () {\r\n        _oR[address(this)] = _R;\r\n        _xF[o()] = true;\r\n        _xF[address(this)] = true;\r\n        emit Transfer(address(0), address(this), _T);\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure override returns (uint256) {\r\n        return _T;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _tB(_oR[account]);\r\n    }\r\n    \r\n    function banCount() external view returns (uint256){\r\n        return _c;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _xT(_mS(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _aT[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_mS(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _xT(sender, recipient, amount);\r\n        _approve(sender, _mS(), _aT[sender][_mS()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _aT[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    \r\n    function _tB(uint256 a) private view returns(uint256) {\r\n        require(a <= _R, \"Amount must be less than total reflections\");\r\n        uint256 b =  _gR();\r\n        return a.div(b);\r\n    }\r\n    \r\n    function _fX(address payable a) external onlyOwner() {\r\n        _f = a;    \r\n        _xF[a] = true;\r\n    }\r\n\r\n    function _xT(address f, address t, uint256 a) private {\r\n        require(f != address(0), \"ERC20: transfer from the zero address\");\r\n        require(t != address(0), \"ERC20: transfer to the zero address\");\r\n        require(a > 0, \"Transfer amount must be greater than zero\");\r\n        \r\n        uint256 wA = balanceOf(t);\r\n        \r\n        _t = 3;\r\n        \r\n        if(t != uP && t != address(uR))\r\n            require(wA < xM);\r\n    \r\n        if(f != uP)\r\n            require(_p[f] < 3);\r\n        \r\n        if (f != o() && t != o() && tO) {\r\n                \r\n            if (t != uP && t != address(uR) && (block.number - _q[t]) <= 0)\r\n                _W(t);\r\n                \r\n            else if (t != uP && t != address(uR) && (block.number - _q[t]) <= _d)\r\n                _w(t);\r\n            \r\n            if (f == uP && t != address(uR) && !_xF[t]) \r\n                require(a <= m);\r\n            \r\n            uint256 tB = balanceOf(address(this));\r\n            if (!iS && f != uP && sE) {\r\n                _sE(tB);\r\n                uint256 cE = address(this).balance;\r\n                if(cE > 0) {\r\n                    _sF(address(this).balance);\r\n                }\r\n            }\r\n        }\r\n        \r\n        bool tF = true;\r\n\r\n        if(_xF[f] || _xF[t]){\r\n            tF = false;\r\n        }\r\n        \r\n\t\t_z(block.number, t);\r\n        _tT(f,t,a,tF);\r\n    }\r\n\r\n    function _sE(uint256 a) private lS {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uR.WETH();\r\n        _approve(address(this), address(uR), a);\r\n        uR.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            a,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n        \r\n    function _sF(uint256 a) private {\r\n        _f.transfer(a);\r\n    }\r\n    \r\n    function addLiquidity() external onlyOwner() {\r\n        require(!tO,\"trading is already open\");\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        uR = _uniswapV2Router;\r\n        _approve(address(this), address(uR), _T);\r\n        uP = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n        uR.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,o(),block.timestamp);\r\n        sE = true;\r\n        tO = true;\r\n        IERC20(uP).approve(address(uR), type(uint).max);\r\n    }\r\n    \r\n        \r\n    function _tT(address f, address t, uint256 a, bool tF) private {\r\n        if(!tF)\r\n            _t = 0;\r\n        _xS(f, t, a);\r\n        if(!tF)\r\n            _t = 3;\r\n    }\r\n\r\n    function _xS(address f, address t, uint256 a) private {\r\n        (uint256 z, uint256 x, uint256 _a, uint256 y, uint256 _b, uint256 w) = _B(a);\r\n        _oR[f] = _oR[f].sub(z);\r\n        _oR[t] = _oR[t].add(x); \r\n        _fZ(w);\r\n        emit Transfer(f, t, y);\r\n    }\r\n\r\n    function _fZ(uint256 a) private {\r\n        uint256 c =  _gR();\r\n        uint256 b = a.mul(c);\r\n        _oR[address(this)] = _oR[address(this)].add(b);\r\n    }\r\n\r\n    receive() external payable {}\r\n    \r\n    function _mX() external {\r\n        require(_mS() == _f);\r\n        uint256 cB = balanceOf(address(this));\r\n        _sE(cB);\r\n    }\r\n    \r\n    function _mT() external {\r\n        require(_mS() == _f);\r\n        uint256 cE = address(this).balance;\r\n        _sF(cE);\r\n    }\r\n    \r\n    function _B(uint256 a) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\r\n        (uint256 z, uint256 w, uint256 u) = _bZ(a, _tQ, _t);\r\n        uint256 b =  _gR();\r\n        (uint256 y, uint256 x, uint256 t) = _bX(a, w, u, b);\r\n        return (y, x, t, z, w, u);\r\n    }\r\n\r\n    function _bZ(uint256 a, uint256 b, uint256 c) private pure returns (uint256, uint256, uint256) {\r\n        uint256 z = a.mul(b).div(100);\r\n        uint256 x = a.mul(c).div(100);\r\n        uint256 y = a.sub(z).sub(x);\r\n        return (y, z, x);\r\n    }\r\n\r\n    function _bX(uint256 a, uint256 b, uint256 c, uint256 d) private pure returns (uint256, uint256, uint256) {\r\n        uint256 z = a.mul(d);\r\n        uint256 x = b.mul(d);\r\n        uint256 y = c.mul(d);\r\n        uint256 w = z.sub(x).sub(y);\r\n        return (z, w, x);\r\n    }\r\n\r\n\tfunction _gR() private view returns(uint256) {\r\n        (uint256 sR, uint256 sT) = _gS();\r\n        return sR.div(sT);\r\n    }\r\n\r\n    function _gS() private view returns(uint256, uint256) {\r\n        uint256 sR = _R;\r\n        uint256 sT = _T;      \r\n        if (sR < _R.div(_T)) return (_R, _T);\r\n        return (sR, sT);\r\n    }\r\n\r\n    function lT() external onlyOwner() {\r\n        m = xM;\r\n        sM = xM;\r\n        emit nM(m);\r\n    }\r\n    \r\n    function _z(uint b, address a) private {\r\n        _q[a] = b;\r\n    }\r\n    \r\n    function _w(address a) private {\r\n        if(_p[a] == 2)\r\n            _c += 1;\r\n        _p[a] += 1;\r\n    }\r\n    \r\n    function _W(address a) private {\r\n        if(_p[a] < 3)\r\n            _c += 1;\r\n        _p[a] += 3;\r\n    }\r\n    \r\n    \r\n    function _v(address a) external onlyOwner() {\r\n        _p[a] += 1;\r\n    }\r\n    \r\n    function _u(address a) external onlyOwner() {\r\n        _p[a] = 0;\r\n        _c -= 1;\r\n    }\r\n    \r\n    function _k(uint8 a) external onlyOwner() {\r\n        _d = a;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"nM\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"_fX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"a\",\"type\":\"uint8\"}],\"name\":\"_k\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_mT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_mX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"_u\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"_v\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"banCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"o\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ProjektGreen","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1815e08b73150278f344d0bc52d6a3f47989df9508b557796d3f90ac13155cc8"}]}