{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interface/ICoFiXV2DAO.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface ICoFiXV2DAO {\r\n\r\n    function setGovernance(address gov) external;\r\n    function start() external; \r\n\r\n    // function addETHReward() external payable; \r\n\r\n    event FlagSet(address gov, uint256 flag);\r\n    event CoFiBurn(address gov, uint256 amount);\r\n}\r\n// File: contracts/lib/TransferHelper.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interface/IWETH.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n    function balanceOf(address account) external view returns (uint);\r\n}\r\n\r\n// File: contracts/interface/ICoFiXV2Controller.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface ICoFiXV2Controller {\r\n\r\n    event NewK(address token, uint256 K, uint256 sigma, uint256 T, uint256 ethAmount, uint256 erc20Amount, uint256 blockNum);\r\n    event NewGovernance(address _new);\r\n    event NewOracle(address _priceOracle);\r\n    event NewKTable(address _kTable);\r\n    event NewTimespan(uint256 _timeSpan);\r\n    event NewKRefreshInterval(uint256 _interval);\r\n    event NewKLimit(int128 maxK0);\r\n    event NewGamma(int128 _gamma);\r\n    event NewTheta(address token, uint32 theta);\r\n    event NewK(address token, uint32 k);\r\n    event NewCGamma(address token, uint32 gamma);\r\n\r\n    function addCaller(address caller) external;\r\n\r\n    function setCGamma(address token, uint32 gamma) external;\r\n\r\n    function queryOracle(address token, uint8 op, bytes memory data) external payable returns (uint256 k, uint256 ethAmount, uint256 erc20Amount, uint256 blockNum, uint256 theta);\r\n\r\n    function getKInfo(address token) external view returns (uint32 k, uint32 updatedAt, uint32 theta);\r\n\r\n    function getLatestPriceAndAvgVola(address token) external payable returns (uint256, uint256, uint256, uint256);\r\n}\r\n// File: contracts/interface/ICoFiXV2Factory.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface ICoFiXV2Factory {\r\n    // All pairs: {ETH <-> ERC20 Token}\r\n    event PairCreated(address indexed token, address pair, uint256);\r\n    event NewGovernance(address _new);\r\n    event NewController(address _new);\r\n    event NewFeeReceiver(address _new);\r\n    event NewFeeVaultForLP(address token, address feeVault);\r\n    event NewVaultForLP(address _new);\r\n    event NewVaultForTrader(address _new);\r\n    event NewVaultForCNode(address _new);\r\n    event NewDAO(address _new);\r\n\r\n    /// @dev Create a new token pair for trading\r\n    /// @param  token the address of token to trade\r\n    /// @param  initToken0Amount the initial asset ratio (initToken0Amount:initToken1Amount)\r\n    /// @param  initToken1Amount the initial asset ratio (initToken0Amount:initToken1Amount)\r\n    /// @return pair the address of new token pair\r\n    function createPair(\r\n        address token,\r\n\t    uint256 initToken0Amount,\r\n        uint256 initToken1Amount\r\n        )\r\n        external\r\n        returns (address pair);\r\n\r\n    function getPair(address token) external view returns (address pair);\r\n    function allPairs(uint256) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function getTradeMiningStatus(address token) external view returns (bool status);\r\n    function setTradeMiningStatus(address token, bool status) external;\r\n    function getFeeVaultForLP(address token) external view returns (address feeVault); // for LPs\r\n    function setFeeVaultForLP(address token, address feeVault) external;\r\n\r\n    function setGovernance(address _new) external;\r\n    function setController(address _new) external;\r\n    function setFeeReceiver(address _new) external;\r\n    function setVaultForLP(address _new) external;\r\n    function setVaultForTrader(address _new) external;\r\n    function setVaultForCNode(address _new) external;\r\n    function setDAO(address _new) external;\r\n    function getController() external view returns (address controller);\r\n    function getFeeReceiver() external view returns (address feeReceiver); // For CoFi Holders\r\n    function getVaultForLP() external view returns (address vaultForLP);\r\n    function getVaultForTrader() external view returns (address vaultForTrader);\r\n    function getVaultForCNode() external view returns (address vaultForCNode);\r\n    function getDAO() external view returns (address dao);\r\n}\r\n\r\n// File: contracts/interface/ICoFiXERC20.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface ICoFiXERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    // function name() external pure returns (string memory);\r\n    // function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n// File: contracts/CoFiXERC20.sol\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\npragma solidity 0.6.12;\r\n\r\n// ERC20 token implementation, inherited by CoFiXPair contract, no owner or governance\r\ncontract CoFiXERC20 is ICoFiXERC20 {\r\n    using SafeMath for uint;\r\n\r\n    string public constant nameForDomain = 'CoFiX Pool Token';\r\n    uint8 public override constant decimals = 18;\r\n    uint  public override totalSupply;\r\n    mapping(address => uint) public override balanceOf;\r\n    mapping(address => mapping(address => uint)) public override allowance;\r\n\r\n    bytes32 public override DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public override constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint) public override nonces;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    constructor() public {\r\n        uint chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(nameForDomain)),\r\n                keccak256(bytes('1')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) external override returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external override returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external override returns (bool) {\r\n        if (allowance[from][msg.sender] != uint(-1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\r\n        require(deadline >= block.timestamp, 'CERC20: EXPIRED');\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'CERC20: INVALID_SIGNATURE');\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n\r\n// File: contracts/interface/ICoFiXV2Pair.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface ICoFiXV2Pair is ICoFiXERC20 {\r\n\r\n    struct OraclePrice {\r\n        uint256 ethAmount;\r\n        uint256 erc20Amount;\r\n        uint256 blockNum;\r\n        uint256 K;\r\n        uint256 theta;\r\n    }\r\n\r\n    // All pairs: {ETH <-> ERC20 Token}\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, address outToken, uint outAmount, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amountIn,\r\n        uint amountOut,\r\n        address outToken,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1);\r\n\r\n    function mint(address to, uint amountETH, uint amountToken) external payable returns (uint liquidity, uint oracleFeeChange);\r\n    function burn(address tokenTo, address ethTo) external payable returns (uint amountTokenOut, uint amountETHOut, uint oracleFeeChange);\r\n    function swapWithExact(address outToken, address to) external payable returns (uint amountIn, uint amountOut, uint oracleFeeChange, uint256[5] memory tradeInfo);\r\n    // function swapForExact(address outToken, uint amountOutExact, address to) external payable returns (uint amountIn, uint amountOut, uint oracleFeeChange, uint256[4] memory tradeInfo);\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address, string memory, string memory, uint256, uint256) external;\r\n\r\n    /// @dev get Net Asset Value Per Share\r\n    /// @param  ethAmount ETH side of Oracle price {ETH <-> ERC20 Token}\r\n    /// @param  erc20Amount Token side of Oracle price {ETH <-> ERC20 Token}\r\n    /// @return navps The Net Asset Value Per Share (liquidity) represents\r\n    function getNAVPerShare(uint256 ethAmount, uint256 erc20Amount) external view returns (uint256 navps);\r\n\r\n    /// @dev get initial asset ratio\r\n    /// @return _initToken0Amount Token0(ETH) side of initial asset ratio {ETH <-> ERC20 Token}\r\n    /// @return _initToken1Amount Token1(ERC20) side of initial asset ratio {ETH <-> ERC20 Token}\r\n    function getInitialAssetRatio() external view returns (uint256 _initToken0Amount, uint256 _initToken1Amount);\r\n}\r\n\r\n// File: contracts/CoFiXV2Pair.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n// Pair contract for each trading pair, storing assets and handling settlement\r\n// No owner or governance\r\ncontract CoFiXV2Pair is ICoFiXV2Pair, CoFiXERC20 {\r\n    using SafeMath for uint;\r\n\r\n    enum CoFiX_OP { QUERY, MINT, BURN, SWAP_WITH_EXACT, SWAP_FOR_EXACT } // operations in CoFiX\r\n\r\n    uint public override constant MINIMUM_LIQUIDITY = 10**9; // it's negligible because we calc liquidity in ETH\r\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\r\n\r\n    uint256 constant public K_BASE = 1E8; // K\r\n    uint256 constant public NAVPS_BASE = 1E18; // NAVPS (Net Asset Value Per Share), need accuracy\r\n    uint256 constant public THETA_BASE = 1E8; // theta\r\n\r\n    string public name;\r\n    string public symbol;\r\n\r\n    address public override immutable factory;\r\n    address public override token0; // WETH token\r\n    address public override token1; // any ERC20 token\r\n\r\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\r\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\r\n\r\n    uint256 public initToken1Amount;\r\n    uint256 public initToken0Amount;\r\n\r\n    uint private unlocked = 1;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, address outToken, uint outAmount, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amountIn,\r\n        uint amountOut,\r\n        address outToken,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    modifier lock() {\r\n        require(unlocked == 1, \"CPair: LOCKED\");\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    constructor() public {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    // called once by the factory at time of deployment\r\n    function initialize(address _token0, address _token1, string memory _name, string memory _symbol, uint256 _initToken0Amount, uint256 _initToken1Amount) external override {\r\n        require(msg.sender == factory, \"CPair: FORBIDDEN\"); // sufficient check\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        initToken1Amount = _initToken1Amount;\r\n        initToken0Amount = _initToken0Amount;\r\n    }\r\n\r\n    function getInitialAssetRatio() public override view returns (uint256 _initToken0Amount, uint256 _initToken1Amount) {\r\n        _initToken1Amount = initToken1Amount;\r\n        _initToken0Amount = initToken0Amount;\r\n    }\r\n\r\n    function getReserves() public override view returns (uint112 _reserve0, uint112 _reserve1) {\r\n        _reserve0 = reserve0;\r\n        _reserve1 = reserve1;\r\n    }\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"CPair: TRANSFER_FAILED\");\r\n    }\r\n\r\n    // update reserves\r\n    function _update(uint balance0, uint balance1) private {\r\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), \"CPair: OVERFLOW\");\r\n        reserve0 = uint112(balance0);\r\n        reserve1 = uint112(balance1);\r\n        emit Sync(reserve0, reserve1);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function mint(address to, uint amountETH, uint amountToken) external payable override lock returns (uint liquidity, uint oracleFeeChange) {\r\n        address _token0 = token0;                                // gas savings\r\n        address _token1 = token1;                                // gas savings\r\n        (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\r\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\r\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\r\n        uint amount0 = balance0.sub(_reserve0);\r\n        uint amount1 = balance1.sub(_reserve1);\r\n\r\n        require(amountETH <= amount0 && amountToken <= amount1, \"CPair: illegal ammount\");\r\n        \r\n        amount0 = amountETH;\r\n        amount1 = amountToken;\r\n        require(amount0.mul(initToken1Amount) == amount1.mul(initToken0Amount), \"CPair: invalid asset ratio\");\r\n        \r\n        uint256 _ethBalanceBefore = address(this).balance;\r\n        { // scope for ethAmount/erc20Amount/blockNum to avoid stack too deep error\r\n            bytes memory data = abi.encode(msg.sender, to, amount0, amount1);\r\n            // query price\r\n            OraclePrice memory _op;\r\n            (_op.K, _op.ethAmount, _op.erc20Amount, _op.blockNum, _op.theta) = _queryOracle(_token1, CoFiX_OP.MINT, data);\r\n            uint256 navps = calcNAVPerShare(_reserve0, _reserve1, _op.ethAmount, _op.erc20Amount);\r\n            if (totalSupply == 0) {\r\n                liquidity = calcLiquidity(amount0, navps).sub(MINIMUM_LIQUIDITY);\r\n                _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\r\n            } else {\r\n                liquidity = calcLiquidity(amount0, navps);\r\n            }\r\n        }\r\n        oracleFeeChange = msg.value.sub(_ethBalanceBefore.sub(address(this).balance));\r\n\r\n        require(liquidity > 0, \"CPair: SHORT_LIQUIDITY_MINTED\");\r\n        _mint(to, liquidity);\r\n\r\n        _update(balance0, balance1);\r\n        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\r\n\r\n        emit Mint(msg.sender, amount0, amount1);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function burn(address tokenTo, address ethTo) external payable override lock returns (uint amountTokenOut, uint amountEthOut, uint oracleFeeChange) {\r\n        address _token0 = token0;                                // gas savings\r\n        address _token1 = token1;                                // gas savings\r\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\r\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\r\n        uint liquidity = balanceOf[address(this)];\r\n\r\n        uint256 _ethBalanceBefore = address(this).balance;\r\n        // uint256 fee;\r\n        {\r\n            bytes memory data = abi.encode(msg.sender, liquidity);\r\n            // query price\r\n            OraclePrice memory _op;\r\n            (_op.K, _op.ethAmount, _op.erc20Amount, _op.blockNum, _op.theta) = _queryOracle(_token1, CoFiX_OP.BURN, data);\r\n\r\n            (amountTokenOut, amountEthOut) = calcOutTokenAndETHForBurn(liquidity, _op); // navps calculated\r\n        }\r\n        oracleFeeChange = msg.value.sub(_ethBalanceBefore.sub(address(this).balance));\r\n\r\n        require(amountTokenOut > 0 && amountEthOut > 0, \"CPair: SHORT_LIQUIDITY_BURNED\");\r\n\r\n        _burn(address(this), liquidity);\r\n        _safeTransfer(_token1, tokenTo, amountTokenOut);\r\n        _safeTransfer(_token0, ethTo, amountEthOut);\r\n\r\n        balance0 = IERC20(_token0).balanceOf(address(this));\r\n        balance1 = IERC20(_token1).balanceOf(address(this));\r\n\r\n        _update(balance0, balance1);\r\n        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\r\n\r\n        emit Burn(msg.sender, _token0, amountEthOut, ethTo);\r\n        emit Burn(msg.sender, _token1, amountTokenOut, tokenTo);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function swapWithExact(address outToken, address to)\r\n        external\r\n        payable override lock\r\n        returns (uint amountIn, uint amountOut, uint oracleFeeChange, uint256[5] memory tradeInfo)\r\n    {\r\n        // tradeInfo[0]: thetaFee, tradeInfo[1]: ethAmount, tradeInfo[2]: erc20Amount\r\n        address _token0 = token0;\r\n        address _token1 = token1;\r\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\r\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\r\n\r\n        // uint256 fee;\r\n        { // scope for ethAmount/erc20Amount/blockNum to avoid stack too deep error\r\n            uint256 _ethBalanceBefore = address(this).balance;\r\n            (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\r\n\r\n            // calc amountIn\r\n            if (outToken == _token1) {\r\n                amountIn = balance0.sub(_reserve0);\r\n            } else if (outToken == _token0) {\r\n                amountIn = balance1.sub(_reserve1);\r\n            } else {\r\n                revert(\"CPair: wrong outToken\");\r\n            }\r\n            require(amountIn > 0, \"CPair: wrong amountIn\");\r\n            bytes memory data = abi.encode(msg.sender, outToken, to, amountIn);\r\n            // query price\r\n            OraclePrice memory _op;\r\n            (_op.K, _op.ethAmount, _op.erc20Amount, _op.blockNum, _op.theta) = _queryOracle(_token1, CoFiX_OP.SWAP_WITH_EXACT, data);\r\n            \r\n            if (outToken == _token1) {\r\n                (amountOut, tradeInfo[0]) = calcOutToken1(amountIn, _op);\r\n            } else if (outToken == _token0) {\r\n                (amountOut, tradeInfo[0]) = calcOutToken0(amountIn, _op);\r\n            }\r\n            oracleFeeChange = msg.value.sub(_ethBalanceBefore.sub(address(this).balance));\r\n            tradeInfo[1] = _op.ethAmount;\r\n            tradeInfo[2] = _op.erc20Amount;\r\n        }\r\n        \r\n        require(to != _token0 && to != _token1, \"CPair: INVALID_TO\");\r\n\r\n        _safeTransfer(outToken, to, amountOut); // optimistically transfer tokens\r\n        if (tradeInfo[0] > 0) {\r\n            if (ICoFiXV2Factory(factory).getTradeMiningStatus(_token1)) {\r\n                // only transfer fee to protocol feeReceiver when trade mining is enabled for this trading pair\r\n                _safeSendFeeForDAO(_token0, tradeInfo[0]);\r\n            } else {\r\n                _safeSendFeeForLP(_token0, _token1, tradeInfo[0]);\r\n                tradeInfo[0] = 0; // so router won't go into the trade mining logic (reduce one more call gas cost)\r\n            }\r\n        }\r\n        balance0 = IERC20(_token0).balanceOf(address(this));\r\n        balance1 = IERC20(_token1).balanceOf(address(this));\r\n\r\n        _update(balance0, balance1);\r\n        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\r\n\r\n        emit Swap(msg.sender, amountIn, amountOut, outToken, to);\r\n    }\r\n\r\n    // force balances to match reserves\r\n    function skim(address to) external override lock {\r\n        address _token0 = token0; // gas savings\r\n        address _token1 = token1; // gas savings\r\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\r\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\r\n    }\r\n\r\n    // force reserves to match balances\r\n    function sync() external override lock {\r\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)));\r\n    }\r\n\r\n    // calc Net Asset Value Per Share (no K)\r\n    // use it in this contract, for optimized gas usage\r\n    function calcNAVPerShare(uint256 balance0, uint256 balance1, uint256 ethAmount, uint256 erc20Amount) public view returns (uint256 navps) {\r\n        uint _totalSupply = totalSupply;\r\n        if (_totalSupply == 0) {\r\n            navps = NAVPS_BASE;\r\n        } else {\r\n            /*\r\n            NV  = \\frac{E_t + U_t/P_t}{(1 + \\frac{k_0}{P_t})*F_t}\\\\\\\\\r\n                = \\frac{E_t + U_t * \\frac{ethAmount}{erc20Amount}}{(1 + \\frac{initToken1Amount}{initToken0Amount} * \\frac{ethAmount}{erc20Amount})*F_t}\\\\\\\\\r\n                = \\frac{E_t * erc20Amount + U_t * ethAmount}{(erc20Amount + \\frac{initToken1Amount * ethAmount}{initToken0Amount}) * F_t}\\\\\\\\\r\n                = \\frac{E_t * erc20Amount * initToken0Amount + U_t * ethAmount * initToken0Amount}{( erc20Amount * initToken0Amount + initToken1Amount * ethAmount) * F_t} \\\\\\\\\r\n                = \\frac{balance0 * erc20Amount * initToken0Amount + balance1 * ethAmount * initToken0Amount}{(erc20Amount * initToken0Amount + initToken1Amount * ethAmount) * totalSupply}\r\n             */\r\n            uint256 balance0MulErc20AmountMulInitToken0Amount = balance0.mul(erc20Amount).mul(initToken0Amount);\r\n            uint256 balance1MulEthAmountMulInitToken0Amount = balance1.mul(ethAmount).mul(initToken0Amount);\r\n            uint256 initToken1AmountMulEthAmount = initToken1Amount.mul(ethAmount);\r\n            uint256 initToken0AmountMulErc20Amount = erc20Amount.mul(initToken0Amount);\r\n\r\n            navps = (balance0MulErc20AmountMulInitToken0Amount.add(balance1MulEthAmountMulInitToken0Amount))\r\n                        .div(_totalSupply).mul(NAVPS_BASE)\r\n                        .div(initToken1AmountMulEthAmount.add(initToken0AmountMulErc20Amount));\r\n        }\r\n    }\r\n\r\n    // use it in this contract, for optimized gas usage\r\n    function calcLiquidity(uint256 amount0, uint256 navps) public pure returns (uint256 liquidity) {\r\n        liquidity = amount0.mul(NAVPS_BASE).div(navps);\r\n    }\r\n\r\n    // get Net Asset Value Per Share for mint\r\n    // only for read, could cost more gas if use it directly in contract\r\n    function getNAVPerShareForMint(OraclePrice memory _op) public view returns (uint256 navps) {\r\n        return calcNAVPerShare(reserve0, reserve1, _op.ethAmount, _op.erc20Amount);\r\n    }\r\n\r\n    // get Net Asset Value Per Share for burn\r\n    // only for read, could cost more gas if use it directly in contract\r\n    function getNAVPerShareForBurn(OraclePrice memory _op) external view returns (uint256 navps) {\r\n        return calcNAVPerShare(reserve0, reserve1, _op.ethAmount, _op.erc20Amount);\r\n    }\r\n\r\n    // get Net Asset Value Per Share\r\n    // only for read, could cost more gas if use it directly in contract\r\n    function getNAVPerShare(uint256 ethAmount, uint256 erc20Amount) external override view returns (uint256 navps) {\r\n        return calcNAVPerShare(reserve0, reserve1, ethAmount, erc20Amount);\r\n    }\r\n\r\n    // get estimated liquidity amount (it represents the amount of pool tokens will be minted if someone provide liquidity to the pool)\r\n    // only for read, could cost more gas if use it directly in contract\r\n    function getLiquidity(uint256 amount0, OraclePrice memory _op) external view returns (uint256 liquidity) {\r\n        uint256 navps = getNAVPerShareForMint(_op);\r\n        return calcLiquidity(amount0, navps);\r\n    }\r\n\r\n    function calcOutTokenAndETHForBurn(uint256 liquidity, OraclePrice memory _op) public view returns (uint256 amountTokenOut, uint256 amountEthOut) {\r\n        // amountEthOut = liquidity * navps * (THETA_BASE - theta) / THETA_BASE\r\n        // amountTokenOut = liquidity * navps * (THETA_BASE - theta) * initToken1Amount / (initToken0Amount * THETA_BASE)\r\n        uint256 navps;\r\n        {\r\n            navps = calcNAVPerShare(reserve0, reserve1, _op.ethAmount, _op.erc20Amount);\r\n            uint256 amountEth = liquidity.mul(navps);\r\n\r\n            uint256 amountEthOutLarge = amountEth.mul(THETA_BASE.sub(_op.theta));\r\n            amountEthOut = amountEthOutLarge.div(NAVPS_BASE).div(THETA_BASE);\r\n            amountTokenOut = amountEthOutLarge.mul(initToken1Amount).div(NAVPS_BASE).div(initToken0Amount).div(THETA_BASE);\r\n            // amountTokenOut = amountEthOut.mul(initToken1Amount).div(initToken0Amount);\r\n        }\r\n\r\n        // recalc amountOut when has no enough reserve0 or reserve1 to out in initAssetRatio\r\n        {\r\n            if (amountEthOut > reserve0) {\r\n                // user first, out eth as much as possibile. And may leave over a few amounts of reserve1. \r\n                uint256 amountEthInsufficient = amountEthOut - reserve0;\r\n                uint256 amountTokenEquivalent = amountEthInsufficient.mul(_op.erc20Amount).div(_op.ethAmount);\r\n                amountTokenOut = amountTokenOut.add(amountTokenEquivalent);\r\n                if (amountTokenOut > reserve1) {\r\n                    amountTokenOut = reserve1;\r\n                }\r\n                amountEthOut = reserve0;\r\n                // amountEthOut = reserve0 - fee;    \r\n            } else if (amountTokenOut > reserve1) {\r\n                uint256 amountTokenInsufficient = amountTokenOut - reserve1;\r\n                uint256 amountEthEquivalent = amountTokenInsufficient.mul(_op.ethAmount).div(_op.erc20Amount);\r\n                amountEthOut = amountEthOut.add(amountEthEquivalent);\r\n                if (amountEthOut > reserve0) {\r\n                    amountEthOut = reserve0;\r\n                }\r\n                amountTokenOut = reserve1;\r\n            }\r\n        }   \r\n    }\r\n\r\n    // get estimated amountOut for token0 (WETH) when swapWithExact\r\n    function calcOutToken0(uint256 amountIn, OraclePrice memory _op) public pure returns (uint256 amountOut, uint256 fee) {\r\n        /*\r\n        x &= (a/P_{b}^{'})*\\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\r\n          &= a / (\\frac{erc20Amount}{ethAmount} * \\frac{(k_{BASE} + k)}{(k_{BASE})}) * \\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\r\n          &= \\frac{a*ethAmount*k_{BASE}}{erc20Amount*(k_{BASE} + k)} * \\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\r\n          &= \\frac{a*ethAmount*k_{BASE}*(THETA_{BASE} - \\theta)}{erc20Amount*(k_{BASE} + k)*THETA_{BASE}} \\\\\\\\\r\n        // amountOut = amountIn * _op.ethAmount * K_BASE * (THETA_BASE - _op.theta) / _op.erc20Amount / (K_BASE + _op.K) / THETA_BASE;\r\n        */\r\n        amountOut = amountIn.mul(_op.ethAmount).mul(K_BASE).mul(THETA_BASE.sub(_op.theta)).div(_op.erc20Amount).div(K_BASE.add(_op.K)).div(THETA_BASE);\r\n        if (_op.theta != 0) {\r\n            // fee = amountIn * _op.ethAmount * K_BASE * (_op.theta) / _op.erc20Amount / (K_BASE + _op.K) / THETA_BASE;\r\n            fee = amountIn.mul(_op.ethAmount).mul(K_BASE).mul(_op.theta).div(_op.erc20Amount).div(K_BASE.add(_op.K)).div(THETA_BASE);\r\n        }\r\n        return (amountOut, fee);\r\n    }\r\n\r\n    // get estimated amountOut for token1 (ERC20 token) when swapWithExact\r\n    function calcOutToken1(uint256 amountIn, OraclePrice memory _op) public pure returns (uint256 amountOut, uint256 fee) {\r\n        /*\r\n        y &= b*P_{s}^{'}*\\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\r\n          &= b * \\frac{erc20Amount}{ethAmount} * \\frac{(k_{BASE} - k)}{(k_{BASE})} * \\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\r\n          &= \\frac{b*erc20Amount*(k_{BASE} - k)*(THETA_{BASE} - \\theta)}{ethAmount*k_{BASE}*THETA_{BASE}} \\\\\\\\\r\n        // amountOut = amountIn * _op.erc20Amount * (K_BASE - _op.K) * (THETA_BASE - _op.theta) / _op.ethAmount / K_BASE / THETA_BASE;\r\n        */\r\n        amountOut = amountIn.mul(_op.erc20Amount).mul(K_BASE.sub(_op.K)).mul(THETA_BASE.sub(_op.theta)).div(_op.ethAmount).div(K_BASE).div(THETA_BASE);\r\n        if (_op.theta != 0) {\r\n            // fee = amountIn * _op.theta / THETA_BASE;\r\n            fee = amountIn.mul(_op.theta).div(THETA_BASE);\r\n        }\r\n        return (amountOut, fee);\r\n    }\r\n\r\n    // get estimate amountInNeeded for token0 (WETH) when swapForExact\r\n    function calcInNeededToken0(uint256 amountOut, OraclePrice memory _op) public pure returns (uint256 amountInNeeded, uint256 fee) {\r\n        // inverse of calcOutToken1\r\n        // amountOut = amountIn.mul(_op.erc20Amount).mul(K_BASE.sub(_op.K)).mul(THETA_BASE.sub(_op.theta)).div(_op.ethAmount).div(K_BASE).div(THETA_BASE);\r\n        amountInNeeded = amountOut.mul(_op.ethAmount).mul(K_BASE).mul(THETA_BASE).div(_op.erc20Amount).div(K_BASE.sub(_op.K)).div(THETA_BASE.sub(_op.theta));\r\n        if (_op.theta != 0) {\r\n            // fee = amountIn * _op.theta / THETA_BASE;\r\n            fee = amountInNeeded.mul(_op.theta).div(THETA_BASE);\r\n        }\r\n        return (amountInNeeded, fee);\r\n    }\r\n\r\n    // get estimate amountInNeeded for token1 (ERC20 token) when swapForExact\r\n    function calcInNeededToken1(uint256 amountOut, OraclePrice memory _op) public pure returns (uint256 amountInNeeded, uint256 fee) {\r\n        // inverse of calcOutToken0\r\n        // amountOut = amountIn.mul(_op.ethAmount).mul(K_BASE).mul(THETA_BASE.sub(_op.theta)).div(_op.erc20Amount).div(K_BASE.add(_op.K)).div(THETA_BASE);\r\n        amountInNeeded = amountOut.mul(_op.erc20Amount).mul(K_BASE.add(_op.K)).mul(THETA_BASE).div(_op.ethAmount).div(K_BASE).div(THETA_BASE.sub(_op.theta));\r\n        if (_op.theta != 0) {\r\n            // fee = amountIn * _op.ethAmount * K_BASE * (_op.theta) / _op.erc20Amount / (K_BASE + _op.K) / THETA_BASE;\r\n            fee = amountInNeeded.mul(_op.ethAmount).mul(K_BASE).mul(_op.theta).div(_op.erc20Amount).div(K_BASE.add(_op.K)).div(THETA_BASE);\r\n        }\r\n        return (amountInNeeded, fee);\r\n    }\r\n\r\n    function _queryOracle(address token, CoFiX_OP op, bytes memory data) internal returns (uint256, uint256, uint256, uint256, uint256) {\r\n        return ICoFiXV2Controller(ICoFiXV2Factory(factory).getController()).queryOracle{value: msg.value}(token, uint8(op), data);\r\n    }\r\n\r\n    function _safeSendFeeForDAO(address _token0, uint256 _fee) internal {\r\n        address feeReceiver = ICoFiXV2Factory(factory).getFeeReceiver();\r\n        if (feeReceiver == address(0)) {\r\n            return; // if feeReceiver not set, theta fee keeps in pair pool\r\n        }\r\n        uint256 bal = IWETH(_token0).balanceOf(address(this));\r\n        if (_fee > bal) {\r\n            _fee = bal;\r\n        }\r\n\r\n        IWETH(_token0).withdraw(_fee);\r\n        if (_fee > 0) TransferHelper.safeTransferETH(feeReceiver, _fee); // transfer fee to protocol dao for redeem Cofi\r\n        // ICoFiXV2DAO(dao).addETHReward{value: _fee}(); \r\n    }\r\n\r\n    // Safe WETH transfer function, just in case not having enough WETH. LP will earn these fees.\r\n    function _safeSendFeeForLP(address _token0, address _token1, uint256 _fee) internal {\r\n        address feeVault = ICoFiXV2Factory(factory).getFeeVaultForLP(_token1);\r\n        if (feeVault == address(0)) {\r\n            return; // if fee vault not set, theta fee keeps in pair pool\r\n        }\r\n        _safeSendFee(_token0, feeVault, _fee); // transfer fee to protocol fee reward pool for LP\r\n    }\r\n\r\n    function _safeSendFee(address _token0, address _receiver, uint256 _fee) internal {\r\n        uint256 wethBal = IERC20(_token0).balanceOf(address(this));\r\n        if (_fee > wethBal) {\r\n            _fee = wethBal;\r\n        }\r\n        if (_fee > 0) _safeTransfer(_token0, _receiver, _fee); \r\n    }\r\n}\r\n// 🦄 & CoFi Rocks","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserve0\",\"type\":\"uint112\"},{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserve1\",\"type\":\"uint112\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"K_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_LIQUIDITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAVPS_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"THETA_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenTo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ethTo\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountTokenOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountEthOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oracleFeeChange\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"K\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"theta\",\"type\":\"uint256\"}],\"internalType\":\"struct ICoFiXV2Pair.OraclePrice\",\"name\":\"_op\",\"type\":\"tuple\"}],\"name\":\"calcInNeededToken0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountInNeeded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"K\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"theta\",\"type\":\"uint256\"}],\"internalType\":\"struct ICoFiXV2Pair.OraclePrice\",\"name\":\"_op\",\"type\":\"tuple\"}],\"name\":\"calcInNeededToken1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountInNeeded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"navps\",\"type\":\"uint256\"}],\"name\":\"calcLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"}],\"name\":\"calcNAVPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"navps\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"K\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"theta\",\"type\":\"uint256\"}],\"internalType\":\"struct ICoFiXV2Pair.OraclePrice\",\"name\":\"_op\",\"type\":\"tuple\"}],\"name\":\"calcOutToken0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"K\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"theta\",\"type\":\"uint256\"}],\"internalType\":\"struct ICoFiXV2Pair.OraclePrice\",\"name\":\"_op\",\"type\":\"tuple\"}],\"name\":\"calcOutToken1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"K\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"theta\",\"type\":\"uint256\"}],\"internalType\":\"struct ICoFiXV2Pair.OraclePrice\",\"name\":\"_op\",\"type\":\"tuple\"}],\"name\":\"calcOutTokenAndETHForBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountTokenOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountEthOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInitialAssetRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_initToken0Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initToken1Amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"K\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"theta\",\"type\":\"uint256\"}],\"internalType\":\"struct ICoFiXV2Pair.OraclePrice\",\"name\":\"_op\",\"type\":\"tuple\"}],\"name\":\"getLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"}],\"name\":\"getNAVPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"navps\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"K\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"theta\",\"type\":\"uint256\"}],\"internalType\":\"struct ICoFiXV2Pair.OraclePrice\",\"name\":\"_op\",\"type\":\"tuple\"}],\"name\":\"getNAVPerShareForBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"navps\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"K\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"theta\",\"type\":\"uint256\"}],\"internalType\":\"struct ICoFiXV2Pair.OraclePrice\",\"name\":\"_op\",\"type\":\"tuple\"}],\"name\":\"getNAVPerShareForMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"navps\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"_reserve0\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"_reserve1\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initToken0Amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initToken1Amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_initToken0Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initToken1Amount\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oracleFeeChange\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nameForDomain\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"swapWithExact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oracleFeeChange\",\"type\":\"uint256\"},{\"internalType\":\"uint256[5]\",\"name\":\"tradeInfo\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"CoFiXV2Pair","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"6666","ConstructorArguments":"","EVMVersion":"istanbul","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://75fd8b231a5e9a3ccabafbc24c4617be2296d370b66ce185fd035003fd69a2ba"}]}