{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/common/governance/IGovernance.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ninterface IGovernance {\r\n    function update(address target, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts/common/governance/Governable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract Governable {\r\n    IGovernance public governance;\r\n\r\n    constructor(address _governance) public {\r\n        governance = IGovernance(_governance);\r\n    }\r\n\r\n    modifier onlyGovernance() {\r\n        _assertGovernance();\r\n        _;\r\n    }\r\n\r\n    function _assertGovernance() private view {\r\n        require(\r\n            msg.sender == address(governance),\r\n            \"Only governance contract is authorized\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/root/withdrawManager/IWithdrawManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract IWithdrawManager {\r\n    function createExitQueue(address token) external;\r\n\r\n    function verifyInclusion(\r\n        bytes calldata data,\r\n        uint8 offset,\r\n        bool verifyTxInclusion\r\n    ) external view returns (uint256 age);\r\n\r\n    function addExitToQueue(\r\n        address exitor,\r\n        address childToken,\r\n        address rootToken,\r\n        uint256 exitAmountOrTokenId,\r\n        bytes32 txHash,\r\n        bool isRegularExit,\r\n        uint256 priority\r\n    ) external;\r\n\r\n    function addInput(\r\n        uint256 exitId,\r\n        uint256 age,\r\n        address utxoOwner,\r\n        address token\r\n    ) external;\r\n\r\n    function challengeExit(\r\n        uint256 exitId,\r\n        uint256 inputId,\r\n        bytes calldata challengeData,\r\n        address adjudicatorPredicate\r\n    ) external;\r\n}\r\n\r\n// File: contracts/common/Registry.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract Registry is Governable {\r\n    // @todo hardcode constants\r\n    bytes32 private constant WETH_TOKEN = keccak256(\"wethToken\");\r\n    bytes32 private constant DEPOSIT_MANAGER = keccak256(\"depositManager\");\r\n    bytes32 private constant STAKE_MANAGER = keccak256(\"stakeManager\");\r\n    bytes32 private constant VALIDATOR_SHARE = keccak256(\"validatorShare\");\r\n    bytes32 private constant WITHDRAW_MANAGER = keccak256(\"withdrawManager\");\r\n    bytes32 private constant CHILD_CHAIN = keccak256(\"childChain\");\r\n    bytes32 private constant STATE_SENDER = keccak256(\"stateSender\");\r\n    bytes32 private constant SLASHING_MANAGER = keccak256(\"slashingManager\");\r\n\r\n    address public erc20Predicate;\r\n    address public erc721Predicate;\r\n\r\n    mapping(bytes32 => address) public contractMap;\r\n    mapping(address => address) public rootToChildToken;\r\n    mapping(address => address) public childToRootToken;\r\n    mapping(address => bool) public proofValidatorContracts;\r\n    mapping(address => bool) public isERC721;\r\n\r\n    enum Type {Invalid, ERC20, ERC721, Custom}\r\n    struct Predicate {\r\n        Type _type;\r\n    }\r\n    mapping(address => Predicate) public predicates;\r\n\r\n    event TokenMapped(address indexed rootToken, address indexed childToken);\r\n    event ProofValidatorAdded(address indexed validator, address indexed from);\r\n    event ProofValidatorRemoved(address indexed validator, address indexed from);\r\n    event PredicateAdded(address indexed predicate, address indexed from);\r\n    event PredicateRemoved(address indexed predicate, address indexed from);\r\n    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);\r\n\r\n    constructor(address _governance) public Governable(_governance) {}\r\n\r\n    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {\r\n        emit ContractMapUpdated(_key, contractMap[_key], _address);\r\n        contractMap[_key] = _address;\r\n    }\r\n\r\n    /**\r\n     * @dev Map root token to child token\r\n     * @param _rootToken Token address on the root chain\r\n     * @param _childToken Token address on the child chain\r\n     * @param _isERC721 Is the token being mapped ERC721\r\n     */\r\n    function mapToken(\r\n        address _rootToken,\r\n        address _childToken,\r\n        bool _isERC721\r\n    ) external onlyGovernance {\r\n        require(_rootToken != address(0x0) && _childToken != address(0x0), \"INVALID_TOKEN_ADDRESS\");\r\n        rootToChildToken[_rootToken] = _childToken;\r\n        childToRootToken[_childToken] = _rootToken;\r\n        isERC721[_rootToken] = _isERC721;\r\n        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);\r\n        emit TokenMapped(_rootToken, _childToken);\r\n    }\r\n\r\n    function addErc20Predicate(address predicate) public onlyGovernance {\r\n        require(predicate != address(0x0), \"Can not add null address as predicate\");\r\n        erc20Predicate = predicate;\r\n        addPredicate(predicate, Type.ERC20);\r\n    }\r\n\r\n    function addErc721Predicate(address predicate) public onlyGovernance {\r\n        erc721Predicate = predicate;\r\n        addPredicate(predicate, Type.ERC721);\r\n    }\r\n\r\n    function addPredicate(address predicate, Type _type) public onlyGovernance {\r\n        require(predicates[predicate]._type == Type.Invalid, \"Predicate already added\");\r\n        predicates[predicate]._type = _type;\r\n        emit PredicateAdded(predicate, msg.sender);\r\n    }\r\n\r\n    function removePredicate(address predicate) public onlyGovernance {\r\n        require(predicates[predicate]._type != Type.Invalid, \"Predicate does not exist\");\r\n        delete predicates[predicate];\r\n        emit PredicateRemoved(predicate, msg.sender);\r\n    }\r\n\r\n    function getValidatorShareAddress() public view returns (address) {\r\n        return contractMap[VALIDATOR_SHARE];\r\n    }\r\n\r\n    function getWethTokenAddress() public view returns (address) {\r\n        return contractMap[WETH_TOKEN];\r\n    }\r\n\r\n    function getDepositManagerAddress() public view returns (address) {\r\n        return contractMap[DEPOSIT_MANAGER];\r\n    }\r\n\r\n    function getStakeManagerAddress() public view returns (address) {\r\n        return contractMap[STAKE_MANAGER];\r\n    }\r\n\r\n    function getSlashingManagerAddress() public view returns (address) {\r\n        return contractMap[SLASHING_MANAGER];\r\n    }\r\n\r\n    function getWithdrawManagerAddress() public view returns (address) {\r\n        return contractMap[WITHDRAW_MANAGER];\r\n    }\r\n\r\n    function getChildChainAndStateSender() public view returns (address, address) {\r\n        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);\r\n    }\r\n\r\n    function isTokenMapped(address _token) public view returns (bool) {\r\n        return rootToChildToken[_token] != address(0x0);\r\n    }\r\n\r\n    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {\r\n        require(isTokenMapped(_token), \"TOKEN_NOT_MAPPED\");\r\n        return isERC721[_token];\r\n    }\r\n\r\n    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {\r\n        if (isTokenMappedAndIsErc721(_token)) {\r\n            return erc721Predicate;\r\n        }\r\n        return erc20Predicate;\r\n    }\r\n\r\n    function isChildTokenErc721(address childToken) public view returns (bool) {\r\n        address rootToken = childToRootToken[childToken];\r\n        require(rootToken != address(0x0), \"Child token is not mapped\");\r\n        return isERC721[rootToken];\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://eips.ethereum.org/EIPS/eip-20\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner The address to query the balance of.\r\n     * @return A uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token to a specified address\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to tr vbmansfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _transfer(from, to, value);\r\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified addresses\r\n     * @param from The address to transfer from.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve an address to spend another addresses' tokens.\r\n     * @param owner The address that owns the tokens.\r\n     * @param spender The address that will spend the tokens.\r\n     * @param value The number of tokens that can be spent.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(spender != address(0));\r\n        require(owner != address(0));\r\n\r\n        _allowed[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _burn(account, value);\r\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\r\n    }\r\n}\r\n\r\n// File: contracts/common/tokens/ERC20NonTradable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract ERC20NonTradable is ERC20 {\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        revert(\"disabled\");\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/staking/StakingInfo.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n// dummy interface to avoid cyclic dependency\r\ncontract IStakeManagerLocal {\r\n    enum Status {Inactive, Active, Locked, Unstaked}\r\n\r\n    struct Validator {\r\n        uint256 amount;\r\n        uint256 reward;\r\n        uint256 activationEpoch;\r\n        uint256 deactivationEpoch;\r\n        uint256 jailTime;\r\n        address signer;\r\n        address contractAddress;\r\n        Status status;\r\n    }\r\n\r\n    mapping(uint256 => Validator) public validators;\r\n    bytes32 public accountStateRoot;\r\n    uint256 public activeAmount; // delegation amount from validator contract\r\n    uint256 public validatorRewards;\r\n\r\n    function currentValidatorSetTotalStake() public view returns (uint256);\r\n\r\n    // signer to Validator mapping\r\n    function signerToValidator(address validatorAddress)\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function isValidator(uint256 validatorId) public view returns (bool);\r\n}\r\n\r\ncontract StakingInfo is Ownable {\r\n    using SafeMath for uint256;\r\n    mapping(uint256 => uint256) public validatorNonce;\r\n\r\n    /// @dev Emitted when validator stakes in '_stakeFor()' in StakeManager.\r\n    /// @param signer validator address.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param activationEpoch validator's first epoch as proposer.\r\n    /// @param amount staking amount.\r\n    /// @param total total staking amount.\r\n    /// @param signerPubkey public key of the validator\r\n    event Staked(\r\n        address indexed signer,\r\n        uint256 indexed validatorId,\r\n        uint256 nonce,\r\n        uint256 indexed activationEpoch,\r\n        uint256 amount,\r\n        uint256 total,\r\n        bytes signerPubkey\r\n    );\r\n\r\n    /// @dev Emitted when validator unstakes in 'unstakeClaim()'\r\n    /// @param user address of the validator.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param amount staking amount.\r\n    /// @param total total staking amount.\r\n    event Unstaked(\r\n        address indexed user,\r\n        uint256 indexed validatorId,\r\n        uint256 amount,\r\n        uint256 total\r\n    );\r\n\r\n    /// @dev Emitted when validator unstakes in '_unstake()'.\r\n    /// @param user address of the validator.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param deactivationEpoch last epoch for validator.\r\n    /// @param amount staking amount.\r\n    event UnstakeInit(\r\n        address indexed user,\r\n        uint256 indexed validatorId,\r\n        uint256 nonce,\r\n        uint256 deactivationEpoch,\r\n        uint256 indexed amount\r\n    );\r\n\r\n    /// @dev Emitted when the validator public key is updated in 'updateSigner()'.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param oldSigner old address of the validator.\r\n    /// @param newSigner new address of the validator.\r\n    /// @param signerPubkey public key of the validator.\r\n    event SignerChange(\r\n        uint256 indexed validatorId,\r\n        uint256 nonce,\r\n        address indexed oldSigner,\r\n        address indexed newSigner,\r\n        bytes signerPubkey\r\n    );\r\n    event Restaked(uint256 indexed validatorId, uint256 amount, uint256 total);\r\n    event Jailed(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed exitEpoch,\r\n        address indexed signer\r\n    );\r\n    event UnJailed(uint256 indexed validatorId, address indexed signer);\r\n    event Slashed(uint256 indexed nonce, uint256 indexed amount);\r\n    event ThresholdChange(uint256 newThreshold, uint256 oldThreshold);\r\n    event DynastyValueChange(uint256 newDynasty, uint256 oldDynasty);\r\n    event ProposerBonusChange(\r\n        uint256 newProposerBonus,\r\n        uint256 oldProposerBonus\r\n    );\r\n\r\n    event RewardUpdate(uint256 newReward, uint256 oldReward);\r\n\r\n    /// @dev Emitted when validator confirms the auction bid and at the time of restaking in confirmAuctionBid() and restake().\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param newAmount the updated stake amount.\r\n    event StakeUpdate(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed nonce,\r\n        uint256 indexed newAmount\r\n    );\r\n    event ClaimRewards(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed amount,\r\n        uint256 indexed totalAmount\r\n    );\r\n    event StartAuction(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed amount,\r\n        uint256 indexed auctionAmount\r\n    );\r\n    event ConfirmAuction(\r\n        uint256 indexed newValidatorId,\r\n        uint256 indexed oldValidatorId,\r\n        uint256 indexed amount\r\n    );\r\n    event TopUpFee(address indexed user, uint256 indexed fee);\r\n    event ClaimFee(address indexed user, uint256 indexed fee);\r\n    // Delegator events\r\n    event ShareMinted(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed amount,\r\n        uint256 tokens\r\n    );\r\n    event ShareBurned(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed amount,\r\n        uint256 tokens\r\n    );\r\n    event DelegatorClaimedRewards(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed rewards\r\n    );\r\n    event DelegatorRestaked(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed totalStaked\r\n    );\r\n    event DelegatorUnstaked(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 amount\r\n    );\r\n    event UpdateCommissionRate(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed newCommissionRate,\r\n        uint256 indexed oldCommissionRate\r\n    );\r\n\r\n    Registry public registry;\r\n\r\n    modifier onlyValidatorContract(uint256 validatorId) {\r\n        address _contract;\r\n        (, , , , , , _contract, ) = IStakeManagerLocal(\r\n            registry.getStakeManagerAddress()\r\n        )\r\n            .validators(validatorId);\r\n        require(_contract == msg.sender,\r\n        \"Invalid sender, not validator\");\r\n        _;\r\n    }\r\n\r\n    modifier StakeManagerOrValidatorContract(uint256 validatorId) {\r\n        address _contract;\r\n        address _stakeManager = registry.getStakeManagerAddress();\r\n        (, , , , , , _contract, ) = IStakeManagerLocal(_stakeManager).validators(\r\n            validatorId\r\n        );\r\n        require(_contract == msg.sender || _stakeManager == msg.sender,\r\n        \"Invalid sender, not stake manager or validator contract\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyStakeManager() {\r\n        require(registry.getStakeManagerAddress() == msg.sender,\r\n        \"Invalid sender, not stake manager\");\r\n        _;\r\n    }\r\n    modifier onlySlashingManager() {\r\n        require(registry.getSlashingManagerAddress() == msg.sender,\r\n        \"Invalid sender, not slashing manager\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _registry) public {\r\n        registry = Registry(_registry);\r\n    }\r\n\r\n    function updateNonce(\r\n        uint256[] calldata validatorIds,\r\n        uint256[] calldata nonces\r\n    ) external onlyOwner {\r\n        require(validatorIds.length == nonces.length, \"args length mismatch\");\r\n\r\n        for (uint256 i = 0; i < validatorIds.length; ++i) {\r\n            validatorNonce[validatorIds[i]] = nonces[i];\r\n        }\r\n    } \r\n\r\n    function logStaked(\r\n        address signer,\r\n        bytes memory signerPubkey,\r\n        uint256 validatorId,\r\n        uint256 activationEpoch,\r\n        uint256 amount,\r\n        uint256 total\r\n    ) public onlyStakeManager {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit Staked(\r\n            signer,\r\n            validatorId,\r\n            validatorNonce[validatorId],\r\n            activationEpoch,\r\n            amount,\r\n            total,\r\n            signerPubkey\r\n        );\r\n    }\r\n\r\n    function logUnstaked(\r\n        address user,\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        uint256 total\r\n    ) public onlyStakeManager {\r\n        emit Unstaked(user, validatorId, amount, total);\r\n    }\r\n\r\n    function logUnstakeInit(\r\n        address user,\r\n        uint256 validatorId,\r\n        uint256 deactivationEpoch,\r\n        uint256 amount\r\n    ) public onlyStakeManager {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit UnstakeInit(\r\n            user,\r\n            validatorId,\r\n            validatorNonce[validatorId],\r\n            deactivationEpoch,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function logSignerChange(\r\n        uint256 validatorId,\r\n        address oldSigner,\r\n        address newSigner,\r\n        bytes memory signerPubkey\r\n    ) public onlyStakeManager {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit SignerChange(\r\n            validatorId,\r\n            validatorNonce[validatorId],\r\n            oldSigner,\r\n            newSigner,\r\n            signerPubkey\r\n        );\r\n    }\r\n\r\n    function logRestaked(uint256 validatorId, uint256 amount, uint256 total)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit Restaked(validatorId, amount, total);\r\n    }\r\n\r\n    function logJailed(uint256 validatorId, uint256 exitEpoch, address signer)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit Jailed(validatorId, exitEpoch, signer);\r\n    }\r\n\r\n    function logUnjailed(uint256 validatorId, address signer)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit UnJailed(validatorId, signer);\r\n    }\r\n\r\n    function logSlashed(uint256 nonce, uint256 amount)\r\n        public\r\n        onlySlashingManager\r\n    {\r\n        emit Slashed(nonce, amount);\r\n    }\r\n\r\n    function logThresholdChange(uint256 newThreshold, uint256 oldThreshold)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit ThresholdChange(newThreshold, oldThreshold);\r\n    }\r\n\r\n    function logDynastyValueChange(uint256 newDynasty, uint256 oldDynasty)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit DynastyValueChange(newDynasty, oldDynasty);\r\n    }\r\n\r\n    function logProposerBonusChange(\r\n        uint256 newProposerBonus,\r\n        uint256 oldProposerBonus\r\n    ) public onlyStakeManager {\r\n        emit ProposerBonusChange(newProposerBonus, oldProposerBonus);\r\n    }\r\n\r\n    function logRewardUpdate(uint256 newReward, uint256 oldReward)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit RewardUpdate(newReward, oldReward);\r\n    }\r\n\r\n    function logStakeUpdate(uint256 validatorId)\r\n        public\r\n        StakeManagerOrValidatorContract(validatorId)\r\n    {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit StakeUpdate(\r\n            validatorId,\r\n            validatorNonce[validatorId],\r\n            totalValidatorStake(validatorId)\r\n        );\r\n    }\r\n\r\n    function logClaimRewards(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        uint256 totalAmount\r\n    ) public onlyStakeManager {\r\n        emit ClaimRewards(validatorId, amount, totalAmount);\r\n    }\r\n\r\n    function logStartAuction(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        uint256 auctionAmount\r\n    ) public onlyStakeManager {\r\n        emit StartAuction(validatorId, amount, auctionAmount);\r\n    }\r\n\r\n    function logConfirmAuction(\r\n        uint256 newValidatorId,\r\n        uint256 oldValidatorId,\r\n        uint256 amount\r\n    ) public onlyStakeManager {\r\n        emit ConfirmAuction(newValidatorId, oldValidatorId, amount);\r\n    }\r\n\r\n    function logTopUpFee(address user, uint256 fee) public onlyStakeManager {\r\n        emit TopUpFee(user, fee);\r\n    }\r\n\r\n    function logClaimFee(address user, uint256 fee) public onlyStakeManager {\r\n        emit ClaimFee(user, fee);\r\n    }\r\n\r\n    function getStakerDetails(uint256 validatorId)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 amount,\r\n            uint256 reward,\r\n            uint256 activationEpoch,\r\n            uint256 deactivationEpoch,\r\n            address signer,\r\n            uint256 _status\r\n        )\r\n    {\r\n        IStakeManagerLocal stakeManager = IStakeManagerLocal(\r\n            registry.getStakeManagerAddress()\r\n        );\r\n        address _contract;\r\n        IStakeManagerLocal.Status status;\r\n        (\r\n            amount,\r\n            reward,\r\n            activationEpoch,\r\n            deactivationEpoch,\r\n            ,\r\n            signer,\r\n            _contract,\r\n            status\r\n        ) = stakeManager.validators(validatorId);\r\n        _status = uint256(status);\r\n        if (_contract != address(0x0)) {\r\n            reward += IStakeManagerLocal(_contract).validatorRewards();\r\n        }\r\n    }\r\n\r\n    function totalValidatorStake(uint256 validatorId)\r\n        public\r\n        view\r\n        returns (uint256 validatorStake)\r\n    {\r\n        address contractAddress;\r\n        (validatorStake, , , , , , contractAddress, ) = IStakeManagerLocal(\r\n            registry.getStakeManagerAddress()\r\n        )\r\n            .validators(validatorId);\r\n        if (contractAddress != address(0x0)) {\r\n            validatorStake += IStakeManagerLocal(contractAddress).activeAmount();\r\n        }\r\n    }\r\n\r\n    function getAccountStateRoot()\r\n        public\r\n        view\r\n        returns (bytes32 accountStateRoot)\r\n    {\r\n        accountStateRoot = IStakeManagerLocal(registry.getStakeManagerAddress())\r\n            .accountStateRoot();\r\n    }\r\n\r\n    function getValidatorContractAddress(uint256 validatorId)\r\n        public\r\n        view\r\n        returns (address ValidatorContract)\r\n    {\r\n        (, , , , , , ValidatorContract, ) = IStakeManagerLocal(\r\n            registry.getStakeManagerAddress()\r\n        )\r\n            .validators(validatorId);\r\n    }\r\n\r\n    // validator Share contract logging func\r\n    function logShareMinted(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 amount,\r\n        uint256 tokens\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit ShareMinted(validatorId, user, amount, tokens);\r\n    }\r\n\r\n    function logShareBurned(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 amount,\r\n        uint256 tokens\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit ShareBurned(validatorId, user, amount, tokens);\r\n    }\r\n\r\n    function logDelegatorClaimRewards(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 rewards\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit DelegatorClaimedRewards(validatorId, user, rewards);\r\n    }\r\n\r\n    function logDelegatorRestaked(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 totalStaked\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit DelegatorRestaked(validatorId, user, totalStaked);\r\n    }\r\n\r\n    function logDelegatorUnstaked(uint256 validatorId, address user, uint256 amount)\r\n        public\r\n        onlyValidatorContract(validatorId)\r\n    {\r\n        emit DelegatorUnstaked(validatorId, user, amount);\r\n    }\r\n\r\n    // deprecated\r\n    function logUpdateCommissionRate(\r\n        uint256 validatorId,\r\n        uint256 newCommissionRate,\r\n        uint256 oldCommissionRate\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit UpdateCommissionRate(\r\n            validatorId,\r\n            newCommissionRate,\r\n            oldCommissionRate\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/Initializable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract Initializable {\r\n    bool inited = false;\r\n\r\n    modifier initializer() {\r\n        require(!inited, \"already inited\");\r\n        inited = true;\r\n        \r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/staking/EventsHub.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract IStakeManagerEventsHub {\r\n    struct Validator {\r\n        uint256 amount;\r\n        uint256 reward;\r\n        uint256 activationEpoch;\r\n        uint256 deactivationEpoch;\r\n        uint256 jailTime;\r\n        address signer;\r\n        address contractAddress;\r\n    }\r\n\r\n    mapping(uint256 => Validator) public validators;\r\n}\r\n\r\ncontract EventsHub is Initializable {\r\n    Registry public registry;\r\n\r\n    modifier onlyValidatorContract(uint256 validatorId) {\r\n        address _contract;\r\n        (, , , , , , _contract) = IStakeManagerEventsHub(registry.getStakeManagerAddress()).validators(validatorId);\r\n        require(_contract == msg.sender, \"not validator\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyStakeManager() {\r\n        require(registry.getStakeManagerAddress() == msg.sender,\r\n        \"Invalid sender, not stake manager\");\r\n        _;\r\n    }\r\n\r\n    function initialize(Registry _registry) external initializer {\r\n        registry = _registry;\r\n    }\r\n\r\n    event ShareBurnedWithId(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed amount,\r\n        uint256 tokens,\r\n        uint256 nonce\r\n    );\r\n\r\n    function logShareBurnedWithId(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 amount,\r\n        uint256 tokens,\r\n        uint256 nonce\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit ShareBurnedWithId(validatorId, user, amount, tokens, nonce);\r\n    }\r\n\r\n    event DelegatorUnstakeWithId(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 nonce\r\n    );\r\n\r\n    function logDelegatorUnstakedWithId(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 amount,\r\n        uint256 nonce\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit DelegatorUnstakeWithId(validatorId, user, amount, nonce);\r\n    }\r\n\r\n    event RewardParams(\r\n        uint256 rewardDecreasePerCheckpoint,\r\n        uint256 maxRewardedCheckpoints,\r\n        uint256 checkpointRewardDelta\r\n    );\r\n\r\n    function logRewardParams(\r\n        uint256 rewardDecreasePerCheckpoint,\r\n        uint256 maxRewardedCheckpoints,\r\n        uint256 checkpointRewardDelta\r\n    ) public onlyStakeManager {\r\n        emit RewardParams(rewardDecreasePerCheckpoint, maxRewardedCheckpoints, checkpointRewardDelta);\r\n    }\r\n\r\n    event UpdateCommissionRate(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed newCommissionRate,\r\n        uint256 indexed oldCommissionRate\r\n    );\r\n\r\n    function logUpdateCommissionRate(\r\n        uint256 validatorId,\r\n        uint256 newCommissionRate,\r\n        uint256 oldCommissionRate\r\n    ) public onlyStakeManager {\r\n        emit UpdateCommissionRate(\r\n            validatorId,\r\n            newCommissionRate,\r\n            oldCommissionRate\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/Lockable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract Lockable {\r\n    bool public locked;\r\n\r\n    modifier onlyWhenUnlocked() {\r\n        _assertUnlocked();\r\n        _;\r\n    }\r\n\r\n    function _assertUnlocked() private view {\r\n        require(!locked, \"locked\");\r\n    }\r\n\r\n    function lock() public {\r\n        locked = true;\r\n    }\r\n\r\n    function unlock() public {\r\n        locked = false;\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/OwnableLockable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract OwnableLockable is Lockable, Ownable {\r\n    function lock() public onlyOwner {\r\n        super.lock();\r\n    }\r\n\r\n    function unlock() public onlyOwner {\r\n        super.unlock();\r\n    }\r\n}\r\n\r\n// File: contracts/staking/stakeManager/IStakeManager.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract IStakeManager {\r\n    // validator replacement\r\n    function startAuction(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external;\r\n\r\n    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;\r\n\r\n    function transferFunds(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool);\r\n\r\n    function delegationDeposit(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool);\r\n\r\n    function unstake(uint256 validatorId) external;\r\n\r\n    function totalStakedFor(address addr) external view returns (uint256);\r\n\r\n    function stakeFor(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 heimdallFee,\r\n        bool acceptDelegation,\r\n        bytes memory signerPubkey\r\n    ) public;\r\n\r\n    function checkSignatures(\r\n        uint256 blockInterval,\r\n        bytes32 voteHash,\r\n        bytes32 stateRoot,\r\n        address proposer,\r\n        uint[3][] calldata sigs\r\n    ) external returns (uint256);\r\n\r\n    function updateValidatorState(uint256 validatorId, int256 amount) public;\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address);\r\n\r\n    function slash(bytes calldata slashingInfoList) external returns (uint256);\r\n\r\n    function validatorStake(uint256 validatorId) public view returns (uint256);\r\n\r\n    function epoch() public view returns (uint256);\r\n\r\n    function getRegistry() public view returns (address);\r\n\r\n    function withdrawalDelay() public view returns (uint256);\r\n\r\n    function delegatedAmount(uint256 validatorId) public view returns(uint256);\r\n\r\n    function decreaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) public;\r\n\r\n    function withdrawDelegatorsReward(uint256 validatorId) public returns(uint256);\r\n\r\n    function delegatorsReward(uint256 validatorId) public view returns(uint256);\r\n\r\n    function dethroneAndStake(\r\n        address auctionUser,\r\n        uint256 heimdallFee,\r\n        uint256 validatorId,\r\n        uint256 auctionAmount,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external;\r\n}\r\n\r\n// File: contracts/staking/validatorShare/IValidatorShare.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n// note this contract interface is only for stakeManager use\r\ncontract IValidatorShare {\r\n    function withdrawRewards() public;\r\n\r\n    function unstakeClaimTokens() public;\r\n\r\n    function getLiquidRewards(address user) public view returns (uint256);\r\n    \r\n    function owner() public view returns (address);\r\n\r\n    function restake() public returns(uint256, uint256);\r\n\r\n    function unlock() external;\r\n\r\n    function lock() external;\r\n\r\n    function drain(\r\n        address token,\r\n        address payable destination,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function slash(uint256 valPow, uint256 delegatedAmount, uint256 totalAmountToSlash) external returns (uint256);\r\n\r\n    function updateDelegation(bool delegation) external;\r\n\r\n    function migrateOut(address user, uint256 amount) external;\r\n\r\n    function migrateIn(address user, uint256 amount) external;\r\n}\r\n\r\n// File: contracts/staking/validatorShare/ValidatorShare.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ValidatorShare is IValidatorShare, ERC20NonTradable, OwnableLockable, Initializable {\r\n    struct DelegatorUnbond {\r\n        uint256 shares;\r\n        uint256 withdrawEpoch;\r\n    }\r\n\r\n    uint256 constant EXCHANGE_RATE_PRECISION = 100;\r\n    // maximum matic possible, even if rate will be 1 and all matic will be staken in one go, it will result in 10 ^ 58 shares\r\n    uint256 constant EXCHANGE_RATE_HIGH_PRECISION = 10**29;\r\n    uint256 constant MAX_COMMISION_RATE = 100;\r\n    uint256 constant REWARD_PRECISION = 10**25;\r\n\r\n    StakingInfo public stakingLogger;\r\n    IStakeManager public stakeManager;\r\n    uint256 public validatorId;\r\n    uint256 public validatorRewards_deprecated;\r\n    uint256 public commissionRate_deprecated;\r\n    uint256 public lastCommissionUpdate_deprecated;\r\n    uint256 public minAmount;\r\n\r\n    uint256 public totalStake_deprecated;\r\n    uint256 public rewardPerShare;\r\n    uint256 public activeAmount;\r\n\r\n    bool public delegation;\r\n\r\n    uint256 public withdrawPool;\r\n    uint256 public withdrawShares;\r\n\r\n    mapping(address => uint256) amountStaked_deprecated; // deprecated, keep for foundation delegators\r\n    mapping(address => DelegatorUnbond) public unbonds;\r\n    mapping(address => uint256) public initalRewardPerShare;\r\n\r\n    mapping(address => uint256) public unbondNonces;\r\n    mapping(address => mapping(uint256 => DelegatorUnbond)) public unbonds_new;\r\n\r\n    EventsHub public eventsHub;\r\n\r\n    // onlyOwner will prevent this contract from initializing, since it's owner is going to be 0x0 address\r\n    function initialize(\r\n        uint256 _validatorId,\r\n        address _stakingLogger,\r\n        address _stakeManager\r\n    ) external initializer {\r\n        validatorId = _validatorId;\r\n        stakingLogger = StakingInfo(_stakingLogger);\r\n        stakeManager = IStakeManager(_stakeManager);\r\n        _transferOwnership(_stakeManager);\r\n        _getOrCacheEventsHub();\r\n\r\n        minAmount = 10**18;\r\n        delegation = true;\r\n    }\r\n\r\n    /**\r\n        Public View Methods\r\n    */\r\n\r\n    function exchangeRate() public view returns (uint256) {\r\n        uint256 totalShares = totalSupply();\r\n        uint256 precision = _getRatePrecision();\r\n        return totalShares == 0 ? precision : stakeManager.delegatedAmount(validatorId).mul(precision).div(totalShares);\r\n    }\r\n\r\n    function getTotalStake(address user) public view returns (uint256, uint256) {\r\n        uint256 shares = balanceOf(user);\r\n        uint256 rate = exchangeRate();\r\n        if (shares == 0) {\r\n            return (0, rate);\r\n        }\r\n\r\n        return (rate.mul(shares).div(_getRatePrecision()), rate);\r\n    }\r\n\r\n    function withdrawExchangeRate() public view returns (uint256) {\r\n        uint256 precision = _getRatePrecision();\r\n        if (validatorId < 8) {\r\n            // fix of potentially broken withdrawals for future unbonding\r\n            // foundation validators have no slashing enabled and thus we can return default exchange rate\r\n            // because without slashing rate will stay constant\r\n            return precision;\r\n        }\r\n\r\n        uint256 _withdrawShares = withdrawShares;\r\n        return _withdrawShares == 0 ? precision : withdrawPool.mul(precision).div(_withdrawShares);\r\n    }\r\n\r\n    function getLiquidRewards(address user) public view returns (uint256) {\r\n        return _calculateReward(user, getRewardPerShare());\r\n    }\r\n\r\n    function getRewardPerShare() public view returns (uint256) {\r\n        return _calculateRewardPerShareWithRewards(stakeManager.delegatorsReward(validatorId));\r\n    }\r\n\r\n    /**\r\n        Public Methods\r\n     */\r\n\r\n    function buyVoucher(uint256 _amount, uint256 _minSharesToMint) public returns(uint256 amountToDeposit) {\r\n        _withdrawAndTransferReward(msg.sender);\r\n        \r\n        amountToDeposit = _buyShares(_amount, _minSharesToMint, msg.sender);\r\n        require(stakeManager.delegationDeposit(validatorId, amountToDeposit, msg.sender), \"deposit failed\");\r\n        \r\n        return amountToDeposit;\r\n    }\r\n\r\n    function restake() public returns(uint256, uint256) {\r\n        address user = msg.sender;\r\n        uint256 liquidReward = _withdrawReward(user);\r\n        uint256 amountRestaked;\r\n\r\n        require(liquidReward >= minAmount, \"Too small rewards to restake\");\r\n\r\n        if (liquidReward != 0) {\r\n            amountRestaked = _buyShares(liquidReward, 0, user);\r\n\r\n            if (liquidReward > amountRestaked) {\r\n                // return change to the user\r\n                require(\r\n                    stakeManager.transferFunds(validatorId, liquidReward - amountRestaked, user),\r\n                    \"Insufficent rewards\"\r\n                );\r\n                stakingLogger.logDelegatorClaimRewards(validatorId, user, liquidReward - amountRestaked);\r\n            }\r\n\r\n            (uint256 totalStaked, ) = getTotalStake(user);\r\n            stakingLogger.logDelegatorRestaked(validatorId, user, totalStaked);\r\n        }\r\n        \r\n        return (amountRestaked, liquidReward);\r\n    }\r\n\r\n    function sellVoucher(uint256 claimAmount, uint256 maximumSharesToBurn) public {\r\n        (uint256 shares, uint256 _withdrawPoolShare) = _sellVoucher(claimAmount, maximumSharesToBurn);\r\n\r\n        DelegatorUnbond memory unbond = unbonds[msg.sender];\r\n        unbond.shares = unbond.shares.add(_withdrawPoolShare);\r\n        // refresh undond period\r\n        unbond.withdrawEpoch = stakeManager.epoch();\r\n        unbonds[msg.sender] = unbond;\r\n\r\n        StakingInfo logger = stakingLogger;\r\n        logger.logShareBurned(validatorId, msg.sender, claimAmount, shares);\r\n        logger.logStakeUpdate(validatorId);\r\n    }\r\n\r\n    function withdrawRewards() public {\r\n        uint256 rewards = _withdrawAndTransferReward(msg.sender);\r\n        require(rewards >= minAmount, \"Too small rewards amount\");\r\n    }\r\n\r\n    function migrateOut(address user, uint256 amount) external onlyOwner {\r\n        _withdrawAndTransferReward(user);\r\n        (uint256 totalStaked, uint256 rate) = getTotalStake(user);\r\n        require(totalStaked >= amount, \"Migrating too much\");\r\n\r\n        uint256 precision = _getRatePrecision();\r\n        uint256 shares = amount.mul(precision).div(rate);\r\n        _burn(user, shares);\r\n\r\n        stakeManager.updateValidatorState(validatorId, -int256(amount));\r\n        activeAmount = activeAmount.sub(amount);\r\n\r\n        stakingLogger.logShareBurned(validatorId, user, amount, shares);\r\n        stakingLogger.logStakeUpdate(validatorId);\r\n        stakingLogger.logDelegatorUnstaked(validatorId, user, amount);\r\n    }\r\n\r\n    function migrateIn(address user, uint256 amount) external onlyOwner {\r\n        _withdrawAndTransferReward(user);\r\n        _buyShares(amount, 0, user);\r\n    }\r\n\r\n    function unstakeClaimTokens() public {\r\n        DelegatorUnbond memory unbond = unbonds[msg.sender];\r\n        uint256 amount = _unstakeClaimTokens(unbond);\r\n        delete unbonds[msg.sender];\r\n        stakingLogger.logDelegatorUnstaked(validatorId, msg.sender, amount);\r\n    }\r\n\r\n    function slash(\r\n        uint256 validatorStake,\r\n        uint256 delegatedAmount,\r\n        uint256 totalAmountToSlash\r\n    ) external onlyOwner returns (uint256) {\r\n        uint256 _withdrawPool = withdrawPool;\r\n        uint256 delegationAmount = delegatedAmount.add(_withdrawPool);\r\n        if (delegationAmount == 0) {\r\n            return 0;\r\n        }\r\n        // total amount to be slashed from delegation pool (active + inactive)\r\n        uint256 _amountToSlash = delegationAmount.mul(totalAmountToSlash).div(validatorStake.add(delegationAmount));\r\n        uint256 _amountToSlashWithdrawalPool = _withdrawPool.mul(_amountToSlash).div(delegationAmount);\r\n\r\n        // slash inactive pool\r\n        uint256 stakeSlashed = _amountToSlash.sub(_amountToSlashWithdrawalPool);\r\n        stakeManager.decreaseValidatorDelegatedAmount(validatorId, stakeSlashed);\r\n        activeAmount = activeAmount.sub(stakeSlashed);\r\n\r\n        withdrawPool = withdrawPool.sub(_amountToSlashWithdrawalPool);\r\n        return _amountToSlash;\r\n    }\r\n\r\n    function updateDelegation(bool _delegation) external onlyOwner {\r\n        delegation = _delegation;\r\n    }\r\n\r\n    function drain(\r\n        address token,\r\n        address payable destination,\r\n        uint256 amount\r\n    ) external onlyOwner {\r\n        if (token == address(0x0)) {\r\n            destination.transfer(amount);\r\n        } else {\r\n            require(ERC20(token).transfer(destination, amount), \"Drain failed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n        New shares exit API\r\n     */\r\n\r\n    function sellVoucher_new(uint256 claimAmount, uint256 maximumSharesToBurn) public {\r\n        (uint256 shares, uint256 _withdrawPoolShare) = _sellVoucher(claimAmount, maximumSharesToBurn);\r\n\r\n        uint256 unbondNonce = unbondNonces[msg.sender].add(1);\r\n\r\n        DelegatorUnbond memory unbond = DelegatorUnbond({\r\n            shares: _withdrawPoolShare,\r\n            withdrawEpoch: stakeManager.epoch()\r\n        });\r\n        unbonds_new[msg.sender][unbondNonce] = unbond;\r\n        unbondNonces[msg.sender] = unbondNonce;\r\n\r\n        _getOrCacheEventsHub().logShareBurnedWithId(validatorId, msg.sender, claimAmount, shares, unbondNonce);\r\n        stakingLogger.logStakeUpdate(validatorId);\r\n    }\r\n\r\n    function unstakeClaimTokens_new(uint256 unbondNonce) public {\r\n        DelegatorUnbond memory unbond = unbonds_new[msg.sender][unbondNonce];\r\n        uint256 amount = _unstakeClaimTokens(unbond);\r\n        delete unbonds_new[msg.sender][unbondNonce];\r\n        _getOrCacheEventsHub().logDelegatorUnstakedWithId(validatorId, msg.sender, amount, unbondNonce);\r\n    }\r\n\r\n    /**\r\n        Private Methods\r\n     */\r\n\r\n    function _getOrCacheEventsHub() private returns(EventsHub) {\r\n        EventsHub _eventsHub = eventsHub;\r\n        if (_eventsHub == EventsHub(0x0)) {\r\n            _eventsHub = EventsHub(Registry(stakeManager.getRegistry()).contractMap(keccak256(\"eventsHub\")));\r\n            eventsHub = _eventsHub;\r\n        }\r\n        return _eventsHub;\r\n    }\r\n\r\n    function _sellVoucher(uint256 claimAmount, uint256 maximumSharesToBurn) private returns(uint256, uint256) {\r\n        // first get how much staked in total and compare to target unstake amount\r\n        (uint256 totalStaked, uint256 rate) = getTotalStake(msg.sender);\r\n        require(totalStaked != 0 && totalStaked >= claimAmount, \"Too much requested\");\r\n\r\n        // convert requested amount back to shares\r\n        uint256 precision = _getRatePrecision();\r\n        uint256 shares = claimAmount.mul(precision).div(rate);\r\n        require(shares <= maximumSharesToBurn, \"too much slippage\");\r\n\r\n        _withdrawAndTransferReward(msg.sender);\r\n\r\n        _burn(msg.sender, shares);\r\n        stakeManager.updateValidatorState(validatorId, -int256(claimAmount));\r\n        activeAmount = activeAmount.sub(claimAmount);\r\n\r\n        uint256 _withdrawPoolShare = claimAmount.mul(precision).div(withdrawExchangeRate());\r\n        withdrawPool = withdrawPool.add(claimAmount);\r\n        withdrawShares = withdrawShares.add(_withdrawPoolShare);\r\n\r\n        return (shares, _withdrawPoolShare);\r\n    }\r\n\r\n    function _unstakeClaimTokens(DelegatorUnbond memory unbond) private returns(uint256) {\r\n        uint256 shares = unbond.shares;\r\n        require(\r\n            unbond.withdrawEpoch.add(stakeManager.withdrawalDelay()) <= stakeManager.epoch() && shares > 0,\r\n            \"Incomplete withdrawal period\"\r\n        );\r\n\r\n        uint256 _amount = withdrawExchangeRate().mul(shares).div(_getRatePrecision());\r\n        withdrawShares = withdrawShares.sub(shares);\r\n        withdrawPool = withdrawPool.sub(_amount);\r\n\r\n        require(stakeManager.transferFunds(validatorId, _amount, msg.sender), \"Insufficent rewards\");\r\n\r\n        return _amount;\r\n    }\r\n\r\n    function _getRatePrecision() private view returns (uint256) {\r\n        // if foundation validator, use old precision\r\n        if (validatorId < 8) {\r\n            return EXCHANGE_RATE_PRECISION;\r\n        }\r\n\r\n        return EXCHANGE_RATE_HIGH_PRECISION;\r\n    }\r\n\r\n    function _calculateRewardPerShareWithRewards(uint256 accumulatedReward) private view returns (uint256) {\r\n        uint256 _rewardPerShare = rewardPerShare;\r\n        if (accumulatedReward != 0) {\r\n            uint256 totalShares = totalSupply();\r\n            \r\n            if (totalShares != 0) {\r\n                _rewardPerShare = _rewardPerShare.add(accumulatedReward.mul(REWARD_PRECISION).div(totalShares));\r\n            }\r\n        }\r\n\r\n        return _rewardPerShare;\r\n    }\r\n\r\n    function _calculateReward(address user, uint256 _rewardPerShare) private view returns (uint256) {\r\n        uint256 shares = balanceOf(user);\r\n        if (shares == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 _initialRewardPerShare = initalRewardPerShare[user];\r\n\r\n        if (_initialRewardPerShare == _rewardPerShare) {\r\n            return 0;\r\n        }\r\n\r\n        return _rewardPerShare.sub(_initialRewardPerShare).mul(shares).div(REWARD_PRECISION);\r\n    }\r\n\r\n    function _withdrawReward(address user) private returns (uint256) {\r\n        uint256 _rewardPerShare = _calculateRewardPerShareWithRewards(\r\n            stakeManager.withdrawDelegatorsReward(validatorId)\r\n        );\r\n        uint256 liquidRewards = _calculateReward(user, _rewardPerShare);\r\n        \r\n        rewardPerShare = _rewardPerShare;\r\n        initalRewardPerShare[user] = _rewardPerShare;\r\n        return liquidRewards;\r\n    }\r\n\r\n    function _withdrawAndTransferReward(address user) private returns (uint256) {\r\n        uint256 liquidRewards = _withdrawReward(user);\r\n        if (liquidRewards != 0) {\r\n            require(stakeManager.transferFunds(validatorId, liquidRewards, user), \"Insufficent rewards\");\r\n            stakingLogger.logDelegatorClaimRewards(validatorId, user, liquidRewards);\r\n        }\r\n        return liquidRewards;\r\n    }\r\n\r\n    function _buyShares(\r\n        uint256 _amount,\r\n        uint256 _minSharesToMint,\r\n        address user\r\n    ) private onlyWhenUnlocked returns (uint256) {\r\n        require(delegation, \"Delegation is disabled\");\r\n\r\n        uint256 rate = exchangeRate();\r\n        uint256 precision = _getRatePrecision();\r\n        uint256 shares = _amount.mul(precision).div(rate);\r\n        require(shares >= _minSharesToMint, \"Too much slippage\");\r\n        require(unbonds[user].shares == 0, \"Ongoing exit\");\r\n\r\n        _mint(user, shares);\r\n\r\n        // clamp amount of tokens in case resulted shares requires less tokens than anticipated\r\n        _amount = rate.mul(shares).div(precision);\r\n\r\n        stakeManager.updateValidatorState(validatorId, int256(_amount));\r\n        activeAmount = activeAmount.add(_amount);\r\n\r\n        StakingInfo logger = stakingLogger;\r\n        logger.logShareMinted(validatorId, user, _amount, shares);\r\n        logger.logStakeUpdate(validatorId);\r\n\r\n        return _amount;\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // get rewards for recipient \r\n        _withdrawAndTransferReward(to);\r\n        // convert rewards to shares\r\n        _withdrawAndTransferReward(from);\r\n        // move shares to recipient\r\n        super._transfer(from, to, value);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"activeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minSharesToMint\",\"type\":\"uint256\"}],\"name\":\"buyVoucher\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToDeposit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionRate_deprecated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delegation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eventsHub\",\"outputs\":[{\"internalType\":\"contract EventsHub\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLiquidRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRewardPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getTotalStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"initalRewardPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_validatorId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_stakingLogger\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakeManager\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastCommissionUpdate_deprecated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"migrateIn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"migrateOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumSharesToBurn\",\"type\":\"uint256\"}],\"name\":\"sellVoucher\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumSharesToBurn\",\"type\":\"uint256\"}],\"name\":\"sellVoucher_new\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delegatedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountToSlash\",\"type\":\"uint256\"}],\"name\":\"slash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakeManager\",\"outputs\":[{\"internalType\":\"contract IStakeManager\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingLogger\",\"outputs\":[{\"internalType\":\"contract StakingInfo\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStake_deprecated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"unbondNonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"unbonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawEpoch\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unbonds_new\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawEpoch\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unstakeClaimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unbondNonce\",\"type\":\"uint256\"}],\"name\":\"unstakeClaimTokens_new\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_delegation\",\"type\":\"bool\"}],\"name\":\"updateDelegation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validatorId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validatorRewards_deprecated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ValidatorShare","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://e0717f62363177110fcfd3ec1db08ba11d62877157d14e00a22e8a3237b30379"}]}