{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/connectors/maker.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\ninterface TokenInterface {\\n    function approve(address, uint) external;\\n    function transfer(address, uint) external;\\n    function transferFrom(address, address, uint) external;\\n    function deposit() external payable;\\n    function withdraw(uint) external;\\n    function balanceOf(address) external view returns (uint);\\n}\\n\\ninterface ManagerLike {\\n    function cdpCan(address, uint, address) external view returns (uint);\\n    function ilks(uint) external view returns (bytes32);\\n    function last(address) external view returns (uint);\\n    function count(address) external view returns (uint);\\n    function owns(uint) external view returns (address);\\n    function urns(uint) external view returns (address);\\n    function vat() external view returns (address);\\n    function open(bytes32, address) external returns (uint);\\n    function give(uint, address) external;\\n    function frob(uint, int, int) external;\\n    function flux(uint, address, uint) external;\\n    function move(uint, address, uint) external;\\n}\\n\\ninterface VatLike {\\n    function can(address, address) external view returns (uint);\\n    function ilks(bytes32) external view returns (uint, uint, uint, uint, uint);\\n    function dai(address) external view returns (uint);\\n    function urns(bytes32, address) external view returns (uint, uint);\\n    function frob(\\n        bytes32,\\n        address,\\n        address,\\n        address,\\n        int,\\n        int\\n    ) external;\\n    function hope(address) external;\\n    function move(address, address, uint) external;\\n    function gem(bytes32, address) external view returns (uint);\\n\\n}\\n\\ninterface TokenJoinInterface {\\n    function dec() external returns (uint);\\n    function gem() external returns (TokenInterface);\\n    function join(address, uint) external payable;\\n    function exit(address, uint) external;\\n}\\n\\ninterface DaiJoinInterface {\\n    function vat() external returns (VatLike);\\n    function dai() external returns (TokenInterface);\\n    function join(address, uint) external payable;\\n    function exit(address, uint) external;\\n}\\n\\ninterface JugLike {\\n    function drip(bytes32) external returns (uint);\\n}\\n\\ninterface PotLike {\\n    function pie(address) external view returns (uint);\\n    function drip() external returns (uint);\\n    function join(uint) external;\\n    function exit(uint) external;\\n}\\n\\ninterface InstaMapping {\\n    function gemJoinMapping(bytes32) external view returns (address);\\n}\\n\\ncontract DSMath {\\n\\n    uint256 constant RAY = 10 ** 27;\\n    uint constant WAD = 10 ** 18;\\n\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, \\\"math-not-safe\\\");\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, \\\"sub-overflow\\\");\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"math-not-safe\\\");\\n    }\\n\\n    function wmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n\\n    function toInt(uint x) internal pure returns (int y) {\\n        y = int(x);\\n        require(y >= 0, \\\"int-overflow\\\");\\n    }\\n\\n    function toRad(uint wad) internal pure returns (uint rad) {\\n        rad = mul(wad, 10 ** 27);\\n    }\\n\\n    function convertTo18(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\\n        amt = mul(_amt, 10 ** (18 - _dec));\\n    }\\n\\n    function convert18ToDec(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\\n        amt = (_amt / 10 ** (18 - _dec));\\n    }\\n}\\n\\n\\ncontract Helpers is DSMath {\\n    /**\\n     * @dev Return ethereum address\\n     */\\n    function getAddressETH() internal pure returns (address) {\\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\\n    }\\n\\n    function getAddressWETH() internal pure returns (address) {\\n        return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // mainnet\\n    }\\n\\n    function isETH(address token) internal pure returns(bool) {\\n        return token == getAddressETH() || token == getAddressWETH();\\n    }\\n}\\n\\n\\ncontract MakerMCDAddresses is Helpers {\\n    /**\\n     * @dev Return Maker MCD Manager Address.\\n    */\\n    function getMcdManager() internal pure returns (address) {\\n        return 0x5ef30b9986345249bc32d8928B7ee64DE9435E39; //mainnet\\n    }\\n\\n    /**\\n     * @dev Return Maker MCD DAI_Join Address.\\n    */\\n    function getMcdDaiJoin() internal pure returns (address) {\\n        return 0x9759A6Ac90977b93B58547b4A71c78317f391A28; // mainnet\\n    }\\n\\n    /**\\n     * @dev Return Maker MCD Jug Address.\\n    */\\n    function getMcdJug() internal pure returns (address) {\\n        return 0x19c0976f590D67707E62397C87829d896Dc0f1F1; // mainnet\\n    }\\n}\\n\\ncontract MakerHelpers is MakerMCDAddresses {\\n    /**\\n     * @dev Return InstaMapping Address.\\n     */\\n    function getMappingAddr() internal pure returns (address) {\\n        return 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88;\\n    }\\n\\n    /**\\n     * @dev Get Vault's ilk.\\n    */\\n    function getVaultData(ManagerLike managerContract, uint vault) internal view returns (bytes32 ilk, address urn) {\\n        ilk = managerContract.ilks(vault);\\n        urn = managerContract.urns(vault);\\n    }\\n\\n    /**\\n     * @dev Gem Join address is ETH type collateral.\\n    */\\n    function isGemEth(address tknAddr) internal pure returns (bool) {\\n        return tknAddr == getAddressWETH();\\n    }\\n\\n    /**\\n     * @dev Get Vault Debt Amount.\\n    */\\n    function _getVaultDebt(\\n        address vat,\\n        bytes32 ilk,\\n        address urn\\n    ) internal view returns (uint wad) {\\n        (, uint rate,,,) = VatLike(vat).ilks(ilk);\\n        (, uint art) = VatLike(vat).urns(ilk, urn);\\n        uint dai = VatLike(vat).dai(urn);\\n\\n        uint rad = sub(mul(art, rate), dai);\\n        wad = rad / RAY;\\n\\n        wad = mul(wad, RAY) < rad ? wad + 1 : wad;\\n    }\\n\\n    /**\\n     * @dev Get Borrow Amount.\\n    */\\n    function _getBorrowAmt(\\n        address vat,\\n        address urn,\\n        bytes32 ilk,\\n        uint amt\\n    ) internal returns (int dart)\\n    {\\n        address jug = getMcdJug();\\n        uint rate = JugLike(jug).drip(ilk);\\n        uint dai = VatLike(vat).dai(urn);\\n        if (dai < mul(amt, RAY)) {\\n            dart = toInt(sub(mul(amt, RAY), dai) / rate);\\n            dart = mul(uint(dart), rate) < mul(amt, RAY) ? dart + 1 : dart;\\n        }\\n    }\\n\\n    /**\\n     * @dev Get Payback Amount.\\n    */\\n    function _getWipeAmt(\\n        address vat,\\n        uint amt,\\n        address urn,\\n        bytes32 ilk\\n    ) internal view returns (int dart)\\n    {\\n        (, uint rate,,,) = VatLike(vat).ilks(ilk);\\n        (, uint art) = VatLike(vat).urns(ilk, urn);\\n        dart = toInt(amt / rate);\\n        dart = uint(dart) <= art ? - dart : - toInt(art);\\n    }\\n\\n}\\n\\ncontract BasicResolver is MakerHelpers {\\n    event LogDeposit(uint256 indexed vault, bytes32 indexed ilk, uint256 tokenAmt);\\n    event LogWithdraw(uint256 indexed vault, bytes32 indexed ilk, uint256 tokenAmt);\\n    event LogBorrow(uint256 indexed vault, bytes32 indexed ilk, uint256 tokenAmt);\\n    event LogPayback(uint256 indexed vault, bytes32 indexed ilk, uint256 tokenAmt);\\n\\n    /**\\n     * @dev Deposit ETH/ERC20_Token Collateral.\\n     * @param vault Vault ID.\\n     * @param amt token amount to deposit.\\n    */\\n    function deposit(uint vault, uint amt) external payable\\n    {\\n        ManagerLike managerContract = ManagerLike(getMcdManager());\\n\\n        uint _amt = amt;\\n        (bytes32 ilk, address urn) = getVaultData(managerContract, vault);\\n\\n        address colAddr = InstaMapping(getMappingAddr()).gemJoinMapping(ilk);\\n        TokenJoinInterface tokenJoinContract = TokenJoinInterface(colAddr);\\n        TokenInterface tokenContract = tokenJoinContract.gem();\\n\\n        if (isGemEth(address(tokenContract))) {\\n            _amt = _amt == uint(-1) ? address(this).balance : _amt;\\n            tokenContract.deposit{value: _amt}();\\n        } else {\\n            _amt = _amt == uint(-1) ?  tokenContract.balanceOf(address(this)) : _amt;\\n        }\\n\\n        tokenContract.approve(address(colAddr), _amt);\\n        tokenJoinContract.join(address(this), _amt);\\n\\n        VatLike(managerContract.vat()).frob(\\n            ilk,\\n            urn,\\n            address(this),\\n            address(this),\\n            toInt(convertTo18(tokenJoinContract.dec(), _amt)),\\n            0\\n        );\\n\\n        emit LogDeposit(vault, ilk, _amt);\\n    }\\n\\n    /**\\n     * @dev Withdraw ETH/ERC20_Token Collateral.\\n     * @param vault Vault ID.\\n     * @param amt token amount to withdraw.\\n    */\\n    function withdraw(uint vault, uint amt) external payable {\\n        ManagerLike managerContract = ManagerLike(getMcdManager());\\n\\n        uint _amt = amt;\\n        (bytes32 ilk, address urn) = getVaultData(managerContract, vault);\\n\\n        address colAddr = InstaMapping(getMappingAddr()).gemJoinMapping(ilk);\\n        TokenJoinInterface tokenJoinContract = TokenJoinInterface(colAddr);\\n\\n        uint _amt18;\\n        if (_amt == uint(-1)) {\\n            (_amt18,) = VatLike(managerContract.vat()).urns(ilk, urn);\\n            _amt = convert18ToDec(tokenJoinContract.dec(), _amt18);\\n        } else {\\n            _amt18 = convertTo18(tokenJoinContract.dec(), _amt);\\n        }\\n\\n        managerContract.frob(\\n            vault,\\n            -toInt(_amt18),\\n            0\\n        );\\n\\n        managerContract.flux(\\n            vault,\\n            address(this),\\n            _amt18\\n        );\\n\\n        TokenInterface tokenContract = tokenJoinContract.gem();\\n\\n        if (isGemEth(address(tokenContract))) {\\n            tokenJoinContract.exit(address(this), _amt);\\n            tokenContract.withdraw(_amt);\\n        } else {\\n            tokenJoinContract.exit(address(this), _amt);\\n        }\\n\\n        \\n\\n        emit LogWithdraw(vault, ilk, _amt);\\n    }\\n\\n    /**\\n     * @dev Borrow DAI.\\n     * @param vault Vault ID.\\n     * @param amt token amount to borrow.\\n    */\\n    function borrow(uint vault, uint amt) external payable {\\n        ManagerLike managerContract = ManagerLike(getMcdManager());\\n\\n        uint _amt = amt;\\n        (bytes32 ilk, address urn) = getVaultData(managerContract, vault);\\n\\n        address daiJoin = getMcdDaiJoin();\\n\\n        VatLike vatContract = VatLike(managerContract.vat());\\n\\n        managerContract.frob(\\n            vault,\\n            0,\\n            _getBorrowAmt(\\n                address(vatContract),\\n                urn,\\n                ilk,\\n                _amt\\n            )\\n        );\\n\\n        managerContract.move(\\n            vault,\\n            address(this),\\n            toRad(_amt)\\n        );\\n\\n        if (vatContract.can(address(this), address(daiJoin)) == 0) {\\n            vatContract.hope(daiJoin);\\n        }\\n\\n        DaiJoinInterface(daiJoin).exit(address(this), _amt);\\n\\n        emit LogBorrow(vault, ilk, _amt);\\n\\n    }\\n\\n    /**\\n     * @dev Payback borrowed DAI.\\n     * @param vault Vault ID.\\n     * @param amt token amount to payback.\\n    */\\n    function payback(uint vault, uint amt) external payable {\\n        ManagerLike managerContract = ManagerLike(getMcdManager());\\n        uint _amt = amt;\\n        (bytes32 ilk, address urn) = getVaultData(managerContract, vault);\\n\\n        address vat = managerContract.vat();\\n\\n        uint _maxDebt = _getVaultDebt(vat, ilk, urn);\\n\\n        _amt = _amt == uint(-1) ? _maxDebt : _amt;\\n\\n        require(_maxDebt >= _amt, \\\"paying-excess-debt\\\");\\n\\n        DaiJoinInterface daiJoinContract = DaiJoinInterface(getMcdDaiJoin());\\n        daiJoinContract.dai().approve(getMcdDaiJoin(), _amt);\\n        daiJoinContract.join(urn, _amt);\\n\\n        managerContract.frob(\\n            vault,\\n            0,\\n            _getWipeAmt(\\n                vat,\\n                VatLike(vat).dai(urn),\\n                urn,\\n                ilk\\n            )\\n        );\\n\\n        emit LogPayback(vault, ilk, _amt);\\n    }\\n}\\n\\ncontract ConnectMaker is  BasicResolver {\\n    string public constant name = \\\"MakerDAO-v1.0\\\";\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vault\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"}],\"name\":\"LogBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vault\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"}],\"name\":\"LogDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vault\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"}],\"name\":\"LogPayback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vault\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"payback\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"ConnectMaker","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}