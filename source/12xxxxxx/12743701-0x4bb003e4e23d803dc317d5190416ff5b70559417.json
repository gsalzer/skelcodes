{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.2;\r\n\r\ninterface IERC20Token {\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n}\r\n\r\ninterface IERC721 {\r\n\r\n    function setPaymentDate(uint256 _asset) external;\r\n    function getTokenDetails(uint256 index) external view returns (uint32 aType, uint32 customDetails, uint32 lastTx, uint32 lastPayment, uint256 initialvalue, string memory coin);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n}\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n   \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    \r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n   \r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    \r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n   \r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n  \r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\ncontract PolkaProfitContract is Ownable {\r\n    \r\n    event Payment(address indexed to, uint256 amount, uint8 network, uint256 gasFee);\r\n    \r\n    bool public paused;\r\n\r\n    struct Claim {\r\n        address account;\r\n        uint8 dNetwork;  // 1= Ethereum   2= BSC\r\n        uint256 assetId;\r\n        uint256 amount;\r\n        uint256 date;\r\n    }\r\n    \r\n    Claim[] public payments;\r\n    \r\n    mapping (address => bool) public blackListed;\r\n    mapping (uint256 => uint256) public weeklyByType;\r\n    address public nftAddress = 0xB20217bf3d89667Fa15907971866acD6CcD570C8;\r\n    address public tokenAddress = 0xaA8330FB2B4D5D07ABFE7A72262752a8505C6B37;\r\n    address payable public walletAddress;\r\n    uint256 public gasFee = 1000000000000000;\r\n    mapping (uint256 => uint256) public bankWithdraws;\r\n    uint256 public bankEarnings;\r\n    address bridgeContract;\r\n    \r\n\r\n    uint256 wUnit = 1 weeks;\r\n    \r\n    constructor() {\r\n        weeklyByType[20] = 18 ether;\r\n        weeklyByType[22] = 4 ether;\r\n        weeklyByType[23] = 3 ether;\r\n        weeklyByType[25] = 1041 ether;\r\n        weeklyByType[26] = 44 ether;\r\n        weeklyByType[29] = 3125 ether;\r\n        weeklyByType[30] = 29 ether;\r\n        weeklyByType[31] = 5 ether;\r\n        weeklyByType[32] = 20 ether;\r\n        weeklyByType[34] = 10 ether;\r\n        weeklyByType[36] = 70 ether;\r\n        weeklyByType[37] = 105 ether;\r\n        weeklyByType[38] = 150 ether;\r\n        weeklyByType[39] = 600 ether;\r\n        weeklyByType[40] = 20 ether;\r\n        \r\n        walletAddress = payable(0xAD334543437EF71642Ee59285bAf2F4DAcBA613F);\r\n        bridgeContract = 0x0A0b052D93EaA7C67F498fb3F8D9f4f56456BA51;\r\n    }\r\n    \r\n    function profitsPayment(uint256 _assetId) public returns (bool success) {\r\n        require(paused == false, \"Contract is paused\");\r\n        IERC721 nft = IERC721(nftAddress);\r\n        address assetOwner = nft.ownerOf(_assetId);\r\n        require(assetOwner == msg.sender, \"Only asset owner can claim profits\");\r\n        require(blackListed[assetOwner] == false, \"This address cannot claim profits\");\r\n        (uint256 totalPayment, ) = calcProfit(_assetId);\r\n        require (totalPayment > 0, \"You need to wait at least 1 week to claim\");\r\n        nft.setPaymentDate(_assetId);\r\n        IERC20Token token = IERC20Token(tokenAddress);\r\n        require(token.transferFrom(walletAddress, assetOwner, totalPayment), \"ERC20 transfer fail\");\r\n        Claim memory thisclaim = Claim(msg.sender, 1, _assetId, totalPayment, block.timestamp);\r\n        payments.push(thisclaim);\r\n        emit Payment(msg.sender, totalPayment, 1, 0);\r\n        return true;\r\n    }\r\n    \r\n    function profitsPaymentBSC(uint256 _assetId) public payable returns (bool success) {\r\n        require(paused == false, \"Contract is paused\");\r\n        require(msg.value >= gasFee, \"Gas fee too low\");\r\n        IERC721 nft = IERC721(nftAddress);\r\n        address assetOwner = nft.ownerOf(_assetId);\r\n        require(assetOwner == msg.sender, \"Only asset owner can claim profits\");\r\n        require(blackListed[assetOwner] == false, \"This address cannot claim profits\");\r\n        (uint256 totalPayment, ) = calcProfit(_assetId);\r\n        require (totalPayment > 0, \"You need to wait at least 1 week to claim\");\r\n        nft.setPaymentDate(_assetId);\r\n        Address.sendValue(walletAddress, msg.value);\r\n        Claim memory thisclaim = Claim(msg.sender, 2, _assetId, totalPayment, block.timestamp);\r\n        payments.push(thisclaim);\r\n        emit Payment(msg.sender, totalPayment, 2, msg.value);\r\n        return true;\r\n    }\r\n    \r\n    function calcProfit(uint256 _assetId) public view returns (uint256 _profit, uint256 _lastPayment) {\r\n        IERC721 nft = IERC721(nftAddress);\r\n        (uint32 assetType,, uint32 lastTransfer, uint32 lastPayment,, ) = nft.getTokenDetails(_assetId);\r\n        uint256 cTime = block.timestamp - lastTransfer;\r\n        uint256 dTime = 0;\r\n        if (lastTransfer < lastPayment) {\r\n            dTime = lastPayment - lastTransfer;\r\n        }\r\n        if ((cTime) < wUnit) { \r\n            return (0, lastTransfer);\r\n        } else {\r\n             uint256 weekCount;  \r\n            if (dTime == 0) {\r\n                weekCount = ((cTime)/(wUnit));\r\n            } else {\r\n                weekCount = ((cTime)/(wUnit)) - (dTime)/(wUnit);\r\n            }\r\n            if (weekCount < 1) {\r\n                return (0, lastPayment);\r\n            } else {\r\n                uint256 totalPayment;\r\n                totalPayment = ((weekCount * weeklyByType[assetType]));\r\n                return (totalPayment, lastPayment);  \r\n                \r\n            }\r\n        }\r\n    }\r\n    \r\n    function calcTotalEarnings(uint256 _assetId) public view returns (uint256 _profit, uint256 _lastPayment) {\r\n        IERC721 nft = IERC721(nftAddress);\r\n        (uint32 assetType,, uint32 lastTransfer,,, ) = nft.getTokenDetails(_assetId);\r\n        uint256 timeFrame = block.timestamp - lastTransfer;\r\n        if (timeFrame < wUnit) {  \r\n            return (0, lastTransfer);\r\n        } else {\r\n            uint256 weekCount = timeFrame/(wUnit); \r\n            uint256 totalPayment;\r\n            totalPayment = ((weekCount * weeklyByType[assetType]));\r\n            return (totalPayment, lastTransfer);    \r\n        }\r\n\r\n    }\r\n    \r\n\r\n    function pauseContract(bool _paused) public onlyOwner {\r\n        paused = _paused;\r\n    }\r\n    \r\n    function blackList(address _wallet, bool _blacklist) public onlyOwner {\r\n        blackListed[_wallet] = _blacklist;\r\n    }\r\n\r\n    function paymentCount() public view returns (uint256 _paymentCount) {\r\n        return payments.length;\r\n    }\r\n    \r\n    function paymentDetail(uint256 _paymentIndex) public view returns (address _to, uint8 _network, uint256 assetId, uint256 _amount, uint256 _date) {\r\n        Claim memory thisPayment = payments[_paymentIndex];\r\n        return (thisPayment.account, thisPayment.dNetwork, thisPayment.assetId, thisPayment.amount, thisPayment.date);\r\n    }\r\n    \r\n    function addType(uint256 _aType, uint256 _weekly) public onlyOwner {\r\n        weeklyByType[_aType] = _weekly;\r\n    }\r\n    \r\n    function setGasFee(uint256 _gasFee) public onlyOwner {\r\n        gasFee = _gasFee;\r\n    }\r\n    \r\n    function setWalletAddress(address _wallet) public onlyOwner {\r\n        walletAddress = payable(_wallet);\r\n    }\r\n    \r\n    function setBridgeContract(address _contract) public onlyOwner {\r\n        bridgeContract = _contract;\r\n    }\r\n    \r\n    function addBankEarnings(uint256 _amount) public {\r\n        require(msg.sender == bridgeContract, \"Not Allowed\");\r\n        bankEarnings += _amount;\r\n    }\r\n    \r\n    function claimBankEarnings(uint256 _assetId) public {\r\n        IERC721 nft = IERC721(nftAddress);\r\n        (uint32 assetType,,,,, ) = nft.getTokenDetails(_assetId);\r\n        address assetOwner = nft.ownerOf(_assetId);\r\n        require(assetType == 33, \"Invalid asset\");\r\n        uint256 toPay = bankEarnings - bankWithdraws[_assetId];\r\n        if (toPay > 0) {\r\n            bankWithdraws[_assetId] = bankEarnings;\r\n            IERC20Token token = IERC20Token(tokenAddress);\r\n            require(token.transferFrom(walletAddress, assetOwner, toPay), \"ERC20 transfer fail\");\r\n            emit Payment(assetOwner, toPay, 2, 0);\r\n        }\r\n    }\r\n    \r\n    function claimBankEarningsBSC(uint256 _assetId) public payable {\r\n        IERC721 nft = IERC721(nftAddress);\r\n        (uint32 assetType,,,,, ) = nft.getTokenDetails(_assetId);\r\n        address assetOwner = nft.ownerOf(_assetId);\r\n        require(assetType == 33, \"Invalid asset\");\r\n        uint256 toPay = bankEarnings - bankWithdraws[_assetId];\r\n        if (toPay > 0) {\r\n            bankWithdraws[_assetId] = bankEarnings;\r\n            Claim memory thisclaim = Claim(assetOwner, 2, _assetId, toPay, block.timestamp);\r\n            payments.push(thisclaim);\r\n            emit Payment(assetOwner, toPay, 2, msg.value);\r\n        }\r\n\r\n    }\r\n    \r\n\r\n\r\n    \r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"network\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasFee\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addBankEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_aType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_weekly\",\"type\":\"uint256\"}],\"name\":\"addType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bankEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bankWithdraws\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_blacklist\",\"type\":\"bool\"}],\"name\":\"blackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blackListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"calcProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_profit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastPayment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"calcTotalEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_profit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastPayment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"claimBankEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"claimBankEarningsBSC\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"pauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_paymentCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_paymentIndex\",\"type\":\"uint256\"}],\"name\":\"paymentDetail\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_network\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_date\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payments\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"dNetwork\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"profitsPayment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"profitsPaymentBSC\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"setBridgeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasFee\",\"type\":\"uint256\"}],\"name\":\"setGasFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setWalletAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"weeklyByType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PolkaProfitContract","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0fd40cba0c420fd87166757ce413512f0fd86cbd7ab350406f0c89db5b8e5774"}]}