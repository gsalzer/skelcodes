{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PermanentStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"./interfaces/IPermanentStorage.sol\\\";\\nimport \\\"./utils/lib_storage/PSStorage.sol\\\";\\n\\ncontract PermanentStorage is IPermanentStorage {\\n\\n    // Constants do not have storage slot.\\n    bytes32 public constant curveTokenIndexStorageId = 0xf4c750cdce673f6c35898d215e519b86e3846b1f0532fb48b84fe9d80f6de2fc; // keccak256(\\\"curveTokenIndex\\\")\\n    bytes32 public constant transactionSeenStorageId = 0x695d523b8578c6379a2121164fd8de334b9c5b6b36dff5408bd4051a6b1704d0;  // keccak256(\\\"transactionSeen\\\")\\n    bytes32 public constant relayerValidStorageId = 0x2c97779b4deaf24e9d46e02ec2699240a957d92782b51165b93878b09dd66f61;  // keccak256(\\\"relayerValid\\\")\\n\\n    // New supported Curve pools\\n    address public constant CURVE_renBTC_POOL = 0x93054188d876f558f4a66B2EF1d97d16eDf0895B;\\n    address public constant CURVE_sBTC_POOL = 0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714;\\n    address public constant CURVE_hBTC_POOL = 0x4CA9b3063Ec5866A4B82E437059D2C43d1be596F;\\n    address public constant CURVE_sETH_POOL = 0xc5424B857f758E906013F3555Dad202e4bdB4567;\\n\\n    // Curve coins\\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant renBTC = 0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D;\\n    address private constant wBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\\n    address private constant sBTC = 0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6;\\n    address private constant hBTC = 0x0316EB71485b0Ab14103307bf65a021042c6d380;\\n    address private constant sETH = 0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb;\\n\\n    // Below are the variables which consume storage slots.\\n    address public operator;\\n    string public version;  // Current version of the contract\\n    mapping(bytes32 => mapping(address => bool)) private permission;\\n\\n\\n    // Operator events\\n    event TransferOwnership(address newOperator);\\n    event SetPermission(bytes32 storageId, address role, bool enabled);\\n    event UpgradeAMMWrapper(address newAMMWrapper);\\n    event UpgradePMM(address newPMM);\\n    event UpgradeRFQ(address newRFQ);\\n    event UpgradeWETH(address newWETH);\\n\\n\\n    /************************************************************\\n    *          Access control and ownership management          *\\n    *************************************************************/\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"PermanentStorage: not the operator\\\");\\n        _;\\n    }\\n\\n    modifier validRole(bool _enabled, address _role) {\\n        if (_enabled) {\\n            require(\\n                (_role == operator) || (_role == ammWrapperAddr()) || (_role == pmmAddr() || (_role == rfqAddr())),\\n                \\\"PermanentStorage: not a valid role\\\"\\n            );\\n        }\\n        _;\\n    }\\n\\n    modifier isPermitted(bytes32 _storageId, address _role) {\\n        require(permission[_storageId][_role], \\\"PermanentStorage: has no permission\\\");\\n        _;\\n    }\\n\\n\\n    function transferOwnership(address _newOperator) external onlyOperator {\\n        require(_newOperator != address(0), \\\"PermanentStorage: operator can not be zero address\\\");\\n        operator = _newOperator;\\n\\n        emit TransferOwnership(_newOperator);\\n    }\\n\\n    /// @dev Set permission for entity to write certain storage.\\n    function setPermission(bytes32 _storageId, address _role, bool _enabled) external onlyOperator validRole(_enabled, _role) {\\n        permission[_storageId][_role] = _enabled;\\n\\n        emit SetPermission(_storageId, _role, _enabled);\\n    }\\n\\n\\n    /************************************************************\\n    *              Constructor and init functions               *\\n    *************************************************************/\\n    /// @dev Replacing constructor and initialize the contract. This function should only be called once.\\n    function initialize() external {\\n        require(\\n            keccak256(abi.encodePacked(version)) == keccak256(abi.encodePacked(\\\"5.1.0\\\")),\\n            \\\"PermanentStorage: not upgrading from 5.1.0 version\\\"\\n        );\\n        // upgrade from 5.1.0 to 5.2.0\\n        version = \\\"5.2.0\\\";\\n        // register renBTC pool\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_renBTC_POOL][renBTC] = 1; // renBTC\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_renBTC_POOL][wBTC] = 2; // wBTC\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_renBTC_POOL] = false;\\n\\n        // register sBTC pool\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sBTC_POOL][renBTC] = 1; // renBTC\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sBTC_POOL][wBTC] = 2; // wBTC\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sBTC_POOL][sBTC] = 3; // sBTC\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_sBTC_POOL] = false;\\n\\n        // register hBTC pool\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_hBTC_POOL][hBTC] = 1; // hBTC\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_hBTC_POOL][wBTC] = 2; // wBTC\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_hBTC_POOL] = false;\\n\\n        // register sETH pool\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sETH_POOL][ETH] = 1; // ETH\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sETH_POOL][sETH] = 2; // sETH\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_sETH_POOL] = false;\\n    }\\n\\n\\n    /************************************************************\\n    *                     Getter functions                      *\\n    *************************************************************/\\n    function hasPermission(bytes32 _storageId, address _role) external view returns (bool) {\\n        return permission[_storageId][_role];\\n    }\\n\\n    function ammWrapperAddr() public view returns (address) {\\n        return PSStorage.getStorage().ammWrapperAddr;\\n    }\\n\\n    function pmmAddr() public view returns (address) {\\n        return PSStorage.getStorage().pmmAddr;\\n    }\\n\\n    function rfqAddr() public view returns (address) {\\n        return PSStorage.getStorage().rfqAddr;\\n    }\\n\\n    function wethAddr() override external view returns (address) {\\n        return PSStorage.getStorage().wethAddr;\\n    }\\n\\n    function getCurvePoolInfo(address _makerAddr, address _takerAssetAddr, address _makerAssetAddr) override external view returns (int128 takerAssetIndex, int128 makerAssetIndex, uint16 swapMethod, bool supportGetDx) {\\n        // underlying_coins\\n        int128 i = AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][_takerAssetAddr];\\n        int128 j = AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][_makerAssetAddr];\\n        supportGetDx = AMMWrapperStorage.getStorage().curveSupportGetDx[_makerAddr];\\n\\n        swapMethod = 0;\\n        if (i != 0 && j != 0) {\\n            // in underlying_coins list\\n            takerAssetIndex = i;\\n            makerAssetIndex = j;\\n            // exchange_underlying\\n            swapMethod = 2;\\n        } else {\\n            // in coins list\\n            int128 iWrapped = AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[_makerAddr][_takerAssetAddr];\\n            int128 jWrapped = AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[_makerAddr][_makerAssetAddr];\\n            if (iWrapped != 0 && jWrapped != 0) {\\n                takerAssetIndex = iWrapped;\\n                makerAssetIndex = jWrapped;\\n                // exchange\\n                swapMethod = 1;\\n            } else {\\n                revert(\\\"PermanentStorage: invalid pair\\\");\\n            }\\n        }\\n        return (takerAssetIndex, makerAssetIndex, swapMethod, supportGetDx);\\n    }\\n\\n    /* \\n    NOTE: `isTransactionSeen` is replaced by `isAMMTransactionSeen`. It is kept for backward compatability.\\n    It should be removed from AMM 5.2.1 upward.\\n    */\\n    function isTransactionSeen(bytes32 _transactionHash) override external view returns (bool) {\\n        return AMMWrapperStorage.getStorage().transactionSeen[_transactionHash];\\n    }\\n\\n    function isAMMTransactionSeen(bytes32 _transactionHash) override external view returns (bool) {\\n        return AMMWrapperStorage.getStorage().transactionSeen[_transactionHash];\\n    }\\n\\n    function isRFQTransactionSeen(bytes32 _transactionHash) override external view returns (bool) {\\n        return RFQStorage.getStorage().transactionSeen[_transactionHash];\\n    }\\n\\n    function isRelayerValid(address _relayer) override external view returns (bool) {\\n        return AMMWrapperStorage.getStorage().relayerValid[_relayer];\\n    }\\n\\n\\n    /************************************************************\\n    *           Management functions for Operator               *\\n    *************************************************************/\\n    /// @dev Update AMMWrapper contract address.\\n    function upgradeAMMWrapper(address _newAMMWrapper) external onlyOperator {\\n        PSStorage.getStorage().ammWrapperAddr = _newAMMWrapper;\\n\\n        emit UpgradeAMMWrapper(_newAMMWrapper);\\n    }\\n\\n    /// @dev Update PMM contract address.\\n    function upgradePMM(address _newPMM) external onlyOperator {\\n        PSStorage.getStorage().pmmAddr = _newPMM;\\n\\n        emit UpgradePMM(_newPMM);\\n    }\\n\\n    /// @dev Update RFQ contract address.\\n    function upgradeRFQ(address _newRFQ) external onlyOperator {\\n        PSStorage.getStorage().rfqAddr = _newRFQ;\\n\\n        emit UpgradeRFQ(_newRFQ);\\n    }\\n\\n    /// @dev Update WETH contract address.\\n    function upgradeWETH(address _newWETH) external onlyOperator {\\n        PSStorage.getStorage().wethAddr = _newWETH;\\n\\n        emit UpgradeWETH(_newWETH);\\n    }\\n\\n\\n    /************************************************************\\n    *                   External functions                      *\\n    *************************************************************/\\n    function setCurvePoolInfo(address _makerAddr, address[] calldata _underlyingCoins, address[] calldata _coins, bool _supportGetDx) override external isPermitted(curveTokenIndexStorageId, msg.sender) {\\n        int128 underlyingCoinsLength = int128(_underlyingCoins.length);\\n        for (int128 i = 0 ; i < underlyingCoinsLength; i++) {\\n            address assetAddr = _underlyingCoins[uint256(i)];\\n            // underlying coins for original DAI, USDC, TUSD\\n            AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][assetAddr] = i + 1;  // Start the index from 1\\n        }\\n\\n        int128 coinsLength = int128(_coins.length);\\n        for (int128 i = 0 ; i < coinsLength; i++) {\\n            address assetAddr = _coins[uint256(i)];\\n            // wrapped coins for cDAI, cUSDC, yDAI, yUSDC, yTUSD, yBUSD\\n            AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[_makerAddr][assetAddr] = i + 1;  // Start the index from 1\\n        }\\n\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[_makerAddr] = _supportGetDx;\\n    }\\n\\n    /* \\n    NOTE: `setTransactionSeen` is replaced by `setAMMTransactionSeen`. It is kept for backward compatability.\\n    It should be removed from AMM 5.2.1 upward.\\n    */\\n    function setTransactionSeen(bytes32 _transactionHash) override external isPermitted(transactionSeenStorageId, msg.sender) {\\n        require(!AMMWrapperStorage.getStorage().transactionSeen[_transactionHash], \\\"PermanentStorage: transaction seen before\\\");\\n        AMMWrapperStorage.getStorage().transactionSeen[_transactionHash] = true;\\n    }\\n\\n    function setAMMTransactionSeen(bytes32 _transactionHash) override external isPermitted(transactionSeenStorageId, msg.sender) {\\n        require(!AMMWrapperStorage.getStorage().transactionSeen[_transactionHash], \\\"PermanentStorage: transaction seen before\\\");\\n        AMMWrapperStorage.getStorage().transactionSeen[_transactionHash] = true;\\n    }\\n\\n    function setRFQTransactionSeen(bytes32 _transactionHash) override external isPermitted(transactionSeenStorageId, msg.sender) {\\n        require(!RFQStorage.getStorage().transactionSeen[_transactionHash], \\\"PermanentStorage: transaction seen before\\\");\\n        RFQStorage.getStorage().transactionSeen[_transactionHash] = true;\\n    }\\n\\n    function setRelayersValid(address[] calldata _relayers, bool[] calldata _isValids) override external isPermitted(relayerValidStorageId, msg.sender) {\\n        require(_relayers.length == _isValids.length, \\\"PermanentStorage: inputs length mismatch\\\");\\n        for (uint256 i = 0; i < _relayers.length; i++) {\\n            AMMWrapperStorage.getStorage().relayerValid[_relayers[i]] = _isValids[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPermanentStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface IPermanentStorage {\\n    function wethAddr() external view returns (address);\\n    function getCurvePoolInfo(address _makerAddr, address _takerAssetAddr, address _makerAssetAddr) external view returns (int128 takerAssetIndex, int128 makerAssetIndex, uint16 swapMethod, bool supportGetDx);\\n    function setCurvePoolInfo(address _makerAddr, address[] calldata _underlyingCoins, address[] calldata _coins, bool _supportGetDx) external;\\n    function isTransactionSeen(bytes32 _transactionHash) external view returns (bool);  // Kept for backward compatability. Should be removed from AMM 5.2.1 upward\\n    function isAMMTransactionSeen(bytes32 _transactionHash) external view returns (bool);\\n    function isRFQTransactionSeen(bytes32 _transactionHash) external view returns (bool);\\n    function isRelayerValid(address _relayer) external view returns (bool);\\n    function setTransactionSeen(bytes32 _transactionHash) external;  // Kept for backward compatability. Should be removed from AMM 5.2.1 upward\\n    function setAMMTransactionSeen(bytes32 _transactionHash) external;\\n    function setRFQTransactionSeen(bytes32 _transactionHash) external;\\n    function setRelayersValid(address[] memory _relayers, bool[] memory _isValids) external;\\n}\"\r\n    },\r\n    \"contracts/utils/lib_storage/PSStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nlibrary PSStorage {\\n    bytes32 private constant STORAGE_SLOT = 0x92dd52b981a2dd69af37d8a3febca29ed6a974aede38ae66e4ef773173aba471;\\n\\n    struct Storage {\\n        address ammWrapperAddr;\\n        address pmmAddr;\\n        address wethAddr;\\n        address rfqAddr;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"permanent.storage.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\\n\\nlibrary AMMWrapperStorage {\\n    bytes32 private constant STORAGE_SLOT = 0xd38d862c9fa97c2fa857a46e08022d272a3579c114ca4f335f1e5fcb692c045e;\\n\\n    struct Storage {\\n        mapping(bytes32 => bool) transactionSeen;\\n        // curve pool => underlying token address => underlying token index\\n        mapping(address => mapping(address => int128)) curveTokenIndexes;\\n        mapping(address => bool) relayerValid;\\n        // 5.1.0 appended storage\\n        // curve pool => wrapped token address => wrapped token index\\n        mapping(address => mapping(address => int128)) curveWrappedTokenIndexes;\\n        mapping(address => bool) curveSupportGetDx;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"permanent.ammwrapper.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\\n\\nlibrary RFQStorage {\\n    bytes32 private constant STORAGE_SLOT = 0x9174e76494cfb023ddc1eb0effb6c12e107165382bbd0ecfddbc38ea108bbe52;\\n\\n    struct Storage {\\n        mapping(bytes32 => bool) transactionSeen;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"permanent.rfq.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"storageId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"role\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SetPermission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAMMWrapper\",\"type\":\"address\"}],\"name\":\"UpgradeAMMWrapper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPMM\",\"type\":\"address\"}],\"name\":\"UpgradePMM\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRFQ\",\"type\":\"address\"}],\"name\":\"UpgradeRFQ\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newWETH\",\"type\":\"address\"}],\"name\":\"UpgradeWETH\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CURVE_hBTC_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CURVE_renBTC_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CURVE_sBTC_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CURVE_sETH_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ammWrapperAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveTokenIndexStorageId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_makerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_takerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_makerAssetAddr\",\"type\":\"address\"}],\"name\":\"getCurvePoolInfo\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"takerAssetIndex\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"makerAssetIndex\",\"type\":\"int128\"},{\"internalType\":\"uint16\",\"name\":\"swapMethod\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"supportGetDx\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_storageId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_role\",\"type\":\"address\"}],\"name\":\"hasPermission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionHash\",\"type\":\"bytes32\"}],\"name\":\"isAMMTransactionSeen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionHash\",\"type\":\"bytes32\"}],\"name\":\"isRFQTransactionSeen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"isRelayerValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionHash\",\"type\":\"bytes32\"}],\"name\":\"isTransactionSeen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pmmAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayerValidStorageId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rfqAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionHash\",\"type\":\"bytes32\"}],\"name\":\"setAMMTransactionSeen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_makerAddr\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_underlyingCoins\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_coins\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_supportGetDx\",\"type\":\"bool\"}],\"name\":\"setCurvePoolInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_storageId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_role\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionHash\",\"type\":\"bytes32\"}],\"name\":\"setRFQTransactionSeen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_relayers\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_isValids\",\"type\":\"bool[]\"}],\"name\":\"setRelayersValid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionHash\",\"type\":\"bytes32\"}],\"name\":\"setTransactionSeen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transactionSeenStorageId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOperator\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAMMWrapper\",\"type\":\"address\"}],\"name\":\"upgradeAMMWrapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPMM\",\"type\":\"address\"}],\"name\":\"upgradePMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRFQ\",\"type\":\"address\"}],\"name\":\"upgradeRFQ\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWETH\",\"type\":\"address\"}],\"name\":\"upgradeWETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PermanentStorage","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}