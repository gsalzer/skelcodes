{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\npragma solidity 0.8.3;\r\n\r\ncontract TimeLock {\r\n    enum State {\r\n        Queued,\r\n        Executed,\r\n        Canceled\r\n    }\r\n\r\n    event SetNextAdmin(address nextAdmin);\r\n    event AcceptAdmin(address admin);\r\n    event Log(\r\n        bytes32 indexed txHash,\r\n        address indexed target,\r\n        uint value,\r\n        bytes data,\r\n        uint eta,\r\n        uint nonce,\r\n        State state\r\n    );\r\n\r\n    uint private constant GRACE_PERIOD = 14 days;\r\n    uint private constant MIN_DELAY = 1 days;\r\n    uint private constant MAX_DELAY = 30 days;\r\n\r\n    address public admin;\r\n    address public nextAdmin;\r\n\r\n    mapping(bytes32 => bool) public queued;\r\n\r\n    constructor() {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"!admin\");\r\n        _;\r\n    }\r\n\r\n    /*\r\n    @notice Set next admin\r\n    @param _nextAdmin Address of next admin\r\n    */\r\n    function setNextAdmin(address _nextAdmin) external onlyAdmin {\r\n        nextAdmin = _nextAdmin;\r\n        emit SetNextAdmin(_nextAdmin);\r\n    }\r\n\r\n    /*\r\n    @notice Set admin to msg.sender\r\n    @dev Only next admin can call\r\n    */\r\n    function acceptAdmin() external {\r\n        require(msg.sender == nextAdmin, \"!next admin\");\r\n        admin = msg.sender;\r\n        nextAdmin = address(0);\r\n        emit AcceptAdmin(msg.sender);\r\n    }\r\n\r\n    /*\r\n    @notice Compute transaction hash from inputs\r\n    @param target Address to call\r\n    @param value Amount of ETH to send\r\n    @param data Data to send to `target`\r\n    @param eta Execute Transaction After - Timestamp after which transaction can be executed\r\n    @param nonce Nonce to create unique tx hash\r\n    @dev Returns keccak256 hash computed from inputs\r\n    */\r\n    function _getTxHash(\r\n        address target,\r\n        uint value,\r\n        bytes calldata data,\r\n        uint eta,\r\n        uint nonce\r\n    ) private pure returns (bytes32) {\r\n        return keccak256(abi.encode(target, value, data, eta, nonce));\r\n    }\r\n\r\n    function getTxHash(\r\n        address target,\r\n        uint value,\r\n        bytes calldata data,\r\n        uint eta,\r\n        uint nonce\r\n    ) external pure returns (bytes32) {\r\n        return _getTxHash(target, value, data, eta, nonce);\r\n    }\r\n\r\n    /*\r\n    @notice Queue a transaction to be executed after `delay`\r\n    @param target Address to call\r\n    @param value Amount of ETH to send\r\n    @param data Data to send to `target`\r\n    @param delay Minimum amount of seconds to wait before transcation can be executed\r\n    @param nonce Nonce to create unique tx hash\r\n    */\r\n    function _queue(\r\n        address target,\r\n        uint value,\r\n        bytes calldata data,\r\n        uint delay,\r\n        uint nonce\r\n    ) private {\r\n        require(delay >= MIN_DELAY, \"delay < min\");\r\n        require(delay <= MAX_DELAY, \"delay > max\");\r\n\r\n        // execute time after\r\n        uint eta = block.timestamp + delay;\r\n        // tx hash may not be unique if eta is same\r\n        bytes32 txHash = _getTxHash(target, value, data, eta, nonce);\r\n\r\n        require(!queued[txHash], \"queued\");\r\n        queued[txHash] = true;\r\n\r\n        emit Log(txHash, target, value, data, eta, nonce, State.Queued);\r\n    }\r\n\r\n    function queue(\r\n        address target,\r\n        uint value,\r\n        bytes calldata data,\r\n        uint delay,\r\n        uint nonce\r\n    ) external onlyAdmin {\r\n        _queue(target, value, data, delay, nonce);\r\n    }\r\n\r\n    /*\r\n    @notice Batch queue transactions\r\n    */\r\n    function batchQueue(\r\n        address[] calldata targets,\r\n        uint[] calldata values,\r\n        bytes[] calldata data,\r\n        uint[] calldata delays,\r\n        uint[] calldata nonces\r\n    ) external onlyAdmin {\r\n        require(targets.length > 0, \"targets.length = 0\");\r\n        require(values.length == targets.length, \"values.length != targets.length\");\r\n        require(data.length == targets.length, \"data.length != targets.length\");\r\n        require(delays.length == targets.length, \"delays.length != targets.length\");\r\n        require(nonces.length == targets.length, \"nonces.length != targets.length\");\r\n\r\n        for (uint i = 0; i < targets.length; i++) {\r\n            _queue(targets[i], values[i], data[i], delays[i], nonces[i]);\r\n        }\r\n    }\r\n\r\n    /*\r\n    @notice Executed transaction\r\n    @param target Address to call\r\n    @param value Amount of ETH to send\r\n    @param data Data to send to `target`\r\n    @param eta Execute Transaction After - Timestamp after which transaction can be executed\r\n    @param nonce Nonce to create unique tx hash\r\n    @dev `eta` must be greater than or equal to `block.timestamp`\r\n    */\r\n    function _execute(\r\n        address target,\r\n        uint value,\r\n        bytes calldata data,\r\n        uint eta,\r\n        uint nonce\r\n    ) private {\r\n        bytes32 txHash = _getTxHash(target, value, data, eta, nonce);\r\n        require(queued[txHash], \"!queued\");\r\n        require(block.timestamp >= eta, \"eta < now\");\r\n        require(block.timestamp <= eta + GRACE_PERIOD, \"eta expired\");\r\n\r\n        queued[txHash] = false;\r\n\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, ) = target.call{value: value}(data);\r\n        require(success, \"tx failed\");\r\n\r\n        emit Log(txHash, target, value, data, eta, nonce, State.Executed);\r\n    }\r\n\r\n    function execute(\r\n        address target,\r\n        uint value,\r\n        bytes calldata data,\r\n        uint eta,\r\n        uint nonce\r\n    ) external payable onlyAdmin {\r\n        require(address(this).balance >= value, \"bal < value\");\r\n        _execute(target, value, data, eta, nonce);\r\n    }\r\n\r\n    /*\r\n    @notice Batch executed transactions\r\n    */\r\n    function batchExecute(\r\n        address[] calldata targets,\r\n        uint[] calldata values,\r\n        bytes[] calldata data,\r\n        uint[] calldata etas,\r\n        uint[] calldata nonces\r\n    ) external payable onlyAdmin {\r\n        require(targets.length > 0, \"targets.length = 0\");\r\n        require(values.length == targets.length, \"values.length != targets.length\");\r\n        require(data.length == targets.length, \"data.length != targets.length\");\r\n        require(etas.length == targets.length, \"etas.length != targets.length\");\r\n        require(nonces.length == targets.length, \"nonces.length != targets.length\");\r\n\r\n        // check total value <= balance\r\n        uint totalValue;\r\n        for (uint i = 0; i < targets.length; i++) {\r\n            totalValue += values[i];\r\n        }\r\n        require(address(this).balance >= totalValue, \"bal < total value\");\r\n\r\n        for (uint i = 0; i < targets.length; i++) {\r\n            _execute(targets[i], values[i], data[i], etas[i], nonces[i]);\r\n        }\r\n    }\r\n\r\n    /*\r\n    @notice Cancel transaction\r\n    @param target Address to call\r\n    @param value Amount of ETH to send\r\n    @param data Data to send to `target`\r\n    @param eta Execute Transaction After - Timestamp after which transaction can be executed\r\n    @param nonce Nonce to create unique tx hash\r\n    */\r\n    function cancel(\r\n        address target,\r\n        uint value,\r\n        bytes calldata data,\r\n        uint eta,\r\n        uint nonce\r\n    ) external onlyAdmin {\r\n        bytes32 txHash = _getTxHash(target, value, data, eta, nonce);\r\n        require(queued[txHash], \"!queued\");\r\n\r\n        queued[txHash] = false;\r\n\r\n        emit Log(txHash, target, value, data, eta, nonce, State.Canceled);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AcceptAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum TimeLock.State\",\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"Log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nextAdmin\",\"type\":\"address\"}],\"name\":\"SetNextAdmin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"etas\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nonces\",\"type\":\"uint256[]\"}],\"name\":\"batchExecute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"delays\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nonces\",\"type\":\"uint256[]\"}],\"name\":\"batchQueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"getTxHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"queue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"queued\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nextAdmin\",\"type\":\"address\"}],\"name\":\"setNextAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"TimeLock","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://9b8a9371f12430b748d1c8e1b002ad77c24c46125f87cfeb61fd69f1f515d028"}]}