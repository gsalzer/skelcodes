{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LadyLuck.sol\": {\r\n      \"content\": \"\\n/**\\n * WWWW.LADYLUCKCOIN.COM\\n * \\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@&#*,(&@@&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&(,&@@&&@@@@@@@@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@&@@@@\\n * @@@@@@@@@@@@@@@@@@@@@@@&@@%*(@@@@@@@&@@%(,...,,,.,,#%@@&@@@@@@@@@@@@@@@@&@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@&&(*&@&@&@@&**#@@&&@@@@@@@@@@@@@@@@@&&&@@@@@@@@@@&*,@&(,,@@\\n * @@@@@@@@@&  .%@@@@@@%*(@&@&@&*(&@@@@@@@@&&*.(&@@@@@@@@@@@@@@@@@@@@@@@@&&*..@@@@@\\n * @@@@@@@@@@&        .#@&@&&(#&@@@@@@@@&@.       &@@@@@@@@@@@@@@@@&@#@&@%*#@@@&@@@\\n * @@@@@@@@@@@@%             #@@@@@@&@@@@.        &@@@@@@@@@@@@@@&&*  .&@@@@@@@@@@@\\n * @@@@@@@@@@@@@(&((@#.            (&@@@@*        @@@@@@@@@@@&#    (@@&&@@@@@@@@@@@\\n * @@@@@@@@@@@@&&      .(@@@@#,         (@      .&@@@@@@@%.     #&@@&@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@**&            ,%@@@&,    ,     .&&.       .&@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@&@**&@%#*%@@&@@@&%(*.   (@(            &&,%@@@&@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@&#*(@@@*             .,*(#*              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@  @@@@*@@(***(((##@@@@@@@.             *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@**@@@&*@@@@@@@@@@@@@@@@@@   %         (@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@**@@@&*@@@@@@@@@@@@@@@@@&  .@%       .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@**@@@@*@@@@@@@@@@@@@@@@*  #&&        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@**(@@@#*@@@@@@@@@@@@@@@@   @&         ,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@**(@@@*#@@@@@@@@@@@@&@@  #@           *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@(**@&&@*(@@@@@@@@@@@@&*  @(            @&@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@&(**@@@@(*@@@@@@@@@@@@  (@(            *@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@&(**&@@@&*(@@@@@@@@@*  &@#             @@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@%(((@&@@%*(@@@@@@@  @@@%             @@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@&@(**(@&&&&((%&&@&@(&@@&             @@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@(***&@@@@&(((&@@&@&@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@#*(*(@@&@@@&(,,*#@,            @@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@&@@(****&@@@@@@@@@#      ..   .@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@@@@@@&&*,,,,*&@@@@*      %.   *@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&*....        @.   (@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@(          @    (@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,            @@    (@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@@@@&@@@#               %@,    (&@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@&@@@.                 @@@     ,@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@(                   &@@@,      @@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@&&.                  (&&&@&@&       &@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@&@@&@@@@@@@@@@@@@@@@&&&@@@@@@@@&@&@@@&&@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@  ██╗░░░░░░█████╗░██████╗░██╗░░░██╗██╗░░░░░██╗░░░██╗░█████╗░██╗░░██╗ @@@@@@\\n * @@@@@  ██║░░░░░██╔══██╗██╔══██╗╚██╗░██╔╝██║░░░░░██║░░░██║██╔══██╗██║░██╔╝ @@@@@@\\n * @@@@@  ██║░░░░░███████║██║░░██║░╚████╔╝░██║░░░░░██║░░░██║██║░░╚═╝█████═╝░ @@@@@@\\n * @@@@@  ██║░░░░░██╔══██║██║░░██║░░╚██╔╝░░██║░░░░░██║░░░██║██║░░██╗██╔═██╗░ @@@@@@\\n * @@@@@  ███████╗██║░░██║██████╔╝░░░██║░░░███████╗╚██████╔╝╚█████╔╝██║░╚██╗ @@@@@@\\n * @@@@@  ╚══════╝╚═╝░░╚═╝╚═════╝░░░░╚═╝░░░╚══════╝░╚═════╝░░╚════╝░╚═╝░░╚═╝ @@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n *\\n * SPDX-License-Identifier: MIT\\n * \\n */\\n \\npragma solidity ^0.8.0;\\n                     \\nabstract contract Initializable {\\n\\n    \\n    bool private _initialized;\\n\\n    bool private _initializing;\\n\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\\ncontract VRFRequestIDBase {\\n    \\n  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,\\n    address _requester, uint256 _nonce)\\n    internal pure returns (uint256)\\n  {\\n    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\n  }\\n  \\n  function makeRequestId(\\n    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\n  }\\n  \\n}\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n  function approve(address spender, uint256 value) external returns (bool success);\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n  function decimals() external view returns (uint8 decimalPlaces);\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n  function name() external view returns (string memory tokenName);\\n  function symbol() external view returns (string memory tokenSymbol);\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n  function transfer(address to, uint256 value) external returns (bool success);\\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\\n}\\n\\nlibrary SafeMathChainlink {\\n\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n    return c;\\n  }\\n\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b > 0, \\\"SafeMath: division by zero\\\");\\n    uint256 c = a / b;\\n\\n    return c;\\n  }\\n\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n    return a % b;\\n  }\\n}\\n\\nabstract contract VRFConsumerBase is Initializable, VRFRequestIDBase {\\n\\n  using SafeMathChainlink for uint256;\\n\\n  function fulfillRandomness(bytes32 requestId, uint256 randomness)\\n    internal virtual;\\n\\n  function requestRandomness(bytes32 _keyHash, uint256 _fee, uint256 _seed)\\n    internal returns (bytes32 requestId)\\n  {\\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, _seed));\\n\\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, _seed, address(this), nonces[_keyHash]);\\n\\n    nonces[_keyHash] = nonces[_keyHash].add(1);\\n    return makeRequestId(_keyHash, vRFSeed);\\n  }\\n\\n  LinkTokenInterface  internal LINK;\\n  address  private vrfCoordinator;\\n\\n  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\\n\\n    function __VRFConsumerBase_init() internal initializer {\\n        __VRFConsumerBase_init_unchained();\\n    }\\n    function __VRFConsumerBase_init_unchained() internal initializer {\\n        vrfCoordinator = 0xf0d54349aDdcf704F77AE15b96510dEA15cb7952;\\n        LINK = LinkTokenInterface(0x514910771AF9Ca656af840dff83E8264EcF986CA);\\n    }\\n\\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\\n    require(msg.sender == vrfCoordinator, \\\"Only VRFCoordinator can fulfill\\\");\\n    fulfillRandomness(requestId, randomness);\\n  }\\n\\n}\\n\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    event Paused(address account);\\n\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    function __Pausable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal initializer {\\n        _paused = false;\\n    }\\n\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    uint256[49] private __gap;\\n}\\n\\nlibrary MathUpgradeable {\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\\nlibrary ArraysUpgradeable {\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        if (array.length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        while (low < high) {\\n            uint256 mid = MathUpgradeable.average(low, high);\\n\\n            if (array[mid] > element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        if (low > 0 && array[low - 1] == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n}\\n\\nlibrary AddressUpgradeable {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            if (returndata.length > 0) {\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\\ninterface IERC20Upgradeable {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    \\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\\n    \\n    using ArraysUpgradeable for uint256[];\\n    using AddressUpgradeable for address;\\n    \\n    mapping(address => bool) internal _isHolder;\\n    mapping(uint256 => mapping(address => address)) internal _groupNextHolder;\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n    \\n    mapping (address => uint256) internal  _balances;\\n    mapping (uint256 => uint256) internal _groupHolders;\\n    mapping (address => uint256) internal _addressGroup;\\n    mapping (address => uint256) internal _weekLotto;  \\n\\n    uint256[] internal GroupIDList;\\n\\n    uint256 internal _totalSupply;\\n    string private _name;\\n    string private _symbol;\\n    \\n    uint256 public ExchangeSupply;\\n    uint256 public HoldersNum;    \\n    uint256 public WeekCounter;\\n\\n    address public MegaPot;\\n    address public LuckPot;\\n    address public DevWallet;\\n    address public MarketingWallet;\\n    \\n    address constant MOJO = address(1);\\n\\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\\n        __Context_init_unchained();\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\\n        _name = name_;\\n        _symbol = symbol_;\\n        MarketingWallet = address(0x05dD722A8478715eC4ab7CDdecB82D598A313072);\\n        MegaPot = address(0x83F9B450a5d71dC6CBeef6D8E7214181FAf5D41f);\\n        LuckPot = address(0xc4e017a03Cee1F129E93052e6b150466102B3aF5);        \\n        DevWallet = address(0x538Ca3c8ad2F0e50730E51D730b907ab993EC326); \\n        \\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function EligibleSupply() public view virtual returns (uint256){\\n        uint256 ExcludedSupply = _totalSupply - ExchangeSupply - balanceOf(MegaPot) - balanceOf(LuckPot) - balanceOf(DevWallet) - balanceOf(MarketingWallet); \\n        return ExcludedSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        \\n        if (_isHolder[account] && _weekLotto[account] < WeekCounter && account != DevWallet && account != MegaPot && account != LuckPot && account != MarketingWallet && !account.isContract()){\\n            uint256 temp = _balances[account];\\n            \\n            uint256 WeekDelta = WeekCounter - _weekLotto[account];\\n            temp = (temp * (99 ** WeekDelta))/(100** WeekDelta);\\n            return temp;\\n            \\n        } else {\\n            return _balances[account];\\n        }\\n    }\\n \\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n    \\n\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n        \\n        uint256 feeAmount =  amount/100;\\n        uint256 gasAmount = amount/100;\\n        \\n        if (sender == MegaPot || sender == LuckPot || sender == DevWallet || sender == MarketingWallet || recipient == DevWallet || recipient == MegaPot || recipient == LuckPot || recipient == MarketingWallet) {\\n            feeAmount = 0;\\n            gasAmount = 0;\\n        }        \\n\\n        uint256 senderBalance = balanceOf(sender);\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        \\n        uint256 receiveAmount = amount - feeAmount - gasAmount;\\n        \\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += receiveAmount;\\n        _balances[MegaPot] += feeAmount;\\n        _balances[MarketingWallet] += gasAmount;\\n        \\n        emit Transfer(sender, recipient, amount);\\n        emit Transfer(sender, MegaPot, feeAmount);        \\n        emit Transfer(sender, MarketingWallet, gasAmount);\\n\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n        \\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n        \\n        \\n        if(_totalSupply == 0){\\n            _totalSupply += amount;\\n        }\\n        \\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");    \\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n\\n\\n        \\n        _balances[account] = accountBalance - amount;\\n        \\n        if(account != MegaPot && account != LuckPot){\\n            _totalSupply -= amount;\\n        }\\n\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function AddGroupHolder(address holder) internal {\\n        if(_isHolder[holder] == false && holder != address(0) && holder != MegaPot && holder != LuckPot && holder != DevWallet && holder != MarketingWallet && !holder.isContract()){\\n            \\n            _isHolder[holder] = true;\\n            \\n            uint256 GroupNumber = 1;\\n            while (_groupHolders[GroupNumber] >=100){\\n                GroupNumber++;\\n            }\\n            \\n            if(_groupNextHolder[GroupNumber][MOJO] == address(0)){\\n                _groupNextHolder[GroupNumber][MOJO] = MOJO;\\n                GroupIDList.push(GroupNumber);\\n            }\\n            _groupNextHolder[GroupNumber][holder] = _groupNextHolder[GroupNumber][MOJO];\\n            _groupNextHolder[GroupNumber][MOJO] = holder;\\n            \\n            _addressGroup[holder] = GroupNumber;\\n            _groupHolders[GroupNumber]++;\\n            \\n            HoldersNum++;\\n            \\n            _weekLotto[holder] = WeekCounter;\\n\\n        }\\n    }\\n    \\n    function RemoveGroupHolder(address holder) internal {\\n        if(_isHolder[holder] == true && holder != address(0) && holder != MegaPot && holder != LuckPot && holder != DevWallet && holder != MarketingWallet && !holder.isContract()){\\n            \\n            _isHolder[holder] = false;\\n            \\n            uint256 GroupNumber = _addressGroup[holder];\\n            \\n            address prevHolder = GetPrevHolder(holder);\\n            \\n            _groupNextHolder[GroupNumber][prevHolder] = _groupNextHolder[GroupNumber][holder];\\n            _groupNextHolder[GroupNumber][holder] = address(0);\\n\\n            _addressGroup[holder] = 0;\\n            _groupHolders[GroupNumber] = _groupHolders[GroupNumber] - 1;\\n            \\n            HoldersNum = HoldersNum - 1;\\n            \\n            \\n            _weekLotto[holder] = 0;\\n                        \\n    }\\n    }\\n    \\n    function GetPrevHolder(address holder) internal view returns(address){\\n        \\n        address currentAddress = MOJO;\\n        uint256 GroupNumber = _addressGroup[holder];        \\n        \\n        while(_groupNextHolder[GroupNumber][currentAddress] != MOJO){\\n            if(_groupNextHolder[GroupNumber][currentAddress] == holder){\\n                return currentAddress;\\n            }\\n            currentAddress = _groupNextHolder[GroupNumber][currentAddress];\\n        }\\n        return address(0);\\n    }\\n    \\n    function GetGroupHolders(uint256 GroupNumber) internal view returns (address[] memory){\\n        address[] memory holders = new address[](_groupHolders[GroupNumber]);\\n        address currentAddress = _groupNextHolder[GroupNumber][MOJO];\\n        for(uint256 i = 0; currentAddress != MOJO; ++i){\\n            holders[i] = currentAddress;\\n            currentAddress = _groupNextHolder[GroupNumber][currentAddress];\\n        }\\n        return holders;\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {\\n\\n    if(to.isContract()){ExchangeSupply  =ExchangeSupply + amount;}\\n    if(from.isContract()){ExchangeSupply =ExchangeSupply - amount;}\\n    \\n    _balances[from] = balanceOf(from);\\n    _weekLotto[from] = WeekCounter;\\n    _balances[to] - balanceOf(to);\\n    _weekLotto[to] = WeekCounter;\\n    \\n    \\n    if (from == address(0)) {\\n      AddGroupHolder(to);\\n      \\n    } else if (to == address(0)) {\\n      if (balanceOf(from) - amount == 0){RemoveGroupHolder(from);}\\n      \\n    } else {\\n      AddGroupHolder(to);\\n      if (balanceOf(from) - amount == 0){RemoveGroupHolder(from);}\\n    }\\n\\n    }\\n    uint256[45] private __gap;\\n}\\n\\ncontract LadyLuck is Initializable, ERC20Upgradeable, OwnableUpgradeable, PausableUpgradeable, VRFConsumerBase  {\\n    \\n    bytes32 internal keyHash;\\n    uint256 internal fee;\\n    uint256 public randomResult;\\n    \\n    uint public LastJackpotTime;\\n    uint public NextJackpotTime;\\n    uint256 internal JackpotFreq;\\n    \\n    uint256 public JackpotStarted;  \\n    uint256 internal PreviousRandomNumber;\\n    uint256[] internal GroupBalanceList;\\n    \\n    uint256 internal WinningGroupMega; \\n    address public WinningWalletMega;\\n    uint256 public WinningNumberMega;\\n\\n    uint256 internal WinningGroupLuck;     \\n    address public WinningWalletLuck;\\n    uint256 public WinningNumberLuck;\\n\\n    uint256 internal RollingGroupTotal;    \\n    \\n    function initialize() public virtual initializer {\\n        \\n        __ERC20_init(\\\"Lady Luck\\\", \\\"LUCK\\\");\\n        \\n        __Context_init();\\n        __Pausable_init();\\n        __Ownable_init();\\n    \\n        __VRFConsumerBase_init();\\n        \\n        keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445;\\n        fee = 2 * 10 ** 18; // 0.1 LINK        \\n        \\n        _mint(DevWallet, 1000000000 * 10 ** decimals());\\n        WinningWalletMega = MegaPot;\\n        WinningWalletLuck = LuckPot;\\n        \\n        JackpotFreq = 604000;//One Week;        \\n        LastJackpotTime = block.timestamp;\\n        NextJackpotTime = block.timestamp + JackpotFreq;   \\n    }\\n    \\n    function distributeToken(address[] memory addresses, uint256 _value) public onlyOwner {\\n\\t    for( uint256 i=0;i<addresses.length;i++){\\n\\t        transfer(addresses[i], _value);\\n\\t    }\\n\\t}\\n    \\n    function PrepareLottery() public onlyOwner {\\n        /////require(block.timestamp > NextJackpotTime);\\n        uint256 NumberOfGroups = ShowGroupIDList().length;          \\n        require(JackpotStarted < NumberOfGroups, \\\"Lottery Has Already Been Prepared\\\");\\n        \\n        JackpotStarted++;\\n\\n        if(JackpotStarted == 1){\\n            _pause();\\n            delete GroupBalanceList;\\n            uint256 temp = GetTrueGroupBalance(JackpotStarted);\\n            GroupBalanceList.push(temp);\\n            RollingGroupTotal = temp;\\n            \\n        } else if(JackpotStarted <= NumberOfGroups){\\n            uint256 temp = GetTrueGroupBalance(JackpotStarted);\\n            GroupBalanceList.push(temp);\\n            RollingGroupTotal += temp;\\n        }\\n        \\n        if(JackpotStarted == NumberOfGroups){\\n            PreviousRandomNumber = randomResult;\\n            getRandomNumber(block.timestamp*block.difficulty);\\n        }\\n    }\\n\\n        \\n    function RunLuckLottery() public onlyOwner {\\n        uint256[] memory GroupIDList = ShowGroupIDList();  \\n        require(JackpotStarted == GroupIDList.length, \\\"Please Prepare Lottery Or End Mega Lottery\\\");        \\n        require(PreviousRandomNumber != randomResult, \\\"Please Wait For Chainlink To Provide The Random Number\\\");\\n        \\n        uint256 FirstRandomResult = uint256(keccak256(abi.encode(randomResult, 0)));\\n        WinningNumberLuck = FirstRandomResult % RollingGroupTotal + 1;\\n\\n        uint256 i = 0;\\n        WinningGroupLuck = 0;\\n        uint256 RollingTotal = 0;        \\n        while (WinningGroupLuck == 0){\\n            uint256 CurrentGroupBalance = GroupBalanceList[i];\\n            if (RollingTotal < WinningNumberLuck && WinningNumberLuck <= RollingTotal + CurrentGroupBalance){\\n                WinningGroupLuck = GroupIDList[i];\\n            } else {\\n                RollingTotal += CurrentGroupBalance;\\n            }\\n            i++;\\n        }\\n\\n        address[] memory GroupWinnerList = GetGroupHolders(WinningGroupLuck);\\n        \\n        for (uint j=0; j<GroupWinnerList.length; j++) {\\n            uint256 CurrentUserBalance = balanceOf(GroupWinnerList[j]);\\n            if (RollingTotal < WinningNumberLuck && WinningNumberLuck <= RollingTotal + CurrentUserBalance){\\n                  WinningWalletLuck = GroupWinnerList[j];\\n            }\\n            RollingTotal += CurrentUserBalance; \\n        }\\n        JackpotStarted++;\\n    }\\n    \\n    \\n    function RunMegaLottery() public onlyOwner {\\n\\n        uint256[] memory GroupIDList = ShowGroupIDList(); \\n        require(JackpotStarted == GroupIDList.length + 1, \\\"Please Prepare Lottery & End Luck Lottery\\\");\\n\\n        uint256 SecondRandomResult = uint256(keccak256(abi.encode(randomResult, 1)));\\n        WinningNumberMega = SecondRandomResult % RollingGroupTotal + 1;\\n        \\n        uint256 i = 0;\\n        WinningGroupMega = 0;\\n        uint256 RollingTotal = 0;        \\n        while (WinningGroupMega == 0){\\n            uint256 CurrentGroupBalance = GroupBalanceList[i];\\n            if (RollingTotal < WinningNumberMega && WinningNumberMega <= RollingTotal + CurrentGroupBalance){\\n                WinningGroupMega = GroupIDList[i];\\n            } else {\\n                RollingTotal += CurrentGroupBalance;\\n            }\\n            i++;\\n        }\\n        \\n        address[] memory GroupWinnerList = GetGroupHolders(WinningGroupMega);\\n        \\n        for (uint j=0; j<GroupWinnerList.length; j++) {\\n            uint256 CurrentUserBalance = balanceOf(GroupWinnerList[j]);\\n            if (RollingTotal < WinningNumberMega && WinningNumberMega <= RollingTotal + CurrentUserBalance){\\n                  WinningWalletMega = GroupWinnerList[j];\\n            }\\n            RollingTotal += CurrentUserBalance; \\n        }\\n        \\n        WeekCounter++;\\n        \\n        _unpause();\\n        \\n        uint256 MegaPotBalance = balanceOf(MegaPot);\\n        _burn(MegaPot, MegaPotBalance);\\n        _mint(WinningWalletMega, MegaPotBalance);\\n\\n        _mint(LuckPot, RollingGroupTotal/100);\\n    \\n        LastJackpotTime = block.timestamp;\\n        NextJackpotTime = LastJackpotTime + JackpotFreq;\\n\\n        JackpotStarted = 0;\\n    }\\n    \\n    function PayLuckWinner() public onlyOwner {\\n        uint256 LuckPotBalance = balanceOf(LuckPot);\\n        _burn(LuckPot, LuckPotBalance);\\n        _mint(WinningWalletLuck, LuckPotBalance);\\n\\n    }\\n    \\n    function GetTrueGroupBalance(uint256 Groups) internal view returns(uint256){\\n        uint256 Temp; \\n        address[] memory TempList = GetGroupHolders(Groups); \\n        for (uint j=0; j<TempList.length; j++) {\\n            Temp += balanceOf(TempList[j]);\\n        }\\n        return Temp;\\n    }    \\n    \\n    function ShowGroupIDList() internal view virtual returns(uint256[] memory){\\n        return GroupIDList;\\n    }\\n\\n    function CurrentTime() public view virtual returns (uint){\\n        return block.timestamp;\\n    }     \\n    \\n    function ChangeLotteryFreq(uint256 Freq) public onlyOwner {\\n        JackpotFreq = Freq;\\n    }\\n    \\n    function ResetLotteryStarted() public onlyOwner {\\n        JackpotStarted = 0;\\n    }\\n    \\n    function CurrentMegaPotSize() public view returns(uint256){\\n        return balanceOf(MegaPot);\\n    }    \\n    \\n    function CurrentLuckPotSize() public view returns(uint256){\\n        return balanceOf(LuckPot);\\n    }       \\n    \\n     function getRandomNumber(uint256 userProvidedSeed) internal returns (bytes32 requestId) {\\n        require(LINK.balanceOf(address(this)) >= fee, \\\"Not enough LINK - fill contract with faucet\\\");\\n        return requestRandomness(keyHash, fee, userProvidedSeed);\\n    }\\n\\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\\n        randomResult = randomness;\\n    }\\n\\n    function withdrawLink() public onlyOwner {\\n        require(LINK.transfer(msg.sender, LINK.balanceOf(address(this))), \\\"Unable to transfer\\\");\\n    }   \\n    \\n    function _beforeTokenTransfer(address from, address to, uint256 amount)\\n        internal\\n        whenNotPaused\\n        override(ERC20Upgradeable)\\n    {\\n        super._beforeTokenTransfer(from, to, amount);\\n    }\\n        \\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }    \\n\\n    function pause() public onlyOwner{\\n        _pause();\\n    }\\n\\n    function unpause() public onlyOwner{\\n        _unpause();\\n    }\\n\\n\\n        \\n    ////\\n    \\n    function resetGroup(uint256 start, uint256 end) public onlyOwner{\\n        address[] memory GroupHoldersList = GetGroupHolders(1);\\n        \\n        for (uint i=start; i<end; i++) {\\n            \\n            RemoveGroupHolder(GroupHoldersList[i]);\\n            \\n            AddGroupHolder(GroupHoldersList[i]);\\n        }\\n    }\\n\\n    function resetTotalSupply(uint256 amount) public onlyOwner{\\n        _totalSupply = amount;\\n    }\\n    \\n    ////\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Freq\",\"type\":\"uint256\"}],\"name\":\"ChangeLotteryFreq\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentLuckPotSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentMegaPotSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DevWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EligibleSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ExchangeSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HoldersNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"JackpotStarted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LastJackpotTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LuckPot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MarketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MegaPot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NextJackpotTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PayLuckWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PrepareLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ResetLotteryStarted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RunLuckLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RunMegaLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WeekCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WinningNumberLuck\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WinningNumberMega\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WinningWalletLuck\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WinningWalletMega\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"distributeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"rawFulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"resetGroup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"resetTotalSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawLink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LadyLuck","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}