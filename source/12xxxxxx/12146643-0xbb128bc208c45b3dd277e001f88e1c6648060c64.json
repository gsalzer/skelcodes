{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\npragma solidity 0.8.2;\r\n\r\n\r\nstruct BassetPersonal {\r\n    // Address of the bAsset\r\n    address addr;\r\n    // Address of the bAsset\r\n    address integrator;\r\n    // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\r\n    bool hasTxFee; // takes a byte in storage\r\n    // Status of the bAsset\r\n    BassetStatus status;\r\n}\r\n\r\nstruct BassetData {\r\n    // 1 Basset * ratio / ratioScale == x Masset (relative value)\r\n    // If ratio == 10e8 then 1 bAsset = 10 mAssets\r\n    // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\r\n    uint128 ratio;\r\n    // Amount of the Basset that is held in Collateral\r\n    uint128 vaultBalance;\r\n}\r\n\r\nabstract contract IMasset {\r\n    // Mint\r\n    function mint(\r\n        address _input,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 mintOutput);\r\n\r\n    function mintMulti(\r\n        address[] calldata _inputs,\r\n        uint256[] calldata _inputQuantities,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 mintOutput);\r\n\r\n    function getMintOutput(address _input, uint256 _inputQuantity)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 mintOutput);\r\n\r\n    function getMintMultiOutput(address[] calldata _inputs, uint256[] calldata _inputQuantities)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 mintOutput);\r\n\r\n    // Swaps\r\n    function swap(\r\n        address _input,\r\n        address _output,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 swapOutput);\r\n\r\n    function getSwapOutput(\r\n        address _input,\r\n        address _output,\r\n        uint256 _inputQuantity\r\n    ) external view virtual returns (uint256 swapOutput);\r\n\r\n    // Redemption\r\n    function redeem(\r\n        address _output,\r\n        uint256 _mAssetQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 outputQuantity);\r\n\r\n    function redeemMasset(\r\n        uint256 _mAssetQuantity,\r\n        uint256[] calldata _minOutputQuantities,\r\n        address _recipient\r\n    ) external virtual returns (uint256[] memory outputQuantities);\r\n\r\n    function redeemExactBassets(\r\n        address[] calldata _outputs,\r\n        uint256[] calldata _outputQuantities,\r\n        uint256 _maxMassetQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 mAssetRedeemed);\r\n\r\n    function getRedeemOutput(address _output, uint256 _mAssetQuantity)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 bAssetOutput);\r\n\r\n    function getRedeemExactBassetsOutput(\r\n        address[] calldata _outputs,\r\n        uint256[] calldata _outputQuantities\r\n    ) external view virtual returns (uint256 mAssetAmount);\r\n\r\n    // Views\r\n    function getBasket() external view virtual returns (bool, bool);\r\n\r\n    function getBasset(address _token)\r\n        external\r\n        view\r\n        virtual\r\n        returns (BassetPersonal memory personal, BassetData memory data);\r\n\r\n    function getBassets()\r\n        external\r\n        view\r\n        virtual\r\n        returns (BassetPersonal[] memory personal, BassetData[] memory data);\r\n\r\n    function bAssetIndexes(address) external view virtual returns (uint8);\r\n\r\n    // SavingsManager\r\n    function collectInterest() external virtual returns (uint256 swapFeesGained, uint256 newSupply);\r\n\r\n    function collectPlatformInterest()\r\n        external\r\n        virtual\r\n        returns (uint256 mintAmount, uint256 newSupply);\r\n\r\n    // Admin\r\n    function setCacheSize(uint256 _cacheSize) external virtual;\r\n\r\n    function upgradeForgeValidator(address _newForgeValidator) external virtual;\r\n\r\n    function setFees(uint256 _swapFee, uint256 _redemptionFee) external virtual;\r\n\r\n    function setTransferFeesFlag(address _bAsset, bool _flag) external virtual;\r\n\r\n    function migrateBassets(address[] calldata _bAssets, address _newIntegration) external virtual;\r\n}\r\n\r\n\r\n// Status of the Basset - has it broken its peg?\r\nenum BassetStatus {\r\n    Default,\r\n    Normal,\r\n    BrokenBelowPeg,\r\n    BrokenAbovePeg,\r\n    Blacklisted,\r\n    Liquidating,\r\n    Liquidated,\r\n    Failed\r\n}\r\n\r\nstruct BasketState {\r\n    bool undergoingRecol;\r\n    bool failed;\r\n}\r\n\r\nstruct InvariantConfig {\r\n    uint256 a;\r\n    WeightLimits limits;\r\n}\r\n\r\nstruct WeightLimits {\r\n    uint128 min;\r\n    uint128 max;\r\n}\r\n\r\nstruct FeederConfig {\r\n    uint256 supply;\r\n    uint256 a;\r\n    WeightLimits limits;\r\n}\r\n\r\nstruct AmpData {\r\n    uint64 initialA;\r\n    uint64 targetA;\r\n    uint64 rampStartTime;\r\n    uint64 rampEndTime;\r\n}\r\n\r\nstruct FeederData {\r\n    uint256 swapFee;\r\n    uint256 redemptionFee;\r\n    uint256 govFee;\r\n    uint256 pendingFees;\r\n    uint256 cacheSize;\r\n    BassetPersonal[] bAssetPersonal;\r\n    BassetData[] bAssetData;\r\n    AmpData ampData;\r\n    WeightLimits weightLimits;\r\n}\r\n\r\nstruct AssetData {\r\n    uint8 idx;\r\n    uint256 amt;\r\n    BassetPersonal personal;\r\n}\r\n\r\nstruct Asset {\r\n    uint8 idx;\r\n    address addr;\r\n    bool exists;\r\n}\r\n\r\nabstract contract IFeederPool {\r\n    // Mint\r\n    function mint(\r\n        address _input,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 mintOutput);\r\n\r\n    function mintMulti(\r\n        address[] calldata _inputs,\r\n        uint256[] calldata _inputQuantities,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 mintOutput);\r\n\r\n    function getMintOutput(address _input, uint256 _inputQuantity)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 mintOutput);\r\n\r\n    function getMintMultiOutput(address[] calldata _inputs, uint256[] calldata _inputQuantities)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 mintOutput);\r\n\r\n    // Swaps\r\n    function swap(\r\n        address _input,\r\n        address _output,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 swapOutput);\r\n\r\n    function getSwapOutput(\r\n        address _input,\r\n        address _output,\r\n        uint256 _inputQuantity\r\n    ) external view virtual returns (uint256 swapOutput);\r\n\r\n    // Redemption\r\n    function redeem(\r\n        address _output,\r\n        uint256 _mAssetQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 outputQuantity);\r\n\r\n    function redeemProportionately(\r\n        uint256 _mAssetQuantity,\r\n        uint256[] calldata _minOutputQuantities,\r\n        address _recipient\r\n    ) external virtual returns (uint256[] memory outputQuantities);\r\n\r\n    function redeemExactBassets(\r\n        address[] calldata _outputs,\r\n        uint256[] calldata _outputQuantities,\r\n        uint256 _maxMassetQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 mAssetRedeemed);\r\n\r\n    function getRedeemOutput(address _output, uint256 _mAssetQuantity)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 bAssetOutput);\r\n\r\n    function getRedeemExactBassetsOutput(\r\n        address[] calldata _outputs,\r\n        uint256[] calldata _outputQuantities\r\n    ) external view virtual returns (uint256 mAssetAmount);\r\n\r\n    // Views\r\n    function getPrice() public view virtual returns (uint256 price, uint256 k);\r\n\r\n    function getConfig() external view virtual returns (FeederConfig memory config);\r\n\r\n    function getBasset(address _token)\r\n        external\r\n        view\r\n        virtual\r\n        returns (BassetPersonal memory personal, BassetData memory data);\r\n\r\n    function getBassets()\r\n        external\r\n        view\r\n        virtual\r\n        returns (BassetPersonal[] memory personal, BassetData[] memory data);\r\n\r\n    // SavingsManager\r\n    function collectPlatformInterest()\r\n        external\r\n        virtual\r\n        returns (uint256 mintAmount, uint256 newSupply);\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Initializable {\r\n\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    // constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC205 is Context, IERC20 {\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = accountBalance - amount;\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n}\r\n\r\nabstract contract InitializableERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\r\n     */\r\n    function _initialize(\r\n        string memory nameArg,\r\n        string memory symbolArg,\r\n        uint8 decimalsArg\r\n    ) internal {\r\n        _name = nameArg;\r\n        _symbol = symbolArg;\r\n        _decimals = decimalsArg;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\nabstract contract InitializableToken is ERC205, InitializableERC20Detailed {\r\n    /**\r\n     * @dev Initialization function for implementing contract\r\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\r\n     */\r\n    function _initialize(string memory _nameArg, string memory _symbolArg) internal {\r\n        InitializableERC20Detailed._initialize(_nameArg, _symbolArg, 18);\r\n    }\r\n}\r\n\r\ncontract ModuleKeys {\r\n    // Governance\r\n    // ===========\r\n    // keccak256(\"Governance\");\r\n    bytes32 internal constant KEY_GOVERNANCE =\r\n        0x9409903de1e6fd852dfc61c9dacb48196c48535b60e25abf92acc92dd689078d;\r\n    //keccak256(\"Staking\");\r\n    bytes32 internal constant KEY_STAKING =\r\n        0x1df41cd916959d1163dc8f0671a666ea8a3e434c13e40faef527133b5d167034;\r\n    //keccak256(\"ProxyAdmin\");\r\n    bytes32 internal constant KEY_PROXY_ADMIN =\r\n        0x96ed0203eb7e975a4cbcaa23951943fa35c5d8288117d50c12b3d48b0fab48d1;\r\n\r\n    // mStable\r\n    // =======\r\n    // keccak256(\"OracleHub\");\r\n    bytes32 internal constant KEY_ORACLE_HUB =\r\n        0x8ae3a082c61a7379e2280f3356a5131507d9829d222d853bfa7c9fe1200dd040;\r\n    // keccak256(\"Manager\");\r\n    bytes32 internal constant KEY_MANAGER =\r\n        0x6d439300980e333f0256d64be2c9f67e86f4493ce25f82498d6db7f4be3d9e6f;\r\n    //keccak256(\"Recollateraliser\");\r\n    bytes32 internal constant KEY_RECOLLATERALISER =\r\n        0x39e3ed1fc335ce346a8cbe3e64dd525cf22b37f1e2104a755e761c3c1eb4734f;\r\n    //keccak256(\"MetaToken\");\r\n    bytes32 internal constant KEY_META_TOKEN =\r\n        0xea7469b14936af748ee93c53b2fe510b9928edbdccac3963321efca7eb1a57a2;\r\n    // keccak256(\"SavingsManager\");\r\n    bytes32 internal constant KEY_SAVINGS_MANAGER =\r\n        0x12fe936c77a1e196473c4314f3bed8eeac1d757b319abb85bdda70df35511bf1;\r\n    // keccak256(\"Liquidator\");\r\n    bytes32 internal constant KEY_LIQUIDATOR =\r\n        0x1e9cb14d7560734a61fa5ff9273953e971ff3cd9283c03d8346e3264617933d4;\r\n    // keccak256(\"InterestValidator\");\r\n    bytes32 internal constant KEY_INTEREST_VALIDATOR =\r\n        0xc10a28f028c7f7282a03c90608e38a4a646e136e614e4b07d119280c5f7f839f;\r\n}\r\n\r\ninterface INexus {\r\n    function governor() external view returns (address);\r\n\r\n    function getModule(bytes32 key) external view returns (address);\r\n\r\n    function proposeModule(bytes32 _key, address _addr) external;\r\n\r\n    function cancelProposedModule(bytes32 _key) external;\r\n\r\n    function acceptProposedModule(bytes32 _key) external;\r\n\r\n    function acceptProposedModules(bytes32[] calldata _keys) external;\r\n\r\n    function requestLockModule(bytes32 _key) external;\r\n\r\n    function cancelLockModule(bytes32 _key) external;\r\n\r\n    function lockModule(bytes32 _key) external;\r\n}\r\n\r\nabstract contract ImmutableModule is ModuleKeys {\r\n    INexus public immutable nexus;\r\n\r\n    /**\r\n     * @dev Initialization function for upgradable proxy contracts\r\n     * @param _nexus Nexus contract address\r\n     */\r\n    constructor(address _nexus) {\r\n        require(_nexus != address(0), \"Nexus address is zero\");\r\n        nexus = INexus(_nexus);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Governor.\r\n     */\r\n    modifier onlyGovernor() {\r\n        _onlyGovernor();\r\n        _;\r\n    }\r\n\r\n    function _onlyGovernor() internal view {\r\n        require(msg.sender == _governor(), \"Only governor can execute\");\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Governance.\r\n     *      Governance is either Governor address or Governance address.\r\n     */\r\n    modifier onlyGovernance() {\r\n        require(\r\n            msg.sender == _governor() || msg.sender == _governance(),\r\n            \"Only governance can execute\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the ProxyAdmin.\r\n     */\r\n    modifier onlyProxyAdmin() {\r\n        require(msg.sender == _proxyAdmin(), \"Only ProxyAdmin can execute\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Manager.\r\n     */\r\n    modifier onlyManager() {\r\n        require(msg.sender == _manager(), \"Only manager can execute\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns Governor address from the Nexus\r\n     * @return Address of Governor Contract\r\n     */\r\n    function _governor() internal view returns (address) {\r\n        return nexus.governor();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns Governance Module address from the Nexus\r\n     * @return Address of the Governance (Phase 2)\r\n     */\r\n    function _governance() internal view returns (address) {\r\n        return nexus.getModule(KEY_GOVERNANCE);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Staking Module address from the Nexus\r\n     * @return Address of the Staking Module contract\r\n     */\r\n    function _staking() internal view returns (address) {\r\n        return nexus.getModule(KEY_STAKING);\r\n    }\r\n\r\n    /**\r\n     * @dev Return ProxyAdmin Module address from the Nexus\r\n     * @return Address of the ProxyAdmin Module contract\r\n     */\r\n    function _proxyAdmin() internal view returns (address) {\r\n        return nexus.getModule(KEY_PROXY_ADMIN);\r\n    }\r\n\r\n    /**\r\n     * @dev Return MetaToken Module address from the Nexus\r\n     * @return Address of the MetaToken Module contract\r\n     */\r\n    function _metaToken() internal view returns (address) {\r\n        return nexus.getModule(KEY_META_TOKEN);\r\n    }\r\n\r\n    /**\r\n     * @dev Return OracleHub Module address from the Nexus\r\n     * @return Address of the OracleHub Module contract\r\n     */\r\n    function _oracleHub() internal view returns (address) {\r\n        return nexus.getModule(KEY_ORACLE_HUB);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Manager Module address from the Nexus\r\n     * @return Address of the Manager Module contract\r\n     */\r\n    function _manager() internal view returns (address) {\r\n        return nexus.getModule(KEY_MANAGER);\r\n    }\r\n\r\n    /**\r\n     * @dev Return SavingsManager Module address from the Nexus\r\n     * @return Address of the SavingsManager Module contract\r\n     */\r\n    function _savingsManager() internal view returns (address) {\r\n        return nexus.getModule(KEY_SAVINGS_MANAGER);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Recollateraliser Module address from the Nexus\r\n     * @return  Address of the Recollateraliser Module contract (Phase 2)\r\n     */\r\n    function _recollateraliser() internal view returns (address) {\r\n        return nexus.getModule(KEY_RECOLLATERALISER);\r\n    }\r\n}\r\n\r\nabstract contract PausableModule is ImmutableModule {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by Governor\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by Governor\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool internal _paused = false;\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     * Hooks into the Module to give the Governor ability to pause\r\n     * @param _nexus Nexus contract address\r\n     */\r\n    constructor(address _nexus) ImmutableModule(_nexus) {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     * @return Returns `true` when paused, otherwise `false`\r\n     */\r\n    function paused() external view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the Governor to pause, triggers stopped state.\r\n     */\r\n    function pause() external onlyGovernor whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Called by Governor to unpause, returns to normal state.\r\n     */\r\n    function unpause() external onlyGovernor whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\ncontract InitializableReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    function _initializeReentrancyGuard() internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\ninterface IBasicToken {\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nlibrary SafeCast {\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary StableMath {\r\n    /**\r\n     * @dev Scaling unit for use in specific calculations,\r\n     * where 1 * 10**18, or 1e18 represents a unit '1'\r\n     */\r\n    uint256 private constant FULL_SCALE = 1e18;\r\n\r\n    /**\r\n     * @dev Token Ratios are used when converting between units of bAsset, mAsset and MTA\r\n     * Reasoning: Takes into account token decimals, and difference in base unit (i.e. grams to Troy oz for gold)\r\n     * bAsset ratio unit for use in exact calculations,\r\n     * where (1 bAsset unit * bAsset.ratio) / ratioScale == x mAsset unit\r\n     */\r\n    uint256 private constant RATIO_SCALE = 1e8;\r\n\r\n    /**\r\n     * @dev Provides an interface to the scaling unit\r\n     * @return Scaling unit (1e18 or 1 * 10**18)\r\n     */\r\n    function getFullScale() internal pure returns (uint256) {\r\n        return FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Provides an interface to the ratio unit\r\n     * @return Ratio scale unit (1e8 or 1 * 10**8)\r\n     */\r\n    function getRatioScale() internal pure returns (uint256) {\r\n        return RATIO_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Scales a given integer to the power of the full scale.\r\n     * @param x   Simple uint256 to scale\r\n     * @return    Scaled value a to an exact number\r\n     */\r\n    function scaleInteger(uint256 x) internal pure returns (uint256) {\r\n        return x * FULL_SCALE;\r\n    }\r\n\r\n    /***************************************\r\n              PRECISE ARITHMETIC\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulTruncateScale(x, y, FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\r\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @param scale Scale unit\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncateScale(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 scale\r\n    ) internal pure returns (uint256) {\r\n        // e.g. assume scale = fullScale\r\n        // z = 10e18 * 9e17 = 9e36\r\n        // return 9e38 / 1e18 = 9e18\r\n        return (x * y) / scale;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit, rounded up to the closest base unit.\r\n     */\r\n    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e17 * 17268172638 = 138145381104e17\r\n        uint256 scaled = x * y;\r\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\r\n        uint256 ceil = scaled + FULL_SCALE - 1;\r\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\r\n        return ceil / FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\r\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\r\n     * @param x     Left hand input to division\r\n     * @param y     Right hand input to division\r\n     * @return      Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e18 * 1e18 = 8e36\r\n        // e.g. 8e36 / 10e18 = 8e17\r\n        return (x * FULL_SCALE) / y;\r\n    }\r\n\r\n    /***************************************\r\n                  RATIO FUNCS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, essentially flooring the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand operand to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return c    Result after multiplying the two inputs and then dividing by the ratio scale\r\n     */\r\n    function mulRatioTruncate(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\r\n        return mulTruncateScale(x, ratio, RATIO_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, rounding up the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand input to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              ratio scale, rounded up to the closest base unit.\r\n     */\r\n    function mulRatioTruncateCeil(uint256 x, uint256 ratio) internal pure returns (uint256) {\r\n        // e.g. How much mAsset should I burn for this bAsset (x)?\r\n        // 1e18 * 1e8 = 1e26\r\n        uint256 scaled = x * ratio;\r\n        // 1e26 + 9.99e7 = 100..00.999e8\r\n        uint256 ceil = scaled + RATIO_SCALE - 1;\r\n        // return 100..00.999e8 / 1e8 = 1e18\r\n        return ceil / RATIO_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two ratioed units, by first scaling the left hand operand\r\n     *      i.e. How much bAsset is this mAsset worth?\r\n     * @param x     Left hand operand in division\r\n     * @param ratio bAsset ratio\r\n     * @return c    Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divRatioPrecisely(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\r\n        // e.g. 1e14 * 1e8 = 1e22\r\n        // return 1e22 / 1e12 = 1e10\r\n        return (x * RATIO_SCALE) / ratio;\r\n    }\r\n\r\n    /***************************************\r\n                    HELPERS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Calculates minimum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Minimum of the two inputs\r\n     */\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculated maximum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Maximum of the two inputs\r\n     */\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? x : y;\r\n    }\r\n\r\n    /**\r\n     * @dev Clamps a value to an upper bound\r\n     * @param x           Left hand input\r\n     * @param upperBound  Maximum possible value to return\r\n     * @return            Input x clamped to a maximum value, upperBound\r\n     */\r\n    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {\r\n        return x > upperBound ? upperBound : x;\r\n    }\r\n}\r\n\r\ninterface IPlatformIntegration {\r\n    /**\r\n     * @dev Deposit the given bAsset to Lending platform\r\n     * @param _bAsset bAsset address\r\n     * @param _amount Amount to deposit\r\n     */\r\n    function deposit(\r\n        address _bAsset,\r\n        uint256 _amount,\r\n        bool isTokenFeeCharged\r\n    ) external returns (uint256 quantityDeposited);\r\n\r\n    /**\r\n     * @dev Withdraw given bAsset from Lending platform\r\n     */\r\n    function withdraw(\r\n        address _receiver,\r\n        address _bAsset,\r\n        uint256 _amount,\r\n        bool _hasTxFee\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraw given bAsset from Lending platform\r\n     */\r\n    function withdraw(\r\n        address _receiver,\r\n        address _bAsset,\r\n        uint256 _amount,\r\n        uint256 _totalAmount,\r\n        bool _hasTxFee\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraw given bAsset from the cache\r\n     */\r\n    function withdrawRaw(\r\n        address _receiver,\r\n        address _bAsset,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current balance of the given bAsset\r\n     */\r\n    function checkBalance(address _bAsset) external returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the pToken\r\n     */\r\n    function bAssetToPToken(address _bAsset) external returns (address pToken);\r\n}\r\n\r\nlibrary FeederManager {\r\n    using SafeERC20 for IERC20;\r\n    using StableMath for uint256;\r\n\r\n    event BassetsMigrated(address[] bAssets, address newIntegrator);\r\n    event StartRampA(uint256 currentA, uint256 targetA, uint256 startTime, uint256 rampEndTime);\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    uint256 private constant MIN_RAMP_TIME = 1 days;\r\n    uint256 private constant MAX_A = 1e6;\r\n\r\n    /**\r\n     * @dev Calculates the gains accrued across all lending markets.\r\n     * @param _bAssetPersonal   Basset personal storage array\r\n     * @param _bAssetData       Basset data storage array\r\n     * @return idxs             Array [0,1]\r\n     * @return rawGains         Raw increases in vault Balance\r\n     */\r\n    function calculatePlatformInterest(\r\n        BassetPersonal[] memory _bAssetPersonal,\r\n        BassetData[] storage _bAssetData\r\n    ) external returns (uint8[] memory idxs, uint256[] memory rawGains) {\r\n        // Get basket details\r\n        BassetData[] memory bAssetData_ = _bAssetData;\r\n        uint256 count = bAssetData_.length;\r\n        idxs = new uint8[](count);\r\n        rawGains = new uint256[](count);\r\n        // 1. Calculate rawGains in each bAsset, in comparison to current vault balance\r\n        for (uint256 i = 0; i < count; i++) {\r\n            idxs[i] = uint8(i);\r\n            BassetPersonal memory bPersonal = _bAssetPersonal[i];\r\n            BassetData memory bData = bAssetData_[i];\r\n            // If there is no integration, then nothing can have accrued\r\n            if (bPersonal.integrator == address(0)) continue;\r\n            uint256 lending =\r\n                IPlatformIntegration(bPersonal.integrator).checkBalance(bPersonal.addr);\r\n            uint256 cache = 0;\r\n            if (!bPersonal.hasTxFee) {\r\n                cache = IERC20(bPersonal.addr).balanceOf(bPersonal.integrator);\r\n            }\r\n            uint256 balance = lending + cache;\r\n            uint256 oldVaultBalance = bData.vaultBalance;\r\n            if (balance > oldVaultBalance && bPersonal.status == BassetStatus.Normal) {\r\n                _bAssetData[i].vaultBalance = SafeCast.toUint128(balance);\r\n                uint256 interestDelta = balance - oldVaultBalance;\r\n                rawGains[i] = interestDelta;\r\n            } else {\r\n                rawGains[i] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers all collateral from one lending market to another - used initially\r\n     *      to handle the migration between Aave V1 and Aave V2. Note - only supports non\r\n     *      tx fee enabled assets. Supports going from no integration to integration, but\r\n     *      not the other way around.\r\n     * @param _bAssetPersonal   Basset data storage array\r\n     * @param _bAssets          Array of basket assets to migrate\r\n     * @param _newIntegration   Address of the new platform integration\r\n     */\r\n    function migrateBassets(\r\n        BassetPersonal[] storage _bAssetPersonal,\r\n        address[] calldata _bAssets,\r\n        address _newIntegration\r\n    ) external {\r\n        uint256 len = _bAssets.length;\r\n        require(len > 0, \"Must migrate some bAssets\");\r\n\r\n        for (uint256 i = 0; i < len; i++) {\r\n            // 1. Check that the bAsset is in the basket\r\n            address bAsset = _bAssets[i];\r\n            uint256 index = _getAssetIndex(_bAssetPersonal, bAsset);\r\n            require(!_bAssetPersonal[index].hasTxFee, \"A bAsset has a transfer fee\");\r\n\r\n            // 2. Withdraw everything from the old platform integration\r\n            address oldAddress = _bAssetPersonal[index].integrator;\r\n            require(oldAddress != _newIntegration, \"Must transfer to new integrator\");\r\n            (uint256 cache, uint256 lendingBal) = (0, 0);\r\n            if (oldAddress == address(0)) {\r\n                cache = IERC20(bAsset).balanceOf(address(this));\r\n            } else {\r\n                IPlatformIntegration oldIntegration = IPlatformIntegration(oldAddress);\r\n                cache = IERC20(bAsset).balanceOf(address(oldIntegration));\r\n                // 2.1. Withdraw from the lending market\r\n                lendingBal = oldIntegration.checkBalance(bAsset);\r\n                if (lendingBal > 0) {\r\n                    oldIntegration.withdraw(address(this), bAsset, lendingBal, false);\r\n                }\r\n                // 2.2. Withdraw from the cache, if any\r\n                if (cache > 0) {\r\n                    oldIntegration.withdrawRaw(address(this), bAsset, cache);\r\n                }\r\n            }\r\n            uint256 sum = lendingBal + cache;\r\n\r\n            // 3. Update the integration address for this bAsset\r\n            _bAssetPersonal[index].integrator = _newIntegration;\r\n\r\n            // 4. Deposit everything into the new\r\n            //    This should fail if we did not receive the full amount from the platform withdrawal\r\n            // 4.1. Deposit all bAsset\r\n            IERC20(bAsset).safeTransfer(_newIntegration, sum);\r\n            IPlatformIntegration newIntegration = IPlatformIntegration(_newIntegration);\r\n            if (lendingBal > 0) {\r\n                newIntegration.deposit(bAsset, lendingBal, false);\r\n            }\r\n            // 4.2. Check balances\r\n            uint256 newLendingBal = newIntegration.checkBalance(bAsset);\r\n            uint256 newCache = IERC20(bAsset).balanceOf(address(newIntegration));\r\n            uint256 upperMargin = 10001e14;\r\n            uint256 lowerMargin = 9999e14;\r\n\r\n            require(\r\n                newLendingBal >= lendingBal.mulTruncate(lowerMargin) &&\r\n                    newLendingBal <= lendingBal.mulTruncate(upperMargin),\r\n                \"Must transfer full amount\"\r\n            );\r\n            require(\r\n                newCache >= cache.mulTruncate(lowerMargin) &&\r\n                    newCache <= cache.mulTruncate(upperMargin),\r\n                \"Must transfer full amount\"\r\n            );\r\n        }\r\n\r\n        emit BassetsMigrated(_bAssets, _newIntegration);\r\n    }\r\n\r\n    /**\r\n     * @dev Simply gets the asset index by looping through bAssets. Given there are only\r\n     * ever 2 assets, should not be gas intensive.\r\n     */\r\n    function _getAssetIndex(BassetPersonal[] storage _bAssetPersonal, address _asset)\r\n        internal\r\n        view\r\n        returns (uint8 idx)\r\n    {\r\n        uint256 len = _bAssetPersonal.length;\r\n        for (uint8 i = 0; i < len; i++) {\r\n            if (_bAssetPersonal[i].addr == _asset) return i;\r\n        }\r\n        revert(\"Invalid asset\");\r\n    }\r\n\r\n    /**\r\n     * @dev Starts changing of the amplification var A\r\n     * @param _targetA      Target A value\r\n     * @param _rampEndTime  Time at which A will arrive at _targetA\r\n     */\r\n    function startRampA(\r\n        AmpData storage _ampData,\r\n        uint256 _targetA,\r\n        uint256 _rampEndTime,\r\n        uint256 _currentA,\r\n        uint256 _precision\r\n    ) external {\r\n        require(\r\n            block.timestamp >= (_ampData.rampStartTime + MIN_RAMP_TIME),\r\n            \"Sufficient period of previous ramp has not elapsed\"\r\n        );\r\n        require(_rampEndTime >= (block.timestamp + MIN_RAMP_TIME), \"Ramp time too short\");\r\n        require(_targetA > 0 && _targetA < MAX_A, \"A target out of bounds\");\r\n\r\n        uint256 preciseTargetA = _targetA * _precision;\r\n\r\n        if (preciseTargetA > _currentA) {\r\n            require(preciseTargetA <= _currentA * 10, \"A target increase too big\");\r\n        } else {\r\n            require(preciseTargetA >= _currentA / 10, \"A target decrease too big\");\r\n        }\r\n\r\n        _ampData.initialA = SafeCast.toUint64(_currentA);\r\n        _ampData.targetA = SafeCast.toUint64(preciseTargetA);\r\n        _ampData.rampStartTime = SafeCast.toUint64(block.timestamp);\r\n        _ampData.rampEndTime = SafeCast.toUint64(_rampEndTime);\r\n\r\n        emit StartRampA(_currentA, preciseTargetA, block.timestamp, _rampEndTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Stops the changing of the amplification var A, setting\r\n     * it to whatever the current value is.\r\n     */\r\n    function stopRampA(AmpData storage _ampData, uint256 _currentA) external {\r\n        require(block.timestamp < _ampData.rampEndTime, \"Amplification not changing\");\r\n\r\n        _ampData.initialA = SafeCast.toUint64(_currentA);\r\n        _ampData.targetA = SafeCast.toUint64(_currentA);\r\n        _ampData.rampStartTime = SafeCast.toUint64(block.timestamp);\r\n        _ampData.rampEndTime = SafeCast.toUint64(block.timestamp);\r\n\r\n        emit StopRampA(_currentA, block.timestamp);\r\n    }\r\n}\r\n\r\nlibrary Root {\r\n    /**\r\n     * @dev Returns the square root of a given number\r\n     * @param x Input\r\n     * @return y Square root of Input\r\n     */\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        if (x == 0) return 0;\r\n        else {\r\n            uint256 xx = x;\r\n            uint256 r = 1;\r\n            if (xx >= 0x100000000000000000000000000000000) {\r\n                xx >>= 128;\r\n                r <<= 64;\r\n            }\r\n            if (xx >= 0x10000000000000000) {\r\n                xx >>= 64;\r\n                r <<= 32;\r\n            }\r\n            if (xx >= 0x100000000) {\r\n                xx >>= 32;\r\n                r <<= 16;\r\n            }\r\n            if (xx >= 0x10000) {\r\n                xx >>= 16;\r\n                r <<= 8;\r\n            }\r\n            if (xx >= 0x100) {\r\n                xx >>= 8;\r\n                r <<= 4;\r\n            }\r\n            if (xx >= 0x10) {\r\n                xx >>= 4;\r\n                r <<= 2;\r\n            }\r\n            if (xx >= 0x8) {\r\n                r <<= 1;\r\n            }\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1; // Seven iterations should be enough\r\n            uint256 r1 = x / r;\r\n            return uint256(r < r1 ? r : r1);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary MassetHelpers {\r\n    using SafeERC20 for IERC20;\r\n\r\n    function transferReturnBalance(\r\n        address _sender,\r\n        address _recipient,\r\n        address _bAsset,\r\n        uint256 _qty\r\n    ) internal returns (uint256 receivedQty, uint256 recipientBalance) {\r\n        uint256 balBefore = IERC20(_bAsset).balanceOf(_recipient);\r\n        IERC20(_bAsset).safeTransferFrom(_sender, _recipient, _qty);\r\n        recipientBalance = IERC20(_bAsset).balanceOf(_recipient);\r\n        receivedQty = recipientBalance - balBefore;\r\n    }\r\n\r\n    function safeInfiniteApprove(address _asset, address _spender) internal {\r\n        IERC20(_asset).safeApprove(_spender, 0);\r\n        IERC20(_asset).safeApprove(_spender, 2**256 - 1);\r\n    }\r\n}\r\n\r\nlibrary FeederLogic {\r\n    using StableMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 internal constant A_PRECISION = 100;\r\n\r\n    /***************************************\r\n                    MINT\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Transfers token in, updates internal balances and computes the fpToken output\r\n     * @param _data                 Feeder pool storage state\r\n     * @param _config               Core config for use in the invariant validator\r\n     * @param _input                Data on the bAsset to deposit for the minted fpToken.\r\n     * @param _inputQuantity        Quantity in input token units.\r\n     * @param _minOutputQuantity    Minimum fpToken quantity to be minted. This protects against slippage.\r\n     * @return mintOutput           Quantity of fpToken minted from the deposited bAsset.\r\n     */\r\n    function mint(\r\n        FeederData storage _data,\r\n        FeederConfig calldata _config,\r\n        Asset calldata _input,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity\r\n    ) external returns (uint256 mintOutput) {\r\n        BassetData[] memory cachedBassetData = _data.bAssetData;\r\n        AssetData memory inputData =\r\n            _transferIn(_data, _config, cachedBassetData, _input, _inputQuantity);\r\n        // Validation should be after token transfer, as real input amt is unknown before\r\n        mintOutput = computeMint(cachedBassetData, inputData.idx, inputData.amt, _config);\r\n        require(mintOutput >= _minOutputQuantity, \"Mint quantity < min qty\");\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers tokens in, updates internal balances and computes the fpToken output.\r\n     * Only fAsset & mAsset are supported in this path.\r\n     * @param _data                 Feeder pool storage state\r\n     * @param _config               Core config for use in the invariant validator\r\n     * @param _indices              Non-duplicate addresses of the bAssets to deposit for the minted fpToken.\r\n     * @param _inputQuantities      Quantity of each input in input token units.\r\n     * @param _minOutputQuantity    Minimum fpToken quantity to be minted. This protects against slippage.\r\n     * @return mintOutput           Quantity of fpToken minted from the deposited bAsset.\r\n     */\r\n    function mintMulti(\r\n        FeederData storage _data,\r\n        FeederConfig calldata _config,\r\n        uint8[] calldata _indices,\r\n        uint256[] calldata _inputQuantities,\r\n        uint256 _minOutputQuantity\r\n    ) external returns (uint256 mintOutput) {\r\n        uint256 len = _indices.length;\r\n        uint256[] memory quantitiesDeposited = new uint256[](len);\r\n        // Load bAssets from storage into memory\r\n        BassetData[] memory allBassets = _data.bAssetData;\r\n        uint256 maxCache = _getCacheDetails(_data, _config.supply);\r\n        // Transfer the Bassets to the integrator & update storage\r\n        for (uint256 i = 0; i < len; i++) {\r\n            if (_inputQuantities[i] > 0) {\r\n                uint8 idx = _indices[i];\r\n                BassetData memory bData = allBassets[idx];\r\n                quantitiesDeposited[i] = _depositTokens(\r\n                    _data.bAssetPersonal[idx],\r\n                    bData.ratio,\r\n                    _inputQuantities[i],\r\n                    maxCache\r\n                );\r\n\r\n                _data.bAssetData[idx].vaultBalance =\r\n                    bData.vaultBalance +\r\n                    SafeCast.toUint128(quantitiesDeposited[i]);\r\n            }\r\n        }\r\n        // Validate the proposed mint, after token transfer\r\n        mintOutput = computeMintMulti(allBassets, _indices, quantitiesDeposited, _config);\r\n        require(mintOutput >= _minOutputQuantity, \"Mint quantity < min qty\");\r\n        require(mintOutput > 0, \"Zero mAsset quantity\");\r\n    }\r\n\r\n    /***************************************\r\n                    SWAP\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Swaps two assets - either internally between fAsset<>mAsset, or between fAsset<>mpAsset by\r\n     * first routing through the mAsset pool.\r\n     * @param _data              Feeder pool storage state\r\n     * @param _config            Core config for use in the invariant validator\r\n     * @param _input             Data on bAsset to deposit\r\n     * @param _output            Data on bAsset to withdraw\r\n     * @param _inputQuantity     Units of input bAsset to swap in\r\n     * @param _minOutputQuantity Minimum quantity of the swap output asset. This protects against slippage\r\n     * @param _recipient         Address to transfer output asset to\r\n     * @return swapOutput        Quantity of output asset returned from swap\r\n     * @return localFee          Fee paid, in fpToken terms\r\n     */\r\n    function swap(\r\n        FeederData storage _data,\r\n        FeederConfig calldata _config,\r\n        Asset calldata _input,\r\n        Asset calldata _output,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external returns (uint256 swapOutput, uint256 localFee) {\r\n        BassetData[] memory cachedBassetData = _data.bAssetData;\r\n\r\n        AssetData memory inputData =\r\n            _transferIn(_data, _config, cachedBassetData, _input, _inputQuantity);\r\n        // 1. [f/mAsset ->][ f/mAsset]               : Y - normal in, SWAP, normal out\r\n        // 3. [mpAsset -> mAsset][ -> fAsset]        : Y - mint in  , SWAP, normal out\r\n        if (_output.exists) {\r\n            (swapOutput, localFee) = _swapLocal(\r\n                _data,\r\n                _config,\r\n                cachedBassetData,\r\n                inputData,\r\n                _output,\r\n                _minOutputQuantity,\r\n                _recipient\r\n            );\r\n        }\r\n        // 2. [fAsset ->][ mAsset][ -> mpAsset]      : Y - normal in, SWAP, mpOut\r\n        else {\r\n            address mAsset = _data.bAssetPersonal[0].addr;\r\n            (swapOutput, localFee) = _swapLocal(\r\n                _data,\r\n                _config,\r\n                cachedBassetData,\r\n                inputData,\r\n                Asset(0, mAsset, true),\r\n                0,\r\n                address(this)\r\n            );\r\n            swapOutput = IMasset(mAsset).redeem(\r\n                _output.addr,\r\n                swapOutput,\r\n                _minOutputQuantity,\r\n                _recipient\r\n            );\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                    REDEEM\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Burns a specified quantity of the senders fpToken in return for a bAsset. The output amount is derived\r\n     * from the invariant. Supports redemption into either the fAsset, mAsset or assets in the mAsset basket.\r\n     * @param _data              Feeder pool storage state\r\n     * @param _config            Core config for use in the invariant validator\r\n     * @param _output            Data on bAsset to withdraw\r\n     * @param _fpTokenQuantity   Quantity of fpToken to burn\r\n     * @param _minOutputQuantity Minimum bAsset quantity to receive for the burnt fpToken. This protects against slippage.\r\n     * @param _recipient         Address to transfer the withdrawn bAssets to.\r\n     * @return outputQuantity    Quanity of bAsset units received for the burnt fpToken\r\n     * @return localFee          Fee paid, in fpToken terms\r\n     */\r\n    function redeem(\r\n        FeederData storage _data,\r\n        FeederConfig calldata _config,\r\n        Asset calldata _output,\r\n        uint256 _fpTokenQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external returns (uint256 outputQuantity, uint256 localFee) {\r\n        if (_output.exists) {\r\n            (outputQuantity, localFee) = _redeemLocal(\r\n                _data,\r\n                _config,\r\n                _output,\r\n                _fpTokenQuantity,\r\n                _minOutputQuantity,\r\n                _recipient\r\n            );\r\n        } else {\r\n            address mAsset = _data.bAssetPersonal[0].addr;\r\n            (outputQuantity, localFee) = _redeemLocal(\r\n                _data,\r\n                _config,\r\n                Asset(0, mAsset, true),\r\n                _fpTokenQuantity,\r\n                0,\r\n                address(this)\r\n            );\r\n            outputQuantity = IMasset(mAsset).redeem(\r\n                _output.addr,\r\n                outputQuantity,\r\n                _minOutputQuantity,\r\n                _recipient\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Credits a recipient with a proportionate amount of bAssets, relative to current vault\r\n     * balance levels and desired fpToken quantity. Burns the fpToken as payment. Only fAsset & mAsset are supported in this path.\r\n     * @param _data                 Feeder pool storage state\r\n     * @param _config               Core config for use in the invariant validator\r\n     * @param _inputQuantity        Quantity of fpToken to redeem\r\n     * @param _minOutputQuantities  Min units of output to receive\r\n     * @param _recipient            Address to credit the withdrawn bAssets\r\n     * @return scaledFee            Fee collected in fpToken terms\r\n     * @return outputs              Array of output asset addresses\r\n     * @return outputQuantities     Array of output asset quantities\r\n     */\r\n    function redeemProportionately(\r\n        FeederData storage _data,\r\n        FeederConfig calldata _config,\r\n        uint256 _inputQuantity,\r\n        uint256[] calldata _minOutputQuantities,\r\n        address _recipient\r\n    )\r\n        external\r\n        returns (\r\n            uint256 scaledFee,\r\n            address[] memory outputs,\r\n            uint256[] memory outputQuantities\r\n        )\r\n    {\r\n        // Calculate mAsset redemption quantities\r\n        scaledFee = _inputQuantity.mulTruncate(_data.redemptionFee);\r\n        // cache = (config.supply - inputQuantity) * 0.2\r\n        uint256 maxCache = _getCacheDetails(_data, _config.supply - _inputQuantity);\r\n\r\n        // Load the bAsset data from storage into memory\r\n        BassetData[] memory allBassets = _data.bAssetData;\r\n        uint256 len = allBassets.length;\r\n        outputs = new address[](len);\r\n        outputQuantities = new uint256[](len);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            // Get amount out, proportionate to redemption quantity\r\n            uint256 amountOut =\r\n                (allBassets[i].vaultBalance * (_inputQuantity - scaledFee)) / _config.supply;\r\n            require(amountOut > 1, \"Output == 0\");\r\n            amountOut -= 1;\r\n            require(amountOut >= _minOutputQuantities[i], \"bAsset qty < min qty\");\r\n            // Set output in array\r\n            (outputQuantities[i], outputs[i]) = (amountOut, _data.bAssetPersonal[i].addr);\r\n            // Transfer the bAsset to the recipient\r\n            _withdrawTokens(\r\n                amountOut,\r\n                _data.bAssetPersonal[i],\r\n                allBassets[i],\r\n                _recipient,\r\n                maxCache\r\n            );\r\n            // Reduce vaultBalance\r\n            _data.bAssetData[i].vaultBalance =\r\n                allBassets[i].vaultBalance -\r\n                SafeCast.toUint128(amountOut);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Credits a recipient with a certain quantity of selected bAssets, in exchange for burning the\r\n     *      relative fpToken quantity from the sender. Only fAsset & mAsset (0,1) are supported in this path.\r\n     * @param _data                 Feeder pool storage state\r\n     * @param _config               Core config for use in the invariant validator\r\n     * @param _indices              Indices of the bAssets to receive\r\n     * @param _outputQuantities     Units of the bAssets to receive\r\n     * @param _maxInputQuantity     Maximum fpToken quantity to burn for the received bAssets. This protects against slippage.\r\n     * @param _recipient            Address to receive the withdrawn bAssets\r\n     * @return fpTokenQuantity      Quantity of fpToken units to burn as payment\r\n     * @return localFee             Fee collected, in fpToken terms\r\n     */\r\n    function redeemExactBassets(\r\n        FeederData storage _data,\r\n        FeederConfig memory _config,\r\n        uint8[] calldata _indices,\r\n        uint256[] calldata _outputQuantities,\r\n        uint256 _maxInputQuantity,\r\n        address _recipient\r\n    ) external returns (uint256 fpTokenQuantity, uint256 localFee) {\r\n        // Load bAsset data from storage to memory\r\n        BassetData[] memory allBassets = _data.bAssetData;\r\n\r\n        // Validate redemption\r\n        uint256 fpTokenRequired =\r\n            computeRedeemExact(allBassets, _indices, _outputQuantities, _config);\r\n        fpTokenQuantity = fpTokenRequired.divPrecisely(1e18 - _data.redemptionFee);\r\n        localFee = fpTokenQuantity - fpTokenRequired;\r\n        require(fpTokenQuantity > 0, \"Must redeem some mAssets\");\r\n        fpTokenQuantity += 1;\r\n        require(fpTokenQuantity <= _maxInputQuantity, \"Redeem mAsset qty > max quantity\");\r\n\r\n        // Burn the full amount of Masset\r\n        uint256 maxCache = _getCacheDetails(_data, _config.supply - fpTokenQuantity);\r\n        // Transfer the Bassets to the recipient\r\n        for (uint256 i = 0; i < _outputQuantities.length; i++) {\r\n            _withdrawTokens(\r\n                _outputQuantities[i],\r\n                _data.bAssetPersonal[_indices[i]],\r\n                allBassets[_indices[i]],\r\n                _recipient,\r\n                maxCache\r\n            );\r\n            _data.bAssetData[_indices[i]].vaultBalance =\r\n                allBassets[_indices[i]].vaultBalance -\r\n                SafeCast.toUint128(_outputQuantities[i]);\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                FORGING - INTERNAL\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Transfers an asset in and updates vault balance. Supports fAsset, mAsset and mpAsset.\r\n     * Transferring an mpAsset requires first a mint in the main pool, and consequent depositing of\r\n     * the mAsset.\r\n     */\r\n    function _transferIn(\r\n        FeederData storage _data,\r\n        FeederConfig memory _config,\r\n        BassetData[] memory _cachedBassetData,\r\n        Asset memory _input,\r\n        uint256 _inputQuantity\r\n    ) internal returns (AssetData memory inputData) {\r\n        // fAsset / mAsset transfers\r\n        if (_input.exists) {\r\n            BassetPersonal memory personal = _data.bAssetPersonal[_input.idx];\r\n            uint256 amt =\r\n                _depositTokens(\r\n                    personal,\r\n                    _cachedBassetData[_input.idx].ratio,\r\n                    _inputQuantity,\r\n                    _getCacheDetails(_data, _config.supply)\r\n                );\r\n            inputData = AssetData(_input.idx, amt, personal);\r\n        }\r\n        // mpAsset transfers\r\n        else {\r\n            inputData = _mpMint(\r\n                _data,\r\n                _input,\r\n                _inputQuantity,\r\n                _getCacheDetails(_data, _config.supply)\r\n            );\r\n            require(inputData.amt > 0, \"Must mint something from mp\");\r\n        }\r\n        _data.bAssetData[inputData.idx].vaultBalance =\r\n            _cachedBassetData[inputData.idx].vaultBalance +\r\n            SafeCast.toUint128(inputData.amt);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints an asset in the main mAsset pool. Input asset must be supported by the mAsset\r\n     * or else the call will revert. After minting, check if the balance exceeds the cache upper limit\r\n     * and consequently deposit if necessary.\r\n     */\r\n    function _mpMint(\r\n        FeederData storage _data,\r\n        Asset memory _input,\r\n        uint256 _inputQuantity,\r\n        uint256 _maxCache\r\n    ) internal returns (AssetData memory mAssetData) {\r\n        mAssetData = AssetData(0, 0, _data.bAssetPersonal[0]);\r\n        IERC20(_input.addr).safeTransferFrom(msg.sender, address(this), _inputQuantity);\r\n\r\n        address integrator =\r\n            mAssetData.personal.integrator == address(0)\r\n                ? address(this)\r\n                : mAssetData.personal.integrator;\r\n\r\n        uint256 balBefore = IERC20(mAssetData.personal.addr).balanceOf(integrator);\r\n        // Mint will revert if the _input.addr is not whitelisted on that mAsset\r\n        IMasset(mAssetData.personal.addr).mint(_input.addr, _inputQuantity, 0, integrator);\r\n        uint256 balAfter = IERC20(mAssetData.personal.addr).balanceOf(integrator);\r\n        mAssetData.amt = balAfter - balBefore;\r\n\r\n        // Route the mAsset to platform integration\r\n        if (integrator != address(this)) {\r\n            if (balAfter > _maxCache) {\r\n                uint256 delta = balAfter - (_maxCache / 2);\r\n                IPlatformIntegration(integrator).deposit(mAssetData.personal.addr, delta, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a swap between fAsset and mAsset. If the output is an mAsset, do not\r\n     * charge the swap fee.\r\n     */\r\n    function _swapLocal(\r\n        FeederData storage _data,\r\n        FeederConfig memory _config,\r\n        BassetData[] memory _cachedBassetData,\r\n        AssetData memory _inputData,\r\n        Asset memory _output,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) internal returns (uint256 swapOutput, uint256 scaledFee) {\r\n        // Validate the swap\r\n        (swapOutput, scaledFee) = computeSwap(\r\n            _cachedBassetData,\r\n            _inputData.idx,\r\n            _output.idx,\r\n            _inputData.amt,\r\n            _output.idx == 0 ? 0 : _data.swapFee,\r\n            _config\r\n        );\r\n        require(swapOutput >= _minOutputQuantity, \"Output qty < minimum qty\");\r\n        require(swapOutput > 0, \"Zero output quantity\");\r\n        // Settle the swap\r\n        _withdrawTokens(\r\n            swapOutput,\r\n            _data.bAssetPersonal[_output.idx],\r\n            _cachedBassetData[_output.idx],\r\n            _recipient,\r\n            _getCacheDetails(_data, _config.supply)\r\n        );\r\n        // Decrease output bal\r\n        _data.bAssetData[_output.idx].vaultBalance =\r\n            _cachedBassetData[_output.idx].vaultBalance -\r\n            SafeCast.toUint128(swapOutput);\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a local redemption into either fAsset or mAsset.\r\n     */\r\n    function _redeemLocal(\r\n        FeederData storage _data,\r\n        FeederConfig memory _config,\r\n        Asset memory _output,\r\n        uint256 _fpTokenQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) internal returns (uint256 outputQuantity, uint256 scaledFee) {\r\n        BassetData[] memory allBassets = _data.bAssetData;\r\n        // Subtract the redemption fee\r\n        scaledFee = _fpTokenQuantity.mulTruncate(_data.redemptionFee);\r\n        // Calculate redemption quantities\r\n        outputQuantity = computeRedeem(\r\n            allBassets,\r\n            _output.idx,\r\n            _fpTokenQuantity - scaledFee,\r\n            _config\r\n        );\r\n        require(outputQuantity >= _minOutputQuantity, \"bAsset qty < min qty\");\r\n        require(outputQuantity > 0, \"Output == 0\");\r\n\r\n        // Transfer the bAssets to the recipient\r\n        _withdrawTokens(\r\n            outputQuantity,\r\n            _data.bAssetPersonal[_output.idx],\r\n            allBassets[_output.idx],\r\n            _recipient,\r\n            _getCacheDetails(_data, _config.supply - _fpTokenQuantity)\r\n        );\r\n        // Set vault balance\r\n        _data.bAssetData[_output.idx].vaultBalance =\r\n            allBassets[_output.idx].vaultBalance -\r\n            SafeCast.toUint128(outputQuantity);\r\n    }\r\n\r\n    /**\r\n     * @dev Deposits a given asset to the system. If there is sufficient room for the asset\r\n     * in the cache, then just transfer, otherwise reset the cache to the desired mid level by\r\n     * depositing the delta in the platform\r\n     */\r\n    function _depositTokens(\r\n        BassetPersonal memory _bAsset,\r\n        uint256 _bAssetRatio,\r\n        uint256 _quantity,\r\n        uint256 _maxCache\r\n    ) internal returns (uint256 quantityDeposited) {\r\n        // 0. If integration is 0, short circuit\r\n        if (_bAsset.integrator == address(0)) {\r\n            (uint256 received, ) =\r\n                MassetHelpers.transferReturnBalance(\r\n                    msg.sender,\r\n                    address(this),\r\n                    _bAsset.addr,\r\n                    _quantity\r\n                );\r\n            return received;\r\n        }\r\n\r\n        // 1 - Send all to PI, using the opportunity to get the cache balance and net amount transferred\r\n        uint256 cacheBal;\r\n        (quantityDeposited, cacheBal) = MassetHelpers.transferReturnBalance(\r\n            msg.sender,\r\n            _bAsset.integrator,\r\n            _bAsset.addr,\r\n            _quantity\r\n        );\r\n\r\n        // 2 - Deposit X if necessary\r\n        // 2.1 - Deposit if xfer fees\r\n        if (_bAsset.hasTxFee) {\r\n            uint256 deposited =\r\n                IPlatformIntegration(_bAsset.integrator).deposit(\r\n                    _bAsset.addr,\r\n                    quantityDeposited,\r\n                    true\r\n                );\r\n\r\n            return StableMath.min(deposited, quantityDeposited);\r\n        }\r\n        // 2.2 - Else Deposit X if Cache > %\r\n        // This check is in place to ensure that any token with a txFee is rejected\r\n        require(quantityDeposited == _quantity, \"Asset not fully transferred\");\r\n\r\n        uint256 relativeMaxCache = _maxCache.divRatioPrecisely(_bAssetRatio);\r\n\r\n        if (cacheBal > relativeMaxCache) {\r\n            uint256 delta = cacheBal - (relativeMaxCache / 2);\r\n            IPlatformIntegration(_bAsset.integrator).deposit(_bAsset.addr, delta, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws a given asset from its platformIntegration. If there is sufficient liquidity\r\n     * in the cache, then withdraw from there, otherwise withdraw from the lending market and reset the\r\n     * cache to the mid level.\r\n     */\r\n    function _withdrawTokens(\r\n        uint256 _quantity,\r\n        BassetPersonal memory _personal,\r\n        BassetData memory _data,\r\n        address _recipient,\r\n        uint256 _maxCache\r\n    ) internal {\r\n        if (_quantity == 0) return;\r\n\r\n        // 1.0 If there is no integrator, send from here\r\n        if (_personal.integrator == address(0)) {\r\n            // If this is part of a cross-swap or cross-redeem, and there is no\r\n            // integrator.. then we don't need to transfer anywhere\r\n            if (_recipient == address(this)) return;\r\n            IERC20(_personal.addr).safeTransfer(_recipient, _quantity);\r\n        }\r\n        // 1.1 If txFee then short circuit - there is no cache\r\n        else if (_personal.hasTxFee) {\r\n            IPlatformIntegration(_personal.integrator).withdraw(\r\n                _recipient,\r\n                _personal.addr,\r\n                _quantity,\r\n                _quantity,\r\n                true\r\n            );\r\n        }\r\n        // 1.2. Else, withdraw from either cache or main vault\r\n        else {\r\n            uint256 cacheBal = IERC20(_personal.addr).balanceOf(_personal.integrator);\r\n            // 2.1 - If balance b in cache, simply withdraw\r\n            if (cacheBal >= _quantity) {\r\n                IPlatformIntegration(_personal.integrator).withdrawRaw(\r\n                    _recipient,\r\n                    _personal.addr,\r\n                    _quantity\r\n                );\r\n            }\r\n            // 2.2 - Else reset the cache to X, or as far as possible\r\n            //       - Withdraw X+b from platform\r\n            //       - Send b to user\r\n            else {\r\n                uint256 relativeMidCache = _maxCache.divRatioPrecisely(_data.ratio) / 2;\r\n                uint256 totalWithdrawal =\r\n                    StableMath.min(\r\n                        relativeMidCache + _quantity - cacheBal,\r\n                        _data.vaultBalance - SafeCast.toUint128(cacheBal)\r\n                    );\r\n\r\n                IPlatformIntegration(_personal.integrator).withdraw(\r\n                    _recipient,\r\n                    _personal.addr,\r\n                    _quantity,\r\n                    totalWithdrawal,\r\n                    false\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the max cache size, given the supply of fpToken\r\n     * @return maxCache    Max units of any given bAsset that should be held in the cache\r\n     */\r\n    function _getCacheDetails(FeederData storage _data, uint256 _supply)\r\n        internal\r\n        view\r\n        returns (uint256 maxCache)\r\n    {\r\n        maxCache = (_supply * _data.cacheSize) / 1e18;\r\n    }\r\n\r\n    /***************************************\r\n                    INVARIANT\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Compute the amount of fpToken received for minting\r\n     * with `quantity` amount of bAsset index `i`.\r\n     * @param _bAssets      Array of all bAsset Data\r\n     * @param _i            Index of bAsset with which to mint\r\n     * @param _rawInput     Raw amount of bAsset to use in mint\r\n     * @param _config       Generalised FeederConfig stored externally\r\n     * @return mintAmount   Quantity of fpTokens minted\r\n     */\r\n    function computeMint(\r\n        BassetData[] memory _bAssets,\r\n        uint8 _i,\r\n        uint256 _rawInput,\r\n        FeederConfig memory _config\r\n    ) public pure returns (uint256 mintAmount) {\r\n        // 1. Get raw reserves\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        // 2. Get value of reserves according to invariant\r\n        uint256 k0 = _invariant(x, sum, _config.a);\r\n        uint256 scaledInput = (_rawInput * _bAssets[_i].ratio) / 1e8;\r\n        require(scaledInput > 1e6, \"Must add > 1e6 units\");\r\n        // 3. Add deposit to x and sum\r\n        x[_i] += scaledInput;\r\n        sum += scaledInput;\r\n        // 4. Finalise mint\r\n        require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\r\n        mintAmount = _computeMintOutput(x, sum, k0, _config);\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the amount of fpToken received for minting\r\n     * with the given array of inputs.\r\n     * @param _bAssets      Array of all bAsset Data\r\n     * @param _indices      Indexes of bAssets with which to mint\r\n     * @param _rawInputs    Raw amounts of bAssets to use in mint\r\n     * @param _config       Generalised FeederConfig stored externally\r\n     * @return mintAmount   Quantity of fpTokens minted\r\n     */\r\n    function computeMintMulti(\r\n        BassetData[] memory _bAssets,\r\n        uint8[] memory _indices,\r\n        uint256[] memory _rawInputs,\r\n        FeederConfig memory _config\r\n    ) public pure returns (uint256 mintAmount) {\r\n        // 1. Get raw reserves\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        // 2. Get value of reserves according to invariant\r\n        uint256 k0 = _invariant(x, sum, _config.a);\r\n        // 3. Add deposits to x and sum\r\n        uint256 len = _indices.length;\r\n        uint8 idx;\r\n        uint256 scaledInput;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            idx = _indices[i];\r\n            scaledInput = (_rawInputs[i] * _bAssets[idx].ratio) / 1e8;\r\n            x[idx] += scaledInput;\r\n            sum += scaledInput;\r\n        }\r\n        // 4. Finalise mint\r\n        require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\r\n        mintAmount = _computeMintOutput(x, sum, k0, _config);\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the amount of bAsset received for swapping\r\n     * `quantity` amount of index `input_idx` to index `output_idx`.\r\n     * @param _bAssets      Array of all bAsset Data\r\n     * @param _i            Index of bAsset to swap IN\r\n     * @param _o            Index of bAsset to swap OUT\r\n     * @param _rawInput     Raw amounts of input bAsset to input\r\n     * @param _feeRate      Swap fee rate to apply to output\r\n     * @param _config       Generalised FeederConfig stored externally\r\n     * @return bAssetOutputQuantity   Raw bAsset output quantity\r\n     * @return scaledSwapFee          Swap fee collected, in fpToken terms\r\n     */\r\n    function computeSwap(\r\n        BassetData[] memory _bAssets,\r\n        uint8 _i,\r\n        uint8 _o,\r\n        uint256 _rawInput,\r\n        uint256 _feeRate,\r\n        FeederConfig memory _config\r\n    ) public pure returns (uint256 bAssetOutputQuantity, uint256 scaledSwapFee) {\r\n        // 1. Get raw reserves\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        // 2. Get value of reserves according to invariant\r\n        uint256 k0 = _invariant(x, sum, _config.a);\r\n        // 3. Add deposits to x and sum\r\n        uint256 scaledInput = (_rawInput * _bAssets[_i].ratio) / 1e8;\r\n        require(scaledInput > 1e6, \"Must add > 1e6 units\");\r\n        x[_i] += scaledInput;\r\n        sum += scaledInput;\r\n        // 4. Calc total fpToken q\r\n        uint256 k1 = _invariant(x, sum, _config.a);\r\n        scaledSwapFee = ((k1 - k0) * _feeRate) / 1e18;\r\n        // 5. Calc output bAsset\r\n        uint256 newOutputReserve = _solveInvariant(x, _config.a, _o, k0 + scaledSwapFee);\r\n        // Convert swap fee to fpToken terms\r\n        // fpFee = fee * s / k\r\n        scaledSwapFee = (scaledSwapFee * _config.supply) / k0;\r\n        uint256 output = x[_o] - newOutputReserve - 1;\r\n        bAssetOutputQuantity = (output * 1e8) / _bAssets[_o].ratio;\r\n        // 6. Check for bounds\r\n        x[_o] -= output;\r\n        sum -= output;\r\n        require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the amount of bAsset index `i` received for\r\n     * redeeming `quantity` amount of fpToken.\r\n     * @param _bAssets              Array of all bAsset Data\r\n     * @param _o                    Index of output bAsset\r\n     * @param _netRedeemInput       Net amount of fpToken to redeem\r\n     * @param _config               Generalised FeederConfig stored externally\r\n     * @return rawOutputUnits       Raw bAsset output returned\r\n     */\r\n    function computeRedeem(\r\n        BassetData[] memory _bAssets,\r\n        uint8 _o,\r\n        uint256 _netRedeemInput,\r\n        FeederConfig memory _config\r\n    ) public pure returns (uint256 rawOutputUnits) {\r\n        require(_netRedeemInput > 1e6, \"Must redeem > 1e6 units\");\r\n        // 1. Get raw reserves\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        // 2. Get value of reserves according to invariant\r\n        uint256 k0 = _invariant(x, sum, _config.a);\r\n        uint256 kFinal = (k0 * (_config.supply - _netRedeemInput)) / _config.supply + 1;\r\n        // 3. Compute bAsset output\r\n        uint256 newOutputReserve = _solveInvariant(x, _config.a, _o, kFinal);\r\n        uint256 output = x[_o] - newOutputReserve - 1;\r\n        rawOutputUnits = (output * 1e8) / _bAssets[_o].ratio;\r\n        // 4. Check for max weight\r\n        x[_o] -= output;\r\n        sum -= output;\r\n        require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the amount of fpToken required to redeem\r\n     * a given selection of bAssets.\r\n     * @param _bAssets          Array of all bAsset Data\r\n     * @param _indices          Indexes of output bAssets\r\n     * @param _rawOutputs       Desired raw bAsset outputs\r\n     * @param _config           Generalised FeederConfig stored externally\r\n     * @return redeemInput      Amount of fpToken required to redeem bAssets\r\n     */\r\n    function computeRedeemExact(\r\n        BassetData[] memory _bAssets,\r\n        uint8[] memory _indices,\r\n        uint256[] memory _rawOutputs,\r\n        FeederConfig memory _config\r\n    ) public pure returns (uint256 redeemInput) {\r\n        // 1. Get raw reserves\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        // 2. Get value of reserves according to invariant\r\n        uint256 k0 = _invariant(x, sum, _config.a);\r\n        // 3. Sub deposits from x and sum\r\n        uint256 len = _indices.length;\r\n        uint256 ratioed;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            ratioed = (_rawOutputs[i] * _bAssets[_indices[i]].ratio) / 1e8;\r\n            x[_indices[i]] -= ratioed;\r\n            sum -= ratioed;\r\n        }\r\n        require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\r\n        // 4. Get new value of reserves according to invariant\r\n        uint256 k1 = _invariant(x, sum, _config.a);\r\n        // 5. Total fpToken is the difference between values\r\n        redeemInput = (_config.supply * (k0 - k1)) / k0;\r\n        require(redeemInput > 1e6, \"Must redeem > 1e6 units\");\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the price of the fpToken, and invariant value k\r\n     * @param _bAssets  Array of all bAsset Data\r\n     * @param _config   Generalised FeederConfig stored externally\r\n     * @return price    Price of an fpToken\r\n     * @return k        Total value of basket, k\r\n     */\r\n    function computePrice(BassetData[] memory _bAssets, FeederConfig memory _config)\r\n        public\r\n        pure\r\n        returns (uint256 price, uint256 k)\r\n    {\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        k = _invariant(x, sum, _config.a);\r\n        price = (1e18 * k) / _config.supply;\r\n    }\r\n\r\n    /***************************************\r\n                    INTERNAL\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Computes the actual mint output after adding mint inputs\r\n     * to the vault balances\r\n     * @param _x            Scaled vaultBalances\r\n     * @param _sum          Sum of vaultBalances, to avoid another loop\r\n     * @param _k            Previous value of invariant, k, before addition\r\n     * @param _config       Generalised FeederConfig stored externally\r\n     * @return mintAmount   Amount of value added to invariant, in fpToken terms\r\n     */\r\n    function _computeMintOutput(\r\n        uint256[] memory _x,\r\n        uint256 _sum,\r\n        uint256 _k,\r\n        FeederConfig memory _config\r\n    ) internal pure returns (uint256 mintAmount) {\r\n        // 1. Get value of reserves according to invariant\r\n        uint256 kFinal = _invariant(_x, _sum, _config.a);\r\n        // 2. Total minted is the difference between values, with respect to total supply\r\n        if (_config.supply == 0) {\r\n            mintAmount = kFinal - _k;\r\n        } else {\r\n            mintAmount = (_config.supply * (kFinal - _k)) / _k;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Simply scaled raw reserve values and returns the sum\r\n     * @param _bAssets  All bAssets\r\n     * @return x        Scaled vault balances\r\n     * @return sum      Sum of scaled vault balances\r\n     */\r\n    function _getReserves(BassetData[] memory _bAssets)\r\n        internal\r\n        pure\r\n        returns (uint256[] memory x, uint256 sum)\r\n    {\r\n        uint256 len = _bAssets.length;\r\n        x = new uint256[](len);\r\n        uint256 r;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            BassetData memory bAsset = _bAssets[i];\r\n            r = (bAsset.vaultBalance * bAsset.ratio) / 1e8;\r\n            x[i] = r;\r\n            sum += r;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks that no bAsset reserves exceed max weight\r\n     * @param _x            Scaled bAsset reserves\r\n     * @param _sum          Sum of x, precomputed\r\n     * @param _limits       Config object containing max and min weights\r\n     * @return inBounds     Bool, true if all assets are within bounds\r\n     */\r\n    function _inBounds(\r\n        uint256[] memory _x,\r\n        uint256 _sum,\r\n        WeightLimits memory _limits\r\n    ) internal pure returns (bool inBounds) {\r\n        uint256 len = _x.length;\r\n        inBounds = true;\r\n        uint256 w;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            w = (_x[i] * 1e18) / _sum;\r\n            if (w > _limits.max || w < _limits.min) return false;\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                    INVARIANT\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Compute the invariant f(x) for a given array of supplies `x`.\r\n     * @param _x        Scaled vault balances\r\n     * @param _sum      Sum of scaled vault balances\r\n     * @param _a        Precise amplification coefficient\r\n     * @return k        Cumulative value of all assets according to the invariant\r\n     */\r\n    function _invariant(\r\n        uint256[] memory _x,\r\n        uint256 _sum,\r\n        uint256 _a\r\n    ) internal pure returns (uint256 k) {\r\n        if (_sum == 0) return 0;\r\n\r\n        uint256 var1 = _x[0] * _x[1];\r\n        uint256 var2 = (_a * var1) / (_x[0] + _x[1]) / A_PRECISION;\r\n        // result = 2 * (isqrt(var2**2 + (A + A_PRECISION) * var1 // A_PRECISION) - var2) + 1\r\n        k = 2 * (Root.sqrt((var2**2) + (((_a + A_PRECISION) * var1) / A_PRECISION)) - var2) + 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Solves the invariant for _i with respect to target K, given an array of reserves.\r\n     * @param _x        Scaled reserve balances\r\n     * @param _a        Precise amplification coefficient\r\n     * @param _idx      Index of asset for which to solve\r\n     * @param _targetK  Target invariant value K\r\n     * @return y        New reserve of _i\r\n     */\r\n    function _solveInvariant(\r\n        uint256[] memory _x,\r\n        uint256 _a,\r\n        uint8 _idx,\r\n        uint256 _targetK\r\n    ) internal pure returns (uint256 y) {\r\n        require(_idx == 0 || _idx == 1, \"Invalid index\");\r\n\r\n        uint256 x = _idx == 0 ? _x[1] : _x[0];\r\n        uint256 var1 = _a + A_PRECISION;\r\n        uint256 var2 = ((_targetK**2) * A_PRECISION) / var1;\r\n        // var3 = var2 // (4 * x) + k * _a // var1 - x\r\n        uint256 tmp = var2 / (4 * x) + ((_targetK * _a) / var1);\r\n        uint256 var3 = tmp >= x ? tmp - x : x - tmp;\r\n        //  result = (sqrt(var3**2 + var2) + var3) // 2\r\n        y = ((Root.sqrt((var3**2) + var2) + tmp - x) / 2) + 1;\r\n    }\r\n}\r\n\r\n\r\n// External\r\n// Internal\r\n// Libs\r\n/**\r\n * @title   FeederPool\r\n * @author  mStable\r\n * @notice  Base contract for Feeder Pools (fPools). Feeder Pools are combined of 50/50 fAsset and mAsset. This supports\r\n *          efficient swaps into and out of mAssets and the bAssets in the mAsset basket (a.k.a mpAssets). There is 0\r\n *          fee to trade from fAsset into mAsset, providing low cost on-ramps into mAssets.\r\n * @dev     VERSION: 1.0\r\n *          DATE:    2021-03-01\r\n */\r\ncontract FeederPool is\r\n    IFeederPool,\r\n    Initializable,\r\n    InitializableToken,\r\n    PausableModule,\r\n    InitializableReentrancyGuard\r\n{\r\n    using SafeERC20 for IERC20;\r\n    using StableMath for uint256;\r\n\r\n    // Forging Events\r\n    event Minted(\r\n        address indexed minter,\r\n        address recipient,\r\n        uint256 output,\r\n        address input,\r\n        uint256 inputQuantity\r\n    );\r\n    event MintedMulti(\r\n        address indexed minter,\r\n        address recipient,\r\n        uint256 output,\r\n        address[] inputs,\r\n        uint256[] inputQuantities\r\n    );\r\n    event Swapped(\r\n        address indexed swapper,\r\n        address input,\r\n        address output,\r\n        uint256 outputAmount,\r\n        uint256 fee,\r\n        address recipient\r\n    );\r\n    event Redeemed(\r\n        address indexed redeemer,\r\n        address recipient,\r\n        uint256 mAssetQuantity,\r\n        address output,\r\n        uint256 outputQuantity,\r\n        uint256 scaledFee\r\n    );\r\n    event RedeemedMulti(\r\n        address indexed redeemer,\r\n        address recipient,\r\n        uint256 mAssetQuantity,\r\n        address[] outputs,\r\n        uint256[] outputQuantity,\r\n        uint256 scaledFee\r\n    );\r\n    // State Events\r\n    event CacheSizeChanged(uint256 cacheSize);\r\n    event FeesChanged(uint256 swapFee, uint256 redemptionFee, uint256 govFee);\r\n    event WeightLimitsChanged(uint128 min, uint128 max);\r\n\r\n    // FeederManager Events\r\n    event BassetsMigrated(address[] bAssets, address newIntegrator);\r\n    event StartRampA(uint256 currentA, uint256 targetA, uint256 startTime, uint256 rampEndTime);\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    // Constants\r\n    uint256 private constant MAX_FEE = 1e16;\r\n    uint256 private constant A_PRECISION = 100;\r\n    address public immutable mAsset;\r\n\r\n    // Core data storage\r\n    FeederData public data;\r\n\r\n    /**\r\n     * @dev Constructor to set immutable bytecode\r\n     * @param _nexus   Nexus address\r\n     * @param _mAsset  Immutable mAsset address\r\n     */\r\n    constructor(address _nexus, address _mAsset) PausableModule(_nexus) {\r\n        mAsset = _mAsset;\r\n    }\r\n\r\n    /**\r\n     * @dev Basic initializer. Sets up core state and importantly provides infinite approvals to the mAsset pool\r\n     * to support the cross pool swaps. bAssetData and bAssetPersonal are always ordered [mAsset, fAsset].\r\n     * @param _nameArg     Name of the fPool token (a.k.a. fpToken)\r\n     * @param _symbolArg   Symbol of the fPool token\r\n     * @param _mAsset      Details on the base mAsset\r\n     * @param _fAsset      Details on the attached fAsset\r\n     * @param _mpAssets    Array of bAssets from the mAsset (to approve)\r\n     * @param _config      Starting invariant config\r\n     */\r\n    function initialize(\r\n        string calldata _nameArg,\r\n        string calldata _symbolArg,\r\n        BassetPersonal calldata _mAsset,\r\n        BassetPersonal calldata _fAsset,\r\n        address[] calldata _mpAssets,\r\n        InvariantConfig memory _config\r\n    ) public initializer {\r\n        InitializableToken._initialize(_nameArg, _symbolArg);\r\n\r\n        _initializeReentrancyGuard();\r\n\r\n        require(_mAsset.addr == mAsset, \"mAsset incorrect\");\r\n        data.bAssetPersonal.push(\r\n            BassetPersonal(_mAsset.addr, _mAsset.integrator, false, BassetStatus.Normal)\r\n        );\r\n        data.bAssetData.push(BassetData(1e8, 0));\r\n        data.bAssetPersonal.push(\r\n            BassetPersonal(_fAsset.addr, _fAsset.integrator, _fAsset.hasTxFee, BassetStatus.Normal)\r\n        );\r\n        data.bAssetData.push(\r\n            BassetData(SafeCast.toUint128(10**(26 - IBasicToken(_fAsset.addr).decimals())), 0)\r\n        );\r\n        for (uint256 i = 0; i < _mpAssets.length; i++) {\r\n            // Call will fail if bAsset does not exist\r\n            IMasset(_mAsset.addr).getBasset(_mpAssets[i]);\r\n            IERC20(_mpAssets[i]).safeApprove(_mAsset.addr, 2**255);\r\n        }\r\n\r\n        uint64 startA = SafeCast.toUint64(_config.a * A_PRECISION);\r\n        data.ampData = AmpData(startA, startA, 0, 0);\r\n        data.weightLimits = _config.limits;\r\n\r\n        data.swapFee = 4e14;\r\n        data.redemptionFee = 1e15;\r\n        data.cacheSize = 1e17;\r\n        data.govFee = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev System will be halted during a recollateralisation event\r\n     */\r\n    modifier whenInOperation() {\r\n        _isOperational();\r\n        _;\r\n    }\r\n\r\n    // Internal fn for modifier to reduce deployment size\r\n    function _isOperational() internal view {\r\n        require(!_paused || msg.sender == _recollateraliser(), \"Unhealthy\");\r\n    }\r\n\r\n    /**\r\n     * @dev Verifies that the caller is the Interest Validator contract\r\n     */\r\n    modifier onlyInterestValidator() {\r\n        require(nexus.getModule(KEY_INTEREST_VALIDATOR) == msg.sender, \"Only validator\");\r\n        _;\r\n    }\r\n\r\n    /***************************************\r\n                    MINTING\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Mint fpTokens with a single bAsset. This contract must have approval to spend the senders bAsset.\r\n     * Supports either fAsset, mAsset or mpAsset as input - with mpAssets used to mint mAsset before depositing.\r\n     * @param _input                Address of the bAsset to deposit.\r\n     * @param _inputQuantity        Quantity in input token units.\r\n     * @param _minOutputQuantity    Minimum fpToken quantity to be minted. This protects against slippage.\r\n     * @param _recipient            Receipient of the newly minted fpTokens\r\n     * @return mintOutput           Quantity of fpToken minted from the deposited bAsset.\r\n     */\r\n    function mint(\r\n        address _input,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external override nonReentrant whenInOperation returns (uint256 mintOutput) {\r\n        require(_recipient != address(0), \"Invalid recipient\");\r\n        require(_inputQuantity > 0, \"Qty==0\");\r\n\r\n        Asset memory input = _getAsset(_input);\r\n\r\n        mintOutput = FeederLogic.mint(\r\n            data,\r\n            _getConfig(),\r\n            input,\r\n            _inputQuantity,\r\n            _minOutputQuantity\r\n        );\r\n\r\n        // Mint the fpToken\r\n        _mint(_recipient, mintOutput);\r\n        emit Minted(msg.sender, _recipient, mintOutput, _input, _inputQuantity);\r\n    }\r\n\r\n    /**\r\n     * @notice Mint fpTokens with multiple bAssets. This contract must have approval to spend the senders bAssets.\r\n     * Supports only fAsset or mAsset as inputs.\r\n     * @param _inputs               Address of the bAssets to deposit.\r\n     * @param _inputQuantities      Quantity in input token units.\r\n     * @param _minOutputQuantity    Minimum fpToken quantity to be minted. This protects against slippage.\r\n     * @param _recipient            Receipient of the newly minted fpTokens\r\n     * @return mintOutput           Quantity of fpToken minted from the deposited bAssets.\r\n     */\r\n    function mintMulti(\r\n        address[] calldata _inputs,\r\n        uint256[] calldata _inputQuantities,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external override nonReentrant whenInOperation returns (uint256 mintOutput) {\r\n        require(_recipient != address(0), \"Invalid recipient\");\r\n        uint256 len = _inputQuantities.length;\r\n        require(len > 0 && len == _inputs.length, \"Input array mismatch\");\r\n\r\n        uint8[] memory indexes = _getAssets(_inputs);\r\n        mintOutput = FeederLogic.mintMulti(\r\n            data,\r\n            _getConfig(),\r\n            indexes,\r\n            _inputQuantities,\r\n            _minOutputQuantity\r\n        );\r\n        // Mint the fpToken\r\n        _mint(_recipient, mintOutput);\r\n        emit MintedMulti(msg.sender, _recipient, mintOutput, _inputs, _inputQuantities);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the projected output of a given mint.\r\n     * @param _input             Address of the bAsset to deposit\r\n     * @param _inputQuantity     Quantity in bAsset units\r\n     * @return mintOutput        Estimated mint output in fpToken terms\r\n     */\r\n    function getMintOutput(address _input, uint256 _inputQuantity)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 mintOutput)\r\n    {\r\n        require(_inputQuantity > 0, \"Qty==0\");\r\n\r\n        Asset memory input = _getAsset(_input);\r\n\r\n        if (input.exists) {\r\n            mintOutput = FeederLogic.computeMint(\r\n                data.bAssetData,\r\n                input.idx,\r\n                _inputQuantity,\r\n                _getConfig()\r\n            );\r\n        } else {\r\n            uint256 estimatedMasset = IMasset(mAsset).getMintOutput(_input, _inputQuantity);\r\n            mintOutput = FeederLogic.computeMint(data.bAssetData, 0, estimatedMasset, _getConfig());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the projected output of a given mint\r\n     * @param _inputs            Non-duplicate address array of addresses to bAssets to deposit for the minted mAsset tokens.\r\n     * @param _inputQuantities   Quantity of each bAsset to deposit for the minted fpToken.\r\n     * @return mintOutput        Estimated mint output in fpToken terms\r\n     */\r\n    function getMintMultiOutput(address[] calldata _inputs, uint256[] calldata _inputQuantities)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 mintOutput)\r\n    {\r\n        uint256 len = _inputQuantities.length;\r\n        require(len > 0 && len == _inputs.length, \"Input array mismatch\");\r\n        uint8[] memory indexes = _getAssets(_inputs);\r\n        return\r\n            FeederLogic.computeMintMulti(data.bAssetData, indexes, _inputQuantities, _getConfig());\r\n    }\r\n\r\n    /***************************************\r\n                    SWAPPING\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Swaps two assets - either internally between fAsset<>mAsset, or between fAsset<>mpAsset by\r\n     * first routing through the mAsset pool.\r\n     * @param _input             Address of bAsset to deposit\r\n     * @param _output            Address of bAsset to withdraw\r\n     * @param _inputQuantity     Units of input bAsset to swap in\r\n     * @param _minOutputQuantity Minimum quantity of the swap output asset. This protects against slippage\r\n     * @param _recipient         Address to transfer output asset to\r\n     * @return swapOutput        Quantity of output asset returned from swap\r\n     */\r\n    function swap(\r\n        address _input,\r\n        address _output,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external override nonReentrant whenInOperation returns (uint256 swapOutput) {\r\n        require(_recipient != address(0), \"Invalid recipient\");\r\n        require(_input != _output, \"Invalid pair\");\r\n        require(_inputQuantity > 0, \"Qty==0\");\r\n\r\n        Asset memory input = _getAsset(_input);\r\n        Asset memory output = _getAsset(_output);\r\n        require(_pathIsValid(input, output), \"Invalid pair\");\r\n\r\n        uint256 localFee;\r\n        (swapOutput, localFee) = FeederLogic.swap(\r\n            data,\r\n            _getConfig(),\r\n            input,\r\n            output,\r\n            _inputQuantity,\r\n            _minOutputQuantity,\r\n            _recipient\r\n        );\r\n\r\n        uint256 govFee = data.govFee;\r\n        if (govFee > 0) {\r\n            data.pendingFees += ((localFee * govFee) / 1e18);\r\n        }\r\n\r\n        emit Swapped(msg.sender, input.addr, output.addr, swapOutput, localFee, _recipient);\r\n    }\r\n\r\n    /**\r\n     * @notice Determines both if a trade is valid, and the expected fee or output.\r\n     * Swap is valid if it does not result in the input asset exceeding its maximum weight.\r\n     * @param _input             Address of bAsset to deposit\r\n     * @param _output            Address of bAsset to receive\r\n     * @param _inputQuantity     Units of input bAsset to swap\r\n     * @return swapOutput        Quantity of output asset returned from swap\r\n     */\r\n    function getSwapOutput(\r\n        address _input,\r\n        address _output,\r\n        uint256 _inputQuantity\r\n    ) external view override returns (uint256 swapOutput) {\r\n        require(_input != _output, \"Invalid pair\");\r\n        require(_inputQuantity > 0, \"Qty==0\");\r\n\r\n        Asset memory input = _getAsset(_input);\r\n        Asset memory output = _getAsset(_output);\r\n        require(_pathIsValid(input, output), \"Invalid pair\");\r\n\r\n        // Internal swap between fAsset and mAsset\r\n        if (input.exists && output.exists) {\r\n            (swapOutput, ) = FeederLogic.computeSwap(\r\n                data.bAssetData,\r\n                input.idx,\r\n                output.idx,\r\n                _inputQuantity,\r\n                output.idx == 0 ? 0 : data.swapFee,\r\n                _getConfig()\r\n            );\r\n            return swapOutput;\r\n        }\r\n\r\n        // Swapping out of fAsset\r\n        if (input.exists) {\r\n            // Swap into mAsset > Redeem into mpAsset\r\n            (swapOutput, ) = FeederLogic.computeSwap(\r\n                data.bAssetData,\r\n                1,\r\n                0,\r\n                _inputQuantity,\r\n                0,\r\n                _getConfig()\r\n            );\r\n            swapOutput = IMasset(mAsset).getRedeemOutput(_output, swapOutput);\r\n        }\r\n        // Else we are swapping into fAsset\r\n        else {\r\n            // Mint mAsset from mp > Swap into fAsset here\r\n            swapOutput = IMasset(mAsset).getMintOutput(_input, _inputQuantity);\r\n            (swapOutput, ) = FeederLogic.computeSwap(\r\n                data.bAssetData,\r\n                0,\r\n                1,\r\n                swapOutput,\r\n                data.swapFee,\r\n                _getConfig()\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a given swap path is valid. Only fAsset<>mAsset & fAsset<>mpAsset swaps are supported.\r\n     */\r\n    function _pathIsValid(Asset memory _in, Asset memory _out)\r\n        internal\r\n        pure\r\n        returns (bool isValid)\r\n    {\r\n        // mpAsset -> mpAsset\r\n        if (!_in.exists && !_out.exists) return false;\r\n        // f/mAsset -> f/mAsset\r\n        if (_in.exists && _out.exists) return true;\r\n        // fAsset -> mpAsset\r\n        if (_in.exists && _in.idx == 1) return true;\r\n        // mpAsset -> fAsset\r\n        if (_out.exists && _out.idx == 1) return true;\r\n        // Path is into or out of mAsset - just use main pool for this\r\n        return false;\r\n    }\r\n\r\n    /***************************************\r\n                    REDEMPTION\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Burns a specified quantity of the senders fpToken in return for a bAsset. The output amount is derived\r\n     * from the invariant. Supports redemption into either the fAsset, mAsset or assets in the mAsset basket.\r\n     * @param _output            Address of the bAsset to withdraw\r\n     * @param _fpTokenQuantity   Quantity of LP Token to burn\r\n     * @param _minOutputQuantity Minimum bAsset quantity to receive for the burnt fpToken. This protects against slippage.\r\n     * @param _recipient         Address to transfer the withdrawn bAssets to.\r\n     * @return outputQuantity    Quanity of bAsset units received for the burnt fpToken\r\n     */\r\n    function redeem(\r\n        address _output,\r\n        uint256 _fpTokenQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external override nonReentrant whenInOperation returns (uint256 outputQuantity) {\r\n        require(_recipient != address(0), \"Invalid recipient\");\r\n        require(_fpTokenQuantity > 0, \"Qty==0\");\r\n\r\n        Asset memory output = _getAsset(_output);\r\n\r\n        // Get config before burning. Config > Burn > CacheSize\r\n        FeederConfig memory config = _getConfig();\r\n        _burn(msg.sender, _fpTokenQuantity);\r\n\r\n        uint256 localFee;\r\n        (outputQuantity, localFee) = FeederLogic.redeem(\r\n            data,\r\n            config,\r\n            output,\r\n            _fpTokenQuantity,\r\n            _minOutputQuantity,\r\n            _recipient\r\n        );\r\n\r\n        uint256 govFee = data.govFee;\r\n        if (govFee > 0) {\r\n            data.pendingFees += ((localFee * govFee) / 1e18);\r\n        }\r\n\r\n        emit Redeemed(\r\n            msg.sender,\r\n            _recipient,\r\n            _fpTokenQuantity,\r\n            output.addr,\r\n            outputQuantity,\r\n            localFee\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Credits a recipient with a proportionate amount of bAssets, relative to current vault\r\n     * balance levels and desired fpToken quantity. Burns the fpToken as payment. Only fAsset & mAsset are supported in this path.\r\n     * @param _inputQuantity        Quantity of fpToken to redeem\r\n     * @param _minOutputQuantities  Min units of output to receive\r\n     * @param _recipient            Address to credit the withdrawn bAssets\r\n     * @return outputQuantities     Array of output asset quantities\r\n     */\r\n    function redeemProportionately(\r\n        uint256 _inputQuantity,\r\n        uint256[] calldata _minOutputQuantities,\r\n        address _recipient\r\n    ) external override nonReentrant whenInOperation returns (uint256[] memory outputQuantities) {\r\n        require(_recipient != address(0), \"Invalid recipient\");\r\n        require(_inputQuantity > 0, \"Qty==0\");\r\n\r\n        // Get config before burning. Burn > CacheSize\r\n        FeederConfig memory config = _getConfig();\r\n        _burn(msg.sender, _inputQuantity);\r\n\r\n        address[] memory outputs;\r\n        uint256 scaledFee;\r\n        (scaledFee, outputs, outputQuantities) = FeederLogic.redeemProportionately(\r\n            data,\r\n            config,\r\n            _inputQuantity,\r\n            _minOutputQuantities,\r\n            _recipient\r\n        );\r\n\r\n        uint256 govFee = data.govFee;\r\n        if (govFee > 0) {\r\n            data.pendingFees += ((scaledFee * govFee) / 1e18);\r\n        }\r\n\r\n        emit RedeemedMulti(\r\n            msg.sender,\r\n            _recipient,\r\n            _inputQuantity,\r\n            outputs,\r\n            outputQuantities,\r\n            scaledFee\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Credits a recipient with a certain quantity of selected bAssets, in exchange for burning the\r\n     *      relative fpToken quantity from the sender. Only fAsset & mAsset (0,1) are supported in this path.\r\n     * @param _outputs              Addresses of the bAssets to receive\r\n     * @param _outputQuantities     Units of the bAssets to receive\r\n     * @param _maxInputQuantity     Maximum fpToken quantity to burn for the received bAssets. This protects against slippage.\r\n     * @param _recipient            Address to receive the withdrawn bAssets\r\n     * @return fpTokenQuantity      Quantity of fpToken units burned as payment\r\n     */\r\n    function redeemExactBassets(\r\n        address[] calldata _outputs,\r\n        uint256[] calldata _outputQuantities,\r\n        uint256 _maxInputQuantity,\r\n        address _recipient\r\n    ) external override nonReentrant whenInOperation returns (uint256 fpTokenQuantity) {\r\n        require(_recipient != address(0), \"Invalid recipient\");\r\n        uint256 len = _outputQuantities.length;\r\n        require(len > 0 && len == _outputs.length, \"Invalid array input\");\r\n        require(_maxInputQuantity > 0, \"Qty==0\");\r\n\r\n        uint8[] memory indexes = _getAssets(_outputs);\r\n\r\n        uint256 localFee;\r\n        (fpTokenQuantity, localFee) = FeederLogic.redeemExactBassets(\r\n            data,\r\n            _getConfig(),\r\n            indexes,\r\n            _outputQuantities,\r\n            _maxInputQuantity,\r\n            _recipient\r\n        );\r\n\r\n        _burn(msg.sender, fpTokenQuantity);\r\n        uint256 govFee = data.govFee;\r\n        if (govFee > 0) {\r\n            data.pendingFees += ((localFee * govFee) / 1e18);\r\n        }\r\n\r\n        emit RedeemedMulti(\r\n            msg.sender,\r\n            _recipient,\r\n            fpTokenQuantity,\r\n            _outputs,\r\n            _outputQuantities,\r\n            localFee\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the estimated output from a given redeem\r\n     * @param _output            Address of the bAsset to receive\r\n     * @param _fpTokenQuantity   Quantity of fpToken to redeem\r\n     * @return bAssetOutput      Estimated quantity of bAsset units received for the burnt fpTokens\r\n     */\r\n    function getRedeemOutput(address _output, uint256 _fpTokenQuantity)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 bAssetOutput)\r\n    {\r\n        require(_fpTokenQuantity > 0, \"Qty==0\");\r\n\r\n        Asset memory output = _getAsset(_output);\r\n        uint256 scaledFee = _fpTokenQuantity.mulTruncate(data.redemptionFee);\r\n\r\n        bAssetOutput = FeederLogic.computeRedeem(\r\n            data.bAssetData,\r\n            output.exists ? output.idx : 0,\r\n            _fpTokenQuantity - scaledFee,\r\n            _getConfig()\r\n        );\r\n        // Extra step for mpAsset redemption\r\n        if (!output.exists) {\r\n            bAssetOutput = IMasset(mAsset).getRedeemOutput(output.addr, bAssetOutput);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the estimated output from a given redeem\r\n     * @param _outputs           Addresses of the bAsset to receive\r\n     * @param _outputQuantities  Quantities of bAsset to redeem\r\n     * @return fpTokenQuantity   Estimated quantity of fpToken units needed to burn to receive output\r\n     */\r\n    function getRedeemExactBassetsOutput(\r\n        address[] calldata _outputs,\r\n        uint256[] calldata _outputQuantities\r\n    ) external view override returns (uint256 fpTokenQuantity) {\r\n        uint256 len = _outputQuantities.length;\r\n        require(len > 0 && len == _outputs.length, \"Invalid array input\");\r\n\r\n        uint8[] memory indexes = _getAssets(_outputs);\r\n\r\n        uint256 mAssetRedeemed =\r\n            FeederLogic.computeRedeemExact(\r\n                data.bAssetData,\r\n                indexes,\r\n                _outputQuantities,\r\n                _getConfig()\r\n            );\r\n        fpTokenQuantity = mAssetRedeemed.divPrecisely(1e18 - data.redemptionFee);\r\n        if (fpTokenQuantity > 0) fpTokenQuantity += 1;\r\n    }\r\n\r\n    /***************************************\r\n                    GETTERS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Gets the price of the fpToken, and invariant value k\r\n     * @return price    Price of an fpToken\r\n     * @return k        Total value of basket, k\r\n     */\r\n    function getPrice() public view override returns (uint256 price, uint256 k) {\r\n        return FeederLogic.computePrice(data.bAssetData, _getConfig());\r\n    }\r\n\r\n    /**\r\n     * @notice Gets all config needed for general InvariantValidator calls\r\n     */\r\n    function getConfig() external view override returns (FeederConfig memory config) {\r\n        return _getConfig();\r\n    }\r\n\r\n    /**\r\n     * @notice Get data for a specific bAsset, if it exists\r\n     * @param _bAsset     Address of bAsset\r\n     * @return personal   Struct with personal data\r\n     * @return vaultData  Struct with full bAsset data\r\n     */\r\n    function getBasset(address _bAsset)\r\n        external\r\n        view\r\n        override\r\n        returns (BassetPersonal memory personal, BassetData memory vaultData)\r\n    {\r\n        Asset memory asset = _getAsset(_bAsset);\r\n        require(asset.exists, \"Invalid asset\");\r\n        personal = data.bAssetPersonal[asset.idx];\r\n        vaultData = data.bAssetData[asset.idx];\r\n    }\r\n\r\n    /**\r\n     * @notice Get data for a all bAssets in basket\r\n     * @return personal    Struct[] with full bAsset data\r\n     * @return vaultData   Number of bAssets in the Basket\r\n     */\r\n    function getBassets()\r\n        external\r\n        view\r\n        override\r\n        returns (BassetPersonal[] memory, BassetData[] memory vaultData)\r\n    {\r\n        return (data.bAssetPersonal, data.bAssetData);\r\n    }\r\n\r\n    /***************************************\r\n                GETTERS - INTERNAL\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Checks if a given asset exists in basket and return the index.\r\n     * @return status    Data containing address, index and whether it exists in basket\r\n     */\r\n    function _getAsset(address _asset) internal view returns (Asset memory status) {\r\n        // if input is mAsset then we know the position\r\n        if (_asset == mAsset) return Asset(0, _asset, true);\r\n\r\n        // else it exists if the position 1 is _asset\r\n        return Asset(1, _asset, data.bAssetPersonal[1].addr == _asset);\r\n    }\r\n\r\n    /**\r\n     * @dev Validates an array of input assets and returns their indexes. Assets must exist\r\n     * in order to be valid, as mintMulti and redeemMulti do not support external bAssets.\r\n     */\r\n    function _getAssets(address[] memory _assets) internal view returns (uint8[] memory indexes) {\r\n        uint256 len = _assets.length;\r\n\r\n        indexes = new uint8[](len);\r\n\r\n        Asset memory input_;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            input_ = _getAsset(_assets[i]);\r\n            indexes[i] = input_.idx;\r\n            require(input_.exists, \"Invalid asset\");\r\n\r\n            for (uint256 j = i + 1; j < len; j++) {\r\n                require(_assets[i] != _assets[j], \"Duplicate asset\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets all config needed for general InvariantValidator calls\r\n     */\r\n    function _getConfig() internal view returns (FeederConfig memory) {\r\n        return FeederConfig(totalSupply() + data.pendingFees, _getA(), data.weightLimits);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets current amplification var A\r\n     */\r\n    function _getA() internal view returns (uint256) {\r\n        AmpData memory ampData_ = data.ampData;\r\n\r\n        uint64 endA = ampData_.targetA;\r\n        uint64 endTime = ampData_.rampEndTime;\r\n\r\n        // If still changing, work out based on current timestmap\r\n        if (block.timestamp < endTime) {\r\n            uint64 startA = ampData_.initialA;\r\n            uint64 startTime = ampData_.rampStartTime;\r\n\r\n            (uint256 elapsed, uint256 total) = (block.timestamp - startTime, endTime - startTime);\r\n\r\n            if (endA > startA) {\r\n                return startA + (((endA - startA) * elapsed) / total);\r\n            } else {\r\n                return startA - (((startA - endA) * elapsed) / total);\r\n            }\r\n        }\r\n        // Else return final value\r\n        else {\r\n            return endA;\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                    YIELD\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Collects the interest generated from the lending markets, performing a theoretical mint, which\r\n     * is then validated by the interest validator to protect against accidental hyper inflation.\r\n     * @return mintAmount   fpToken units generated from interest collected from lending markets\r\n     * @return newSupply    fpToken total supply after mint\r\n     */\r\n    function collectPlatformInterest()\r\n        external\r\n        override\r\n        onlyInterestValidator\r\n        whenInOperation\r\n        nonReentrant\r\n        returns (uint256 mintAmount, uint256 newSupply)\r\n    {\r\n        (uint8[] memory idxs, uint256[] memory gains) =\r\n            FeederManager.calculatePlatformInterest(data.bAssetPersonal, data.bAssetData);\r\n        // Calculate potential mint amount. This will be validated by the interest validator\r\n        mintAmount = FeederLogic.computeMintMulti(data.bAssetData, idxs, gains, _getConfig());\r\n        newSupply = totalSupply() + data.pendingFees + mintAmount;\r\n\r\n        uint256 govFee = data.govFee;\r\n        if (govFee > 0) {\r\n            data.pendingFees += ((mintAmount * govFee) / 1e18);\r\n        }\r\n\r\n        // Dummy mint event to catch the collections here\r\n        emit MintedMulti(address(this), msg.sender, 0, new address[](0), gains);\r\n    }\r\n\r\n    /**\r\n     * @dev Collects the pending gov fees extracted from swap, redeem and platform interest.\r\n     */\r\n    function collectPendingFees() external onlyInterestValidator {\r\n        uint256 fees = data.pendingFees;\r\n        if (fees > 1) {\r\n            uint256 mintAmount = fees - 1;\r\n            data.pendingFees = 1;\r\n\r\n            _mint(msg.sender, mintAmount);\r\n            emit MintedMulti(\r\n                address(this),\r\n                msg.sender,\r\n                mintAmount,\r\n                new address[](0),\r\n                new uint256[](0)\r\n            );\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                    STATE\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Sets the MAX cache size for each bAsset. The cache will actually revolve around\r\n     *      _cacheSize * totalSupply / 2 under normal circumstances.\r\n     * @param _cacheSize Maximum percent of total fpToken supply to hold for each bAsset\r\n     */\r\n    function setCacheSize(uint256 _cacheSize) external onlyGovernor {\r\n        require(_cacheSize <= 2e17, \"Must be <= 20%\");\r\n\r\n        data.cacheSize = _cacheSize;\r\n\r\n        emit CacheSizeChanged(_cacheSize);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the ecosystem fee for sewapping bAssets or redeeming specific bAssets\r\n     * @param _swapFee       Fee calculated in (%/100 * 1e18)\r\n     * @param _redemptionFee Fee calculated in (%/100 * 1e18)\r\n     * @param _govFee        Fee calculated in (%/100 * 1e18)\r\n     */\r\n    function setFees(\r\n        uint256 _swapFee,\r\n        uint256 _redemptionFee,\r\n        uint256 _govFee\r\n    ) external onlyGovernor {\r\n        require(_swapFee <= MAX_FEE, \"Swap rate oob\");\r\n        require(_redemptionFee <= MAX_FEE, \"Redemption rate oob\");\r\n        require(_govFee <= 5e17, \"Gov fee rate oob\");\r\n\r\n        data.swapFee = _swapFee;\r\n        data.redemptionFee = _redemptionFee;\r\n        data.govFee = _govFee;\r\n\r\n        emit FeesChanged(_swapFee, _redemptionFee, _govFee);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the maximum weight across all bAssets\r\n     * @param _min Weight where 100% = 1e18\r\n     * @param _max Weight where 100% = 1e18\r\n     */\r\n    function setWeightLimits(uint128 _min, uint128 _max) external onlyGovernor {\r\n        require(_min <= 3e17 && _max >= 7e17, \"Weights oob\");\r\n\r\n        data.weightLimits = WeightLimits(_min, _max);\r\n\r\n        emit WeightLimitsChanged(_min, _max);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers all collateral from one lending market to another - used initially\r\n     *      to handle the migration between Aave V1 and Aave V2. Note - only supports non\r\n     *      tx fee enabled assets. Supports going from no integration to integration, but\r\n     *      not the other way around.\r\n     * @param _bAssets Array of basket assets to migrate\r\n     * @param _newIntegration Address of the new platform integration\r\n     */\r\n    function migrateBassets(address[] calldata _bAssets, address _newIntegration)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        FeederManager.migrateBassets(data.bAssetPersonal, _bAssets, _newIntegration);\r\n    }\r\n\r\n    /**\r\n     * @dev Starts changing of the amplification var A\r\n     * @param _targetA      Target A value\r\n     * @param _rampEndTime  Time at which A will arrive at _targetA\r\n     */\r\n    function startRampA(uint256 _targetA, uint256 _rampEndTime) external onlyGovernor {\r\n        FeederManager.startRampA(data.ampData, _targetA, _rampEndTime, _getA(), A_PRECISION);\r\n    }\r\n\r\n    /**\r\n     * @dev Stops the changing of the amplification var A, setting\r\n     * it to whatever the current value is.\r\n     */\r\n    function stopRampA() external onlyGovernor {\r\n        FeederManager.stopRampA(data.ampData, _getA());\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nexus\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mAsset\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"bAssets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newIntegrator\",\"type\":\"address\"}],\"name\":\"BassetsMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cacheSize\",\"type\":\"uint256\"}],\"name\":\"CacheSizeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redemptionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"govFee\",\"type\":\"uint256\"}],\"name\":\"FeesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputQuantity\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"inputs\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"inputQuantities\",\"type\":\"uint256[]\"}],\"name\":\"MintedMulti\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mAssetQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"output\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scaledFee\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mAssetQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"outputs\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"outputQuantity\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scaledFee\",\"type\":\"uint256\"}],\"name\":\"RedeemedMulti\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rampEndTime\",\"type\":\"uint256\"}],\"name\":\"StartRampA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"StopRampA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"output\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"name\":\"WeightLimitsChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectPendingFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectPlatformInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"data\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redemptionFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"govFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cacheSize\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"initialA\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"targetA\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"rampStartTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"rampEndTime\",\"type\":\"uint64\"}],\"internalType\":\"struct AmpData\",\"name\":\"ampData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct WeightLimits\",\"name\":\"weightLimits\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bAsset\",\"type\":\"address\"}],\"name\":\"getBasset\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"integrator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasTxFee\",\"type\":\"bool\"},{\"internalType\":\"enum BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct BassetPersonal\",\"name\":\"personal\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct BassetData\",\"name\":\"vaultData\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBassets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"integrator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasTxFee\",\"type\":\"bool\"},{\"internalType\":\"enum BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct BassetPersonal[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct BassetData[]\",\"name\":\"vaultData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct FeederConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_inputs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_inputQuantities\",\"type\":\"uint256[]\"}],\"name\":\"getMintMultiOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputQuantity\",\"type\":\"uint256\"}],\"name\":\"getMintOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_outputs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_outputQuantities\",\"type\":\"uint256[]\"}],\"name\":\"getRedeemExactBassetsOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fpTokenQuantity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fpTokenQuantity\",\"type\":\"uint256\"}],\"name\":\"getRedeemOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bAssetOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputQuantity\",\"type\":\"uint256\"}],\"name\":\"getSwapOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_nameArg\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbolArg\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"integrator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasTxFee\",\"type\":\"bool\"},{\"internalType\":\"enum BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct BassetPersonal\",\"name\":\"_mAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"integrator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasTxFee\",\"type\":\"bool\"},{\"internalType\":\"enum BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct BassetPersonal\",\"name\":\"_fAsset\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"_mpAssets\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct InvariantConfig\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bAssets\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_newIntegration\",\"type\":\"address\"}],\"name\":\"migrateBassets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOutputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_inputs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_inputQuantities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_minOutputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"mintMulti\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nexus\",\"outputs\":[{\"internalType\":\"contract INexus\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fpTokenQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOutputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputQuantity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_outputs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_outputQuantities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_maxInputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"redeemExactBassets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fpTokenQuantity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_inputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_minOutputQuantities\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"redeemProportionately\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"outputQuantities\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cacheSize\",\"type\":\"uint256\"}],\"name\":\"setCacheSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_redemptionFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_govFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_max\",\"type\":\"uint128\"}],\"name\":\"setWeightLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_targetA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rampEndTime\",\"type\":\"uint256\"}],\"name\":\"startRampA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopRampA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOutputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"FeederPool","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000afce80b19a8ce13dec0739a1aab7a028d6845eb3000000000000000000000000945facb997494cc2570096c74b5f66a3507330a1","EVMVersion":"Default","Library":"FeederManager:90ae544e8cc76d2867987ee4f5456c02c50abd8b;FeederLogic:2837c77527c37d61d9763f53005211dacb4125de","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d6da3799ecba2e803f9352b6b3400dac6b289c58c4c43c537f4706d883575976"}]}