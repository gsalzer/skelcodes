{"status":"1","message":"OK","result":[{"SourceCode":"{\"address-utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev Utility library of inline functions on addresses.\\r\\n * @notice Based on:\\r\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\\r\\n * Requires EIP-1052.\\r\\n */\\r\\nlibrary AddressUtils\\r\\n{\\r\\n\\r\\n  /**\\r\\n   * @dev Returns whether the target address is a contract.\\r\\n   * @param _addr Address to check.\\r\\n   * @return addressCheck True if _addr is a contract, false if not.\\r\\n   */\\r\\n  function isContract(\\r\\n    address _addr\\r\\n  )\\r\\n    internal\\r\\n    view\\r\\n    returns (bool addressCheck)\\r\\n  {\\r\\n    // This method relies in extcodesize, which returns 0 for contracts in\\r\\n    // construction, since the code is only stored at the end of the\\r\\n    // constructor execution.\\r\\n\\r\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n    // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n    bytes32 codehash;\\r\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n    assembly { codehash := extcodehash(_addr) } // solhint-disable-line\\r\\n    addressCheck = (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\r\\n  }\\r\\n\\r\\n}\\r\\n\"},\"cmk-utils.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ncontract CmkUtils {\\r\\n    function getMin(uint256 a,uint256 b) internal pure returns(uint256){\\r\\n        if(a\\u003eb) return b;\\r\\n        else return a;\\r\\n    }\\r\\n\\r\\n    function uint2str(uint256 _i) internal pure returns (string memory str) {\\r\\n        if (_i == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 j = _i;\\r\\n        uint256 length;\\r\\n        while (j != 0) {\\r\\n            length++;\\r\\n            j /= 10;\\r\\n        }\\r\\n        bytes memory bstr = new bytes(length);\\r\\n        uint256 k = length;\\r\\n        j = _i;\\r\\n        while (j != 0) {\\r\\n            bstr[--k] = bytes1(uint8(48 + (j % 10)));\\r\\n            j /= 10;\\r\\n        }\\r\\n        str = string(bstr);\\r\\n    }\\r\\n\\r\\n    function strConcat(string memory _a, string memory _b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory _concatenatedString)\\r\\n    {\\r\\n        return strConcat(_a, _b, \\\"\\\", \\\"\\\", \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function strConcat(\\r\\n        string memory _a,\\r\\n        string memory _b,\\r\\n        string memory _c\\r\\n    ) internal pure returns (string memory _concatenatedString) {\\r\\n        return strConcat(_a, _b, _c, \\\"\\\", \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function strConcat(\\r\\n        string memory _a,\\r\\n        string memory _b,\\r\\n        string memory _c,\\r\\n        string memory _d\\r\\n    ) internal pure returns (string memory _concatenatedString) {\\r\\n        return strConcat(_a, _b, _c, _d, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function strConcat(\\r\\n        string memory _a,\\r\\n        string memory _b,\\r\\n        string memory _c,\\r\\n        string memory _d,\\r\\n        string memory _e\\r\\n    ) internal pure returns (string memory _concatenatedString) {\\r\\n        bytes memory _ba = bytes(_a);\\r\\n        bytes memory _bb = bytes(_b);\\r\\n        bytes memory _bc = bytes(_c);\\r\\n        bytes memory _bd = bytes(_d);\\r\\n        bytes memory _be = bytes(_e);\\r\\n        string memory abcde = new string(\\r\\n            _ba.length + _bb.length + _bc.length + _bd.length + _be.length\\r\\n        );\\r\\n        bytes memory babcde = bytes(abcde);\\r\\n        uint256 k = 0;\\r\\n        uint256 i = 0;\\r\\n        for (i = 0; i \\u003c _ba.length; i++) {\\r\\n            babcde[k++] = _ba[i];\\r\\n        }\\r\\n        for (i = 0; i \\u003c _bb.length; i++) {\\r\\n            babcde[k++] = _bb[i];\\r\\n        }\\r\\n        for (i = 0; i \\u003c _bc.length; i++) {\\r\\n            babcde[k++] = _bc[i];\\r\\n        }\\r\\n        for (i = 0; i \\u003c _bd.length; i++) {\\r\\n            babcde[k++] = _bd[i];\\r\\n        }\\r\\n        for (i = 0; i \\u003c _be.length; i++) {\\r\\n            babcde[k++] = _be[i];\\r\\n        }\\r\\n        return string(babcde);\\r\\n    }\\r\\n}\\r\\n\"},\"crypto-monkey-king.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity ^0.8.4;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./erc721-metadata.sol\\\";\\r\\nimport \\\"./nf-token-enumerable.sol\\\";\\r\\nimport \\\"./ownable.sol\\\";\\r\\nimport \\\"./address-utils.sol\\\";\\r\\nimport \\\"./cmk-utils.sol\\\";\\r\\nimport \\\"./datetime-library.sol\\\";\\r\\n\\r\\ncontract CryptoMonkeyKing is\\r\\n    NFTokenEnumerable,\\r\\n    Ownable,\\r\\n    CmkUtils,\\r\\n    ERC721Metadata\\r\\n{\\r\\n    using AddressUtils for address;\\r\\n\\r\\n    /************************************struct********************************/\\r\\n    struct NFT {\\r\\n        uint256 id;\\r\\n        bool isSelling;\\r\\n        uint256 priceInWei;\\r\\n        address owner;\\r\\n    }\\r\\n\\r\\n    struct MintedInfo {\\r\\n        uint256 lastYear;\\r\\n        uint256 lastMonth;\\r\\n        uint256 lastDay;\\r\\n        uint256 lastCount;\\r\\n        uint256 minted;\\r\\n    }\\r\\n\\r\\n    /************************************error********************************/\\r\\n    string constant NOT_VALID_NFT_ID = \\\"004001\\\";\\r\\n    string constant NOT_RESERVE = \\\"004002\\\";\\r\\n    string constant NOT_NORMAL = \\\"004003\\\";\\r\\n    string constant IN_SELLING = \\\"004004\\\";\\r\\n    string constant NO_SELLING = \\\"004005\\\";\\r\\n    string constant NFT_HAS_NO_OWNER = \\\"004006\\\";\\r\\n    string constant NFT_HAS_OWNER = \\\"004007\\\";\\r\\n    string constant IS_NFT_OWNER = \\\"004008\\\";\\r\\n    string constant NOT_NFT_OWNER = \\\"004009\\\";\\r\\n    string constant NOT_AIRDROP_ACCOUNT = \\\"004010\\\";\\r\\n    string constant NOT_ENOUGH_BALANCE = \\\"004011\\\";\\r\\n    string constant OUT_OF_MAX_PAGE_SIZE = \\\"004012\\\";\\r\\n    string constant OUT_OF_MINT_MAX_PER_TIME = \\\"004013\\\";\\r\\n    string constant OUT_OF_MINT_MAX_PER_DAY = \\\"004014\\\";\\r\\n    string constant SENDER_MINTED = \\\"004015\\\";\\r\\n\\r\\n    /************************************variable********************************/\\r\\n    string private baseURI;\\r\\n    address private airdropAccount;\\r\\n    uint256 private maxSupply;\\r\\n    uint256 private maxPageSize;\\r\\n    uint256 private maxMintPerTime;\\r\\n    uint256 private mintMaxPerDay;\\r\\n    uint256 private mintPrice;\\r\\n    MintedInfo mintedInfo;\\r\\n    mapping(address =\\u003e bool) private addressToMinted;\\r\\n\\r\\n    /************************************validator********************************/\\r\\n    modifier onlyAirdrop() {\\r\\n        require(msg.sender == airdropAccount, NOT_AIRDROP_ACCOUNT);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier validNFTId(uint256 _id) {\\r\\n        require(_id \\u003e= 0 \\u0026\\u0026 _id \\u003c= maxSupply - 1, NOT_VALID_NFT_ID);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /************************************helps********************************/\\r\\n    function isReserve(uint256 _id) internal pure returns (bool) {\\r\\n        return _id \\u003e= 7000 \\u0026\\u0026 _id \\u003c 10000;\\r\\n    }\\r\\n\\r\\n    function isNormal(uint256 _id) internal pure returns (bool) {\\r\\n        return _id \\u003e= 0 \\u0026\\u0026 _id \\u003c 7000;\\r\\n    }\\r\\n\\r\\n    /************************************business********************************/\\r\\n    /***contructor***/\\r\\n    constructor() {\\r\\n        baseURI = \\\"https://cryptomonkeyking.com/token\\\";\\r\\n        airdropAccount = 0x251d42b900973eD14D7Ea82Ce9310D34534f75EC;\\r\\n        maxSupply = 10000;\\r\\n        maxPageSize = 1000;\\r\\n        maxMintPerTime = 5;\\r\\n        mintMaxPerDay = 200;\\r\\n    }\\r\\n\\r\\n    /***ERC721Metadata***/\\r\\n    function name() external pure override returns (string memory _name) {\\r\\n        return \\\"Crypto Monkey King\\\";\\r\\n    }\\r\\n\\r\\n    function symbol() external pure override returns (string memory _symbol) {\\r\\n        return \\\"CMK\\\";\\r\\n    }\\r\\n\\r\\n    function tokenURI(uint256 _id)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (string memory)\\r\\n    {\\r\\n        return strConcat(baseURI, \\\"/\\\", uint2str(_id));\\r\\n    }\\r\\n\\r\\n    /***onlyOwner***/\\r\\n    function setBaseURI(string memory _baseURI) public onlyOwner {\\r\\n        baseURI = _baseURI;\\r\\n    }\\r\\n\\r\\n    function getBaseURI() public view onlyOwner returns (string memory) {\\r\\n        return baseURI;\\r\\n    }\\r\\n\\r\\n    function setAirdropAccount(address _airdropAccount) public onlyOwner {\\r\\n        airdropAccount = _airdropAccount;\\r\\n    }\\r\\n\\r\\n    function getAirdropAccount() public view onlyOwner returns (address) {\\r\\n        return airdropAccount;\\r\\n    }\\r\\n\\r\\n    function setMintPrice(uint256 _mintPrice) public onlyOwner {\\r\\n        mintPrice = _mintPrice;\\r\\n    }\\r\\n\\r\\n    function getMintPrice() public view returns (uint256) {\\r\\n        return mintPrice;\\r\\n    }\\r\\n\\r\\n    function setMaxMintPerTime(uint256 _maxMintPerTime) public onlyOwner {\\r\\n        maxMintPerTime = _maxMintPerTime;\\r\\n    }\\r\\n\\r\\n    function getMaxMintPerTime() public view returns (uint256) {\\r\\n        return maxMintPerTime;\\r\\n    }\\r\\n\\r\\n    function setMintMaxPerDay(uint256 _mintMaxPerDay) public onlyOwner {\\r\\n        mintMaxPerDay = _mintMaxPerDay;\\r\\n    }\\r\\n\\r\\n    function getMintMaxPerDay() public view returns (uint256) {\\r\\n        return mintMaxPerDay;\\r\\n    }\\r\\n\\r\\n    /***business***/\\r\\n    function getMaxSupply() public view returns (uint256) {\\r\\n        return maxSupply;\\r\\n    }\\r\\n\\r\\n    function getMaxPageSize() public view returns (uint256) {\\r\\n        return maxPageSize;\\r\\n    }\\r\\n\\r\\n    function getMintableRemaining() public view returns (uint256) {\\r\\n        return 7000 - mintedInfo.minted;\\r\\n    }\\r\\n\\r\\n    function getPagedNFTs(uint256 pageSize, uint256 pageIndex)\\r\\n        public\\r\\n        view\\r\\n        returns (NFT[] memory)\\r\\n    {\\r\\n        require(pageSize \\u003c= maxPageSize, OUT_OF_MAX_PAGE_SIZE);\\r\\n\\r\\n        uint256 start = pageSize * pageIndex;\\r\\n        uint256 end = start + pageSize - 1;\\r\\n\\r\\n        if (start \\u003e maxSupply - 1) {\\r\\n            start = maxSupply - 1;\\r\\n        }\\r\\n\\r\\n        if (end \\u003e maxSupply - 1) {\\r\\n            end = maxSupply - 1;\\r\\n        }\\r\\n\\r\\n        NFT[] memory NFTs = new NFT[](pageSize);\\r\\n        for (uint256 i = start; i \\u003c= end; i++) {\\r\\n            address owner = idToOwner[i];\\r\\n            NFT memory nft = NFT(i, false, 0, owner);\\r\\n            NFTs[i - start] = nft;\\r\\n        }\\r\\n        return NFTs;\\r\\n    }\\r\\n\\r\\n    function getMintedCountToday() public view returns(uint256){\\r\\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary\\r\\n            .timestampToDate(block.timestamp);\\r\\n        uint count=0;\\r\\n        if (\\r\\n            mintedInfo.lastYear == year \\u0026\\u0026\\r\\n            mintedInfo.lastMonth == month \\u0026\\u0026\\r\\n            mintedInfo.lastDay == day\\r\\n        ) {\\r\\n            count = mintedInfo.lastCount;\\r\\n        } else {\\r\\n            count = 0;\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n\\r\\n    function getMintableCountToday() public view returns (uint256) {\\r\\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary\\r\\n            .timestampToDate(block.timestamp);\\r\\n\\r\\n        uint256 count = 0;\\r\\n        uint256 remainToday = CmkUtils.getMin(7000 - mintedInfo.minted, mintMaxPerDay);\\r\\n        if (\\r\\n            mintedInfo.lastYear == year \\u0026\\u0026\\r\\n            mintedInfo.lastMonth == month \\u0026\\u0026\\r\\n            mintedInfo.lastDay == day\\r\\n        ) {\\r\\n            count = remainToday - mintedInfo.lastCount;\\r\\n        } else {\\r\\n            count = remainToday;\\r\\n        }\\r\\n\\r\\n        if (count \\u003c 0) {\\r\\n            count = 0;\\r\\n        }\\r\\n\\r\\n        return count;\\r\\n    }\\r\\n\\r\\n    function isMinted(address _addr) public view returns (bool) {\\r\\n        return addressToMinted[_addr];\\r\\n    }\\r\\n\\r\\n    function mintNFTs(uint256[] memory _ids) public payable {\\r\\n        // 需要未领过\\r\\n        require(!addressToMinted[msg.sender], SENDER_MINTED);\\r\\n        // 不要超过当日可领上限\\r\\n        require(\\r\\n            _ids.length \\u003c= getMintableCountToday(),\\r\\n            OUT_OF_MINT_MAX_PER_DAY\\r\\n        );\\r\\n        // 不要超过每次可领上限\\r\\n        require(_ids.length \\u003c= maxMintPerTime, OUT_OF_MINT_MAX_PER_TIME);\\r\\n\\r\\n        uint256 total = _ids.length * mintPrice;\\r\\n        require(total \\u003c= msg.value, NOT_ENOUGH_BALANCE);\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c _ids.length; i++) {\\r\\n            uint256 _id = _ids[i];\\r\\n            require(isNormal(_id), NOT_NORMAL);\\r\\n            require(idToOwner[_id] == address(0), NFT_HAS_OWNER);\\r\\n\\r\\n            _mint(msg.sender, _id);\\r\\n        }\\r\\n\\r\\n        // 更新当日领取数\\r\\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary\\r\\n            .timestampToDate(block.timestamp);\\r\\n\\r\\n        if (\\r\\n            mintedInfo.lastYear == year \\u0026\\u0026\\r\\n            mintedInfo.lastMonth == month \\u0026\\u0026\\r\\n            mintedInfo.lastDay == day\\r\\n        ) {\\r\\n            mintedInfo.lastCount += _ids.length;\\r\\n        } else {\\r\\n            mintedInfo.lastCount = _ids.length;\\r\\n        }\\r\\n\\r\\n        // 更新最近领取时间\\r\\n        mintedInfo.lastYear = year;\\r\\n        mintedInfo.lastMonth = month;\\r\\n        mintedInfo.lastDay = day;\\r\\n\\r\\n        // 更新累计已领\\r\\n        mintedInfo.minted += _ids.length;\\r\\n\\r\\n        // 标记已领取\\r\\n        addressToMinted[msg.sender] = true;\\r\\n\\r\\n        // 收款\\r\\n        if (mintPrice \\u003e 0) {\\r\\n            payable(owner).transfer(msg.value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function airdropNFT(address _to, uint256 _id)\\r\\n        public\\r\\n        onlyAirdrop\\r\\n        validNFTId(_id)\\r\\n    {\\r\\n        require(isReserve(_id), NOT_RESERVE);\\r\\n        require(idToOwner[_id] == address(0), NFT_HAS_OWNER);\\r\\n\\r\\n        _mint(_to, _id);\\r\\n    }\\r\\n\\r\\n    function airdropNFTs(address _to, uint256[] memory _ids) public {\\r\\n        for (uint256 i = 0; i \\u003c _ids.length; i++) {\\r\\n            uint256 id = _ids[i];\\r\\n            airdropNFT(_to, id);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function giveNFT(address _to, uint256 _id) public validNFTId(_id) {\\r\\n        require(this.ownerOf(_id) == msg.sender, NOT_NFT_OWNER);\\r\\n\\r\\n        _transfer(_to, _id);\\r\\n    }\\r\\n\\r\\n    function giveNFTs(address _to, uint256[] memory _ids) public {\\r\\n        for (uint256 i = 0; i \\u003c _ids.length; i++) {\\r\\n            uint256 id = _ids[i];\\r\\n            giveNFT(_to, id);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"datetime-library.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// BokkyPooBah\\u0027s DateTime Library v1.01\\r\\n//\\r\\n// A gas-efficient Solidity date and time library\\r\\n//\\r\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\r\\n//\\r\\n// Tested date range 1970/01/01 to 2345/12/31\\r\\n//\\r\\n// Conventions:\\r\\n// Unit      | Range         | Notes\\r\\n// :-------- |:-------------:|:-----\\r\\n// timestamp | \\u003e= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\r\\n// year      | 1970 ... 2345 |\\r\\n// month     | 1 ... 12      |\\r\\n// day       | 1 ... 31      |\\r\\n// hour      | 0 ... 23      |\\r\\n// minute    | 0 ... 59      |\\r\\n// second    | 0 ... 59      |\\r\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\r\\n//\\r\\n//\\r\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\\r\\n// ----------------------------------------------------------------------------\\r\\n\\r\\nlibrary BokkyPooBahsDateTimeLibrary {\\r\\n\\r\\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\\r\\n    uint constant SECONDS_PER_HOUR = 60 * 60;\\r\\n    uint constant SECONDS_PER_MINUTE = 60;\\r\\n    int constant OFFSET19700101 = 2440588;\\r\\n\\r\\n    uint constant DOW_MON = 1;\\r\\n    uint constant DOW_TUE = 2;\\r\\n    uint constant DOW_WED = 3;\\r\\n    uint constant DOW_THU = 4;\\r\\n    uint constant DOW_FRI = 5;\\r\\n    uint constant DOW_SAT = 6;\\r\\n    uint constant DOW_SUN = 7;\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Calculate the number of days from 1970/01/01 to year/month/day using\\r\\n    // the date conversion algorithm from\\r\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\r\\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\r\\n    //\\r\\n    // days = day\\r\\n    //      - 32075\\r\\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\r\\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\r\\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\r\\n    //      - offset\\r\\n    // ------------------------------------------------------------------------\\r\\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\\r\\n        require(year \\u003e= 1970);\\r\\n        int _year = int(year);\\r\\n        int _month = int(month);\\r\\n        int _day = int(day);\\r\\n\\r\\n        int __days = _day\\r\\n          - 32075\\r\\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\\r\\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\\r\\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\\r\\n          - OFFSET19700101;\\r\\n\\r\\n        _days = uint(__days);\\r\\n    }\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\r\\n    // the date conversion algorithm from\\r\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\r\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\r\\n    //\\r\\n    // int L = days + 68569 + offset\\r\\n    // int N = 4 * L / 146097\\r\\n    // L = L - (146097 * N + 3) / 4\\r\\n    // year = 4000 * (L + 1) / 1461001\\r\\n    // L = L - 1461 * year / 4 + 31\\r\\n    // month = 80 * L / 2447\\r\\n    // dd = L - 2447 * month / 80\\r\\n    // L = month / 11\\r\\n    // month = month + 2 - 12 * L\\r\\n    // year = 100 * (N - 49) + year + L\\r\\n    // ------------------------------------------------------------------------\\r\\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\\r\\n        int __days = int(_days);\\r\\n\\r\\n        int L = __days + 68569 + OFFSET19700101;\\r\\n        int N = 4 * L / 146097;\\r\\n        L = L - (146097 * N + 3) / 4;\\r\\n        int _year = 4000 * (L + 1) / 1461001;\\r\\n        L = L - 1461 * _year / 4 + 31;\\r\\n        int _month = 80 * L / 2447;\\r\\n        int _day = L - 2447 * _month / 80;\\r\\n        L = _month / 11;\\r\\n        _month = _month + 2 - 12 * L;\\r\\n        _year = 100 * (N - 49) + _year + L;\\r\\n\\r\\n        year = uint(_year);\\r\\n        month = uint(_month);\\r\\n        day = uint(_day);\\r\\n    }\\r\\n\\r\\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\\r\\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\\r\\n    }\\r\\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\\r\\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\\r\\n    }\\r\\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\\r\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\\r\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        uint secs = timestamp % SECONDS_PER_DAY;\\r\\n        hour = secs / SECONDS_PER_HOUR;\\r\\n        secs = secs % SECONDS_PER_HOUR;\\r\\n        minute = secs / SECONDS_PER_MINUTE;\\r\\n        second = secs % SECONDS_PER_MINUTE;\\r\\n    }\\r\\n\\r\\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\\r\\n        if (year \\u003e= 1970 \\u0026\\u0026 month \\u003e 0 \\u0026\\u0026 month \\u003c= 12) {\\r\\n            uint daysInMonth = _getDaysInMonth(year, month);\\r\\n            if (day \\u003e 0 \\u0026\\u0026 day \\u003c= daysInMonth) {\\r\\n                valid = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\\r\\n        if (isValidDate(year, month, day)) {\\r\\n            if (hour \\u003c 24 \\u0026\\u0026 minute \\u003c 60 \\u0026\\u0026 second \\u003c 60) {\\r\\n                valid = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\\r\\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        leapYear = _isLeapYear(year);\\r\\n    }\\r\\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\\r\\n        leapYear = ((year % 4 == 0) \\u0026\\u0026 (year % 100 != 0)) || (year % 400 == 0);\\r\\n    }\\r\\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\\r\\n        weekDay = getDayOfWeek(timestamp) \\u003c= DOW_FRI;\\r\\n    }\\r\\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\\r\\n        weekEnd = getDayOfWeek(timestamp) \\u003e= DOW_SAT;\\r\\n    }\\r\\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\\r\\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        daysInMonth = _getDaysInMonth(year, month);\\r\\n    }\\r\\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\\r\\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\r\\n            daysInMonth = 31;\\r\\n        } else if (month != 2) {\\r\\n            daysInMonth = 30;\\r\\n        } else {\\r\\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\\r\\n        }\\r\\n    }\\r\\n    // 1 = Monday, 7 = Sunday\\r\\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\\r\\n        uint _days = timestamp / SECONDS_PER_DAY;\\r\\n        dayOfWeek = (_days + 3) % 7 + 1;\\r\\n    }\\r\\n\\r\\n    function getYear(uint timestamp) internal pure returns (uint year) {\\r\\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    function getMonth(uint timestamp) internal pure returns (uint month) {\\r\\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    function getDay(uint timestamp) internal pure returns (uint day) {\\r\\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    function getHour(uint timestamp) internal pure returns (uint hour) {\\r\\n        uint secs = timestamp % SECONDS_PER_DAY;\\r\\n        hour = secs / SECONDS_PER_HOUR;\\r\\n    }\\r\\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\\r\\n        uint secs = timestamp % SECONDS_PER_HOUR;\\r\\n        minute = secs / SECONDS_PER_MINUTE;\\r\\n    }\\r\\n    function getSecond(uint timestamp) internal pure returns (uint second) {\\r\\n        second = timestamp % SECONDS_PER_MINUTE;\\r\\n    }\\r\\n\\r\\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\\r\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        year += _years;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\\r\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        month += _months;\\r\\n        year += (month - 1) / 12;\\r\\n        month = (month - 1) % 12 + 1;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _seconds;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n\\r\\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\\r\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        year -= _years;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\\r\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        uint yearMonth = year * 12 + (month - 1) - _months;\\r\\n        year = yearMonth / 12;\\r\\n        month = yearMonth % 12 + 1;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp - _seconds;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n\\r\\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\r\\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\r\\n        _years = toYear - fromYear;\\r\\n    }\\r\\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\r\\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\r\\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\\r\\n    }\\r\\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\r\\n    }\\r\\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\\r\\n    }\\r\\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\\r\\n    }\\r\\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _seconds = toTimestamp - fromTimestamp;\\r\\n    }\\r\\n}\"},\"erc165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev A standard for detecting smart contract interfaces. \\r\\n * See: https://eips.ethereum.org/EIPS/eip-165.\\r\\n */\\r\\ninterface ERC165\\r\\n{\\r\\n\\r\\n  /**\\r\\n   * @dev Checks if the smart contract includes a specific interface.\\r\\n   * This function uses less than 30,000 gas.\\r\\n   * @param _interfaceID The interface identifier, as specified in ERC-165.\\r\\n   * @return True if _interfaceID is supported, false otherwise.\\r\\n   */\\r\\n  function supportsInterface(\\r\\n    bytes4 _interfaceID\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (bool);\\r\\n    \\r\\n}\\r\\n\"},\"erc721-enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\\r\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\r\\n */\\r\\ninterface ERC721Enumerable\\r\\n{\\r\\n\\r\\n  /**\\r\\n   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\\r\\n   * assigned and queryable owner not equal to the zero address.\\r\\n   * @return Total supply of NFTs.\\r\\n   */\\r\\n  function totalSupply()\\r\\n    external\\r\\n    view\\r\\n    returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\\r\\n   * @param _index A counter less than `totalSupply()`.\\r\\n   * @return Token id.\\r\\n   */\\r\\n  function tokenByIndex(\\r\\n    uint256 _index\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\\r\\n   * not specified. It throws if `_index` \\u003e= `balanceOf(_owner)` or if `_owner` is the zero address,\\r\\n   * representing invalid NFTs.\\r\\n   * @param _owner An address where we are interested in NFTs owned by them.\\r\\n   * @param _index A counter less than `balanceOf(_owner)`.\\r\\n   * @return Token id.\\r\\n   */\\r\\n  function tokenOfOwnerByIndex(\\r\\n    address _owner,\\r\\n    uint256 _index\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (uint256);\\r\\n\\r\\n}\\r\\n\"},\"erc721-metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev Optional metadata extension for ERC-721 non-fungible token standard.\\r\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\r\\n */\\r\\ninterface ERC721Metadata\\r\\n{\\r\\n\\r\\n  /**\\r\\n   * @dev Returns a descriptive name for a collection of NFTs in this contract.\\r\\n   * @return _name Representing name.\\r\\n   */\\r\\n  function name()\\r\\n    external\\r\\n    view\\r\\n    returns (string memory _name);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns a abbreviated name for a collection of NFTs in this contract.\\r\\n   * @return _symbol Representing symbol.\\r\\n   */\\r\\n  function symbol()\\r\\n    external\\r\\n    view\\r\\n    returns (string memory _symbol);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\\r\\n   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\\r\\n   * that conforms to the \\\"ERC721 Metadata JSON Schema\\\".\\r\\n   * @return URI of _tokenId.\\r\\n   */\\r\\n  function tokenURI(uint256 _tokenId)\\r\\n    external\\r\\n    view\\r\\n    returns (string memory);\\r\\n\\r\\n}\\r\\n\"},\"erc721-token-receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev ERC-721 interface for accepting safe transfers.\\r\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\r\\n */\\r\\ninterface ERC721TokenReceiver\\r\\n{\\r\\n\\r\\n  /**\\r\\n   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\\r\\n   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\\r\\n   * of other than the magic value MUST result in the transaction being reverted.\\r\\n   * Returns `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))` unless throwing.\\r\\n   * @notice The contract address is always the message sender. A wallet/broker/auction application\\r\\n   * MUST implement the wallet interface if it will accept safe transfers.\\r\\n   * @param _operator The address which called `safeTransferFrom` function.\\r\\n   * @param _from The address which previously owned the token.\\r\\n   * @param _tokenId The NFT identifier which is being transferred.\\r\\n   * @param _data Additional data with no specified format.\\r\\n   * @return Returns `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n   */\\r\\n  function onERC721Received(\\r\\n    address _operator,\\r\\n    address _from,\\r\\n    uint256 _tokenId,\\r\\n    bytes calldata _data\\r\\n  )\\r\\n    external\\r\\n    returns(bytes4);\\r\\n\\r\\n}\\r\\n\"},\"erc721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev ERC-721 non-fungible token standard.\\r\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\r\\n */\\r\\ninterface ERC721\\r\\n{\\r\\n\\r\\n  /**\\r\\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\\r\\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\\r\\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\\r\\n   * transfer, the approved address for that NFT (if any) is reset to none.\\r\\n   */\\r\\n  event Transfer(\\r\\n    address indexed _from,\\r\\n    address indexed _to,\\r\\n    uint256 indexed _tokenId\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\\r\\n   * address indicates there is no approved address. When a Transfer event emits, this also\\r\\n   * indicates that the approved address for that NFT (if any) is reset to none.\\r\\n   */\\r\\n  event Approval(\\r\\n    address indexed _owner,\\r\\n    address indexed _approved,\\r\\n    uint256 indexed _tokenId\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\\r\\n   * all NFTs of the owner.\\r\\n   */\\r\\n  event ApprovalForAll(\\r\\n    address indexed _owner,\\r\\n    address indexed _operator,\\r\\n    bool _approved\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers the ownership of an NFT from one address to another address.\\r\\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\\r\\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\\r\\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\\r\\n   * function checks if `_to` is a smart contract (code size \\u003e 0). If so, it calls\\r\\n   * `onERC721Received` on `_to` and throws if the return value is not\\r\\n   * `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`.\\r\\n   * @param _from The current owner of the NFT.\\r\\n   * @param _to The new owner.\\r\\n   * @param _tokenId The NFT to transfer.\\r\\n   * @param _data Additional data with no specified format, sent in call to `_to`.\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId,\\r\\n    bytes calldata _data\\r\\n  )\\r\\n    external;\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers the ownership of an NFT from one address to another address.\\r\\n   * @notice This works identically to the other function with an extra data parameter, except this\\r\\n   * function just sets data to \\\"\\\"\\r\\n   * @param _from The current owner of the NFT.\\r\\n   * @param _to The new owner.\\r\\n   * @param _tokenId The NFT to transfer.\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    external;\\r\\n\\r\\n  /**\\r\\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\\r\\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\\r\\n   * address. Throws if `_tokenId` is not a valid NFT.\\r\\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\\r\\n   * they may be permanently lost.\\r\\n   * @param _from The current owner of the NFT.\\r\\n   * @param _to The new owner.\\r\\n   * @param _tokenId The NFT to transfer.\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    external;\\r\\n\\r\\n  /**\\r\\n   * @dev Set or reaffirm the approved address for an NFT.\\r\\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\\r\\n   * the current NFT owner, or an authorized operator of the current owner.\\r\\n   * @param _approved The new approved NFT controller.\\r\\n   * @param _tokenId The NFT to approve.\\r\\n   */\\r\\n  function approve(\\r\\n    address _approved,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    external;\\r\\n\\r\\n  /**\\r\\n   * @dev Enables or disables approval for a third party (\\\"operator\\\") to manage all of\\r\\n   * `msg.sender`\\u0027s assets. It also emits the ApprovalForAll event.\\r\\n   * @notice The contract MUST allow multiple operators per owner.\\r\\n   * @param _operator Address to add to the set of authorized operators.\\r\\n   * @param _approved True if the operators is approved, false to revoke approval.\\r\\n   */\\r\\n  function setApprovalForAll(\\r\\n    address _operator,\\r\\n    bool _approved\\r\\n  )\\r\\n    external;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\\r\\n   * considered invalid, and this function throws for queries about the zero address.\\r\\n   * @param _owner Address for whom to query the balance.\\r\\n   * @return Balance of _owner.\\r\\n   */\\r\\n  function balanceOf(\\r\\n    address _owner\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\\r\\n   * considered invalid, and queries about them do throw.\\r\\n   * @param _tokenId The identifier for an NFT.\\r\\n   * @return Address of _tokenId owner.\\r\\n   */\\r\\n  function ownerOf(\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (address);\\r\\n\\r\\n  /**\\r\\n   * @dev Get the approved address for a single NFT.\\r\\n   * @notice Throws if `_tokenId` is not a valid NFT.\\r\\n   * @param _tokenId The NFT to find the approved address for.\\r\\n   * @return Address that _tokenId is approved for.\\r\\n   */\\r\\n  function getApproved(\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (address);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\\r\\n   * @param _owner The address that owns the NFTs.\\r\\n   * @param _operator The address that acts on behalf of the owner.\\r\\n   * @return True if approved for all, false otherwise.\\r\\n   */\\r\\n  function isApprovedForAll(\\r\\n    address _owner,\\r\\n    address _operator\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (bool);\\r\\n\\r\\n}\\r\\n\"},\"Migrations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.4.22 \\u003c0.9.0;\\r\\n\\r\\ncontract Migrations {\\r\\n  address public owner = msg.sender;\\r\\n  uint public last_completed_migration;\\r\\n\\r\\n  modifier restricted() {\\r\\n    require(\\r\\n      msg.sender == owner,\\r\\n      \\\"This function is restricted to the contract\\u0027s owner\\\"\\r\\n    );\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function setCompleted(uint completed) public restricted {\\r\\n    last_completed_migration = completed;\\r\\n  }\\r\\n}\\r\\n\"},\"nf-token-enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./nf-token.sol\\\";\\r\\nimport \\\"./erc721-enumerable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Optional enumeration implementation for ERC-721 non-fungible token standard.\\r\\n */\\r\\ncontract NFTokenEnumerable is\\r\\n  NFToken,\\r\\n  ERC721Enumerable\\r\\n{\\r\\n\\r\\n  /**\\r\\n   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\\r\\n   * Based on 0xcert framework error codes.\\r\\n   */\\r\\n  string constant INVALID_INDEX = \\\"005007\\\";\\r\\n\\r\\n  /**\\r\\n   * @dev Array of all NFT IDs.\\r\\n   */\\r\\n  uint256[] internal tokens;\\r\\n\\r\\n  /**\\r\\n   * @dev Mapping from token ID to its index in global tokens array.\\r\\n   */\\r\\n  mapping(uint256 =\\u003e uint256) internal idToIndex;\\r\\n\\r\\n  /**\\r\\n   * @dev Mapping from owner to list of owned NFT IDs.\\r\\n   */\\r\\n  mapping(address =\\u003e uint256[]) internal ownerToIds;\\r\\n\\r\\n  /**\\r\\n   * @dev Mapping from NFT ID to its index in the owner tokens list.\\r\\n   */\\r\\n  mapping(uint256 =\\u003e uint256) internal idToOwnerIndex;\\r\\n\\r\\n  /**\\r\\n   * @dev Contract constructor.\\r\\n   */\\r\\n  constructor()\\r\\n  {\\r\\n    supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the count of all existing NFTokens.\\r\\n   * @return Total supply of NFTs.\\r\\n   */\\r\\n  function totalSupply()\\r\\n    external\\r\\n    override\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    return tokens.length;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns NFT ID by its index.\\r\\n   * @param _index A counter less than `totalSupply()`.\\r\\n   * @return Token id.\\r\\n   */\\r\\n  function tokenByIndex(\\r\\n    uint256 _index\\r\\n  )\\r\\n    external\\r\\n    override\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    require(_index \\u003c tokens.length, INVALID_INDEX);\\r\\n    return tokens[_index];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev returns the n-th NFT ID from a list of owner\\u0027s tokens.\\r\\n   * @param _owner Token owner\\u0027s address.\\r\\n   * @param _index Index number representing n-th token in owner\\u0027s list of tokens.\\r\\n   * @return Token id.\\r\\n   */\\r\\n  function tokenOfOwnerByIndex(\\r\\n    address _owner,\\r\\n    uint256 _index\\r\\n  )\\r\\n    external\\r\\n    override\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    require(_index \\u003c ownerToIds[_owner].length, INVALID_INDEX);\\r\\n    return ownerToIds[_owner][_index];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Mints a new NFT.\\r\\n   * @notice This is an internal function which should be called from user-implemented external\\r\\n   * mint function. Its purpose is to show and properly initialize data structures when using this\\r\\n   * implementation.\\r\\n   * @param _to The address that will own the minted NFT.\\r\\n   * @param _tokenId of the NFT to be minted by the msg.sender.\\r\\n   */\\r\\n  function _mint(\\r\\n    address _to,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    internal\\r\\n    override\\r\\n    virtual\\r\\n  {\\r\\n    super._mint(_to, _tokenId);\\r\\n    tokens.push(_tokenId);\\r\\n    idToIndex[_tokenId] = tokens.length - 1;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Burns a NFT.\\r\\n   * @notice This is an internal function which should be called from user-implemented external\\r\\n   * burn function. Its purpose is to show and properly initialize data structures when using this\\r\\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\\r\\n   * NFT.\\r\\n   * @param _tokenId ID of the NFT to be burned.\\r\\n   */\\r\\n  function _burn(\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    internal\\r\\n    override\\r\\n    virtual\\r\\n  {\\r\\n    super._burn(_tokenId);\\r\\n\\r\\n    uint256 tokenIndex = idToIndex[_tokenId];\\r\\n    uint256 lastTokenIndex = tokens.length - 1;\\r\\n    uint256 lastToken = tokens[lastTokenIndex];\\r\\n\\r\\n    tokens[tokenIndex] = lastToken;\\r\\n\\r\\n    tokens.pop();\\r\\n    // This wastes gas if you are burning the last token but saves a little gas if you are not.\\r\\n    idToIndex[lastToken] = tokenIndex;\\r\\n    idToIndex[_tokenId] = 0;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Removes a NFT from an address.\\r\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\r\\n   * @param _from Address from wich we want to remove the NFT.\\r\\n   * @param _tokenId Which NFT we want to remove.\\r\\n   */\\r\\n  function _removeNFToken(\\r\\n    address _from,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    internal\\r\\n    override\\r\\n    virtual\\r\\n  {\\r\\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\\r\\n    delete idToOwner[_tokenId];\\r\\n\\r\\n    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\\r\\n    uint256 lastTokenIndex = ownerToIds[_from].length - 1;\\r\\n\\r\\n    if (lastTokenIndex != tokenToRemoveIndex)\\r\\n    {\\r\\n      uint256 lastToken = ownerToIds[_from][lastTokenIndex];\\r\\n      ownerToIds[_from][tokenToRemoveIndex] = lastToken;\\r\\n      idToOwnerIndex[lastToken] = tokenToRemoveIndex;\\r\\n    }\\r\\n\\r\\n    ownerToIds[_from].pop();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Assigns a new NFT to an address.\\r\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\r\\n   * @param _to Address to wich we want to add the NFT.\\r\\n   * @param _tokenId Which NFT we want to add.\\r\\n   */\\r\\n  function _addNFToken(\\r\\n    address _to,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    internal\\r\\n    override\\r\\n    virtual\\r\\n  {\\r\\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\\r\\n    idToOwner[_tokenId] = _to;\\r\\n\\r\\n    ownerToIds[_to].push(_tokenId);\\r\\n    idToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\\r\\n   * extension to remove double storage(gas optimization) of owner NFT count.\\r\\n   * @param _owner Address for whom to query the count.\\r\\n   * @return Number of _owner NFTs.\\r\\n   */\\r\\n  function _getOwnerNFTCount(\\r\\n    address _owner\\r\\n  )\\r\\n    internal\\r\\n    override\\r\\n    virtual\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    return ownerToIds[_owner].length;\\r\\n  }\\r\\n}\\r\\n\"},\"nf-token-metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./nf-token.sol\\\";\\r\\nimport \\\"./erc721-metadata.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\\r\\n */\\r\\ncontract NFTokenMetadata is\\r\\n  NFToken,\\r\\n  ERC721Metadata\\r\\n{\\r\\n\\r\\n  /**\\r\\n   * @dev A descriptive name for a collection of NFTs.\\r\\n   */\\r\\n  string internal nftName;\\r\\n\\r\\n  /**\\r\\n   * @dev An abbreviated name for NFTokens.\\r\\n   */\\r\\n  string internal nftSymbol;\\r\\n\\r\\n  /**\\r\\n   * @dev Mapping from NFT ID to metadata uri.\\r\\n   */\\r\\n  mapping (uint256 =\\u003e string) internal idToUri;\\r\\n\\r\\n  /**\\r\\n   * @dev Contract constructor.\\r\\n   * @notice When implementing this contract don\\u0027t forget to set nftName and nftSymbol.\\r\\n   */\\r\\n  constructor()\\r\\n  {\\r\\n    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns a descriptive name for a collection of NFTokens.\\r\\n   * @return _name Representing name.\\r\\n   */\\r\\n  function name()\\r\\n    external\\r\\n    override\\r\\n    view\\r\\n    returns (string memory _name)\\r\\n  {\\r\\n    _name = nftName;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns an abbreviated name for NFTokens.\\r\\n   * @return _symbol Representing symbol.\\r\\n   */\\r\\n  function symbol()\\r\\n    external\\r\\n    override\\r\\n    view\\r\\n    returns (string memory _symbol)\\r\\n  {\\r\\n    _symbol = nftSymbol;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev A distinct URI (RFC 3986) for a given NFT.\\r\\n   * @param _tokenId Id for which we want uri.\\r\\n   * @return URI of _tokenId.\\r\\n   */\\r\\n  function tokenURI(\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    external\\r\\n    override\\r\\n    view\\r\\n    validNFToken(_tokenId)\\r\\n    returns (string memory)\\r\\n  {\\r\\n    return idToUri[_tokenId];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Burns a NFT.\\r\\n   * @notice This is an internal function which should be called from user-implemented external\\r\\n   * burn function. Its purpose is to show and properly initialize data structures when using this\\r\\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\\r\\n   * NFT.\\r\\n   * @param _tokenId ID of the NFT to be burned.\\r\\n   */\\r\\n  function _burn(\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    internal\\r\\n    override\\r\\n    virtual\\r\\n  {\\r\\n    super._burn(_tokenId);\\r\\n\\r\\n    if (bytes(idToUri[_tokenId]).length != 0)\\r\\n    {\\r\\n      delete idToUri[_tokenId];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Set a distinct URI (RFC 3986) for a given NFT ID.\\r\\n   * @notice This is an internal function which should be called from user-implemented external\\r\\n   * function. Its purpose is to show and properly initialize data structures when using this\\r\\n   * implementation.\\r\\n   * @param _tokenId Id for which we want URI.\\r\\n   * @param _uri String representing RFC 3986 URI.\\r\\n   */\\r\\n  function _setTokenUri(\\r\\n    uint256 _tokenId,\\r\\n    string memory _uri\\r\\n  )\\r\\n    internal\\r\\n    validNFToken(_tokenId)\\r\\n  {\\r\\n    idToUri[_tokenId] = _uri;\\r\\n  }\\r\\n\\r\\n}\\r\\n\"},\"nf-token.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./erc721.sol\\\";\\r\\nimport \\\"./erc721-token-receiver.sol\\\";\\r\\nimport \\\"./supports-interface.sol\\\";\\r\\nimport \\\"./address-utils.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of ERC-721 non-fungible token standard.\\r\\n */\\r\\ncontract NFToken is\\r\\n  ERC721,\\r\\n  SupportsInterface\\r\\n{\\r\\n  using AddressUtils for address;\\r\\n\\r\\n  /**\\r\\n   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\\r\\n   * Based on 0xcert framework error codes.\\r\\n   */\\r\\n  string constant ZERO_ADDRESS = \\\"003001\\\";\\r\\n  string constant NOT_VALID_NFT = \\\"003002\\\";\\r\\n  string constant NOT_OWNER_OR_OPERATOR = \\\"003003\\\";\\r\\n  string constant NOT_OWNER_APPROVED_OR_OPERATOR = \\\"003004\\\";\\r\\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \\\"003005\\\";\\r\\n  string constant NFT_ALREADY_EXISTS = \\\"003006\\\";\\r\\n  string constant NOT_OWNER = \\\"003007\\\";\\r\\n  string constant IS_OWNER = \\\"003008\\\";\\r\\n\\r\\n  /**\\r\\n   * @dev Magic value of a smart contract that can receive NFT.\\r\\n   * Equal to: bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\")).\\r\\n   */\\r\\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\\r\\n\\r\\n  /**\\r\\n   * @dev A mapping from NFT ID to the address that owns it.\\r\\n   */\\r\\n  mapping (uint256 =\\u003e address) internal idToOwner;\\r\\n\\r\\n  /**\\r\\n   * @dev Mapping from NFT ID to approved address.\\r\\n   */\\r\\n  mapping (uint256 =\\u003e address) internal idToApproval;\\r\\n\\r\\n   /**\\r\\n   * @dev Mapping from owner address to count of his tokens.\\r\\n   */\\r\\n  mapping (address =\\u003e uint256) private ownerToNFTokenCount;\\r\\n\\r\\n  /**\\r\\n   * @dev Mapping from owner address to mapping of operator addresses.\\r\\n   */\\r\\n  mapping (address =\\u003e mapping (address =\\u003e bool)) internal ownerToOperators;\\r\\n\\r\\n  /**\\r\\n   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\\r\\n   * @param _tokenId ID of the NFT to validate.\\r\\n   */\\r\\n  modifier canOperate(\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n  {\\r\\n    address tokenOwner = idToOwner[_tokenId];\\r\\n    require(\\r\\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\\r\\n      NOT_OWNER_OR_OPERATOR\\r\\n    );\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Guarantees that the msg.sender is allowed to transfer NFT.\\r\\n   * @param _tokenId ID of the NFT to transfer.\\r\\n   */\\r\\n  modifier canTransfer(\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n  {\\r\\n    address tokenOwner = idToOwner[_tokenId];\\r\\n    require(\\r\\n      tokenOwner == msg.sender\\r\\n      || idToApproval[_tokenId] == msg.sender\\r\\n      || ownerToOperators[tokenOwner][msg.sender],\\r\\n      NOT_OWNER_APPROVED_OR_OPERATOR\\r\\n    );\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Guarantees that _tokenId is a valid Token.\\r\\n   * @param _tokenId ID of the NFT to validate.\\r\\n   */\\r\\n  modifier validNFToken(\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n  {\\r\\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Contract constructor.\\r\\n   */\\r\\n  constructor()\\r\\n  {\\r\\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\\r\\n   * be changed to payable.\\r\\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\\r\\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\\r\\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\\r\\n   * function checks if `_to` is a smart contract (code size \\u003e 0). If so, it calls\\r\\n   * `onERC721Received` on `_to` and throws if the return value is not\\r\\n   * `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`.\\r\\n   * @param _from The current owner of the NFT.\\r\\n   * @param _to The new owner.\\r\\n   * @param _tokenId The NFT to transfer.\\r\\n   * @param _data Additional data with no specified format, sent in call to `_to`.\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId,\\r\\n    bytes calldata _data\\r\\n  )\\r\\n    external\\r\\n    override\\r\\n  {\\r\\n    _safeTransferFrom(_from, _to, _tokenId, _data);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\\r\\n   * be changed to payable.\\r\\n   * @notice This works identically to the other function with an extra data parameter, except this\\r\\n   * function just sets data to \\\"\\\"\\r\\n   * @param _from The current owner of the NFT.\\r\\n   * @param _to The new owner.\\r\\n   * @param _tokenId The NFT to transfer.\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    external\\r\\n    override\\r\\n  {\\r\\n    _safeTransferFrom(_from, _to, _tokenId, \\\"\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\\r\\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\\r\\n   * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\\r\\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\\r\\n   * they may be permanently lost.\\r\\n   * @param _from The current owner of the NFT.\\r\\n   * @param _to The new owner.\\r\\n   * @param _tokenId The NFT to transfer.\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    external\\r\\n    override\\r\\n    canTransfer(_tokenId)\\r\\n    validNFToken(_tokenId)\\r\\n  {\\r\\n    address tokenOwner = idToOwner[_tokenId];\\r\\n    require(tokenOwner == _from, NOT_OWNER);\\r\\n    require(_to != address(0), ZERO_ADDRESS);\\r\\n\\r\\n    _transfer(_to, _tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\\r\\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\\r\\n   * the current NFT owner, or an authorized operator of the current owner.\\r\\n   * @param _approved Address to be approved for the given NFT ID.\\r\\n   * @param _tokenId ID of the token to be approved.\\r\\n   */\\r\\n  function approve(\\r\\n    address _approved,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    external\\r\\n    override\\r\\n    canOperate(_tokenId)\\r\\n    validNFToken(_tokenId)\\r\\n  {\\r\\n    address tokenOwner = idToOwner[_tokenId];\\r\\n    require(_approved != tokenOwner, IS_OWNER);\\r\\n\\r\\n    idToApproval[_tokenId] = _approved;\\r\\n    emit Approval(tokenOwner, _approved, _tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Enables or disables approval for a third party (\\\"operator\\\") to manage all of\\r\\n   * `msg.sender`\\u0027s assets. It also emits the ApprovalForAll event.\\r\\n   * @notice This works even if sender doesn\\u0027t own any tokens at the time.\\r\\n   * @param _operator Address to add to the set of authorized operators.\\r\\n   * @param _approved True if the operators is approved, false to revoke approval.\\r\\n   */\\r\\n  function setApprovalForAll(\\r\\n    address _operator,\\r\\n    bool _approved\\r\\n  )\\r\\n    external\\r\\n    override\\r\\n  {\\r\\n    ownerToOperators[msg.sender][_operator] = _approved;\\r\\n    emit ApprovalForAll(msg.sender, _operator, _approved);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\\r\\n   * considered invalid, and this function throws for queries about the zero address.\\r\\n   * @param _owner Address for whom to query the balance.\\r\\n   * @return Balance of _owner.\\r\\n   */\\r\\n  function balanceOf(\\r\\n    address _owner\\r\\n  )\\r\\n    external\\r\\n    override\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    require(_owner != address(0), ZERO_ADDRESS);\\r\\n    return _getOwnerNFTCount(_owner);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\\r\\n   * considered invalid, and queries about them do throw.\\r\\n   * @param _tokenId The identifier for an NFT.\\r\\n   * @return _owner Address of _tokenId owner.\\r\\n   */\\r\\n  function ownerOf(\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    external\\r\\n    override\\r\\n    view\\r\\n    returns (address _owner)\\r\\n  {\\r\\n    _owner = idToOwner[_tokenId];\\r\\n    require(_owner != address(0), NOT_VALID_NFT);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Get the approved address for a single NFT.\\r\\n   * @notice Throws if `_tokenId` is not a valid NFT.\\r\\n   * @param _tokenId ID of the NFT to query the approval of.\\r\\n   * @return Address that _tokenId is approved for.\\r\\n   */\\r\\n  function getApproved(\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    external\\r\\n    override\\r\\n    view\\r\\n    validNFToken(_tokenId)\\r\\n    returns (address)\\r\\n  {\\r\\n    return idToApproval[_tokenId];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Checks if `_operator` is an approved operator for `_owner`.\\r\\n   * @param _owner The address that owns the NFTs.\\r\\n   * @param _operator The address that acts on behalf of the owner.\\r\\n   * @return True if approved for all, false otherwise.\\r\\n   */\\r\\n  function isApprovedForAll(\\r\\n    address _owner,\\r\\n    address _operator\\r\\n  )\\r\\n    external\\r\\n    override\\r\\n    view\\r\\n    returns (bool)\\r\\n  {\\r\\n    return ownerToOperators[_owner][_operator];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Actually performs the transfer.\\r\\n   * @notice Does NO checks.\\r\\n   * @param _to Address of a new owner.\\r\\n   * @param _tokenId The NFT that is being transferred.\\r\\n   */\\r\\n  function _transfer(\\r\\n    address _to,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    internal\\r\\n  {\\r\\n    address from = idToOwner[_tokenId];\\r\\n    _clearApproval(_tokenId);\\r\\n\\r\\n    _removeNFToken(from, _tokenId);\\r\\n    _addNFToken(_to, _tokenId);\\r\\n\\r\\n    emit Transfer(from, _to, _tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Mints a new NFT.\\r\\n   * @notice This is an internal function which should be called from user-implemented external\\r\\n   * mint function. Its purpose is to show and properly initialize data structures when using this\\r\\n   * implementation.\\r\\n   * @param _to The address that will own the minted NFT.\\r\\n   * @param _tokenId of the NFT to be minted by the msg.sender.\\r\\n   */\\r\\n  function _mint(\\r\\n    address _to,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    internal\\r\\n    virtual\\r\\n  {\\r\\n    require(_to != address(0), ZERO_ADDRESS);\\r\\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\\r\\n\\r\\n    _addNFToken(_to, _tokenId);\\r\\n\\r\\n    emit Transfer(address(0), _to, _tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Burns a NFT.\\r\\n   * @notice This is an internal function which should be called from user-implemented external burn\\r\\n   * function. Its purpose is to show and properly initialize data structures when using this\\r\\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\\r\\n   * NFT.\\r\\n   * @param _tokenId ID of the NFT to be burned.\\r\\n   */\\r\\n  function _burn(\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    internal\\r\\n    virtual\\r\\n    validNFToken(_tokenId)\\r\\n  {\\r\\n    address tokenOwner = idToOwner[_tokenId];\\r\\n    _clearApproval(_tokenId);\\r\\n    _removeNFToken(tokenOwner, _tokenId);\\r\\n    emit Transfer(tokenOwner, address(0), _tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Removes a NFT from owner.\\r\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\r\\n   * @param _from Address from which we want to remove the NFT.\\r\\n   * @param _tokenId Which NFT we want to remove.\\r\\n   */\\r\\n  function _removeNFToken(\\r\\n    address _from,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    internal\\r\\n    virtual\\r\\n  {\\r\\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\\r\\n    ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\\r\\n    delete idToOwner[_tokenId];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Assigns a new NFT to owner.\\r\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\r\\n   * @param _to Address to which we want to add the NFT.\\r\\n   * @param _tokenId Which NFT we want to add.\\r\\n   */\\r\\n  function _addNFToken(\\r\\n    address _to,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    internal\\r\\n    virtual\\r\\n  {\\r\\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\\r\\n\\r\\n    idToOwner[_tokenId] = _to;\\r\\n    ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to] + 1;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\\r\\n   * extension to remove double storage (gas optimization) of owner NFT count.\\r\\n   * @param _owner Address for whom to query the count.\\r\\n   * @return Number of _owner NFTs.\\r\\n   */\\r\\n  function _getOwnerNFTCount(\\r\\n    address _owner\\r\\n  )\\r\\n    internal\\r\\n    virtual\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    return ownerToNFTokenCount[_owner];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Actually perform the safeTransferFrom.\\r\\n   * @param _from The current owner of the NFT.\\r\\n   * @param _to The new owner.\\r\\n   * @param _tokenId The NFT to transfer.\\r\\n   * @param _data Additional data with no specified format, sent in call to `_to`.\\r\\n   */\\r\\n  function _safeTransferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId,\\r\\n    bytes memory _data\\r\\n  )\\r\\n    private\\r\\n    canTransfer(_tokenId)\\r\\n    validNFToken(_tokenId)\\r\\n  {\\r\\n    address tokenOwner = idToOwner[_tokenId];\\r\\n    require(tokenOwner == _from, NOT_OWNER);\\r\\n    require(_to != address(0), ZERO_ADDRESS);\\r\\n\\r\\n    _transfer(_to, _tokenId);\\r\\n\\r\\n    if (_to.isContract())\\r\\n    {\\r\\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\\r\\n      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Clears the current approval of a given NFT ID.\\r\\n   * @param _tokenId ID of the NFT to be transferred.\\r\\n   */\\r\\n  function _clearApproval(\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    private\\r\\n  {\\r\\n    if (idToApproval[_tokenId] != address(0))\\r\\n    {\\r\\n      delete idToApproval[_tokenId];\\r\\n    }\\r\\n  }\\r\\n\\r\\n}\\r\\n\"},\"ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev The contract has an owner address, and provides basic authorization control whitch\\r\\n * simplifies the implementation of user permissions. This contract is based on the source code at:\\r\\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\\r\\n */\\r\\ncontract Ownable\\r\\n{\\r\\n\\r\\n  /**\\r\\n   * @dev Error constants.\\r\\n   */\\r\\n  string public constant NOT_CURRENT_OWNER = \\\"018001\\\";\\r\\n  string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = \\\"018002\\\";\\r\\n\\r\\n  /**\\r\\n   * @dev Current owner address.\\r\\n   */\\r\\n  address public owner;\\r\\n\\r\\n  /**\\r\\n   * @dev An event which is triggered when the owner is changed.\\r\\n   * @param previousOwner The address of the previous owner.\\r\\n   * @param newOwner The address of the new owner.\\r\\n   */\\r\\n  event OwnershipTransferred(\\r\\n    address indexed previousOwner,\\r\\n    address indexed newOwner\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev The constructor sets the original `owner` of the contract to the sender account.\\r\\n   */\\r\\n  constructor()\\r\\n  {\\r\\n    owner = msg.sender;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Throws if called by any account other than the owner.\\r\\n   */\\r\\n  modifier onlyOwner()\\r\\n  {\\r\\n    require(msg.sender == owner, NOT_CURRENT_OWNER);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n   * @param _newOwner The address to transfer ownership to.\\r\\n   */\\r\\n  function transferOwnership(\\r\\n    address _newOwner\\r\\n  )\\r\\n    public\\r\\n    onlyOwner\\r\\n  {\\r\\n    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\\r\\n    emit OwnershipTransferred(owner, _newOwner);\\r\\n    owner = _newOwner;\\r\\n  }\\r\\n\\r\\n}\\r\\n\"},\"supports-interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./erc165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of standard for detect smart contract interfaces.\\r\\n */\\r\\ncontract SupportsInterface is\\r\\n  ERC165\\r\\n{\\r\\n\\r\\n  /**\\r\\n   * @dev Mapping of supported intefraces. You must not set element 0xffffffff to true.\\r\\n   */\\r\\n  mapping(bytes4 =\\u003e bool) internal supportedInterfaces;\\r\\n\\r\\n  /**\\r\\n   * @dev Contract constructor.\\r\\n   */\\r\\n  constructor()\\r\\n  {\\r\\n    supportedInterfaces[0x01ffc9a7] = true; // ERC165\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Function to check which interfaces are suported by this contract.\\r\\n   * @param _interfaceID Id of the interface.\\r\\n   * @return True if _interfaceID is supported, false otherwise.\\r\\n   */\\r\\n  function supportsInterface(\\r\\n    bytes4 _interfaceID\\r\\n  )\\r\\n    external\\r\\n    override\\r\\n    view\\r\\n    returns (bool)\\r\\n  {\\r\\n    return supportedInterfaces[_interfaceID];\\r\\n  }\\r\\n\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CANNOT_TRANSFER_TO_ZERO_ADDRESS\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NOT_CURRENT_OWNER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"airdropNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"airdropNFTs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAirdropAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxMintPerTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxPageSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintMaxPerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintableCountToday\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintableRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintedCountToday\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageIndex\",\"type\":\"uint256\"}],\"name\":\"getPagedNFTs\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSelling\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"priceInWei\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"internalType\":\"struct CryptoMonkeyKing.NFT[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"giveNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"giveNFTs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isMinted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"mintNFTs\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_airdropAccount\",\"type\":\"address\"}],\"name\":\"setAirdropAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxMintPerTime\",\"type\":\"uint256\"}],\"name\":\"setMaxMintPerTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintMaxPerDay\",\"type\":\"uint256\"}],\"name\":\"setMintMaxPerDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintPrice\",\"type\":\"uint256\"}],\"name\":\"setMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CryptoMonkeyKing","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e7168e71313d50a51c8a8164e260779e4b759679ea2685197c8bf7d4f8222ad7"}]}