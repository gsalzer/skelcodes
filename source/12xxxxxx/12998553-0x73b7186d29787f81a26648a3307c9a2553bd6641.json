{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at BscScan.com on 2021-07-09\r\n*/\r\n\r\n// File: contracts/LockerUtils.sol\r\n\r\npragma solidity 0.6.5;\r\n\r\n\r\ninterface Locker{\r\n    /*\r\n    Returns lockId, tokenAddress, withdrawalAddress, tokenAmount,unlockTime, withdrawn\r\n    */\r\n    function getDepositByTokenAddress(address _tokenAddress,uint256 _index) view external\r\n        returns (uint256, address, address, uint256, uint256, bool);\r\n    function getTotalDepositsByTokenAddress(address _token) external view returns (uint256);\r\n}\r\n\r\npragma solidity 0.6.5;\r\n\r\n\r\ncontract LockerUtils {\r\n    \r\n    /// @notice Returns a list of locks.\r\n    /// @param _lock The Locker.\r\n    /// @param _token The token address\r\n    /// @param _offset The first lockId (Starts with 1)\r\n    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\r\n    ///  expensive but it also returns a dynamic array, which is only supported for web3 calls, and\r\n    ///  not contract-to-contract calls.\r\n    function locks(Locker _lock, address _token, uint256 _offset, uint256 _limit) external view returns(\r\n        uint256[] memory lockIds, uint256[] memory amounts\r\n    ) {\r\n        uint256 lockCount = _lock.getTotalDepositsByTokenAddress(_token);\r\n\r\n        \r\n        uint256[] memory returnLockIds = new uint256[](lockCount);\r\n        uint256[] memory amountsReturn = new uint256[](lockCount);\r\n        uint256 resultIndex = 0;\r\n        \r\n        uint256 lockId;\r\n        uint256 limit = _limit;\r\n        if (lockCount < limit) {\r\n            limit = lockCount;\r\n        }\r\n\r\n        for (lockId = _offset; lockId <= limit; lockId++) {\r\n            (uint256 id,,,uint256 amount,,) = _lock.getDepositByTokenAddress(_token, lockId - 1);\r\n            returnLockIds[resultIndex] = id;\r\n            amountsReturn[resultIndex] = amount;\r\n            resultIndex++;\r\n        }\r\n\r\n        return (returnLockIds, amountsReturn);\r\n        \r\n    }\r\n    \r\n    function locksTimes(Locker _lock, address _token, uint256 _offset, uint256 _limit) external view returns(\r\n        uint256[] memory unlockTimes\r\n    ) {\r\n        uint256 lockCount = _lock.getTotalDepositsByTokenAddress(_token);\r\n\r\n        \r\n        uint256[] memory unlockTimesRes = new uint256[](lockCount);\r\n        uint256 resultIndex = 0;\r\n        \r\n        uint256 lockId;\r\n        uint256 limit = _limit;\r\n        if (lockCount < limit) {\r\n            limit = lockCount;\r\n        }\r\n\r\n        for (lockId = _offset; lockId <= limit; lockId++) {\r\n            (,,,,uint256 unlock,) = _lock.getDepositByTokenAddress(_token, lockId - 1);\r\n            unlockTimesRes[resultIndex] = unlock;\r\n            resultIndex++;\r\n        }\r\n\r\n        return (unlockTimesRes);\r\n        \r\n    }\r\n    \r\n    function locksDetails(Locker _lock, address _token, uint256 _offset, uint256 _limit) external view returns(\r\n        address[] memory withdrawalAddresses, bool[] memory withdrawns\r\n    ) {\r\n        uint256 lockCount = _lock.getTotalDepositsByTokenAddress(_token);\r\n\r\n        \r\n        address[] memory withdrawalAddressesRes = new address[](lockCount);\r\n        bool[] memory withdrawnsRes = new bool[](lockCount);\r\n        uint256 resultIndex = 0;\r\n        \r\n        uint256 lockId;\r\n        uint256 limit = _limit;\r\n        if (lockCount < limit) {\r\n            limit = lockCount;\r\n        }\r\n\r\n        for (lockId = _offset; lockId <= limit; lockId++) {\r\n            (,, address withdrawAddress,,,bool withdrawn) = _lock.getDepositByTokenAddress(_token, lockId - 1);\r\n            withdrawalAddressesRes[resultIndex] = withdrawAddress;\r\n            withdrawnsRes[resultIndex] = withdrawn;\r\n            resultIndex++;\r\n        }\r\n\r\n        return (withdrawalAddressesRes, withdrawnsRes);\r\n        \r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Locker\",\"name\":\"_lock\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"locks\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"lockIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Locker\",\"name\":\"_lock\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"locksDetails\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"withdrawalAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"withdrawns\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Locker\",\"name\":\"_lock\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"locksTimes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"unlockTimes\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LockerUtils","CompilerVersion":"v0.6.5+commit.f956cc89","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://15abfb2beaf2e0ac00cad05a40f5980f014b8a4d640f9341a7b25a8b008359ca"}]}