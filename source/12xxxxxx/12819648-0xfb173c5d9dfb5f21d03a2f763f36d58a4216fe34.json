{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/tokens-base/IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File: contracts/tokens-base/IERC20Metadata.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: contracts/utils/Context.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/tokens-base/ERC20.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 internal _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The defaut value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(\r\n            currentAllowance >= amount,\r\n            \"ERC20: transfer amount exceeds allowance\"\r\n        );\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender] + addedValue\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(\r\n            currentAllowance >= subtractedValue,\r\n            \"ERC20: decreased allowance below zero\"\r\n        );\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(\r\n            senderBalance >= amount,\r\n            \"ERC20: transfer amount exceeds balance\"\r\n        );\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        // TODO: remove before hook unless needed\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = accountBalance - amount;\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: contracts/core/YoloEthereumUtilityTokens.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev {ERC20} token, including:\r\n *\r\n *  - Preminted initial supply\r\n *  - No access control mechanism (for minting/pausing) and hence no governance\r\n *  From OpenZep\r\n * _Available since v3.4._\r\n */\r\ncontract YoloEthereumUtilityTokens is ERC20 {\r\n    /**\r\n     * @dev Mints `initialSupply` amount of token and transfers them to `owner`.\r\n     *\r\n     * See {ERC20-constructor}.\r\n     */\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        address owner\r\n    ) ERC20(name, symbol) {\r\n        require(bytes(name).length != 0, \"token name must be specified\");\r\n        require(bytes(symbol).length != 0, \"token symbol must be specified\");\r\n        uint256 amount = 10**9 * 10**(decimals()); // 1 Billion Tokens\r\n        _mint(owner, amount);\r\n    }\r\n}\r\n\r\n// File: contracts/fx-portal/IRootChainManager.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRootChainManager {\r\n    event TokenMapped(\r\n        address indexed rootToken,\r\n        address indexed childToken,\r\n        bytes32 indexed tokenType\r\n    );\r\n\r\n    event PredicateRegistered(\r\n        bytes32 indexed tokenType,\r\n        address indexed predicateAddress\r\n    );\r\n\r\n    function registerPredicate(bytes32 tokenType, address predicateAddress)\r\n        external;\r\n\r\n    function mapToken(\r\n        address rootToken,\r\n        address childToken,\r\n        bytes32 tokenType\r\n    ) external;\r\n\r\n    function depositEtherFor(address user) external payable;\r\n\r\n    function depositFor(\r\n        address user,\r\n        address rootToken,\r\n        bytes calldata depositData\r\n    ) external;\r\n\r\n    function exit(bytes calldata inputData) external;\r\n}\r\n\r\n// File: contracts/fx-portal/lib/RLPReader.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary RLPReader {\r\n    uint8 constant STRING_SHORT_START = 0x80;\r\n    uint8 constant STRING_LONG_START = 0xb8;\r\n    uint8 constant LIST_SHORT_START = 0xc0;\r\n    uint8 constant LIST_LONG_START = 0xf8;\r\n    uint8 constant WORD_SIZE = 32;\r\n\r\n    struct RLPItem {\r\n        uint256 len;\r\n        uint256 memPtr;\r\n    }\r\n\r\n    /*\r\n     * @param item RLP encoded bytes\r\n     */\r\n    function toRlpItem(bytes memory item)\r\n        internal\r\n        pure\r\n        returns (RLPItem memory)\r\n    {\r\n        require(item.length > 0, \"RLPReader: INVALID_BYTES_LENGTH\");\r\n        uint256 memPtr;\r\n        assembly {\r\n            memPtr := add(item, 0x20)\r\n        }\r\n\r\n        return RLPItem(item.length, memPtr);\r\n    }\r\n\r\n    /*\r\n     * @param item RLP encoded list in bytes\r\n     */\r\n    function toList(RLPItem memory item)\r\n        internal\r\n        pure\r\n        returns (RLPItem[] memory)\r\n    {\r\n        require(isList(item), \"RLPReader: ITEM_NOT_LIST\");\r\n\r\n        uint256 items = numItems(item);\r\n        RLPItem[] memory result = new RLPItem[](items);\r\n        uint256 listLength = _itemLength(item.memPtr);\r\n        require(\r\n            listLength == item.len,\r\n            \"RLPReader: LIST_DECODED_LENGTH_MISMATCH\"\r\n        );\r\n\r\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint256 dataLen;\r\n        for (uint256 i = 0; i < items; i++) {\r\n            dataLen = _itemLength(memPtr);\r\n            result[i] = RLPItem(dataLen, memPtr);\r\n            memPtr = memPtr + dataLen;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\r\n    function isList(RLPItem memory item) internal pure returns (bool) {\r\n        uint8 byte0;\r\n        uint256 memPtr = item.memPtr;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < LIST_SHORT_START) return false;\r\n        return true;\r\n    }\r\n\r\n    /** RLPItem conversions into data types **/\r\n\r\n    // @returns raw rlp encoding in bytes\r\n    function toRlpBytes(RLPItem memory item)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory result = new bytes(item.len);\r\n\r\n        uint256 ptr;\r\n        assembly {\r\n            ptr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr, ptr, item.len);\r\n        return result;\r\n    }\r\n\r\n    function toAddress(RLPItem memory item) internal pure returns (address) {\r\n        require(!isList(item), \"RLPReader: DECODING_LIST_AS_ADDRESS\");\r\n        // 1 byte for the length prefix\r\n        require(item.len == 21, \"RLPReader: INVALID_ADDRESS_LENGTH\");\r\n\r\n        return address(bytes20(uint160(toUint(item))));\r\n    }\r\n\r\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\r\n        require(!isList(item), \"RLPReader: DECODING_LIST_AS_UINT\");\r\n        require(item.len <= 33, \"RLPReader: INVALID_UINT_LENGTH\");\r\n\r\n        uint256 itemLength = _itemLength(item.memPtr);\r\n        require(\r\n            itemLength == item.len,\r\n            \"RLPReader: UINT_DECODED_LENGTH_MISMATCH\"\r\n        );\r\n\r\n        uint256 offset = _payloadOffset(item.memPtr);\r\n        uint256 len = item.len - offset;\r\n        uint256 result;\r\n        uint256 memPtr = item.memPtr + offset;\r\n        assembly {\r\n            result := mload(memPtr)\r\n\r\n            // shfit to the correct location if neccesary\r\n            if lt(len, 32) {\r\n                result := div(result, exp(256, sub(32, len)))\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // enforces 32 byte length\r\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\r\n        uint256 itemLength = _itemLength(item.memPtr);\r\n        require(\r\n            itemLength == item.len,\r\n            \"RLPReader: UINT_STRICT_DECODED_LENGTH_MISMATCH\"\r\n        );\r\n        // one byte prefix\r\n        require(item.len == 33, \"RLPReader: INVALID_UINT_STRICT_LENGTH\");\r\n\r\n        uint256 result;\r\n        uint256 memPtr = item.memPtr + 1;\r\n        assembly {\r\n            result := mload(memPtr)\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        uint256 listLength = _itemLength(item.memPtr);\r\n        require(\r\n            listLength == item.len,\r\n            \"RLPReader: BYTES_DECODED_LENGTH_MISMATCH\"\r\n        );\r\n        uint256 offset = _payloadOffset(item.memPtr);\r\n\r\n        uint256 len = item.len - offset; // data length\r\n        bytes memory result = new bytes(len);\r\n\r\n        uint256 destPtr;\r\n        assembly {\r\n            destPtr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr + offset, destPtr, len);\r\n        return result;\r\n    }\r\n\r\n    /*\r\n     * Private Helpers\r\n     */\r\n\r\n    // @return number of payload items inside an encoded list.\r\n    function numItems(RLPItem memory item) private pure returns (uint256) {\r\n        // add `isList` check if `item` is expected to be passsed without a check from calling function\r\n        // require(isList(item), \"RLPReader: NUM_ITEMS_NOT_LIST\");\r\n\r\n        uint256 count = 0;\r\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint256 endPtr = item.memPtr + item.len;\r\n        while (currPtr < endPtr) {\r\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\r\n            require(\r\n                currPtr <= endPtr,\r\n                \"RLPReader: NUM_ITEMS_DECODED_LENGTH_MISMATCH\"\r\n            );\r\n            count++;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    // @return entire rlp item byte length\r\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\r\n        uint256 itemLen;\r\n        uint256 byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\r\n        else if (byte0 < STRING_LONG_START)\r\n            itemLen = byte0 - STRING_SHORT_START + 1;\r\n        else if (byte0 < LIST_SHORT_START) {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\r\n                memPtr := add(memPtr, 1) // skip over the first byte\r\n\r\n                /* 32 byte word size */\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\r\n                itemLen := add(dataLen, add(byteLen, 1))\r\n            }\r\n        } else if (byte0 < LIST_LONG_START) {\r\n            itemLen = byte0 - LIST_SHORT_START + 1;\r\n        } else {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xf7)\r\n                memPtr := add(memPtr, 1)\r\n\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\r\n                itemLen := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        return itemLen;\r\n    }\r\n\r\n    // @return number of bytes until the data\r\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\r\n        uint256 byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START) return 0;\r\n        else if (\r\n            byte0 < STRING_LONG_START ||\r\n            (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)\r\n        ) return 1;\r\n        else if (byte0 < LIST_SHORT_START)\r\n            // being explicit\r\n            return byte0 - (STRING_LONG_START - 1) + 1;\r\n        else return byte0 - (LIST_LONG_START - 1) + 1;\r\n    }\r\n\r\n    /*\r\n     * @param src Pointer to source\r\n     * @param dest Pointer to destination\r\n     * @param len Amount of memory to copy from the source\r\n     */\r\n    function copy(\r\n        uint256 src,\r\n        uint256 dest,\r\n        uint256 len\r\n    ) private pure {\r\n        if (len == 0) return;\r\n\r\n        unchecked {\r\n            // copy as many word sizes as possible\r\n            for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n                assembly {\r\n                    mstore(dest, mload(src))\r\n                }\r\n\r\n                src += WORD_SIZE;\r\n                dest += WORD_SIZE;\r\n            }\r\n\r\n            // left over bytes. Mask is used to remove unwanted bytes from the word\r\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\r\n            assembly {\r\n                let srcpart := and(mload(src), not(mask)) // zero out src\r\n                let destpart := and(mload(dest), mask) // retrieve the bytes\r\n                mstore(dest, or(destpart, srcpart))\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/fx-portal/lib/MerklePatriciaProof.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary MerklePatriciaProof {\r\n    /*\r\n     * @dev Verifies a merkle patricia proof.\r\n     * @param value The terminating value in the trie.\r\n     * @param encodedPath The path in the trie leading to value.\r\n     * @param rlpParentNodes The rlp encoded stack of nodes.\r\n     * @param root The root hash of the trie.\r\n     * @return The boolean validity of the proof.\r\n     */\r\n    function verify(\r\n        bytes memory value,\r\n        bytes memory encodedPath,\r\n        bytes memory rlpParentNodes,\r\n        bytes32 root\r\n    ) internal pure returns (bool) {\r\n        RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);\r\n        RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);\r\n\r\n        bytes memory currentNode;\r\n        RLPReader.RLPItem[] memory currentNodeList;\r\n\r\n        bytes32 nodeKey = root;\r\n        uint256 pathPtr = 0;\r\n\r\n        bytes memory path = _getNibbleArray(encodedPath);\r\n        if (path.length == 0) {\r\n            return false;\r\n        }\r\n\r\n        for (uint256 i = 0; i < parentNodes.length; i++) {\r\n            if (pathPtr > path.length) {\r\n                return false;\r\n            }\r\n\r\n            currentNode = RLPReader.toRlpBytes(parentNodes[i]);\r\n            if (nodeKey != keccak256(currentNode)) {\r\n                return false;\r\n            }\r\n            currentNodeList = RLPReader.toList(parentNodes[i]);\r\n\r\n            if (currentNodeList.length == 17) {\r\n                if (pathPtr == path.length) {\r\n                    if (\r\n                        keccak256(RLPReader.toBytes(currentNodeList[16])) ==\r\n                        keccak256(value)\r\n                    ) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                uint8 nextPathNibble = uint8(path[pathPtr]);\r\n                if (nextPathNibble > 16) {\r\n                    return false;\r\n                }\r\n                nodeKey = bytes32(\r\n                    RLPReader.toUintStrict(currentNodeList[nextPathNibble])\r\n                );\r\n                pathPtr += 1;\r\n            } else if (currentNodeList.length == 2) {\r\n                uint256 traversed = _nibblesToTraverse(\r\n                    RLPReader.toBytes(currentNodeList[0]),\r\n                    path,\r\n                    pathPtr\r\n                );\r\n                if (pathPtr + traversed == path.length) {\r\n                    //leaf node\r\n                    if (\r\n                        keccak256(RLPReader.toBytes(currentNodeList[1])) ==\r\n                        keccak256(value)\r\n                    ) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                //extension node\r\n                if (traversed == 0) {\r\n                    return false;\r\n                }\r\n\r\n                pathPtr += traversed;\r\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _nibblesToTraverse(\r\n        bytes memory encodedPartialPath,\r\n        bytes memory path,\r\n        uint256 pathPtr\r\n    ) private pure returns (uint256) {\r\n        uint256 len = 0;\r\n        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\r\n        // and slicedPath have elements that are each one hex character (1 nibble)\r\n        bytes memory partialPath = _getNibbleArray(encodedPartialPath);\r\n        bytes memory slicedPath = new bytes(partialPath.length);\r\n\r\n        // pathPtr counts nibbles in path\r\n        // partialPath.length is a number of nibbles\r\n        for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {\r\n            bytes1 pathNibble = path[i];\r\n            slicedPath[i - pathPtr] = pathNibble;\r\n        }\r\n\r\n        if (keccak256(partialPath) == keccak256(slicedPath)) {\r\n            len = partialPath.length;\r\n        } else {\r\n            len = 0;\r\n        }\r\n        return len;\r\n    }\r\n\r\n    // bytes b must be hp encoded\r\n    function _getNibbleArray(bytes memory b)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory nibbles = \"\";\r\n        if (b.length > 0) {\r\n            uint8 offset;\r\n            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));\r\n            if (hpNibble == 1 || hpNibble == 3) {\r\n                nibbles = new bytes(b.length * 2 - 1);\r\n                bytes1 oddNibble = _getNthNibbleOfBytes(1, b);\r\n                nibbles[0] = oddNibble;\r\n                offset = 1;\r\n            } else {\r\n                nibbles = new bytes(b.length * 2 - 2);\r\n                offset = 0;\r\n            }\r\n\r\n            for (uint256 i = offset; i < nibbles.length; i++) {\r\n                nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);\r\n            }\r\n        }\r\n        return nibbles;\r\n    }\r\n\r\n    function _getNthNibbleOfBytes(uint256 n, bytes memory str)\r\n        private\r\n        pure\r\n        returns (bytes1)\r\n    {\r\n        return\r\n            bytes1(\r\n                n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10\r\n            );\r\n    }\r\n}\r\n\r\n// File: contracts/fx-portal/lib/Merkle.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Merkle {\r\n    function checkMembership(\r\n        bytes32 leaf,\r\n        uint256 index,\r\n        bytes32 rootHash,\r\n        bytes memory proof\r\n    ) internal pure returns (bool) {\r\n        require(proof.length % 32 == 0, \"Invalid proof length\");\r\n        uint256 proofHeight = proof.length / 32;\r\n        // Proof of size n means, height of the tree is n+1.\r\n        // In a tree of height n+1, max #leafs possible is 2 ^ n\r\n        require(index < 2**proofHeight, \"Leaf index is too big\");\r\n\r\n        bytes32 proofElement;\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 32; i <= proof.length; i += 32) {\r\n            assembly {\r\n                proofElement := mload(add(proof, i))\r\n            }\r\n\r\n            if (index % 2 == 0) {\r\n                computedHash = keccak256(\r\n                    abi.encodePacked(computedHash, proofElement)\r\n                );\r\n            } else {\r\n                computedHash = keccak256(\r\n                    abi.encodePacked(proofElement, computedHash)\r\n                );\r\n            }\r\n\r\n            index = index / 2;\r\n        }\r\n        return computedHash == rootHash;\r\n    }\r\n}\r\n\r\n// File: contracts/access/Ownable.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Ownable {\r\n    address public owner;\r\n\r\n    // Sets the original owner of\r\n    // contract when it is deployed\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    modifier restricted() {\r\n        require(msg.sender == owner, \"Must have admin role to invoke\");\r\n        _;\r\n    }\r\n\r\n    function transferOwner(address newOwner)\r\n        external\r\n        restricted\r\n        returns (bool)\r\n    {\r\n        address previousOwner = owner;\r\n        owner = newOwner;\r\n        emit OwnershipTransferred(previousOwner, newOwner);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/fx-portal/tunnel/FxBaseRootTunnel.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IFxStateSender {\r\n    function sendMessageToChild(address _receiver, bytes calldata _data)\r\n        external;\r\n}\r\n\r\ncontract ICheckpointManager {\r\n    struct HeaderBlock {\r\n        bytes32 root;\r\n        uint256 start;\r\n        uint256 end;\r\n        uint256 createdAt;\r\n        address proposer;\r\n    }\r\n\r\n    /**\r\n     * @notice mapping of checkpoint header numbers to block details\r\n     * @dev These checkpoints are submited by plasma contracts\r\n     */\r\n    mapping(uint256 => HeaderBlock) public headerBlocks;\r\n}\r\n\r\nabstract contract FxBaseRootTunnel is Ownable {\r\n    using RLPReader for bytes;\r\n    using RLPReader for RLPReader.RLPItem;\r\n    using Merkle for bytes32;\r\n\r\n    // keccak256(MessageSent(bytes))\r\n    bytes32 public constant SEND_MESSAGE_EVENT_SIG =\r\n        0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036;\r\n\r\n    // state sender contract\r\n    IFxStateSender public fxRoot;\r\n    // root chain manager\r\n    ICheckpointManager public checkpointManager;\r\n    // child tunnel contract which receives and sends messages\r\n    address public fxChildTunnel;\r\n\r\n    // storage to avoid duplicate exits\r\n    mapping(bytes32 => bool) public processedExits;\r\n\r\n    constructor(\r\n        address _checkpointManager,\r\n        address _fxRoot,\r\n        address fxChildTunnel_\r\n    ) {\r\n        checkpointManager = ICheckpointManager(_checkpointManager);\r\n        fxRoot = IFxStateSender(_fxRoot);\r\n        fxChildTunnel = fxChildTunnel_;\r\n    }\r\n\r\n    // just in case\r\n    function setFxChildTunnel(address _fxChildTunnel) public restricted {\r\n        require(\r\n            _fxChildTunnel != address(0),\r\n            \"fx child tunnel aka child issuance contract address must be specified\"\r\n        );\r\n        fxChildTunnel = _fxChildTunnel;\r\n    }\r\n\r\n    // just in case\r\n    function setFxRoot(address _fxRoot) public restricted {\r\n        require(\r\n            _fxRoot != address(0),\r\n            \"fxRoot contract address must be specified\"\r\n        );\r\n        fxRoot = IFxStateSender(_fxRoot);\r\n    }\r\n\r\n    // just in case\r\n    function setCheckpointManager(address _checkpointManager)\r\n        public\r\n        restricted\r\n    {\r\n        require(\r\n            _checkpointManager != address(0),\r\n            \"checkpoint manager contract address must be specified\"\r\n        );\r\n        checkpointManager = ICheckpointManager(_checkpointManager);\r\n    }\r\n\r\n    /**\r\n     * @notice Send bytes message to Child Tunnel\r\n     * @param message bytes message that will be sent to Child Tunnel\r\n     * some message examples -\r\n     *   abi.encode(tokenId);\r\n     *   abi.encode(tokenId, tokenMetadata);\r\n     *   abi.encode(messageType, messageData);\r\n     */\r\n    function _sendMessageToChild(bytes memory message) internal {\r\n        fxRoot.sendMessageToChild(fxChildTunnel, message);\r\n    }\r\n\r\n    function _validateAndExtractMessage(bytes memory inputData)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        RLPReader.RLPItem[] memory inputDataRLPList = inputData\r\n        .toRlpItem()\r\n        .toList();\r\n\r\n        // checking if exit has already been processed\r\n        // unique exit is identified using hash of (blockNumber, branchMask, receiptLogIndex)\r\n        bytes32 exitHash = keccak256(\r\n            abi.encodePacked(\r\n                inputDataRLPList[2].toUint(), // blockNumber\r\n                // first 2 nibbles are dropped while generating nibble array\r\n                // this allows branch masks that are valid but bypass exitHash check (changing first 2 nibbles only)\r\n                // so converting to nibble array and then hashing it\r\n                MerklePatriciaProof._getNibbleArray(\r\n                    inputDataRLPList[8].toBytes()\r\n                ), // branchMask\r\n                inputDataRLPList[9].toUint() // receiptLogIndex\r\n            )\r\n        );\r\n        require(\r\n            processedExits[exitHash] == false,\r\n            \"FxRootTunnel: EXIT_ALREADY_PROCESSED\"\r\n        );\r\n        processedExits[exitHash] = true;\r\n\r\n        RLPReader.RLPItem[] memory receiptRLPList = inputDataRLPList[6]\r\n        .toBytes()\r\n        .toRlpItem()\r\n        .toList();\r\n        RLPReader.RLPItem memory logRLP = receiptRLPList[3].toList()[\r\n            inputDataRLPList[9].toUint() // receiptLogIndex\r\n        ];\r\n\r\n        RLPReader.RLPItem[] memory logRLPList = logRLP.toList();\r\n\r\n        // check child tunnel\r\n        require(\r\n            fxChildTunnel == RLPReader.toAddress(logRLPList[0]),\r\n            \"FxRootTunnel: INVALID_FX_CHILD_TUNNEL\"\r\n        );\r\n\r\n        // verify receipt inclusion\r\n        require(\r\n            MerklePatriciaProof.verify(\r\n                inputDataRLPList[6].toBytes(), // receipt\r\n                inputDataRLPList[8].toBytes(), // branchMask\r\n                inputDataRLPList[7].toBytes(), // receiptProof\r\n                bytes32(inputDataRLPList[5].toUint()) // receiptRoot\r\n            ),\r\n            \"FxRootTunnel: INVALID_RECEIPT_PROOF\"\r\n        );\r\n\r\n        // verify checkpoint inclusion\r\n        _checkBlockMembershipInCheckpoint(\r\n            inputDataRLPList[2].toUint(), // blockNumber\r\n            inputDataRLPList[3].toUint(), // blockTime\r\n            bytes32(inputDataRLPList[4].toUint()), // txRoot\r\n            bytes32(inputDataRLPList[5].toUint()), // receiptRoot\r\n            inputDataRLPList[0].toUint(), // headerNumber\r\n            inputDataRLPList[1].toBytes() // blockProof\r\n        );\r\n\r\n        RLPReader.RLPItem[] memory logTopicRLPList = logRLPList[1].toList(); // topics\r\n\r\n        require(\r\n            bytes32(logTopicRLPList[0].toUint()) == SEND_MESSAGE_EVENT_SIG, // topic0 is event sig\r\n            \"FxRootTunnel: INVALID_SIGNATURE\"\r\n        );\r\n\r\n        // received message data\r\n        bytes memory receivedData = logRLPList[2].toBytes();\r\n        bytes memory message = abi.decode(receivedData, (bytes)); // event decodes params again, so decoding bytes to get message\r\n        return message;\r\n    }\r\n\r\n    function _checkBlockMembershipInCheckpoint(\r\n        uint256 blockNumber,\r\n        uint256 blockTime,\r\n        bytes32 txRoot,\r\n        bytes32 receiptRoot,\r\n        uint256 headerNumber,\r\n        bytes memory blockProof\r\n    ) private view returns (uint256) {\r\n        (\r\n            bytes32 headerRoot,\r\n            uint256 startBlock,\r\n            ,\r\n            uint256 createdAt,\r\n\r\n        ) = checkpointManager.headerBlocks(headerNumber);\r\n\r\n        require(\r\n            keccak256(\r\n                abi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot)\r\n            ).checkMembership(blockNumber - startBlock, headerRoot, blockProof),\r\n            \"FxRootTunnel: INVALID_HEADER\"\r\n        );\r\n        return createdAt;\r\n    }\r\n\r\n    /**\r\n     * @notice receive message from  L2 to L1, validated by proof\r\n     * @dev This function verifies if the transaction actually happened on child chain\r\n     *\r\n     * @param inputData RLP encoded data of the reference tx containing following list of fields\r\n     *  0 - headerNumber - Checkpoint header block number containing the reference tx\r\n     *  1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root\r\n     *  2 - blockNumber - Block number containing the reference tx on child chain\r\n     *  3 - blockTime - Reference tx block time\r\n     *  4 - txRoot - Transactions root of block\r\n     *  5 - receiptRoot - Receipts root of block\r\n     *  6 - receipt - Receipt of the reference transaction\r\n     *  7 - receiptProof - Merkle proof of the reference receipt\r\n     *  8 - branchMask - 32 bits denoting the path of receipt in merkle tree\r\n     *  9 - receiptLogIndex - Log Index to read from the receipt\r\n     */\r\n    function receiveMessage(bytes memory inputData) public virtual {\r\n        bytes memory message = _validateAndExtractMessage(inputData);\r\n        _processMessageFromChild(message);\r\n    }\r\n\r\n    /**\r\n     * @notice Process message received from Child Tunnel\r\n     * @dev function needs to be implemented to handle message as per requirement\r\n     * This is called by onStateReceive function.\r\n     * Since it is called via a system call, any event will not be emitted during its execution.\r\n     * @param message bytes message that was sent from Child Tunnel\r\n     */\r\n    function _processMessageFromChild(bytes memory message) internal virtual;\r\n}\r\n\r\n// File: contracts/issuance/IssuanceCommon.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\nabstract contract IssuanceCommon is Ownable {\r\n    uint256 public immutable deploymentTimestamp;\r\n\r\n    address public fundRecipient;\r\n    bool public isContributionWindowOpen;\r\n    bool public isContributionWindowClosed;\r\n    bool public isRedemptionRegimeOpen;\r\n    uint256 public contributionStartTimestamp;\r\n\r\n    // Mapping contributors address to amount\r\n    mapping(address => uint256) public contributorAmounts;\r\n\r\n    mapping(address => bool) public claimsCheck;\r\n\r\n    event ContributionWindowOpened(address indexed authorizer);\r\n    event ContributionMade(address indexed contributor, uint256 value);\r\n    event ContributionWindowClosed(address indexed authorizer, uint256 value);\r\n    event RedemptionWindowOpened(\r\n        address indexed authorizer,\r\n        uint256 contributionValue,\r\n        uint256 allocatedTokens\r\n    );\r\n    event TokensRedeemed(address indexed redeemer, uint256 value);\r\n    event InvestmentFundTransferred(address indexed recipient, uint256 value);\r\n\r\n    modifier validateRecipient(address _recipient) {\r\n        require(_recipient != address(0), \"recipient cannot be zero address\");\r\n        require(\r\n            _recipient == fundRecipient,\r\n            \"recipient must match registered fund receiver!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        deploymentTimestamp = block.timestamp;\r\n    }\r\n\r\n    function openContributionWindow() external virtual returns (bool);\r\n\r\n    function closeContributionWindow() external virtual returns (bool);\r\n\r\n    function openRedemptionRegime() external virtual returns (bool);\r\n\r\n    function registerFundRecipient(address _fundRecipient)\r\n        external\r\n        restricted\r\n        returns (bool)\r\n    {\r\n        fundRecipient = _fundRecipient;\r\n\r\n        return true;\r\n    }\r\n\r\n    function redeemTokens() external virtual returns (bool);\r\n}\r\n\r\n// File: contracts/issuance/IssuanceEthereum.sol\r\n\r\n/**\r\n\r\nYOLOrekt Token Issuance - \r\n\r\nYOLOrekt is issuing 5% of the 1 Billion total supply to raise capital to provide in-game liquidity. \r\nThis contracts accepts ETH contributions for acquiring early YOLO tokens at a price that \r\nis determined at close by calculating proportion of funds raised on the ethereum root chain \r\nwith respect to the polygon child chain and sending the appropriate share of YOLO tokens to the \r\nchild issuance contract, while encumbering the appropriate amount (the remainder) for \r\nredemption by the contributors within the Ethereum (root) chain.\r\n\r\nhttps://yolorekt.com \r\n\r\nAuthors :\r\nGaren Vartanian\r\nYogesh Srihari \r\n\r\n**/\r\n\r\npragma solidity 0.8.4;\r\n\r\ncontract IssuanceEthereum is IssuanceCommon, FxBaseRootTunnel {\r\n    uint256 public constant TOTAL_ISSUANCE_CONTRACT_TOKENS =\r\n        50 * 10**6 * 10**18; // 5% of 1B tokens\r\n\r\n    // YOLOrekt's ERC20 Contracts\r\n    YoloEthereumUtilityTokens public immutable yoloEthereumTokenContract;\r\n\r\n    // Sum of contribution on Ethereum side\r\n    uint256 public rootSum;\r\n\r\n    // Remaining proportion after distribution Polygon side's contribution\r\n    uint256 public rootIssuanceAllocatedTokens;\r\n\r\n    // Polygon's Total Contribution Sum in Wei (mEth)\r\n    uint256 public childSum;\r\n\r\n    // Polygon sum received from child tunnel and processed\r\n    bool public hasProcessedMessageFromChild;\r\n\r\n    // Polygon side token proportion requested to be sent\r\n    bool public hasRootToChildTransferRequest;\r\n\r\n    // Predicate contract for ERC20 token lock and transfer across root to child\r\n    address public predicateContractAddress;\r\n\r\n    // Polygon root contracts watched by Heimdall nodes\r\n    IRootChainManager public rootChainManagerContract;\r\n\r\n    constructor(\r\n        address yoloEthereumTokenAddress_,\r\n        address checkpointManager_,\r\n        address fxRoot_,\r\n        address fxChildTunnel_,\r\n        address rootChainManager_,\r\n        address predicateContractAddress_\r\n    ) FxBaseRootTunnel(checkpointManager_, fxRoot_, fxChildTunnel_) {\r\n        require(\r\n            yoloEthereumTokenAddress_ != address(0),\r\n            \"YOLO ethereum token contract address must be specified\"\r\n        );\r\n        require(\r\n            checkpointManager_ != address(0),\r\n            \"checkpointManager contract address must be specified\"\r\n        );\r\n        require(\r\n            fxRoot_ != address(0),\r\n            \"fxRoot contract address must be specified\"\r\n        );\r\n        require(\r\n            fxChildTunnel_ != address(0),\r\n            \"fx child tunnel aka child issuance contract address must be specified\"\r\n        );\r\n        require(\r\n            rootChainManager_ != address(0),\r\n            \"root chain manager contract address must be specified\"\r\n        );\r\n        require(\r\n            predicateContractAddress_ != address(0),\r\n            \"erc20 predicate contract address must be specified\"\r\n        );\r\n\r\n        // Use ChainId to compare and stop contract instantiaion if its the wrong address\r\n\r\n        yoloEthereumTokenContract = YoloEthereumUtilityTokens(\r\n            yoloEthereumTokenAddress_\r\n        );\r\n        rootChainManagerContract = IRootChainManager(rootChainManager_);\r\n        predicateContractAddress = predicateContractAddress_;\r\n    }\r\n\r\n    // just in case\r\n    function setPredicateContractAddress(address contractAddress)\r\n        external\r\n        restricted\r\n        returns (bool)\r\n    {\r\n        require(\r\n            contractAddress != address(0),\r\n            \"erc20 predicate contract address must be specified\"\r\n        );\r\n        predicateContractAddress = contractAddress;\r\n\r\n        return true;\r\n    }\r\n\r\n    // just in case\r\n    function setRootManagerContract(address contractAddress)\r\n        external\r\n        restricted\r\n        returns (bool)\r\n    {\r\n        require(\r\n            contractAddress != address(0),\r\n            \"root chain manager contract address must be specified\"\r\n        );\r\n        rootChainManagerContract = IRootChainManager(contractAddress);\r\n\r\n        return true;\r\n    }\r\n\r\n    // escape hatch - for unlikely scenario where incorrect amount of tokens transferred into\r\n    // issaunce contract, e.g. value other than TOTAL_ISSUANCE_CONTRACT_TOKENS (50 Million)\r\n    // transferred into IssuanceEthereum\r\n    function returnYoloTokens(address ownerAddress, uint256 amount)\r\n        external\r\n        restricted\r\n        returns (bool)\r\n    {\r\n        require(\r\n            isContributionWindowOpen == false,\r\n            \"contribution window already opened\"\r\n        );\r\n\r\n        yoloEthereumTokenContract.transfer(ownerAddress, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function openContributionWindow()\r\n        external\r\n        override\r\n        restricted\r\n        returns (bool)\r\n    {\r\n        require(\r\n            yoloEthereumTokenContract.balanceOf(address(this)) ==\r\n                TOTAL_ISSUANCE_CONTRACT_TOKENS,\r\n            \"50 million tokens must be transferred to issuance contract before issuance is started\"\r\n        );\r\n        require(\r\n            isContributionWindowOpen == false,\r\n            \"contribution window already opened\"\r\n        );\r\n\r\n        isContributionWindowOpen = true;\r\n        contributionStartTimestamp = block.timestamp;\r\n        emit ContributionWindowOpened(msg.sender);\r\n\r\n        return true;\r\n    }\r\n\r\n    function contribute() public payable returns (bool) {\r\n        require(\r\n            isContributionWindowOpen == true,\r\n            \"contribution window has not opened\"\r\n        );\r\n        require(\r\n            isContributionWindowClosed == false,\r\n            \"contribution window has closed\"\r\n        );\r\n        require(msg.value >= 0.01 ether, \"minimum contribution is 0.01 ether\");\r\n\r\n        uint256 contributorTotal = contributorAmounts[msg.sender] + msg.value;\r\n\r\n        contributorAmounts[msg.sender] = contributorTotal;\r\n        rootSum += msg.value;\r\n        emit ContributionMade(msg.sender, msg.value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function closeContributionWindow()\r\n        external\r\n        override\r\n        restricted\r\n        returns (bool)\r\n    {\r\n        require(\r\n            isContributionWindowOpen == true,\r\n            \"contribution window must be open before closing\"\r\n        );\r\n\r\n        isContributionWindowClosed = true;\r\n\r\n        emit ContributionWindowClosed(msg.sender, rootSum);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _processMessageFromChild(bytes memory data) internal override {\r\n        childSum = abi.decode(data, (uint256));\r\n        hasProcessedMessageFromChild = true;\r\n    }\r\n\r\n    // !!! remove virtual after testing\r\n    function depositOnChildIssuanceContract()\r\n        external\r\n        virtual\r\n        restricted\r\n        returns (bool)\r\n    {\r\n        require(\r\n            isContributionWindowClosed == true,\r\n            \"contribution window must be closed\"\r\n        );\r\n        require(\r\n            hasProcessedMessageFromChild == true,\r\n            \"childSum must be processed from child first\"\r\n        );\r\n        require(\r\n            hasRootToChildTransferRequest == false,\r\n            \"root to child transfer already requested\"\r\n        );\r\n        require(\r\n            predicateContractAddress != address(0),\r\n            \"predicate contract address must be set\"\r\n        );\r\n\r\n        // expressions can overflow, assign sum first\r\n        uint256 totalCrossChainSum = rootSum + childSum;\r\n        uint256 childTokenAmount = (TOTAL_ISSUANCE_CONTRACT_TOKENS * childSum) /\r\n            totalCrossChainSum;\r\n\r\n        rootIssuanceAllocatedTokens =\r\n            TOTAL_ISSUANCE_CONTRACT_TOKENS -\r\n            childTokenAmount;\r\n\r\n        yoloEthereumTokenContract.approve(\r\n            predicateContractAddress,\r\n            childTokenAmount\r\n        );\r\n\r\n        bytes memory encodedChildAmount = abi.encode(childTokenAmount);\r\n\r\n        rootChainManagerContract.depositFor(\r\n            fxChildTunnel,\r\n            address(yoloEthereumTokenContract),\r\n            encodedChildAmount\r\n        );\r\n\r\n        hasRootToChildTransferRequest = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    function openRedemptionRegime() external override returns (bool) {\r\n        // check repeateadly - this means isContributionWindowClosed is also true\r\n        require(\r\n            hasRootToChildTransferRequest == true,\r\n            \"requires token transfer request to child and updated root token pool amount\"\r\n        );\r\n\r\n        require(\r\n            msg.sender == owner ||\r\n                block.timestamp > contributionStartTimestamp + 60 days,\r\n            \"cannot open redemption window unless owner or 60 days since deployment\"\r\n        );\r\n        require(\r\n            isRedemptionRegimeOpen == false,\r\n            \"redemption regime already open\"\r\n        );\r\n\r\n        isRedemptionRegimeOpen = true;\r\n\r\n        emit RedemptionWindowOpened(\r\n            msg.sender,\r\n            rootSum,\r\n            rootIssuanceAllocatedTokens\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    function migrateInvestmentFund(address payable recipient)\r\n        external\r\n        restricted\r\n        validateRecipient(recipient)\r\n        returns (bool)\r\n    {\r\n        require(\r\n            isContributionWindowClosed == true,\r\n            \"contribution window must be closed\"\r\n        );\r\n\r\n        uint256 contractBalance = address(this).balance;\r\n        recipient.transfer(contractBalance);\r\n        emit InvestmentFundTransferred(recipient, contractBalance);\r\n\r\n        return true;\r\n    }\r\n\r\n    function redeemTokens() external override returns (bool) {\r\n        // Which will unlock once the product goes live.\r\n        require(\r\n            isRedemptionRegimeOpen == true,\r\n            \"redemption window is not open yet\"\r\n        );\r\n        require(claimsCheck[msg.sender] == false, \"prior claim executed\");\r\n\r\n        claimsCheck[msg.sender] = true;\r\n\r\n        uint256 claimAmount = (contributorAmounts[msg.sender] *\r\n            rootIssuanceAllocatedTokens) / rootSum;\r\n\r\n        contributorAmounts[msg.sender] = 0;\r\n\r\n        yoloEthereumTokenContract.transfer(msg.sender, claimAmount);\r\n        emit TokensRedeemed(msg.sender, claimAmount);\r\n\r\n        return true;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"yoloEthereumTokenAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"checkpointManager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fxRoot_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fxChildTunnel_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rootChainManager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"predicateContractAddress_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ContributionMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ContributionWindowClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"}],\"name\":\"ContributionWindowOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InvestmentFundTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contributionValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocatedTokens\",\"type\":\"uint256\"}],\"name\":\"RedemptionWindowOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokensRedeemed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SEND_MESSAGE_EVENT_SIG\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_ISSUANCE_CONTRACT_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpointManager\",\"outputs\":[{\"internalType\":\"contract ICheckpointManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"childSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimsCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeContributionWindow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contribute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contributionStartTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributorAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploymentTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositOnChildIssuanceContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxChildTunnel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxRoot\",\"outputs\":[{\"internalType\":\"contract IFxStateSender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasProcessedMessageFromChild\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasRootToChildTransferRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isContributionWindowClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isContributionWindowOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRedemptionRegimeOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"migrateInvestmentFund\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openContributionWindow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openRedemptionRegime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"predicateContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"processedExits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"inputData\",\"type\":\"bytes\"}],\"name\":\"receiveMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fundRecipient\",\"type\":\"address\"}],\"name\":\"registerFundRecipient\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"returnYoloTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootChainManagerContract\",\"outputs\":[{\"internalType\":\"contract IRootChainManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootIssuanceAllocatedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_checkpointManager\",\"type\":\"address\"}],\"name\":\"setCheckpointManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fxChildTunnel\",\"type\":\"address\"}],\"name\":\"setFxChildTunnel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fxRoot\",\"type\":\"address\"}],\"name\":\"setFxRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setPredicateContractAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setRootManagerContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yoloEthereumTokenContract\",\"outputs\":[{\"internalType\":\"contract YoloEthereumUtilityTokens\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"IssuanceEthereum","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000811648e10c9cd7f7517644928f3b45fb953c4db400000000000000000000000086e4dc95c7fbdbf52e33d563bbdb00823894c287000000000000000000000000fe5e5d361b2ad62c541bab87c45a0b9b018389a20000000000000000000000007ed1bc8439ab2b14681de5b4bd281799d6bf9799000000000000000000000000a0c68c638235ee32657e8f720a23cec1bfc77c7700000000000000000000000040ec5b33f54e0e8a33a975908c5ba1c14e5bbbdf","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://167f8668135feeb3346746cbb37fc7d978fe9c2f19d4ee85ab0570f1576b508c"}]}