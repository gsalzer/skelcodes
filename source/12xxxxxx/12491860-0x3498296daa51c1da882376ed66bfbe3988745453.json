{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public proposedOwner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() virtual {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev propeses a new owner\r\n     * Can only be called by the current owner.\r\n     */\r\n    function proposeOwner(address payable _newOwner) external onlyOwner {\r\n        proposedOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev claims ownership of the contract\r\n     * Can only be called by the new proposed owner.\r\n     */\r\n    function claimOwnership() external {\r\n        require(msg.sender == proposedOwner);\r\n        emit OwnershipTransferred(owner, proposedOwner);\r\n        owner = proposedOwner;\r\n    }\r\n}\r\n\r\ninterface IPika {\r\n    function minSupply() external returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function burn(uint256 value) external;\r\n}\r\n\r\ncontract PikaStaking is Owned {\r\n    address public communityWallet;\r\n    uint256 public totalAmountStaked = 0;\r\n    mapping(address => uint256) public balances;\r\n    mapping(address => uint256) public claimPeriods;\r\n    IPika public pika;\r\n    uint256 public periodNonce = 0;\r\n    uint256 public periodFinish;\r\n    uint256 public minPeriodDuration = 14 days;\r\n    uint256 public rewardPerToken = 0;\r\n    uint256 public maxInitializationReward;\r\n\r\n    event Staked(address indexed user, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n    event RewardClaimed(address indexed user, uint256 amount);\r\n    event StakingPeriodStarted(uint256 totalRewardPool, uint256 periodFinish);\r\n    event MinPeriodDurationUpdated(uint256 oldDuration, uint256 newDuration);\r\n    event MaxInitializationRewardUpdated(uint256 oldValue, uint256 newValue);\r\n\r\n    constructor(address _token, address _communityWallet) {\r\n        pika = IPika(_token);\r\n        communityWallet = _communityWallet;\r\n        maxInitializationReward = 1000000000 ether;\r\n        periodFinish = block.timestamp + 3 days;\r\n    }\r\n\r\n    /**\r\n     * @notice allows a user to stake tokens\r\n     * @dev requires to claim pending rewards before being able to stake more tokens\r\n     * @param _amount of tokens to stake\r\n     */\r\n    function stake(uint256 _amount) public {\r\n        uint256 balance = balances[msg.sender];\r\n        if (balance > 0) {\r\n            require(\r\n                claimPeriods[msg.sender] == periodNonce,\r\n                \"Claim your reward before staking more tokens\"\r\n            );\r\n        }\r\n        pika.transferFrom(msg.sender, address(this), _amount);\r\n        uint256 burnedAmount = (_amount * 12) / 100;\r\n        if (pika.totalSupply() - burnedAmount >= pika.minSupply()) {\r\n            pika.burn(burnedAmount);\r\n        } else {\r\n            burnedAmount = 0;\r\n        }\r\n        uint256 communityWalletAmount = (_amount * 3) / 100;\r\n        pika.transfer(communityWallet, communityWalletAmount);\r\n        uint256 userBalance = _amount - burnedAmount - communityWalletAmount;\r\n        balances[msg.sender] += userBalance;\r\n        claimPeriods[msg.sender] = periodNonce;\r\n        totalAmountStaked += userBalance;\r\n        emit Staked(msg.sender, userBalance);\r\n    }\r\n\r\n    /**\r\n     * @notice allows a user to withdraw staked tokens\r\n     * @dev unclaimed tokens cannot be claimed after withdrawal\r\n     * @dev unstakes all tokens\r\n     */\r\n    function withdraw() public {\r\n        uint256 balance = balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        totalAmountStaked -= balance;\r\n        pika.transfer(msg.sender, balance);\r\n        emit Withdraw(msg.sender, balance);\r\n    }\r\n\r\n    /**\r\n     * @notice claims a reward for the staked tokens\r\n     * @dev can only claim once per staking period\r\n     */\r\n    function claimReward() public {\r\n        uint256 balance = balances[msg.sender];\r\n        require(balance > 0, \"No tokens staked\");\r\n        require(\r\n            claimPeriods[msg.sender] < periodNonce,\r\n            \"Wait for this period to finish before claiming your reward\"\r\n        );\r\n        claimPeriods[msg.sender] = periodNonce;\r\n        uint256 reward = (balance * rewardPerToken) / 1 ether;\r\n        pika.transfer(msg.sender, reward);\r\n        emit RewardClaimed(msg.sender, reward);\r\n    }\r\n\r\n    /**\r\n     * @notice returns claimable reward for a user\r\n     * @param _user to check\r\n     */\r\n    function claimableReward(address _user) public view returns (uint256) {\r\n        if (claimPeriods[_user] == periodNonce) {\r\n            return 0;\r\n        }\r\n        return (balances[_user] * rewardPerToken) / 1 ether;\r\n    }\r\n\r\n    /**\r\n     * @notice initializes new staking claim period\r\n     * @dev requires previous staking period to be over\r\n     * @dev only callable by anyone, msg.sender receives a portion of the staking pool as a reward\r\n     */\r\n    function initNewRewardPeriod() external {\r\n        require(\r\n            block.timestamp >= periodFinish,\r\n            \"Wait for claim period to finish\"\r\n        );\r\n        require(totalAmountStaked > 0, \"No tokens staked in contract\");\r\n        uint256 rewardPool = pika.balanceOf(address(this)) - totalAmountStaked;\r\n        uint256 initializationReward = rewardPool / 1000;\r\n        if (initializationReward > maxInitializationReward) {\r\n            initializationReward = maxInitializationReward;\r\n        }\r\n        rewardPool -= initializationReward;\r\n        pika.transfer(msg.sender, initializationReward);\r\n        rewardPerToken = (rewardPool * 1 ether) / totalAmountStaked;\r\n        periodNonce++;\r\n        periodFinish = block.timestamp + minPeriodDuration;\r\n        emit StakingPeriodStarted(rewardPool, periodFinish);\r\n    }\r\n\r\n    /**\r\n     * @notice sets a new minimum duration for each staking claim period\r\n     * @dev only callable by owner\r\n     * @param _days amount of days the new staking claim period should at least last\r\n     */\r\n    function setMinDuration(uint256 _days) external onlyOwner {\r\n        emit MinPeriodDurationUpdated(minPeriodDuration / 1 days, _days);\r\n        minPeriodDuration = _days * 1 days;\r\n    }\r\n\r\n    /**\r\n     * @notice sets maximum initialization reward\r\n     * @dev only callable by owner\r\n     * @param _newMaxReward new maximum reward paid out by initNewRewardPeriod function\r\n     */\r\n    function setMaxInitializationReward(uint256 _newMaxReward)\r\n        external\r\n        onlyOwner\r\n    {\r\n        emit MaxInitializationRewardUpdated(\r\n            maxInitializationReward,\r\n            _newMaxReward\r\n        );\r\n        maxInitializationReward = _newMaxReward;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_communityWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"MaxInitializationRewardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"MinPeriodDurationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalRewardPool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"periodFinish\",\"type\":\"uint256\"}],\"name\":\"StakingPeriodStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimPeriods\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"claimableReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"communityWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initNewRewardPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxInitializationReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPeriodDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pika\",\"outputs\":[{\"internalType\":\"contract IPika\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"proposeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaxReward\",\"type\":\"uint256\"}],\"name\":\"setMaxInitializationReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"setMinDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAmountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PikaStaking","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000a682ee16b497afceedf47e4820fc2af3845fd2d200000000000000000000000025fe8fbba7e090f3d781bc6dd2dbe90889ee7ef3","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6f916d6002524233e6446415feb007626df9c1277f4761aff8038be49f02cfa3"}]}