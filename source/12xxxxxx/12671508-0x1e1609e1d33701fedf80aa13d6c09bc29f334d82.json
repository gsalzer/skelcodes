{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/I_Curve.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n/**\r\n * @title   Interface Curve\r\n * @notice  This contract acts as an interface to the curve contract. For\r\n *          documentation please see the curve smart contract.\r\n */\r\ninterface I_Curve {\r\n    \r\n    // -------------------------------------------------------------------------\r\n    // View functions\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * @notice This function is only callable after the curve contract has been\r\n     *         initialized.\r\n     * @param  _amount The amount of tokens a user wants to buy\r\n     * @return uint256 The cost to buy the _amount of tokens in the collateral\r\n     *         currency (see collateral token).\r\n     */\r\n    function buyPrice(uint256 _amount)\r\n        external\r\n        view\r\n        returns (uint256 collateralRequired);\r\n\r\n    /**\r\n     * @notice This function is only callable after the curve contract has been\r\n     *         initialized.\r\n     * @param  _amount The amount of tokens a user wants to sell\r\n     * @return collateralReward The reward for selling the _amount of tokens in the\r\n     *         collateral currency (see collateral token).\r\n     */\r\n    function sellReward(uint256 _amount)\r\n        external\r\n        view\r\n        returns (uint256 collateralReward);\r\n\r\n    /**\r\n      * @return If the curve is both active and initialised.\r\n      */\r\n    function isCurveActive() external view returns (bool);\r\n\r\n    /**\r\n      * @return The address of the collateral token (DAI)\r\n      */\r\n    function collateralToken() external view returns (address);\r\n\r\n    /**\r\n      * @return The address of the bonded token (BZZ).\r\n      */\r\n    function bondedToken() external view returns (address);\r\n\r\n    /**\r\n      * @return The required collateral amount (DAI) to initialise the curve.\r\n      */\r\n    function requiredCollateral(uint256 _initialSupply)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    // -------------------------------------------------------------------------\r\n    // State modifying functions\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * @notice This function initializes the curve contract, and ensure the\r\n     *         curve has the required permissions on the token contract needed\r\n     *         to function.\r\n     */\r\n    function init() external;\r\n\r\n    /**\r\n      * @param  _amount The amount of tokens (BZZ) the user wants to buy.\r\n      * @param  _maxCollateralSpend The max amount of collateral (DAI) the user is\r\n      *         willing to spend in order to buy the _amount of tokens.\r\n      * @return The status of the mint. Note that should the total cost of the\r\n      *         purchase exceed the _maxCollateralSpend the transaction will revert.\r\n      */\r\n    function mint(uint256 _amount, uint256 _maxCollateralSpend)\r\n        external\r\n        returns (bool success);\r\n\r\n    /**\r\n      * @param  _amount The amount of tokens (BZZ) the user wants to buy.\r\n      * @param  _maxCollateralSpend The max amount of collateral (DAI) the user is\r\n      *         willing to spend in order to buy the _amount of tokens.\r\n      * @param  _to The address to send the tokens to.\r\n      * @return The status of the mint. Note that should the total cost of the\r\n      *         purchase exceed the _maxCollateralSpend the transaction will revert.\r\n      */\r\n    function mintTo(\r\n        uint256 _amount, \r\n        uint256 _maxCollateralSpend, \r\n        address _to\r\n    )\r\n        external\r\n        returns (bool success);\r\n\r\n    /**\r\n      * @param  _amount The amount of tokens (BZZ) the user wants to sell.\r\n      * @param  _minCollateralReward The min amount of collateral (DAI) the user is\r\n      *         willing to receive for their tokens.\r\n      * @return The status of the burn. Note that should the total reward of the\r\n      *         burn be below the _minCollateralReward the transaction will revert.\r\n      */\r\n    function redeem(uint256 _amount, uint256 _minCollateralReward)\r\n        external\r\n        returns (bool success);\r\n\r\n    /**\r\n      * @notice Shuts down the curve, disabling buying, selling and both price\r\n      *         functions. Can only be called by the owner. Will renounce the\r\n      *         minter role on the bonded token.\r\n      */\r\n    function shutDown() external;\r\n}\r\n\r\n// File: contracts/I_router_02.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n/**\r\n  * Please note that this interface was created as IUniswapV2Router02 uses\r\n  * Solidity >= 0.6.2, and the BZZ infastructure uses 0.5.0. \r\n  */\r\ninterface I_router_02 {\r\n    // Views & Pure\r\n    function WETH() external pure returns (address);\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n   \r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    // State modifying\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint amountIn, \r\n        uint amountOutMin, \r\n        address[] calldata path, \r\n        address to, \r\n        uint deadline\r\n    )\r\n        external\r\n        returns (uint[] memory amounts);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/Eth_broker.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n\r\n\r\n\r\ncontract Eth_broker {\r\n    // The instance of the curve\r\n    I_Curve internal curve_;\r\n    // The instance of the Uniswap router\r\n    I_router_02 internal router_;\r\n    // The instance of the DAI token\r\n    IERC20 internal dai_;\r\n    // The address for the underlying token address\r\n    IERC20 internal bzz_;\r\n    // Mutex guard for state modifying functions\r\n    uint256 private status_;\r\n    // States for the guard \r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Events\r\n    // -------------------------------------------------------------------------\r\n\r\n    // Emitted when tokens are minted\r\n    event mintTokensWithEth(\r\n        address indexed buyer,      // The address of the buyer\r\n        uint256 amount,             // The amount of bonded tokens to mint\r\n        uint256 priceForTokensDai,  // The price in DAI for the token amount\r\n        uint256 EthTradedForDai,    // The ETH amount sold for DAI\r\n        uint256 maxSpendDai         // The max amount of DAI to spend\r\n    );\r\n    // Emitted when tokens are minted\r\n    event mintTokensToWithEth(\r\n        address indexed buyer,      // The address of the buyer\r\n        address indexed receiver,   // The address of the receiver of the tokens\r\n        uint256 amount,             // The amount of bonded tokens to mint\r\n        uint256 priceForTokensDai,  // The price in DAI for the token amount\r\n        uint256 EthTradedForDai,    // The ETH amount sold for DAI\r\n        uint256 maxSpendDai         // The max amount of DAI to spend\r\n    );\r\n    // Emitted when tokens are burnt\r\n    event burnTokensWithEth(\r\n        address indexed seller,     // The address of the seller\r\n        uint256 amount,             // The amount of bonded tokens to burn\r\n        uint256 rewardReceivedDai,  // The amount of DAI received for selling\r\n        uint256 ethReceivedForDai,  // How much ETH the DAI was traded for\r\n        uint256 minRewardDai        // The min amount of DAI to sell for\r\n    );\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Modifiers\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n      * @notice Checks if the curve is active (may be redundant).\r\n      */\r\n    modifier isCurveActive() {\r\n        require(curve_.isCurveActive(), \"Curve inactive\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n      * @notice Protects against re-entrancy attacks\r\n      */\r\n    modifier mutex() {\r\n        require(status_ != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        // Any calls to non Reentrant after this point will fail\r\n        status_ = _ENTERED;\r\n        // Function executes\r\n        _;\r\n        // Status set to not entered\r\n        status_ = _NOT_ENTERED;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(\r\n        address _bzzCurve, \r\n        address _collateralToken, \r\n        address _router02\r\n    ) \r\n        public \r\n    {\r\n        require(\r\n            _bzzCurve != address(0) &&\r\n            _collateralToken != address(0) &&\r\n            _router02 != address(0),\r\n            \"Addresses of contracts cannot be 0x address\"\r\n        );\r\n        curve_ = I_Curve(_bzzCurve);\r\n        dai_ = IERC20(_collateralToken);\r\n        router_ = I_router_02(_router02);\r\n        // Setting the address of the underlying token (BZZ)\r\n        bzz_ = IERC20(curve_.bondedToken());\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // View functions\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * @notice This function is only callable after the curve contract has been\r\n     *         initialized.\r\n     * @param  _amount The amount of tokens a user wants to buy\r\n     * @return uint256 The cost to buy the _amount of tokens in ETH\r\n     */\r\n    function buyPrice(uint256 _amount)\r\n        public\r\n        view\r\n        isCurveActive()\r\n        returns (uint256)\r\n    {\r\n        // Getting the current DAI cost for token amount\r\n        uint256 daiCost = curve_.buyPrice(_amount);\r\n        // Returning the required ETH to buy DAI amount\r\n        return router_.getAmountsIn(\r\n            daiCost, \r\n            getPath(true)\r\n        )[0];\r\n    }\r\n\r\n    /**\r\n     * @notice This function is only callable after the curve contract has been\r\n     *         initialized.\r\n     * @param  _amount The amount of tokens a user wants to sell\r\n     * @return uint256 The reward for selling the _amount of tokens in ETH\r\n     */\r\n    function sellReward(uint256 _amount)\r\n        public\r\n        view\r\n        isCurveActive()\r\n        returns (uint256)\r\n    {\r\n        // Getting the current DAI reward for token amount\r\n        uint256 daiReward = curve_.sellReward(_amount);\r\n        // Returning the ETH reward for token sale\r\n        return router_.getAmountsIn(\r\n            daiReward, \r\n            getPath(true)\r\n        )[0];\r\n    }\r\n    \r\n    /**\r\n      * @param  _daiAmount The amount of dai to be traded for ETH\r\n      * @return uint256 The amount of ETH that can be traded for given the\r\n      *         dai amount\r\n      */\r\n    function sellRewardDai(uint256 _daiAmount)\r\n        public\r\n        view\r\n        isCurveActive()\r\n        returns (uint256)\r\n    {\r\n        // Returning the ETH reward for the dai amount\r\n        return router_.getAmountsIn(\r\n            _daiAmount, \r\n            getPath(true)\r\n        )[0];\r\n    }\r\n    \r\n    /**\r\n      * @param  _buy If the path is for a buy or sell transaction\r\n      * @return address[] The path for the transaction\r\n      */\r\n    function getPath(bool _buy) public view returns(address[] memory) {\r\n        address[] memory buyPath = new address[](2);\r\n        if(_buy) {\r\n            buyPath[0] = router_.WETH();\r\n            buyPath[1] = address(dai_);\r\n        } else {\r\n            buyPath[0] = address(dai_);\r\n            buyPath[1] = router_.WETH();\r\n        }\r\n        \r\n        return buyPath;\r\n    }\r\n    \r\n    /**\r\n      * @return Gets the current time\r\n      */\r\n    function getTime() public view returns(uint256) {\r\n        return now;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // State modifying functions\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n      * @param  _tokenAmount The amount of BZZ tokens the user would like to\r\n      *         buy from the curve.\r\n      * @param  _maxDaiSpendAmount The max amount of collateral (DAI) the user\r\n      *         is willing to spend to buy the amount of tokens.\r\n      * @param  _deadline Unix timestamp after which the transaction will \r\n      *         revert. - Taken from Uniswap documentation: \r\n      *         https://uniswap.org/docs/v2/smart-contracts/router02/#swapethforexacttokens\r\n      * @return bool If the transaction completed successfully.\r\n      * @notice Before this function is called the caller does not need to\r\n      *         approve the spending of anything. Please assure that the amount\r\n      *         of ETH sent with this transaction is sufficient by first calling\r\n      *         `buyPrice` with the same token amount. Add your % slippage to\r\n      *         the max dai spend amount (you can get the expected amount by \r\n      *         calling `buyPrice` on the curve contract).\r\n      */\r\n    function mint(\r\n        uint256 _tokenAmount, \r\n        uint256 _maxDaiSpendAmount, \r\n        uint _deadline\r\n    )\r\n        external\r\n        payable\r\n        isCurveActive()\r\n        mutex()\r\n        returns (bool)\r\n    {\r\n        (uint256 daiNeeded, uint256 ethReceived) = _commonMint(\r\n            _tokenAmount,\r\n            _maxDaiSpendAmount,\r\n            _deadline,\r\n            msg.sender\r\n        );\r\n        // Emitting event with all important info\r\n        emit mintTokensWithEth(\r\n            msg.sender, \r\n            _tokenAmount, \r\n            daiNeeded, \r\n            ethReceived, \r\n            _maxDaiSpendAmount\r\n        );\r\n        // Returning that the mint executed successfully\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @param  _tokenAmount The amount of BZZ tokens the user would like to\r\n      *         buy from the curve.\r\n      * @param  _maxDaiSpendAmount The max amount of collateral (DAI) the user\r\n      *         is willing to spend to buy the amount of tokens.\r\n      * @param  _deadline Unix timestamp after which the transaction will \r\n      *         revert. - Taken from Uniswap documentation: \r\n      *         https://uniswap.org/docs/v2/smart-contracts/router02/#swapethforexacttokens\r\n      * @return bool If the transaction completed successfully.\r\n      * @notice Before this function is called the caller does not need to\r\n      *         approve the spending of anything. Please assure that the amount\r\n      *         of ETH sent with this transaction is sufficient by first calling\r\n      *         `buyPrice` with the same token amount. Add your % slippage to\r\n      *         the max dai spend amount (you can get the expected amount by \r\n      *         calling `buyPrice` on the curve contract).\r\n      */\r\n    function mintTo(\r\n        uint256 _tokenAmount, \r\n        uint256 _maxDaiSpendAmount, \r\n        uint _deadline,\r\n        address _to\r\n    )\r\n        external\r\n        payable\r\n        isCurveActive()\r\n        mutex()\r\n        returns (bool)\r\n    {\r\n        (uint256 daiNeeded, uint256 ethReceived) = _commonMint(\r\n            _tokenAmount,\r\n            _maxDaiSpendAmount,\r\n            _deadline,\r\n            _to\r\n        );\r\n        // Emitting event with all important info\r\n        emit mintTokensToWithEth(\r\n            msg.sender, \r\n            _to,\r\n            _tokenAmount, \r\n            daiNeeded, \r\n            ethReceived, \r\n            _maxDaiSpendAmount\r\n        );\r\n        // Returning that the mint executed successfully\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @notice The user needs to have approved this contract as a spender of\r\n      *         of the desired `_tokenAmount` to sell before calling this\r\n      *         transaction. Failure to do so will result in the call reverting.\r\n      *         This function is payable to receive ETH from internal calls.\r\n      *         Please do not send ETH to this function.\r\n      * @param  _tokenAmount The amount of BZZ tokens the user would like to\r\n      *         sell.\r\n      * @param  _minDaiSellValue The min value of collateral (DAI) the user\r\n      *         is willing to sell their tokens for.\r\n      * @param  _deadline Unix timestamp after which the transaction will \r\n      *         revert. - Taken from Uniswap documentation: \r\n      *         https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensforeth\r\n      * @return bool If the transaction completed successfully.\r\n      */\r\n    function redeem(\r\n        uint256 _tokenAmount, \r\n        uint256 _minDaiSellValue,\r\n        uint _deadline\r\n    )\r\n        external\r\n        payable\r\n        isCurveActive()\r\n        mutex()\r\n        returns (bool)\r\n    {\r\n        // Gets the current reward for selling the amount of tokens\r\n        uint256 daiReward = curve_.sellReward(_tokenAmount);\r\n        // The check that the dai reward amount is not more than the min sell \r\n        // amount happens in the curve.\r\n\r\n        // Transferring _amount of tokens into this contract\r\n        require(\r\n            bzz_.transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                _tokenAmount\r\n            ),\r\n            \"Transferring BZZ failed\"\r\n        );\r\n        // Approving the curve as a spender\r\n        require(\r\n            bzz_.approve(\r\n                address(curve_),\r\n                _tokenAmount\r\n            ),\r\n            \"BZZ approve failed\"\r\n        );\r\n        // Selling tokens for DAI\r\n        require(\r\n            curve_.redeem(\r\n                _tokenAmount,\r\n                daiReward\r\n            ),\r\n            \"Curve burn failed\"\r\n        );\r\n        // Getting expected ETH for DAI\r\n        uint256 ethMin = sellRewardDai(dai_.balanceOf(address(this)));\r\n        // Approving the router as a spender\r\n        require(\r\n            dai_.approve(\r\n                address(router_),\r\n                daiReward\r\n            ),\r\n            \"DAI approve failed\"\r\n        );\r\n        // Selling DAI received for ETH\r\n        router_.swapExactTokensForETH(\r\n            daiReward, \r\n            ethMin, \r\n            getPath(false), \r\n            msg.sender, \r\n            _deadline\r\n        );\r\n        // Emitting event with all important info\r\n        emit burnTokensWithEth(\r\n            msg.sender, \r\n            _tokenAmount, \r\n            daiReward, \r\n            ethMin, \r\n            _minDaiSellValue\r\n        );\r\n        // Returning that the burn executed successfully\r\n        return true;\r\n    }\r\n\r\n    function() external payable {\r\n        require(\r\n            msg.sender == address(router_),\r\n            \"ETH not accepted outside router\"\r\n        );\r\n    }\r\n\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Internal functions\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n      * @param  _tokenAmount The amount of BZZ tokens the user would like to\r\n      *         buy from the curve.\r\n      * @param  _maxDaiSpendAmount The max amount of collateral (DAI) the user\r\n      *         is willing to spend to buy the amount of tokens.\r\n      * @param  _deadline Unix timestamp after which the transaction will \r\n      *         revert. - Taken from Uniswap documentation: \r\n      *         https://uniswap.org/docs/v2/smart-contracts/router02/#swapethforexacttokens\r\n      * @return uint256 The dai needed to buy the tokens.\r\n      * @return uint256 The Ether received from the user for the trade.\r\n      * @notice Before this function is called the caller does not need to\r\n      *         approve the spending of anything. Please assure that the amount\r\n      *         of ETH sent with this transaction is sufficient by first calling\r\n      *         `buyPrice` with the same token amount. Add your % slippage to\r\n      *         the max dai spend amount (you can get the expected amount by \r\n      *         calling `buyPrice` on the curve contract).\r\n      */\r\n    function _commonMint(\r\n        uint256 _tokenAmount, \r\n        uint256 _maxDaiSpendAmount, \r\n        uint _deadline,\r\n        address _to\r\n    )\r\n        internal\r\n        returns(\r\n            uint256 daiNeeded,\r\n            uint256 ethReceived\r\n        )\r\n    {\r\n        // Getting the exact needed amount of DAI for desired token amount\r\n        daiNeeded = curve_.buyPrice(_tokenAmount);\r\n        // Checking that this amount is not more than the max spend amount\r\n        require(\r\n            _maxDaiSpendAmount >= daiNeeded,\r\n            \"DAI required for trade above max\"\r\n        );\r\n        // Swapping sent ETH for exact amount of DAI needed\r\n        router_.swapETHForExactTokens.value(msg.value)(\r\n            daiNeeded, \r\n            getPath(true), \r\n            address(this), \r\n            _deadline\r\n        );\r\n        // Getting the amount of ETH received\r\n        ethReceived = address(this).balance;\r\n        // Approving the curve as a spender\r\n        require(\r\n            dai_.approve(address(curve_), daiNeeded),\r\n            \"DAI approve failed\"\r\n        );\r\n        // Buying tokens (BZZ) against the curve\r\n        require(\r\n            curve_.mintTo(_tokenAmount, daiNeeded, _to),\r\n            \"BZZ mintTo failed\"\r\n        );\r\n        // Refunding user excess ETH\r\n        msg.sender.transfer(ethReceived);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_maxDaiSpendAmount\",\"type\":\"uint256\"},{\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_buy\",\"type\":\"bool\"}],\"name\":\"getPath\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_daiAmount\",\"type\":\"uint256\"}],\"name\":\"sellRewardDai\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_minDaiSellValue\",\"type\":\"uint256\"},{\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_maxDaiSpendAmount\",\"type\":\"uint256\"},{\"name\":\"_deadline\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"mintTo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_bzzCurve\",\"type\":\"address\"},{\"name\":\"_collateralToken\",\"type\":\"address\"},{\"name\":\"_router02\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"priceForTokensDai\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"EthTradedForDai\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maxSpendDai\",\"type\":\"uint256\"}],\"name\":\"mintTokensWithEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"priceForTokensDai\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"EthTradedForDai\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maxSpendDai\",\"type\":\"uint256\"}],\"name\":\"mintTokensToWithEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardReceivedDai\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethReceivedForDai\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minRewardDai\",\"type\":\"uint256\"}],\"name\":\"burnTokensWithEth\",\"type\":\"event\"}]","ContractName":"Eth_broker","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"0000000000000000000000004f32ab778e85c4ad0cead54f8f82f5ee74d469040000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d","EVMVersion":"Default","Library":"","LicenseType":"BSD-3-Clause","Proxy":"0","Implementation":"","SwarmSource":"bzzr://cc34d81bce1ba88e5286344136fca772987c64b439314aac86de7d48a2a418cf"}]}