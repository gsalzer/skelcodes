{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/*\r\n    a0 a1 a2 a3\r\n\r\n    ---Rank 1-----------------------------------\r\n    a0 a1 a2 a3 => 60%\r\n\r\n    ---Rank 2-----------------------------------\r\n    (a0 a1 a2 !a3) => 25%\r\n\r\n    ---Rank 3-----------------------------------\r\n    a0a1 or a1a2 or a2a3 => 10%\r\n\r\n    ---Rank 4-----------------------------------\r\n    a0 or a1 or a2 or a3 => 4%\r\n    \r\n    1% -> dev\r\n    --------------------------------------------\r\n    \r\n    If nobody won anything (not even 1 number):\r\n\r\n    1% -> dev\r\n    4% -> burned\r\n    95% -> next pot\r\n\r\n*/\r\n\r\ncontract Lottery {\r\n    using SafeMath for uint;\r\n\r\n    uint8 public lotoID = 1;\r\n    uint8 public winum1 = 11;\r\n    uint8 public winum2 = 11;\r\n    uint8 public winum3 = 11;\r\n    uint8 public winum4 = 11;\r\n\r\n    uint256 public numOfTickets = 1;\r\n    uint256 public ticketPrice = 1000 * 10**9;\r\n\r\n    mapping(address => string) tickets;\r\n    mapping(address => uint256) ticketsCount;\r\n    mapping(address => bool) isPlayer;\r\n    address[] public players;\r\n    address[] public winners;\r\n\r\n    IERC20 public inu;\r\n    address public devX;\r\n\r\n    bool public lotoEnabled;\r\n    bool public buyingEnabled;\r\n\r\n    event EndedLoto(uint256 payedOut);\r\n    event BoughtTicket(address account,uint8[] numbers);\r\n\r\n    constructor(address inu_, address devX_) public {\r\n        inu = IERC20(inu_);\r\n        devX = devX_;\r\n    }\r\n\r\n    modifier onlyDev() {\r\n        require(msg.sender == devX, \"Dev Only\");\r\n        _;\r\n    }\r\n\r\n    function append(string memory a, string memory b, string memory c, string memory d, string memory e) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(a, b, c, d, e,\"-\"));\r\n    }\r\n\r\n    function toUint8(bytes1 num) internal pure returns (uint8) {\r\n        if (num == bytes1(\"0\")) {\r\n            return 0;\r\n        } else if (num == bytes1(\"1\")) {\r\n            return 1;\r\n        } else if (num == bytes1(\"2\")) {\r\n            return 2;\r\n        } else if (num == bytes1(\"3\")) {\r\n            return 3;\r\n        } else if (num == bytes1(\"4\")) {\r\n            return 4;\r\n        } else if (num == bytes1(\"5\")) {\r\n            return 5;\r\n        } else if (num == bytes1(\"6\")) {\r\n            return 6;\r\n        } else if (num == bytes1(\"7\")) {\r\n            return 7;\r\n        } else if (num == bytes1(\"8\")) {\r\n            return 8;\r\n        } else if (num == bytes1(\"9\")) {\r\n            return 9;\r\n        }\r\n    }\r\n\r\n    function toString(uint8 num) internal pure returns (string memory) {\r\n        if (num == 0) {\r\n            return \"0\";\r\n        } else if (num == 1) {\r\n            return \"1\";\r\n        } else if (num == 2) {\r\n            return \"2\";\r\n        } else if (num == 3) {\r\n            return \"3\";\r\n        } else if (num == 4) {\r\n            return \"4\";\r\n        } else if (num == 5) {\r\n            return \"5\";\r\n        } else if (num == 6) {\r\n            return \"6\";\r\n        } else if (num == 7) {\r\n            return \"7\";\r\n        } else if (num == 8) {\r\n            return \"8\";\r\n        } else if (num == 9) {\r\n            return \"9\";\r\n        }\r\n    }\r\n\r\n    function getTickets(address address_) public view returns (string memory) {\r\n        return tickets[address_];\r\n    }\r\n    \r\n    function getWinningNumber() external view returns(string memory){\r\n        if(winum1==11 && winum2 == 11 && winum3 == 11 && winum4 == 11){\r\n            return \"Not out\";\r\n        }\r\n        return append(\"\",toString(winum1),toString(winum2),toString(winum3),toString(winum4));\r\n    }\r\n\r\n    function getNumPlayers() external view returns (uint256) {\r\n        return players.length;\r\n    }\r\n\r\n    function getTotalTickets() external view returns (uint256){\r\n        return numOfTickets - 1;\r\n    }\r\n\r\n    function disableBuying() external onlyDev() {\r\n        buyingEnabled = false;\r\n    }\r\n\r\n    function enableLoto() external onlyDev() {\r\n        require(!lotoEnabled);\r\n        uint256 len = players.length;\r\n        for (uint256 i = 1; i <= len; i++) { \r\n            tickets[players[i-1]] = \"\";\r\n            isPlayer[players[i-1]] = false;\r\n            ticketsCount[players[i-1]]=0;\r\n        }\r\n        delete players;\r\n        delete winners;\r\n        numOfTickets = 1;\r\n        winum1=11;\r\n        winum2=11;\r\n        winum3=11;\r\n        winum4=11;\r\n        lotoEnabled = true;\r\n        buyingEnabled = true;\r\n    }\r\n\r\n    function disableLoto(uint8[] memory winningNumber) external onlyDev() {\r\n        require(winningNumber[0] >= 0);\r\n        require(winningNumber[1] >= 0);\r\n        require(winningNumber[2] >= 0);\r\n        require(winningNumber[3] >= 0);\r\n\r\n        require(winningNumber[0] < 10);\r\n        require(winningNumber[1] < 10);\r\n        require(winningNumber[2] < 10);\r\n        require(winningNumber[3] < 10);\r\n\r\n        require(lotoEnabled);\r\n\r\n\r\n        winum1 = winningNumber[0];\r\n        winum2 = winningNumber[1];\r\n        winum3 = winningNumber[2];\r\n        winum4 = winningNumber[3];\r\n\r\n        lotoEnabled = false;\r\n        buyingEnabled = false;\r\n        lotoID += 1;\r\n\r\n        determineWinners();\r\n        if (winners.length > 0) {\r\n            uint256 payedTotal = payoutRewards();\r\n            emit EndedLoto(payedTotal);\r\n        } else {\r\n            if (inu.balanceOf(address(this)) > 0) {\r\n                uint256 devR = inu.balanceOf(address(this)).div(100);\r\n                uint256 burnR = inu.balanceOf(address(this)).mul(4).div(100);\r\n                inu.transfer(devX, devR);\r\n\r\n                if (inu.balanceOf(address(this)) < burnR) {\r\n                    burnR = inu.balanceOf(address(this));\r\n                }\r\n                inu.transfer(\r\n                    address(0x000000000000000000000000000000000000dEaD),\r\n                    burnR\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function payoutRewards() internal onlyDev() returns(uint256) {\r\n        uint256 rank1 = 1;\r\n        uint256 rank2 = 1;\r\n        uint256 rank3 = 1;\r\n        uint256 rank4 = 1;\r\n\r\n        uint256 len = winners.length;\r\n        for (uint256 i = 1; i <= len; i++) {\r\n            uint8[] memory ranks = scanAddressTickets(winners[i-1],getTickets(winners[i-1]));\r\n            uint256 len2 = ranks.length;\r\n            for(uint256 j=1; j<= len2; j++){\r\n                if(ranks[j-1] == 1){\r\n                    rank1 += 1;\r\n                }\r\n                else if(ranks[j-1] == 2){\r\n                    rank2 += 1;\r\n                }\r\n                else if(ranks[j-1] == 3){\r\n                    rank3 += 1;\r\n                }\r\n                else if(ranks[j-1] == 4){\r\n                    rank4 += 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        uint256 rewardRank1 = inu.balanceOf(address(this)).mul(60).div(100);\r\n        uint256 rewardRank2 = inu.balanceOf(address(this)).mul(25).div(100);\r\n        uint256 rewardRank3 = inu.balanceOf(address(this)).mul(10).div(100);\r\n        uint256 rewardRank4 = inu.balanceOf(address(this)).mul(4).div(100);\r\n        uint256 rewardDev = inu\r\n        .balanceOf(address(this))\r\n        .sub(rewardRank1)\r\n        .sub(rewardRank2)\r\n        .sub(rewardRank3)\r\n        .sub(rewardRank4);\r\n\r\n        if (rank1 != 1) {\r\n            rewardRank1 = rewardRank1.div(rank1-1);\r\n        }\r\n        if (rank2 != 1) {\r\n            rewardRank2 = rewardRank2.div(rank2-1);\r\n        }\r\n        if (rank3 != 1) {\r\n            rewardRank3 = rewardRank3.div(rank3-1);\r\n        }\r\n        if (rank4 != 1) {\r\n            rewardRank4 = rewardRank4.div(rank4-1);\r\n        }\r\n\r\n        uint256 help = 0;\r\n        for (uint256 i = 1; i <= len; i++) {\r\n            uint8[] memory ranks = scanAddressTickets(winners[i-1],getTickets(winners[i-1]));\r\n            uint256 len2 = ranks.length;\r\n            for(uint256 j=1; j<= len2; j++){\r\n                if(ranks[j-1] == 1){\r\n                    if (rewardRank1 > inu.balanceOf(address(this))) {\r\n                        rewardRank1 = inu.balanceOf(address(this));\r\n                    }\r\n                    inu.transfer(winners[i-1], rewardRank1);\r\n                    help += rewardRank1;\r\n                }\r\n                else if(ranks[j-1] == 2){\r\n                   if (rewardRank2 > inu.balanceOf(address(this))) {\r\n                        rewardRank2 = inu.balanceOf(address(this));\r\n                    }\r\n                    inu.transfer(winners[i-1], rewardRank2);\r\n                    help += rewardRank2;\r\n                }\r\n                else if(ranks[j-1] == 3){\r\n                   if (rewardRank3 > inu.balanceOf(address(this))) {\r\n                        rewardRank3 = inu.balanceOf(address(this));\r\n                    }\r\n                    inu.transfer(winners[i-1], rewardRank3);\r\n                    help += rewardRank3;\r\n                }\r\n                else if(ranks[j-1] == 4){\r\n                    if (rewardRank4 > inu.balanceOf(address(this))) {\r\n                        rewardRank4 = inu.balanceOf(address(this));\r\n                    }\r\n                    inu.transfer(winners[i-1], rewardRank4);\r\n                    help += rewardRank4;\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (rewardDev > inu.balanceOf(address(this))) {\r\n            rewardDev = inu.balanceOf(address(this));\r\n        }\r\n        inu.transfer(devX, rewardDev);\r\n        help += rewardDev;\r\n        return help;\r\n    }\r\n\r\n    function determineWinners() internal onlyDev() {\r\n        uint256 len = players.length;\r\n        for (uint256 i = 1; i <= len; i++) {\r\n            string memory playerTicket = getTickets(players[i-1]);\r\n            uint8[] memory ranks = scanAddressTickets(players[i-1],playerTicket);\r\n            uint256 len2 = ranks.length;\r\n            for(uint256 j = 1; j<= len2; j++){\r\n                if(ranks[j-1] != 0){\r\n                    winners.push(players[i-1]);\r\n                    break;\r\n                } \r\n            }\r\n        }\r\n    }\r\n\r\n    function scanAddressTickets(address account,string memory ticket) internal view returns (uint8[] memory) {\r\n \r\n        bytes memory b = bytes(ticket);\r\n        uint256 len = ticketsCount[account].mul(5);\r\n        uint256 winTrack = 0;\r\n        \r\n        uint8[] memory ranks = new uint8[](len);\r\n        \r\n        if(len <= 4) return ranks;\r\n        \r\n        for(uint256 i=1; i<=len; i+=5){\r\n           uint8 num1 = toUint8(b[i-1]);\r\n           uint8 num2 = toUint8(b[i]);\r\n           uint8 num3 = toUint8(b[i+1]);\r\n           uint8 num4 = toUint8(b[i+2]);\r\n\r\n           uint8 res = scanTicket([num1,num2,num3,num4]);\r\n           \r\n           if(res != 0 && res != 5){\r\n            ranks[winTrack] = res;\r\n            winTrack += 1;\r\n           }\r\n        }\r\n\r\n        return ranks;\r\n    }\r\n\r\n    function scanTicket(uint8[4] memory ticket)\r\n        public\r\n        view\r\n        returns (uint8)\r\n    {\r\n        if(lotoEnabled) {\r\n            return 5;\r\n        }\r\n\r\n        if (ticket[0] == winum1 &&\r\n                ticket[1] == winum2 &&\r\n                ticket[2] == winum3 && ticket[3] == winum4) {\r\n            return 1;\r\n        } else if (\r\n            (ticket[0] == winum1 &&\r\n                ticket[1] == winum2 &&\r\n                ticket[2] == winum3)\r\n        ) {\r\n            return 2;\r\n        } else if (\r\n            (ticket[0] == winum1 &&\r\n                ticket[1] == winum2) ||\r\n            (ticket[1] == winum2 &&\r\n                ticket[2] == winum3) ||\r\n            (ticket[2] == winum3 && ticket[3] == winum4)\r\n        ) {\r\n            return 3;\r\n        } else if (\r\n            (ticket[0] == winum1) ||\r\n            (ticket[1] == winum2) ||\r\n            (ticket[2] == winum3) ||\r\n            (ticket[3] == winum4)\r\n        ) {\r\n            return 4;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function buyTicket(uint8[] memory numbers) internal {\r\n        require(inu.balanceOf(msg.sender) >= ticketPrice);\r\n        require(numbers[0] >= 0);\r\n        require(numbers[1] >= 0);\r\n        require(numbers[2] >= 0);\r\n        require(numbers[3] >= 0);\r\n\r\n        require(numbers[0] < 10);\r\n        require(numbers[1] < 10);\r\n        require(numbers[2] < 10);\r\n        require(numbers[3] < 10);\r\n\r\n        if(!isPlayer[msg.sender]) {\r\n            players.push(msg.sender);\r\n            isPlayer[msg.sender] = true;\r\n        }\r\n\r\n        string memory currentTickets = tickets[msg.sender];\r\n        tickets[msg.sender] = append(currentTickets,toString(numbers[0]),toString(numbers[1]),toString(numbers[2]),toString(numbers[3]));\r\n\r\n        emit BoughtTicket(msg.sender,numbers);\r\n    }\r\n    \r\n    function buyMultipleTickets(uint8[][] memory tickets_) public {\r\n        uint256 len = tickets_.length;\r\n        require(inu.balanceOf(msg.sender) >= ticketPrice.mul(len));\r\n        inu.transferFrom(msg.sender, address(this), ticketPrice.mul(len));\r\n        \r\n        for(uint256 i=1; i<= len;i++){\r\n            buyTicket(tickets_[i-1]);\r\n        }\r\n        numOfTickets += len;\r\n        ticketsCount[msg.sender] += len;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inu_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"devX_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8[]\",\"name\":\"numbers\",\"type\":\"uint8[]\"}],\"name\":\"BoughtTicket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payedOut\",\"type\":\"uint256\"}],\"name\":\"EndedLoto\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint8[][]\",\"name\":\"tickets_\",\"type\":\"uint8[][]\"}],\"name\":\"buyMultipleTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableBuying\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"winningNumber\",\"type\":\"uint8[]\"}],\"name\":\"disableLoto\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableLoto\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumPlayers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"getTickets\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWinningNumber\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inu\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotoEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotoID\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numOfTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[4]\",\"name\":\"ticket\",\"type\":\"uint8[4]\"}],\"name\":\"scanTicket\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winum1\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winum2\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winum3\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winum4\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Lottery","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000f29171d7bcdc464a0758cf3217fe83173772b900000000000000000000000028a782553c4b3f78991b41cb47ab4d78716ef738","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://740e90f0c2e82c90e236e4f6b1a89676afa6a7ef571df86000f1d084c1855bba"}]}