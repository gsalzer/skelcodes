{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\nB.PROTOCOL TERMS OF USE\r\n=======================\r\n\r\nTHE TERMS OF USE CONTAINED HEREIN (THESE “TERMS”) GOVERN YOUR USE OF B.PROTOCOL, WHICH IS A DECENTRALIZED PROTOCOL ON THE ETHEREUM BLOCKCHAIN (the “PROTOCOL”) THAT enables a backstop liquidity mechanism FOR DECENTRALIZED LENDING PLATFORMS (“DLPs”).  \r\nPLEASE READ THESE TERMS CAREFULLY AT https://github.com/backstop-protocol/Terms-and-Conditions, INCLUDING ALL DISCLAIMERS AND RISK FACTORS, BEFORE USING THE PROTOCOL. BY USING THE PROTOCOL, YOU ARE IRREVOCABLY CONSENTING TO BE BOUND BY THESE TERMS. \r\nIF YOU DO NOT AGREE TO ALL OF THESE TERMS, DO NOT USE THE PROTOCOL. YOUR RIGHT TO USE THE PROTOCOL IS SUBJECT AND DEPENDENT BY YOUR AGREEMENT TO ALL TERMS AND CONDITIONS SET FORTH HEREIN, WHICH AGREEMENT SHALL BE EVIDENCED BY YOUR USE OF THE PROTOCOL.\r\nMinors Prohibited: The Protocol is not directed to individuals under the age of eighteen (18) or the age of majority in your jurisdiction if the age of majority is greater. If you are under the age of eighteen or the age of majority (if greater), you are not authorized to access or use the Protocol. By using the Protocol, you represent and warrant that you are above such age.\r\n\r\nLicense; No Warranties; Limitation of Liability;\r\n(a) The software underlying the Protocol is licensed for use in accordance with the 3-clause BSD License, which can be accessed here: https://opensource.org/licenses/BSD-3-Clause.\r\n(b) THE PROTOCOL IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\", “WITH ALL FAULTS” and “AS AVAILABLE” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n(c) IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \r\n*/\r\n\r\n\r\n// Sources flattened with hardhat v2.5.0 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/GSN/Context.sol@v2.5.1\r\n\r\npragma solidity ^0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/ownership/Ownable.sol@v2.5.1\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/bprotocol/proxy/GnosisSafeProxy.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ninterface IProxy {\r\n    function masterCopy() external view returns (address);\r\n}\r\n\r\n/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.io>\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ncontract GnosisSafeProxy {\r\n\r\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\r\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\r\n    address internal masterCopy;\r\n\r\n    /// @dev Constructor function sets address of master copy contract.\r\n    /// @param _masterCopy Master copy address.\r\n    constructor(address _masterCopy)\r\n        public\r\n    {\r\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\r\n        masterCopy = _masterCopy;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\r\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\r\n                mstore(0, masterCopy)\r\n                return(0, 0x20)\r\n            }\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if eq(success, 0) { revert(0, returndatasize()) }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/bprotocol/interfaces/IAvatar.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract IERC20Avatar {\r\n    function transfer(address cToken, address dst, uint256 amount) external returns (bool);\r\n    function transferFrom(address cToken, address src, address dst, uint256 amount) external returns (bool);\r\n    function approve(address cToken, address spender, uint256 amount) public returns (bool);\r\n}\r\n\r\ncontract IAvatar is IERC20Avatar {\r\n    function initialize(address _registry, address comp, address compVoter) external;\r\n    function quit() external returns (bool);\r\n    function canUntop() public returns (bool);\r\n    function toppedUpCToken() external returns (address);\r\n    function toppedUpAmount() external returns (uint256);\r\n    function redeem(address cToken, uint256 redeemTokens, address payable userOrDelegatee) external returns (uint256);\r\n    function redeemUnderlying(address cToken, uint256 redeemAmount, address payable userOrDelegatee) external returns (uint256);\r\n    function borrow(address cToken, uint256 borrowAmount, address payable userOrDelegatee) external returns (uint256);\r\n    function borrowBalanceCurrent(address cToken) external returns (uint256);\r\n    function collectCToken(address cToken, address from, uint256 cTokenAmt) public;\r\n    function liquidateBorrow(uint repayAmount, address cTokenCollateral) external payable returns (uint256);\r\n\r\n    // Comptroller functions\r\n    function enterMarket(address cToken) external returns (uint256);\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);\r\n    function exitMarket(address cToken) external returns (uint256);\r\n    function claimComp() external;\r\n    function claimComp(address[] calldata bTokens) external;\r\n    function claimComp(address[] calldata bTokens, bool borrowers, bool suppliers) external;\r\n    function getAccountLiquidity() external view returns (uint err, uint liquidity, uint shortFall);\r\n}\r\n\r\n// Workaround for issue https://github.com/ethereum/solidity/issues/526\r\n// CEther\r\ncontract IAvatarCEther is IAvatar {\r\n    function mint() external payable;\r\n    function repayBorrow() external payable;\r\n    function repayBorrowBehalf(address borrower) external payable;\r\n}\r\n\r\n// CErc20\r\ncontract IAvatarCErc20 is IAvatar {\r\n    function mint(address cToken, uint256 mintAmount) external returns (uint256);\r\n    function repayBorrow(address cToken, uint256 repayAmount) external returns (uint256);\r\n    function repayBorrowBehalf(address cToken, address borrower, uint256 repayAmount) external returns (uint256);\r\n}\r\n\r\ncontract ICushion {\r\n    function liquidateBorrow(uint256 underlyingAmtToLiquidate, uint256 amtToDeductFromTopup, address cTokenCollateral) external payable returns (uint256);    \r\n    function canLiquidate() external returns (bool);\r\n    function untop(uint amount) external;\r\n    function toppedUpAmount() external returns (uint);\r\n    function remainingLiquidationAmount() external returns(uint);\r\n    function getMaxLiquidationAmount(address debtCToken) public returns (uint256);\r\n}\r\n\r\ncontract ICushionCErc20 is ICushion {\r\n    function topup(address cToken, uint256 topupAmount) external;\r\n}\r\n\r\ncontract ICushionCEther is ICushion {\r\n    function topup() external payable;\r\n}\r\n\r\n\r\n// File contracts/bprotocol/Registry.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n/**\r\n * @dev Registry contract to maintain Compound, BProtocol and avatar address.\r\n */\r\ncontract Registry is Ownable {\r\n\r\n    // Compound Contracts\r\n    address public comptroller;\r\n    address public comp;\r\n    address public cEther;\r\n\r\n    // BProtocol Contracts\r\n    address public pool;\r\n    address public score;\r\n    address public compVoter; // this will not be used\r\n    address public bComptroller;\r\n\r\n\r\n    // Avatar\r\n    address public avatarImpl;\r\n\r\n    // Owner => Avatar\r\n    mapping (address => address) public avatarOf;\r\n\r\n    // Avatar => Owner\r\n    mapping (address => address) public ownerOf;\r\n\r\n    address[] public avatars;\r\n\r\n    // An Avatar can have multiple Delegatee\r\n    // Avatar => Delegatee => bool\r\n    mapping (address => mapping(address => bool)) public delegate;\r\n\r\n    // dummy caller, for safer delegate and execute\r\n    DummyCaller public dummyCaller;\r\n\r\n    // (target, 4 bytes) => boolean. For each target address and function call, can avatar call it?\r\n    // this is to support upgradable features in compound\r\n    // calls that allow user to change collateral and debt size, and enter/exit market should not be listed\r\n    mapping (address => mapping(bytes4 => bool)) public whitelistedAvatarCalls;\r\n\r\n    event NewAvatar(address indexed avatar, address owner);\r\n    event Delegate(address indexed delegator, address avatar, address delegatee);\r\n    event RevokeDelegate(address indexed delegator, address avatar, address delegatee);\r\n    event NewPool(address oldPool, address newPool);\r\n    event NewScore(address oldScore, address newScore);\r\n    event AvatarCallWhitelisted(address target, bytes4 functionSig, bool whitelist);\r\n\r\n    constructor(\r\n        address _comptroller,\r\n        address _comp,\r\n        address _cEther,\r\n        address _pool,\r\n        address _bComptroller,\r\n        address _compVoter,\r\n        address _avatarImpl\r\n    )\r\n        public\r\n    {\r\n        comptroller = _comptroller;\r\n        comp = _comp;\r\n        cEther = _cEther;\r\n        pool = _pool;\r\n        bComptroller = _bComptroller;\r\n        compVoter = _compVoter;\r\n\r\n        avatarImpl = _avatarImpl;\r\n        dummyCaller = new DummyCaller();\r\n    }\r\n\r\n    function setPool(address newPool) external onlyOwner {\r\n        require(newPool != address(0), \"Registry: pool-address-is-zero\");\r\n        address oldPool = pool;\r\n        pool = newPool;\r\n        emit NewPool(oldPool, newPool);\r\n    }\r\n\r\n    function setScore(address newScore) external onlyOwner {\r\n        require(newScore != address(0), \"Registry: score-address-is-zero\");\r\n        address oldScore = score;\r\n        score = newScore;\r\n        emit NewScore(oldScore, newScore);\r\n    }\r\n\r\n    function setWhitelistAvatarCall(address target, bytes4 functionSig, bool list) external onlyOwner {\r\n        whitelistedAvatarCalls[target][functionSig] = list;\r\n        emit AvatarCallWhitelisted(target, functionSig, list);\r\n    }\r\n\r\n    function newAvatar() external returns (address) {\r\n        return _newAvatar(msg.sender);\r\n    }\r\n\r\n    function getAvatar(address _owner) public returns (address) {\r\n        require(_owner != address(0), \"Registry: owner-address-is-zero\");\r\n        address _avatar = avatarOf[_owner];\r\n        if(_avatar == address(0)) {\r\n            _avatar = _newAvatar(_owner);\r\n        }\r\n        return _avatar;\r\n    }\r\n\r\n    function delegateAvatar(address delegatee) public {\r\n        require(delegatee != address(0), \"Registry: delegatee-address-is-zero\");\r\n        address _avatar = avatarOf[msg.sender];\r\n        require(_avatar != address(0), \"Registry: avatar-not-found\");\r\n\r\n        delegate[_avatar][delegatee] = true;\r\n        emit Delegate(msg.sender, _avatar, delegatee);\r\n    }\r\n\r\n    function revokeDelegateAvatar(address delegatee) public {\r\n        address _avatar = avatarOf[msg.sender];\r\n        require(_avatar != address(0), \"Registry: avatar-not-found\");\r\n        require(delegate[_avatar][delegatee], \"Registry: not-delegated\");\r\n\r\n        delegate[_avatar][delegatee] = false;\r\n        emit RevokeDelegate(msg.sender, _avatar, delegatee);\r\n    }\r\n\r\n    function delegateAndExecuteOnce(address delegatee, address payable target, bytes calldata data) external payable {\r\n        // make sure there is an avatar\r\n        getAvatar(msg.sender);\r\n        delegateAvatar(delegatee);\r\n        dummyCaller.execute.value(msg.value)(target, data);\r\n        revokeDelegateAvatar(delegatee);\r\n    }\r\n\r\n    function _newAvatar(address _owner) internal returns (address) {\r\n        require(avatarOf[_owner] == address(0), \"Registry: avatar-exits-for-owner\");\r\n        // _owner should not be an avatar address\r\n        require(ownerOf[_owner] == address(0), \"Registry: cannot-create-an-avatar-of-avatar\");\r\n\r\n        // Deploy GnosisSafeProxy with the Avatar contract as logic contract\r\n        address _avatar = _deployAvatarProxy(_owner);\r\n        // Initialize Avatar\r\n        IAvatar(_avatar).initialize(address(this), comp, compVoter);\r\n\r\n        avatarOf[_owner] = _avatar;\r\n        ownerOf[_avatar] = _owner;\r\n        avatars.push(_avatar);\r\n        emit NewAvatar(_avatar, _owner);\r\n        return _avatar;\r\n    }\r\n\r\n    function _deployAvatarProxy(address _owner) internal returns (address proxy) {\r\n        bytes32 salt = keccak256(abi.encodePacked(_owner));\r\n        bytes memory proxyCode = type(GnosisSafeProxy).creationCode;\r\n        bytes memory deploymentData = abi.encodePacked(proxyCode, uint256(avatarImpl));\r\n\r\n        assembly {\r\n            proxy := create2(0, add(deploymentData, 0x20), mload(deploymentData), salt)\r\n            if iszero(extcodesize(proxy)) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    function avatarLength() external view returns (uint256) {\r\n        return avatars.length;\r\n    }\r\n\r\n    function avatarList() external view returns (address[] memory) {\r\n        return avatars;\r\n    }\r\n\r\n    function doesAvatarExist(address _avatar) public view returns (bool) {\r\n        return ownerOf[_avatar] != address(0);\r\n    }\r\n\r\n    function doesAvatarExistFor(address _owner) public view returns (bool) {\r\n        return avatarOf[_owner] != address(0);\r\n    }\r\n}\r\n\r\ncontract DummyCaller {\r\n    function execute(address target, bytes calldata data) external payable {\r\n        (bool succ, bytes memory err) = target.call.value(msg.value)(data);\r\n        require(succ, string(err));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/bprotocol/interfaces/IRegistry.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\ninterface IRegistry {\r\n\r\n    // Ownable\r\n    function transferOwnership(address newOwner) external;\r\n\r\n    // Compound contracts\r\n    function comp() external view returns (address);\r\n    function comptroller() external view returns (address);\r\n    function cEther() external view returns (address);\r\n\r\n    // B.Protocol contracts\r\n    function bComptroller() external view returns (address);\r\n    function score() external view returns (address);\r\n    function pool() external view returns (address);\r\n\r\n    // Avatar functions\r\n    function delegate(address avatar, address delegatee) external view returns (bool);\r\n    function doesAvatarExist(address avatar) external view returns (bool);\r\n    function doesAvatarExistFor(address owner) external view returns (bool);\r\n    function ownerOf(address avatar) external view returns (address);\r\n    function avatarOf(address owner) external view returns (address);\r\n    function newAvatar() external returns (address);\r\n    function getAvatar(address owner) external returns (address);\r\n    // avatar whitelisted calls\r\n    function whitelistedAvatarCalls(address target, bytes4 functionSig) external view returns(bool);\r\n\r\n    function setPool(address newPool) external;\r\n    function setScore(address newScore) external;\r\n    function setWhitelistAvatarCall(address target, bytes4 functionSig, bool list) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v2.5.1\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/bprotocol/interfaces/CTokenInterfaces.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract CTokenInterface {\r\n    /* ERC20 */\r\n    function transfer(address dst, uint amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function totalSupply() external view returns (uint256);\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n\r\n    /* User Interface */\r\n    function isCToken() external view returns (bool);\r\n    function underlying() external view returns (IERC20);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function borrowBalanceStored(address account) public view returns (uint);\r\n    function exchangeRateCurrent() public returns (uint);\r\n    function exchangeRateStored() public view returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function accrueInterest() public returns (uint);\r\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);\r\n\r\n}\r\n\r\ncontract ICToken is CTokenInterface {\r\n\r\n    /* User Interface */\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n}\r\n\r\n// Workaround for issue https://github.com/ethereum/solidity/issues/526\r\n// Defined separate contract as `mint()` override with `.value()` has issues\r\ncontract ICErc20 is ICToken {\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\r\n    function liquidateBorrow(address borrower, uint repayAmount, address cTokenCollateral) external returns (uint);\r\n}\r\n\r\ncontract ICEther is ICToken {\r\n    function mint() external payable;\r\n    function repayBorrow() external payable;\r\n    function repayBorrowBehalf(address borrower) external payable;\r\n    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\r\n}\r\n\r\ncontract IPriceOracle {\r\n    /**\r\n      * @notice Get the underlying price of a cToken asset\r\n      * @param cToken The cToken to get the underlying price of\r\n      * @return The underlying asset price mantissa (scaled by 1e18).\r\n      *  Zero means the price is unavailable.\r\n      */\r\n    function getUnderlyingPrice(CTokenInterface cToken) external view returns (uint);\r\n}\r\n\r\n\r\n// File contracts/bprotocol/lib/CarefulMath.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/**\r\n  * @title Careful Math\r\n  * @author Compound\r\n  * @notice COPY TAKEN FROM COMPOUND FINANCE\r\n  * @notice Derived from OpenZeppelin's SafeMath library\r\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n  */\r\ncontract CarefulMath {\r\n\r\n    /**\r\n     * @dev Possible error codes that we can return\r\n     */\r\n    enum MathError {\r\n        NO_ERROR,\r\n        DIVISION_BY_ZERO,\r\n        INTEGER_OVERFLOW,\r\n        INTEGER_UNDERFLOW\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, returns an error on overflow.\r\n    */\r\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (a == 0) {\r\n            return (MathError.NO_ERROR, 0);\r\n        }\r\n\r\n        uint c = a * b;\r\n\r\n        if (c / a != b) {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        } else {\r\n            return (MathError.NO_ERROR, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b == 0) {\r\n            return (MathError.DIVISION_BY_ZERO, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, a / b);\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b <= a) {\r\n            return (MathError.NO_ERROR, a - b);\r\n        } else {\r\n            return (MathError.INTEGER_UNDERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, returns an error on overflow.\r\n    */\r\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        uint c = a + b;\r\n\r\n        if (c >= a) {\r\n            return (MathError.NO_ERROR, c);\r\n        } else {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev add a and b and then subtract c\r\n    */\r\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\r\n        (MathError err0, uint sum) = addUInt(a, b);\r\n\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return subUInt(sum, c);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/bprotocol/lib/Exponential.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/**\r\n * @title Exponential module for storing fixed-precision decimals\r\n * @author Compound\r\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\r\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\r\n *         `Exp({mantissa: 5100000000000000000})`.\r\n */\r\ncontract Exponential is CarefulMath {\r\n    uint constant expScale = 1e18;\r\n    uint constant doubleScale = 1e36;\r\n    uint constant halfExpScale = expScale/2;\r\n    uint constant mantissaOne = expScale;\r\n\r\n    struct Exp {\r\n        uint mantissa;\r\n    }\r\n\r\n    struct Double {\r\n        uint mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates an exponential from numerator and denominator values.\r\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\r\n     *            or if `denom` is zero.\r\n     */\r\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\r\n     */\r\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(product));\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, returning a new Exp.\r\n     */\r\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\r\n        /*\r\n          We are doing this as:\r\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\r\n\r\n          How it works:\r\n          Exp = a / b;\r\n          Scalar = s;\r\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\r\n        */\r\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials, returning a new exponential.\r\n     */\r\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n\r\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // We add half the scale before dividing so that we get rounding instead of truncation.\r\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\r\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\r\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\r\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\r\n        assert(err2 == MathError.NO_ERROR);\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\r\n     */\r\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\r\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Divides two exponentials, returning a new exponential.\r\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\r\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\r\n     */\r\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        return getExp(a.mantissa, b.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Truncates the given exp to a whole number value.\r\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\r\n     */\r\n    function truncate(Exp memory exp) pure internal returns (uint) {\r\n        // Note: We are not using careful math here as we're performing a division that cannot fail\r\n        return exp.mantissa / expScale;\r\n    }\r\n\r\n\r\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\r\n        require(n < 2**224, errorMessage);\r\n        return uint224(n);\r\n    }\r\n\r\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(uint a, uint b) pure internal returns (uint) {\r\n        return add_(a, b, \"addition overflow\");\r\n    }\r\n\r\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(uint a, uint b) pure internal returns (uint) {\r\n        return sub_(a, b, \"subtraction underflow\");\r\n    }\r\n\r\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\r\n    }\r\n\r\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / expScale;\r\n    }\r\n\r\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\r\n    }\r\n\r\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / doubleScale;\r\n    }\r\n\r\n    function mul_(uint a, uint b) pure internal returns (uint) {\r\n        return mul_(a, b, \"multiplication overflow\");\r\n    }\r\n\r\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        require(c / a == b, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, expScale), b.mantissa);\r\n    }\r\n\r\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Double memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, doubleScale), b.mantissa);\r\n    }\r\n\r\n    function div_(uint a, uint b) pure internal returns (uint) {\r\n        return div_(a, b, \"divide by zero\");\r\n    }\r\n\r\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\r\n    }\r\n\r\n    // New functions added by BProtocol\r\n    // =================================\r\n\r\n    function mulTrucate(uint a, uint b) internal pure returns (uint) {\r\n        return mul_(a, b) / expScale;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/math/SafeMath.sol@v2.5.1\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v2.5.1\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/SafeERC20.sol@v2.5.1\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/bprotocol/btoken/AbsBToken.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n// Interface\r\n\r\n\r\n\r\n// Libs\r\n\r\n\r\n\r\n/**\r\n * @title AbsBToken is BProtocol token contract which represents the Compound's CToken\r\n */\r\ncontract AbsBToken is Exponential {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // BProtocol Registry contract\r\n    IRegistry public registry;\r\n    // Compound's CToken this BToken contract is tied to\r\n    address public cToken;\r\n\r\n    modifier onlyDelegatee(address _avatar) {\r\n        // `msg.sender` is delegatee\r\n        require(registry.delegate(_avatar, msg.sender), \"BToken: delegatee-not-authorized\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _registry, address _cToken) internal {\r\n        registry = IRegistry(_registry);\r\n        cToken = _cToken;\r\n    }\r\n\r\n    function _myAvatar() internal returns (address) {\r\n        return registry.getAvatar(msg.sender);\r\n    }\r\n\r\n    // CEther / CErc20\r\n    // ===============\r\n    function borrowBalanceCurrent(address account) external returns (uint256) {\r\n        address _avatar = registry.getAvatar(account);\r\n        return IAvatar(_avatar).borrowBalanceCurrent(cToken);\r\n    }\r\n\r\n    // redeem()\r\n    function redeem(uint256 redeemTokens) external returns (uint256) {\r\n        return _redeem(_myAvatar(), redeemTokens);\r\n    }\r\n\r\n    function redeemOnAvatar(address _avatar, uint256 redeemTokens) external onlyDelegatee(_avatar) returns (uint256) {\r\n        return _redeem(_avatar, redeemTokens);\r\n    }\r\n\r\n    function _redeem(address _avatar, uint256 redeemTokens) internal returns (uint256) {\r\n        uint256 result = IAvatar(_avatar).redeem(cToken, redeemTokens, msg.sender);\r\n        require(result == 0, \"BToken: redeem-failed\");\r\n        return result;\r\n    }\r\n\r\n    // redeemUnderlying()\r\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {\r\n        return _redeemUnderlying(_myAvatar(), redeemAmount);\r\n    }\r\n\r\n    function redeemUnderlyingOnAvatar(address _avatar, uint256 redeemAmount) external onlyDelegatee(_avatar) returns (uint256) {\r\n        return _redeemUnderlying(_avatar, redeemAmount);\r\n    }\r\n\r\n    function _redeemUnderlying(address _avatar, uint256 redeemAmount) internal returns (uint256) {\r\n        uint256 result = IAvatar(_avatar).redeemUnderlying(cToken, redeemAmount, msg.sender);\r\n        require(result == 0, \"BToken: redeemUnderlying-failed\");\r\n        return result;\r\n    }\r\n\r\n    // borrow()\r\n    function borrow(uint256 borrowAmount) external returns (uint256) {\r\n        return _borrow(_myAvatar(), borrowAmount);\r\n    }\r\n\r\n    function borrowOnAvatar(address _avatar, uint256 borrowAmount) external onlyDelegatee(_avatar) returns (uint256) {\r\n        return _borrow(_avatar, borrowAmount);\r\n    }\r\n\r\n    function _borrow(address _avatar, uint256 borrowAmount) internal returns (uint256) {\r\n        uint256 result = IAvatar(_avatar).borrow(cToken, borrowAmount, msg.sender);\r\n        require(result == 0, \"BToken: borrow-failed\");\r\n        return result;\r\n    }\r\n\r\n    // other functions\r\n    function exchangeRateCurrent() public returns (uint256) {\r\n        return ICToken(cToken).exchangeRateCurrent();\r\n    }\r\n\r\n    function exchangeRateStored() public view returns (uint) {\r\n        return ICToken(cToken).exchangeRateStored();\r\n    }\r\n\r\n    // IERC20\r\n    // =======\r\n    // transfer()\r\n    function transfer(address dst, uint256 amount) external returns (bool) {\r\n        return _transfer(_myAvatar(), dst, amount);\r\n    }\r\n\r\n    function transferOnAvatar(address _avatar, address dst, uint256 amount) external onlyDelegatee(_avatar) returns (bool) {\r\n        return _transfer(_avatar, dst, amount);\r\n    }\r\n\r\n    function _transfer(address _avatar, address dst, uint256 amount) internal returns (bool) {\r\n        bool result = IAvatar(_avatar).transfer(cToken, dst, amount);\r\n        require(result, \"BToken: transfer-failed\");\r\n        return result;\r\n    }\r\n\r\n    // transferFrom()\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\r\n        return _transferFrom(_myAvatar(), src, dst, amount);\r\n    }\r\n\r\n    function transferFromOnAvatar(address _avatar, address src, address dst, uint256 amount) external onlyDelegatee(_avatar) returns (bool) {\r\n        return _transferFrom(_avatar, src, dst, amount);\r\n    }\r\n\r\n    function _transferFrom(address _avatar, address src, address dst, uint256 amount) internal returns (bool) {\r\n        bool result = IAvatar(_avatar).transferFrom(cToken, src, dst, amount);\r\n        require(result, \"BToken: transferFrom-failed\");\r\n        return result;\r\n    }\r\n\r\n    // approve()\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        return IAvatar(_myAvatar()).approve(cToken, spender, amount);\r\n    }\r\n\r\n    function approveOnAvatar(address _avatar, address spender, uint256 amount) public onlyDelegatee(_avatar) returns (bool) {\r\n        return IAvatar(_avatar).approve(cToken, spender, amount);\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        address spenderAvatar = registry.avatarOf(spender);\r\n        if(spenderAvatar == address(0)) return 0;\r\n        return ICToken(cToken).allowance(registry.avatarOf(owner), spenderAvatar);\r\n    }\r\n\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        address avatar = registry.avatarOf(owner);\r\n        if(avatar == address(0)) return 0;\r\n        return ICToken(cToken).balanceOf(avatar);\r\n    }\r\n\r\n    function balanceOfUnderlying(address owner) external returns (uint) {\r\n        address avatar = registry.avatarOf(owner);\r\n        if(avatar == address(0)) return 0;\r\n        return ICToken(cToken).balanceOfUnderlying(avatar);\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return ICToken(cToken).name();\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return ICToken(cToken).symbol();\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return ICToken(cToken).decimals();\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return ICToken(cToken).totalSupply();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/bprotocol/btoken/BErc20.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\ncontract BErc20 is AbsBToken {\r\n\r\n    IERC20 public underlying;\r\n\r\n    constructor(\r\n        address _registry,\r\n        address _cToken\r\n    ) public AbsBToken(_registry, _cToken) {\r\n        underlying = ICToken(cToken).underlying();\r\n    }\r\n\r\n    // mint()\r\n    function mint(uint256 mintAmount) external returns (uint256) {\r\n        return _mint(_myAvatar(), mintAmount);\r\n    }\r\n\r\n    function mintOnAvatar(address _avatar, uint256 mintAmount) external onlyDelegatee(_avatar) returns (uint256) {\r\n        return _mint(_avatar, mintAmount);\r\n    }\r\n\r\n    function _mint(address _avatar, uint256 mintAmount) internal returns (uint256) {\r\n        underlying.safeTransferFrom(msg.sender, _avatar, mintAmount);\r\n        uint256 result = IAvatarCErc20(_avatar).mint(cToken, mintAmount);\r\n        require(result == 0, \"BErc20: mint-failed\");\r\n        return result;\r\n    }\r\n\r\n    // repayBorrow()\r\n    function repayBorrow(uint256 repayAmount) external returns (uint256) {\r\n        return _repayBorrow(_myAvatar(), repayAmount);\r\n    }\r\n\r\n    function repayBorrowOnAvatar(address _avatar, uint256 repayAmount) external onlyDelegatee(_avatar) returns (uint256) {\r\n        return _repayBorrow(_avatar, repayAmount);\r\n    }\r\n\r\n    function _repayBorrow(address _avatar, uint256 repayAmount) internal returns (uint256) {\r\n        uint256 actualRepayAmount = repayAmount;\r\n        if(repayAmount == uint256(-1)) {\r\n            actualRepayAmount = IAvatarCErc20(_avatar).borrowBalanceCurrent(cToken);\r\n        }\r\n        underlying.safeTransferFrom(msg.sender, _avatar, actualRepayAmount);\r\n        uint256 result = IAvatarCErc20(_avatar).repayBorrow(cToken, actualRepayAmount);\r\n        require(result == 0, \"BErc20: repayBorrow-failed\");\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/bprotocol/btoken/BEther.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\ncontract BEther is AbsBToken {\r\n\r\n    constructor(\r\n        address _registry,\r\n        address _cToken\r\n    ) public AbsBToken(_registry, _cToken) {}\r\n\r\n    function _myAvatarCEther() internal returns (IAvatarCEther) {\r\n        return IAvatarCEther(address(_myAvatar()));\r\n    }\r\n\r\n    // mint()\r\n    function mint() external payable {\r\n        // CEther calls requireNoError() to ensure no failures\r\n        _myAvatarCEther().mint.value(msg.value)();\r\n    }\r\n\r\n    function mintOnAvatar(address _avatar) external onlyDelegatee(_avatar) payable {\r\n        // CEther calls requireNoError() to ensure no failures\r\n        IAvatarCEther(_avatar).mint.value(msg.value)();\r\n    }\r\n\r\n    // repayBorrow()\r\n    function repayBorrow() external payable {\r\n        // CEther calls requireNoError() to ensure no failures\r\n        _myAvatarCEther().repayBorrow.value(msg.value)();\r\n    }\r\n\r\n    function repayBorrowOnAvatar(address _avatar) external onlyDelegatee(_avatar) payable {\r\n        // CEther calls requireNoError() to ensure no failures\r\n        IAvatarCEther(_avatar).repayBorrow.value(msg.value)();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/bprotocol/interfaces/IComptroller.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ninterface IComptroller {\r\n\r\n    // ComptrollerLensInterface.sol\r\n    // =============================\r\n    function markets(address) external view returns (bool, uint);\r\n    function oracle() external view returns (address);\r\n    function getAccountLiquidity(address) external view returns (uint, uint, uint);\r\n    function getAssetsIn(address) external view returns (address[] memory);\r\n    function compAccrued(address) external view returns (uint);\r\n    // Claim all the COMP accrued by holder in all markets\r\n    function claimComp(address holder) external;\r\n    // Claim all the COMP accrued by holder in specific markets\r\n    function claimComp(address holder, address[] calldata cTokens) external;\r\n    function claimComp(address[] calldata holders, address[] calldata cTokens, bool borrowers, bool suppliers) external;\r\n\r\n    // Public storage defined in Comptroller contract\r\n    // ===============================================\r\n    function checkMembership(address account, address cToken) external view returns (bool);\r\n    function closeFactorMantissa() external returns (uint256);\r\n    function liquidationIncentiveMantissa() external returns (uint256);\r\n\r\n\r\n\r\n    // Public/external functions defined in Comptroller contract\r\n    // ==========================================================\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cToken) external returns (uint);\r\n\r\n    function mintAllowed(address cToken, address minter, uint mintAmount) external returns (uint);\r\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint);\r\n\r\n    function getAllMarkets() external view returns (address[] memory);\r\n\r\n    function liquidateCalculateSeizeTokens(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        uint actualRepayAmount) external view returns (uint, uint);\r\n\r\n    function compBorrowState(address cToken) external returns (uint224, uint32);\r\n    function compSupplyState(address cToken) external returns (uint224, uint32);\r\n}\r\n\r\n\r\n// File contracts/bprotocol/BComptroller.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract BComptroller {\r\n\r\n    IComptroller public comptroller;\r\n\r\n    IRegistry public registry;\r\n\r\n    // CToken => BToken\r\n    mapping(address => address) public c2b;\r\n\r\n    // BToken => CToken\r\n    mapping(address => address) public b2c;\r\n\r\n    event NewBToken(address indexed cToken, address bToken);\r\n\r\n    modifier onlyDelegatee(IAvatar _avatar) {\r\n        // `msg.sender` is delegatee\r\n        require(registry.delegate(address(_avatar), msg.sender), \"BComptroller: delegatee-not-authorized\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _comptroller) public {\r\n        comptroller = IComptroller(_comptroller);\r\n    }\r\n\r\n    function setRegistry(address _registry) public {\r\n        require(address(registry) == address(0), \"BComptroller: registry-already-set\");\r\n        registry = IRegistry(_registry);\r\n    }\r\n\r\n    function newBToken(address cToken) external returns (address) {\r\n        require(c2b[cToken] == address(0), \"BComptroller: BToken-already-exists\");\r\n        (bool isListed,) = comptroller.markets(cToken);\r\n        require(isListed, \"BComptroller: cToken-not-listed-on-compound\");\r\n\r\n        bool is_cETH = cToken == registry.cEther();\r\n        address bToken;\r\n        if(is_cETH) {\r\n            bToken = address(new BEther(address(registry), cToken));\r\n        } else {\r\n            bToken = address(new BErc20(address(registry), cToken));\r\n        }\r\n\r\n        c2b[cToken] = bToken;\r\n        b2c[bToken] = cToken;\r\n        emit NewBToken(cToken, bToken);\r\n        return bToken;\r\n    }\r\n\r\n    function isBToken(address bToken) public view returns (bool) {\r\n        return b2c[bToken] != address(0);\r\n    }\r\n\r\n    function enterMarket(address bToken) external returns (uint256) {\r\n        IAvatar avatar = IAvatar(registry.getAvatar(msg.sender));\r\n        return _enterMarket(avatar, bToken);\r\n    }\r\n\r\n    function enterMarketOnAvatar(IAvatar avatar, address bToken) external onlyDelegatee(avatar) returns (uint256) {\r\n        return _enterMarket(avatar, bToken);\r\n    }\r\n\r\n    function _enterMarket(IAvatar avatar, address bToken) internal returns (uint256) {\r\n        require(b2c[bToken] != address(0), \"BComptroller: CToken-not-exist-for-bToken\");\r\n        return avatar.enterMarket(bToken);\r\n    }\r\n\r\n    function enterMarkets(address[] calldata bTokens) external returns (uint256[] memory) {\r\n        IAvatar avatar = IAvatar(registry.getAvatar(msg.sender));\r\n        return _enterMarkets(avatar, bTokens);\r\n    }\r\n\r\n    function enterMarketsOnAvatar(IAvatar avatar, address[] calldata bTokens) external onlyDelegatee(avatar) returns (uint256[] memory) {\r\n        return _enterMarkets(avatar, bTokens);\r\n    }\r\n\r\n    function _enterMarkets(IAvatar avatar, address[] memory bTokens) internal returns (uint256[] memory) {\r\n        for(uint i = 0; i < bTokens.length; i++) {\r\n            require(b2c[bTokens[i]] != address(0), \"BComptroller: CToken-not-exist-for-bToken\");\r\n        }\r\n        return avatar.enterMarkets(bTokens);\r\n    }\r\n\r\n    function exitMarket(address bToken) external returns (uint256) {\r\n        IAvatar avatar = IAvatar(registry.getAvatar(msg.sender));\r\n        return avatar.exitMarket(bToken);\r\n    }\r\n\r\n    function exitMarketOnAvatar(IAvatar avatar, address bToken) external onlyDelegatee(avatar) returns (uint256) {\r\n        return avatar.exitMarket(bToken);\r\n    }\r\n\r\n    function getAccountLiquidity(address account) external view returns (uint err, uint liquidity, uint shortFall) {\r\n        IAvatar avatar = IAvatar(registry.avatarOf(account));\r\n\r\n        if(avatar == IAvatar(0)) return (0, 0, 0);\r\n        \r\n        return avatar.getAccountLiquidity();\r\n    }\r\n\r\n    function claimComp(address holder) external {\r\n        IAvatar avatar = IAvatar(registry.getAvatar(holder));\r\n        avatar.claimComp();\r\n    }\r\n\r\n    function claimComp(address holder, address[] calldata bTokens) external {\r\n        IAvatar avatar = IAvatar(registry.getAvatar(holder));\r\n        avatar.claimComp(bTokens);\r\n    }\r\n\r\n    function claimComp(\r\n        address[] calldata holders,\r\n        address[] calldata bTokens,\r\n        bool borrowers,\r\n        bool suppliers\r\n    )\r\n        external\r\n    {\r\n        for(uint256 i = 0; i < holders.length; i++) {\r\n            IAvatar avatar = IAvatar(registry.getAvatar(holders[i]));\r\n            avatar.claimComp(bTokens, borrowers, suppliers);\r\n        }\r\n    }\r\n\r\n    function oracle() external view returns (address) {\r\n        return comptroller.oracle();\r\n    }\r\n\r\n    function getAllMarkets() external view returns (address[] memory) {\r\n        return comptroller.getAllMarkets();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/bprotocol/interfaces/IBToken.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ninterface IBToken {\r\n    function cToken() external view returns (address);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n}\r\n\r\n\r\n// File contracts/bprotocol/interfaces/IUniswapAnchoredView.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ninterface IUniswapAnchoredView {\r\n    function postPrices(bytes[] calldata messages, bytes[] calldata signatures, string[] calldata symbols) external;\r\n    function price(string calldata symbol) external view returns (uint);\r\n    function getUnderlyingPrice(address cToken) external view returns (uint);\r\n}\r\n\r\n\r\n// File contracts/bprotocol/interfaces/IBComptroller.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ninterface IBComptroller {\r\n    function isCToken(address cToken) external view returns (bool);\r\n    function isBToken(address bToken) external view returns (bool);\r\n    function c2b(address cToken) external view returns (address);\r\n    function b2c(address bToken) external view returns (address);\r\n}\r\n\r\n\r\n// File contracts/bprotocol/Pool.sol\r\n\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pool contract to manage the pool of member's fund\r\n */\r\ncontract Pool is Exponential, Ownable {\r\n    using SafeERC20 for IERC20;\r\n    address internal constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    IComptroller public comptroller;\r\n    IBComptroller public bComptroller;\r\n    IRegistry public registry;\r\n    address public jar;\r\n    address public cEther;\r\n    address[] public members;\r\n    // member share profit params\r\n    uint public shareNumerator;\r\n    uint public shareDenominator;\r\n    // member => underlying => amount\r\n    mapping(address => mapping(address => uint)) public balance;\r\n    // member => underlying => amount\r\n    mapping(address => mapping(address => uint)) public topupBalance;\r\n    // avatar => TopupInfo\r\n    mapping(address => TopupInfo) public topped;\r\n\r\n    // bToken => threshold\r\n    mapping(address => uint) public minSharingThreshold; // debt above this size will be shared\r\n    uint public minTopupBps = 250; // 2.5%\r\n    uint public holdingTime = 5 hours; // after 5 hours, someone else can topup instead\r\n    uint public selectionDuration = 60 minutes;  // member selection duration for round robin, default 60 mins\r\n\r\n    struct MemberTopupInfo {\r\n        uint expire;        // after expire time, other member can topup. relevant only if small\r\n        uint amountTopped;  // amount of underlying tokens toppedUp\r\n        uint amountLiquidated; // how much was already liquidated\r\n    }\r\n\r\n    struct TopupInfo {\r\n        mapping(address => MemberTopupInfo) memberInfo; // info per member\r\n        uint debtToLiquidatePerMember; // total debt avail to liquidate\r\n        address cToken;          // underlying debt cToken address\r\n    }\r\n\r\n    function getMemberTopupInfo(\r\n        address user,\r\n        address member\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            uint expire,\r\n            uint amountTopped,\r\n            uint amountLiquidated\r\n        )\r\n    {\r\n        address avatar = registry.avatarOf(user);\r\n        MemberTopupInfo memory memberInfo = topped[avatar].memberInfo[member];\r\n        expire = memberInfo.expire;\r\n        amountTopped = memberInfo.amountTopped;\r\n        amountLiquidated = memberInfo.amountLiquidated;\r\n    }\r\n\r\n    function getDebtTopupInfo(address user, address bTokenDebt) public /* view */ returns(uint minTopup, uint maxTopup, bool isSmall) {\r\n        uint debt = IBToken(bTokenDebt).borrowBalanceCurrent(user);\r\n        minTopup = mul_(debt, minTopupBps) / 10000;\r\n        maxTopup = debt / members.length;\r\n        isSmall = debt < minSharingThreshold[bTokenDebt];\r\n    }\r\n\r\n    function untop(address user, uint underlyingAmount) public onlyMember {\r\n        _untop(msg.sender, user, underlyingAmount);\r\n    }\r\n\r\n    function _untopOnBehalf(address member, address user, uint underlyingAmount) internal {\r\n        _untop(member, user, underlyingAmount);\r\n    }\r\n\r\n    function _untop(address member, address user, uint underlyingAmount) internal {\r\n        require(underlyingAmount > 0, \"Pool: amount-is-zero\");\r\n        address avatar = registry.avatarOf(user);\r\n        TopupInfo storage info = topped[avatar];\r\n\r\n        address bToken = bComptroller.c2b(info.cToken);\r\n\r\n        MemberTopupInfo storage memberInfo = info.memberInfo[member];\r\n        // cannot untop more than topped up amount\r\n        require(memberInfo.amountTopped >= underlyingAmount, \"Pool: amount-too-big\");\r\n        require(ICushion(avatar).remainingLiquidationAmount() == 0, \"Pool: cannot-untop-in-liquidation\");\r\n\r\n        (uint minTopup,,) = getDebtTopupInfo(user, bToken);\r\n\r\n        require(\r\n            memberInfo.amountTopped == underlyingAmount ||\r\n            sub_(memberInfo.amountTopped, underlyingAmount) >= minTopup,\r\n            \"Pool: invalid-amount\"\r\n        );\r\n\r\n        if(ICushion(avatar).toppedUpAmount() > 0) ICushion(avatar).untop(underlyingAmount);\r\n        address underlying = _getUnderlying(info.cToken);\r\n        balance[member][underlying] = add_(balance[member][underlying], underlyingAmount);\r\n        topupBalance[member][underlying] = sub_(topupBalance[member][underlying], underlyingAmount);\r\n\r\n        memberInfo.amountTopped = 0;\r\n        memberInfo.expire = 0;\r\n    }\r\n\r\n    function smallTopupWinner(address avatar) public view returns(address) {\r\n        uint chosen = uint(keccak256(abi.encodePacked(avatar, now / selectionDuration))) % members.length;\r\n        return members[chosen];\r\n    }\r\n\r\n    function topup(address user, address bToken, uint amount, bool resetApprove) external onlyMember {\r\n        address avatar = registry.avatarOf(user);\r\n        address cToken = bComptroller.b2c(bToken);\r\n        (uint minTopup, uint maxTopup, bool small) = getDebtTopupInfo(user, bToken);\r\n\r\n        address underlying = _getUnderlying(cToken);\r\n        uint memberBalance = balance[msg.sender][underlying];\r\n\r\n        require(memberBalance >= amount, \"Pool: topup-insufficient-balance\");\r\n        require(ICushion(avatar).remainingLiquidationAmount() == 0, \"Pool: cannot-topup-in-liquidation\");\r\n\r\n        TopupInfo storage info = topped[avatar];\r\n        _untopOnMembers(user, avatar, cToken, small);\r\n\r\n        MemberTopupInfo storage memberInfo = info.memberInfo[msg.sender];\r\n        require(add_(amount, memberInfo.amountTopped) >= minTopup, \"Pool: topup-amount-small\");\r\n        require(add_(amount, memberInfo.amountTopped) <= maxTopup, \"Pool: topup-amount-big\");\r\n\r\n        // For first topup skip this check as `expire = 0`\r\n        // From next topup, check for turn of msg.sender (new member)\r\n        if(small && memberInfo.expire != 0 && memberInfo.expire <= now) {\r\n            require(smallTopupWinner(avatar) == msg.sender, \"Pool: topup-not-your-turn\");\r\n        }\r\n\r\n        // topup is valid\r\n        balance[msg.sender][underlying] = sub_(memberBalance, amount);\r\n        topupBalance[msg.sender][underlying] = add_(topupBalance[msg.sender][underlying], amount);\r\n\r\n        if(small && memberInfo.expire <= now) {\r\n            memberInfo.expire = add_(now, holdingTime);\r\n        }\r\n\r\n        memberInfo.amountTopped = add_(memberInfo.amountTopped, amount);\r\n        // in all the below, as sload will soon cost 2k gas, we use sstore without\r\n        // checking if the value really changed\r\n        memberInfo.amountLiquidated = 0;\r\n        info.debtToLiquidatePerMember = 0;\r\n        info.cToken = cToken;\r\n\r\n        if(_isCEther(cToken)) {\r\n            ICushionCEther(avatar).topup.value(amount)();\r\n        } else {\r\n            if(resetApprove) IERC20(underlying).safeApprove(avatar, 0);\r\n            IERC20(underlying).safeApprove(avatar, amount);\r\n            ICushionCErc20(avatar).topup(cToken, amount);\r\n        }\r\n    }\r\n\r\n    // created this function to avoid stack too deep error\r\n    function _untopOnMembers(address user, address avatar, address cToken, bool small) internal {\r\n        uint realCushion = ICushion(avatar).toppedUpAmount();\r\n        TopupInfo memory info = topped[avatar];\r\n        for(uint i = 0 ; i < members.length ; i++) {\r\n            address member = members[i];\r\n            MemberTopupInfo memory memberInfo = topped[avatar].memberInfo[member];\r\n            uint amount = memberInfo.amountTopped;\r\n            if(amount > 0) {\r\n                if(realCushion == 0) {\r\n                    _untopOnBehalf(member, user, amount);\r\n                    // now it is 0 topup\r\n                    continue;\r\n                }\r\n\r\n                require(info.cToken == cToken, \"Pool: cToken-miss-match\");\r\n\r\n                if(member == msg.sender) continue; // skil below check for me(member)\r\n                if(! small) continue; // if big loan, share with it with other members\r\n                // me(member) checking for other member's expire\r\n                require(memberInfo.expire < now, \"Pool: other-member-topped\");\r\n                _untopOnBehalf(member, user, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    event MemberDeposit(address indexed member, address underlying, uint amount);\r\n    event MemberWithdraw(address indexed member, address underlying, uint amount);\r\n    event MemberToppedUp(address indexed member, address avatar, address cToken, uint amount);\r\n    event MemberUntopped(address indexed member, address avatar);\r\n    event MemberBite(address indexed member, address avatar, address cTokenDebt, address cTokenCollateral, uint underlyingAmtToLiquidate);\r\n    event ProfitParamsChanged(uint numerator, uint denominator);\r\n    event MembersSet(address[] members);\r\n    event SelectionDurationChanged(uint oldDuration, uint newDuration);\r\n    event MinTopupBpsChanged(uint oldMinTopupBps, uint newMinTopupBps);\r\n    event HoldingTimeChanged(uint oldHoldingTime, uint newHoldingTime);\r\n    event MinSharingThresholdChanged(address indexed bToken, uint oldThreshold, uint newThreshold);\r\n\r\n    modifier onlyMember() {\r\n        require(_isMember(msg.sender), \"Pool: not-member\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _jar) public {\r\n        jar = _jar;\r\n    }\r\n\r\n    // Added to avoid stack-too-deep-error\r\n    // This also reduce the code size as modifier code is copied to function\r\n    function _isMember(address member) internal view returns (bool isMember) {\r\n        for(uint i = 0 ; i < members.length ; i++) {\r\n            if(members[i] == member) {\r\n                isMember = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setRegistry(address _registry) external onlyOwner {\r\n        require(address(registry) == address(0), \"Pool: registry-already-set\");\r\n        registry = IRegistry(_registry);\r\n        comptroller = IComptroller(registry.comptroller());\r\n        bComptroller = IBComptroller(registry.bComptroller());\r\n        cEther = registry.cEther();\r\n    }\r\n\r\n    function emergencyExecute(address target, bytes calldata data) external payable onlyOwner {\r\n        (bool succ, bytes memory ret) = target.call.value(msg.value)(data);\r\n        require(succ, string(ret));\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function to receive ETH from Avatar\r\n     */\r\n    function() external payable {}\r\n\r\n    function setMinTopupBps(uint newMinTopupBps) external onlyOwner {\r\n        require(newMinTopupBps >= 0 && newMinTopupBps <= 10000, \"Pool: incorrect-minTopupBps\");\r\n        uint oldMinTopupBps = minTopupBps;\r\n        minTopupBps = newMinTopupBps;\r\n        emit MinTopupBpsChanged(oldMinTopupBps, newMinTopupBps);\r\n    }\r\n\r\n    function setHoldingTime(uint newHoldingTime) external onlyOwner {\r\n        require(newHoldingTime > 0, \"Pool: incorrect-holdingTime\");\r\n        uint oldHoldingTime = holdingTime;\r\n        holdingTime = newHoldingTime;\r\n        emit HoldingTimeChanged(oldHoldingTime, newHoldingTime);\r\n    }\r\n\r\n    function setMinSharingThreshold(address bToken, uint newMinThreshold) external onlyOwner {\r\n        require(newMinThreshold > 0, \"Pool: incorrect-minThreshold\");\r\n        require(bComptroller.isBToken(bToken), \"Pool: not-a-BToken\");\r\n        uint oldMinThreshold = minSharingThreshold[bToken];\r\n        minSharingThreshold[bToken] = newMinThreshold;\r\n        emit MinSharingThresholdChanged(bToken, oldMinThreshold, newMinThreshold);\r\n    }\r\n\r\n    function setProfitParams(uint numerator, uint denominator) external onlyOwner {\r\n        require(numerator < denominator, \"Pool: invalid-profit-params\");\r\n        shareNumerator = numerator;\r\n        shareDenominator = denominator;\r\n        emit ProfitParamsChanged(numerator, denominator);\r\n    }\r\n\r\n    function setSelectionDuration(uint newDuration) external onlyOwner {\r\n        require(newDuration > 0, \"Pool: selection-duration-is-zero\");\r\n        uint oldDuration = selectionDuration;\r\n        selectionDuration = newDuration;\r\n        emit SelectionDurationChanged(oldDuration, newDuration);\r\n    }\r\n\r\n    function setMembers(address[] calldata newMembersList) external onlyOwner {\r\n        members = newMembersList;\r\n        emit MembersSet(newMembersList);\r\n    }\r\n\r\n    function deposit() external payable onlyMember {\r\n        balance[msg.sender][ETH_ADDR] = add_(balance[msg.sender][ETH_ADDR], msg.value);\r\n        emit MemberDeposit(msg.sender, ETH_ADDR, msg.value);\r\n    }\r\n\r\n    function deposit(address underlying, uint amount) external onlyMember {\r\n        IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);\r\n        balance[msg.sender][underlying] = add_(balance[msg.sender][underlying], amount);\r\n        emit MemberDeposit(msg.sender, underlying, amount);\r\n    }\r\n\r\n    function withdraw(address underlying, uint amount) external {\r\n        if(_isETH(underlying)) {\r\n            balance[msg.sender][ETH_ADDR] = sub_(balance[msg.sender][ETH_ADDR], amount);\r\n            msg.sender.transfer(amount);\r\n        } else {\r\n            balance[msg.sender][underlying] = sub_(balance[msg.sender][underlying], amount);\r\n            IERC20(underlying).safeTransfer(msg.sender, amount);\r\n        }\r\n        emit MemberWithdraw(msg.sender, underlying, amount);\r\n    }\r\n\r\n    function liquidateBorrow(\r\n        address borrower,\r\n        address bTokenCollateral,\r\n        address bTokenDebt,\r\n        uint underlyingAmtToLiquidate\r\n    )\r\n        public onlyMember\r\n    {\r\n        address cTokenCollateral = bComptroller.b2c(bTokenCollateral);\r\n        address cTokenDebt = bComptroller.b2c(bTokenDebt);\r\n        address avatar = registry.avatarOf(borrower);\r\n        TopupInfo storage info = topped[avatar];\r\n\r\n        require(info.memberInfo[msg.sender].amountTopped > 0, \"Pool: member-didnt-topup\");\r\n        uint debtToLiquidatePerMember = info.debtToLiquidatePerMember;\r\n\r\n        if(debtToLiquidatePerMember == 0) {\r\n            uint numMembers = 0;\r\n            for(uint i = 0 ; i < members.length ; i++) {\r\n                if(info.memberInfo[members[i]].amountTopped > 0) {\r\n                    numMembers++;\r\n                }\r\n            }\r\n            debtToLiquidatePerMember = ICushion(avatar).getMaxLiquidationAmount(cTokenDebt) / numMembers;\r\n            info.debtToLiquidatePerMember = debtToLiquidatePerMember;\r\n        }\r\n\r\n        MemberTopupInfo memory memberInfo = info.memberInfo[msg.sender];\r\n\r\n        require(memberInfo.amountTopped > 0, \"Pool: member-didnt-topup\");\r\n        require(\r\n            add_(memberInfo.amountLiquidated, underlyingAmtToLiquidate) <= debtToLiquidatePerMember,\r\n            \"Pool: amount-too-big\"\r\n        );\r\n\r\n        uint amtToDeductFromTopup = mul_(underlyingAmtToLiquidate, memberInfo.amountTopped) / (\r\n            sub_(debtToLiquidatePerMember, memberInfo.amountLiquidated)\r\n        );\r\n\r\n        uint amtToRepayOnCompound = sub_(underlyingAmtToLiquidate, amtToDeductFromTopup);\r\n\r\n        address debtUnderlying = _getUnderlying(cTokenDebt);\r\n        require(balance[msg.sender][debtUnderlying] >= amtToRepayOnCompound, \"Pool: low-member-balance\");\r\n\r\n        if(! _isCEther(cTokenDebt)) {\r\n            IERC20(debtUnderlying).safeApprove(avatar, amtToRepayOnCompound);\r\n        }\r\n\r\n        require(\r\n            ICushion(avatar).liquidateBorrow.value(debtUnderlying == ETH_ADDR ?\r\n                                                   amtToRepayOnCompound :\r\n                                                   0)(underlyingAmtToLiquidate, amtToDeductFromTopup, cTokenCollateral) == 0,\r\n            \"Pool: liquidateBorrow-failed\"\r\n        );\r\n\r\n        // substract payment from member balance\r\n        balance[msg.sender][debtUnderlying] = sub_(balance[msg.sender][debtUnderlying],  amtToRepayOnCompound);\r\n\r\n        // share siezed cTokens with `member` and `jar`\r\n        _shareLiquidationProceeds(cTokenCollateral, msg.sender);\r\n\r\n        info.memberInfo[msg.sender].amountLiquidated = add_(memberInfo.amountLiquidated, underlyingAmtToLiquidate);\r\n        info.memberInfo[msg.sender].amountTopped = sub_(memberInfo.amountTopped, amtToDeductFromTopup);\r\n        topupBalance[msg.sender][debtUnderlying] = sub_(topupBalance[msg.sender][debtUnderlying], amtToDeductFromTopup);\r\n        if(IAvatar(avatar).toppedUpAmount() == 0) {\r\n            //info.debtToLiquidatePerMember = 0; // this indicates the liquidation ended\r\n            delete topped[avatar]; // this will reset debtToLiquidatePerMember\r\n        }\r\n        emit MemberBite(msg.sender, avatar, cTokenDebt, cTokenCollateral, underlyingAmtToLiquidate);\r\n    }\r\n\r\n    function feedPricesAndLiquidate(\r\n        IUniswapAnchoredView priceOracle,\r\n        bytes[] calldata messages,\r\n        bytes[] calldata signatures,\r\n        string[] calldata symbols,\r\n        address borrower,\r\n        address bTokenCollateral,\r\n        address bTokenDebt,\r\n        uint underlyingAmtToLiquidate\r\n    )\r\n        external\r\n    {\r\n        priceOracle.postPrices(messages, signatures, symbols);\r\n        liquidateBorrow(borrower, bTokenCollateral, bTokenDebt, underlyingAmtToLiquidate);\r\n    }\r\n\r\n    function _shareLiquidationProceeds(address cTokenCollateral, address member) internal {\r\n        uint seizedTokens = IERC20(cTokenCollateral).balanceOf(address(this));\r\n        uint memberShare = div_(mul_(seizedTokens, shareNumerator), shareDenominator);\r\n        uint jarShare = sub_(seizedTokens, memberShare);\r\n\r\n        IERC20(cTokenCollateral).safeTransfer(member, memberShare);\r\n        IERC20(cTokenCollateral).safeTransfer(jar, jarShare);\r\n    }\r\n\r\n    function membersLength() external view returns (uint) {\r\n        return members.length;\r\n    }\r\n\r\n    function getMembers() external view returns (address[] memory) {\r\n        return members;\r\n    }\r\n\r\n    function _isETH(address addr) internal pure returns (bool) {\r\n        return addr == ETH_ADDR;\r\n    }\r\n\r\n    function _isCEther(address addr) internal view returns (bool) {\r\n        return addr == cEther;\r\n    }\r\n\r\n    function _getUnderlying(address cToken) internal view returns (address underlying) {\r\n        if(_isCEther(cToken)) {\r\n            underlying = ETH_ADDR;\r\n        } else {\r\n            underlying = address(ICErc20(cToken).underlying());\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/bprotocol/info/LiquidatorInfo.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LiquidatorInfo {\r\n    address constant ETH = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n\r\n    struct AvatarInfo {\r\n        address user;\r\n\r\n        uint totalDebt; // total debt according to price feed\r\n        uint totalCollateral; // total collateral according to price feed\r\n        uint weightedCollateral; // collateral x collateral factor. liquidation when weightedCollateral < totalDebt\r\n\r\n        address[] debtTokens;\r\n        uint[] debtAmounts;\r\n\r\n        address[] collateralTokens;\r\n        uint[] collateralAmounts;\r\n        uint[] weightedCollateralAmounts;\r\n    }\r\n\r\n    struct CushionInfo {\r\n        bool hasCushion;\r\n        bool shouldTopup;\r\n        bool shouldUntop;\r\n\r\n        address cushionCurrentToken;\r\n        uint cushionCurrentSize;\r\n        uint cushionTokenTotalDebt;\r\n\r\n        address[] cushionPossibleTokens; // which tokens could be used for cushion\r\n        uint[] cushionMaxSizes;\r\n    }\r\n\r\n    struct LiquidationInfo {\r\n        // only relevant if there is a cushion. we assume only one liquidator\r\n        uint remainingLiquidationSize;\r\n        uint memberLiquidationIncentive;\r\n    }\r\n\r\n    struct AccountInfo {\r\n        AvatarInfo avatarInfo;\r\n        CushionInfo cushionInfo;\r\n        LiquidationInfo liquidationInfo;\r\n        uint blockNumber;\r\n    }\r\n\r\n    struct CToken2BToken {\r\n        address[] cTokens;\r\n        address[] bTokens;\r\n    }\r\n\r\n    struct CurrentPrices {\r\n        uint[] currPrices;\r\n        address[] ctokens;\r\n    }\r\n\r\n    struct Info {\r\n        AccountInfo[] accountInfo;\r\n        CToken2BToken c2bMapping;\r\n        CurrentPrices currPrices;\r\n        uint numAvatars;\r\n    }\r\n\r\n    function getCTokenToBTokenList(BComptroller bComptroller) \r\n        public\r\n        view\r\n        returns (CToken2BToken memory info)\r\n    {\r\n        info.cTokens = bComptroller.getAllMarkets();\r\n        info.bTokens = new address[](info.cTokens.length);\r\n\r\n        for(uint i = 0; i < info.cTokens.length; i++) {\r\n            info.bTokens[i] = bComptroller.c2b(info.cTokens[i]);\r\n        }\r\n    }\r\n\r\n    function getCurrentPrices(IUniswapAnchoredView oracle, address[] memory ctokens)\r\n        public\r\n        view\r\n        returns (CurrentPrices memory info)\r\n    {\r\n        info.currPrices = new uint[](ctokens.length);\r\n        info.ctokens = ctokens;\r\n\r\n        for(uint i = 0 ; i < ctokens.length ; i++) {\r\n            info.currPrices[i] = oracle.getUnderlyingPrice(ctokens[i]);\r\n        }\r\n    }\r\n\r\n    function isIn(address[] memory array, address elm) internal pure returns(bool) {\r\n        for(uint i = 0 ; i < array.length ; i++) {\r\n            if(elm == array[i]) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function getAvatarInfo(\r\n        Registry registry,\r\n        BComptroller bComptroller,\r\n        address[] memory cTokens,\r\n        uint[] memory priceFeed,\r\n        address avatar\r\n    ) \r\n        public\r\n        returns(AvatarInfo memory info) \r\n    {\r\n        require(cTokens.length == priceFeed.length, \"cTokens-priceFeed-missmatch\");\r\n\r\n        uint numTokens = cTokens.length;\r\n        address user = registry.ownerOf(avatar);\r\n\r\n        info.user = user;\r\n        info.debtTokens = new address[](numTokens);\r\n        info.debtAmounts = new uint[](numTokens);\r\n        info.collateralTokens = new address[](numTokens);\r\n        info.collateralAmounts = new uint[](numTokens);\r\n        info.weightedCollateralAmounts = new uint[](numTokens);\r\n\r\n        IComptroller comptroller = bComptroller.comptroller();\r\n        address[] memory assetsIn = comptroller.getAssetsIn(avatar);\r\n\r\n        for(uint i = 0 ; i < numTokens ; i++) {\r\n            if(registry.cEther() == cTokens[i]) \r\n                info.debtTokens[i] = ETH;\r\n            else \r\n                info.debtTokens[i] = address(CTokenInterface(cTokens[i]).underlying());\r\n\r\n            address bToken = bComptroller.c2b(cTokens[i]);\r\n            info.debtAmounts[i] = IBToken(bToken).borrowBalanceCurrent(user);\r\n\r\n            info.collateralTokens[i] = cTokens[i];\r\n            info.collateralAmounts[i] = IBToken(bToken).balanceOfUnderlying(user);\r\n            if(! isIn(assetsIn, cTokens[i])) info.collateralAmounts[i] = 0; \r\n            // set as 0 if not in market\r\n            // CR = collateralRatio = collateralFactorMantissa\r\n            (,uint CR) = comptroller.markets(cTokens[i]);\r\n            info.weightedCollateralAmounts[i] = info.collateralAmounts[i] * CR / 1e18;\r\n\r\n            info.totalDebt += info.debtAmounts[i] * priceFeed[i] / 1e18;\r\n            info.totalCollateral += info.collateralAmounts[i] * priceFeed[i] / 1e18;\r\n            info.weightedCollateral += info.weightedCollateralAmounts[i] * priceFeed[i] / 1e18;\r\n        }\r\n    }\r\n\r\n    function cTokenToUnderlying(Registry registry, address cToken) internal view returns(address) {\r\n        if(registry.cEther() == cToken) \r\n            return ETH; \r\n        else \r\n            return address(CTokenInterface(cToken).underlying());\r\n    }\r\n\r\n    function getCushionInfo(\r\n        Registry registry,\r\n        BComptroller bComptroller,\r\n        Pool pool,\r\n        address[] memory cTokens,\r\n        uint[] memory priceFeed,\r\n        uint debtAmount,\r\n        uint weightedCollateral,\r\n        address avatar,\r\n        address me\r\n    ) \r\n        public\r\n        returns(CushionInfo memory info) \r\n    {\r\n        address user = registry.ownerOf(avatar);\r\n        info.hasCushion = ICushion(avatar).toppedUpAmount() > 0;\r\n        (, uint amountTopped,) = pool.getMemberTopupInfo(user, me);\r\n\r\n        if(debtAmount > weightedCollateral) {\r\n            // assume there is only one member\r\n            info.shouldTopup = true;\r\n        }\r\n        info.shouldUntop = (!info.hasCushion && amountTopped > 0);\r\n\r\n        if(amountTopped > 0) {\r\n            (,address toppedCToken) = pool.topped(avatar);\r\n            info.cushionCurrentToken = cTokenToUnderlying(registry, toppedCToken);\r\n            info.cushionCurrentSize = amountTopped;\r\n        }\r\n\r\n        info.cushionPossibleTokens = new address[](cTokens.length);\r\n        info.cushionMaxSizes = new uint[](cTokens.length);        \r\n        for(uint i = 0 ; i < cTokens.length ; i++) {\r\n            uint debt = IBToken(bComptroller.c2b(cTokens[i])).borrowBalanceCurrent(user);\r\n            uint debtUsd = debt * priceFeed[i] / 1e18;\r\n            if(amountTopped > 0 && info.hasCushion) {\r\n                if(info.cushionCurrentToken != cTokenToUnderlying(registry, cTokens[i])) continue;\r\n                info.cushionTokenTotalDebt = debt;\r\n                debt -= amountTopped;\r\n            }\r\n\r\n            info.cushionPossibleTokens[i] = cTokenToUnderlying(registry, cTokens[i]);\r\n            info.cushionMaxSizes[i] = debt;\r\n\r\n            if(debtAmount > weightedCollateral) {\r\n                // not enough debt to topup\r\n                if(debtUsd < (debtAmount - weightedCollateral)) info.cushionMaxSizes[i] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getLiquidationInfo(Pool pool, address avatar) public returns(LiquidationInfo memory info) {\r\n        info.remainingLiquidationSize = ICushion(avatar).remainingLiquidationAmount();\r\n        Registry registry = Registry(address(pool.registry()));\r\n        IComptroller comptroller = IComptroller(registry.comptroller());\r\n        info.memberLiquidationIncentive = \r\n            comptroller.liquidationIncentiveMantissa() * pool.shareNumerator() / pool.shareDenominator();\r\n    }\r\n\r\n    function getSingleAccountInfo(\r\n        Pool pool,\r\n        Registry registry,\r\n        BComptroller bComptroller, \r\n        address me,\r\n        address avatar,\r\n        address[] memory cTokens,\r\n        uint[] memory priceFeed,\r\n        IUniswapAnchoredView oracle\r\n    )\r\n        public\r\n        returns(AccountInfo memory info) \r\n    {\r\n\r\n        info.avatarInfo = getAvatarInfo(registry, bComptroller, cTokens, priceFeed, avatar);\r\n        info.cushionInfo = getCushionInfo(\r\n            registry,\r\n            bComptroller,\r\n            pool,\r\n            cTokens,\r\n            priceFeed,\r\n            info.avatarInfo.totalDebt,\r\n            info.avatarInfo.weightedCollateral,\r\n            avatar,\r\n            me\r\n        );\r\n        info.liquidationInfo = getLiquidationInfo(pool, avatar);\r\n        info.blockNumber = block.number;\r\n\r\n        CurrentPrices memory realPrices = getCurrentPrices(oracle, cTokens);\r\n        AvatarInfo memory realAvatarInfo = getAvatarInfo(registry, bComptroller, cTokens, realPrices.currPrices, avatar);\r\n\r\n        if(realAvatarInfo.totalDebt > realAvatarInfo.weightedCollateral) {\r\n            if(info.liquidationInfo.remainingLiquidationSize == 0) {\r\n                info.liquidationInfo.remainingLiquidationSize = info.cushionInfo.cushionTokenTotalDebt / 2;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getInfo(\r\n        uint startAccount,\r\n        uint endAccount,\r\n        address me,\r\n        Pool pool,\r\n        address[] memory cTokens,\r\n        uint[] memory priceFeed,\r\n        string[] memory /* symbols */ // this is obselete now\r\n    )\r\n        public\r\n        returns(Info memory info) \r\n    {\r\n        info.accountInfo = new AccountInfo[](endAccount + 1 - startAccount);\r\n\r\n        Registry registry = Registry(address(pool.registry()));\r\n        BComptroller bComptroller = BComptroller(address(pool.bComptroller()));\r\n\r\n        IUniswapAnchoredView oracle = IUniswapAnchoredView(IComptroller(BComptroller(bComptroller).comptroller()).oracle());\r\n\r\n        for(uint i = 0 ; i + startAccount <= endAccount ; i++) {\r\n            uint accountNumber = i + startAccount;\r\n            address avatar = registry.avatars(accountNumber);\r\n            info.accountInfo[i] = getSingleAccountInfo(pool, registry, bComptroller, me, avatar, cTokens, priceFeed, oracle);\r\n        }\r\n\r\n        info.c2bMapping = getCTokenToBTokenList(bComptroller);\r\n        info.currPrices = getCurrentPrices(oracle, cTokens);\r\n        info.numAvatars = registry.avatarLength();\r\n    }\r\n\r\n    function getNumAvatars(Pool pool) public view returns(uint) {\r\n        Registry registry = Registry(address(pool.registry()));\r\n        return registry.avatarLength(); \r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Registry\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"contract BComptroller\",\"name\":\"bComptroller\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"cTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"priceFeed\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"avatar\",\"type\":\"address\"}],\"name\":\"getAvatarInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weightedCollateral\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"debtTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"debtAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"collateralTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"collateralAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weightedCollateralAmounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct LiquidatorInfo.AvatarInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract BComptroller\",\"name\":\"bComptroller\",\"type\":\"address\"}],\"name\":\"getCTokenToBTokenList\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"cTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"bTokens\",\"type\":\"address[]\"}],\"internalType\":\"struct LiquidatorInfo.CToken2BToken\",\"name\":\"info\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IUniswapAnchoredView\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"ctokens\",\"type\":\"address[]\"}],\"name\":\"getCurrentPrices\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"currPrices\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"ctokens\",\"type\":\"address[]\"}],\"internalType\":\"struct LiquidatorInfo.CurrentPrices\",\"name\":\"info\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Registry\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"contract BComptroller\",\"name\":\"bComptroller\",\"type\":\"address\"},{\"internalType\":\"contract Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"cTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"priceFeed\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weightedCollateral\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"avatar\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"me\",\"type\":\"address\"}],\"name\":\"getCushionInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasCushion\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"shouldTopup\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"shouldUntop\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"cushionCurrentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cushionCurrentSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cushionTokenTotalDebt\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"cushionPossibleTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"cushionMaxSizes\",\"type\":\"uint256[]\"}],\"internalType\":\"struct LiquidatorInfo.CushionInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startAccount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAccount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"me\",\"type\":\"address\"},{\"internalType\":\"contract Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"cTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"priceFeed\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"name\":\"getInfo\",\"outputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weightedCollateral\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"debtTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"debtAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"collateralTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"collateralAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weightedCollateralAmounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct LiquidatorInfo.AvatarInfo\",\"name\":\"avatarInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasCushion\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"shouldTopup\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"shouldUntop\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"cushionCurrentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cushionCurrentSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cushionTokenTotalDebt\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"cushionPossibleTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"cushionMaxSizes\",\"type\":\"uint256[]\"}],\"internalType\":\"struct LiquidatorInfo.CushionInfo\",\"name\":\"cushionInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"remainingLiquidationSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"memberLiquidationIncentive\",\"type\":\"uint256\"}],\"internalType\":\"struct LiquidatorInfo.LiquidationInfo\",\"name\":\"liquidationInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct LiquidatorInfo.AccountInfo[]\",\"name\":\"accountInfo\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"cTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"bTokens\",\"type\":\"address[]\"}],\"internalType\":\"struct LiquidatorInfo.CToken2BToken\",\"name\":\"c2bMapping\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"currPrices\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"ctokens\",\"type\":\"address[]\"}],\"internalType\":\"struct LiquidatorInfo.CurrentPrices\",\"name\":\"currPrices\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"numAvatars\",\"type\":\"uint256\"}],\"internalType\":\"struct LiquidatorInfo.Info\",\"name\":\"info\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"avatar\",\"type\":\"address\"}],\"name\":\"getLiquidationInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"remainingLiquidationSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"memberLiquidationIncentive\",\"type\":\"uint256\"}],\"internalType\":\"struct LiquidatorInfo.LiquidationInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract Pool\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getNumAvatars\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"contract Registry\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"contract BComptroller\",\"name\":\"bComptroller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"me\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"avatar\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"cTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"priceFeed\",\"type\":\"uint256[]\"},{\"internalType\":\"contract IUniswapAnchoredView\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"getSingleAccountInfo\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weightedCollateral\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"debtTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"debtAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"collateralTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"collateralAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weightedCollateralAmounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct LiquidatorInfo.AvatarInfo\",\"name\":\"avatarInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasCushion\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"shouldTopup\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"shouldUntop\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"cushionCurrentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cushionCurrentSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cushionTokenTotalDebt\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"cushionPossibleTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"cushionMaxSizes\",\"type\":\"uint256[]\"}],\"internalType\":\"struct LiquidatorInfo.CushionInfo\",\"name\":\"cushionInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"remainingLiquidationSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"memberLiquidationIncentive\",\"type\":\"uint256\"}],\"internalType\":\"struct LiquidatorInfo.LiquidationInfo\",\"name\":\"liquidationInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct LiquidatorInfo.AccountInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LiquidatorInfo","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"BSD-3-Clause","Proxy":"0","Implementation":"","SwarmSource":"bzzr://212b2ec640ad4624649393ca0ef90c7475576fc307859b5caed838212286fc48"}]}