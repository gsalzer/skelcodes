{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MiningTreasury.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport \\\"./MultiSig.sol\\\";\\n\\ncontract MiningTreasury is MultiSig {\\n    constructor (\\n        address[] memory _owners,\\n        uint256 _required\\n    )\\n        public\\n        MultiSig(_owners, _required)\\n    {\\n    }\\n}\"\r\n    },\r\n    \"contracts/MultiSig.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport \\\"./utils/LibBytes.sol\\\";\\nimport \\\"./MultiSigLibEIP712.sol\\\";\\n\\n/**\\n * @title MultiSig\\n * @author dYdX\\n *\\n * Multi-Signature Wallet.\\n * Allows multiple parties to agree on transactions before execution.\\n * Adapted from Stefan George's MultiSigWallet contract.\\n *\\n * Logic Changes:\\n *  - Removed the fallback function\\n *  - Ensure newOwner is notNull\\n *\\n * Syntax Changes:\\n *  - Update Solidity syntax for 0.5.X: use `emit` keyword (events), use `view` keyword (functions)\\n *  - Add braces to all `if` and `for` statements\\n *  - Remove named return variables\\n *  - Add space before and after comparison operators\\n *  - Add ADDRESS_ZERO as a constant\\n *  - uint => uint256\\n *  - external_call => externalCall\\n */\\ncontract MultiSig is MultiSigLibEIP712 {\\n    using LibBytes for bytes;\\n\\n    // ============ Events ============\\n\\n    event Deposit(address indexed depositer, uint256 amount);\\n    event Confirmation(address indexed sender, uint256 indexed transactionId);\\n    event Revocation(address indexed sender, uint256 indexed transactionId);\\n    event Submission(uint256 indexed transactionId);\\n    event Execution(uint256 indexed transactionId);\\n    event ExecutionFailure(uint256 indexed transactionId);\\n    event OwnerAddition(address indexed owner);\\n    event OwnerRemoval(address indexed owner);\\n    event RequirementChange(uint256 required);\\n\\n    // ============ Constants ============\\n\\n    uint256 constant public MAX_OWNER_COUNT = 50;\\n    address constant ADDRESS_ZERO = address(0x0);\\n\\n    // ============ Storage ============\\n\\n    mapping (uint256 => Transaction) public transactions;\\n    mapping (uint256 => mapping (address => bool)) public confirmations;\\n    mapping (address => bool) public isOwner;\\n    address[] public owners;\\n    uint256 public required;\\n    uint256 public transactionCount;\\n\\n    // ============ Structs ============\\n\\n    struct Transaction {\\n        address destination;\\n        uint256 value;\\n        bytes data;\\n        bool executed;\\n    }\\n\\n    // ============ Modifiers ============\\n\\n    modifier onlyWallet() {\\n        /* solium-disable-next-line error-reason */\\n        require(msg.sender == address(this));\\n        _;\\n    }\\n\\n    modifier ownerDoesNotExist(\\n        address owner\\n    ) {\\n        /* solium-disable-next-line error-reason */\\n        require(!isOwner[owner]);\\n        _;\\n    }\\n\\n    modifier ownerExists(\\n        address owner\\n    ) {\\n        /* solium-disable-next-line error-reason */\\n        require(isOwner[owner]);\\n        _;\\n    }\\n\\n    modifier transactionExists(\\n        uint256 transactionId\\n    ) {\\n        /* solium-disable-next-line error-reason */\\n        require(transactions[transactionId].destination != ADDRESS_ZERO);\\n        _;\\n    }\\n\\n    modifier confirmed(\\n        uint256 transactionId,\\n        address owner\\n    ) {\\n        /* solium-disable-next-line error-reason */\\n        require(confirmations[transactionId][owner]);\\n        _;\\n    }\\n\\n    modifier notConfirmed(\\n        uint256 transactionId,\\n        address owner\\n    ) {\\n        /* solium-disable-next-line error-reason */\\n        require(!confirmations[transactionId][owner]);\\n        _;\\n    }\\n\\n    modifier notExecuted(\\n        uint256 transactionId\\n    ) {\\n        /* solium-disable-next-line error-reason */\\n        require(!transactions[transactionId].executed);\\n        _;\\n    }\\n\\n    modifier notNull(\\n        address _address\\n    ) {\\n        /* solium-disable-next-line error-reason */\\n        require(_address != ADDRESS_ZERO);\\n        _;\\n    }\\n\\n    modifier validRequirement(\\n        uint256 ownerCount,\\n        uint256 _required\\n    ) {\\n        /* solium-disable-next-line error-reason */\\n        require(\\n            ownerCount <= MAX_OWNER_COUNT\\n            && _required <= ownerCount\\n            && _required != 0\\n            && ownerCount != 0\\n        );\\n        _;\\n    }\\n\\n    // ========= Fallback function ==========\\n    receive() external payable {\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    // ============ Constructor ============\\n\\n    /**\\n     * Contract constructor sets initial owners and required number of confirmations.\\n     *\\n     * @param  _owners    List of initial owners.\\n     * @param  _required  Number of required confirmations.\\n     */\\n    constructor(\\n        address[] memory _owners,\\n        uint256 _required\\n    )\\n        public\\n        validRequirement(_owners.length, _required)\\n        MultiSigLibEIP712()\\n    {\\n        for (uint256 i = 0; i < _owners.length; i++) {\\n            /* solium-disable-next-line error-reason */\\n            require(!isOwner[_owners[i]] && _owners[i] != ADDRESS_ZERO);\\n            isOwner[_owners[i]] = true;\\n        }\\n        owners = _owners;\\n        required = _required;\\n    }\\n\\n    // ============ Wallet-Only Functions ============\\n\\n    /**\\n     * Allows to add a new owner. Transaction has to be sent by wallet.\\n     *\\n     * @param  owner  Address of new owner.\\n     */\\n    function addOwner(\\n        address owner\\n    )\\n        public\\n        onlyWallet\\n        ownerDoesNotExist(owner)\\n        notNull(owner)\\n        validRequirement(owners.length + 1, required)\\n    {\\n        isOwner[owner] = true;\\n        owners.push(owner);\\n        emit OwnerAddition(owner);\\n    }\\n\\n    /**\\n     * Allows to remove an owner. Transaction has to be sent by wallet.\\n     *\\n     * @param  owner  Address of owner.\\n     */\\n    function removeOwner(\\n        address owner\\n    )\\n        public\\n        onlyWallet\\n        ownerExists(owner)\\n    {\\n        isOwner[owner] = false;\\n        for (uint256 i = 0; i < owners.length - 1; i++) {\\n            if (owners[i] == owner) {\\n                owners[i] = owners[owners.length - 1];\\n                break;\\n            }\\n        }\\n        delete owners[owners.length - 1];\\n        if (required > owners.length) {\\n            changeRequirement(owners.length);\\n        }\\n        emit OwnerRemoval(owner);\\n    }\\n\\n    /**\\n     * Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\\n     *\\n     * @param  owner     Address of owner to be replaced.\\n     * @param  newOwner  Address of new owner.\\n     */\\n    function replaceOwner(\\n        address owner,\\n        address newOwner\\n    )\\n        public\\n        onlyWallet\\n        ownerExists(owner)\\n        ownerDoesNotExist(newOwner)\\n        notNull(newOwner)\\n    {\\n        for (uint256 i = 0; i < owners.length; i++) {\\n            if (owners[i] == owner) {\\n                owners[i] = newOwner;\\n                break;\\n            }\\n        }\\n        isOwner[owner] = false;\\n        isOwner[newOwner] = true;\\n        emit OwnerRemoval(owner);\\n        emit OwnerAddition(newOwner);\\n    }\\n\\n    /**\\n     * Allows to change the number of required confirmations. Transaction has to be sent by wallet.\\n     *\\n     * @param  _required  Number of required confirmations.\\n     */\\n    function changeRequirement(\\n        uint256 _required\\n    )\\n        public\\n        onlyWallet\\n        validRequirement(owners.length, _required)\\n    {\\n        required = _required;\\n        emit RequirementChange(_required);\\n    }\\n\\n    // ============ Owner Functions ============\\n\\n    /**\\n     * Allows an owner to submit and confirm a transaction.\\n     *\\n     * @param  destination  Transaction target address.\\n     * @param  value        Transaction ether value.\\n     * @param  data         Transaction data payload.\\n     * @return              Transaction ID.\\n     */\\n    function submitTransaction(\\n        address destination,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        public\\n        returns (uint256)\\n    {\\n        uint256 transactionId = addTransaction(destination, value, data);\\n        confirmTransaction(transactionId);\\n        return transactionId;\\n    }\\n\\n    /**\\n     * Allows an owner to submit and confirm a transaction via meta transaction.\\n     *\\n     * @param  signer           Signer of the meta transaction.\\n     * @param  transactionId    Transaction ID of this transaction.\\n     * @param  destination      Transaction target address.\\n     * @param  value            Transaction ether value.\\n     * @param  data             Transaction data payload.\\n     * @param  sig              Signature.\\n     * @return                  Transaction ID.\\n     */\\n    function submitTransaction(\\n        address signer,\\n        uint256 transactionId,\\n        address destination,\\n        uint256 value,\\n        bytes memory data,\\n        bytes memory sig\\n    )\\n        public\\n        ownerExists(signer)\\n        returns (uint256)\\n    {\\n        // SUBMIT_TRANSACTION_TYPE_HASH = keccak256(\\\"submitTransaction(uint256 transactionId,address destination,uint256 value,bytes data)\\\");\\n        bytes32 EIP712SignDigest = keccak256(\\n            abi.encodePacked(\\n                bytes1(0x19),\\n                bytes1(0x01),\\n                EIP712_DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        SUBMIT_TRANSACTION_TYPE_HASH,\\n                        transactionId,\\n                        destination,\\n                        value,\\n                        data\\n                    )\\n                )\\n            )\\n        );\\n        validateSignature(signer, EIP712SignDigest, sig);\\n\\n        uint256 _transactionId = addTransaction(destination, value, data);\\n\\n        require(transactionId == _transactionId);\\n\\n        confirmTransactionBySigner(signer, transactionId);\\n        return transactionId;\\n    }\\n\\n    // confirm transaction on behalf of signer, not msg.sender\\n    function confirmTransactionBySigner(\\n        address signer,\\n        uint256 transactionId\\n    )\\n        internal\\n        transactionExists(transactionId)\\n        notConfirmed(transactionId, signer)\\n    {\\n        // Confirm\\n        confirmations[transactionId][signer] = true;\\n        emit Confirmation(signer, transactionId);\\n\\n        // Execute\\n        executeTransactionBySigner(signer, transactionId);\\n    }\\n\\n    // execute transaction on behalf of signer, not msg.sender\\n    function executeTransactionBySigner(\\n        address signer,\\n        uint256 transactionId\\n    )\\n        internal\\n        notExecuted(transactionId)\\n    {\\n        if (isConfirmed(transactionId)) {\\n            Transaction storage txn = transactions[transactionId];\\n            txn.executed = true;\\n            if (externalCall(\\n                txn.destination,\\n                txn.value,\\n                txn.data.length,\\n                txn.data)\\n            ) {\\n                emit Execution(transactionId);\\n            } else {\\n                emit ExecutionFailure(transactionId);\\n                txn.executed = false;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Allows an owner to confirm a transaction.\\n     *\\n     * @param  transactionId  Transaction ID.\\n     */\\n    function confirmTransaction(\\n        uint256 transactionId\\n    )\\n        public\\n        virtual\\n        ownerExists(msg.sender)\\n        transactionExists(transactionId)\\n        notConfirmed(transactionId, msg.sender)\\n    {\\n        confirmations[transactionId][msg.sender] = true;\\n        emit Confirmation(msg.sender, transactionId);\\n        executeTransaction(transactionId);\\n    }\\n\\n    /**\\n     * Allows an owner to confirm a transaction via meta transaction.\\n     *\\n     * @param  signer           Signer of the meta transaction.\\n     * @param  transactionId    Transaction ID.\\n     * @param  sig              Signature.\\n     */\\n    function confirmTransaction(\\n        address signer,\\n        uint256 transactionId,\\n        bytes memory sig\\n    )\\n        public\\n        virtual\\n        ownerExists(signer)\\n        transactionExists(transactionId)\\n        notConfirmed(transactionId, signer)\\n    {\\n        // CONFIRM_TRANSACTION_TYPE_HASH = keccak256(\\\"confirmTransaction(uint256 transactionId)\\\");\\n        bytes32 EIP712SignDigest = keccak256(\\n            abi.encodePacked(\\n                bytes1(0x19),\\n                bytes1(0x01),\\n                EIP712_DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        CONFIRM_TRANSACTION_TYPE_HASH,\\n                        transactionId\\n                    )\\n                )\\n            )\\n        );\\n        validateSignature(signer, EIP712SignDigest, sig);\\n\\n        confirmations[transactionId][signer] = true;\\n        emit Confirmation(signer, transactionId);\\n        executeTransactionBySigner(signer, transactionId);\\n    }\\n\\n    /**\\n     * Allows an owner to revoke a confirmation for a transaction.\\n     *\\n     * @param  transactionId  Transaction ID.\\n     */\\n    function revokeConfirmation(\\n        uint256 transactionId\\n    )\\n        public\\n        ownerExists(msg.sender)\\n        confirmed(transactionId, msg.sender)\\n        notExecuted(transactionId)\\n    {\\n        confirmations[transactionId][msg.sender] = false;\\n        emit Revocation(msg.sender, transactionId);\\n    }\\n\\n    /**\\n     * Allows an owner to execute a confirmed transaction.\\n     *\\n     * @param  transactionId  Transaction ID.\\n     */\\n    function executeTransaction(\\n        uint256 transactionId\\n    )\\n        public\\n        virtual\\n        ownerExists(msg.sender)\\n        confirmed(transactionId, msg.sender)\\n        notExecuted(transactionId)\\n    {\\n        if (isConfirmed(transactionId)) {\\n            Transaction storage txn = transactions[transactionId];\\n            txn.executed = true;\\n            if (externalCall(\\n                txn.destination,\\n                txn.value,\\n                txn.data.length,\\n                txn.data)\\n            ) {\\n                emit Execution(transactionId);\\n            } else {\\n                emit ExecutionFailure(transactionId);\\n                txn.executed = false;\\n            }\\n        }\\n    }\\n\\n    // ============ Getter Functions ============\\n\\n    /**\\n     * Returns the confirmation status of a transaction.\\n     *\\n     * @param  transactionId  Transaction ID.\\n     * @return                Confirmation status.\\n     */\\n    function isConfirmed(\\n        uint256 transactionId\\n    )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        uint256 count = 0;\\n        for (uint256 i = 0; i < owners.length; i++) {\\n            if (confirmations[transactionId][owners[i]]) {\\n                count += 1;\\n            }\\n            if (count == required) {\\n                return true;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Returns number of confirmations of a transaction.\\n     *\\n     * @param  transactionId  Transaction ID.\\n     * @return                Number of confirmations.\\n     */\\n    function getConfirmationCount(\\n        uint256 transactionId\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 count = 0;\\n        for (uint256 i = 0; i < owners.length; i++) {\\n            if (confirmations[transactionId][owners[i]]) {\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    /**\\n     * Returns total number of transactions after filers are applied.\\n     *\\n     * @param  pending   Include pending transactions.\\n     * @param  executed  Include executed transactions.\\n     * @return           Total number of transactions after filters are applied.\\n     */\\n    function getTransactionCount(\\n        bool pending,\\n        bool executed\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 count = 0;\\n        for (uint256 i = 0; i < transactionCount; i++) {\\n            if (\\n                pending && !transactions[i].executed\\n                || executed && transactions[i].executed\\n            ) {\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    /**\\n     * Returns array of owners.\\n     *\\n     * @return  Array of owner addresses.\\n     */\\n    function getOwners()\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        return owners;\\n    }\\n\\n    /**\\n     * Returns array with owner addresses, which confirmed transaction.\\n     *\\n     * @param  transactionId  Transaction ID.\\n     * @return                Array of owner addresses.\\n     */\\n    function getConfirmations(\\n        uint256 transactionId\\n    )\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        address[] memory confirmationsTemp = new address[](owners.length);\\n        uint256 count = 0;\\n        uint256 i;\\n        for (i = 0; i < owners.length; i++) {\\n            if (confirmations[transactionId][owners[i]]) {\\n                confirmationsTemp[count] = owners[i];\\n                count += 1;\\n            }\\n        }\\n        address[] memory _confirmations = new address[](count);\\n        for (i = 0; i < count; i++) {\\n            _confirmations[i] = confirmationsTemp[i];\\n        }\\n        return _confirmations;\\n    }\\n\\n    /**\\n     * Returns list of transaction IDs in defined range.\\n     *\\n     * @param  from      Index start position of transaction array.\\n     * @param  to        Index end position of transaction array.\\n     * @param  pending   Include pending transactions.\\n     * @param  executed  Include executed transactions.\\n     * @return           Array of transaction IDs.\\n     */\\n    function getTransactionIds(\\n        uint256 from,\\n        uint256 to,\\n        bool pending,\\n        bool executed\\n    )\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory transactionIdsTemp = new uint256[](transactionCount);\\n        uint256 count = 0;\\n        uint256 i;\\n        for (i = 0; i < transactionCount; i++) {\\n            if (\\n                pending && !transactions[i].executed\\n                || executed && transactions[i].executed\\n            ) {\\n                transactionIdsTemp[count] = i;\\n                count += 1;\\n            }\\n        }\\n        uint256[] memory _transactionIds = new uint256[](to - from);\\n        for (i = from; i < to; i++) {\\n            _transactionIds[i - from] = transactionIdsTemp[i];\\n        }\\n        return _transactionIds;\\n    }\\n\\n    // ============ Helper Functions ============\\n\\n    function validateSignature(\\n        address signer,\\n        bytes32 digest,\\n        bytes memory sig\\n    )\\n        internal\\n    {\\n        require(sig.length == 65);\\n        uint8 v = uint8(sig[64]);\\n        bytes32 r = sig.readBytes32(0);\\n        bytes32 s = sig.readBytes32(32);\\n        address recovered = ecrecover(digest, v, r, s);\\n        require(signer == recovered);\\n    }\\n\\n    // call has been separated into its own function in order to take advantage\\n    // of the Solidity's code generator to produce a loop that copies tx.data into memory.\\n    function externalCall(\\n        address destination,\\n        uint256 value,\\n        uint256 dataLength,\\n        bytes memory data\\n    )\\n        internal\\n        returns (bool)\\n    {\\n        bool result;\\n        /* solium-disable-next-line security/no-inline-assembly */\\n        assembly {\\n            let x := mload(0x40)   // \\\"Allocate\\\" memory for output (0x40 is where \\\"free memory\\\" pointer is stored by convention)\\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\\n            result := call(\\n                sub(gas(), 34710),   // 34710 is the value that solidity is currently emitting\\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\\n                destination,\\n                value,\\n                d,\\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\\n                x,\\n                0                  // Output is ignored, therefore the output size is zero\\n            )\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * Adds a new transaction to the transaction mapping, if transaction does not exist yet.\\n     *\\n     * @param  destination  Transaction target address.\\n     * @param  value        Transaction ether value.\\n     * @param  data         Transaction data payload.\\n     * @return              Transaction ID.\\n     */\\n    function addTransaction(\\n        address destination,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        internal\\n        notNull(destination)\\n        returns (uint256)\\n    {\\n        uint256 transactionId = transactionCount;\\n        transactions[transactionId] = Transaction({\\n            destination: destination,\\n            value: value,\\n            data: data,\\n            executed: false\\n        });\\n        transactionCount += 1;\\n        emit Submission(transactionId);\\n        return transactionId;\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/LibBytes.sol\": {\r\n      \"content\": \"/**\\n *Submitted for verification at Etherscan.io on 2019-05-13\\n*/\\n\\n/*\\n\\n    Copyright 2019 dYdX Trading Inc.\\n\\n    Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n    you may not use this file except in compliance with the License.\\n    You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n    Unless required by applicable law or agreed to in writing, software\\n    distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n    See the License for the specific language governing permissions and\\n    limitations under the License.\\n\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nlibrary LibBytes {\\n      /***********************************|\\n    |        Read Bytes Functions       |\\n    |__________________________________*/\\n\\n    /**\\n    * @dev Reads a bytes32 value from a position in a byte array.\\n    * @param b Byte array containing a bytes32 value.\\n    * @param index Index in byte array of bytes32 value.\\n    * @return result bytes32 value from byte array.\\n    */\\n    function readBytes32(\\n        bytes memory b,\\n        uint256 index\\n    )\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        require(\\n        b.length >= index + 32,\\n        \\\"LibBytes#readBytes32 greater or equal to 32 length required\\\"\\n        );\\n\\n        // Arrays are prefixed by a 256 bit length parameter\\n        index += 32;\\n\\n        // Read the bytes32 from array memory\\n        assembly {\\n        result := mload(add(b, index))\\n        }\\n        return result;\\n    }\\n}\"\r\n    },\r\n    \"contracts/MultiSigLibEIP712.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ncontract MultiSigLibEIP712 {\\n    /***********************************|\\n  |             Constants             |\\n  |__________________________________*/\\n\\n    // EIP712Domain\\n    string public constant EIP712_DOMAIN_NAME = \\\"MultiSig\\\";\\n    string public constant EIP712_DOMAIN_VERSION = \\\"v1\\\";\\n\\n    // EIP712Domain Separator\\n    bytes32 public EIP712_DOMAIN_SEPARATOR;\\n\\n    // SUBMIT_TRANSACTION_TYPE_HASH = keccak256(\\\"submitTransaction(uint256 transactionId,address destination,uint256 value,bytes data)\\\");\\n    bytes32 public constant SUBMIT_TRANSACTION_TYPE_HASH = 0x2c78e27c3bb2592e67e8d37ad1a95bfccd188e77557c22593b1af0b920a08295;\\n\\n    // CONFIRM_TRANSACTION_TYPE_HASH = keccak256(\\\"confirmTransaction(uint256 transactionId)\\\");\\n    bytes32 public constant CONFIRM_TRANSACTION_TYPE_HASH = 0x3e96bdc38d4133bc81813a187b2d41bc74332643ce7dbe82c7d94ead8366a65f;\\n\\n    constructor() public {\\n        EIP712_DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n                keccak256(bytes(EIP712_DOMAIN_NAME)),\\n                keccak256(bytes(EIP712_DOMAIN_VERSION)),\\n                getChainID(),\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /**\\n    * @dev Return `chainId`\\n    */\\n    function getChainID() internal pure returns (uint) {\\n        uint chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        return chainId;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_required\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Execution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"ExecutionFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"RequirementChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Revocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Submission\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONFIRM_TRANSACTION_TYPE_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OWNER_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUBMIT_TRANSACTION_TYPE_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_required\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"confirmations\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getConfirmationCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getConfirmations\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"pending\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"pending\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"replaceOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"required\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"revokeConfirmation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"submitTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"submitTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transactionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MiningTreasury","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000005000000000000000000000000b9e29984fe50602e7a619662ebed4f90d93824c7000000000000000000000000b7c7124c1edf51378994f877d2a17ecd6b7901a3000000000000000000000000cb50bb8da47becfed8a5fb78f089f0a1b19b99b3000000000000000000000000fa711411cc498f6c2a6babb28c254c2fb58b0308000000000000000000000000cc734cebf6bd685e1d74ac6b09bf2fca867d7791","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}