{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interface/ILiquidityProtection.sol\r\n\r\npragma solidity >=0.6.0;\r\n\r\n\r\ninterface IConverterAnchor {\r\n\r\n}\r\n\r\ninterface ILiquidityProtection {\r\n    function addLiquidity(\r\n        IConverterAnchor _poolAnchor,\r\n        IERC20 _reserveToken,\r\n        uint256 _amount\r\n    ) external payable returns(uint);\r\n    // returns id of deposit\r\n\r\n    function removeLiquidity(uint256 _id, uint32 _portion) external;\r\n\r\n    function removeLiquidityReturn(\r\n        uint256 _id,\r\n        uint32 _portion,\r\n        uint256 _removeTimestamp\r\n    ) external view returns (uint256, uint256, uint256);\r\n    // returns amount in the reserve token\r\n    // returns actual return amount in the reserve token\r\n    // returns compensation in the network token\r\n\r\n    // call 24 hours after removing liquidity\r\n    function claimBalance(uint256 _startIndex, uint256 _endIndex) external;\r\n}\r\n\r\n// File: contracts/interface/IStakingRewards.sol\r\n\r\npragma solidity >=0.6.0;\r\n\r\ninterface IDSToken {\r\n\r\n}\r\n\r\ninterface IStakingRewards {\r\n    // claims all rewards from providing address\r\n    function claimRewards() external returns (uint256);\r\n    // returns pending rewards from providing address\r\n    function pendingRewards(address provider) external view returns (uint256);\r\n    // returns all staked rewards and the ID of the new position\r\n    function stakeRewards(uint256 maxAmount, IDSToken poolToken) external returns (uint256, uint256);\r\n}\r\n\r\n// File: contracts/interface/IContractRegistry.sol\r\n\r\npragma solidity >=0.6.0;\r\n\r\ninterface IContractRegistry {\r\n    function addressOf(bytes32 contractName) external view returns(address);\r\n}\r\n\r\n// File: contracts/interface/IxBNT.sol\r\n\r\npragma solidity 0.6.2;\r\n\r\ninterface IxBNT {\r\n    function getProxyAddressDepositIds(address proxyAddress) external view returns(uint256[] memory);\r\n}\r\n\r\n// File: contracts/helpers/LiquidityProvider.sol\r\n\r\npragma solidity 0.6.2;\r\n\r\n\r\n\r\n\r\n\r\ncontract LiquidityProvider {\r\n    bool private initialized;\r\n\r\n    IContractRegistry private contractRegistry;\r\n    IERC20 private bnt;\r\n    IERC20 private vbnt;\r\n\r\n    address private xbnt;\r\n    uint256 public nextDepositIndexToClaimBalance;\r\n\r\n    function initializeAndAddLiquidity(\r\n        IContractRegistry _contractRegistry,\r\n        address _xbnt,\r\n        IERC20 _bnt,\r\n        IERC20 _vbnt,\r\n        address _poolToken,\r\n        uint256 _amount\r\n    ) external returns(uint256) {\r\n        require(msg.sender == _xbnt, \"Invalid caller\");\r\n        require(!initialized, \"Already initialized\");\r\n        initialized = true;\r\n\r\n        contractRegistry = _contractRegistry;\r\n        xbnt = _xbnt;\r\n        bnt = _bnt;\r\n        vbnt = _vbnt;\r\n\r\n        return _addLiquidity(_poolToken, _amount);\r\n    }\r\n\r\n    function _addLiquidity(\r\n        address _poolToken,\r\n        uint256 _amount\r\n    ) private returns(uint256 id) {\r\n        ILiquidityProtection lp = getLiquidityProtectionContract();\r\n        bnt.approve(address(lp), uint(-1));\r\n\r\n        id = lp.addLiquidity(IConverterAnchor(_poolToken), bnt, _amount);\r\n\r\n        _retrieveVbntBalance();\r\n    }\r\n\r\n    /*\r\n     * @notice Restake this proxy's rewards\r\n     */\r\n    function claimAndRestake(address _poolToken) external onlyXbntContract returns(uint256 newDepositId, uint256 restakedBal){\r\n        (, newDepositId) = getStakingRewardsContract().stakeRewards(uint(-1), IDSToken(_poolToken));\r\n        restakedBal = _retrieveVbntBalance();\r\n    }\r\n\r\n    function claimRewards() external onlyXbntContract returns(uint256 rewardsAmount){\r\n        rewardsAmount = _claimRewards();\r\n    }\r\n\r\n    function _claimRewards() private returns(uint256 rewards){\r\n        rewards = getStakingRewardsContract().claimRewards();\r\n        _retrieveBntBalance();\r\n    }\r\n\r\n    function _removeLiquidity(ILiquidityProtection _lp, uint256 _id) private {\r\n        _lp.removeLiquidity(_id, 1000000); // full PPM resolution\r\n    }\r\n\r\n    /*\r\n     * @notice Initiate final exit from this proxy\r\n     */\r\n    function claimRewardsAndRemoveLiquidity() external onlyXbntContract returns(uint256 rewards) {\r\n        rewards = _claimRewards();\r\n        uint256[] memory depositIds = getDepositIds();\r\n\r\n        ILiquidityProtection lp = getLiquidityProtectionContract();\r\n        vbnt.approve(address(lp), uint(-1));\r\n\r\n        for(uint256 i = 0; i < depositIds.length; i++){\r\n            _removeLiquidity(lp, depositIds[i]);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @notice Called 24 hours after `claimRewardsAndRemoveLiquidity`\r\n     */\r\n    function claimBalance() external onlyXbntContract {\r\n        getLiquidityProtectionContract().claimBalance(0, getDepositIds().length);\r\n        _retrieveBntBalance();\r\n    }\r\n\r\n    function _retrieveBntBalance() private {\r\n        bnt.transfer(xbnt, bnt.balanceOf(address(this)));\r\n    }\r\n\r\n    function _retrieveVbntBalance() private returns(uint256 vbntBal) {\r\n        vbntBal = vbnt.balanceOf(address(this));\r\n        vbnt.transfer(xbnt, vbntBal);\r\n    }\r\n\r\n    function pendingRewards() external view returns(uint){\r\n        return getStakingRewardsContract().pendingRewards(address(this));\r\n    }\r\n\r\n    function getStakingRewardsContract() private view returns(IStakingRewards){\r\n        return IStakingRewards(contractRegistry.addressOf(\"StakingRewards\"));\r\n    }\r\n\r\n    function getLiquidityProtectionContract() private view returns(ILiquidityProtection){\r\n        return ILiquidityProtection(contractRegistry.addressOf(\"LiquidityProtection\"));\r\n    }\r\n\r\n    function getDepositIds() private view returns(uint256[] memory){\r\n        return IxBNT(xbnt).getProxyAddressDepositIds(address(this));\r\n    }\r\n\r\n    modifier onlyXbntContract {\r\n        require(msg.sender == xbnt, \"Invalid caller\");\r\n        _;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"claimAndRestake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newDepositId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restakedBal\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardsAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewardsAndRemoveLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"_contractRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_xbnt\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_bnt\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_vbnt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"initializeAndAddLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextDepositIndexToClaimBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LiquidityProvider","CompilerVersion":"v0.6.2+commit.bacdbe57","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4314bc3d7a0a9e4cae53ed24812b31836424e060822d402887211ad852b610c8"}]}