{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/bridge/AdminControlled.sol\r\n\r\npragma solidity ^0.6;\r\n\r\ncontract AdminControlled {\r\n    address public admin;\r\n    uint public paused;\r\n\r\n    constructor(address _admin, uint flags) public {\r\n        admin = _admin;\r\n        paused = flags;\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier pausable(uint flag) {\r\n        require((paused & flag) == 0 || msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    function adminPause(uint flags) public onlyAdmin {\r\n        paused = flags;\r\n    }\r\n\r\n    function adminSstore(uint key, uint value) public onlyAdmin {\r\n        assembly {\r\n            sstore(key, value)\r\n        }\r\n    }\r\n\r\n    function adminSstoreWithMask(\r\n        uint key,\r\n        uint value,\r\n        uint mask\r\n    ) public onlyAdmin {\r\n        assembly {\r\n            let oldval := sload(key)\r\n            sstore(key, xor(and(xor(value, oldval), mask), oldval))\r\n        }\r\n    }\r\n\r\n    function adminSendEth(address payable destination, uint amount) public onlyAdmin {\r\n        destination.transfer(amount);\r\n    }\r\n\r\n    function adminReceiveEth() public payable onlyAdmin {}\r\n\r\n    function adminDelegatecall(address target, bytes memory data) public payable onlyAdmin returns (bytes memory) {\r\n        (bool success, bytes memory rdata) = target.delegatecall(data);\r\n        require(success);\r\n        return rdata;\r\n    }\r\n}\r\n\r\n// File: contracts/bridge/INearBridge.sol\r\n\r\npragma solidity ^0.6;\r\n\r\ninterface INearBridge {\r\n    event BlockHashAdded(uint64 indexed height, bytes32 blockHash);\r\n\r\n    event BlockHashReverted(uint64 indexed height, bytes32 blockHash);\r\n\r\n    function blockHashes(uint64 blockNumber) external view returns (bytes32);\r\n\r\n    function blockMerkleRoots(uint64 blockNumber) external view returns (bytes32);\r\n\r\n    function balanceOf(address wallet) external view returns (uint256);\r\n\r\n    function deposit() external payable;\r\n\r\n    function withdraw() external;\r\n\r\n    function initWithValidators(bytes calldata initialValidators) external;\r\n\r\n    function initWithBlock(bytes calldata data) external;\r\n\r\n    function addLightClientBlock(bytes calldata data) external;\r\n\r\n    function challenge(address payable receiver, uint256 signatureIndex) external;\r\n\r\n    function checkBlockProducerSignatureInHead(uint256 signatureIndex) external view returns (bool);\r\n}\r\n\r\n// File: contracts/bridge/Borsh.sol\r\n\r\npragma solidity ^0.6;\r\n\r\n\r\nlibrary Borsh {\r\n    using SafeMath for uint256;\r\n\r\n    struct Data {\r\n        uint256 offset;\r\n        bytes raw;\r\n    }\r\n\r\n    function from(bytes memory data) internal pure returns (Data memory) {\r\n        return Data({offset: 0, raw: data});\r\n    }\r\n\r\n    modifier shift(Data memory data, uint256 size) {\r\n        require(data.raw.length >= data.offset + size, \"Borsh: Out of range\");\r\n        _;\r\n        data.offset += size;\r\n    }\r\n\r\n    function finished(Data memory data) internal pure returns (bool) {\r\n        return data.offset == data.raw.length;\r\n    }\r\n\r\n    function peekKeccak256(Data memory data, uint256 length) internal pure returns (bytes32 res) {\r\n        return bytesKeccak256(data.raw, data.offset, length);\r\n    }\r\n\r\n    function bytesKeccak256(\r\n        bytes memory ptr,\r\n        uint256 offset,\r\n        uint256 length\r\n    ) internal pure returns (bytes32 res) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            res := keccak256(add(add(ptr, 32), offset), length)\r\n        }\r\n    }\r\n\r\n    function peekSha256(Data memory data, uint256 length) internal view returns (bytes32) {\r\n        return bytesSha256(data.raw, data.offset, length);\r\n    }\r\n\r\n    function bytesSha256(\r\n        bytes memory ptr,\r\n        uint256 offset,\r\n        uint256 length\r\n    ) internal view returns (bytes32) {\r\n        bytes32[1] memory result;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            pop(staticcall(gas(), 0x02, add(add(ptr, 32), offset), length, result, 32))\r\n        }\r\n        return result[0];\r\n    }\r\n\r\n    function decodeU8(Data memory data) internal pure shift(data, 1) returns (uint8 value) {\r\n        value = uint8(data.raw[data.offset]);\r\n    }\r\n\r\n    function decodeI8(Data memory data) internal pure shift(data, 1) returns (int8 value) {\r\n        value = int8(data.raw[data.offset]);\r\n    }\r\n\r\n    function decodeU16(Data memory data) internal pure returns (uint16 value) {\r\n        value = uint16(decodeU8(data));\r\n        value |= (uint16(decodeU8(data)) << 8);\r\n    }\r\n\r\n    function decodeI16(Data memory data) internal pure returns (int16 value) {\r\n        value = int16(decodeI8(data));\r\n        value |= (int16(decodeI8(data)) << 8);\r\n    }\r\n\r\n    function decodeU32(Data memory data) internal pure returns (uint32 value) {\r\n        value = uint32(decodeU16(data));\r\n        value |= (uint32(decodeU16(data)) << 16);\r\n    }\r\n\r\n    function decodeI32(Data memory data) internal pure returns (int32 value) {\r\n        value = int32(decodeI16(data));\r\n        value |= (int32(decodeI16(data)) << 16);\r\n    }\r\n\r\n    function decodeU64(Data memory data) internal pure returns (uint64 value) {\r\n        value = uint64(decodeU32(data));\r\n        value |= (uint64(decodeU32(data)) << 32);\r\n    }\r\n\r\n    function decodeI64(Data memory data) internal pure returns (int64 value) {\r\n        value = int64(decodeI32(data));\r\n        value |= (int64(decodeI32(data)) << 32);\r\n    }\r\n\r\n    function decodeU128(Data memory data) internal pure returns (uint128 value) {\r\n        value = uint128(decodeU64(data));\r\n        value |= (uint128(decodeU64(data)) << 64);\r\n    }\r\n\r\n    function decodeI128(Data memory data) internal pure returns (int128 value) {\r\n        value = int128(decodeI64(data));\r\n        value |= (int128(decodeI64(data)) << 64);\r\n    }\r\n\r\n    function decodeU256(Data memory data) internal pure returns (uint256 value) {\r\n        value = uint256(decodeU128(data));\r\n        value |= (uint256(decodeU128(data)) << 128);\r\n    }\r\n\r\n    function decodeI256(Data memory data) internal pure returns (int256 value) {\r\n        value = int256(decodeI128(data));\r\n        value |= (int256(decodeI128(data)) << 128);\r\n    }\r\n\r\n    function decodeBool(Data memory data) internal pure returns (bool value) {\r\n        value = (decodeU8(data) != 0);\r\n    }\r\n\r\n    function decodeBytes(Data memory data) internal pure returns (bytes memory value) {\r\n        value = new bytes(decodeU32(data));\r\n        for (uint i = 0; i < value.length; i++) {\r\n            value[i] = byte(decodeU8(data));\r\n        }\r\n    }\r\n\r\n    function decodeBytes32(Data memory data) internal pure shift(data, 32) returns (bytes32 value) {\r\n        bytes memory raw = data.raw;\r\n        uint256 offset = data.offset;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            value := mload(add(add(raw, 32), offset))\r\n        }\r\n    }\r\n\r\n    function decodeBytes20(Data memory data) internal pure returns (bytes20 value) {\r\n        for (uint i = 0; i < 20; i++) {\r\n            value |= bytes20(byte(decodeU8(data)) & 0xFF) >> (i * 8);\r\n        }\r\n    }\r\n\r\n    // Public key\r\n\r\n    struct SECP256K1PublicKey {\r\n        uint256 x;\r\n        uint256 y;\r\n    }\r\n\r\n    function decodeSECP256K1PublicKey(Borsh.Data memory data) internal pure returns (SECP256K1PublicKey memory key) {\r\n        key.x = decodeU256(data);\r\n        key.y = decodeU256(data);\r\n    }\r\n\r\n    struct ED25519PublicKey {\r\n        bytes32 xy;\r\n    }\r\n\r\n    function decodeED25519PublicKey(Borsh.Data memory data) internal pure returns (ED25519PublicKey memory key) {\r\n        key.xy = decodeBytes32(data);\r\n    }\r\n\r\n    // Signature\r\n\r\n    struct SECP256K1Signature {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n    }\r\n\r\n    function decodeSECP256K1Signature(Borsh.Data memory data) internal pure returns (SECP256K1Signature memory sig) {\r\n        sig.r = decodeBytes32(data);\r\n        sig.s = decodeBytes32(data);\r\n        sig.v = decodeU8(data);\r\n    }\r\n\r\n    struct ED25519Signature {\r\n        bytes32[2] rs;\r\n    }\r\n\r\n    function decodeED25519Signature(Borsh.Data memory data) internal pure returns (ED25519Signature memory sig) {\r\n        sig.rs[0] = decodeBytes32(data);\r\n        sig.rs[1] = decodeBytes32(data);\r\n    }\r\n}\r\n\r\n// File: contracts/bridge/NearDecoder.sol\r\n\r\npragma solidity ^0.6;\r\n\r\n\r\n\r\nlibrary NearDecoder {\r\n    using Borsh for Borsh.Data;\r\n    using NearDecoder for Borsh.Data;\r\n\r\n    struct PublicKey {\r\n        uint8 enumIndex;\r\n        Borsh.ED25519PublicKey ed25519;\r\n        Borsh.SECP256K1PublicKey secp256k1;\r\n    }\r\n\r\n    function decodePublicKey(Borsh.Data memory data) internal pure returns (PublicKey memory key) {\r\n        key.enumIndex = data.decodeU8();\r\n\r\n        if (key.enumIndex == 0) {\r\n            key.ed25519 = data.decodeED25519PublicKey();\r\n        } else if (key.enumIndex == 1) {\r\n            key.secp256k1 = data.decodeSECP256K1PublicKey();\r\n        } else {\r\n            revert(\"NearBridge: Only ED25519 and SECP256K1 public keys are supported\");\r\n        }\r\n    }\r\n\r\n    struct ValidatorStake {\r\n        string account_id;\r\n        PublicKey public_key;\r\n        uint128 stake;\r\n    }\r\n\r\n    function decodeValidatorStake(Borsh.Data memory data) internal pure returns (ValidatorStake memory validatorStake) {\r\n        validatorStake.account_id = string(data.decodeBytes());\r\n        validatorStake.public_key = data.decodePublicKey();\r\n        validatorStake.stake = data.decodeU128();\r\n    }\r\n\r\n    struct OptionalValidatorStakes {\r\n        bool none;\r\n        ValidatorStake[] validatorStakes;\r\n        bytes32 hash; // Additional computable element\r\n    }\r\n\r\n    function decodeOptionalValidatorStakes(Borsh.Data memory data)\r\n        internal\r\n        view\r\n        returns (OptionalValidatorStakes memory stakes)\r\n    {\r\n        stakes.none = (data.decodeU8() == 0);\r\n        if (!stakes.none) {\r\n            uint256 start = data.offset;\r\n\r\n            stakes.validatorStakes = new ValidatorStake[](data.decodeU32());\r\n            for (uint i = 0; i < stakes.validatorStakes.length; i++) {\r\n                stakes.validatorStakes[i] = data.decodeValidatorStake();\r\n            }\r\n\r\n            uint256 stop = data.offset;\r\n            data.offset = start;\r\n            stakes.hash = data.peekSha256(stop - start);\r\n            data.offset = stop;\r\n        }\r\n    }\r\n\r\n    struct Signature {\r\n        uint8 enumIndex;\r\n        Borsh.ED25519Signature ed25519;\r\n        Borsh.SECP256K1Signature secp256k1;\r\n    }\r\n\r\n    function decodeSignature(Borsh.Data memory data) internal pure returns (Signature memory sig) {\r\n        sig.enumIndex = data.decodeU8();\r\n\r\n        if (sig.enumIndex == 0) {\r\n            sig.ed25519 = data.decodeED25519Signature();\r\n        } else if (sig.enumIndex == 1) {\r\n            sig.secp256k1 = data.decodeSECP256K1Signature();\r\n        } else {\r\n            revert(\"NearBridge: Only ED25519 and SECP256K1 signatures are supported\");\r\n        }\r\n    }\r\n\r\n    struct OptionalSignature {\r\n        bool none;\r\n        Signature signature;\r\n    }\r\n\r\n    function decodeOptionalSignature(Borsh.Data memory data) internal pure returns (OptionalSignature memory sig) {\r\n        sig.none = (data.decodeU8() == 0);\r\n        if (!sig.none) {\r\n            sig.signature = data.decodeSignature();\r\n        }\r\n    }\r\n\r\n    struct LightClientBlock {\r\n        bytes32 prev_block_hash;\r\n        bytes32 next_block_inner_hash;\r\n        BlockHeaderInnerLite inner_lite;\r\n        bytes32 inner_rest_hash;\r\n        OptionalValidatorStakes next_bps;\r\n        OptionalSignature[] approvals_after_next;\r\n        bytes32 hash;\r\n        bytes32 next_hash;\r\n    }\r\n\r\n    struct InitialValidators {\r\n        ValidatorStake[] validator_stakes;\r\n    }\r\n\r\n    function decodeInitialValidators(Borsh.Data memory data)\r\n        internal\r\n        view\r\n        returns (InitialValidators memory validators)\r\n    {\r\n        validators.validator_stakes = new ValidatorStake[](data.decodeU32());\r\n        for (uint i = 0; i < validators.validator_stakes.length; i++) {\r\n            validators.validator_stakes[i] = data.decodeValidatorStake();\r\n        }\r\n    }\r\n\r\n    function decodeLightClientBlock(Borsh.Data memory data) internal view returns (LightClientBlock memory header) {\r\n        header.prev_block_hash = data.decodeBytes32();\r\n        header.next_block_inner_hash = data.decodeBytes32();\r\n        header.inner_lite = data.decodeBlockHeaderInnerLite();\r\n        header.inner_rest_hash = data.decodeBytes32();\r\n        header.next_bps = data.decodeOptionalValidatorStakes();\r\n\r\n        header.approvals_after_next = new OptionalSignature[](data.decodeU32());\r\n        for (uint i = 0; i < header.approvals_after_next.length; i++) {\r\n            header.approvals_after_next[i] = data.decodeOptionalSignature();\r\n        }\r\n\r\n        header.hash = sha256(\r\n            abi.encodePacked(\r\n                sha256(abi.encodePacked(header.inner_lite.hash, header.inner_rest_hash)),\r\n                header.prev_block_hash\r\n            )\r\n        );\r\n\r\n        header.next_hash = sha256(abi.encodePacked(header.next_block_inner_hash, header.hash));\r\n    }\r\n\r\n    struct BlockHeaderInnerLite {\r\n        uint64 height; /// Height of this block since the genesis block (height 0).\r\n        bytes32 epoch_id; /// Epoch start hash of this block's epoch. Used for retrieving validator information\r\n        bytes32 next_epoch_id;\r\n        bytes32 prev_state_root; /// Root hash of the state at the previous block.\r\n        bytes32 outcome_root; /// Root of the outcomes of transactions and receipts.\r\n        uint64 timestamp; /// Timestamp at which the block was built.\r\n        bytes32 next_bp_hash; /// Hash of the next epoch block producers set\r\n        bytes32 block_merkle_root;\r\n        bytes32 hash; // Additional computable element\r\n    }\r\n\r\n    function decodeBlockHeaderInnerLite(Borsh.Data memory data)\r\n        internal\r\n        view\r\n        returns (BlockHeaderInnerLite memory header)\r\n    {\r\n        header.hash = data.peekSha256(208);\r\n        header.height = data.decodeU64();\r\n        header.epoch_id = data.decodeBytes32();\r\n        header.next_epoch_id = data.decodeBytes32();\r\n        header.prev_state_root = data.decodeBytes32();\r\n        header.outcome_root = data.decodeBytes32();\r\n        header.timestamp = data.decodeU64();\r\n        header.next_bp_hash = data.decodeBytes32();\r\n        header.block_merkle_root = data.decodeBytes32();\r\n    }\r\n}\r\n\r\n// File: contracts/ProofDecoder.sol\r\n\r\npragma solidity ^0.6;\r\n\r\n\r\n\r\nlibrary ProofDecoder {\r\n    using Borsh for Borsh.Data;\r\n    using ProofDecoder for Borsh.Data;\r\n    using NearDecoder for Borsh.Data;\r\n\r\n    struct FullOutcomeProof {\r\n        ExecutionOutcomeWithIdAndProof outcome_proof;\r\n        MerklePath outcome_root_proof; // TODO: now empty array\r\n        BlockHeaderLight block_header_lite;\r\n        MerklePath block_proof;\r\n    }\r\n\r\n    function decodeFullOutcomeProof(Borsh.Data memory data) internal view returns (FullOutcomeProof memory proof) {\r\n        proof.outcome_proof = data.decodeExecutionOutcomeWithIdAndProof();\r\n        proof.outcome_root_proof = data.decodeMerklePath();\r\n        proof.block_header_lite = data.decodeBlockHeaderLight();\r\n        proof.block_proof = data.decodeMerklePath();\r\n    }\r\n\r\n    struct BlockHeaderLight {\r\n        bytes32 prev_block_hash;\r\n        bytes32 inner_rest_hash;\r\n        NearDecoder.BlockHeaderInnerLite inner_lite;\r\n        bytes32 hash; // Computable\r\n    }\r\n\r\n    function decodeBlockHeaderLight(Borsh.Data memory data) internal view returns (BlockHeaderLight memory header) {\r\n        header.prev_block_hash = data.decodeBytes32();\r\n        header.inner_rest_hash = data.decodeBytes32();\r\n        header.inner_lite = data.decodeBlockHeaderInnerLite();\r\n\r\n        header.hash = sha256(\r\n            abi.encodePacked(\r\n                sha256(abi.encodePacked(header.inner_lite.hash, header.inner_rest_hash)),\r\n                header.prev_block_hash\r\n            )\r\n        );\r\n    }\r\n\r\n    struct ExecutionStatus {\r\n        uint8 enumIndex;\r\n        bool unknown;\r\n        bool failed;\r\n        bytes successValue; /// The final action succeeded and returned some value or an empty vec.\r\n        bytes32 successReceiptId; /// The final action of the receipt returned a promise or the signed\r\n        /// transaction was converted to a receipt. Contains the receipt_id of the generated receipt.\r\n    }\r\n\r\n    function decodeExecutionStatus(Borsh.Data memory data)\r\n        internal\r\n        pure\r\n        returns (ExecutionStatus memory executionStatus)\r\n    {\r\n        executionStatus.enumIndex = data.decodeU8();\r\n        if (executionStatus.enumIndex == 0) {\r\n            executionStatus.unknown = true;\r\n        } else if (executionStatus.enumIndex == 1) {\r\n            //revert(\"NearDecoder: decodeExecutionStatus failure case not implemented yet\");\r\n            // Can avoid revert since ExecutionStatus is latest field in all parent structures\r\n            executionStatus.failed = true;\r\n        } else if (executionStatus.enumIndex == 2) {\r\n            executionStatus.successValue = data.decodeBytes();\r\n        } else if (executionStatus.enumIndex == 3) {\r\n            executionStatus.successReceiptId = data.decodeBytes32();\r\n        } else {\r\n            revert(\"NearDecoder: decodeExecutionStatus index out of range\");\r\n        }\r\n    }\r\n\r\n    struct ExecutionOutcome {\r\n        bytes[] logs; /// Logs from this transaction or receipt.\r\n        bytes32[] receipt_ids; /// Receipt IDs generated by this transaction or receipt.\r\n        uint64 gas_burnt; /// The amount of the gas burnt by the given transaction or receipt.\r\n        uint128 tokens_burnt; /// The total number of the tokens burnt by the given transaction or receipt.\r\n        bytes executor_id; /// Hash of the transaction or receipt id that produced this outcome.\r\n        ExecutionStatus status; /// Execution status. Contains the result in case of successful execution.\r\n        bytes32[] merkelization_hashes;\r\n    }\r\n\r\n    function decodeExecutionOutcome(Borsh.Data memory data) internal view returns (ExecutionOutcome memory outcome) {\r\n        outcome.logs = new bytes[](data.decodeU32());\r\n        for (uint i = 0; i < outcome.logs.length; i++) {\r\n            outcome.logs[i] = data.decodeBytes();\r\n        }\r\n\r\n        uint256 start = data.offset;\r\n        outcome.receipt_ids = new bytes32[](data.decodeU32());\r\n        for (uint i = 0; i < outcome.receipt_ids.length; i++) {\r\n            outcome.receipt_ids[i] = data.decodeBytes32();\r\n        }\r\n        outcome.gas_burnt = data.decodeU64();\r\n        outcome.tokens_burnt = data.decodeU128();\r\n        outcome.executor_id = data.decodeBytes();\r\n        outcome.status = data.decodeExecutionStatus();\r\n        uint256 stop = data.offset;\r\n\r\n        outcome.merkelization_hashes = new bytes32[](1 + outcome.logs.length);\r\n        data.offset = start;\r\n        outcome.merkelization_hashes[0] = data.peekSha256(stop - start);\r\n        data.offset = stop;\r\n        for (uint i = 0; i < outcome.logs.length; i++) {\r\n            outcome.merkelization_hashes[i + 1] = sha256(outcome.logs[i]);\r\n        }\r\n    }\r\n\r\n    struct ExecutionOutcomeWithId {\r\n        bytes32 id; /// The transaction hash or the receipt ID.\r\n        ExecutionOutcome outcome;\r\n        bytes32 hash;\r\n    }\r\n\r\n    function decodeExecutionOutcomeWithId(Borsh.Data memory data)\r\n        internal\r\n        view\r\n        returns (ExecutionOutcomeWithId memory outcome)\r\n    {\r\n        outcome.id = data.decodeBytes32();\r\n        outcome.outcome = data.decodeExecutionOutcome();\r\n\r\n        uint256 len = 1 + outcome.outcome.merkelization_hashes.length;\r\n        outcome.hash = sha256(\r\n            abi.encodePacked(\r\n                uint8((len >> 0) & 0xFF),\r\n                uint8((len >> 8) & 0xFF),\r\n                uint8((len >> 16) & 0xFF),\r\n                uint8((len >> 24) & 0xFF),\r\n                outcome.id,\r\n                outcome.outcome.merkelization_hashes\r\n            )\r\n        );\r\n    }\r\n\r\n    struct MerklePathItem {\r\n        bytes32 hash;\r\n        uint8 direction; // 0 = left, 1 = right\r\n    }\r\n\r\n    function decodeMerklePathItem(Borsh.Data memory data) internal pure returns (MerklePathItem memory item) {\r\n        item.hash = data.decodeBytes32();\r\n        item.direction = data.decodeU8();\r\n        require(item.direction < 2, \"ProofDecoder: MerklePathItem direction should be 0 or 1\");\r\n    }\r\n\r\n    struct MerklePath {\r\n        MerklePathItem[] items;\r\n    }\r\n\r\n    function decodeMerklePath(Borsh.Data memory data) internal pure returns (MerklePath memory path) {\r\n        path.items = new MerklePathItem[](data.decodeU32());\r\n        for (uint i = 0; i < path.items.length; i++) {\r\n            path.items[i] = data.decodeMerklePathItem();\r\n        }\r\n    }\r\n\r\n    struct ExecutionOutcomeWithIdAndProof {\r\n        MerklePath proof;\r\n        bytes32 block_hash;\r\n        ExecutionOutcomeWithId outcome_with_id;\r\n    }\r\n\r\n    function decodeExecutionOutcomeWithIdAndProof(Borsh.Data memory data)\r\n        internal\r\n        view\r\n        returns (ExecutionOutcomeWithIdAndProof memory outcome)\r\n    {\r\n        outcome.proof = data.decodeMerklePath();\r\n        outcome.block_hash = data.decodeBytes32();\r\n        outcome.outcome_with_id = data.decodeExecutionOutcomeWithId();\r\n    }\r\n}\r\n\r\n// File: contracts/INearProver.sol\r\n\r\npragma solidity ^0.6;\r\n\r\ninterface INearProver {\r\n    function proveOutcome(bytes calldata proofData, uint64 blockHeight) external view returns (bool);\r\n}\r\n\r\n// File: contracts/NearProver.sol\r\n\r\npragma solidity ^0.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract NearProver is INearProver, AdminControlled {\r\n    using SafeMath for uint256;\r\n    using Borsh for Borsh.Data;\r\n    using NearDecoder for Borsh.Data;\r\n    using ProofDecoder for Borsh.Data;\r\n\r\n    INearBridge public bridge;\r\n\r\n    constructor(\r\n        INearBridge _bridge,\r\n        address _admin,\r\n        uint _pausedFlags\r\n    ) public AdminControlled(_admin, _pausedFlags) {\r\n        bridge = _bridge;\r\n    }\r\n\r\n    uint constant UNPAUSE_ALL = 0;\r\n    uint constant PAUSED_VERIFY = 1;\r\n\r\n    function proveOutcome(bytes memory proofData, uint64 blockHeight)\r\n        public\r\n        view\r\n        override\r\n        pausable(PAUSED_VERIFY)\r\n        returns (bool)\r\n    {\r\n        Borsh.Data memory borshData = Borsh.from(proofData);\r\n        ProofDecoder.FullOutcomeProof memory fullOutcomeProof = borshData.decodeFullOutcomeProof();\r\n        require(borshData.finished(), \"NearProver: argument should be exact borsh serialization\");\r\n\r\n        bytes32 hash =\r\n            _computeRoot(fullOutcomeProof.outcome_proof.outcome_with_id.hash, fullOutcomeProof.outcome_proof.proof);\r\n\r\n        hash = sha256(abi.encodePacked(hash));\r\n\r\n        hash = _computeRoot(hash, fullOutcomeProof.outcome_root_proof);\r\n\r\n        require(\r\n            hash == fullOutcomeProof.block_header_lite.inner_lite.outcome_root,\r\n            \"NearProver: outcome merkle proof is not valid\"\r\n        );\r\n\r\n        bytes32 expectedBlockMerkleRoot = bridge.blockMerkleRoots(blockHeight);\r\n\r\n        require(\r\n            _computeRoot(fullOutcomeProof.block_header_lite.hash, fullOutcomeProof.block_proof) ==\r\n                expectedBlockMerkleRoot,\r\n            \"NearProver: block proof is not valid\"\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    function _computeRoot(bytes32 node, ProofDecoder.MerklePath memory proof) internal pure returns (bytes32 hash) {\r\n        hash = node;\r\n        for (uint i = 0; i < proof.items.length; i++) {\r\n            ProofDecoder.MerklePathItem memory item = proof.items[i];\r\n            if (item.direction == 0) {\r\n                hash = sha256(abi.encodePacked(item.hash, hash));\r\n            } else {\r\n                hash = sha256(abi.encodePacked(hash, item.hash));\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract INearBridge\",\"name\":\"_bridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pausedFlags\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"adminDelegatecall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"name\":\"adminPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminReceiveEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"adminSendEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"adminSstore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mask\",\"type\":\"uint256\"}],\"name\":\"adminSstoreWithMask\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contract INearBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"blockHeight\",\"type\":\"uint64\"}],\"name\":\"proveOutcome\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"NearProver","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ce9d8c70c2ac161383c4debf207d884f6531b1b9000000000000000000000000bf7aad3498a66e8722a897b3c5ede45c2c25fb820000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://001bfb295ddf2c98c3a1a19c9aac9ef41c24672f7234947edbf86f10f1017536"}]}