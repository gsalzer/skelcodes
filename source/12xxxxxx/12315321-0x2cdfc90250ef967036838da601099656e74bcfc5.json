{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n * Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``\\u0027s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"},\"IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\nimport \\\"IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"},\"IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"},\"IEthCrossChainManager.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\n\\n/**\\n * @dev Interface of the EthCrossChainManager contract for business contract like LockProxy to request cross chain transaction\\n */\\ninterface IEthCrossChainManager {\\n    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\\n}\\n\"},\"IEthCrossChainManagerProxy.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\n\\n/**\\n * @dev Interface of the EthCrossChainManagerProxy for business contract like LockProxy to obtain the reliable EthCrossChainManager contract hash.\\n */\\ninterface IEthCrossChainManagerProxy {\\n    function getEthCrossChainManager() external view returns (address);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public  onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"PolyNFTLockProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"ZeroCopySink.sol\\\";\\nimport \\\"ZeroCopySource.sol\\\";\\nimport \\\"Utils.sol\\\";\\nimport \\\"Address.sol\\\";\\nimport \\\"IERC721Metadata.sol\\\";\\nimport \\\"IERC721Receiver.sol\\\";\\nimport \\\"SafeMath.sol\\\";\\nimport \\\"IEthCrossChainManager.sol\\\";\\nimport \\\"IEthCrossChainManagerProxy.sol\\\";\\n\\ncontract PolyNFTLockProxy is IERC721Receiver, Ownable {\\n    using SafeMath for uint;\\n    using Address for address;\\n\\n    struct TxArgs {\\n        bytes toAssetHash;\\n        bytes toAddress;\\n        uint256 tokenId;\\n        bytes tokenURI;\\n    }\\n\\n    address public managerProxyContract;\\n    mapping(uint64 =\\u003e bytes) public proxyHashMap;\\n    mapping(address =\\u003e mapping(uint64 =\\u003e bytes)) public assetHashMap;\\n    mapping(address =\\u003e bool) safeTransfer;\\n\\n    event SetManagerProxyEvent(address manager);\\n    event BindProxyEvent(uint64 toChainId, bytes targetProxyHash);\\n    event BindAssetEvent(address fromAssetHash, uint64 toChainId, bytes targetProxyHash);\\n    event UnlockEvent(address toAssetHash, address toAddress, uint256 tokenId);\\n    event LockEvent(address fromAssetHash, address fromAddress, bytes toAssetHash, bytes toAddress, uint64 toChainId, uint256 tokenId);\\n    \\n    modifier onlyManagerContract() {\\n        IEthCrossChainManagerProxy ieccmp = IEthCrossChainManagerProxy(managerProxyContract);\\n        require(_msgSender() == ieccmp.getEthCrossChainManager(), \\\"msgSender is not EthCrossChainManagerContract\\\");\\n        _;\\n    }\\n    \\n    function setManagerProxy(address ethCCMProxyAddr) onlyOwner public {\\n        managerProxyContract = ethCCMProxyAddr;\\n        emit SetManagerProxyEvent(managerProxyContract);\\n    }\\n    \\n    function bindProxyHash(uint64 toChainId, bytes memory targetProxyHash) onlyOwner public returns (bool) {\\n        proxyHashMap[toChainId] = targetProxyHash;\\n        emit BindProxyEvent(toChainId, targetProxyHash);\\n        return true;\\n    }\\n    \\n    function bindAssetHash(address fromAssetHash, uint64 toChainId, bytes memory toAssetHash) onlyOwner public returns (bool) {\\n        assetHashMap[fromAssetHash][toChainId] = toAssetHash;\\n        emit BindAssetEvent(fromAssetHash, toChainId, toAssetHash);\\n        return true;\\n    }\\n    \\n    // /* @notice                  This function is meant to be invoked by the ETH crosschain management contract,\\n    // *                           then mint a certin amount of tokens to the designated address since a certain amount \\n    // *                           was burnt from the source chain invoker.\\n    // *  @param argsBs            The argument bytes recevied by the ethereum lock proxy contract, need to be deserialized.\\n    // *                           based on the way of serialization in the source chain proxy contract.\\n    // *  @param fromContractAddr  The source chain contract address\\n    // *  @param fromChainId       The source chain id\\n    // */\\n    function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) public onlyManagerContract returns (bool) {\\n        TxArgs memory args = _deserializeTxArgs(argsBs);\\n\\n        require(fromContractAddr.length != 0, \\\"from proxy contract address cannot be empty\\\");\\n        require(Utils.equalStorage(proxyHashMap[fromChainId], fromContractAddr), \\\"From Proxy contract address error!\\\");\\n        \\n        require(args.toAssetHash.length != 0, \\\"toAssetHash cannot be empty\\\");\\n        address toAssetHash = Utils.bytesToAddress(args.toAssetHash);\\n\\n        require(args.toAddress.length != 0, \\\"toAddress cannot be empty\\\");\\n        address toAddress = Utils.bytesToAddress(args.toAddress);\\n        \\n        bool success;\\n        bytes memory res;\\n        address owner;\\n        bytes memory raw = abi.encodeWithSignature(\\\"ownerOf(uint256)\\\", args.tokenId);\\n        (success, res) = toAssetHash.call(raw);\\n        if (success) {\\n            owner = abi.decode(res, (address));\\n            require(owner == address(this) || owner == address(0), \\\"your token ID is not hold by lockproxy.\\\");\\n            if (owner == address(this)) {\\n                raw = abi.encodeWithSignature(\\\"safeTransferFrom(address,address,uint256)\\\", address(this), toAddress, args.tokenId);\\n                (success, ) = toAssetHash.call(raw);\\n                require(success, \\\"failed to call safeTransferFrom\\\");\\n            }\\n        }\\n        if (!success || owner == address(0)) {\\n            raw = abi.encodeWithSignature(\\\"mintWithURI(address,uint256,string)\\\", toAddress, args.tokenId, string(args.tokenURI));\\n            (success, ) = toAssetHash.call(raw);\\n            require(success, \\\"failed to call mintWithURI to mint a new mapping NFT\\\");\\n        }\\n        \\n        emit UnlockEvent(toAssetHash, toAddress, args.tokenId);\\n        return true;\\n    }\\n\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) public override returns (bytes4) {\\n        address fromAssetHash = _msgSender();\\n        require(data.length \\u003e 0, \\\"length of toAddress can\\u0027t be zero. \\\");\\n        require(fromAssetHash.isContract(), \\\"caller must be a contract. \\\");\\n            \\n        bytes memory toAddress;\\n        uint64 toChainId;\\n        bytes memory toAssetHash;\\n        {\\n            (toAddress, toChainId) = _deserializeCallData(data);\\n            toAssetHash = assetHashMap[fromAssetHash][toChainId];\\n            require(toAssetHash.length != 0, \\\"empty illegal toAssetHash\\\");\\n    \\n            IERC721Metadata nft = IERC721Metadata(fromAssetHash);\\n            require(nft.ownerOf(tokenId) == address(this), \\\"wrong owner for this token ID\\\");\\n    \\n            string memory uri = nft.tokenURI(tokenId);\\n            TxArgs memory txArgs = TxArgs({\\n                toAssetHash: toAssetHash,\\n                toAddress: toAddress,\\n                tokenId: tokenId,\\n                tokenURI: bytes(uri)\\n            });\\n            bytes memory txData = _serializeTxArgs(txArgs);\\n            IEthCrossChainManager eccm = IEthCrossChainManager(IEthCrossChainManagerProxy(managerProxyContract).getEthCrossChainManager());\\n            \\n            bytes memory toProxyHash = proxyHashMap[toChainId];\\n            require(toProxyHash.length != 0, \\\"empty illegal toProxyHash\\\");\\n            require(eccm.crossChain(toChainId, toProxyHash, \\\"unlock\\\", txData), \\\"EthCrossChainManager crossChain executed error!\\\");\\n        }\\n        {\\n            emit LockEvent(fromAssetHash, from, toAssetHash, toAddress, toChainId, tokenId);\\n        }\\n\\n        return this.onERC721Received.selector;\\n    }\\n    \\n    function _serializeTxArgs(TxArgs memory args) internal pure returns (bytes memory) {\\n        bytes memory buff;\\n        buff = abi.encodePacked(\\n            ZeroCopySink.WriteVarBytes(args.toAssetHash),\\n            ZeroCopySink.WriteVarBytes(args.toAddress),\\n            ZeroCopySink.WriteUint256(args.tokenId),\\n            ZeroCopySink.WriteVarBytes(args.tokenURI)\\n            );\\n        return buff;\\n    }\\n\\n    function _deserializeTxArgs(bytes memory valueBs) internal pure returns (TxArgs memory) {\\n        TxArgs memory args;\\n        uint256 off = 0;\\n        (args.toAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\\n        (args.toAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);\\n        (args.tokenId, off) = ZeroCopySource.NextUint256(valueBs, off);\\n        (args.tokenURI, off) = ZeroCopySource.NextVarBytes(valueBs, off);\\n        return args;\\n    }\\n    \\n    function _deserializeCallData(bytes memory valueBs) internal pure returns (bytes memory, uint64) {\\n        bytes memory toAddress;\\n        uint64 chainId;\\n        uint256 off = 0;\\n        (toAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);\\n        (chainId, off) = ZeroCopySource.NextUint64(valueBs, off);\\n        return (toAddress, chainId);\\n    }\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n */\\ncontract ReentrancyGuard {\\n    // counter to allow mutex lock with only one SSTORE operation\\n    uint256 private _guardCounter;\\n\\n    constructor () internal {\\n        // The counter starts at one to prevent changing it from zero to a non-zero\\n        // value, which is a more expensive operation.\\n        _guardCounter = 1;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _guardCounter += 1;\\n        uint256 localCounter = _guardCounter;\\n        _;\\n        require(localCounter == _guardCounter, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b != 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n\\nlibrary Utils {\\n\\n    /* @notice      Convert the bytes array to bytes32 type, the bytes array length must be 32\\n    *  @param _bs   Source bytes array\\n    *  @return      bytes32\\n    */\\n    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\\n        require(_bs.length == 32, \\\"bytes length is not 32.\\\");\\n        assembly {\\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\\n            value := mload(add(_bs, 0x20))\\n        }\\n    }\\n\\n    /* @notice      Convert bytes to uint256\\n    *  @param _b    Source bytes should have length of 32\\n    *  @return      uint256\\n    */\\n    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\\n        require(_bs.length == 32, \\\"bytes length is not 32.\\\");\\n        assembly {\\n            // load 32 bytes from memory starting from position _bs + 32\\n            value := mload(add(_bs, 0x20))\\n        }\\n        require(value \\u003c= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \\\"Value exceeds the range\\\");\\n    }\\n\\n    /* @notice      Convert uint256 to bytes\\n    *  @param _b    uint256 that needs to be converted\\n    *  @return      bytes\\n    */\\n    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\\n        require(_value \\u003c= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \\\"Value exceeds the range\\\");\\n        assembly {\\n            // Get a location of some free memory and store it in result as\\n            // Solidity does for memory variables.\\n            bs := mload(0x40)\\n            // Put 0x20 at the first word, the length of bytes for uint256 value\\n            mstore(bs, 0x20)\\n            //In the next word, put value in bytes format to the next 32 bytes\\n            mstore(add(bs, 0x20), _value)\\n            // Update the free-memory pointer by padding our last write location to 32 bytes\\n            mstore(0x40, add(bs, 0x40))\\n        }\\n    }\\n\\n    /* @notice      Convert bytes to address\\n    *  @param _bs   Source bytes: bytes length must be 20\\n    *  @return      Converted address from source bytes\\n    */\\n    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\\n    {\\n        require(_bs.length == 20, \\\"bytes length does not match address\\\");\\n        assembly {\\n            // for _bs, first word store _bs.length, second word store _bs.value\\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\\n            addr := mload(add(_bs, 0x14))\\n        }\\n\\n    }\\n    \\n    /* @notice      Convert address to bytes\\n    *  @param _addr Address need to be converted\\n    *  @return      Converted bytes from address\\n    */\\n    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\\n        assembly {\\n            // Get a location of some free memory and store it in result as\\n            // Solidity does for memory variables.\\n            bs := mload(0x40)\\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\\n            mstore(bs, 0x14)\\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\\n            mstore(add(bs, 0x20), shl(96, _addr))\\n            // Update the free-memory pointer by padding our last write location to 32 bytes\\n            mstore(0x40, add(bs, 0x40))\\n       }\\n    }\\n\\n    /* @notice          Do hash leaf as the multi-chain does\\n    *  @param _data     Data in bytes format\\n    *  @return          Hashed value in bytes32 format\\n    */\\n    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\\n        result = sha256(abi.encodePacked(byte(0x0), _data));\\n    }\\n\\n    /* @notice          Do hash children as the multi-chain does\\n    *  @param _l        Left node\\n    *  @param _r        Right node\\n    *  @return          Hashed value in bytes32 format\\n    */\\n    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\\n        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\\n    }\\n\\n    /* @notice              Compare if two bytes are equal, which are in storage and memory, seperately\\n                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L368\\n    *  @param _preBytes     The bytes stored in storage\\n    *  @param _postBytes    The bytes stored in memory\\n    *  @return              Bool type indicating if they are equal\\n    */\\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes_slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don\\u0027t match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // fslot can contain both the length and contents of the array\\n                // if slength \\u003c 32 bytes so let\\u0027s prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                // slength != 0\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there\\u0027s\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don\\u0027t breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes_slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint(mc \\u003c end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    /* @notice              Slice the _bytes from _start index till the result has length of _length\\n                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L246\\n    *  @param _bytes        The original bytes needs to be sliced\\n    *  @param _start        The index of _bytes for the start of sliced bytes\\n    *  @param _length       The index of _bytes for the end of sliced bytes\\n    *  @return              The sliced bytes\\n    */\\n    function slice(\\n        bytes memory _bytes,\\n        uint _start,\\n        uint _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_bytes.length \\u003e= (_start + _length));\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don\\u0027t care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we\\u0027re done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                // lengthmod \\u003c= _length % 32\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin\\u0027s length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let\\u0027s just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n    /* @notice              Check if the elements number of _signers within _keepers array is no less than _m\\n    *  @param _keepers      The array consists of serveral address\\n    *  @param _signers      Some specific addresses to be looked into\\n    *  @param _m            The number requirement paramter\\n    *  @return              True means containment, false meansdo do not contain.\\n    */\\n    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\\n        uint m = 0;\\n        for(uint i = 0; i \\u003c _signers.length; i++){\\n            for (uint j = 0; j \\u003c _keepers.length; j++) {\\n                if (_signers[i] == _keepers[j]) {\\n                    m++;\\n                    delete _keepers[j];\\n                }\\n            }\\n        }\\n        return m \\u003e= _m;\\n    }\\n\\n    /* @notice              TODO\\n    *  @param key\\n    *  @return\\n    */\\n    function compressMCPubKey(bytes memory key) internal pure returns (bytes memory newkey) {\\n         require(key.length \\u003e= 67, \\\"key lenggh is too short\\\");\\n         newkey = slice(key, 0, 35);\\n         if (uint8(key[66]) % 2 == 0){\\n             newkey[2] = byte(0x02);\\n         } else {\\n             newkey[2] = byte(0x03);\\n         }\\n         return newkey;\\n    }\\n    \\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *      Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L18\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\n     * function returns false is an externally-owned account (EOA) and not a\\n     * contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\n    }\\n}\"},\"ZeroCopySink.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over encoding and serialization operation into bytes from bassic types in Solidity for PolyNetwork cross chain utility.\\n *\\n * Encode basic types in Solidity into bytes easily. It\\u0027s designed to be used \\n * for PolyNetwork cross chain application, and the encoding rules on Ethereum chain \\n * and the decoding rules on other chains should be consistent. Here we  \\n * follow the underlying serialization rule with implementation found here: \\n * https://github.com/polynetwork/poly/blob/master/common/zero_copy_sink.go\\n *\\n * Using this library instead of the unchecked serialization method can help reduce\\n * the risk of serious bugs and handfule, so it\\u0027s recommended to use it.\\n *\\n * Please note that risk can be minimized, yet not eliminated.\\n */\\nlibrary ZeroCopySink {\\n    /* @notice          Convert boolean value into bytes\\n    *  @param b         The boolean value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteBool(bool b) internal pure returns (bytes memory) {\\n        bytes memory buff;\\n        assembly{\\n            buff := mload(0x40)\\n            mstore(buff, 1)\\n            switch iszero(b)\\n            case 1 {\\n                mstore(add(buff, 0x20), shl(248, 0x00))\\n                // mstore8(add(buff, 0x20), 0x00)\\n            }\\n            default {\\n                mstore(add(buff, 0x20), shl(248, 0x01))\\n                // mstore8(add(buff, 0x20), 0x01)\\n            }\\n            mstore(0x40, add(buff, 0x21))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Convert byte value into bytes\\n    *  @param b         The byte value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteByte(byte b) internal pure returns (bytes memory) {\\n        return WriteUint8(uint8(b));\\n    }\\n\\n    /* @notice          Convert uint8 value into bytes\\n    *  @param v         The uint8 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\\n        bytes memory buff;\\n        assembly{\\n            buff := mload(0x40)\\n            mstore(buff, 1)\\n            mstore(add(buff, 0x20), shl(248, v))\\n            // mstore(add(buff, 0x20), byte(0x1f, v))\\n            mstore(0x40, add(buff, 0x21))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Convert uint16 value into bytes\\n    *  @param v         The uint16 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\\n        bytes memory buff;\\n\\n        assembly{\\n            buff := mload(0x40)\\n            let byteLen := 0x02\\n            mstore(buff, byteLen)\\n            for {\\n                let mindex := 0x00\\n                let vindex := 0x1f\\n            } lt(mindex, byteLen) {\\n                mindex := add(mindex, 0x01)\\n                vindex := sub(vindex, 0x01)\\n            }{\\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\\n            }\\n            mstore(0x40, add(buff, 0x22))\\n        }\\n        return buff;\\n    }\\n    \\n    /* @notice          Convert uint32 value into bytes\\n    *  @param v         The uint32 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\\n        bytes memory buff;\\n        assembly{\\n            buff := mload(0x40)\\n            let byteLen := 0x04\\n            mstore(buff, byteLen)\\n            for {\\n                let mindex := 0x00\\n                let vindex := 0x1f\\n            } lt(mindex, byteLen) {\\n                mindex := add(mindex, 0x01)\\n                vindex := sub(vindex, 0x01)\\n            }{\\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\\n            }\\n            mstore(0x40, add(buff, 0x24))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Convert uint64 value into bytes\\n    *  @param v         The uint64 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\\n        bytes memory buff;\\n\\n        assembly{\\n            buff := mload(0x40)\\n            let byteLen := 0x08\\n            mstore(buff, byteLen)\\n            for {\\n                let mindex := 0x00\\n                let vindex := 0x1f\\n            } lt(mindex, byteLen) {\\n                mindex := add(mindex, 0x01)\\n                vindex := sub(vindex, 0x01)\\n            }{\\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\\n            }\\n            mstore(0x40, add(buff, 0x28))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Convert limited uint256 value into bytes\\n    *  @param v         The uint256 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\\n        require(v \\u003c= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \\\"Value exceeds uint255 range\\\");\\n        bytes memory buff;\\n\\n        assembly{\\n            buff := mload(0x40)\\n            let byteLen := 0x20\\n            mstore(buff, byteLen)\\n            for {\\n                let mindex := 0x00\\n                let vindex := 0x1f\\n            } lt(mindex, byteLen) {\\n                mindex := add(mindex, 0x01)\\n                vindex := sub(vindex, 0x01)\\n            }{\\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\\n            }\\n            mstore(0x40, add(buff, 0x40))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Convert limited uint256 value into bytes\\n    *  @param v         The uint256 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint256(uint256 v) internal pure returns (bytes memory) {\\n        require(v \\u003c= uint256(-1), \\\"Value exceeds uint256 range\\\");\\n        bytes memory buff;\\n\\n        assembly{\\n            buff := mload(0x40)\\n            let byteLen := 0x20\\n            mstore(buff, byteLen)\\n            for {\\n                let mindex := 0x00\\n                let vindex := 0x1f\\n            } lt(mindex, byteLen) {\\n                mindex := add(mindex, 0x01)\\n                vindex := sub(vindex, 0x01)\\n            }{\\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\\n            }\\n            mstore(0x40, add(buff, 0x40))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Encode bytes format data into bytes\\n    *  @param data      The bytes array data\\n    *  @return          Encoded bytes array\\n    */\\n    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\\n        uint64 l = uint64(data.length);\\n        return abi.encodePacked(WriteVarUint(l), data);\\n    }\\n\\n    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\\n        if (v \\u003c 0xFD){\\n    \\t\\treturn WriteUint8(uint8(v));\\n    \\t} else if (v \\u003c= 0xFFFF) {\\n    \\t\\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\\n    \\t} else if (v \\u003c= 0xFFFFFFFF) {\\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\\n    \\t} else {\\n    \\t\\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\\n    \\t}\\n    }\\n}\"},\"ZeroCopySource.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over decoding and deserialization operation from bytes into bassic types in Solidity for PolyNetwork cross chain utility.\\n *\\n * Decode into basic types in Solidity from bytes easily. It\\u0027s designed to be used \\n * for PolyNetwork cross chain application, and the decoding rules on Ethereum chain \\n * and the encoding rule on other chains should be consistent, and . Here we\\n * follow the underlying deserialization rule with implementation found here: \\n * https://github.com/polynetwork/poly/blob/master/common/zero_copy_source.go\\n *\\n * Using this library instead of the unchecked serialization method can help reduce\\n * the risk of serious bugs and handfule, so it\\u0027s recommended to use it.\\n *\\n * Please note that risk can be minimized, yet not eliminated.\\n */\\nlibrary ZeroCopySource {\\n    /* @notice              Read next byte as boolean type starting at offset from buff\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the boolean value\\n    *  @return              The the read boolean value and new offset\\n    */\\n    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\\n        require(offset + 1 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 1, \\\"Offset exceeds limit\\\");\\n        // byte === bytes1\\n        byte v;\\n        assembly{\\n            v := mload(add(add(buff, 0x20), offset))\\n        }\\n        bool value;\\n        if (v == 0x01) {\\n\\t\\t    value = true;\\n    \\t} else if (v == 0x00) {\\n            value = false;\\n        } else {\\n            revert(\\\"NextBool value error\\\");\\n        }\\n        return (value, offset + 1);\\n    }\\n\\n    /* @notice              Read next byte starting at offset from buff\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the byte value\\n    *  @return              The read byte value and new offset\\n    */\\n    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\\n        require(offset + 1 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 1, \\\"NextByte, Offset exceeds maximum\\\");\\n        byte v;\\n        assembly{\\n            v := mload(add(add(buff, 0x20), offset))\\n        }\\n        return (v, offset + 1);\\n    }\\n\\n    /* @notice              Read next byte as uint8 starting at offset from buff\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the byte value\\n    *  @return              The read uint8 value and new offset\\n    */\\n    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\\n        require(offset + 1 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 1, \\\"NextUint8, Offset exceeds maximum\\\");\\n        uint8 v;\\n        assembly{\\n            let tmpbytes := mload(0x40)\\n            let bvalue := mload(add(add(buff, 0x20), offset))\\n            mstore8(tmpbytes, byte(0, bvalue))\\n            mstore(0x40, add(tmpbytes, 0x01))\\n            v := mload(sub(tmpbytes, 0x1f))\\n        }\\n        return (v, offset + 1);\\n    }\\n\\n    /* @notice              Read next two bytes as uint16 type starting from offset\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the uint16 value\\n    *  @return              The read uint16 value and updated offset\\n    */\\n    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\\n        require(offset + 2 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 2, \\\"NextUint16, offset exceeds maximum\\\");\\n        \\n        uint16 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let bvalue := mload(add(add(buff, 0x20), offset))\\n            mstore8(tmpbytes, byte(0x01, bvalue))\\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\\n            mstore(0x40, add(tmpbytes, 0x02))\\n            v := mload(sub(tmpbytes, 0x1e))\\n        }\\n        return (v, offset + 2);\\n    }\\n\\n\\n    /* @notice              Read next four bytes as uint32 type starting from offset\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the uint32 value\\n    *  @return              The read uint32 value and updated offset\\n    */\\n    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\\n        require(offset + 4 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 4, \\\"NextUint32, offset exceeds maximum\\\");\\n        uint32 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x04\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 4);\\n    }\\n\\n    /* @notice              Read next eight bytes as uint64 type starting from offset\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the uint64 value\\n    *  @return              The read uint64 value and updated offset\\n    */\\n    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\\n        require(offset + 8 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 8, \\\"NextUint64, offset exceeds maximum\\\");\\n        uint64 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x08\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 8);\\n    }\\n\\n    /* @notice              Read next 32 bytes as uint256 type starting from offset,\\n                            there are limits considering the numerical limits in multi-chain\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the uint256 value\\n    *  @return              The read uint256 value and updated offset\\n    */\\n    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\\n        require(offset + 32 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 32, \\\"NextUint255, offset exceeds maximum\\\");\\n        uint256 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x20\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(tmpbytes)\\n        }\\n        require(v \\u003c= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \\\"Value exceeds the range\\\");\\n        return (v, offset + 32);\\n    }\\n\\n    function NextUint256(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\\n        require(offset + 32 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 32, \\\"NextUint256, offset exceeds maximum\\\");\\n        uint256 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x20\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(tmpbytes)\\n        }\\n        require(v \\u003c= uint256(-1), \\\"Value exceeds the range\\\");\\n        return (v, offset + 32);\\n    }\\n\\n    /* @notice              Read next variable bytes starting from offset,\\n                            the decoding rule coming from multi-chain\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the bytes value\\n    *  @return              The read variable bytes array value and updated offset\\n    */\\n    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\\n        uint len;\\n        (len, offset) = NextVarUint(buff, offset);\\n        require(offset + len \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + len, \\\"NextVarBytes, offset exceeds maximum\\\");\\n        bytes memory tempBytes;\\n        assembly{\\n            switch iszero(len)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don\\u0027t care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we\\u0027re done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(len, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin\\u0027s length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, len)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, len)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let\\u0027s just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return (tempBytes, offset + len);\\n    }\\n    /* @notice              Read next 32 bytes starting from offset,\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the bytes value\\n    *  @return              The read bytes32 value and updated offset\\n    */\\n    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\\n        require(offset + 32 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 32, \\\"NextHash, offset exceeds maximum\\\");\\n        bytes32 v;\\n        assembly {\\n            v := mload(add(buff, add(offset, 0x20)))\\n        }\\n        return (v, offset + 32);\\n    }\\n\\n    /* @notice              Read next 20 bytes starting from offset,\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the bytes value\\n    *  @return              The read bytes20 value and updated offset\\n    */\\n    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\\n        require(offset + 20 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 20, \\\"NextBytes20, offset exceeds maximum\\\");\\n        bytes20 v;\\n        assembly {\\n            v := mload(add(buff, add(offset, 0x20)))\\n        }\\n        return (v, offset + 20);\\n    }\\n    \\n    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\\n        byte v;\\n        (v, offset) = NextByte(buff, offset);\\n\\n        uint value;\\n        if (v == 0xFD) {\\n            // return NextUint16(buff, offset);\\n            (value, offset) = NextUint16(buff, offset);\\n            require(value \\u003e= 0xFD \\u0026\\u0026 value \\u003c= 0xFFFF, \\\"NextUint16, value outside range\\\");\\n            return (value, offset);\\n        } else if (v == 0xFE) {\\n            // return NextUint32(buff, offset);\\n            (value, offset) = NextUint32(buff, offset);\\n            require(value \\u003e 0xFFFF \\u0026\\u0026 value \\u003c= 0xFFFFFFFF, \\\"NextVarUint, value outside range\\\");\\n            return (value, offset);\\n        } else if (v == 0xFF) {\\n            // return NextUint64(buff, offset);\\n            (value, offset) = NextUint64(buff, offset);\\n            require(value \\u003e 0xFFFFFFFF, \\\"NextVarUint, value outside range\\\");\\n            return (value, offset);\\n        } else{\\n            // return (uint8(v), offset);\\n            value = uint8(v);\\n            require(value \\u003c 0xFD, \\\"NextVarUint, value outside range\\\");\\n            return (value, offset);\\n        }\\n    }\\n}\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAssetHash\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"targetProxyHash\",\"type\":\"bytes\"}],\"name\":\"BindAssetEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"targetProxyHash\",\"type\":\"bytes\"}],\"name\":\"BindProxyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAssetHash\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"toAssetHash\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"toAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"LockEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"SetManagerProxyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAssetHash\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"UnlockEvent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"assetHashMap\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromAssetHash\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"toAssetHash\",\"type\":\"bytes\"}],\"name\":\"bindAssetHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"targetProxyHash\",\"type\":\"bytes\"}],\"name\":\"bindProxyHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managerProxyContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"proxyHashMap\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ethCCMProxyAddr\",\"type\":\"address\"}],\"name\":\"setManagerProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"argsBs\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"fromContractAddr\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"fromChainId\",\"type\":\"uint64\"}],\"name\":\"unlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PolyNFTLockProxy","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2270cf87d629ec559973a67b7708c741b76b3cbca9e11a499cb1da70f3485871"}]}