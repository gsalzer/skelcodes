{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/v1/send/GenieSend.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"../../../interfaces/markets/tokens/IERC20.sol\\\";\\nimport \\\"../../../interfaces/markets/tokens/IERC721.sol\\\";\\nimport \\\"../../../interfaces/markets/tokens/IERC1155.sol\\\";\\nimport \\\"../SpecialTransferHelper.sol\\\";\\n\\ncontract GenieSend is SpecialTransferHelper {\\n\\n    struct ERC20Details {\\n        address[] tokenAddrs;\\n        uint256[] amounts;\\n    }\\n\\n    struct ERC721SendDetails {\\n        address tokenAddr;\\n        uint256[] ids;\\n    }\\n\\n    struct ERC1155SendDetails {\\n        address tokenAddr;\\n        uint256[] ids;\\n        uint256[] amounts;\\n    }\\n\\n    function transferERC20(\\n        ERC20Details memory erc20Details,\\n        address recipient\\n    ) public {\\n        // transfer ERC20 tokens from the sender to this contract\\n        for (uint256 i = 0; i < erc20Details.tokenAddrs.length; i++) {\\n            require(\\n                IERC20(erc20Details.tokenAddrs[i]).transferFrom(\\n                    _msgSender(),\\n                    recipient,\\n                    erc20Details.amounts[i]\\n                ),\\n                \\\"transferERC20: transfer failed\\\"\\n            );\\n        }\\n    }\\n\\n    function transferERC721(\\n        ERC721SendDetails[] memory erc721Details,\\n        address recipient\\n    ) public {\\n        for (uint256 i = 0; i < erc721Details.length; i++) {\\n            // accept CryptoPunks\\n            if (erc721Details[i].tokenAddr == 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB) {\\n                address[] memory _to = new address[](1);\\n                _to[0] = recipient;\\n                \\n                _acceptCryptoPunk(\\n                    ERC721Details(\\n                        erc721Details[i].tokenAddr,\\n                        _to,\\n                        erc721Details[i].ids\\n                    )\\n                );\\n                \\n                _transferCryptoPunk(\\n                    ERC721Details(\\n                        erc721Details[i].tokenAddr,\\n                        _to,\\n                        erc721Details[i].ids\\n                    )\\n                );\\n            }\\n            // accept Mooncat\\n            else if (erc721Details[i].tokenAddr == 0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6) {\\n                address[] memory _to = new address[](1);\\n                _to[0] = recipient;\\n\\n                _acceptMoonCat(\\n                    ERC721Details(\\n                        erc721Details[i].tokenAddr,\\n                        _to,\\n                        erc721Details[i].ids\\n                    )\\n                );\\n                \\n                _transferMoonCat(\\n                    ERC721Details(\\n                        erc721Details[i].tokenAddr,\\n                        _to,\\n                        erc721Details[i].ids\\n                    )\\n                );\\n            }\\n            // default\\n            else {\\n                for (uint256 j = 0; j < erc721Details[i].ids.length; j++) {\\n                    IERC721(erc721Details[i].tokenAddr).transferFrom(\\n                        msg.sender,\\n                        recipient,\\n                        erc721Details[i].ids[j]\\n                    );\\n                }\\n            }\\n        }\\n    }\\n\\n    function transferERC1155(\\n        ERC1155SendDetails[] memory erc1155Details, \\n        address recipient\\n    ) public {\\n        for (uint256 i = 0; i < erc1155Details.length; i++) {\\n            IERC1155(erc1155Details[i].tokenAddr).safeBatchTransferFrom(\\n                msg.sender,\\n                recipient,\\n                erc1155Details[i].ids,\\n                erc1155Details[i].amounts,\\n                \\\"\\\"\\n            );\\n        }\\n    }\\n\\n    function _transferEth(address _recipient) internal {\\n        if (address(this).balance > 0) {\\n            (bool success, ) = _recipient.call{value: address(this).balance}('');\\n            require(success, \\\"_transferEth: Eth transfer failed\\\");\\n        }\\n    }\\n\\n    function transferAssets(\\n        ERC20Details memory erc20Details,\\n        ERC721SendDetails[] memory erc721Details,\\n        ERC1155SendDetails[] memory erc1155Details,\\n        address recipient\\n    ) external payable {\\n        _transferEth(recipient);\\n        transferERC20(erc20Details, recipient);\\n        transferERC721(erc721Details, recipient);\\n        transferERC1155(erc1155Details, recipient);\\n    }\\n}\"\r\n    },\r\n    \"interfaces/markets/tokens/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface IERC20 {\\n    /**\\n        * @dev Returns the amount of tokens owned by `account`.\\n        */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n        * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n        *\\n        * Returns a boolean value indicating whether the operation succeeded.\\n        *\\n        * Emits a {Transfer} event.\\n        */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n}\"\r\n    },\r\n    \"interfaces/markets/tokens/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface IERC721 {\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n    ///  THEY MAY BE PERMANENTLY LOST\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\n    ///  `_tokenId` is not a valid NFT.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;\\n    \\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n    \\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\"\r\n    },\r\n    \"interfaces/markets/tokens/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\ninterface IERC1155 {\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/v1/SpecialTransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"../../interfaces/punks/ICryptoPunks.sol\\\";\\nimport \\\"../../interfaces/punks/IWrappedPunk.sol\\\";\\nimport \\\"../../interfaces/mooncats/IMoonCatsRescue.sol\\\";\\n\\ncontract SpecialTransferHelper is Context {\\n\\n    struct ERC721Details {\\n        address tokenAddr;\\n        address[] to;\\n        uint256[] ids;\\n    }\\n\\n    function _uintToBytes5(uint256 id)\\n        internal\\n        pure\\n        returns (bytes5 slicedDataBytes5)\\n    {\\n        bytes memory _bytes = new bytes(32);\\n        assembly {\\n            mstore(add(_bytes, 32), id)\\n        }\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // The first word of the slice result is potentially a partial\\n            // word read from the original array. To read it, we calculate\\n            // the length of that partial word and start copying that many\\n            // bytes into the array. The first word we copy will start with\\n            // data we don't care about, but the last `lengthmod` bytes will\\n            // land at the beginning of the contents of the new array. When\\n            // we're done copying, we overwrite the full first word with\\n            // the actual length of the slice.\\n            let lengthmod := and(5, 31)\\n\\n            // The multiplication in the next line is necessary\\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\\n            // the following copy loop was copying the origin's length\\n            // and then ending prematurely not copying everything it should.\\n            let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n            let end := add(mc, 5)\\n\\n            for {\\n                // The multiplication in the next line has the same exact purpose\\n                // as the one above.\\n                let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), 27)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            mstore(tempBytes, 5)\\n\\n            //update free-memory pointer\\n            //allocating the array padded to 32 bytes like the compiler does now\\n            mstore(0x40, and(add(mc, 31), not(31)))\\n        }\\n\\n        assembly {\\n            slicedDataBytes5 := mload(add(tempBytes, 32))\\n        }\\n    }\\n\\n\\n    function _acceptMoonCat(ERC721Details memory erc721Details) internal {\\n        for (uint256 i = 0; i < erc721Details.ids.length; i++) {\\n            bytes5 catId = _uintToBytes5(erc721Details.ids[i]);\\n            address owner = IMoonCatsRescue(erc721Details.tokenAddr).catOwners(catId);\\n            require(owner == _msgSender(), \\\"_acceptMoonCat: invalid mooncat owner\\\");\\n            IMoonCatsRescue(erc721Details.tokenAddr).acceptAdoptionOffer(catId);\\n        }\\n    }\\n\\n    function _transferMoonCat(ERC721Details memory erc721Details) internal {\\n        for (uint256 i = 0; i < erc721Details.ids.length; i++) {\\n            IMoonCatsRescue(erc721Details.tokenAddr).giveCat(_uintToBytes5(erc721Details.ids[i]), erc721Details.to[i]);\\n        }\\n    }\\n\\n    function _acceptCryptoPunk(ERC721Details memory erc721Details) internal {\\n        for (uint256 i = 0; i < erc721Details.ids.length; i++) {    \\n            address owner = ICryptoPunks(erc721Details.tokenAddr).punkIndexToAddress(erc721Details.ids[i]);\\n            require(owner == _msgSender(), \\\"_acceptCryptoPunk: invalid punk owner\\\");\\n            ICryptoPunks(erc721Details.tokenAddr).buyPunk(erc721Details.ids[i]);\\n        }\\n    }\\n\\n    function _transferCryptoPunk(ERC721Details memory erc721Details) internal {\\n        for (uint256 i = 0; i < erc721Details.ids.length; i++) {\\n            ICryptoPunks(erc721Details.tokenAddr).transferPunk(erc721Details.to[i], erc721Details.ids[i]);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/punks/ICryptoPunks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface ICryptoPunks {\\n    function punkIndexToAddress(uint index) external view returns(address owner);\\n    function offerPunkForSaleToAddress(uint punkIndex, uint minSalePriceInWei, address toAddress) external;\\n    function buyPunk(uint punkIndex) external payable;\\n    function transferPunk(address to, uint punkIndex) external;\\n}\"\r\n    },\r\n    \"interfaces/punks/IWrappedPunk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface IWrappedPunk {\\n    /**\\n     * @dev Mints a wrapped punk\\n     */\\n    function mint(uint256 punkIndex) external;\\n\\n    /**\\n     * @dev Burns a specific wrapped punk\\n     */\\n    function burn(uint256 punkIndex) external;\\n    \\n    /**\\n     * @dev Registers proxy\\n     */\\n    function registerProxy() external;\\n\\n    /**\\n     * @dev Gets proxy address\\n     */\\n    function proxyInfo(address user) external view returns (address);\\n}\"\r\n    },\r\n    \"interfaces/mooncats/IMoonCatsRescue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface IMoonCatsRescue {\\n    function acceptAdoptionOffer(bytes5 catId) payable external;\\n    function makeAdoptionOfferToAddress(bytes5 catId, uint price, address to) external;\\n    function giveCat(bytes5 catId, address to) external;\\n    function catOwners(bytes5 catId) external view returns(address);\\n    function rescueOrder(uint256 rescueIndex) external view returns(bytes5 catId);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct GenieSend.ERC20Details\",\"name\":\"erc20Details\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"internalType\":\"struct GenieSend.ERC721SendDetails[]\",\"name\":\"erc721Details\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct GenieSend.ERC1155SendDetails[]\",\"name\":\"erc1155Details\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"transferAssets\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct GenieSend.ERC1155SendDetails[]\",\"name\":\"erc1155Details\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"transferERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct GenieSend.ERC20Details\",\"name\":\"erc20Details\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"transferERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"internalType\":\"struct GenieSend.ERC721SendDetails[]\",\"name\":\"erc721Details\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"transferERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GenieSend","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}