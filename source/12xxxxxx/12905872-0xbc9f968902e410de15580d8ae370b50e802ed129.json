{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/NameRegistry.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\n\\ncontract NameRegistry {\\n    struct ContractDetails {\\n        // registered contract address\\n        address contractAddress;\\n    }\\n    event RegisteredNewContract(bytes32 name, address contractAddr);\\n    mapping(bytes32 => ContractDetails) registry;\\n\\n    function registerName(bytes32 name, address addr) external returns (bool) {\\n        ContractDetails memory info = registry[name];\\n        // create info if it doesn't exist in the registry\\n        if (info.contractAddress == address(0)) {\\n            info.contractAddress = addr;\\n            registry[name] = info;\\n            // added to registry\\n            return true;\\n        } else {\\n            // already was registered\\n            return false;\\n        }\\n    }\\n\\n    function getContractDetails(bytes32 name) external view returns (address) {\\n        return (registry[name].contractAddress);\\n    }\\n\\n    function updateContractDetails(bytes32 name, address addr) external {\\n        // TODO not sure if we should do this\\n        // If we do we need a plan on how to remove this\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/POB.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\n\\n/*\\nPOB contract handles all the proof of burn related functionality\\n*/\\ncontract POB {\\n    address public coordinator;\\n\\n    constructor() public {\\n        coordinator = msg.sender;\\n    }\\n\\n    function getCoordinator() public view returns (address) {\\n        return coordinator;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/TokenRegistry.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.21;\\n\\nimport { Logger } from \\\"./logger.sol\\\";\\nimport { NameRegistry as Registry } from \\\"./NameRegistry.sol\\\";\\nimport { ParamManager } from \\\"./libs/ParamManager.sol\\\";\\nimport { POB } from \\\"./POB.sol\\\";\\n\\ncontract TokenRegistry {\\n    address public rollupNC;\\n    Logger public logger;\\n    mapping(address => bool) public pendingRegistrations;\\n    mapping(uint256 => address) public registeredTokens;\\n\\n    uint256 public numTokens;\\n\\n    modifier onlyCoordinator() {\\n        POB pobContract = POB(\\n            nameRegistry.getContractDetails(ParamManager.POB())\\n        );\\n        assert(msg.sender == pobContract.getCoordinator());\\n        _;\\n    }\\n    Registry public nameRegistry;\\n\\n    constructor(address _registryAddr) public {\\n        nameRegistry = Registry(_registryAddr);\\n\\n        logger = Logger(nameRegistry.getContractDetails(ParamManager.LOGGER()));\\n    }\\n\\n    /**\\n     * @notice Requests addition of a new token to the chain, can be called by anyone\\n     * @param tokenContract Address for the new token being added\\n     */\\n    function requestTokenRegistration(address tokenContract) public {\\n        require(\\n            pendingRegistrations[tokenContract] == false,\\n            \\\"Token already registered.\\\"\\n        );\\n        pendingRegistrations[tokenContract] = true;\\n        logger.logRegistrationRequest(tokenContract);\\n    }\\n\\n    /**\\n     * @notice Add new tokens to the rollup chain by assigning them an ID called tokenType from here on\\n     * @param tokenContract Deposit tree depth or depth of subtree that is being deposited\\n     * TODO: add a modifier to allow only coordinator\\n     */\\n    function finaliseTokenRegistration(address tokenContract) public {\\n        require(\\n            pendingRegistrations[tokenContract],\\n            \\\"Token was not registered\\\"\\n        );\\n        numTokens++;\\n        registeredTokens[numTokens] = tokenContract; // tokenType => token contract address\\n        logger.logRegisteredToken(numTokens, tokenContract);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/ParamManager.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\n\\nlibrary ParamManager {\\n    function DEPOSIT_MANAGER() public pure returns (bytes32) {\\n        return keccak256(\\\"deposit_manager\\\");\\n    }\\n\\n    function WITHDRAW_MANAGER() public pure returns (bytes32) {\\n        return keccak256(\\\"withdraw_manager\\\");\\n    }\\n\\n    function TOKEN() public pure returns (bytes32) {\\n        return keccak256(\\\"token\\\");\\n    }\\n\\n    function POB() public pure returns (bytes32) {\\n        return keccak256(\\\"pob\\\");\\n    }\\n\\n    function Governance() public pure returns (bytes32) {\\n        return keccak256(\\\"governance\\\");\\n    }\\n\\n    function ROLLUP_CORE() public pure returns (bytes32) {\\n        return keccak256(\\\"rollup_core\\\");\\n    }\\n\\n    function ACCOUNTS_TREE() public pure returns (bytes32) {\\n        return keccak256(\\\"accounts_tree\\\");\\n    }\\n\\n    function LOGGER() public pure returns (bytes32) {\\n        return keccak256(\\\"logger\\\");\\n    }\\n\\n    function MERKLE_UTILS() public pure returns (bytes32) {\\n        return keccak256(\\\"merkle_lib\\\");\\n    }\\n\\n    function PARAM_MANAGER() public pure returns (bytes32) {\\n        return keccak256(\\\"param_manager\\\");\\n    }\\n\\n    function TOKEN_REGISTRY() public pure returns (bytes32) {\\n        return keccak256(\\\"token_registry\\\");\\n    }\\n\\n    function FRAUD_PROOF() public pure returns (bytes32) {\\n        return keccak256(\\\"fraud_proof\\\");\\n    }\\n\\n    bytes32 public constant _CHAIN_ID = keccak256(\\\"opru-123\\\");\\n\\n    function CHAIN_ID() public pure returns (bytes32) {\\n        return _CHAIN_ID;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/Types.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\n\\n/**\\n * @title DataTypes\\n */\\nlibrary Types {\\n    // We define Usage for a batch or for a tx\\n    // to check if the usage of a batch and all txs in it are the same\\n    enum Usage {\\n        Genesis, // The Genesis type is only applicable to batch but not tx\\n        Transfer,\\n        Deposit\\n    }\\n    // PDALeaf represents the leaf in\\n    // Pubkey DataAvailability Tree\\n    struct PDALeaf {\\n        bytes pubkey;\\n    }\\n\\n    // Batch represents the batch submitted periodically to the ethereum chain\\n    struct Batch {\\n        bytes32 stateRoot;\\n        bytes32 accountRoot;\\n        bytes32 depositTree;\\n        address committer;\\n        bytes32 txRoot;\\n        uint256 stakeCommitted;\\n        uint256 finalisesOn;\\n        uint256 timestamp;\\n        Usage batchType;\\n    }\\n\\n    // Transaction represents how each transaction looks like for\\n    // this rollup chain\\n    struct Transaction {\\n        uint256 fromIndex;\\n        uint256 toIndex;\\n        uint256 tokenType;\\n        uint256 nonce;\\n        uint256 txType;\\n        uint256 amount;\\n        bytes signature;\\n    }\\n\\n    // AccountInclusionProof consists of the following fields\\n    // 1. Path to the account leaf from root in the balances tree\\n    // 2. Actual data stored in the leaf\\n    struct AccountInclusionProof {\\n        uint256 pathToAccount;\\n        UserAccount account;\\n    }\\n\\n    struct TranasctionInclusionProof {\\n        uint256 pathToTx;\\n        Transaction data;\\n    }\\n\\n    struct PDAInclusionProof {\\n        uint256 pathToPubkey;\\n        PDALeaf pubkey_leaf;\\n    }\\n\\n    // UserAccount contains the actual data stored in the leaf of balance tree\\n    struct UserAccount {\\n        // ID is the path to the pubkey in the PDA tree\\n        uint256 ID;\\n        uint256 tokenType;\\n        uint256 balance;\\n        uint256 nonce;\\n    }\\n\\n    struct AccountMerkleProof {\\n        AccountInclusionProof accountIP;\\n        bytes32[] siblings;\\n    }\\n\\n    struct AccountProofs {\\n        AccountMerkleProof from;\\n        AccountMerkleProof to;\\n    }\\n\\n    struct BatchValidationProofs {\\n        AccountProofs[] accountProofs;\\n        PDAMerkleProof[] pdaProof;\\n    }\\n\\n    struct TransactionMerkleProof {\\n        TranasctionInclusionProof _tx;\\n        bytes32[] siblings;\\n    }\\n\\n    struct PDAMerkleProof {\\n        PDAInclusionProof _pda;\\n        bytes32[] siblings;\\n    }\\n\\n    enum ErrorCode {\\n        NoError,\\n        InvalidTokenAddress,\\n        InvalidTokenAmount,\\n        NotEnoughTokenBalance,\\n        BadFromTokenType,\\n        BadToTokenType\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/logger.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\n\\nimport { Types } from \\\"./libs/Types.sol\\\";\\n\\ncontract Logger {\\n    /*********************\\n     * Rollup Contract *\\n     ********************/\\n    event NewBatch(\\n        address committer,\\n        bytes32 txroot,\\n        bytes32 updatedRoot,\\n        uint256 index,\\n        Types.Usage batchType\\n    );\\n\\n    function logNewBatch(\\n        address committer,\\n        bytes32 txroot,\\n        bytes32 updatedRoot,\\n        uint256 index,\\n        Types.Usage batchType\\n    ) public {\\n        emit NewBatch(committer, txroot, updatedRoot, index, batchType);\\n    }\\n\\n    event StakeWithdraw(address committed, uint256 amount, uint256 batch_id);\\n\\n    function logStakeWithdraw(\\n        address committed,\\n        uint256 amount,\\n        uint256 batch_id\\n    ) public {\\n        emit StakeWithdraw(committed, amount, batch_id);\\n    }\\n\\n    event BatchRollback(\\n        uint256 batch_id,\\n        address committer,\\n        bytes32 stateRoot,\\n        bytes32 txRoot,\\n        uint256 stakeSlashed\\n    );\\n\\n    function logBatchRollback(\\n        uint256 batch_id,\\n        address committer,\\n        bytes32 stateRoot,\\n        bytes32 txRoot,\\n        uint256 stakeSlashed\\n    ) public {\\n        emit BatchRollback(\\n            batch_id,\\n            committer,\\n            stateRoot,\\n            txRoot,\\n            stakeSlashed\\n        );\\n    }\\n\\n    event RollbackFinalisation(uint256 totalBatchesSlashed);\\n\\n    function logRollbackFinalisation(uint256 totalBatchesSlashed) public {\\n        emit RollbackFinalisation(totalBatchesSlashed);\\n    }\\n\\n    event RegisteredToken(uint256 tokenType, address tokenContract);\\n\\n    function logRegisteredToken(uint256 tokenType, address tokenContract)\\n        public\\n    {\\n        emit RegisteredToken(tokenType, tokenContract);\\n    }\\n\\n    event RegistrationRequest(address tokenContract);\\n\\n    function logRegistrationRequest(address tokenContract) public {\\n        emit RegistrationRequest(tokenContract);\\n    }\\n\\n    event NewPubkeyAdded(uint256 AccountID, bytes pubkey);\\n\\n    function logNewPubkeyAdded(uint256 accountID, bytes memory pubkey) public {\\n        emit NewPubkeyAdded(accountID, pubkey);\\n    }\\n\\n    event DepositQueued(uint256 AccountID, bytes pubkey, bytes data);\\n\\n    function logDepositQueued(\\n        uint256 accountID,\\n        bytes memory pubkey,\\n        bytes memory data\\n    ) public {\\n        emit DepositQueued(accountID, pubkey, data);\\n    }\\n\\n    event DepositLeafMerged(bytes32 left, bytes32 right, bytes32 newRoot);\\n\\n    function logDepositLeafMerged(\\n        bytes32 left,\\n        bytes32 right,\\n        bytes32 newRoot\\n    ) public {\\n        emit DepositLeafMerged(left, right, newRoot);\\n    }\\n\\n    event DepositSubTreeReady(bytes32 root);\\n\\n    function logDepositSubTreeReady(bytes32 root) public {\\n        emit DepositSubTreeReady(root);\\n    }\\n\\n    event DepositsFinalised(bytes32 depositSubTreeRoot, uint256 pathToSubTree);\\n\\n    function logDepositFinalised(\\n        bytes32 depositSubTreeRoot,\\n        uint256 pathToSubTree\\n    ) public {\\n        emit DepositsFinalised(depositSubTreeRoot, pathToSubTree);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"/contracts/libs/ParamManager.sol\": {\r\n        \"ParamManager\": \"0x874dF019F8Ac3c7a2575c0F513e300915e4A8Dc1\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registryAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"finaliseTokenRegistration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logger\",\"outputs\":[{\"internalType\":\"contract Logger\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nameRegistry\",\"outputs\":[{\"internalType\":\"contract NameRegistry\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingRegistrations\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"requestTokenRegistration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rollupNC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TokenRegistry","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000deb8e93884732a191052af12fb20c42b0e701c16","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}