{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity = 0.5.16;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"YouSwap: CALLER_IS_NOT_THE_OWNER\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"YouSwap: NEW_OWNER_IS_THE_ZERO_ADDRESS\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Management is Ownable {\r\n    mapping(address => uint8) private _managers;\r\n    uint internal _nonce;\r\n    mapping(uint => Transaction) internal _pendingTransactions;\r\n    uint[] internal _pendingTxIDs;\r\n\r\n    uint internal constant MIN_SIGNATURES = 3;\r\n    uint private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1, 'YouSwap: LOCKED');\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    struct Transaction {\r\n        uint8 state;\r\n        address creator;\r\n        uint8 teamId;\r\n        address teamAccount;\r\n        address newTeamAccount;\r\n        address agent;\r\n        address newAgent;\r\n        uint8 signatureCount;\r\n        mapping(address => uint8) signatures;\r\n    }\r\n\r\n    event TransactionCreated(\r\n        address creator,\r\n        uint8 teamId,\r\n        address teamAccount,\r\n        address newTeamAccount,\r\n        address teamAgent,\r\n        address newTeamAgent,\r\n        uint transactionId\r\n    );\r\n\r\n    constructor() public {\r\n        _managers[0xf3c5C84E69163bD60D49A90cC4d4b7f12bb592d2] = 1;\r\n        _managers[0xD391FF3F474478aB9517aabD8cA22c599c6E6314] = 1;\r\n        _managers[0x6A02a11035136FB3Ca55F163ed80Eae2CeE0057F] = 1;\r\n    }\r\n\r\n    modifier isManager{\r\n        require(_managers[msg.sender] == 1, \"CALLER_IS_NOT_A_MANAGER\");\r\n        _;\r\n    }\r\n\r\n    function addManager(address manager) external onlyOwner {\r\n        _managers[manager] = 1;\r\n    }\r\n\r\n    function removeManager(address manager) external onlyOwner {\r\n        _managers[manager] = 0;\r\n    }\r\n\r\n    function getPendingTxIDs() external view returns (uint[] memory){\r\n        return _pendingTxIDs;\r\n    }\r\n\r\n    function getPendingTransaction(uint transactionId) external view returns\r\n    (\r\n        address creator,\r\n        uint8 teamId,\r\n        address teamAccount,\r\n        address newTeamAccount,\r\n        address teamAgent,\r\n        address newTeamAgent,\r\n        uint8 signatureCount){\r\n\r\n        require(_pendingTransactions[transactionId].state == 1, 'YouSwap:NOT_EXIST');\r\n\r\n        return (\r\n        _pendingTransactions[transactionId].creator,\r\n        _pendingTransactions[transactionId].teamId,\r\n        _pendingTransactions[transactionId].teamAccount,\r\n        _pendingTransactions[transactionId].newTeamAccount,\r\n        _pendingTransactions[transactionId].agent,\r\n        _pendingTransactions[transactionId].newAgent,\r\n        _pendingTransactions[transactionId].signatureCount);\r\n    }\r\n\r\n    function deleteTransaction(uint transactionId) public isManager {\r\n        require(_pendingTransactions[transactionId].state == 1, 'YouSwap:NOT_EXIST');\r\n        uint8 replace = 0;\r\n        for (uint i = 0; i < _pendingTxIDs.length; i++) {\r\n            if (1 == replace) {\r\n                _pendingTxIDs[i - 1] = _pendingTxIDs[i];\r\n            }\r\n\r\n            if (transactionId == _pendingTxIDs[i]) {\r\n                replace = 1;\r\n            }\r\n        }\r\n        delete _pendingTxIDs[_pendingTxIDs.length - 1];\r\n        _pendingTxIDs.length--;\r\n\r\n        delete _pendingTransactions[transactionId];\r\n    }\r\n}\r\n\r\ncontract TokenDispatch is Management {\r\n    using SafeMath for uint256;\r\n\r\n    struct Team {\r\n        address account;\r\n        address agent;\r\n        uint256 reserved;\r\n        uint256 claimed;\r\n        uint8 claimedTimes;\r\n        uint256 lastClaimedHeight;\r\n        uint256 packageI;\r\n        uint256 packageII;\r\n        uint256 packageIII;\r\n        uint256 packageIV;\r\n        bool approved;\r\n    }\r\n\r\n    uint256 public constant startHeight = 12113920;\r\n    uint256 public constant totalSupply = 4 * 10 ** 13;//30 million for startup team, 10 million for investment organizations\r\n    uint256 public totalClaimed;\r\n    uint256 public approved;\r\n    uint8 private _teamId;\r\n    mapping(uint8 => Team) private _teams;\r\n    address private constant _youToken = 0x1d32916CFA6534D261AD53E2498AB95505bd2510;\r\n    uint256 private constant _blocksOfMonth = 172800;//3600/15*24*30;\r\n\r\n    event Claimed(\r\n        address indexed recipient,\r\n        uint8 teamId,\r\n        uint256 amountOfYou\r\n    );\r\n\r\n    event ApproveTeam(\r\n        uint8 teamId,\r\n        address indexed account,\r\n        address indexed agent,\r\n        uint256 reserve\r\n    );\r\n\r\n    event TeamUpdated(\r\n        uint8 teamId,\r\n        address indexed oldAccount,\r\n        address newAccount,\r\n        address indexed oldAgent,\r\n        address newAgent\r\n    );\r\n\r\n    constructor() public {\r\n        totalClaimed = 0;\r\n        approved = 0;\r\n        _teamId = 0;\r\n    }\r\n\r\n    function approve(address account, address agent, uint256 reserve) public onlyOwner {\r\n        require(approved.add(reserve) <= totalSupply, 'YouSwap: EXCEEDS_THE_TOTAL_SUPPLY_FOR_TEAM');\r\n        _teamId ++;\r\n        _teams[_teamId].approved = true;\r\n        _teams[_teamId].account = account;\r\n        _teams[_teamId].agent = agent;\r\n        _teams[_teamId].reserved = reserve;\r\n\r\n        _teams[_teamId].packageI = reserve.mul(12).div(100);\r\n        _teams[_teamId].packageII = reserve.mul(27).div(100);\r\n        _teams[_teamId].packageIII = reserve.mul(24).div(100);\r\n        _teams[_teamId].packageIV = reserve.mul(37).div(100);\r\n\r\n        _teams[_teamId].lastClaimedHeight = startHeight;\r\n        approved = approved.add(reserve);\r\n\r\n        emit ApproveTeam(_teamId, account, agent, reserve);\r\n    }\r\n\r\n    function teamOf(uint8 teamId) external view returns\r\n    (\r\n        address account,\r\n        address agent,\r\n        uint256 reserved,\r\n        uint256 claimed,\r\n        uint8 claimedTimes,\r\n        uint256 lastClaimedHeight\r\n    ) {\r\n        require(_teams[teamId].approved, 'YouSwap: NOT_EXIST');\r\n        return\r\n        (\r\n        _teams[teamId].account,\r\n        _teams[teamId].agent,\r\n        _teams[teamId].reserved,\r\n        _teams[teamId].claimed,\r\n        _teams[teamId].claimedTimes,\r\n        _teams[teamId].lastClaimedHeight\r\n        );\r\n    }\r\n\r\n    function nextClaimHeightOf(uint8 teamId) external view returns (uint256) {\r\n        require(_teams[teamId].approved, 'YouSwap: NOT_EXIST');\r\n        require(_teams[teamId].claimed < _teams[teamId].reserved, 'YouSwap: COMPLETED_ALREADY');\r\n        return _teams[teamId].lastClaimedHeight.add(_blocksOfMonth);\r\n    }\r\n\r\n    function claimedOf(uint8 teamId) external view returns (uint256) {\r\n        require(_teams[teamId].approved, 'YouSwap: NOT_EXIST');\r\n        return _teams[teamId].claimed;\r\n    }\r\n\r\n    function balanceOf(uint8 teamId) external view returns (uint256) {\r\n        require(_teams[teamId].approved, 'YouSwap: NOT_EXIST');\r\n        return _teams[teamId].reserved.sub(_teams[teamId].claimed);\r\n    }\r\n\r\n    function updateTeam(uint8 teamId, address newAccount, address newAgent) isManager external returns (uint256) {\r\n        require(_teams[teamId].approved, 'YouSwap: NOT_EXIST');\r\n        uint transactionId = ++_nonce;\r\n        Transaction storage transaction = _pendingTransactions[transactionId];\r\n        require(transaction.state == 0, 'YouSwap: TRANSACTION_EXISTS');\r\n        transaction.state = 1;\r\n        transaction.creator = msg.sender;\r\n        transaction.teamId = teamId;\r\n        transaction.teamAccount = _teams[teamId].account;\r\n        transaction.newTeamAccount = newAccount;\r\n        transaction.agent = _teams[teamId].agent;\r\n        transaction.newAgent = newAgent;\r\n        transaction.signatureCount = 1;\r\n        transaction.signatures[msg.sender] = 1;\r\n\r\n        _pendingTxIDs.push(transactionId);\r\n\r\n        emit TransactionCreated(msg.sender, teamId, _teams[teamId].account, newAccount, _teams[teamId].agent, newAgent, transactionId);\r\n\r\n        return transactionId;\r\n    }\r\n\r\n    function claim(uint8 teamId) external lock {\r\n        require(_teams[teamId].approved, 'YouSwap: TEAM_NOT_EXIST');\r\n        require(block.number >= startHeight.add(_blocksOfMonth), 'YouSwap: TIME_IS_NOT_UP');\r\n        require(_teams[teamId].agent == msg.sender || _teams[teamId].account == msg.sender, 'YouSwap: CALLER_IS_NOT_THE_OWNER_OR_AGENT');\r\n        require(_teams[teamId].claimed < _teams[teamId].reserved, 'YouSwap: EXCEEDS_THE_RESERVED_AMOUNT');\r\n        uint deltaBlocks = block.number.sub(_teams[teamId].lastClaimedHeight);\r\n        require(deltaBlocks >= _blocksOfMonth, 'YouSwap: CLAIMED_THIS_MONTH');\r\n\r\n        uint times = 0;\r\n        uint256 canClaimThisTime = 0;\r\n        if (block.number <= startHeight.add(_blocksOfMonth.mul(3))) {//The first stage of 3 months, normal claim state\r\n            times = deltaBlocks.div(_blocksOfMonth);\r\n            canClaimThisTime = _teams[teamId].packageI.div(3).mul(times);\r\n            _teams[teamId].lastClaimedHeight = _teams[teamId].lastClaimedHeight.add(_blocksOfMonth * times);\r\n        }\r\n        else if (block.number <= startHeight.add(_blocksOfMonth.mul(12))) {//The second stage of 9 months(4~12month)\r\n            if (_teams[teamId].lastClaimedHeight < startHeight.add(_blocksOfMonth.mul(3))) {//Claim-progress still in the first stage,then just finish this stage\r\n                canClaimThisTime = _teams[teamId].packageI.sub(_teams[teamId].claimed);\r\n                _teams[teamId].lastClaimedHeight = startHeight.add(_blocksOfMonth.mul(3));\r\n            }\r\n            else {//Claim-progress in the second stage(4~12month),normal claim state\r\n                times = deltaBlocks.div(_blocksOfMonth);\r\n                canClaimThisTime = _teams[teamId].packageII.div(9).mul(times);\r\n                _teams[teamId].lastClaimedHeight = _teams[teamId].lastClaimedHeight.add(_blocksOfMonth.mul(times));\r\n            }\r\n        }\r\n        else if (block.number <= startHeight.add(_blocksOfMonth.mul(24))) {//The third stage of 12 months(13~24)\r\n            if (_teams[teamId].lastClaimedHeight < startHeight.add(_blocksOfMonth.mul(3))) {//Only finish the first stage\r\n                canClaimThisTime = _teams[teamId].packageI.sub(_teams[teamId].claimed);\r\n                _teams[teamId].lastClaimedHeight = startHeight.add(_blocksOfMonth.mul(3));\r\n            }\r\n            else if (_teams[teamId].lastClaimedHeight < startHeight.add(_blocksOfMonth.mul(12))) {//Only finish the second stage\r\n                canClaimThisTime = _teams[teamId].packageII.add(_teams[teamId].packageI).sub(_teams[teamId].claimed);\r\n                _teams[teamId].lastClaimedHeight = startHeight.add(_blocksOfMonth.mul(12));\r\n            }\r\n            else {\r\n                times = deltaBlocks.div(_blocksOfMonth);\r\n                canClaimThisTime = _teams[teamId].packageIII.div(12).mul(times);\r\n                _teams[teamId].lastClaimedHeight = _teams[teamId].lastClaimedHeight.add(_blocksOfMonth.mul(times));\r\n            }\r\n        }\r\n        else {//The fourth stage of 37 months\r\n            if (_teams[teamId].lastClaimedHeight < startHeight.add(_blocksOfMonth.mul(3))) {\r\n                canClaimThisTime = _teams[teamId].packageI.sub(_teams[teamId].claimed);\r\n                _teams[teamId].lastClaimedHeight = startHeight.add(_blocksOfMonth.mul(3));\r\n            }\r\n            else if (_teams[teamId].lastClaimedHeight < startHeight.add(_blocksOfMonth.mul(12))) {\r\n                canClaimThisTime = _teams[teamId].packageII.add(_teams[teamId].packageI).sub(_teams[teamId].claimed);\r\n                _teams[teamId].lastClaimedHeight = startHeight.add(_blocksOfMonth.mul(12));\r\n            }\r\n            else if (_teams[teamId].lastClaimedHeight < startHeight.add(_blocksOfMonth.mul(24))) {\r\n                canClaimThisTime = _teams[teamId].packageIII.add(_teams[teamId].packageII).add(_teams[teamId].packageI).sub(_teams[teamId].claimed);\r\n                _teams[teamId].lastClaimedHeight = startHeight.add(_blocksOfMonth.mul(24));\r\n            }\r\n            else {\r\n                times = deltaBlocks.div(_blocksOfMonth);\r\n                canClaimThisTime = _teams[teamId].packageIV.div(37).mul(times);\r\n                if (_teams[teamId].claimed.add(canClaimThisTime).add(10000) > _teams[teamId].reserved) {//The last month\r\n                    canClaimThisTime = _teams[teamId].reserved.sub(_teams[teamId].claimed);\r\n                }\r\n                _teams[teamId].lastClaimedHeight = _teams[teamId].lastClaimedHeight.add(_blocksOfMonth.mul(times));\r\n            }\r\n        }\r\n\r\n        _mintYou(_teams[teamId].account, canClaimThisTime);\r\n        _teams[teamId].claimed = _teams[teamId].claimed.add(canClaimThisTime);\r\n\r\n        totalClaimed = totalClaimed.add(canClaimThisTime);\r\n        require(totalClaimed <= totalSupply, 'YouSwap: EXCEEDS_THE_UPPER_LIMIT');\r\n        emit Claimed(_teams[teamId].account, teamId, canClaimThisTime);\r\n    }\r\n\r\n    function _mintYou(address recipient, uint256 amount) private {\r\n        bytes4 methodId = bytes4(keccak256(bytes('mint(address,uint256)')));\r\n\r\n        (bool success, bytes memory data) = _youToken.call(abi.encodeWithSelector(methodId, recipient, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'YouSwap: TRANSFER_FAILED');\r\n    }\r\n\r\n    function signTransaction(uint transactionId) external lock isManager {\r\n        require(_pendingTransactions[transactionId].state == 1, 'YouSwap:NOT_EXIST');\r\n        Transaction storage transaction = _pendingTransactions[transactionId];\r\n        require(transaction.signatures[msg.sender] != 1, \"YouSwap: SIGNED_ALREADY\");\r\n        transaction.signatures[msg.sender] = 1;\r\n        transaction.signatureCount++;\r\n\r\n        if (transaction.signatureCount >= MIN_SIGNATURES) {\r\n            _teams[transaction.teamId].account = transaction.newTeamAccount;\r\n            _teams[transaction.teamId].agent = transaction.newAgent;\r\n            emit TeamUpdated(transaction.teamId, transaction.teamAccount, transaction.newTeamAccount, transaction.agent, transaction.newAgent);\r\n\r\n            deleteTransaction(transactionId);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"teamId\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"}],\"name\":\"ApproveTeam\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"teamId\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOfYou\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"teamId\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAccount\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAgent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAgent\",\"type\":\"address\"}],\"name\":\"TeamUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"teamId\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"teamAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTeamAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"teamAgent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTeamAgent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"TransactionCreated\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"approved\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"teamId\",\"type\":\"uint8\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"teamId\",\"type\":\"uint8\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"teamId\",\"type\":\"uint8\"}],\"name\":\"claimedOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"deleteTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getPendingTransaction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"teamId\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"teamAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newTeamAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"teamAgent\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newTeamAgent\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"signatureCount\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPendingTxIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"teamId\",\"type\":\"uint8\"}],\"name\":\"nextClaimHeightOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"signTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"teamId\",\"type\":\"uint8\"}],\"name\":\"teamOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reserved\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"claimedTimes\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimedHeight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"teamId\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"newAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newAgent\",\"type\":\"address\"}],\"name\":\"updateTeam\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenDispatch","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://ebe4ad70d099a515d6b8b8fd6e11cb92a035ebe4ccd47e1d923179ad68145aad"}]}