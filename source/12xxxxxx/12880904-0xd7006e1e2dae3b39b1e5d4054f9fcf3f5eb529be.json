{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external;\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external;\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface UNIPair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast); \r\n}\r\n\r\ncontract GuarateeContract {\r\n    // SafeMath library\r\n    using SafeMath for uint256;\r\n    \r\n    // manager address\r\n    address public owner;\r\n    \r\n    // ether/usdt pair address\r\n    UNIPair public pair;\r\n    \r\n    // usdt address\r\n    IERC20 public usdt;\r\n    \r\n    // contract start id\r\n    uint256 public contractID;\r\n    \r\n    // owner totalBalance\r\n    uint256 public ownerTotalBalance;\r\n    \r\n    // owner currentBalance\r\n    uint256 public ownerCurrentBalance;\r\n    \r\n    struct singleContract {\r\n        uint256 id;\r\n        address from;\r\n        address to;\r\n        uint256 value;\r\n        uint8   prAcc;\r\n        uint8   cfAcc;\r\n        uint8   ctState;\r\n        uint256 stateTime;\r\n    }\r\n    mapping(uint256 => singleContract) singleContracts;\r\n    \r\n    event SignSingleContract(\r\n        uint256 id, address from, address to, address manager, uint256 value,\r\n        uint8 prAcc, uint8 cfAcc, uint8 ctState, uint256 stateTime\r\n    );\r\n\r\n    event ApplyTerminateSingleContract(\r\n        address applyer, uint256 id, uint8 prAcc, uint8 ctState, uint256 stateTime\r\n    );\r\n    \r\n    event ConfirmTerminateSingleContract(\r\n        address confirmer, uint256 id, uint8 cfAcc, uint8 ctState, bool isAccept, uint256 stateTime\r\n    );\r\n    \r\n    struct doubleContract {\r\n        uint256 id;\r\n        address from;\r\n        address to;\r\n        uint256 fvalue;\r\n        uint256 tvalue;\r\n        uint8   prAcc;\r\n        uint8   cfAcc;\r\n        uint8   ctState;\r\n        uint8   withdrawType;\r\n        uint256 stateTime;\r\n    }\r\n    mapping(uint256 => doubleContract) doubleContracts;\r\n    \r\n    event SignDoubleContract(\r\n        uint256 id, address from, address to, address manager, uint256 fvalue, uint256 tvalue,\r\n        uint8 prAcc, uint8 cfAcc, uint8 ctState, uint8 withdrawType, uint256 stateTime\r\n    );\r\n    \r\n    event ConfirmSignDoubleContract(\r\n        address confirmer, uint256 id, uint256 tvalue, uint8 cfAcc, uint8 ctState, uint256 stateTime\r\n    );\r\n    \r\n    event CancleDoubleContract(\r\n        address opter, uint256 id, uint8 ctState, uint256 stateTime\r\n    );\r\n\r\n    event ApplyTerminateDoubleContract(\r\n        address applyer, uint256 id, uint8 prAcc, uint8 ctState, uint8 withdrawType, uint256 stateTime\r\n    );\r\n    \r\n    event ConfirmTerminateDoubleContract(\r\n        address confirmer, uint256 id, uint8 cfAcc, uint8 ctState, bool isAccept, uint256 stateTime\r\n    );\r\n    \r\n    event UpdateOwnerAddress(address newOner);\r\n    \r\n    modifier scExists(uint256 _id) {\r\n        require(_id < contractID, \"Contract does not exist\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not owner\");\r\n        _;\r\n    }\r\n    \r\n    constructor(IERC20 _usdt, UNIPair _pair, address _owner, uint256 _contractID) {\r\n        owner = _owner;\r\n        contractID = _contractID;\r\n        usdt = _usdt;\r\n        pair = _pair;\r\n    }\r\n    \r\n    function signSingleContract(address _to, uint256 _value) public {\r\n        require(usdt.balanceOf(msg.sender) >= _value && _value > 0, \"value error\");\r\n        singleContract storage sc = singleContracts[contractID++];\r\n        sc.id = contractID.sub(1);\r\n        sc.from = msg.sender;\r\n        sc.to = _to;\r\n        sc.value = _value;\r\n        sc.prAcc = 0;\r\n        sc.cfAcc = 0;\r\n        sc.ctState = 1;\r\n        sc.stateTime = block.timestamp;\r\n        \r\n        usdt.transferFrom(msg.sender, address(this), _value);\r\n        \r\n        emit SignSingleContract(sc.id, sc.from, sc.to, owner, sc.value, sc.prAcc, sc.cfAcc, sc.ctState, sc.stateTime);\r\n    }\r\n    \r\n    function applyTerminateSingleContract(uint256 _id) public scExists(_id) {\r\n        singleContract storage sc = singleContracts[_id];\r\n        require((msg.sender == sc.from && sc.prAcc != 1) || (msg.sender == sc.to && sc.prAcc != 2), \"illegal address or not permission\");\r\n        require(sc.ctState == 1, \"terminate contract in progress or finished\");\r\n        \r\n        if(msg.sender == sc.from) {\r\n            sc.prAcc = 1;\r\n            sc.ctState = 2;\r\n            sc.stateTime = block.timestamp;\r\n        }else {\r\n            sc.prAcc = 2;\r\n            sc.ctState = 2;\r\n            sc.stateTime = block.timestamp;\r\n        }\r\n        \r\n        emit ApplyTerminateSingleContract(msg.sender, _id, sc.prAcc, sc.ctState, sc.stateTime);\r\n    }\r\n    \r\n    function confirmTerminateSingleContract(uint256 _id, bool _isAccept) public scExists(_id) {\r\n        uint256 gasAtStart = gasleft();\r\n\r\n        singleContract storage sc = singleContracts[_id];\r\n        require((msg.sender == sc.from && sc.prAcc != 1) || (msg.sender == sc.to && sc.prAcc != 2) || msg.sender == owner, \"illegal address\");\r\n        require(sc.ctState == 2, \"terminate contract finished or not start\");\r\n        address to = sc.prAcc == 1 ? sc.from : sc.to;\r\n        require(usdt.balanceOf(address(this)) >= sc.value, \"value error\");\r\n\r\n        if(_isAccept){\r\n            if(msg.sender == owner) {\r\n                sc.cfAcc = 3;\r\n                sc.ctState = 3;\r\n                sc.stateTime = block.timestamp;\r\n                \r\n                (uint256 reserve0, uint256 reserve1,) = pair.getReserves();\r\n                uint256 feeSpent = gasAtStart.sub(gasleft()).add(63109).mul(tx.gasprice);\r\n                uint256 usdtSpent = reserve1.mul(10**12).mul(feeSpent).div(reserve0).div(10**12);\r\n                if(usdtSpent >= sc.value){\r\n                    ownerTotalBalance = ownerTotalBalance.add(sc.value);\r\n                    ownerCurrentBalance = ownerCurrentBalance.add(sc.value);\r\n                }else{\r\n                    uint256 amount = sc.value.sub(usdtSpent);\r\n                \r\n                    usdt.transfer(to, amount);\r\n                    ownerTotalBalance = ownerTotalBalance.add(usdtSpent);\r\n                    ownerCurrentBalance = ownerCurrentBalance.add(usdtSpent);\r\n                }\r\n\r\n                emit ConfirmTerminateSingleContract(msg.sender, _id, sc.cfAcc, sc.ctState, _isAccept, sc.stateTime);\r\n\r\n                return;\r\n\r\n            }\r\n\r\n            require(3 days < block.timestamp - sc.stateTime, \"have to wait 72 hours\");\r\n\r\n            if(msg.sender == sc.from) {\r\n                \r\n                sc.cfAcc = 1;\r\n                sc.ctState = 3;\r\n                sc.stateTime = block.timestamp;\r\n                \r\n            }else {\r\n                sc.cfAcc = 2;\r\n                sc.ctState = 3;\r\n                sc.stateTime = block.timestamp;\r\n            }\r\n\r\n            uint256 amount1 = sc.value.mul(17).div(20);\r\n            usdt.transfer(to, amount1);\r\n            ownerTotalBalance = ownerTotalBalance.add(sc.value.sub(amount1));\r\n            ownerCurrentBalance = ownerCurrentBalance.add(sc.value.sub(amount1));\r\n            \r\n            emit ConfirmTerminateSingleContract(msg.sender, _id, sc.cfAcc, sc.ctState, _isAccept, sc.stateTime);\r\n\r\n        }else {\r\n            sc.ctState = 1;\r\n            sc.stateTime = block.timestamp;\r\n                \r\n            emit ConfirmTerminateSingleContract(msg.sender, _id, sc.cfAcc, sc.ctState, _isAccept, sc.stateTime);\r\n        }\r\n    }\r\n    \r\n    function signDoubleContract(address _to, uint256 _value) public {\r\n        require(usdt.balanceOf(msg.sender) >= _value && _value > 0, \"value error\");\r\n        doubleContract storage sc = doubleContracts[contractID++];\r\n        sc.id = contractID.sub(1);\r\n        sc.from = msg.sender;\r\n        sc.to = _to;\r\n        sc.fvalue = _value;\r\n        sc.tvalue = 0;\r\n        sc.prAcc = 0;\r\n        sc.cfAcc = 0;\r\n        sc.ctState = 0;\r\n        sc.withdrawType = 0;\r\n        sc.stateTime = block.timestamp;\r\n        \r\n        usdt.transferFrom(msg.sender, address(this), _value);\r\n        \r\n        emit SignDoubleContract(sc.id, sc.from, sc.to, owner, sc.fvalue, sc.tvalue, sc.prAcc, sc.cfAcc, sc.ctState, sc.withdrawType, sc.stateTime);\r\n    }\r\n    \r\n    function confirmSignDoubleContract(uint256 _id, uint256 _value) public scExists(_id) {\r\n        require(usdt.balanceOf(msg.sender) >= _value && _value > 0, \"value error\");\r\n        doubleContract storage sc = doubleContracts[_id];\r\n        require(msg.sender == sc.to, \"you have not permission to confirm\");\r\n        require(sc.ctState == 0, \"contract state wrong\");\r\n        require(3 days > block.timestamp - sc.stateTime, \"the contract has expired\");\r\n        \r\n        sc.tvalue = _value;\r\n        sc.ctState = 1;\r\n        sc.stateTime = block.timestamp;\r\n        \r\n        usdt.transferFrom(msg.sender, address(this), _value);\r\n        \r\n        emit ConfirmSignDoubleContract(msg.sender, _id, sc.tvalue, sc.cfAcc, sc.ctState, sc.stateTime);\r\n    }\r\n    \r\n    function cancleDoubleContract(uint256 _id) public scExists(_id) {\r\n        doubleContract storage sc = doubleContracts[_id];\r\n        require(3 days < block.timestamp - sc.stateTime, \"have to wait 72 hours\");\r\n        require(msg.sender == sc.from, \"you have not permission to confirm\");\r\n        require(sc.ctState == 0, \"contract state wrong\");\r\n        \r\n        sc.ctState = 5;\r\n\r\n        require(usdt.balanceOf(address(this)) >= sc.fvalue, \"value error\");\r\n        usdt.transfer(msg.sender, sc.fvalue);\r\n        \r\n        emit CancleDoubleContract(msg.sender, _id, sc.ctState, sc.stateTime);\r\n    }\r\n    \r\n    function applyTerminateDoubleContract(uint256 _id, uint8 _withdrawType) public scExists(_id) {\r\n        doubleContract storage sc = doubleContracts[_id];\r\n        require((msg.sender == sc.from && sc.prAcc != 1) || (msg.sender == sc.to && sc.prAcc != 2), \"illegal address or not permission\");\r\n        require(sc.ctState == 1, \"terminate contract is not confirm sign or in progress or finished\");\r\n        require(_withdrawType == 1 || _withdrawType == 2, \"illegal withdrawType\");\r\n        \r\n        if(msg.sender == sc.from) {\r\n            sc.prAcc = 1;\r\n            sc.ctState = 2;\r\n            sc.withdrawType = _withdrawType;\r\n            sc.stateTime = block.timestamp;\r\n        }else {\r\n            sc.prAcc = 2;\r\n            sc.ctState = 2;\r\n            sc.withdrawType = _withdrawType;\r\n            sc.stateTime = block.timestamp;\r\n        }\r\n        \r\n        emit ApplyTerminateDoubleContract(msg.sender, _id, sc.prAcc, sc.ctState, sc.withdrawType, sc.stateTime);\r\n    }\r\n    \r\n    function confirmTerminateDoubleContract(uint256 _id, bool _isAccept) public scExists(_id) {\r\n        uint256 gasAtStart = gasleft();\r\n        doubleContract storage sc = doubleContracts[_id];\r\n        require((msg.sender == sc.from && sc.prAcc != 1) || (msg.sender == sc.to && sc.prAcc != 2) || msg.sender == owner, \"illegal address\");\r\n        require(sc.ctState == 2, \"terminate contract finished or not start\");\r\n        address to = sc.prAcc == 1 ? sc.from : sc.to;\r\n        require(usdt.balanceOf(address(this)) >= sc.fvalue.add(sc.tvalue), \"value error\");\r\n        \r\n        if(_isAccept){\r\n            if(msg.sender == owner) {\r\n                sc.cfAcc = 3;\r\n                sc.ctState = 3;\r\n                sc.stateTime = block.timestamp;\r\n                \r\n                (uint256 reserve0, uint256 reserve1,) = pair.getReserves();\r\n                uint256 feeSpent = gasAtStart.sub(gasleft()).add(63109).mul(tx.gasprice);\r\n                uint256 usdtSpent = reserve1.mul(10**12).mul(feeSpent).div(reserve0).div(10**12);\r\n                \r\n                if(sc.withdrawType == 1) {\r\n                    uint256 usdtSpent1 = usdtSpent >= sc.fvalue ? sc.fvalue : usdtSpent;\r\n                    uint256 usdtSpent2 = usdtSpent >= sc.tvalue ? sc.tvalue : usdtSpent;\r\n                    uint256 amountOfWithdraw1 = sc.fvalue.sub(usdtSpent1);\r\n                    uint256 amountOfWithdraw2 = sc.tvalue.sub(usdtSpent2);\r\n                    \r\n                    usdt.transfer(sc.from, amountOfWithdraw1);\r\n                    usdt.transfer(sc.to, amountOfWithdraw2);\r\n                    ownerTotalBalance = ownerTotalBalance.add(usdtSpent1.add(usdtSpent2));\r\n                    ownerCurrentBalance = ownerCurrentBalance.add(usdtSpent1.add(usdtSpent2));\r\n                }else {\r\n                    usdtSpent = usdtSpent > sc.fvalue.add(sc.tvalue) ? sc.fvalue.add(sc.tvalue) : usdtSpent;\r\n                    uint256 amountOfWithdraw = sc.fvalue.add(sc.tvalue).sub(usdtSpent);\r\n                    \r\n                    usdt.transfer(to, amountOfWithdraw);\r\n                    ownerTotalBalance = ownerTotalBalance.add(usdtSpent);\r\n                    ownerCurrentBalance = ownerCurrentBalance.add(usdtSpent);\r\n                }\r\n\r\n                emit ConfirmTerminateDoubleContract(msg.sender, _id, sc.cfAcc, sc.ctState, _isAccept, sc.stateTime);\r\n                \r\n                return;\r\n            }\r\n            \r\n            require(3 days < block.timestamp - sc.stateTime, \"have to wait 72 hours\");\r\n            \r\n            if(msg.sender == sc.from) {\r\n                sc.cfAcc = 1;\r\n                sc.ctState = 3;\r\n                sc.stateTime = block.timestamp;\r\n            }\r\n            \r\n            if(msg.sender == sc.to) {\r\n                sc.cfAcc = 2;\r\n                sc.ctState = 3;\r\n                sc.stateTime = block.timestamp;\r\n            }\r\n            \r\n            uint256 amount1 = sc.fvalue.mul(17).div(20);\r\n            uint256 amount2 = sc.tvalue.mul(17).div(20);\r\n            uint256 amount3 = amount1.add(amount2);\r\n            \r\n            if(sc.withdrawType == 1) {\r\n                usdt.transfer(sc.from, amount1);\r\n                usdt.transfer(sc.to, amount2);\r\n            }\r\n            if(sc.withdrawType == 2) {\r\n                usdt.transfer(to, amount3);\r\n            }\r\n\r\n            ownerTotalBalance = ownerTotalBalance.add(sc.fvalue.add(sc.tvalue).sub(amount3));\r\n            ownerCurrentBalance = ownerCurrentBalance.add(sc.fvalue.add(sc.tvalue).sub(amount3));\r\n                \r\n            emit ConfirmTerminateDoubleContract(msg.sender, _id, sc.cfAcc, sc.ctState, _isAccept, sc.stateTime);\r\n        }else {\r\n            sc.ctState = 1;\r\n            sc.stateTime = block.timestamp;\r\n                \r\n            emit ConfirmTerminateDoubleContract(msg.sender, _id, sc.cfAcc, sc.ctState, _isAccept, sc.stateTime);\r\n        }\r\n    }\r\n    \r\n    function withdraw(uint256 amount) public onlyOwner {\r\n        require(ownerCurrentBalance >= amount, \"amount exceeds balance\");\r\n        require(usdt.balanceOf(address(this)) >= amount, \"amount exceeds balance\");\r\n        ownerCurrentBalance = ownerCurrentBalance.sub(amount);\r\n        usdt.transfer(msg.sender, amount);\r\n    }\r\n    \r\n    function updateOwnerAddress(address _newOwnerAddress) public onlyOwner {\r\n        owner = _newOwnerAddress;\r\n        \r\n        emit UpdateOwnerAddress(owner);\r\n    }\r\n    \r\n    function getSingleContract(uint256 _id) public view \r\n        returns (uint256 id, address from, address to, address manager, \r\n                 uint256 value, uint8 prAcc, uint8 cfAcc, uint8 ctState, uint256 stateTime)\r\n    {\r\n        singleContract storage sc = singleContracts[_id];\r\n        return (sc.id, sc.from, sc.to, owner, sc.value, sc.prAcc, sc.cfAcc, sc.ctState, sc.stateTime);\r\n    }\r\n    \r\n    function getDoubleContract(uint256 _id) public view \r\n        returns (uint256 id, address from, address to, address manager, \r\n                 uint256 fvalue, uint256 tvalue, uint8 prAcc, uint8 cfAcc, uint8 ctState, uint8   withdrawType, uint256 stateTime)\r\n    {\r\n        doubleContract storage sc = doubleContracts[_id];\r\n        return (sc.id, sc.from, sc.to, owner, sc.fvalue, sc.tvalue, sc.prAcc, sc.cfAcc, sc.ctState, sc.withdrawType, sc.stateTime);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"contract UNIPair\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_contractID\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"applyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"prAcc\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ctState\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"withdrawType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stateTime\",\"type\":\"uint256\"}],\"name\":\"ApplyTerminateDoubleContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"applyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"prAcc\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ctState\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stateTime\",\"type\":\"uint256\"}],\"name\":\"ApplyTerminateSingleContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"opter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ctState\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stateTime\",\"type\":\"uint256\"}],\"name\":\"CancleDoubleContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"confirmer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tvalue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"cfAcc\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ctState\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stateTime\",\"type\":\"uint256\"}],\"name\":\"ConfirmSignDoubleContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"confirmer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"cfAcc\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ctState\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAccept\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stateTime\",\"type\":\"uint256\"}],\"name\":\"ConfirmTerminateDoubleContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"confirmer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"cfAcc\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ctState\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAccept\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stateTime\",\"type\":\"uint256\"}],\"name\":\"ConfirmTerminateSingleContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fvalue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tvalue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"prAcc\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"cfAcc\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ctState\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"withdrawType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stateTime\",\"type\":\"uint256\"}],\"name\":\"SignDoubleContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"prAcc\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"cfAcc\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"ctState\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stateTime\",\"type\":\"uint256\"}],\"name\":\"SignSingleContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOner\",\"type\":\"address\"}],\"name\":\"UpdateOwnerAddress\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_withdrawType\",\"type\":\"uint8\"}],\"name\":\"applyTerminateDoubleContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"applyTerminateSingleContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"cancleDoubleContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"confirmSignDoubleContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isAccept\",\"type\":\"bool\"}],\"name\":\"confirmTerminateDoubleContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isAccept\",\"type\":\"bool\"}],\"name\":\"confirmTerminateSingleContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getDoubleContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fvalue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tvalue\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"prAcc\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"cfAcc\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"ctState\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"withdrawType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"stateTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getSingleContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"prAcc\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"cfAcc\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"ctState\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"stateTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerCurrentBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerTotalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"contract UNIPair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"signDoubleContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"signSingleContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwnerAddress\",\"type\":\"address\"}],\"name\":\"updateOwnerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GuarateeContract","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000000d4a11d5eeaac28ec3f61d100daf4d40471f18520000000000000000000000007afc0978224e4561a5cc7afb9b6759e367bc25f500000000000000000000000000000000000000000000000000000000000003e8","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://429eaf29bc1e593055a736da84ee00a10e8037c77c9d683dbe1c4537e95f8dec"}]}