{"status":"1","message":"OK","result":[{"SourceCode":"{\"BlobStorage.sol\":{\"content\":\"pragma solidity 0.5.10;\\n\\nimport \\u0027./LibInteger.sol\\u0027;\\nimport \\u0027./LibBlob.sol\\u0027;\\n\\n/**\\n * @title BlobStorage \\n * @dev Store core details about the blobs permanently\\n */\\ncontract BlobStorage\\n{\\n    using LibInteger for uint;\\n\\n    /**\\n     * @dev The admin of the contract\\n     */\\n    address payable private _admin;\\n\\n    /**\\n     * @dev Permitted addresses to carry out storage functions\\n     */\\n    mapping (address =\\u003e bool) private _permissions;\\n\\n    /**\\n     * @dev Names of tokens\\n     */\\n    mapping (uint =\\u003e uint) private _names;\\n\\n    /**\\n     * @dev Listing prices of tokens\\n     */\\n    mapping (uint =\\u003e uint) private _listings;\\n\\n    /**\\n     * @dev Original minters of tokens\\n     */\\n    mapping (uint =\\u003e address payable) private _minters;\\n\\n    /**\\n     * @dev Names currently reserved\\n     */\\n    mapping (uint =\\u003e bool) private _reservations;\\n\\n    /**\\n     * @dev The metadata of blobs\\n     */\\n    mapping (uint =\\u003e uint[]) private _metadata;\\n\\n    /**\\n     * @dev Initialise the contract\\n     */\\n    constructor() public\\n    {\\n        //The contract creator becomes the admin\\n        _admin = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Allow access only for the admin of contract\\n     */\\n    modifier onlyAdmin()\\n    {\\n        require(msg.sender == _admin);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allow access only for the permitted addresses\\n     */\\n    modifier onlyPermitted()\\n    {\\n        require(_permissions[msg.sender]);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Give or revoke permission of accounts\\n     * @param account The address to change permission\\n     * @param permission True if the permission should be granted, false if it should be revoked\\n     */\\n    function permit(address account, bool permission) public onlyAdmin\\n    {\\n        _permissions[account] = permission;\\n    }\\n\\n    /**\\n     * @dev Withdraw from the balance of this contract\\n     * @param amount The amount to be withdrawn, if zero is provided the whole balance will be withdrawn\\n     */\\n    function clean(uint amount) public onlyAdmin\\n    {\\n        if (amount == 0){\\n            _admin.transfer(address(this).balance);\\n        } else {\\n            _admin.transfer(amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the name of token\\n     * @param id The id of token\\n     * @param value The value to be set\\n     */\\n    function setName(uint id, uint value) public onlyPermitted\\n    {\\n        _names[id] = value;\\n    }\\n\\n    /**\\n     * @dev Set the listing price of token\\n     * @param id The id of token\\n     * @param value The value to be set\\n     */\\n    function setListing(uint id, uint value) public onlyPermitted\\n    {\\n        _listings[id] = value;\\n    }\\n\\n    /**\\n     * @dev Set the original minter of token\\n     * @param id The id of token\\n     * @param value The value to be set\\n     */\\n    function setMinter(uint id, address payable value) public onlyPermitted\\n    {\\n        _minters[id] = value;\\n    }\\n\\n    /**\\n     * @dev Set whether the name is reserved\\n     * @param name The name\\n     * @param value True if the name is reserved, otherwise false\\n     */\\n    function setReservation(uint name, bool value) public onlyPermitted\\n    {\\n        _reservations[name] = value;\\n    }\\n\\n    /**\\n     * @dev Add a new version of metadata to the token\\n     * @param id The token id\\n     * @param value The value to be set\\n     */\\n    function incrementMetadata(uint id, uint value) public onlyPermitted\\n    {\\n        _metadata[id].push(value);\\n    }\\n\\n    /**\\n     * @dev Remove the latest version of metadata from token\\n     * @param id The token id\\n     */\\n    function decrementMetadata(uint id) public onlyPermitted\\n    {\\n        _metadata[id].length = _metadata[id].length.sub(1);\\n    }\\n\\n    /**\\n     * @dev Get name of token\\n     * @param id The id of token\\n     * @return string The name\\n     */\\n    function getName(uint id) public view returns (uint)\\n    {\\n        return _names[id];\\n    }\\n\\n    /**\\n     * @dev Get listing price of token\\n     * @param id The id of token\\n     * @return uint The listing price\\n     */\\n    function getListing(uint id) public view returns (uint)\\n    {\\n        return _listings[id];\\n    }\\n\\n    /**\\n     * @dev Get original minter of token\\n     * @param id The id of token\\n     * @return uint The original minter\\n     */\\n    function getMinter(uint id) public view returns (address payable)\\n    {\\n        return _minters[id];\\n    }\\n\\n    /**\\n     * @dev Check whether the provided name is reserved\\n     * @param name The name to check\\n     * @return bool True if the name is reserved, otherwise false\\n     */\\n    function isReserved(uint name) public view returns (bool)\\n    {\\n        return _reservations[name];\\n    }\\n\\n    /**\\n     * @dev Check whether the provided address is permitted\\n     * @param account The address to check\\n     * @return bool True if the address is permitted, otherwise false\\n     */\\n    function isPermitted(address account) public view returns (bool)\\n    {\\n        return _permissions[account];\\n    }\\n\\n    /**\\n     * @dev Get latest version of metadata of token\\n     * @param id The id of token\\n     * @return uint The metadata value\\n     */\\n    function getLatestMetadata(uint id) public view returns (uint)\\n    {\\n        if (_metadata[id].length \\u003e 0) {\\n            return _metadata[id][_metadata[id].length.sub(1)];\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Get previous version of metadata of token\\n     * @param id The id of token\\n     * @return uint The metadata value\\n     */\\n    function getPreviousMetadata(uint id) public view returns (uint)\\n    {\\n        if (_metadata[id].length \\u003e 1) {\\n            return _metadata[id][_metadata[id].length.sub(2)];\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\"},\"LibBlob.sol\":{\"content\":\"pragma solidity 0.5.10;\\n\\n/**\\n * @title LibBlob\\n * @dev Blob related utility functions\\n */\\nlibrary LibBlob\\n{\\n    struct Metadata\\n    {\\n        uint partner;\\n        uint level;\\n        uint param1;\\n        uint param2;\\n        uint param3;\\n        uint param4;\\n        uint param5;\\n        uint param6;\\n    }\\n\\n    struct Name\\n    {\\n        uint char1;\\n        uint char2;\\n        uint char3;\\n        uint char4;\\n        uint char5;\\n        uint char6;\\n        uint char7;\\n        uint char8;\\n    }\\n\\n    /**\\n     * @dev Convert metadata to a single integer\\n     * @param metadata The metadata to be converted\\n     * @return uint The integer representing the metadata\\n     */\\n    function metadataToUint(Metadata memory metadata) internal pure returns (uint)\\n    {\\n        uint params = uint(metadata.partner);\\n        params |= metadata.level\\u003c\\u003c32;\\n        params |= metadata.param1\\u003c\\u003c64;\\n        params |= metadata.param2\\u003c\\u003c96;\\n        params |= metadata.param3\\u003c\\u003c128;\\n        params |= metadata.param4\\u003c\\u003c160;\\n        params |= metadata.param5\\u003c\\u003c192;\\n        params |= metadata.param6\\u003c\\u003c224;\\n\\n        return params;\\n    }\\n\\n    /**\\n     * @dev Convert given integer to a metadata object\\n     * @param params The integer to be converted\\n     * @return Metadata The metadata represented by the integer\\n     */\\n    function uintToMetadata(uint params) internal pure returns (Metadata memory)\\n    {\\n        Metadata memory metadata;\\n\\n        metadata.partner = uint(uint32(params));\\n        metadata.level = uint(uint32(params\\u003e\\u003e32));\\n        metadata.param1 = uint(uint32(params\\u003e\\u003e64));\\n        metadata.param2 = uint(uint32(params\\u003e\\u003e96));\\n        metadata.param3 = uint(uint32(params\\u003e\\u003e128));\\n        metadata.param4 = uint(uint32(params\\u003e\\u003e160));\\n        metadata.param5 = uint(uint32(params\\u003e\\u003e192));\\n        metadata.param6 = uint(uint32(params\\u003e\\u003e224));\\n\\n        return metadata;\\n    }\\n\\n    /**\\n     * @dev Convert name to a single integer\\n     * @param name The name to be converted\\n     * @return uint The integer representing the name\\n     */\\n    function nameToUint(Name memory name) internal pure returns (uint)\\n    {\\n        uint params = uint(name.char1);\\n        params |= name.char2\\u003c\\u003c32;\\n        params |= name.char3\\u003c\\u003c64;\\n        params |= name.char4\\u003c\\u003c96;\\n        params |= name.char5\\u003c\\u003c128;\\n        params |= name.char6\\u003c\\u003c160;\\n        params |= name.char7\\u003c\\u003c192;\\n        params |= name.char8\\u003c\\u003c224;\\n\\n        return params;\\n    }\\n\\n    /**\\n     * @dev Convert given integer to a name object\\n     * @param params The integer to be converted\\n     * @return Name The name represented by the integer\\n     */\\n    function uintToName(uint params) internal pure returns (Name memory)\\n    {\\n        Name memory name;\\n\\n        name.char1 = uint(uint32(params));\\n        name.char2 = uint(uint32(params\\u003e\\u003e32));\\n        name.char3 = uint(uint32(params\\u003e\\u003e64));\\n        name.char4 = uint(uint32(params\\u003e\\u003e96));\\n        name.char5 = uint(uint32(params\\u003e\\u003e128));\\n        name.char6 = uint(uint32(params\\u003e\\u003e160));\\n        name.char7 = uint(uint32(params\\u003e\\u003e192));\\n        name.char8 = uint(uint32(params\\u003e\\u003e224));\\n\\n        return name;\\n    }\\n}\\n\"},\"LibInteger.sol\":{\"content\":\"pragma solidity 0.5.10;\\n\\n/**\\n * @title LibInteger \\n * @dev Integer related utility functions\\n */\\nlibrary LibInteger\\n{    \\n    /**\\n     * @dev Safely multiply, revert on overflow\\n     * @param a The first number\\n     * @param b The second number\\n     * @return uint The answer\\n    */\\n    function mul(uint a, uint b) internal pure returns (uint)\\n    {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Safely divide, revert if divisor is zero\\n     * @param a The first number\\n     * @param b The second number\\n     * @return uint The answer\\n    */\\n    function div(uint a, uint b) internal pure returns (uint)\\n    {\\n        require(b \\u003e 0, \\\"\\\");\\n        uint c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Safely substract, revert if answer is negative\\n     * @param a The first number\\n     * @param b The second number\\n     * @return uint The answer\\n    */\\n    function sub(uint a, uint b) internal pure returns (uint)\\n    {\\n        require(b \\u003c= a, \\\"\\\");\\n        uint c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Safely add, revert if overflow\\n     * @param a The first number\\n     * @param b The second number\\n     * @return uint The answer\\n    */\\n    function add(uint a, uint b) internal pure returns (uint)\\n    {\\n        uint c = a + b;\\n        require(c \\u003e= a, \\\"\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Convert number to string\\n     * @param value The number to convert\\n     * @return string The string representation\\n    */\\n    function toString(uint value) internal pure returns (string memory)\\n    {\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n\\n        uint temp = value;\\n        uint digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n\\n        bytes memory buffer = new bytes(digits);\\n        uint index = digits - 1;\\n        \\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = byte(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        \\n        return string(buffer);\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"incrementMetadata\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getListing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"name\",\"type\":\"uint256\"}],\"name\":\"isReserved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setListing\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getLatestMetadata\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPermitted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"clean\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getName\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setReservation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"decrementMetadata\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getPreviousMetadata\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"permission\",\"type\":\"bool\"}],\"name\":\"permit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"BlobStorage","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://4131e001713d39f7f280eb95c80f5684d8571b857dad53472e1653a83bf0fce5"}]}