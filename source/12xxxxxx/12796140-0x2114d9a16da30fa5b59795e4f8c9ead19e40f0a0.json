{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.6;\r\n\r\ninterface IV2Strategy {\r\n    function name() external view returns (string memory);\r\n\r\n    function apiVersion() external view returns (string memory);\r\n\r\n    function strategist() external view returns (address);\r\n\r\n    function rewards() external view returns (address);\r\n\r\n    function vault() external view returns (address);\r\n\r\n    function keeper() external view returns (address);\r\n\r\n    function want() external view returns (address);\r\n\r\n    function emergencyExit() external view returns (bool);\r\n\r\n    function isActive() external view returns (bool);\r\n\r\n    function delegatedAssets() external view returns (uint256);\r\n\r\n    function estimatedTotalAssets() external view returns (uint256);\r\n    \r\n    function doHealthCheck() external view returns (bool);\r\n    \r\n    function healthCheck() external view returns (address);\r\n}\r\n\r\ninterface IAddressesGenerator {\r\n    function assetsAddresses() external view returns (address[] memory);\r\n}\r\n\r\ninterface IV2Vault {\r\n    function withdrawalQueue(uint256 arg0) external view returns (address);\r\n}\r\n\r\ninterface IAddressMergeHelper {\r\n    function mergeAddresses(address[][] memory addressesSets)\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n    \r\n    function symbol() external view returns (string memory);\r\n}\r\n\r\ninterface IOracle {\r\n    function getNormalizedValueUsdc(\r\n        address tokenAddress,\r\n        uint256 amount,\r\n        uint256 priceUsdc\r\n    ) external view returns (uint256);\r\n    \r\n    function getPriceUsdcRecommended(\r\n        address tokenAddress\r\n    ) external view returns (uint256);\r\n}\r\n\r\ncontract StrategiesHelper {\r\n    address public addressesGeneratorAddress;\r\n    address public addressesMergeHelperAddress;\r\n    address public oracleAddress;\r\n    address public ownerAddress;\r\n\r\n    struct StrategyMetadata {\r\n        string name;\r\n        address id;\r\n        string apiVersion;\r\n        address strategist;\r\n        address rewards;\r\n        address vault;\r\n        address keeper;\r\n        address want;\r\n        uint256 wantPriceUsdc;\r\n        uint8 wantDecimals;\r\n        string wantSymbol;\r\n        bool emergencyExit;\r\n        bool isActive;\r\n        uint256 delegatedAssets;\r\n        uint256 estimatedTotalAssets;\r\n        uint256 estimatedTotalAssetsUsdc;\r\n        bool doHealthCheck;\r\n        address healthCheckAddress;\r\n    }\r\n\r\n    constructor(address _addressesGeneratorAddress, address _addressesMergeHelperAddress, address _oracleAddress) {\r\n        addressesGeneratorAddress = _addressesGeneratorAddress;\r\n        addressesMergeHelperAddress = _addressesMergeHelperAddress;\r\n        oracleAddress = _oracleAddress;\r\n        ownerAddress = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Fetch the number of strategies for a vault\r\n     */\r\n    function assetStrategiesLength(address assetAddress)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        IV2Vault vault = IV2Vault(assetAddress);\r\n        uint256 strategyIdx;\r\n        while (true) {\r\n            address strategyAddress = vault.withdrawalQueue(strategyIdx);\r\n            if (strategyAddress == address(0)) {\r\n                break;\r\n            }\r\n            strategyIdx++;\r\n        }\r\n        return strategyIdx;\r\n    }\r\n\r\n    /**\r\n     * Fetch the total number of strategies for all vaults\r\n     */\r\n    function assetsStrategiesLength() public view returns (uint256) {\r\n        return assetsStrategiesAddresses().length;\r\n    }\r\n\r\n    /**\r\n     * Fetch strategy addresses given a vault address\r\n     */\r\n    function assetStrategiesAddresses(address assetAddress)\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        IV2Vault vault = IV2Vault(assetAddress);\r\n        uint256 numberOfStrategies = assetStrategiesLength(assetAddress);\r\n        address[] memory _strategiesAddresses =\r\n            new address[](numberOfStrategies);\r\n        for (\r\n            uint256 strategyIdx = 0;\r\n            strategyIdx < numberOfStrategies;\r\n            strategyIdx++\r\n        ) {\r\n            address strategyAddress = vault.withdrawalQueue(strategyIdx);\r\n            _strategiesAddresses[strategyIdx] = strategyAddress;\r\n        }\r\n        return _strategiesAddresses;\r\n    }\r\n\r\n    /**\r\n     * Fetch all strategy addresses for all vaults\r\n     */\r\n     function assetsStrategiesAddresses() public view returns (address[] memory) {\r\n        address[] memory _assetsAddresses = IAddressesGenerator(addressesGeneratorAddress).assetsAddresses();\r\n        return assetsStrategiesAddresses(_assetsAddresses);\r\n     }\r\n     \r\n    /**\r\n     * Convert an ASCII string to a number given a string and a base\r\n     */\r\n    function atoi(string memory a, uint8 base) internal pure returns (uint256 i) {\r\n        require(base == 2 || base == 8 || base == 10 || base == 16);\r\n        bytes memory buf = bytes(a);\r\n        for (uint256 p = 0; p < buf.length; p++) {\r\n            uint8 digit = uint8(buf[p]) - 0x30;\r\n            if (digit > 10) {\r\n                digit -= 7;\r\n            }\r\n            require(digit < base);\r\n            i *= base;\r\n            i += digit;\r\n        }\r\n        return i;\r\n    }\r\n    \r\n    /**\r\n     * Check to see if two strings are exactly equal\r\n     */\r\n    function stringsEqual(string memory input1, string memory input2) internal pure returns (bool) {\r\n        bytes32 input1Bytes32;\r\n        bytes32 input2Bytes32;\r\n        assembly {\r\n            input1Bytes32 := mload(add(input1, 32))\r\n            input2Bytes32 := mload(add(input2, 32))\r\n        }\r\n        return input1Bytes32 == input2Bytes32;\r\n    }\r\n\r\n    /**\r\n     * Fetch strategy addresses by filter\r\n     */\r\n     function assetsStrategiesAddressesByFilter(string[][] memory filter) public view returns (address[] memory) {\r\n        address[] memory _assetsStrategiesAddresses =\r\n            assetsStrategiesAddresses();\r\n        return assetsStrategiesAddressesByFilter(_assetsStrategiesAddresses, filter);\r\n    }\r\n    \r\n    /**\r\n     * Fetch strategy addresses by filter\r\n     */\r\n    function assetsStrategiesAddressesByFilter(address[] memory _strategiesAddresses, string[][] memory filter) public view returns (address[] memory) {\r\n        uint256 numberOfStrategies = _strategiesAddresses.length;\r\n        uint256 numberOfFilteredStrategies;\r\n        for (\r\n            uint256 strategyIdx = 0;\r\n            strategyIdx < numberOfStrategies;\r\n            strategyIdx++\r\n        ) {\r\n            address strategyAddress = _strategiesAddresses[strategyIdx];\r\n            if (strategyPassesFilter(strategyAddress, filter)) {\r\n                _strategiesAddresses[numberOfFilteredStrategies] = strategyAddress;\r\n                numberOfFilteredStrategies++;\r\n            }\r\n        }\r\n        bytes memory encodedAddresses = abi.encode(_strategiesAddresses);\r\n        assembly {\r\n            mstore(add(encodedAddresses, 0x40), numberOfFilteredStrategies)\r\n        }\r\n        address[] memory filteredAddresses =\r\n            abi.decode(encodedAddresses, (address[]));\r\n        return filteredAddresses;\r\n     }\r\n\r\n    /**\r\n     * Fetch all strategy addresses given an array of vaults\r\n     */\r\n    function assetsStrategiesAddresses(address[] memory _assetsAddresses)\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        uint256 numberOfAssets = _assetsAddresses.length;\r\n        address[][] memory _strategiesForAssets =\r\n            new address[][](numberOfAssets);\r\n        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\r\n            address assetAddress = _assetsAddresses[assetIdx];\r\n            address[] memory _assetStrategiessAddresses =\r\n                assetStrategiesAddresses(assetAddress);\r\n            _strategiesForAssets[assetIdx] = _assetStrategiessAddresses;\r\n        }\r\n        address[] memory mergedAddresses =\r\n            IAddressMergeHelper(addressesMergeHelperAddress).mergeAddresses(_strategiesForAssets);\r\n        return mergedAddresses;\r\n    }\r\n\r\n    /**\r\n     * Fetch total delegated balance for all strategies\r\n     */\r\n    function assetsStrategiesDelegatedBalance()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        address[] memory _assetsAddresses = IAddressesGenerator(addressesGeneratorAddress).assetsAddresses();\r\n        uint256 numberOfAssets = _assetsAddresses.length;\r\n        uint256 assetsDelegatedBalance;\r\n        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\r\n            address assetAddress = _assetsAddresses[assetIdx];\r\n            uint256 assetDelegatedBalance =\r\n                assetStrategiesDelegatedBalance(assetAddress);\r\n            assetsDelegatedBalance += assetDelegatedBalance;\r\n        }\r\n        return assetsDelegatedBalance;\r\n    }\r\n\r\n    /**\r\n     * Fetch delegated balance for all of a vault's strategies\r\n     */\r\n    function assetStrategiesDelegatedBalance(address assetAddress)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        address[] memory _assetStrategiesAddresses =\r\n            assetStrategiesAddresses(assetAddress);\r\n        uint256 numberOfStrategies = _assetStrategiesAddresses.length;\r\n        uint256 strategiesDelegatedBalance;\r\n        for (\r\n            uint256 strategyIdx = 0;\r\n            strategyIdx < numberOfStrategies;\r\n            strategyIdx++\r\n        ) {\r\n            address strategyAddress = _assetStrategiesAddresses[strategyIdx];\r\n            IV2Strategy _strategy = IV2Strategy(strategyAddress);\r\n            uint256 strategyDelegatedBalance = _strategy.delegatedAssets();\r\n            strategiesDelegatedBalance += strategyDelegatedBalance;\r\n        }\r\n        return strategiesDelegatedBalance;\r\n    }\r\n\r\n    /**\r\n     * Fetch metadata for all strategies scoped to a vault\r\n     */\r\n    function assetStrategies(address assetAddress)\r\n        external\r\n        view\r\n        returns (StrategyMetadata[] memory)\r\n    {\r\n        IV2Vault vault = IV2Vault(assetAddress);\r\n        uint256 numberOfStrategies = assetStrategiesLength(assetAddress);\r\n        StrategyMetadata[] memory _strategies =\r\n            new StrategyMetadata[](numberOfStrategies);\r\n        for (\r\n            uint256 strategyIdx = 0;\r\n            strategyIdx < numberOfStrategies;\r\n            strategyIdx++\r\n        ) {\r\n            address strategyAddress = vault.withdrawalQueue(strategyIdx);\r\n            StrategyMetadata memory _strategy = strategy(strategyAddress);\r\n            _strategies[strategyIdx] = _strategy;\r\n        }\r\n        return _strategies;\r\n    }\r\n\r\n    /**\r\n     * Fetch metadata for all strategies\r\n     */\r\n    function assetsStrategies()\r\n        external\r\n        view\r\n        returns (StrategyMetadata[] memory)\r\n    {\r\n        address[] memory _assetsStrategiesAddresses =\r\n            assetsStrategiesAddresses();\r\n        return strategies(_assetsStrategiesAddresses);\r\n    }\r\n    \r\n    /**\r\n     * Fetch metadata for all strategies\r\n     */\r\n    function assetsStrategiesByFilter(string[][] memory _filter)\r\n        external\r\n        view\r\n        returns (StrategyMetadata[] memory)\r\n    {\r\n        address[] memory _assetsStrategiesAddresses =\r\n            assetsStrategiesAddressesByFilter(_filter);\r\n        return strategies(_assetsStrategiesAddresses);\r\n    }\r\n    \r\n    /**\r\n     * Fetch metadata for strategies given an array of vault addresses\r\n     */\r\n    function assetsStrategies(address[] memory _assetsAddresses)\r\n        public\r\n        view\r\n        returns (StrategyMetadata[] memory)\r\n    {\r\n        return strategies(assetsStrategiesAddresses(_assetsAddresses));\r\n    }\r\n    \r\n    /**\r\n     * Fetch metadata for strategies given an array of vault addresses and a filter\r\n     */\r\n    function assetsStrategiesByFilter(address[] memory _assetsAddresses, string[][] memory _filter)\r\n        public\r\n        view\r\n        returns (StrategyMetadata[] memory)\r\n    {\r\n        return strategies(assetsStrategiesAddressesByFilter(_assetsAddresses, _filter));\r\n    }\r\n    \r\n    /**\r\n     * Fetch metadata for a strategy given a strategy address\r\n     */\r\n    function strategy(address strategyAddress)\r\n        public\r\n        view\r\n        returns (StrategyMetadata memory)\r\n    {\r\n        IV2Strategy _strategy = IV2Strategy(strategyAddress);\r\n        IOracle _oracle = IOracle(oracleAddress);\r\n        bool _doHealthCheck;\r\n        address _healthCheckAddress;\r\n        address _wantAddress = _strategy.want();\r\n        IERC20 _want = IERC20(_wantAddress);\r\n        uint256 _wantPriceUsdc = _oracle.getPriceUsdcRecommended(_wantAddress);\r\n        uint256 _estimatedTotalAssets = _strategy.estimatedTotalAssets();\r\n        try _strategy.doHealthCheck() {\r\n            _doHealthCheck = _strategy.doHealthCheck();\r\n        } catch {}\r\n        try _strategy.healthCheck() {\r\n             _healthCheckAddress = _strategy.healthCheck();\r\n        } catch {}\r\n        return\r\n            StrategyMetadata({\r\n                name: _strategy.name(),\r\n                id: strategyAddress,\r\n                apiVersion: _strategy.apiVersion(),\r\n                strategist: _strategy.strategist(),\r\n                rewards: _strategy.rewards(),\r\n                vault: _strategy.vault(),\r\n                keeper: _strategy.keeper(),\r\n                want: _wantAddress,\r\n                wantPriceUsdc: _wantPriceUsdc,\r\n                wantDecimals: _want.decimals(),\r\n                wantSymbol: _want.symbol(),\r\n                emergencyExit: _strategy.emergencyExit(),\r\n                isActive: _strategy.isActive(),\r\n                delegatedAssets: _strategy.delegatedAssets(),\r\n                estimatedTotalAssets: _estimatedTotalAssets,\r\n                estimatedTotalAssetsUsdc: _oracle.getNormalizedValueUsdc(_wantAddress, _estimatedTotalAssets, _wantPriceUsdc),\r\n                doHealthCheck: _doHealthCheck,\r\n                healthCheckAddress: _healthCheckAddress\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Fetch metadata for strategies given an array of strategy addresses\r\n     */\r\n    function strategies(address[] memory _strategiesAddresses)\r\n        public\r\n        view\r\n        returns (StrategyMetadata[] memory)\r\n    {\r\n        uint256 numberOfStrategies = _strategiesAddresses.length;\r\n        StrategyMetadata[] memory _strategies =\r\n            new StrategyMetadata[](numberOfStrategies);\r\n        for (\r\n            uint256 strategyIdx = 0;\r\n            strategyIdx < numberOfStrategies;\r\n            strategyIdx++\r\n        ) {\r\n            address strategyAddress = _strategiesAddresses[strategyIdx];\r\n            StrategyMetadata memory _strategy = strategy(strategyAddress);\r\n            _strategies[strategyIdx] = _strategy;\r\n        }\r\n        return _strategies;\r\n    }\r\n    \r\n    /**\r\n     * Filter a strategy using a reverse polish notation (RPM) query language\r\n     *\r\n     * Each instruction is a tuple of either two or three strings.\r\n     *\r\n     * Argument 0 - Operand type\r\n     * -------------------------\r\n     * KEY      - Denotes a value should be fetched using a function sighash derived from argument 1\r\n     * VALUE    - A value to be added directly to the stack\r\n     * OPERATOR - The name of the instruction to execute\r\n     *\r\n     * Argument 1 - Key/Value or operator\r\n     * ----------------------------------\r\n     * Data     - If KEY or VALUE are specified in argument 0, argument 1 represents either the key\r\n     *            to fetch data with or the value to be added to the stack\r\n     * Operator - If OPERATOR is specified in argument 0, argument 1 represents the operator to execute.\r\n     *            Valid operators are: EQ, GT, GTE, LT, LTE, OR, AND, NE and LIKE\r\n     *\r\n     * Argument 2 - Value type\r\n     * -----------------------\r\n     * For key/value operands argument 2 describes how to parse a value to be placed on the stack.\r\n     * Valid options are: STRING, HEX, DECIMAL\r\n     *\r\n     * Note: The stack size is 32 bytes. Any values beyond this will be truncated.\r\n     *\r\n     * Example Filter\r\n     * ==============\r\n     * Description: Find all strategies whose apiVersion is like 0.3.5 or 0.3.3\r\n     *              where strategist address is C3D6880fD95E06C816cB030fAc45b3ffe3651Cb0\r\n     * filter = [\r\n     *     [\"KEY\",        \"apiVersion\", \"STRING\"],\r\n     *     [\"VALUE\",      \"0.3.5\", \"STRING\"],\r\n     *     [\"OPERATOR\",   \"LIKE\"],\r\n     *     [\"KEY\",        \"apiVersion\", \"STRING\"],\r\n     *     [\"VALUE\",      \"0.3.3\", \"STRING\"],\r\n     *     [\"OPERATOR\",   \"LIKE\"],\r\n     *     [\"OPERATOR\",   \"OR\"],\r\n     *     [\"KEY\",        \"strategist\", \"HEX\"],\r\n     *     [\"VALUE\",      \"C3D6880fD95E06C816cB030fAc45b3ffe3651Cb0\", \"HEX\"],\r\n     *     [\"OPERATOR\",   \"EQ\"],\r\n     *     [\"OPERATOR\",   \"AND\"]\r\n     * ];\r\n     */\r\n    function strategyPassesFilter(address strategyAddress, string[][] memory instructions) public view returns (bool) {\r\n        bytes32[] memory stack = new bytes32[](instructions.length * 3);\r\n        uint256 stackLength;\r\n        for (uint256 instructionsIdx; instructionsIdx < instructions.length; instructionsIdx++) {\r\n            string[] memory instruction = instructions[instructionsIdx];\r\n            string memory instructionPart1 = instruction[1];\r\n            bool operandIsOperator = stringsEqual(instruction[0], \"OPERATOR\");\r\n            if (operandIsOperator) {\r\n                bool result;\r\n                bytes32 operandTwo = stack[stackLength - 1];\r\n                bytes32 operandOne = stack[stackLength - 2];\r\n                if (stringsEqual(instruction[1], \"EQ\")) {\r\n                    result = uint256(operandTwo) == uint256(operandOne);\r\n                }\r\n                if (stringsEqual(instruction[1], \"NE\")) {\r\n                    result = uint256(operandTwo) != uint256(operandOne);\r\n                }\r\n                if (stringsEqual(instruction[1], \"GT\")) {\r\n                    result = uint256(operandTwo) > uint256(operandOne);\r\n                }\r\n                if (stringsEqual(instruction[1], \"GTE\")) {\r\n                    result = uint256(operandTwo) >= uint256(operandOne);\r\n                }\r\n                if (stringsEqual(instruction[1], \"LT\")) {\r\n                    result = uint256(operandTwo) < uint256(operandOne);\r\n                }\r\n                if (stringsEqual(instruction[1], \"LTE\")) {\r\n                    result = uint256(operandTwo) <= uint256(operandOne);\r\n                }\r\n                if (stringsEqual(instruction[1], \"AND\")) {\r\n                    result = uint256(operandTwo & operandOne) == 1;\r\n                }\r\n                if (stringsEqual(instruction[1], \"OR\")) {\r\n                    result = uint256(operandTwo | operandOne) == 1;\r\n                }\r\n                if (stringsEqual(instruction[1], \"LIKE\")) {\r\n                    string memory haystack = String.bytes32ToString(operandOne);\r\n                    string memory needle = String.bytes32ToString(operandTwo);\r\n                    result = String.contains(haystack, needle);\r\n                }\r\n                if (result) {\r\n                    stack[stackLength - 2] = bytes32(uint256(1));\r\n                } else {\r\n                    stack[stackLength - 2] = bytes32(uint256(0));\r\n                }\r\n                stackLength--;\r\n            } else {\r\n                bytes32 stackItem;\r\n                bool operandIsKey = stringsEqual(instruction[0], \"KEY\");\r\n                bytes memory data;\r\n                if (operandIsKey) {\r\n                    (, bytes memory matchBytes) =\r\n                        address(strategyAddress).staticcall(abi.encodeWithSignature(string(abi.encodePacked(instruction[1], \"()\"))));\r\n                    data = matchBytes;\r\n                }\r\n                if (stringsEqual(instruction[2], \"HEX\")) {\r\n                    if (operandIsKey == true) {\r\n                        assembly {\r\n                            stackItem := mload(add(data, 0x20))\r\n                        }\r\n                    } else {\r\n                        stackItem = bytes32(atoi(String.uppercase(instruction[1]), 16));\r\n                    }\r\n                } else if (stringsEqual(instruction[2], \"STRING\")) {\r\n                    if (operandIsKey == true) {\r\n                        assembly {\r\n                            stackItem := mload(add(data, 0x60))\r\n                        }\r\n                    } else {\r\n                        assembly {\r\n                            stackItem := mload(add(instructionPart1, 0x20))\r\n                        }                        \r\n                    }\r\n                } else if (stringsEqual(instruction[2], \"DECIMAL\")) {\r\n                    if (operandIsKey == true) {\r\n                        assembly {\r\n                            stackItem := mload(add(data, 0x20))\r\n                        }\r\n                    } else {\r\n                        stackItem = bytes32(atoi(instruction[1], 10));\r\n                    }\r\n                }\r\n                stack[stackLength] = stackItem;\r\n                stackLength++;\r\n            }\r\n        }\r\n        if (uint256(stack[0]) == 1) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Allow storage slots to be manually updated\r\n     */\r\n    function updateSlot(bytes32 slot, bytes32 value) external {\r\n        require(msg.sender == ownerAddress, \"Caller is not the owner\");\r\n        assembly {\r\n            sstore(slot, value)\r\n        }\r\n    }\r\n}\r\n\r\nlibrary String {\r\n    /**\r\n     * Convert a string to lowercase\r\n     */\r\n    function lowercase(string memory input) internal pure returns (string memory) {\r\n        bytes memory _input = bytes(input);\r\n        for (uint inputIdx = 0; inputIdx < _input.length; inputIdx++) {\r\n            uint8 character = uint8(_input[inputIdx]);\r\n            if (character >= 65 && character <= 90) {\r\n                character += 0x20;\r\n                _input[inputIdx] = bytes1(character);\r\n            }\r\n        }\r\n        return string(_input);\r\n    }\r\n\r\n    /**\r\n     * Convert a string to uppercase\r\n     */\r\n    function uppercase(string memory input) internal pure returns (string memory) {\r\n        bytes memory _input = bytes(input);\r\n        for (uint inputIdx = 0; inputIdx < _input.length; inputIdx++) {\r\n            uint8 character = uint8(_input[inputIdx]);\r\n            if (character >= 97 && character <= 122) {\r\n                character -= 0x20;\r\n                _input[inputIdx] = bytes1(character);\r\n            }\r\n        }\r\n        return string(_input);\r\n    }\r\n\r\n    /**\r\n     * Search for a needle in a haystack\r\n     */\r\n    function contains(string memory haystack, string memory needle) internal pure returns (bool) {\r\n        return indexOf(needle, haystack) >= 0;\r\n    }\r\n    \r\n    /**\r\n     * Convert bytes32 to string and remove padding\r\n     */\r\n    function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\r\n        uint8 i = 0;\r\n        while(i < 32 && _bytes32[i] != 0) {\r\n            i++;\r\n        }\r\n        bytes memory bytesArray = new bytes(i);\r\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\r\n            bytesArray[i] = _bytes32[i];\r\n        }\r\n        return string(bytesArray);\r\n    }\r\n\r\n    /**\r\n     * Case insensitive string search\r\n     *\r\n     * @param needle The string to search for\r\n     * @param haystack The string to search in\r\n     * @return Returns -1 if no match is found, otherwise returns the index of the match \r\n     */\r\n    function indexOf(string memory needle, string memory haystack) internal pure returns (int256) {\r\n        bytes memory _needle = bytes(lowercase(needle));\r\n        bytes memory _haystack = bytes(lowercase(haystack));\r\n        if (_haystack.length < _needle.length) {\r\n            return -1;\r\n        }\r\n        bool _match;\r\n        for (uint256 haystackIdx; haystackIdx < _haystack.length; haystackIdx++) {\r\n            for (uint256 needleIdx; needleIdx < _needle.length; needleIdx++) {\r\n                uint8 needleChar = uint8(_needle[needleIdx]);\r\n                if (haystackIdx + needleIdx >= _haystack.length) {\r\n                    return -1;\r\n                }\r\n                uint8 haystackChar = uint8(_haystack[haystackIdx + needleIdx]);\r\n                if (needleChar == haystackChar) {\r\n                    _match = true;\r\n                    if (needleIdx == _needle.length - 1) {\r\n                        return int(haystackIdx);\r\n                    }\r\n                } else {\r\n                    _match = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressesGeneratorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addressesMergeHelperAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracleAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"addressesGeneratorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressesMergeHelperAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetStrategies\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"apiVersion\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"strategist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wantPriceUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"wantDecimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"wantSymbol\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"emergencyExit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"delegatedAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedTotalAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedTotalAssetsUsdc\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"doHealthCheck\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"healthCheckAddress\",\"type\":\"address\"}],\"internalType\":\"struct StrategiesHelper.StrategyMetadata[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetStrategiesAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetStrategiesDelegatedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetStrategiesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assetsAddresses\",\"type\":\"address[]\"}],\"name\":\"assetsStrategies\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"apiVersion\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"strategist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wantPriceUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"wantDecimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"wantSymbol\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"emergencyExit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"delegatedAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedTotalAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedTotalAssetsUsdc\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"doHealthCheck\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"healthCheckAddress\",\"type\":\"address\"}],\"internalType\":\"struct StrategiesHelper.StrategyMetadata[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsStrategies\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"apiVersion\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"strategist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wantPriceUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"wantDecimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"wantSymbol\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"emergencyExit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"delegatedAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedTotalAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedTotalAssetsUsdc\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"doHealthCheck\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"healthCheckAddress\",\"type\":\"address\"}],\"internalType\":\"struct StrategiesHelper.StrategyMetadata[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsStrategiesAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assetsAddresses\",\"type\":\"address[]\"}],\"name\":\"assetsStrategiesAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[][]\",\"name\":\"filter\",\"type\":\"string[][]\"}],\"name\":\"assetsStrategiesAddressesByFilter\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_strategiesAddresses\",\"type\":\"address[]\"},{\"internalType\":\"string[][]\",\"name\":\"filter\",\"type\":\"string[][]\"}],\"name\":\"assetsStrategiesAddressesByFilter\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[][]\",\"name\":\"_filter\",\"type\":\"string[][]\"}],\"name\":\"assetsStrategiesByFilter\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"apiVersion\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"strategist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wantPriceUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"wantDecimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"wantSymbol\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"emergencyExit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"delegatedAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedTotalAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedTotalAssetsUsdc\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"doHealthCheck\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"healthCheckAddress\",\"type\":\"address\"}],\"internalType\":\"struct StrategiesHelper.StrategyMetadata[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assetsAddresses\",\"type\":\"address[]\"},{\"internalType\":\"string[][]\",\"name\":\"_filter\",\"type\":\"string[][]\"}],\"name\":\"assetsStrategiesByFilter\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"apiVersion\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"strategist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wantPriceUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"wantDecimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"wantSymbol\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"emergencyExit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"delegatedAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedTotalAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedTotalAssetsUsdc\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"doHealthCheck\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"healthCheckAddress\",\"type\":\"address\"}],\"internalType\":\"struct StrategiesHelper.StrategyMetadata[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsStrategiesDelegatedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsStrategiesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_strategiesAddresses\",\"type\":\"address[]\"}],\"name\":\"strategies\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"apiVersion\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"strategist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wantPriceUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"wantDecimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"wantSymbol\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"emergencyExit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"delegatedAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedTotalAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedTotalAssetsUsdc\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"doHealthCheck\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"healthCheckAddress\",\"type\":\"address\"}],\"internalType\":\"struct StrategiesHelper.StrategyMetadata[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"strategy\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"apiVersion\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"strategist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wantPriceUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"wantDecimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"wantSymbol\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"emergencyExit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"delegatedAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedTotalAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedTotalAssetsUsdc\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"doHealthCheck\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"healthCheckAddress\",\"type\":\"address\"}],\"internalType\":\"struct StrategiesHelper.StrategyMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"},{\"internalType\":\"string[][]\",\"name\":\"instructions\",\"type\":\"string[][]\"}],\"name\":\"strategyPassesFilter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"value\",\"type\":\"bytes32\"}],\"name\":\"updateSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StrategiesHelper","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000437758d475f70249e03eda6be23684ad1fc375f0000000000000000000000000957e3ae7983155a9f9e08da555b8084448be26e400000000000000000000000083d95e0d5f402511db06817aff3f9ea88224b030","EVMVersion":"Default","Library":"String:b7326bb9a7e7073725c3d8245ca931ad8b1a2204","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e8574d47957838679a93f3263b70e8793941363715b307e8c9b2b37aebd1842c"}]}