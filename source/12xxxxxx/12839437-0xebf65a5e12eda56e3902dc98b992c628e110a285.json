{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/options/lib/GenSymbol.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport {DateTime} from \\\"./DateTime.sol\\\";\\n\\n// SAFEMATH DISCLAIMER:\\n// We and don't use SafeMath here intentionally, because input values are based on chars arithmetics\\n// and the results are used solely for display purposes (generating a token SYMBOL).\\n// Moreover - input data is provided only by contract owners, as creation of tokens is limited to owner only.\\nlibrary GenSymbol {\\n    function monthToHex(uint8 m) public pure returns (bytes1) {\\n        if (m > 0 && m < 10) {\\n            return bytes1(uint8(bytes1(\\\"0\\\")) + m);\\n        } else if (m >= 10 && m < 13) {\\n            return bytes1(uint8(bytes1(\\\"A\\\")) + (m - 10));\\n        }\\n        revert(\\\"Invalid month\\\");\\n    }\\n\\n    function tsToDate(uint256 _ts) public pure returns (string memory) {\\n        bytes memory date = new bytes(4);\\n\\n        uint256 year = DateTime.getYear(_ts);\\n\\n        require(year >= 2020, \\\"Year cannot be before 2020 as it is coded only by one digit\\\");\\n        require(year < 2030, \\\"Year cannot be after 2029 as it is coded only by one digit\\\");\\n\\n        date[0] = bytes1(\\n            uint8(bytes1(\\\"0\\\")) + uint8(year - 2020) // 2020 is coded as \\\"0\\\"\\n        );\\n\\n        date[1] = monthToHex(DateTime.getMonth(_ts)); // October = 10 is coded by \\\"A\\\"\\n\\n        uint8 day = DateTime.getDay(_ts); // Day is just coded as a day of month starting from 1\\n        require(day > 0 && day <= 31, \\\"Invalid day\\\");\\n\\n        date[2] = bytes1(uint8(bytes1(\\\"0\\\")) + (day / 10));\\n        date[3] = bytes1(uint8(bytes1(\\\"0\\\")) + (day % 10));\\n\\n        return string(date);\\n    }\\n\\n    function RKMconvert(uint256 _num) public pure returns (bytes memory) {\\n        bytes memory map = \\\"0000KKKMMMGGGTTTPPPEEEZZZYYY\\\";\\n        uint8 len;\\n\\n        uint256 i = _num;\\n        while (i != 0) {\\n            // Calculate the length of the input number\\n            len++;\\n            i /= 10;\\n        }\\n\\n        bytes1 prefix = map[len]; // Get the prefix code letter\\n\\n        uint8 prefixPos = len > 3 ? ((len - 1) % 3) + 1 : 0; // Position of prefix (or 0 if the number is 3 digits or less)\\n\\n        // Get the leftmost 4 digits from input number or just take the number as is if its already 4 digits or less\\n        uint256 firstFour = len > 4 ? _num / 10**(len - 4) : _num;\\n\\n        bytes memory bStr = \\\"00000\\\";\\n        // We start from index 4 ^ of zero-string and go left\\n        uint8 index = 4;\\n\\n        while (firstFour != 0) {\\n            // If index is on prefix position - insert a prefix and decrease index\\n            if (index == prefixPos) bStr[index--] = prefix;\\n            bStr[index--] = bytes1(uint8(48 + (firstFour % 10)));\\n            firstFour /= 10;\\n        }\\n        return bStr;\\n    }\\n\\n    function uint2str(uint256 _num) public pure returns (bytes memory) {\\n        if (_num > 99999) return RKMconvert(_num);\\n\\n        if (_num == 0) {\\n            return \\\"00000\\\";\\n        }\\n        uint256 j = _num;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n\\n        bytes memory bStr = \\\"00000\\\";\\n        uint256 k = 4;\\n        while (_num != 0) {\\n            bStr[k--] = bytes1(uint8(48 + (_num % 10)));\\n            _num /= 10;\\n        }\\n        return bStr;\\n    }\\n\\n    function genOptionSymbol(\\n        uint256 _ts,\\n        string memory _type,\\n        bool put,\\n        uint256 _strikePrice\\n    ) external pure returns (string memory) {\\n        string memory putCall;\\n        putCall = put ? \\\"P\\\" : \\\"C\\\";\\n        return string(abi.encodePacked(_type, tsToDate(_ts), putCall, uint2str(_strikePrice)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/options/lib/DateTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Stripped version of the following:\\n// https://github.com/pipermerriam/ethereum-datetime\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\n// SAFEMATH DISCLAIMER:\\n// We and don't use SafeMath here intentionally, because all of the operations are basic arithmetics\\n// (we have introduced a limit of year 2100 to definitely fit into uint16, hoping Year2100-problem will not be our problem)\\n// and the results are used solely for display purposes (generating a token SYMBOL).\\n// Moreover - input data is provided only by contract owners, as creation of tokens is limited to owner only.\\nlibrary DateTime {\\n    struct _DateTime {\\n        uint16 year;\\n        uint8 month;\\n        uint8 day;\\n    }\\n\\n    uint256 constant DAY_IN_SECONDS = 86400; // leap second?\\n    uint256 constant YEAR_IN_SECONDS = 31536000;\\n    uint256 constant LEAP_YEAR_IN_SECONDS = 31622400;\\n\\n    uint16 constant ORIGIN_YEAR = 1970;\\n\\n    function isLeapYear(uint16 year) public pure returns (bool) {\\n        if (year % 4 != 0) {\\n            return false;\\n        }\\n        if (year % 100 != 0) {\\n            return true;\\n        }\\n        if (year % 400 != 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    function leapYearsBefore(uint256 year) public pure returns (uint256) {\\n        year -= 1;\\n        return year / 4 - year / 100 + year / 400;\\n    }\\n\\n    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\n            return 31;\\n        } else if (month == 4 || month == 6 || month == 9 || month == 11) {\\n            return 30;\\n        } else if (isLeapYear(year)) {\\n            return 29;\\n        } else {\\n            return 28;\\n        }\\n    }\\n\\n    function parseTimestamp(uint256 timestamp) public pure returns (_DateTime memory dt) {\\n        uint256 secondsAccountedFor = 0;\\n        uint256 buf;\\n        uint8 i;\\n\\n        // Year\\n        dt.year = getYear(timestamp);\\n        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\\n        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\\n\\n        // Month\\n        uint256 secondsInMonth;\\n        for (i = 1; i <= 12; i++) {\\n            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\\n            if (secondsInMonth + secondsAccountedFor > timestamp) {\\n                dt.month = i;\\n                break;\\n            }\\n            secondsAccountedFor += secondsInMonth;\\n        }\\n\\n        // Day\\n        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\\n            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\\n                dt.day = i;\\n                break;\\n            }\\n            secondsAccountedFor += DAY_IN_SECONDS;\\n        }\\n    }\\n\\n    function getYear(uint256 timestamp) public pure returns (uint16) {\\n        require(timestamp < 4102444800, \\\"Years after 2100 aren't supported for sanity and safety reasons\\\");\\n        uint256 secondsAccountedFor = 0;\\n        uint16 year;\\n        uint256 numLeapYears;\\n\\n        // Year\\n        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\\n\\n        while (secondsAccountedFor > timestamp) {\\n            if (isLeapYear(uint16(year - 1))) {\\n                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\\n            } else {\\n                secondsAccountedFor -= YEAR_IN_SECONDS;\\n            }\\n            year -= 1;\\n        }\\n        return year;\\n    }\\n\\n    function getMonth(uint256 timestamp) external pure returns (uint8) {\\n        return parseTimestamp(timestamp).month;\\n    }\\n\\n    function getDay(uint256 timestamp) external pure returns (uint8) {\\n        return parseTimestamp(timestamp).day;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/options/lib/DateTime.sol\": {\r\n        \"DateTime\": \"0x5c2487fe4019a1214f9b72a171ce7b74df3a3a44\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"RKMconvert\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ts\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_type\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"put\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_strikePrice\",\"type\":\"uint256\"}],\"name\":\"genOptionSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"m\",\"type\":\"uint8\"}],\"name\":\"monthToHex\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ts\",\"type\":\"uint256\"}],\"name\":\"tsToDate\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"uint2str\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"GenSymbol","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}