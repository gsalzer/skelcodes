{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.6.12;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction underflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract LevTreasuryVester {\r\n    using SafeMath for uint256;\r\n\r\n    address public lev;\r\n    mapping(address => TreasuryVester) internal _Treasury;\r\n\r\n    struct TreasuryVester {\r\n        uint256 vestingAmount;\r\n        uint256 vestingBegin;\r\n        uint256 vestingFirst;\r\n        uint256 vestingShare;\r\n        uint256 nextTime;\r\n        uint256 vestingCycle;\r\n    }\r\n\r\n    constructor(address _lev) public {\r\n        lev = _lev;\r\n    }\r\n\r\n    function creatTreasury(\r\n        address recipient_,\r\n        uint256 vestingAmount_,\r\n        uint256 vestingFirst_,\r\n        uint256 vestingShare_,\r\n        uint256 vestingBegin_,\r\n        uint256 vestingCycle_\r\n    ) external {\r\n        require(\r\n            vestingBegin_ >= block.timestamp,\r\n            \"TreasuryVester::creat: vesting begin too early\"\r\n        );\r\n        require(\r\n            vestingCycle_ >= 24 * 3600 * 30,\r\n            \"TreasuryVester::creat: vesting cycle too small\"\r\n        );\r\n        TreasuryVester storage treasury = _Treasury[recipient_];\r\n        require(\r\n            treasury.vestingAmount == 0,\r\n            \"TreasuryVester::creat: recipient already exists\"\r\n        );\r\n        treasury.vestingAmount = vestingAmount_;\r\n        treasury.vestingBegin = vestingBegin_;\r\n        treasury.vestingFirst = vestingFirst_;\r\n        treasury.vestingShare = vestingShare_;\r\n        treasury.nextTime = vestingBegin_;\r\n        treasury.vestingCycle = vestingCycle_;\r\n\r\n        ILev(lev).transferFrom(msg.sender, address(this), vestingAmount_);\r\n    }\r\n\r\n    function setRecipient(address recipient_) external {\r\n        TreasuryVester storage treasury = _Treasury[msg.sender];\r\n        TreasuryVester storage treasury2 = _Treasury[recipient_];\r\n        require(\r\n            treasury.vestingAmount > 0,\r\n            \"TreasuryVester::setRecipient: unauthorized\"\r\n        );\r\n        require(\r\n            treasury2.vestingAmount == 0,\r\n            \"TreasuryVester::setRecipient: recipient already exists\"\r\n        );\r\n        treasury2 = treasury;\r\n        treasury.vestingAmount = 0;\r\n    }\r\n\r\n    function claim() external {\r\n        TreasuryVester storage treasury = _Treasury[msg.sender];\r\n        require(\r\n            treasury.vestingAmount > 0,\r\n            \"TreasuryVester::claim: not sufficient funds\"\r\n        );\r\n        require(\r\n            block.timestamp >= treasury.nextTime,\r\n            \"TreasuryVester::claim: not time yet\"\r\n        );\r\n        uint256 amount;\r\n        if (treasury.nextTime == treasury.vestingBegin) {\r\n            amount = treasury.vestingFirst;\r\n        } else {\r\n            amount = treasury.vestingShare;\r\n        }\r\n        if (ILev(lev).balanceOf(address(this)) < amount) {\r\n            amount = ILev(lev).balanceOf(address(this));\r\n        }\r\n        if (treasury.vestingAmount < amount) {\r\n            amount = treasury.vestingAmount;\r\n        }\r\n        treasury.nextTime = treasury.nextTime.add(treasury.vestingCycle);\r\n        treasury.vestingAmount = treasury.vestingAmount.sub(amount);\r\n        ILev(lev).transfer(msg.sender, amount);\r\n    }\r\n}\r\n\r\ninterface ILev {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address dst, uint256 rawAmount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lev\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vestingAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingFirst_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingShare_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingBegin_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingCycle_\",\"type\":\"uint256\"}],\"name\":\"creatTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"}],\"name\":\"setRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LevTreasuryVester","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008eb624b2403c7fa5e19f2184765cb6195845765f","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://acff1d2849ee96cf18ee7ce92ae8188b227b5f0b7c2fcb07f34e54f29e49d132"}]}