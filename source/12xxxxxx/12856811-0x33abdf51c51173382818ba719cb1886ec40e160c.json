{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/metapriest/code/my_code/dotvote/contracts/contracts/SafeMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\nlibrary SafeMathLib {\\n  function times(uint a, uint b) public pure returns (uint) {\\n    uint c = a * b;\\n    require(a == 0 || c / a == b, 'Overflow detected');\\n    return c;\\n  }\\n\\n  function minus(uint a, uint b) public pure returns (uint) {\\n    require(b <= a, 'Underflow detected');\\n    return a - b;\\n  }\\n\\n  function plus(uint a, uint b) public pure returns (uint) {\\n    uint c = a + b;\\n    require(c>=a && c>=b, 'Overflow detected');\\n    return c;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"/home/metapriest/code/my_code/dotvote/contracts/contracts/identity/VotingIdentity2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\nimport \\\"../SafeMathLib.sol\\\";\\nimport \\\"../interfaces/IERC721Receiver.sol\\\";\\n\\n// ERC 721\\ncontract VotingIdentity2 {\\n    using SafeMathLib for uint;\\n\\n    mapping (uint => address) public owners;\\n    mapping (address => uint) public balances;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) public operatorApprovals;\\n    mapping (uint => address) public tokenApprovals;\\n\\n    // owner -> array of tokens owned...  ownershipMap[owner][index] = tokenNumber\\n    mapping (address => mapping (uint => uint)) public ownershipMap;\\n\\n    // array of all tokens in existence #enumeration\\n    mapping (uint => uint) public allTokens;\\n\\n    // tokenId -> uri ... typically ipfs://...\\n    mapping (uint => string) public uriMap;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\\n     *\\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n     */\\n    bytes4 private constant INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    bytes4 private constant INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n    bytes4 private constant INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n    string _name;\\n    string _symbol;\\n\\n    uint public numIdentities = 0;\\n\\n    // owner is a special name in the OpenZeppelin standard that opensea annoyingly expects for their management page\\n    address public _owner;\\n    // minter has the sole, permanent authority to mint identities, in practice this will be a contract\\n    address public _minter;\\n\\n    event OwnerUpdated(address oldOwner, address newOwner);\\n    event IdentityCreated(address indexed owner, uint indexed token);\\n\\n\\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\\n    ///  may be created and assigned without emitting Transfer. At the time of\\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /// @dev This emits when the approved address for an NFT is changed or\\n    ///  reaffirmed. The zero address indicates there is no approved address.\\n    ///  When a Transfer event emits, this also indicates that the approved\\n    ///  address for that NFT (if any) is reset to none.\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /// @dev This emits when an operator is enabled or disabled for an owner.\\n    ///  The operator can manage all NFTs of the owner.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    modifier ownerOnly() {\\n        require (msg.sender == _owner, 'Identity: Only owner may call this');\\n        _;\\n    }\\n\\n    constructor(address ooner, address minter, string memory nomen, string memory symbowl) {\\n        _owner = ooner;\\n        // we set it here with no resetting allowed so we cannot commit to NFTs and then reset\\n        _minter = minter;\\n        _name = nomen;\\n        _symbol = symbowl;\\n    }\\n\\n    // this function creates an identity for free. Only minter can call it.\\n    function createIdentityFor(address thisOwner, uint thisToken, string memory uri) public {\\n        require(msg.sender == _minter, 'Only minter may create identity');\\n        require(owners[thisToken] == address(0), 'Token already exists');\\n\\n        // for getTokenByIndex below, 0 based index so we do it before incrementing numIdentities\\n        allTokens[numIdentities] = thisToken;\\n\\n        // increment the number of identities\\n        numIdentities = numIdentities.plus(1);\\n\\n        // set owner of new token\\n        owners[thisToken] = thisOwner;\\n\\n        // append token to tokens owned\\n        ownershipMap[thisOwner][balances[thisOwner]] = thisToken;\\n\\n        // increment balances for owner\\n        balances[thisOwner] = balances[thisOwner].plus(1);\\n        uriMap[thisToken] = uri;\\n        emit Transfer(address(0), thisOwner, thisToken);\\n        emit IdentityCreated(thisOwner, thisToken);\\n    }\\n\\n    /// ================= SETTERS =======================================\\n\\n    // change the owner key\\n    function setOwner(address newOwner) external ownerOnly {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnerUpdated(oldOwner, newOwner);\\n    }\\n\\n    /// ================= ERC 721 FUNCTIONS =============================================\\n\\n    /// @notice Count all NFTs assigned to an owner\\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\\n    ///  function throws for queries about the zero address.\\n    /// @param _address An address for whom to query the balance\\n    /// @return The number of NFTs owned by `owner`, possibly zero\\n    function balanceOf(address _address) external view returns (uint256) {\\n        return balances[_address];\\n    }\\n\\n    /// @notice Find the owner of an NFT\\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\\n    ///  about them do throw.\\n    /// @param tokenId The identifier for an NFT\\n    /// @return The address of the owner of the NFT\\n    function ownerOf(uint256 tokenId) external view returns (address)  {\\n        address ooner = owners[tokenId];\\n        require(ooner != address(0), 'No such token');\\n        return ooner;\\n    }\\n\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n    ///  TO CONFIRM THAT `to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n    ///  THEY MAY BE PERMANENTLY LOST\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    ///  operator, or the approved address for this NFT. Throws if `from` is\\n    ///  not the current owner. Throws if `to` is the zero address. Throws if\\n    ///  `tokenId` is not a valid NFT.\\n    /// @param from The current owner of the NFT\\n    /// @param to The new owner\\n    /// @param tokenId The NFT to transfer\\n    function transferFrom(address from, address to, uint256 tokenId) public {\\n        require(isApproved(msg.sender, tokenId), 'Identity: Unapproved transfer');\\n        transfer(from, to, tokenId);\\n    }\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    ///  operator, or the approved address for this NFT. Throws if `from` is\\n    ///  not the current owner. Throws if `to` is the zero address. Throws if\\n    ///  `tokenId` is not a valid NFT. When transfer is complete, this function\\n    ///  checks if `to` is a smart contract (code size > 0). If so, it calls\\n    ///  `onERC721Received` on `to` and throws if the return value is not\\n    ///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n    /// @param from The current owner of the NFT\\n    /// @param to The new owner\\n    /// @param tokenId The NFT to transfer\\n    /// @param data Additional data with no specified format, sent in call to `to`\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {\\n        transferFrom(from, to, tokenId);\\n        require(checkOnERC721Received(from, to, tokenId, data), \\\"Identity: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev This works identically to the other function with an extra data parameter,\\n    ///  except this function just sets data to \\\"\\\".\\n    /// @param from The current owner of the NFT\\n    /// @param to The new owner\\n    /// @param tokenId The NFT to transfer\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n\\n    /// @notice Change or reaffirm the approved address for an NFT\\n    /// @dev The zero address indicates there is no approved address.\\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\n    ///  operator of the current owner.\\n    /// @param approved The new approved NFT controller\\n    /// @param tokenId The NFT to approve\\n    function approve(address approved, uint256 tokenId) public {\\n        address holder = owners[tokenId];\\n        require(isApproved(msg.sender, tokenId), 'Identity: Not authorized to approve');\\n        require(holder != approved, 'Identity: Approving self not allowed');\\n        tokenApprovals[tokenId] = approved;\\n        emit Approval(holder, approved, tokenId);\\n    }\\n\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\n    ///  all of `msg.sender`'s assets\\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\\n    ///  multiple operators per owner.\\n    /// @param operator Address to add to the set of authorized operators\\n    /// @param approved True if the operator is approved, false to revoke approval\\n    function setApprovalForAll(address operator, bool approved) external {\\n        operatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /// @notice Get the approved address for a single NFT\\n    /// @dev Throws if `tokenId` is not a valid NFT.\\n    /// @param tokenId The NFT to find the approved address for\\n    /// @return The approved address for this NFT, or the zero address if there is none\\n    function getApproved(uint256 tokenId) external view returns (address) {\\n        address holder = owners[tokenId];\\n        require(holder != address(0), 'Identity: Invalid tokenId');\\n        return tokenApprovals[tokenId];\\n    }\\n\\n    /// @notice Query if an address is an authorized operator for another address\\n    /// @param _address The address that owns the NFTs\\n    /// @param operator The address that acts on behalf of the owner\\n    /// @return True if `operator` is an approved operator for `owner`, false otherwise\\n    function isApprovedForAll(address _address, address operator) public view returns (bool) {\\n        return operatorApprovals[_address][operator];\\n    }\\n\\n    /// ================ UTILS =========================\\n    function isApproved(address operator, uint tokenId) public view returns (bool) {\\n        address holder = owners[tokenId];\\n        return (\\n            operator == holder ||\\n            operatorApprovals[holder][operator] ||\\n            tokenApprovals[tokenId] == operator\\n        );\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address from, address to, uint256 tokenId) internal {\\n        require(owners[tokenId] == from, \\\"Identity: Transfer of token that is not own\\\");\\n        require(to != address(0), \\\"Identity: transfer to the zero address\\\");\\n\\n        // Clear approvals from the previous owner\\n        approve(address(0), tokenId);\\n\\n        owners[tokenId] = to;\\n        // decrement from balances n -> n-1\\n        balances[from] = balances[from].minus(1);\\n        // balances[from] now points to the tip of the \\\"array\\\", set it to 0\\n        ownershipMap[from][balances[from]] = 0;\\n\\n        // balances[to] points past the tip of the array, set it to the token\\n        ownershipMap[to][balances[to]] = tokenId;\\n        // increment balances[to] to point past the end of the array n-1 -> n\\n        balances[to] = balances[to].plus(1);\\n\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for non-contract addresses\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\\n        private returns (bool)\\n    {\\n        if (!isContract(to)) {\\n            return true;\\n        }\\n        IERC721Receiver target = IERC721Receiver(to);\\n        bytes4 retval = target.onERC721Received(from, to, tokenId, data);\\n        return ERC721_RECEIVED == retval;\\n    }\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\\n        return (\\n            interfaceId == INTERFACE_ID_ERC721 ||\\n            interfaceId == INTERFACE_ID_ERC165 ||\\n            interfaceId == INTERFACE_ID_ERC721_ENUMERABLE ||\\n            interfaceId == INTERFACE_ID_ERC721_METADATA\\n        );\\n    }\\n\\n    /// ================= ERC721Metadata FUNCTIONS =============================================\\n\\n    /// @notice A descriptive name for a collection of NFTs in this contract\\n    function name() external view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /// @notice An abbreviated name for NFTs in this contract\\n    function symbol() external view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\n    ///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n    ///  Metadata JSON Schema\\\".\\n    function tokenURI(uint256 _tokenId) external view returns (string memory) {\\n        return uriMap[_tokenId];\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /// ================= ERC721Enumerable FUNCTIONS =============================================\\n\\n\\n    /// @notice Count NFTs tracked by this contract\\n    /// @return A count of valid NFTs tracked by this contract, where each one of\\n    ///  them has an assigned and queryable owner not equal to the zero address\\n    function totalSupply() external view returns (uint256) {\\n        return numIdentities;\\n    }\\n\\n    /// @notice Enumerate valid NFTs\\n    /// @dev Throws if `_index` >= `totalSupply()`.\\n    /// @param _index A counter less than `totalSupply()`\\n    /// @return The token identifier for the `_index`th NFT,\\n    ///  (sort order not specified)\\n    function tokenByIndex(uint256 _index) external view returns (uint256) {\\n        require(_index < numIdentities, 'Invalid token index');\\n        return allTokens[_index];\\n    }\\n\\n    /// @notice Enumerate NFTs assigned to an owner\\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\\n    ///  `_owner` is the zero address, representing invalid NFTs.\\n    /// @param _address An address where we are interested in NFTs owned by them\\n    /// @param _index A counter less than `balanceOf(_owner)`\\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\\n    ///   (sort order not specified)\\n    function tokenOfOwnerByIndex(address _address, uint256 _index) external view returns (uint256) {\\n        require(_index < balances[_address], 'Index out of range');\\n        require(_address != address(0), 'Cannot query zero address');\\n        return ownershipMap[_address][_index];\\n    }\\n\\n\\n}\\n\"\r\n    },\r\n    \"/home/metapriest/code/my_code/dotvote/contracts/contracts/interfaces/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"/home/metapriest/code/my_code/dotvote/contracts/contracts/SafeMathLib.sol\": {\r\n        \"SafeMathLib\": \"0x82d7630c5EB722557De6D76575C9a7b8DE718500\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ooner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"nomen\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbowl\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"}],\"name\":\"IdentityCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"thisOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"thisToken\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"createIdentityFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numIdentities\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operatorApprovals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownershipMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenApprovals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uriMap\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VotingIdentity2","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000288fe43139741f91a8cbb6f4add83811c794851b000000000000000000000000fb0e8ff1deb51a76e4a623a4f839aa3a5ce786be000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000001245746874726164657220566f746572204944000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034556490000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}