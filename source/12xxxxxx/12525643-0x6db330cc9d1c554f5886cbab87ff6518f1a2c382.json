{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\nimport \\\"../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\nimport \\\"../proxy/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/BeaconProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"./IBeacon.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\\n *\\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\\n * conflict with the storage layout of the implementation behind the proxy.\\n *\\n * _Available since v3.4._\\n */\\ncontract BeaconProxy is Proxy {\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 private constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Initializes the proxy with `beacon`.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\\n     * constructor.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract with the interface {IBeacon}.\\n     */\\n    constructor(address beacon, bytes memory data) public payable {\\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.beacon\\\")) - 1));\\n        _setBeacon(beacon, data);\\n    }\\n\\n    /**\\n     * @dev Returns the current beacon address.\\n     */\\n    function _beacon() internal view virtual returns (address beacon) {\\n        bytes32 slot = _BEACON_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            beacon := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address of the associated beacon.\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return IBeacon(_beacon()).implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the proxy to use a new beacon.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract.\\n     * - The implementation returned by `beacon` must be a contract.\\n     */\\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\\n        require(\\n            Address.isContract(beacon),\\n            \\\"BeaconProxy: beacon is not a contract\\\"\\n        );\\n        require(\\n            Address.isContract(IBeacon(beacon).implementation()),\\n            \\\"BeaconProxy: beacon implementation is not a contract\\\"\\n        );\\n        bytes32 slot = _BEACON_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, beacon)\\n        }\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(_implementation(), data, \\\"BeaconProxy: function call failed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ProxyAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../access/Ownable.sol\\\";\\nimport \\\"./TransparentUpgradeableProxy.sol\\\";\\n\\n/**\\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\\n */\\ncontract ProxyAdmin is Ownable {\\n\\n    /**\\n     * @dev Returns the current implementation of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"implementation()\\\")) == 0x5c60da1b\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\\\"5c60da1b\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Returns the current admin of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"admin()\\\")) == 0xf851a440\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\\\"f851a440\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Changes the admin of `proxy` to `newAdmin`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the current admin of `proxy`.\\n     */\\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\\n        proxy.changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\\n        proxy.upgradeTo(implementation);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes memory data) public payable virtual onlyOwner {\\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./UpgradeableProxy.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n *\\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n *\\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n *\\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n *\\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\\n */\\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\\n    /**\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\\n     */\\n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {\\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _setAdmin(admin_);\\n    }\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _admin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function admin() external ifAdmin returns (address admin_) {\\n        admin_ = _admin();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function implementation() external ifAdmin returns (address implementation_) {\\n        implementation_ = _implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\\n     */\\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\\n        require(newAdmin != address(0), \\\"TransparentUpgradeableProxy: new admin is the zero address\\\");\\n        emit AdminChanged(_admin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\\n     */\\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\\n        _upgradeTo(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n     * proxied contract.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\\n        _upgradeTo(newImplementation);\\n        Address.functionDelegateCall(newImplementation, data);\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _admin() internal view virtual returns (address adm) {\\n        bytes32 slot = _ADMIN_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            adm := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        bytes32 slot = _ADMIN_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, newAdmin)\\n        }\\n    }\\n\\n    /**\\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\\n     */\\n    function _beforeFallback() internal virtual override {\\n        require(msg.sender != _admin(), \\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\n        super._beforeFallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/UpgradeableBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"../access/Ownable.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\n\\n/**\\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\\n * implementation contract, which is where they will delegate all function calls.\\n *\\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\\n */\\ncontract UpgradeableBeacon is IBeacon, Ownable {\\n    address private _implementation;\\n\\n    /**\\n     * @dev Emitted when the implementation returned by the beacon is changed.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\\n     * beacon.\\n     */\\n    constructor(address implementation_) public {\\n        _setImplementation(implementation_);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function implementation() public view virtual override returns (address) {\\n        return _implementation;\\n    }\\n\\n    /**\\n     * @dev Upgrades the beacon to a new implementation.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * Requirements:\\n     *\\n     * - msg.sender must be the owner of the contract.\\n     * - `newImplementation` must be a contract.\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Sets the implementation contract address for this beacon\\n     *\\n     * Requirements:\\n     *\\n     * - `newImplementation` must be a contract.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"UpgradeableBeacon: implementation is not a contract\\\");\\n        _implementation = newImplementation;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/UpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n *\\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\\n * {TransparentUpgradeableProxy}.\\n */\\ncontract UpgradeableProxy is Proxy {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) public payable {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _setImplementation(_logic);\\n        if(_data.length > 0) {\\n            Address.functionDelegateCall(_logic, _data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Upgrades the proxy to a new implementation.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal virtual {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"UpgradeableProxy: new implementation is not a contract\\\");\\n\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, newImplementation)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor () internal {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/arch/Hashing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./Value.sol\\\";\\n\\nlibrary Hashing {\\n    using Hashing for Value.Data;\\n    using Value for Value.CodePoint;\\n\\n    function keccak1(bytes32 b) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(b));\\n    }\\n\\n    function keccak2(bytes32 a, bytes32 b) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(a, b));\\n    }\\n\\n    function bytes32FromArray(\\n        bytes memory arr,\\n        uint256 offset,\\n        uint256 arrLength\\n    ) internal pure returns (uint256) {\\n        uint256 res = 0;\\n        for (uint256 i = 0; i < 32; i++) {\\n            res = res << 8;\\n            bytes1 b = arrLength > offset + i ? arr[offset + i] : bytes1(0);\\n            res = res | uint256(uint8(b));\\n        }\\n        return res;\\n    }\\n\\n    /*\\n     * !! Note that dataLength must be a power of two !!\\n     *\\n     * If you have an arbitrary data length, you can round it up with roundUpToPow2.\\n     * The boolean return value tells if the data segment data[startOffset..startOffset+dataLength] only included zeroes.\\n     * If pack is true, the returned value is the merkle hash where trailing zeroes are ignored, that is,\\n     *   if h is the smallest height for which all data[startOffset+2**h..] are zero, merkle hash of data[startOffset..startOffset+2**h] is returned.\\n     * If all elements in the data segment are zero (and pack is true), keccak1(bytes32(0)) is returned.\\n     */\\n    function merkleRoot(\\n        bytes memory data,\\n        uint256 rawDataLength,\\n        uint256 startOffset,\\n        uint256 dataLength,\\n        bool pack\\n    ) internal pure returns (bytes32, bool) {\\n        if (dataLength <= 32) {\\n            if (startOffset >= rawDataLength) {\\n                return (keccak1(bytes32(0)), true);\\n            }\\n            bytes32 res = keccak1(bytes32(bytes32FromArray(data, startOffset, rawDataLength)));\\n            return (res, res == keccak1(bytes32(0)));\\n        }\\n        (bytes32 h2, bool zero2) =\\n            merkleRoot(data, rawDataLength, startOffset + dataLength / 2, dataLength / 2, false);\\n        if (zero2 && pack) {\\n            return merkleRoot(data, rawDataLength, startOffset, dataLength / 2, pack);\\n        }\\n        (bytes32 h1, bool zero1) =\\n            merkleRoot(data, rawDataLength, startOffset, dataLength / 2, false);\\n        return (keccak2(h1, h2), zero1 && zero2);\\n    }\\n\\n    function roundUpToPow2(uint256 len) internal pure returns (uint256) {\\n        if (len <= 1) return 1;\\n        else return 2 * roundUpToPow2((len + 1) / 2);\\n    }\\n\\n    function bytesToBufferHash(\\n        bytes memory buf,\\n        uint256 startOffset,\\n        uint256 length\\n    ) internal pure returns (bytes32) {\\n        (bytes32 mhash, ) =\\n            merkleRoot(buf, startOffset + length, startOffset, roundUpToPow2(length), true);\\n        return keccak2(bytes32(uint256(123)), mhash);\\n    }\\n\\n    function hashInt(uint256 val) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(val));\\n    }\\n\\n    function hashCodePoint(Value.CodePoint memory cp) internal pure returns (bytes32) {\\n        assert(cp.immediate.length < 2);\\n        if (cp.immediate.length == 0) {\\n            return\\n                keccak256(abi.encodePacked(Value.codePointTypeCode(), cp.opcode, cp.nextCodePoint));\\n        }\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    Value.codePointTypeCode(),\\n                    cp.opcode,\\n                    cp.immediate[0].hash(),\\n                    cp.nextCodePoint\\n                )\\n            );\\n    }\\n\\n    function hashTuplePreImage(bytes32 innerHash, uint256 valueSize)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(uint8(Value.tupleTypeCode()), innerHash, valueSize));\\n    }\\n\\n    function hash(Value.Data memory val) internal pure returns (bytes32) {\\n        if (val.typeCode == Value.intTypeCode()) {\\n            return hashInt(val.intVal);\\n        } else if (val.typeCode == Value.codePointTypeCode()) {\\n            return hashCodePoint(val.cpVal);\\n        } else if (val.typeCode == Value.tuplePreImageTypeCode()) {\\n            return hashTuplePreImage(bytes32(val.intVal), val.size);\\n        } else if (val.typeCode == Value.tupleTypeCode()) {\\n            Value.Data memory preImage = getTuplePreImage(val.tupleVal);\\n            return preImage.hash();\\n        } else if (val.typeCode == Value.hashOnlyTypeCode()) {\\n            return bytes32(val.intVal);\\n        } else if (val.typeCode == Value.bufferTypeCode()) {\\n            return keccak256(abi.encodePacked(uint256(123), val.bufferHash));\\n        } else {\\n            require(false, \\\"Invalid type code\\\");\\n        }\\n    }\\n\\n    function getTuplePreImage(Value.Data[] memory vals) internal pure returns (Value.Data memory) {\\n        require(vals.length <= 8, \\\"Invalid tuple length\\\");\\n        bytes32[] memory hashes = new bytes32[](vals.length);\\n        uint256 hashCount = hashes.length;\\n        uint256 size = 1;\\n        for (uint256 i = 0; i < hashCount; i++) {\\n            hashes[i] = vals[i].hash();\\n            size += vals[i].size;\\n        }\\n        bytes32 firstHash = keccak256(abi.encodePacked(uint8(hashes.length), hashes));\\n        return Value.newTuplePreImage(firstHash, size);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/arch/IOneStepProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../bridge/interfaces/IBridge.sol\\\";\\nimport \\\"../bridge/interfaces/ISequencerInbox.sol\\\";\\n\\ninterface IOneStepProof {\\n    // Bridges is sequencer bridge then delayed bridge\\n    function executeStep(\\n        address[2] calldata bridges,\\n        uint256 initialMessagesRead,\\n        bytes32[2] calldata accs,\\n        bytes calldata proof,\\n        bytes calldata bproof\\n    )\\n        external\\n        view\\n        returns (\\n            uint64 gas,\\n            uint256 afterMessagesRead,\\n            bytes32[4] memory fields\\n        );\\n\\n    function executeStepDebug(\\n        address[2] calldata bridges,\\n        uint256 initialMessagesRead,\\n        bytes32[2] calldata accs,\\n        bytes calldata proof,\\n        bytes calldata bproof\\n    ) external view returns (string memory startMachine, string memory afterMachine);\\n}\\n\"\r\n    },\r\n    \"contracts/arch/Marshaling.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./Value.sol\\\";\\nimport \\\"./Hashing.sol\\\";\\n\\nimport \\\"../libraries/BytesLib.sol\\\";\\n\\nlibrary Marshaling {\\n    using BytesLib for bytes;\\n    using Value for Value.Data;\\n\\n    // This depends on how it's implemented in arb-os\\n    function deserializeMessage(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            bool,\\n            uint256,\\n            address,\\n            uint8,\\n            bytes memory\\n        )\\n    {\\n        require(data.length >= startOffset && data.length - startOffset >= 8, \\\"too short\\\");\\n        uint256 size = 0;\\n        for (uint256 i = 0; i < 8; i++) {\\n            size *= 256;\\n            size += uint8(data[startOffset + 7 - i]);\\n        }\\n        (, uint256 sender) = deserializeInt(data, startOffset + 8);\\n        (, uint256 kind) = deserializeInt(data, startOffset + 8 + 32);\\n        bytes memory res = new bytes(size - 64);\\n        for (uint256 i = 0; i < size - 64; i++) {\\n            res[i] = data[startOffset + 8 + 64 + i];\\n        }\\n        return (true, startOffset + 8 + size, address(uint160(sender)), uint8(kind), res);\\n    }\\n\\n    function deserializeRawMessage(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            bool,\\n            uint256,\\n            bytes memory\\n        )\\n    {\\n        require(data.length >= startOffset && data.length - startOffset >= 8, \\\"too short\\\");\\n        uint256 size = 0;\\n        for (uint256 i = 0; i < 8; i++) {\\n            size *= 256;\\n            size += uint8(data[startOffset + 7 - i]);\\n        }\\n        bytes memory res = new bytes(size);\\n        for (uint256 i = 0; i < size; i++) {\\n            res[i] = data[startOffset + 8 + i];\\n        }\\n        return (true, startOffset + 8 + size, res);\\n    }\\n\\n    function deserializeHashPreImage(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (uint256 offset, Value.Data memory value)\\n    {\\n        require(data.length >= startOffset && data.length - startOffset >= 64, \\\"too short\\\");\\n        bytes32 hashData;\\n        uint256 size;\\n        (offset, hashData) = extractBytes32(data, startOffset);\\n        (offset, size) = deserializeInt(data, offset);\\n        return (offset, Value.newTuplePreImage(hashData, size));\\n    }\\n\\n    function deserializeInt(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            uint256 // val\\n        )\\n    {\\n        require(data.length >= startOffset && data.length - startOffset >= 32, \\\"too short\\\");\\n        return (startOffset + 32, data.toUint(startOffset));\\n    }\\n\\n    function deserializeBytes32(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            bytes32 // val\\n        )\\n    {\\n        require(data.length >= startOffset && data.length - startOffset >= 32, \\\"too short\\\");\\n        return (startOffset + 32, data.toBytes32(startOffset));\\n    }\\n\\n    function deserializeCodePoint(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            Value.Data memory // val\\n        )\\n    {\\n        uint256 offset = startOffset;\\n        uint8 immediateType;\\n        uint8 opCode;\\n        Value.Data memory immediate;\\n        bytes32 nextHash;\\n\\n        (offset, immediateType) = extractUint8(data, offset);\\n        (offset, opCode) = extractUint8(data, offset);\\n        if (immediateType == 1) {\\n            (offset, immediate) = deserialize(data, offset);\\n        }\\n        (offset, nextHash) = extractBytes32(data, offset);\\n        if (immediateType == 1) {\\n            return (offset, Value.newCodePoint(opCode, nextHash, immediate));\\n        }\\n        return (offset, Value.newCodePoint(opCode, nextHash));\\n    }\\n\\n    function deserializeTuple(\\n        uint8 memberCount,\\n        bytes memory data,\\n        uint256 startOffset\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            Value.Data[] memory // val\\n        )\\n    {\\n        uint256 offset = startOffset;\\n        Value.Data[] memory members = new Value.Data[](memberCount);\\n        for (uint8 i = 0; i < memberCount; i++) {\\n            (offset, members[i]) = deserialize(data, offset);\\n        }\\n        return (offset, members);\\n    }\\n\\n    function deserialize(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            Value.Data memory // val\\n        )\\n    {\\n        require(startOffset < data.length, \\\"invalid offset\\\");\\n        (uint256 offset, uint8 valType) = extractUint8(data, startOffset);\\n        if (valType == Value.intTypeCode()) {\\n            uint256 intVal;\\n            (offset, intVal) = deserializeInt(data, offset);\\n            return (offset, Value.newInt(intVal));\\n        } else if (valType == Value.codePointTypeCode()) {\\n            return deserializeCodePoint(data, offset);\\n        } else if (valType == Value.bufferTypeCode()) {\\n            bytes32 hashVal;\\n            (offset, hashVal) = deserializeBytes32(data, offset);\\n            return (offset, Value.newBuffer(hashVal));\\n        } else if (valType == Value.tuplePreImageTypeCode()) {\\n            return deserializeHashPreImage(data, offset);\\n        } else if (valType >= Value.tupleTypeCode() && valType < Value.valueTypeCode()) {\\n            uint8 tupLength = uint8(valType - Value.tupleTypeCode());\\n            Value.Data[] memory tupleVal;\\n            (offset, tupleVal) = deserializeTuple(tupLength, data, offset);\\n            return (offset, Value.newTuple(tupleVal));\\n        }\\n        require(false, \\\"invalid typecode\\\");\\n    }\\n\\n    function extractUint8(bytes memory data, uint256 startOffset)\\n        private\\n        pure\\n        returns (\\n            uint256, // offset\\n            uint8 // val\\n        )\\n    {\\n        return (startOffset + 1, uint8(data[startOffset]));\\n    }\\n\\n    function extractBytes32(bytes memory data, uint256 startOffset)\\n        private\\n        pure\\n        returns (\\n            uint256, // offset\\n            bytes32 // val\\n        )\\n    {\\n        return (startOffset + 32, data.toBytes32(startOffset));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/arch/Value.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nlibrary Value {\\n    uint8 internal constant INT_TYPECODE = 0;\\n    uint8 internal constant CODE_POINT_TYPECODE = 1;\\n    uint8 internal constant HASH_PRE_IMAGE_TYPECODE = 2;\\n    uint8 internal constant TUPLE_TYPECODE = 3;\\n    uint8 internal constant BUFFER_TYPECODE = TUPLE_TYPECODE + 9;\\n    // All values received from clients will have type codes less than the VALUE_TYPE_COUNT\\n    uint8 internal constant VALUE_TYPE_COUNT = TUPLE_TYPECODE + 10;\\n\\n    // The following types do not show up in the marshalled format and is\\n    // only used for internal tracking purposes\\n    uint8 internal constant HASH_ONLY = 100;\\n\\n    struct CodePoint {\\n        uint8 opcode;\\n        bytes32 nextCodePoint;\\n        Data[] immediate;\\n    }\\n\\n    struct Data {\\n        uint256 intVal;\\n        CodePoint cpVal;\\n        Data[] tupleVal;\\n        bytes32 bufferHash;\\n        uint8 typeCode;\\n        uint256 size;\\n    }\\n\\n    function tupleTypeCode() internal pure returns (uint8) {\\n        return TUPLE_TYPECODE;\\n    }\\n\\n    function tuplePreImageTypeCode() internal pure returns (uint8) {\\n        return HASH_PRE_IMAGE_TYPECODE;\\n    }\\n\\n    function intTypeCode() internal pure returns (uint8) {\\n        return INT_TYPECODE;\\n    }\\n\\n    function bufferTypeCode() internal pure returns (uint8) {\\n        return BUFFER_TYPECODE;\\n    }\\n\\n    function codePointTypeCode() internal pure returns (uint8) {\\n        return CODE_POINT_TYPECODE;\\n    }\\n\\n    function valueTypeCode() internal pure returns (uint8) {\\n        return VALUE_TYPE_COUNT;\\n    }\\n\\n    function hashOnlyTypeCode() internal pure returns (uint8) {\\n        return HASH_ONLY;\\n    }\\n\\n    function isValidTupleSize(uint256 size) internal pure returns (bool) {\\n        return size <= 8;\\n    }\\n\\n    function typeCodeVal(Data memory val) internal pure returns (Data memory) {\\n        if (val.typeCode == 2) {\\n            // Map HashPreImage to Tuple\\n            return newInt(TUPLE_TYPECODE);\\n        }\\n        return newInt(val.typeCode);\\n    }\\n\\n    function valLength(Data memory val) internal pure returns (uint8) {\\n        if (val.typeCode == TUPLE_TYPECODE) {\\n            return uint8(val.tupleVal.length);\\n        } else {\\n            return 1;\\n        }\\n    }\\n\\n    function isInt(Data memory val) internal pure returns (bool) {\\n        return val.typeCode == INT_TYPECODE;\\n    }\\n\\n    function isInt64(Data memory val) internal pure returns (bool) {\\n        return val.typeCode == INT_TYPECODE && val.intVal < (1 << 64);\\n    }\\n\\n    function isCodePoint(Data memory val) internal pure returns (bool) {\\n        return val.typeCode == CODE_POINT_TYPECODE;\\n    }\\n\\n    function isTuple(Data memory val) internal pure returns (bool) {\\n        return val.typeCode == TUPLE_TYPECODE;\\n    }\\n\\n    function isBuffer(Data memory val) internal pure returns (bool) {\\n        return val.typeCode == BUFFER_TYPECODE;\\n    }\\n\\n    function newEmptyTuple() internal pure returns (Data memory) {\\n        return newTuple(new Data[](0));\\n    }\\n\\n    function newBoolean(bool val) internal pure returns (Data memory) {\\n        if (val) {\\n            return newInt(1);\\n        } else {\\n            return newInt(0);\\n        }\\n    }\\n\\n    function newInt(uint256 _val) internal pure returns (Data memory) {\\n        return\\n            Data(_val, CodePoint(0, 0, new Data[](0)), new Data[](0), 0, INT_TYPECODE, uint256(1));\\n    }\\n\\n    function newHashedValue(bytes32 valueHash, uint256 valueSize)\\n        internal\\n        pure\\n        returns (Data memory)\\n    {\\n        return\\n            Data(\\n                uint256(valueHash),\\n                CodePoint(0, 0, new Data[](0)),\\n                new Data[](0),\\n                0,\\n                HASH_ONLY,\\n                valueSize\\n            );\\n    }\\n\\n    function newTuple(Data[] memory _val) internal pure returns (Data memory) {\\n        require(isValidTupleSize(_val.length), \\\"Tuple must have valid size\\\");\\n        uint256 size = 1;\\n\\n        for (uint256 i = 0; i < _val.length; i++) {\\n            size += _val[i].size;\\n        }\\n\\n        return Data(0, CodePoint(0, 0, new Data[](0)), _val, 0, TUPLE_TYPECODE, size);\\n    }\\n\\n    function newTuplePreImage(bytes32 preImageHash, uint256 size)\\n        internal\\n        pure\\n        returns (Data memory)\\n    {\\n        return\\n            Data(\\n                uint256(preImageHash),\\n                CodePoint(0, 0, new Data[](0)),\\n                new Data[](0),\\n                0,\\n                HASH_PRE_IMAGE_TYPECODE,\\n                size\\n            );\\n    }\\n\\n    function newCodePoint(uint8 opCode, bytes32 nextHash) internal pure returns (Data memory) {\\n        return newCodePoint(CodePoint(opCode, nextHash, new Data[](0)));\\n    }\\n\\n    function newCodePoint(\\n        uint8 opCode,\\n        bytes32 nextHash,\\n        Data memory immediate\\n    ) internal pure returns (Data memory) {\\n        Data[] memory imm = new Data[](1);\\n        imm[0] = immediate;\\n        return newCodePoint(CodePoint(opCode, nextHash, imm));\\n    }\\n\\n    function newCodePoint(CodePoint memory _val) private pure returns (Data memory) {\\n        return Data(0, _val, new Data[](0), 0, CODE_POINT_TYPECODE, uint256(1));\\n    }\\n\\n    function newBuffer(bytes32 bufHash) internal pure returns (Data memory) {\\n        return\\n            Data(\\n                uint256(0),\\n                CodePoint(0, 0, new Data[](0)),\\n                new Data[](0),\\n                bufHash,\\n                BUFFER_TYPECODE,\\n                uint256(1)\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/Bridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./Inbox.sol\\\";\\nimport \\\"./Outbox.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport \\\"./interfaces/IBridge.sol\\\";\\n\\ncontract Bridge is OwnableUpgradeable, IBridge {\\n    using Address for address;\\n    struct InOutInfo {\\n        uint256 index;\\n        bool allowed;\\n    }\\n\\n    mapping(address => InOutInfo) private allowedInboxesMap;\\n    mapping(address => InOutInfo) private allowedOutboxesMap;\\n\\n    address[] public allowedInboxList;\\n    address[] public allowedOutboxList;\\n\\n    address public override activeOutbox;\\n    bytes32[] public override inboxAccs;\\n\\n    function initialize() external initializer {\\n        __Ownable_init();\\n    }\\n\\n    function allowedInboxes(address inbox) external view override returns (bool) {\\n        return allowedInboxesMap[inbox].allowed;\\n    }\\n\\n    function allowedOutboxes(address outbox) external view override returns (bool) {\\n        return allowedOutboxesMap[outbox].allowed;\\n    }\\n\\n    function deliverMessageToInbox(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable override returns (uint256) {\\n        require(allowedInboxesMap[msg.sender].allowed, \\\"NOT_FROM_INBOX\\\");\\n        uint256 count = inboxAccs.length;\\n        bytes32 messageHash =\\n            Messages.messageHash(\\n                kind,\\n                sender,\\n                block.number,\\n                block.timestamp, // solhint-disable-line not-rely-on-time\\n                count,\\n                tx.gasprice,\\n                messageDataHash\\n            );\\n        bytes32 prevAcc = 0;\\n        if (count > 0) {\\n            prevAcc = inboxAccs[count - 1];\\n        }\\n        inboxAccs.push(Messages.addMessageToInbox(prevAcc, messageHash));\\n        emit MessageDelivered(count, prevAcc, msg.sender, kind, sender, messageDataHash);\\n        return count;\\n    }\\n\\n    function executeCall(\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external override returns (bool success, bytes memory returnData) {\\n        require(allowedOutboxesMap[msg.sender].allowed, \\\"NOT_FROM_OUTBOX\\\");\\n        if (data.length > 0) require(destAddr.isContract(), \\\"NO_CODE_AT_DEST\\\");\\n        address currentOutbox = activeOutbox;\\n        activeOutbox = msg.sender;\\n        (success, returnData) = destAddr.call{ value: amount }(data);\\n        activeOutbox = currentOutbox;\\n    }\\n\\n    function setInbox(address inbox, bool enabled) external override onlyOwner {\\n        InOutInfo storage info = allowedInboxesMap[inbox];\\n        bool alreadyEnabled = info.allowed;\\n        if ((alreadyEnabled && enabled) || (!alreadyEnabled && !enabled)) {\\n            return;\\n        }\\n        if (enabled) {\\n            allowedInboxesMap[inbox] = InOutInfo(allowedInboxList.length, true);\\n            allowedInboxList.push(inbox);\\n        } else {\\n            allowedInboxList[info.index] = allowedInboxList[allowedInboxList.length - 1];\\n            allowedInboxesMap[allowedInboxList[info.index]].index = info.index;\\n            allowedInboxList.pop();\\n            delete allowedInboxesMap[inbox];\\n        }\\n    }\\n\\n    function setOutbox(address outbox, bool enabled) external override onlyOwner {\\n        InOutInfo storage info = allowedOutboxesMap[outbox];\\n        bool alreadyEnabled = info.allowed;\\n        if ((alreadyEnabled && enabled) || (!alreadyEnabled && !enabled)) {\\n            return;\\n        }\\n        if (enabled) {\\n            allowedOutboxesMap[outbox] = InOutInfo(allowedOutboxList.length, true);\\n            allowedOutboxList.push(outbox);\\n        } else {\\n            allowedOutboxList[info.index] = allowedOutboxList[allowedOutboxList.length - 1];\\n            allowedOutboxesMap[allowedOutboxList[info.index]].index = info.index;\\n            allowedOutboxList.pop();\\n            delete allowedOutboxesMap[outbox];\\n        }\\n    }\\n\\n    function messageCount() external view override returns (uint256) {\\n        return inboxAccs.length;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/Inbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./interfaces/IInbox.sol\\\";\\nimport \\\"./interfaces/IBridge.sol\\\";\\n\\nimport \\\"./Messages.sol\\\";\\nimport \\\"../libraries/Cloneable.sol\\\";\\nimport \\\"../libraries/Whitelist.sol\\\";\\n\\ncontract Inbox is IInbox, WhitelistConsumer, Cloneable {\\n    uint8 internal constant ETH_TRANSFER = 0;\\n    uint8 internal constant L2_MSG = 3;\\n    uint8 internal constant L1MessageType_L2FundedByL1 = 7;\\n    uint8 internal constant L1MessageType_submitRetryableTx = 9;\\n\\n    uint8 internal constant L2MessageType_unsignedEOATx = 0;\\n    uint8 internal constant L2MessageType_unsignedContractTx = 1;\\n\\n    IBridge public override bridge;\\n\\n    function initialize(IBridge _bridge, address _whitelist) external {\\n        require(address(bridge) == address(0), \\\"ALREADY_INIT\\\");\\n        bridge = _bridge;\\n        WhitelistConsumer.whitelist = _whitelist;\\n    }\\n\\n    /**\\n     * @notice Send a generic L2 message to the chain\\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\\n     * @param messageData Data of the message being sent\\n     */\\n    function sendL2MessageFromOrigin(bytes calldata messageData)\\n        external\\n        onlyWhitelisted\\n        returns (uint256)\\n    {\\n        // solhint-disable-next-line avoid-tx-origin\\n        require(msg.sender == tx.origin, \\\"origin only\\\");\\n        uint256 msgNum = deliverToBridge(L2_MSG, msg.sender, keccak256(messageData));\\n        emit InboxMessageDeliveredFromOrigin(msgNum);\\n        return msgNum;\\n    }\\n\\n    /**\\n     * @notice Send a generic L2 message to the chain\\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\\n     * @param messageData Data of the message being sent\\n     */\\n    function sendL2Message(bytes calldata messageData)\\n        external\\n        override\\n        onlyWhitelisted\\n        returns (uint256)\\n    {\\n        uint256 msgNum = deliverToBridge(L2_MSG, msg.sender, keccak256(messageData));\\n        emit InboxMessageDelivered(msgNum, messageData);\\n        return msgNum;\\n    }\\n\\n    function sendL1FundedUnsignedTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        uint256 nonce,\\n        address destAddr,\\n        bytes calldata data\\n    ) external payable virtual override onlyWhitelisted returns (uint256) {\\n        return\\n            _deliverMessage(\\n                L1MessageType_L2FundedByL1,\\n                msg.sender,\\n                abi.encodePacked(\\n                    L2MessageType_unsignedEOATx,\\n                    maxGas,\\n                    gasPriceBid,\\n                    nonce,\\n                    uint256(uint160(bytes20(destAddr))),\\n                    msg.value,\\n                    data\\n                )\\n            );\\n    }\\n\\n    function sendL1FundedContractTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        address destAddr,\\n        bytes calldata data\\n    ) external payable virtual override onlyWhitelisted returns (uint256) {\\n        return\\n            _deliverMessage(\\n                L1MessageType_L2FundedByL1,\\n                msg.sender,\\n                abi.encodePacked(\\n                    L2MessageType_unsignedContractTx,\\n                    maxGas,\\n                    gasPriceBid,\\n                    uint256(uint160(bytes20(destAddr))),\\n                    msg.value,\\n                    data\\n                )\\n            );\\n    }\\n\\n    function sendUnsignedTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        uint256 nonce,\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external virtual override onlyWhitelisted returns (uint256) {\\n        return\\n            _deliverMessage(\\n                L2_MSG,\\n                msg.sender,\\n                abi.encodePacked(\\n                    L2MessageType_unsignedEOATx,\\n                    maxGas,\\n                    gasPriceBid,\\n                    nonce,\\n                    uint256(uint160(bytes20(destAddr))),\\n                    amount,\\n                    data\\n                )\\n            );\\n    }\\n\\n    function sendContractTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external virtual override onlyWhitelisted returns (uint256) {\\n        return\\n            _deliverMessage(\\n                L2_MSG,\\n                msg.sender,\\n                abi.encodePacked(\\n                    L2MessageType_unsignedContractTx,\\n                    maxGas,\\n                    gasPriceBid,\\n                    uint256(uint160(bytes20(destAddr))),\\n                    amount,\\n                    data\\n                )\\n            );\\n    }\\n\\n    function depositEth(uint256 maxSubmissionCost)\\n        external\\n        payable\\n        virtual\\n        override\\n        onlyWhitelisted\\n        returns (uint256)\\n    {\\n        return\\n            this.createRetryableTicket{ value: msg.value }(\\n                msg.sender,\\n                0,\\n                maxSubmissionCost,\\n                msg.sender,\\n                msg.sender,\\n                0,\\n                0,\\n                \\\"\\\"\\n            );\\n    }\\n\\n    /**\\n    @notice Put an message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\\n    * @dev all msg.value will deposited to callValueRefundAddress on L2\\n    * @param destAddr destination L2 contract address\\n    * @param l2CallValue call value for retryable L2 message \\n    * @param  maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\\n    * @param excessFeeRefundAddress maxgas x gasprice - execution cost gets credited here on L2 balance\\n    * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\\n    * @param maxGas Max gas deducted from user's L2 balance to cover L2 execution\\n    * @param gasPriceBid price bid for L2 execution\\n    * @param data ABI encoded data of L2 message \\n    * @return unique id for retryable transaction (keccak256(requestID, uint(0) )\\n     */\\n    function createRetryableTicket(\\n        address destAddr,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        bytes calldata data\\n    ) external payable virtual override onlyWhitelisted returns (uint256) {\\n        return\\n            _deliverMessage(\\n                L1MessageType_submitRetryableTx,\\n                msg.sender,\\n                abi.encodePacked(\\n                    uint256(uint160(bytes20(destAddr))),\\n                    l2CallValue,\\n                    msg.value,\\n                    maxSubmissionCost,\\n                    uint256(uint160(bytes20(excessFeeRefundAddress))),\\n                    uint256(uint160(bytes20(callValueRefundAddress))),\\n                    maxGas,\\n                    gasPriceBid,\\n                    data.length,\\n                    data\\n                )\\n            );\\n    }\\n\\n    function _deliverMessage(\\n        uint8 _kind,\\n        address _sender,\\n        bytes memory _messageData\\n    ) internal returns (uint256) {\\n        uint256 msgNum = deliverToBridge(_kind, _sender, keccak256(_messageData));\\n        emit InboxMessageDelivered(msgNum, _messageData);\\n        return msgNum;\\n    }\\n\\n    function deliverToBridge(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) internal returns (uint256) {\\n        return bridge.deliverMessageToInbox{ value: msg.value }(kind, sender, messageDataHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/Messages.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nlibrary Messages {\\n    function messageHash(\\n        uint8 kind,\\n        address sender,\\n        uint256 blockNumber,\\n        uint256 timestamp,\\n        uint256 inboxSeqNum,\\n        uint256 gasPriceL1,\\n        bytes32 messageDataHash\\n    ) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    kind,\\n                    sender,\\n                    blockNumber,\\n                    timestamp,\\n                    inboxSeqNum,\\n                    gasPriceL1,\\n                    messageDataHash\\n                )\\n            );\\n    }\\n\\n    function addMessageToInbox(bytes32 inbox, bytes32 message) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(inbox, message));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/Outbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./OutboxEntry.sol\\\";\\n\\nimport \\\"./interfaces/IOutbox.sol\\\";\\nimport \\\"./interfaces/IBridge.sol\\\";\\n\\nimport \\\"./Messages.sol\\\";\\nimport \\\"../libraries/MerkleLib.sol\\\";\\nimport \\\"../libraries/BytesLib.sol\\\";\\nimport \\\"../libraries/Cloneable.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/proxy/BeaconProxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/UpgradeableBeacon.sol\\\";\\n\\ncontract Outbox is IOutbox, Cloneable {\\n    using BytesLib for bytes;\\n\\n    bytes1 internal constant MSG_ROOT = 0;\\n\\n    uint8 internal constant SendType_sendTxToL1 = 3;\\n\\n    address public rollup;\\n    IBridge public bridge;\\n\\n    UpgradeableBeacon public beacon;\\n    OutboxEntry[] public outboxes;\\n\\n    // Note, these variables are set and then wiped during a single transaction.\\n    // Therefore their values don't need to be maintained, and their slots will\\n    // be empty outside of transactions\\n    address internal _sender;\\n    uint128 internal _l2Block;\\n    uint128 internal _l1Block;\\n    uint128 internal _timestamp;\\n\\n    function initialize(address _rollup, IBridge _bridge) external {\\n        require(rollup == address(0), \\\"ALREADY_INIT\\\");\\n        rollup = _rollup;\\n        bridge = _bridge;\\n\\n        address outboxEntryTemplate = address(new OutboxEntry());\\n        beacon = new UpgradeableBeacon(outboxEntryTemplate);\\n        beacon.transferOwnership(_rollup);\\n    }\\n\\n    /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\\n    /// When the return value is zero, that means this is a system message\\n    function l2ToL1Sender() external view override returns (address) {\\n        return _sender;\\n    }\\n\\n    function l2ToL1Block() external view override returns (uint256) {\\n        return uint256(_l2Block);\\n    }\\n\\n    function l2ToL1EthBlock() external view override returns (uint256) {\\n        return uint256(_l1Block);\\n    }\\n\\n    function l2ToL1Timestamp() external view override returns (uint256) {\\n        return uint256(_timestamp);\\n    }\\n\\n    function processOutgoingMessages(bytes calldata sendsData, uint256[] calldata sendLengths)\\n        external\\n        override\\n    {\\n        require(msg.sender == rollup, \\\"ONLY_ROLLUP\\\");\\n        // If we've reached here, we've already confirmed that sum(sendLengths) == sendsData.length\\n        uint256 messageCount = sendLengths.length;\\n        uint256 offset = 0;\\n        for (uint256 i = 0; i < messageCount; i++) {\\n            handleOutgoingMessage(bytes(sendsData[offset:offset + sendLengths[i]]));\\n            offset += sendLengths[i];\\n        }\\n    }\\n\\n    function handleOutgoingMessage(bytes memory data) private {\\n        // Otherwise we have an unsupported message type and we skip the message\\n        if (data[0] == MSG_ROOT) {\\n            require(data.length == 97, \\\"BAD_LENGTH\\\");\\n            uint256 batchNum = data.toUint(1);\\n            uint256 numInBatch = data.toUint(33);\\n            bytes32 outputRoot = data.toBytes32(65);\\n\\n            address clone = address(new BeaconProxy(address(beacon), \\\"\\\"));\\n            OutboxEntry(clone).initialize(outputRoot, numInBatch);\\n            uint256 outboxIndex = outboxes.length;\\n            outboxes.push(OutboxEntry(clone));\\n            emit OutboxEntryCreated(batchNum, outboxIndex, outputRoot, numInBatch);\\n        }\\n    }\\n\\n    /**\\n     * @notice Executes a messages in an Outbox entry. Reverts if dispute period hasn't expired and\\n     * @param outboxIndex Index of OutboxEntry in outboxes array\\n     * @param proof Merkle proof of message inclusion in outbox entry\\n     * @param index Index of message in outbox entry\\n     * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\\n     * @param destAddr destination address for L1 contract call\\n     * @param l2Block l2 block number at which sendTxToL1 call was made\\n     * @param l1Block l1 block number at which sendTxToL1 call was made\\n     * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\\n     * @param amount value in L1 message in wei\\n     * @param calldataForL1 abi-encoded L1 message data\\n     */\\n    function executeTransaction(\\n        uint256 outboxIndex,\\n        bytes32[] calldata proof,\\n        uint256 index,\\n        address l2Sender,\\n        address destAddr,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 amount,\\n        bytes calldata calldataForL1\\n    ) external virtual {\\n        bytes32 userTx =\\n            calculateItemHash(\\n                l2Sender,\\n                destAddr,\\n                l2Block,\\n                l1Block,\\n                l2Timestamp,\\n                amount,\\n                calldataForL1\\n            );\\n\\n        spendOutput(outboxIndex, proof, index, userTx);\\n        emit OutBoxTransactionExecuted(destAddr, l2Sender, outboxIndex, index);\\n\\n        address currentSender = _sender;\\n        uint128 currentL2Block = _l2Block;\\n        uint128 currentL1Block = _l1Block;\\n        uint128 currentTimestamp = _timestamp;\\n\\n        _sender = l2Sender;\\n        _l2Block = uint128(l2Block);\\n        _l1Block = uint128(l1Block);\\n        _timestamp = uint128(l2Timestamp);\\n\\n        executeBridgeCall(destAddr, amount, calldataForL1);\\n\\n        _sender = currentSender;\\n        _l2Block = currentL2Block;\\n        _l1Block = currentL1Block;\\n        _timestamp = currentTimestamp;\\n    }\\n\\n    function spendOutput(\\n        uint256 outboxIndex,\\n        bytes32[] memory proof,\\n        uint256 path,\\n        bytes32 item\\n    ) internal {\\n        require(proof.length <= 256, \\\"PROOF_TOO_LONG\\\");\\n        require(path < 2**proof.length, \\\"PATH_NOT_MINIMAL\\\");\\n\\n        // Hash the leaf an extra time to prove it's a leaf\\n        bytes32 calcRoot = calculateMerkleRoot(proof, path, item);\\n        OutboxEntry outbox = outboxes[outboxIndex];\\n        require(address(outbox) != address(0), \\\"NO_OUTBOX\\\");\\n\\n        // With a minimal path, the pair of path and proof length should always identify\\n        // a unique leaf. The path itself is not enough since the path length to different\\n        // leaves could potentially be different\\n        bytes32 uniqueKey = keccak256(abi.encodePacked(path, proof.length));\\n        uint256 numRemaining = outbox.spendOutput(calcRoot, uniqueKey);\\n\\n        if (numRemaining == 0) {\\n            outbox.destroy();\\n            outboxes[outboxIndex] = OutboxEntry(address(0));\\n        }\\n    }\\n\\n    function executeBridgeCall(\\n        address destAddr,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal {\\n        (bool success, bytes memory returndata) = bridge.executeCall(destAddr, amount, data);\\n        if (!success) {\\n            if (returndata.length > 0) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(\\\"BRIDGE_CALL_FAILED\\\");\\n            }\\n        }\\n    }\\n\\n    function calculateItemHash(\\n        address l2Sender,\\n        address destAddr,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 amount,\\n        bytes calldata calldataForL1\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    SendType_sendTxToL1,\\n                    uint256(uint160(bytes20(l2Sender))),\\n                    uint256(uint160(bytes20(destAddr))),\\n                    l2Block,\\n                    l1Block,\\n                    l2Timestamp,\\n                    amount,\\n                    calldataForL1\\n                )\\n            );\\n    }\\n\\n    function calculateMerkleRoot(\\n        bytes32[] memory proof,\\n        uint256 path,\\n        bytes32 item\\n    ) public pure returns (bytes32) {\\n        return MerkleLib.calculateRoot(proof, path, keccak256(abi.encodePacked(item)));\\n    }\\n\\n    function outboxesLength() public view returns (uint256) {\\n        return outboxes.length;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/OutboxEntry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../libraries/Cloneable.sol\\\";\\n\\ncontract OutboxEntry is Cloneable {\\n    address outbox;\\n    bytes32 public root;\\n    uint256 public numRemaining;\\n    mapping(bytes32 => bool) public spentOutput;\\n\\n    function initialize(bytes32 _root, uint256 _numInBatch) external {\\n        require(outbox == address(0), \\\"ALREADY_INIT\\\");\\n        require(root == 0, \\\"ALREADY_INIT\\\");\\n        require(_root != 0, \\\"BAD_ROOT\\\");\\n        outbox = msg.sender;\\n        root = _root;\\n        numRemaining = _numInBatch;\\n    }\\n\\n    function spendOutput(bytes32 _root, bytes32 _id) external returns (uint256) {\\n        require(msg.sender == outbox, \\\"NOT_FROM_OUTBOX\\\");\\n        require(!spentOutput[_id], \\\"ALREADY_SPENT\\\");\\n        require(_root == root, \\\"BAD_ROOT\\\");\\n\\n        spentOutput[_id] = true;\\n        numRemaining--;\\n\\n        return numRemaining;\\n    }\\n\\n    function destroy() external {\\n        require(msg.sender == outbox, \\\"NOT_FROM_OUTBOX\\\");\\n        safeSelfDestruct(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/SequencerInbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./interfaces/ISequencerInbox.sol\\\";\\nimport \\\"./interfaces/IBridge.sol\\\";\\nimport \\\"../arch/Marshaling.sol\\\";\\nimport \\\"../libraries/Cloneable.sol\\\";\\nimport \\\"../rollup/Rollup.sol\\\";\\n\\nimport \\\"./Messages.sol\\\";\\n\\ncontract SequencerInbox is ISequencerInbox, Cloneable {\\n    uint8 internal constant L2_MSG = 3;\\n    uint8 internal constant END_OF_BLOCK = 6;\\n\\n    bytes32[] public override inboxAccs;\\n    uint256 public override messageCount;\\n\\n    uint256 totalDelayedMessagesRead;\\n\\n    IBridge public delayedInbox;\\n    address public sequencer;\\n    address public rollup;\\n\\n    function initialize(\\n        IBridge _delayedInbox,\\n        address _sequencer,\\n        address _rollup\\n    ) external {\\n        require(address(delayedInbox) == address(0), \\\"ALREADY_INIT\\\");\\n        delayedInbox = _delayedInbox;\\n        sequencer = _sequencer;\\n        rollup = _rollup;\\n    }\\n\\n    function setSequencer(address newSequencer) external override {\\n        require(msg.sender == rollup, \\\"ONLY_ROLLUP\\\");\\n        sequencer = newSequencer;\\n        emit SequencerAddressUpdated(newSequencer);\\n    }\\n\\n    function maxDelayBlocks() public view override returns (uint256) {\\n        return RollupBase(rollup).sequencerInboxMaxDelayBlocks();\\n    }\\n\\n    function maxDelaySeconds() public view override returns (uint256) {\\n        return RollupBase(rollup).sequencerInboxMaxDelaySeconds();\\n    }\\n\\n    function getLastDelayedAcc() internal view returns (bytes32) {\\n        bytes32 acc = 0;\\n        if (totalDelayedMessagesRead > 0) {\\n            acc = delayedInbox.inboxAccs(totalDelayedMessagesRead - 1);\\n        }\\n        return acc;\\n    }\\n\\n    function forceInclusion(\\n        uint256 _totalDelayedMessagesRead,\\n        uint8 kind,\\n        uint256[2] calldata l1BlockAndTimestamp,\\n        uint256 inboxSeqNum,\\n        uint256 gasPriceL1,\\n        address sender,\\n        bytes32 messageDataHash,\\n        bytes32 delayedAcc\\n    ) external {\\n        require(_totalDelayedMessagesRead > totalDelayedMessagesRead, \\\"DELAYED_BACKWARDS\\\");\\n        {\\n            bytes32 messageHash =\\n                Messages.messageHash(\\n                    kind,\\n                    sender,\\n                    l1BlockAndTimestamp[0],\\n                    l1BlockAndTimestamp[1],\\n                    inboxSeqNum,\\n                    gasPriceL1,\\n                    messageDataHash\\n                );\\n            require(l1BlockAndTimestamp[0] + maxDelayBlocks() < block.number, \\\"MAX_DELAY_BLOCKS\\\");\\n            require(l1BlockAndTimestamp[1] + maxDelaySeconds() < block.timestamp, \\\"MAX_DELAY_TIME\\\");\\n\\n            bytes32 prevDelayedAcc = 0;\\n            if (_totalDelayedMessagesRead > 1) {\\n                prevDelayedAcc = delayedInbox.inboxAccs(_totalDelayedMessagesRead - 2);\\n            }\\n            require(\\n                delayedInbox.inboxAccs(_totalDelayedMessagesRead - 1) ==\\n                    Messages.addMessageToInbox(prevDelayedAcc, messageHash),\\n                \\\"DELAYED_ACCUMULATOR\\\"\\n            );\\n        }\\n\\n        uint256 startNum = messageCount;\\n        bytes32 beforeAcc = 0;\\n        if (inboxAccs.length > 0) {\\n            beforeAcc = inboxAccs[inboxAccs.length - 1];\\n        }\\n\\n        (bytes32 acc, uint256 count) =\\n            includeDelayedMessages(\\n                beforeAcc,\\n                startNum,\\n                _totalDelayedMessagesRead,\\n                block.number,\\n                block.timestamp,\\n                delayedAcc\\n            );\\n        inboxAccs.push(acc);\\n        messageCount = count;\\n        emit DelayedInboxForced(\\n            startNum,\\n            beforeAcc,\\n            count,\\n            _totalDelayedMessagesRead,\\n            [acc, delayedAcc],\\n            inboxAccs.length - 1\\n        );\\n    }\\n\\n    function addSequencerL2BatchFromOrigin(\\n        bytes calldata transactions,\\n        uint256[] calldata lengths,\\n        uint256[] calldata sectionsMetadata,\\n        bytes32 afterAcc\\n    ) external {\\n        // solhint-disable-next-line avoid-tx-origin\\n        require(msg.sender == tx.origin, \\\"origin only\\\");\\n        uint256 startNum = messageCount;\\n        bytes32 beforeAcc =\\n            addSequencerL2BatchImpl(transactions, lengths, sectionsMetadata, afterAcc);\\n        emit SequencerBatchDeliveredFromOrigin(\\n            startNum,\\n            beforeAcc,\\n            messageCount,\\n            afterAcc,\\n            inboxAccs.length - 1\\n        );\\n    }\\n\\n    function addSequencerL2Batch(\\n        bytes calldata transactions,\\n        uint256[] calldata lengths,\\n        uint256[] calldata sectionsMetadata,\\n        bytes32 afterAcc\\n    ) external {\\n        uint256 startNum = messageCount;\\n        bytes32 beforeAcc =\\n            addSequencerL2BatchImpl(transactions, lengths, sectionsMetadata, afterAcc);\\n        emit SequencerBatchDelivered(\\n            startNum,\\n            beforeAcc,\\n            messageCount,\\n            afterAcc,\\n            transactions,\\n            lengths,\\n            sectionsMetadata,\\n            inboxAccs.length - 1,\\n            msg.sender\\n        );\\n    }\\n\\n    function addSequencerL2BatchImpl(\\n        bytes memory transactions,\\n        uint256[] calldata lengths,\\n        uint256[] calldata sectionsMetadata,\\n        bytes32 afterAcc\\n    ) private returns (bytes32 beforeAcc) {\\n        require(msg.sender == sequencer, \\\"ONLY_SEQUENCER\\\");\\n\\n        if (inboxAccs.length > 0) {\\n            beforeAcc = inboxAccs[inboxAccs.length - 1];\\n        }\\n\\n        uint256 runningCount = messageCount;\\n        bytes32 runningAcc = beforeAcc;\\n        uint256 processedItems = 0;\\n        uint256 dataOffset;\\n        assembly {\\n            dataOffset := add(transactions, 32)\\n        }\\n        for (uint256 i = 0; i + 5 <= sectionsMetadata.length; i += 5) {\\n            // Each metadata section consists of:\\n            // [numItems, l1BlockNumber, l1Timestamp, newTotalDelayedMessagesRead, newDelayedAcc]\\n            {\\n                uint256 l1BlockNumber = sectionsMetadata[i + 1];\\n                require(l1BlockNumber + maxDelayBlocks() >= block.number, \\\"BLOCK_TOO_OLD\\\");\\n                require(l1BlockNumber <= block.number, \\\"BLOCK_TOO_NEW\\\");\\n            }\\n            {\\n                uint256 l1Timestamp = sectionsMetadata[i + 2];\\n                require(l1Timestamp + maxDelaySeconds() >= block.timestamp, \\\"TIME_TOO_OLD\\\");\\n                require(l1Timestamp <= block.timestamp, \\\"TIME_TOO_NEW\\\");\\n            }\\n\\n            {\\n                bytes32 prefixHash =\\n                    keccak256(\\n                        abi.encodePacked(\\n                            msg.sender,\\n                            sectionsMetadata[i + 1],\\n                            sectionsMetadata[i + 2]\\n                        )\\n                    );\\n                uint256 numItems = sectionsMetadata[i];\\n                (runningAcc, runningCount, dataOffset) = calcL2Batch(\\n                    dataOffset,\\n                    lengths,\\n                    processedItems,\\n                    numItems, // num items\\n                    prefixHash,\\n                    runningCount,\\n                    runningAcc\\n                );\\n                processedItems += numItems; // num items\\n            }\\n\\n            uint256 newTotalDelayedMessagesRead = sectionsMetadata[i + 3];\\n            require(newTotalDelayedMessagesRead >= totalDelayedMessagesRead, \\\"DELAYED_BACKWARDS\\\");\\n            require(newTotalDelayedMessagesRead >= 1, \\\"MUST_DELAYED_INIT\\\");\\n            require(\\n                totalDelayedMessagesRead >= 1 || sectionsMetadata[i] == 0,\\n                \\\"MUST_DELAYED_INIT_START\\\"\\n            );\\n            if (newTotalDelayedMessagesRead > totalDelayedMessagesRead) {\\n                (runningAcc, runningCount) = includeDelayedMessages(\\n                    runningAcc,\\n                    runningCount,\\n                    newTotalDelayedMessagesRead,\\n                    sectionsMetadata[i + 1], // block number\\n                    sectionsMetadata[i + 2], // timestamp\\n                    bytes32(sectionsMetadata[i + 4]) // delayed accumulator\\n                );\\n            }\\n        }\\n\\n        uint256 startOffset;\\n        assembly {\\n            startOffset := add(transactions, 32)\\n        }\\n        require(dataOffset >= startOffset, \\\"OFFSET_OVERFLOW\\\");\\n        require(dataOffset <= startOffset + transactions.length, \\\"TRANSACTIONS_OVERRUN\\\");\\n\\n        require(runningCount > messageCount, \\\"EMPTY_BATCH\\\");\\n        inboxAccs.push(runningAcc);\\n        messageCount = runningCount;\\n\\n        require(runningAcc == afterAcc, \\\"AFTER_ACC\\\");\\n    }\\n\\n    function calcL2Batch(\\n        uint256 beforeOffset,\\n        uint256[] calldata lengths,\\n        uint256 lengthsOffset,\\n        uint256 itemCount,\\n        bytes32 prefixHash,\\n        uint256 beforeCount,\\n        bytes32 beforeAcc\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes32 acc,\\n            uint256 count,\\n            uint256 offset\\n        )\\n    {\\n        offset = beforeOffset;\\n        count = beforeCount;\\n        acc = beforeAcc;\\n        itemCount += lengthsOffset;\\n        for (uint256 i = lengthsOffset; i < itemCount; i++) {\\n            uint256 length = lengths[i];\\n            bytes32 messageDataHash;\\n            assembly {\\n                messageDataHash := keccak256(offset, length)\\n            }\\n            acc = keccak256(abi.encodePacked(acc, count, prefixHash, messageDataHash));\\n            offset += length;\\n            count++;\\n        }\\n        return (acc, count, offset);\\n    }\\n\\n    // Precondition: _totalDelayedMessagesRead > totalDelayedMessagesRead\\n    function includeDelayedMessages(\\n        bytes32 acc,\\n        uint256 count,\\n        uint256 _totalDelayedMessagesRead,\\n        uint256 l1BlockNumber,\\n        uint256 timestamp,\\n        bytes32 delayedAcc\\n    ) private returns (bytes32, uint256) {\\n        require(_totalDelayedMessagesRead <= delayedInbox.messageCount(), \\\"DELAYED_TOO_FAR\\\");\\n        require(delayedAcc == delayedInbox.inboxAccs(_totalDelayedMessagesRead - 1), \\\"DELAYED_ACC\\\");\\n        acc = keccak256(\\n            abi.encodePacked(\\n                \\\"Delayed messages:\\\",\\n                acc,\\n                count,\\n                totalDelayedMessagesRead,\\n                _totalDelayedMessagesRead,\\n                delayedAcc\\n            )\\n        );\\n        count += _totalDelayedMessagesRead - totalDelayedMessagesRead;\\n        bytes memory emptyBytes;\\n        acc = keccak256(\\n            abi.encodePacked(\\n                acc,\\n                count,\\n                keccak256(abi.encodePacked(address(0), l1BlockNumber, timestamp)),\\n                keccak256(emptyBytes)\\n            )\\n        );\\n        count++;\\n        totalDelayedMessagesRead = _totalDelayedMessagesRead;\\n        return (acc, count);\\n    }\\n\\n    function proveSeqBatchMsgCount(\\n        bytes calldata proof,\\n        uint256 offset,\\n        bytes32 acc\\n    ) internal pure returns (uint256, uint256) {\\n        uint256 endCount;\\n\\n        bytes32 buildingAcc;\\n        uint256 seqNum;\\n        bytes32 messageHeaderHash;\\n        bytes32 messageDataHash;\\n        (offset, buildingAcc) = Marshaling.deserializeBytes32(proof, offset);\\n        (offset, seqNum) = Marshaling.deserializeInt(proof, offset);\\n        (offset, messageHeaderHash) = Marshaling.deserializeBytes32(proof, offset);\\n        (offset, messageDataHash) = Marshaling.deserializeBytes32(proof, offset);\\n        buildingAcc = keccak256(\\n            abi.encodePacked(buildingAcc, seqNum, messageHeaderHash, messageDataHash)\\n        );\\n        endCount = seqNum + 1;\\n        require(buildingAcc == acc, \\\"BATCH_ACC\\\");\\n\\n        return (offset, endCount);\\n    }\\n\\n    function proveBatchContainsSequenceNumber(bytes calldata proof, uint256 inboxCount)\\n        external\\n        view\\n        override\\n        returns (uint256, bytes32)\\n    {\\n        if (inboxCount == 0) {\\n            return (0, 0);\\n        }\\n\\n        (uint256 offset, uint256 seqBatchNum) = Marshaling.deserializeInt(proof, 0);\\n        uint256 lastBatchCount = 0;\\n        if (seqBatchNum > 0) {\\n            (offset, lastBatchCount) = proveSeqBatchMsgCount(\\n                proof,\\n                offset,\\n                inboxAccs[seqBatchNum - 1]\\n            );\\n            lastBatchCount++;\\n        }\\n\\n        bytes32 seqBatchAcc = inboxAccs[seqBatchNum];\\n        uint256 thisBatchCount;\\n        (offset, thisBatchCount) = proveSeqBatchMsgCount(proof, offset, seqBatchAcc);\\n\\n        require(inboxCount > lastBatchCount, \\\"BATCH_START\\\");\\n        require(inboxCount <= thisBatchCount, \\\"BATCH_END\\\");\\n\\n        return (thisBatchCount, seqBatchAcc);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/interfaces/IBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface IBridge {\\n    event MessageDelivered(\\n        uint256 indexed messageIndex,\\n        bytes32 indexed beforeInboxAcc,\\n        address inbox,\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    );\\n\\n    function deliverMessageToInbox(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable returns (uint256);\\n\\n    function executeCall(\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    // These are only callable by the admin\\n    function setInbox(address inbox, bool enabled) external;\\n\\n    function setOutbox(address inbox, bool enabled) external;\\n\\n    // View functions\\n\\n    function activeOutbox() external view returns (address);\\n\\n    function allowedInboxes(address inbox) external view returns (bool);\\n\\n    function allowedOutboxes(address outbox) external view returns (bool);\\n\\n    function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function messageCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/interfaces/IInbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IMessageProvider.sol\\\";\\n\\ninterface IInbox is IMessageProvider {\\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\\n\\n    function sendUnsignedTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        uint256 nonce,\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function sendContractTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function sendL1FundedUnsignedTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        uint256 nonce,\\n        address destAddr,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function sendL1FundedContractTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        address destAddr,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function createRetryableTicket(\\n        address destAddr,\\n        uint256 arbTxCallValue,\\n        uint256 maxSubmissionCost,\\n        address submissionRefundAddress,\\n        address valueRefundAddress,\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\\n\\n    function bridge() external view returns (IBridge);\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/interfaces/IMessageProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface IMessageProvider {\\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\\n\\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/interfaces/IOutbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface IOutbox {\\n    event OutboxEntryCreated(\\n        uint256 indexed batchNum,\\n        uint256 outboxIndex,\\n        bytes32 outputRoot,\\n        uint256 numInBatch\\n    );\\n    event OutBoxTransactionExecuted(\\n        address indexed destAddr,\\n        address indexed l2Sender,\\n        uint256 indexed outboxIndex,\\n        uint256 transactionIndex\\n    );\\n\\n    function l2ToL1Sender() external view returns (address);\\n\\n    function l2ToL1Block() external view returns (uint256);\\n\\n    function l2ToL1EthBlock() external view returns (uint256);\\n\\n    function l2ToL1Timestamp() external view returns (uint256);\\n\\n    function processOutgoingMessages(bytes calldata sendsData, uint256[] calldata sendLengths)\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/interfaces/ISequencerInbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface ISequencerInbox {\\n    event SequencerBatchDelivered(\\n        uint256 indexed firstMessageNum,\\n        bytes32 indexed beforeAcc,\\n        uint256 newMessageCount,\\n        bytes32 afterAcc,\\n        bytes transactions,\\n        uint256[] lengths,\\n        uint256[] sectionsMetadata,\\n        uint256 seqBatchIndex,\\n        address sequencer\\n    );\\n\\n    event SequencerBatchDeliveredFromOrigin(\\n        uint256 indexed firstMessageNum,\\n        bytes32 indexed beforeAcc,\\n        uint256 newMessageCount,\\n        bytes32 afterAcc,\\n        uint256 seqBatchIndex\\n    );\\n\\n    event DelayedInboxForced(\\n        uint256 indexed firstMessageNum,\\n        bytes32 indexed beforeAcc,\\n        uint256 newMessageCount,\\n        uint256 totalDelayedMessagesRead,\\n        bytes32[2] afterAccAndDelayed,\\n        uint256 seqBatchIndex\\n    );\\n\\n    event SequencerAddressUpdated(address newAddress);\\n\\n    function setSequencer(address newSequencer) external;\\n\\n    function messageCount() external view returns (uint256);\\n\\n    function maxDelayBlocks() external view returns (uint256);\\n\\n    function maxDelaySeconds() external view returns (uint256);\\n\\n    function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function proveBatchContainsSequenceNumber(bytes calldata proof, uint256 inboxCount)\\n        external\\n        view\\n        returns (uint256, bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/challenge/ChallengeLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../libraries/MerkleLib.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary ChallengeLib {\\n    using SafeMath for uint256;\\n\\n    function firstSegmentSize(uint256 totalCount, uint256 bisectionCount)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return totalCount / bisectionCount + (totalCount % bisectionCount);\\n    }\\n\\n    function otherSegmentSize(uint256 totalCount, uint256 bisectionCount)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return totalCount / bisectionCount;\\n    }\\n\\n    function bisectionChunkHash(\\n        uint256 _segmentStart,\\n        uint256 _segmentLength,\\n        bytes32 _startHash,\\n        bytes32 _endHash\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_segmentStart, _segmentLength, _startHash, _endHash));\\n    }\\n\\n    function inboxDeltaHash(bytes32 _inboxAcc, bytes32 _deltaAcc) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_inboxAcc, _deltaAcc));\\n    }\\n\\n    function assertionHash(uint256 _arbGasUsed, bytes32 _restHash) internal pure returns (bytes32) {\\n        // Note: make sure this doesn't return Challenge.UNREACHABLE_ASSERTION (currently 0)\\n        return keccak256(abi.encodePacked(_arbGasUsed, _restHash));\\n    }\\n\\n    function assertionRestHash(\\n        uint256 _totalMessagesRead,\\n        bytes32 _machineState,\\n        bytes32 _sendAcc,\\n        uint256 _sendCount,\\n        bytes32 _logAcc,\\n        uint256 _logCount\\n    ) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    _totalMessagesRead,\\n                    _machineState,\\n                    _sendAcc,\\n                    _sendCount,\\n                    _logAcc,\\n                    _logCount\\n                )\\n            );\\n    }\\n\\n    function updatedBisectionRoot(\\n        bytes32[] memory _chainHashes,\\n        uint256 _challengedSegmentStart,\\n        uint256 _challengedSegmentLength\\n    ) internal pure returns (bytes32) {\\n        uint256 bisectionCount = _chainHashes.length - 1;\\n        bytes32[] memory hashes = new bytes32[](bisectionCount);\\n        uint256 chunkSize = ChallengeLib.firstSegmentSize(_challengedSegmentLength, bisectionCount);\\n        uint256 segmentStart = _challengedSegmentStart;\\n        hashes[0] = ChallengeLib.bisectionChunkHash(\\n            segmentStart,\\n            chunkSize,\\n            _chainHashes[0],\\n            _chainHashes[1]\\n        );\\n        segmentStart = segmentStart.add(chunkSize);\\n        chunkSize = ChallengeLib.otherSegmentSize(_challengedSegmentLength, bisectionCount);\\n        for (uint256 i = 1; i < bisectionCount; i++) {\\n            hashes[i] = ChallengeLib.bisectionChunkHash(\\n                segmentStart,\\n                chunkSize,\\n                _chainHashes[i],\\n                _chainHashes[i + 1]\\n            );\\n            segmentStart = segmentStart.add(chunkSize);\\n        }\\n        return MerkleLib.generateRoot(hashes);\\n    }\\n\\n    function verifySegmentProof(\\n        bytes32 challengeState,\\n        bytes32 item,\\n        bytes32[] calldata _merkleNodes,\\n        uint256 _merkleRoute\\n    ) internal pure returns (bool) {\\n        return challengeState == MerkleLib.calculateRoot(_merkleNodes, _merkleRoute, item);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/challenge/IChallenge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../bridge/interfaces/IBridge.sol\\\";\\nimport \\\"../bridge/interfaces/ISequencerInbox.sol\\\";\\nimport \\\"../arch/IOneStepProof.sol\\\";\\n\\ninterface IChallenge {\\n    function initializeChallenge(\\n        IOneStepProof[] calldata _executors,\\n        address _resultReceiver,\\n        bytes32 _executionHash,\\n        uint256 _maxMessageCount,\\n        address _asserter,\\n        address _challenger,\\n        uint256 _asserterTimeLeft,\\n        uint256 _challengerTimeLeft,\\n        ISequencerInbox _sequencerBridge,\\n        IBridge _delayedBridge\\n    ) external;\\n\\n    function currentResponderTimeLeft() external view returns (uint256);\\n\\n    function lastMoveBlock() external view returns (uint256);\\n\\n    function timeout() external;\\n\\n    function asserter() external view returns (address);\\n\\n    function challenger() external view returns (address);\\n\\n    function clearChallenge() external;\\n}\\n\"\r\n    },\r\n    \"contracts/challenge/IChallengeFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../bridge/interfaces/IBridge.sol\\\";\\nimport \\\"../bridge/interfaces/ISequencerInbox.sol\\\";\\n\\ninterface IChallengeFactory {\\n    function createChallenge(\\n        address _resultReceiver,\\n        bytes32 _executionHash,\\n        uint256 _maxMessageCount,\\n        address _asserter,\\n        address _challenger,\\n        uint256 _asserterTimeLeft,\\n        uint256 _challengerTimeLeft,\\n        ISequencerInbox _sequencerBridge,\\n        IBridge _delayedBridge\\n    ) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BytesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\n\\npragma solidity ^0.6.11;\\n\\n/* solhint-disable no-inline-assembly */\\nlibrary BytesLib {\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= (_start + 20), \\\"Read out of bounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= (_start + 1), \\\"Read out of bounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= (_start + 32), \\\"Read out of bounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= (_start + 32), \\\"Read out of bounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n}\\n/* solhint-enable no-inline-assembly */\\n\"\r\n    },\r\n    \"contracts/libraries/Cloneable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./ICloneable.sol\\\";\\n\\ncontract Cloneable is ICloneable {\\n    string private constant NOT_CLONE = \\\"NOT_CLONE\\\";\\n\\n    bool private isMasterCopy;\\n\\n    constructor() public {\\n        isMasterCopy = true;\\n    }\\n\\n    function isMaster() external view override returns (bool) {\\n        return isMasterCopy;\\n    }\\n\\n    function safeSelfDestruct(address payable dest) internal {\\n        require(!isMasterCopy, NOT_CLONE);\\n        selfdestruct(dest);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ICloneable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface ICloneable {\\n    function isMaster() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/MerkleLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nlibrary MerkleLib {\\n    function generateRoot(bytes32[] memory _hashes) internal pure returns (bytes32) {\\n        bytes32[] memory prevLayer = _hashes;\\n        while (prevLayer.length > 1) {\\n            bytes32[] memory nextLayer = new bytes32[]((prevLayer.length + 1) / 2);\\n            for (uint256 i = 0; i < nextLayer.length; i++) {\\n                if (2 * i + 1 < prevLayer.length) {\\n                    nextLayer[i] = keccak256(\\n                        abi.encodePacked(prevLayer[2 * i], prevLayer[2 * i + 1])\\n                    );\\n                } else {\\n                    nextLayer[i] = prevLayer[2 * i];\\n                }\\n            }\\n            prevLayer = nextLayer;\\n        }\\n        return prevLayer[0];\\n    }\\n\\n    function calculateRoot(\\n        bytes32[] memory nodes,\\n        uint256 route,\\n        bytes32 item\\n    ) internal pure returns (bytes32) {\\n        uint256 proofItems = nodes.length;\\n        require(proofItems <= 256);\\n        bytes32 h = item;\\n        for (uint256 i = 0; i < proofItems; i++) {\\n            if (route % 2 == 0) {\\n                h = keccak256(abi.encodePacked(nodes[i], h));\\n            } else {\\n                h = keccak256(abi.encodePacked(h, nodes[i]));\\n            }\\n            route /= 2;\\n        }\\n        return h;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Whitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nabstract contract WhitelistConsumer {\\n    address public whitelist;\\n\\n    event WhitelistSourceUpdated(address newSource);\\n\\n    modifier onlyWhitelisted {\\n        if (whitelist != address(0)) {\\n            require(Whitelist(whitelist).isAllowed(msg.sender), \\\"NOT_WHITELISTED\\\");\\n        }\\n        _;\\n    }\\n\\n    function updateWhitelistSource(address newSource) external {\\n        require(msg.sender == whitelist, \\\"NOT_FROM_LIST\\\");\\n        whitelist = newSource;\\n        emit WhitelistSourceUpdated(newSource);\\n    }\\n}\\n\\ncontract Whitelist {\\n    address public owner;\\n    mapping(address => bool) public isAllowed;\\n\\n    event OwnerUpdated(address newOwner);\\n    event WhitelistUpgraded(address newWhitelist, address[] targets);\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"ONLY_OWNER\\\");\\n        _;\\n    }\\n\\n    function setOwner(address newOwner) external onlyOwner {\\n        owner = newOwner;\\n        emit OwnerUpdated(newOwner);\\n    }\\n\\n    function setWhitelist(address[] memory user, bool[] memory val) external onlyOwner {\\n        require(user.length == val.length, \\\"INVALID_INPUT\\\");\\n\\n        for (uint256 i = 0; i < user.length; i++) {\\n            isAllowed[user[i]] = val[i];\\n        }\\n    }\\n\\n    // set new whitelist to address(0) to disable whitelist\\n    function triggerConsumers(address newWhitelist, address[] memory targets) external onlyOwner {\\n        for (uint256 i = 0; i < targets.length; i++) {\\n            WhitelistConsumer(targets[i]).updateWhitelistSource(newWhitelist);\\n        }\\n        emit WhitelistUpgraded(newWhitelist, targets);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rollup/BridgeCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../bridge/Bridge.sol\\\";\\nimport \\\"../bridge/SequencerInbox.sol\\\";\\nimport \\\"../bridge/Inbox.sol\\\";\\nimport \\\"../bridge/Outbox.sol\\\";\\nimport \\\"./RollupEventBridge.sol\\\";\\n\\nimport \\\"../bridge/interfaces/IBridge.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/ProxyAdmin.sol\\\";\\nimport \\\"../libraries/Whitelist.sol\\\";\\n\\ncontract BridgeCreator is Ownable {\\n    Bridge public delayedBridgeTemplate;\\n    SequencerInbox public sequencerInboxTemplate;\\n    Inbox public inboxTemplate;\\n    RollupEventBridge public rollupEventBridgeTemplate;\\n    Outbox public outboxTemplate;\\n\\n    event TemplatesUpdated();\\n\\n    constructor() public Ownable() {\\n        delayedBridgeTemplate = new Bridge();\\n        sequencerInboxTemplate = new SequencerInbox();\\n        inboxTemplate = new Inbox();\\n        rollupEventBridgeTemplate = new RollupEventBridge();\\n        outboxTemplate = new Outbox();\\n    }\\n\\n    function updateTemplates(\\n        address _delayedBridgeTemplate,\\n        address _sequencerInboxTemplate,\\n        address _inboxTemplate,\\n        address _rollupEventBridgeTemplate,\\n        address _outboxTemplate\\n    ) external onlyOwner {\\n        delayedBridgeTemplate = Bridge(_delayedBridgeTemplate);\\n        sequencerInboxTemplate = SequencerInbox(_sequencerInboxTemplate);\\n        inboxTemplate = Inbox(_inboxTemplate);\\n        rollupEventBridgeTemplate = RollupEventBridge(_rollupEventBridgeTemplate);\\n        outboxTemplate = Outbox(_outboxTemplate);\\n\\n        emit TemplatesUpdated();\\n    }\\n\\n    struct CreateBridgeFrame {\\n        ProxyAdmin admin;\\n        Bridge delayedBridge;\\n        SequencerInbox sequencerInbox;\\n        Inbox inbox;\\n        RollupEventBridge rollupEventBridge;\\n        Outbox outbox;\\n        Whitelist whitelist;\\n    }\\n\\n    function createBridge(\\n        address adminProxy,\\n        address rollup,\\n        address sequencer\\n    )\\n        external\\n        returns (\\n            Bridge,\\n            SequencerInbox,\\n            Inbox,\\n            RollupEventBridge,\\n            Outbox\\n        )\\n    {\\n        CreateBridgeFrame memory frame;\\n        {\\n            frame.delayedBridge = Bridge(\\n                address(\\n                    new TransparentUpgradeableProxy(address(delayedBridgeTemplate), adminProxy, \\\"\\\")\\n                )\\n            );\\n            frame.sequencerInbox = SequencerInbox(\\n                address(\\n                    new TransparentUpgradeableProxy(address(sequencerInboxTemplate), adminProxy, \\\"\\\")\\n                )\\n            );\\n            frame.inbox = Inbox(\\n                address(new TransparentUpgradeableProxy(address(inboxTemplate), adminProxy, \\\"\\\"))\\n            );\\n            frame.rollupEventBridge = RollupEventBridge(\\n                address(\\n                    new TransparentUpgradeableProxy(\\n                        address(rollupEventBridgeTemplate),\\n                        adminProxy,\\n                        \\\"\\\"\\n                    )\\n                )\\n            );\\n            frame.outbox = Outbox(\\n                address(new TransparentUpgradeableProxy(address(outboxTemplate), adminProxy, \\\"\\\"))\\n            );\\n            frame.whitelist = new Whitelist();\\n        }\\n\\n        frame.delayedBridge.initialize();\\n        frame.sequencerInbox.initialize(IBridge(frame.delayedBridge), sequencer, rollup);\\n        frame.inbox.initialize(IBridge(frame.delayedBridge), address(frame.whitelist));\\n        frame.rollupEventBridge.initialize(address(frame.delayedBridge), rollup);\\n        frame.outbox.initialize(rollup, IBridge(frame.delayedBridge));\\n\\n        frame.delayedBridge.setInbox(address(frame.inbox), true);\\n        frame.delayedBridge.transferOwnership(rollup);\\n\\n        frame.whitelist.setOwner(rollup);\\n\\n        return (\\n            frame.delayedBridge,\\n            frame.sequencerInbox,\\n            frame.inbox,\\n            frame.rollupEventBridge,\\n            frame.outbox\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rollup/INode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface INode {\\n    function initialize(\\n        address _rollup,\\n        bytes32 _stateHash,\\n        bytes32 _challengeHash,\\n        bytes32 _confirmData,\\n        uint256 _prev,\\n        uint256 _deadlineBlock\\n    ) external;\\n\\n    function destroy() external;\\n\\n    function addStaker(address staker) external returns (uint256);\\n\\n    function removeStaker(address staker) external;\\n\\n    function childCreated(uint256) external;\\n\\n    function resetChildren() external;\\n\\n    function newChildConfirmDeadline(uint256 deadline) external;\\n\\n    function stateHash() external view returns (bytes32);\\n\\n    function challengeHash() external view returns (bytes32);\\n\\n    function confirmData() external view returns (bytes32);\\n\\n    function prev() external view returns (uint256);\\n\\n    function deadlineBlock() external view returns (uint256);\\n\\n    function noChildConfirmedBeforeBlock() external view returns (uint256);\\n\\n    function stakerCount() external view returns (uint256);\\n\\n    function stakers(address staker) external view returns (bool);\\n\\n    function firstChildBlock() external view returns (uint256);\\n\\n    function latestChildNumber() external view returns (uint256);\\n\\n    function requirePastDeadline() external view;\\n\\n    function requirePastChildConfirmDeadline() external view;\\n}\\n\"\r\n    },\r\n    \"contracts/rollup/INodeFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface INodeFactory {\\n    function createNode(\\n        bytes32 _stateHash,\\n        bytes32 _challengeHash,\\n        bytes32 _confirmData,\\n        uint256 _prev,\\n        uint256 _deadlineBlock\\n    ) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/rollup/IRollupCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./INode.sol\\\";\\n\\ninterface IRollupCore {\\n    function _stakerMap(address stakerAddress)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            address,\\n            bool\\n        );\\n\\n    function getNode(uint256 nodeNum) external view returns (INode);\\n\\n    /**\\n     * @notice Get the address of the staker at the given index\\n     * @param stakerNum Index of the staker\\n     * @return Address of the staker\\n     */\\n    function getStakerAddress(uint256 stakerNum) external view returns (address);\\n\\n    /**\\n     * @notice Check whether the given staker is staked\\n     * @param staker Staker address to check\\n     * @return True or False for whether the staker was staked\\n     */\\n    function isStaked(address staker) external view returns (bool);\\n\\n    /**\\n     * @notice Get the latest staked node of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Latest node staked of the staker\\n     */\\n    function latestStakedNode(address staker) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the current challenge of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Current challenge of the staker\\n     */\\n    function currentChallenge(address staker) external view returns (address);\\n\\n    /**\\n     * @notice Get the amount staked of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Amount staked of the staker\\n     */\\n    function amountStaked(address staker) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the original staker address of the zombie at the given index\\n     * @param zombieNum Index of the zombie to lookup\\n     * @return Original staker address of the zombie\\n     */\\n    function zombieAddress(uint256 zombieNum) external view returns (address);\\n\\n    /**\\n     * @notice Get Latest node that the given zombie at the given index is staked on\\n     * @param zombieNum Index of the zombie to lookup\\n     * @return Latest node that the given zombie is staked on\\n     */\\n    function zombieLatestStakedNode(uint256 zombieNum) external view returns (uint256);\\n\\n    /// @return Current number of un-removed zombies\\n    function zombieCount() external view returns (uint256);\\n\\n    function isZombie(address staker) external view returns (bool);\\n\\n    /**\\n     * @notice Get the amount of funds withdrawable by the given address\\n     * @param owner Address to check the funds of\\n     * @return Amount of funds withdrawable by owner\\n     */\\n    function withdrawableFunds(address owner) external view returns (uint256);\\n\\n    /**\\n     * @return Index of the first unresolved node\\n     * @dev If all nodes have been resolved, this will be latestNodeCreated + 1\\n     */\\n    function firstUnresolvedNode() external view returns (uint256);\\n\\n    /// @return Index of the latest confirmed node\\n    function latestConfirmed() external view returns (uint256);\\n\\n    /// @return Index of the latest rollup node created\\n    function latestNodeCreated() external view returns (uint256);\\n\\n    /// @return Ethereum block that the most recent stake was created\\n    function lastStakeBlock() external view returns (uint256);\\n\\n    /// @return Number of active stakers currently staked\\n    function stakerCount() external view returns (uint256);\\n\\n    /// @return Node hash as of this node number\\n    function getNodeHash(uint256 index) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/rollup/Rollup.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./RollupCore.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/ProxyAdmin.sol\\\";\\nimport \\\"./RollupEventBridge.sol\\\";\\n\\nimport \\\"./INode.sol\\\";\\nimport \\\"./INodeFactory.sol\\\";\\nimport \\\"../challenge/IChallenge.sol\\\";\\nimport \\\"../challenge/IChallengeFactory.sol\\\";\\nimport \\\"../bridge/interfaces/IBridge.sol\\\";\\nimport \\\"../bridge/interfaces/IOutbox.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../bridge/Messages.sol\\\";\\nimport \\\"./RollupLib.sol\\\";\\nimport \\\"../libraries/Cloneable.sol\\\";\\nimport \\\"./facets/IRollupFacets.sol\\\";\\n\\nabstract contract RollupBase is Cloneable, RollupCore, Pausable {\\n    // Rollup Config\\n    uint256 public confirmPeriodBlocks;\\n    uint256 public extraChallengeTimeBlocks;\\n    uint256 public arbGasSpeedLimitPerBlock;\\n    uint256 public baseStake;\\n\\n    // Bridge is an IInbox and IOutbox\\n    IBridge public delayedBridge;\\n    ISequencerInbox public sequencerBridge;\\n    IOutbox public outbox;\\n    RollupEventBridge public rollupEventBridge;\\n    IChallengeFactory public challengeFactory;\\n    INodeFactory public nodeFactory;\\n    address public owner;\\n    address public stakeToken;\\n    uint256 public minimumAssertionPeriod;\\n\\n    uint256 public sequencerInboxMaxDelayBlocks;\\n    uint256 public sequencerInboxMaxDelaySeconds;\\n    uint256 public challengeExecutionBisectionDegree;\\n\\n    address[] internal facets;\\n\\n    mapping(address => bool) isValidator;\\n\\n    event RollupCreated(bytes32 machineHash);\\n\\n    event NodeCreated(\\n        uint256 indexed nodeNum,\\n        bytes32 indexed parentNodeHash,\\n        bytes32 nodeHash,\\n        bytes32 executionHash,\\n        uint256 inboxMaxCount,\\n        uint256 afterInboxBatchEndCount,\\n        bytes32 afterInboxBatchAcc,\\n        bytes32[3][2] assertionBytes32Fields,\\n        uint256[4][2] assertionIntFields\\n    );\\n\\n    event NodeConfirmed(\\n        uint256 indexed nodeNum,\\n        bytes32 afterSendAcc,\\n        uint256 afterSendCount,\\n        bytes32 afterLogAcc,\\n        uint256 afterLogCount\\n    );\\n\\n    event NodeRejected(uint256 indexed nodeNum);\\n\\n    event RollupChallengeStarted(\\n        address indexed challengeContract,\\n        address asserter,\\n        address challenger,\\n        uint256 challengedNode\\n    );\\n\\n    event StakerReassigned(address indexed staker, uint256 newNode);\\n    event NodesDestroyed(uint256 indexed startNode, uint256 indexed endNode);\\n    event OwnerFunctionCalled(uint256 indexed id);\\n}\\n\\ncontract Rollup is RollupBase {\\n    // _rollupParams = [ confirmPeriodBlocks, extraChallengeTimeBlocks, arbGasSpeedLimitPerBlock, baseStake ]\\n    // connectedContracts = [delayedBridge, sequencerInbox, outbox, rollupEventBridge, challengeFactory, nodeFactory]\\n    function initialize(\\n        bytes32 _machineHash,\\n        uint256[4] calldata _rollupParams,\\n        address _stakeToken,\\n        address _owner,\\n        bytes calldata _extraConfig,\\n        address[6] calldata connectedContracts,\\n        address[2] calldata _facets,\\n        uint256[2] calldata sequencerInboxParams\\n    ) public {\\n        require(confirmPeriodBlocks == 0, \\\"ALREADY_INIT\\\");\\n        require(_rollupParams[0] != 0, \\\"BAD_CONF_PERIOD\\\");\\n\\n        delayedBridge = IBridge(connectedContracts[0]);\\n        sequencerBridge = ISequencerInbox(connectedContracts[1]);\\n        outbox = IOutbox(connectedContracts[2]);\\n        delayedBridge.setOutbox(connectedContracts[2], true);\\n        rollupEventBridge = RollupEventBridge(connectedContracts[3]);\\n        delayedBridge.setInbox(connectedContracts[3], true);\\n\\n        rollupEventBridge.rollupInitialized(\\n            _rollupParams[0],\\n            _rollupParams[2],\\n            _rollupParams[3],\\n            _stakeToken,\\n            _owner,\\n            _extraConfig\\n        );\\n\\n        challengeFactory = IChallengeFactory(connectedContracts[4]);\\n        nodeFactory = INodeFactory(connectedContracts[5]);\\n\\n        INode node = createInitialNode(_machineHash);\\n        initializeCore(node);\\n\\n        confirmPeriodBlocks = _rollupParams[0];\\n        extraChallengeTimeBlocks = _rollupParams[1];\\n        arbGasSpeedLimitPerBlock = _rollupParams[2];\\n        baseStake = _rollupParams[3];\\n        owner = _owner;\\n        // A little over 15 minutes\\n        minimumAssertionPeriod = 75;\\n        challengeExecutionBisectionDegree = 400;\\n\\n        sequencerInboxMaxDelayBlocks = sequencerInboxParams[0];\\n        sequencerInboxMaxDelaySeconds = sequencerInboxParams[1];\\n\\n        // facets[0] == admin, facets[1] == user\\n        facets = _facets;\\n\\n        (bool success, ) =\\n            _facets[1].delegatecall(\\n                abi.encodeWithSelector(IRollupUser.initialize.selector, _stakeToken)\\n            );\\n        require(success, \\\"FAIL_INIT_FACET\\\");\\n\\n        emit RollupCreated(_machineHash);\\n    }\\n\\n    function createInitialNode(bytes32 _machineHash) private returns (INode) {\\n        bytes32 state =\\n            RollupLib.stateHash(\\n                RollupLib.ExecutionState(\\n                    0, // total gas used\\n                    _machineHash,\\n                    0, // inbox count\\n                    0, // send count\\n                    0, // log count\\n                    0, // send acc\\n                    0, // log acc\\n                    block.number, // block proposed\\n                    1 // Initialization message already in inbox\\n                )\\n            );\\n        return\\n            INode(\\n                nodeFactory.createNode(\\n                    state,\\n                    0, // challenge hash (not challengeable)\\n                    0, // confirm data\\n                    0, // prev node\\n                    block.number // deadline block (not challengeable)\\n                )\\n            );\\n    }\\n\\n    /**\\n     * Fallback and delegate functions from OZ\\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/proxy/TransparentUpgradeableProxy.sol\\n     * And dispatch pattern from EIP-2535: Diamonds\\n     */\\n\\n    function getFacets() public view returns (address, address) {\\n        return (getAdminFacet(), getUserFacet());\\n    }\\n\\n    function getAdminFacet() public view returns (address) {\\n        return facets[0];\\n    }\\n\\n    function getUserFacet() public view returns (address) {\\n        return facets[1];\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        require(msg.data.length >= 4, \\\"NO_FUNC_SIG\\\");\\n        address rollupOwner = owner;\\n        // if there is an owner and it is the sender, delegate to admin facet\\n        address target =\\n            rollupOwner != address(0) && rollupOwner == msg.sender\\n                ? getAdminFacet()\\n                : getUserFacet();\\n        _delegate(target);\\n    }\\n\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n                // delegatecall returns 0 on error.\\n                case 0 {\\n                    revert(0, returndatasize())\\n                }\\n                default {\\n                    return(0, returndatasize())\\n                }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rollup/RollupCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./INode.sol\\\";\\nimport \\\"./IRollupCore.sol\\\";\\nimport \\\"./RollupLib.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract RollupCore is IRollupCore {\\n    using SafeMath for uint256;\\n\\n    struct Zombie {\\n        address stakerAddress;\\n        uint256 latestStakedNode;\\n    }\\n\\n    struct Staker {\\n        uint256 index;\\n        uint256 latestStakedNode;\\n        uint256 amountStaked;\\n        // currentChallenge is 0 if staker is not in a challenge\\n        address currentChallenge;\\n        bool isStaked;\\n    }\\n\\n    uint256 private _latestConfirmed;\\n    uint256 private _firstUnresolvedNode;\\n    uint256 private _latestNodeCreated;\\n    uint256 private _lastStakeBlock;\\n    mapping(uint256 => INode) private _nodes;\\n    mapping(uint256 => bytes32) private _nodeHashes;\\n\\n    address payable[] private _stakerList;\\n    mapping(address => Staker) public override _stakerMap;\\n\\n    Zombie[] private _zombies;\\n\\n    mapping(address => uint256) private _withdrawableFunds;\\n\\n    /**\\n     * @notice Get the address of the Node contract for the given node\\n     * @param nodeNum Index of the node\\n     * @return Address of the Node contract\\n     */\\n    function getNode(uint256 nodeNum) public view override returns (INode) {\\n        return _nodes[nodeNum];\\n    }\\n\\n    /**\\n     * @notice Get the address of the staker at the given index\\n     * @param stakerNum Index of the staker\\n     * @return Address of the staker\\n     */\\n    function getStakerAddress(uint256 stakerNum) public view override returns (address) {\\n        return _stakerList[stakerNum];\\n    }\\n\\n    /**\\n     * @notice Check whether the given staker is staked\\n     * @param staker Staker address to check\\n     * @return True or False for whether the staker was staked\\n     */\\n    function isStaked(address staker) public view override returns (bool) {\\n        return _stakerMap[staker].isStaked;\\n    }\\n\\n    /**\\n     * @notice Get the latest staked node of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Latest node staked of the staker\\n     */\\n    function latestStakedNode(address staker) public view override returns (uint256) {\\n        return _stakerMap[staker].latestStakedNode;\\n    }\\n\\n    /**\\n     * @notice Get the current challenge of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Current challenge of the staker\\n     */\\n    function currentChallenge(address staker) public view override returns (address) {\\n        return _stakerMap[staker].currentChallenge;\\n    }\\n\\n    /**\\n     * @notice Get the amount staked of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Amount staked of the staker\\n     */\\n    function amountStaked(address staker) public view override returns (uint256) {\\n        return _stakerMap[staker].amountStaked;\\n    }\\n\\n    /**\\n     * @notice Get the original staker address of the zombie at the given index\\n     * @param zombieNum Index of the zombie to lookup\\n     * @return Original staker address of the zombie\\n     */\\n    function zombieAddress(uint256 zombieNum) public view override returns (address) {\\n        return _zombies[zombieNum].stakerAddress;\\n    }\\n\\n    /**\\n     * @notice Get Latest node that the given zombie at the given index is staked on\\n     * @param zombieNum Index of the zombie to lookup\\n     * @return Latest node that the given zombie is staked on\\n     */\\n    function zombieLatestStakedNode(uint256 zombieNum) public view override returns (uint256) {\\n        return _zombies[zombieNum].latestStakedNode;\\n    }\\n\\n    /// @return Current number of un-removed zombies\\n    function zombieCount() public view override returns (uint256) {\\n        return _zombies.length;\\n    }\\n\\n    function isZombie(address staker) public view override returns (bool) {\\n        for (uint256 i = 0; i < _zombies.length; i++) {\\n            if (staker == _zombies[i].stakerAddress) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Get the amount of funds withdrawable by the given address\\n     * @param owner Address to check the funds of\\n     * @return Amount of funds withdrawable by owner\\n     */\\n    function withdrawableFunds(address owner) public view override returns (uint256) {\\n        return _withdrawableFunds[owner];\\n    }\\n\\n    /**\\n     * @return Index of the first unresolved node\\n     * @dev If all nodes have been resolved, this will be latestNodeCreated + 1\\n     */\\n    function firstUnresolvedNode() public view override returns (uint256) {\\n        return _firstUnresolvedNode;\\n    }\\n\\n    /// @return Index of the latest confirmed node\\n    function latestConfirmed() public view override returns (uint256) {\\n        return _latestConfirmed;\\n    }\\n\\n    /// @return Index of the latest rollup node created\\n    function latestNodeCreated() public view override returns (uint256) {\\n        return _latestNodeCreated;\\n    }\\n\\n    /// @return Ethereum block that the most recent stake was created\\n    function lastStakeBlock() public view override returns (uint256) {\\n        return _lastStakeBlock;\\n    }\\n\\n    /// @return Number of active stakers currently staked\\n    function stakerCount() public view override returns (uint256) {\\n        return _stakerList.length;\\n    }\\n\\n    /**\\n     * @notice Initialize the core with an initial node\\n     * @param initialNode Initial node to start the chain with\\n     */\\n    function initializeCore(INode initialNode) internal {\\n        _nodes[0] = initialNode;\\n        _firstUnresolvedNode = 1;\\n    }\\n\\n    /**\\n     * @notice React to a new node being created by storing it an incrementing the latest node counter\\n     * @param node Node that was newly created\\n     * @param nodeHash The hash of said node\\n     */\\n    function nodeCreated(INode node, bytes32 nodeHash) internal {\\n        _latestNodeCreated++;\\n        _nodes[_latestNodeCreated] = node;\\n        _nodeHashes[_latestNodeCreated] = nodeHash;\\n    }\\n\\n    /// @return Node hash as of this node number\\n    function getNodeHash(uint256 index) public view override returns (bytes32) {\\n        return _nodeHashes[index];\\n    }\\n\\n    function resetNodeHash(uint256 index) internal {\\n        _nodeHashes[index] = 0;\\n    }\\n\\n    /**\\n     * @notice Update the latest node created\\n     * @param newLatestNodeCreated New value for the latest node created\\n     */\\n    function updateLatestNodeCreated(uint256 newLatestNodeCreated) internal {\\n        _latestNodeCreated = newLatestNodeCreated;\\n    }\\n\\n    /// @notice Reject the next unresolved node\\n    function rejectNextNode() internal {\\n        destroyNode(_firstUnresolvedNode);\\n        _firstUnresolvedNode++;\\n    }\\n\\n    /// @notice Confirm the next unresolved node\\n    function confirmNextNode() internal {\\n        destroyNode(_latestConfirmed);\\n        _latestConfirmed = _firstUnresolvedNode;\\n        _firstUnresolvedNode++;\\n    }\\n\\n    /// @notice Confirm the next unresolved node\\n    function confirmLatestNode() internal {\\n        destroyNode(_latestConfirmed);\\n        uint256 latestNode = _latestNodeCreated;\\n        _latestConfirmed = latestNode;\\n        _firstUnresolvedNode = latestNode + 1;\\n    }\\n\\n    /**\\n     * @notice Create a new stake\\n     * @param stakerAddress Address of the new staker\\n     * @param depositAmount Stake amount of the new staker\\n     */\\n    function createNewStake(address payable stakerAddress, uint256 depositAmount) internal {\\n        uint256 stakerIndex = _stakerList.length;\\n        _stakerList.push(stakerAddress);\\n        _stakerMap[stakerAddress] = Staker(\\n            stakerIndex,\\n            _latestConfirmed,\\n            depositAmount,\\n            address(0),\\n            true\\n        );\\n        _lastStakeBlock = block.number;\\n    }\\n\\n    /**\\n     * @notice Check to see whether the two stakers are in the same challenge\\n     * @param stakerAddress1 Address of the first staker\\n     * @param stakerAddress2 Address of the second staker\\n     * @return Address of the challenge that the two stakers are in\\n     */\\n    function inChallenge(address stakerAddress1, address stakerAddress2)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        Staker storage staker1 = _stakerMap[stakerAddress1];\\n        Staker storage staker2 = _stakerMap[stakerAddress2];\\n        address challenge = staker1.currentChallenge;\\n        require(challenge == staker2.currentChallenge, \\\"IN_CHAL\\\");\\n        require(challenge != address(0), \\\"NO_CHAL\\\");\\n        return challenge;\\n    }\\n\\n    /**\\n     * @notice Make the given staker as not being in a challenge\\n     * @param stakerAddress Address of the staker to remove from a challenge\\n     */\\n    function clearChallenge(address stakerAddress) internal {\\n        Staker storage staker = _stakerMap[stakerAddress];\\n        staker.currentChallenge = address(0);\\n    }\\n\\n    /**\\n     * @notice Mark both the given stakers as engaged in the challenge\\n     * @param staker1 Address of the first staker\\n     * @param staker2 Address of the second staker\\n     * @param challenge Address of the challenge both stakers are now in\\n     */\\n    function challengeStarted(\\n        address staker1,\\n        address staker2,\\n        address challenge\\n    ) internal {\\n        _stakerMap[staker1].currentChallenge = challenge;\\n        _stakerMap[staker2].currentChallenge = challenge;\\n    }\\n\\n    /**\\n     * @notice Add to the stake of the given staker by the given amount\\n     * @param stakerAddress Address of the staker to increase the stake of\\n     * @param amountAdded Amount of stake to add to the staker\\n     */\\n    function increaseStakeBy(address stakerAddress, uint256 amountAdded) internal {\\n        Staker storage staker = _stakerMap[stakerAddress];\\n        staker.amountStaked = staker.amountStaked.add(amountAdded);\\n    }\\n\\n    /**\\n     * @notice Reduce the stake of the given staker to the given target\\n     * @param stakerAddress Address of the staker to reduce the stake of\\n     * @param target Amount of stake to leave with the staker\\n     * @return Amount of value released from the stake\\n     */\\n    function reduceStakeTo(address stakerAddress, uint256 target) internal returns (uint256) {\\n        Staker storage staker = _stakerMap[stakerAddress];\\n        uint256 current = staker.amountStaked;\\n        require(target <= current, \\\"TOO_LITTLE_STAKE\\\");\\n        uint256 amountWithdrawn = current.sub(target);\\n        staker.amountStaked = target;\\n        _withdrawableFunds[stakerAddress] = _withdrawableFunds[stakerAddress].add(amountWithdrawn);\\n        return amountWithdrawn;\\n    }\\n\\n    /**\\n     * @notice Remove the given staker and turn them into a zombie\\n     * @param stakerAddress Address of the staker to remove\\n     */\\n    function turnIntoZombie(address stakerAddress) internal {\\n        Staker storage staker = _stakerMap[stakerAddress];\\n        _zombies.push(Zombie(stakerAddress, staker.latestStakedNode));\\n        deleteStaker(stakerAddress);\\n    }\\n\\n    /**\\n     * @notice Update the latest staked node of the zombie at the given index\\n     * @param zombieNum Index of the zombie to move\\n     * @param latest New latest node the zombie is staked on\\n     */\\n    function zombieUpdateLatestStakedNode(uint256 zombieNum, uint256 latest) internal {\\n        _zombies[zombieNum].latestStakedNode = latest;\\n    }\\n\\n    /**\\n     * @notice Remove the zombie at the given index\\n     * @param zombieNum Index of the zombie to remove\\n     */\\n    function removeZombie(uint256 zombieNum) internal {\\n        _zombies[zombieNum] = _zombies[_zombies.length - 1];\\n        _zombies.pop();\\n    }\\n\\n    /**\\n     * @notice Remove the given staker and return their stake\\n     * @param stakerAddress Address of the staker withdrawing their stake\\n     */\\n    function withdrawStaker(address stakerAddress) internal {\\n        Staker storage staker = _stakerMap[stakerAddress];\\n        _withdrawableFunds[stakerAddress] = _withdrawableFunds[stakerAddress].add(\\n            staker.amountStaked\\n        );\\n        deleteStaker(stakerAddress);\\n    }\\n\\n    /**\\n     * @notice Advance the given staker to the given node\\n     * @param stakerAddress Address of the staker adding their stake\\n     * @param nodeNum Index of the node to stake on\\n     */\\n    function stakeOnNode(\\n        address stakerAddress,\\n        uint256 nodeNum,\\n        uint256 confirmPeriodBlocks\\n    ) internal {\\n        Staker storage staker = _stakerMap[stakerAddress];\\n        INode node = _nodes[nodeNum];\\n        uint256 newStakerCount = node.addStaker(stakerAddress);\\n        staker.latestStakedNode = nodeNum;\\n        if (newStakerCount == 1) {\\n            INode parent = _nodes[node.prev()];\\n            parent.newChildConfirmDeadline(block.number.add(confirmPeriodBlocks));\\n        }\\n    }\\n\\n    /**\\n     * @notice Clear the withdrawable funds for the given address\\n     * @param owner Address of the account to remove funds from\\n     * @return Amount of funds removed from account\\n     */\\n    function withdrawFunds(address owner) internal returns (uint256) {\\n        uint256 amount = _withdrawableFunds[owner];\\n        _withdrawableFunds[owner] = 0;\\n        return amount;\\n    }\\n\\n    /**\\n     * @notice Increase the withdrawable funds for the given address\\n     * @param owner Address of the account to add withdrawable funds to\\n     */\\n    function increaseWithdrawableFunds(address owner, uint256 amount) internal {\\n        _withdrawableFunds[owner] = _withdrawableFunds[owner].add(amount);\\n    }\\n\\n    /**\\n     * @notice Remove the given staker\\n     * @param stakerAddress Address of the staker to remove\\n     */\\n    function deleteStaker(address stakerAddress) private {\\n        Staker storage staker = _stakerMap[stakerAddress];\\n        uint256 stakerIndex = staker.index;\\n        _stakerList[stakerIndex] = _stakerList[_stakerList.length - 1];\\n        _stakerMap[_stakerList[stakerIndex]].index = stakerIndex;\\n        _stakerList.pop();\\n        delete _stakerMap[stakerAddress];\\n    }\\n\\n    /**\\n     * @notice Destroy the given node and clear out its address\\n     * @param nodeNum Index of the node to remove\\n     */\\n    function destroyNode(uint256 nodeNum) internal {\\n        _nodes[nodeNum].destroy();\\n        _nodes[nodeNum] = INode(0);\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rollup/RollupCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../bridge/Bridge.sol\\\";\\nimport \\\"../bridge/SequencerInbox.sol\\\";\\nimport \\\"../bridge/Inbox.sol\\\";\\nimport \\\"../bridge/Outbox.sol\\\";\\nimport \\\"./RollupEventBridge.sol\\\";\\nimport \\\"./BridgeCreator.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/proxy/ProxyAdmin.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./Rollup.sol\\\";\\nimport \\\"./facets/RollupUser.sol\\\";\\nimport \\\"./facets/RollupAdmin.sol\\\";\\nimport \\\"../bridge/interfaces/IBridge.sol\\\";\\n\\nimport \\\"./RollupLib.sol\\\";\\nimport \\\"../libraries/ICloneable.sol\\\";\\n\\ncontract RollupCreator is Ownable {\\n    event RollupCreated(address indexed rollupAddress, address inboxAddress, address adminProxy);\\n    event TemplatesUpdated();\\n\\n    BridgeCreator public bridgeCreator;\\n    ICloneable public rollupTemplate;\\n    address public challengeFactory;\\n    address public nodeFactory;\\n    address public rollupAdminFacet;\\n    address public rollupUserFacet;\\n\\n    constructor() public Ownable() {}\\n\\n    function setTemplates(\\n        BridgeCreator _bridgeCreator,\\n        ICloneable _rollupTemplate,\\n        address _challengeFactory,\\n        address _nodeFactory,\\n        address _rollupAdminFacet,\\n        address _rollupUserFacet\\n    ) external onlyOwner {\\n        bridgeCreator = _bridgeCreator;\\n        rollupTemplate = _rollupTemplate;\\n        challengeFactory = _challengeFactory;\\n        nodeFactory = _nodeFactory;\\n        rollupAdminFacet = _rollupAdminFacet;\\n        rollupUserFacet = _rollupUserFacet;\\n        emit TemplatesUpdated();\\n    }\\n\\n    function createRollup(\\n        bytes32 _machineHash,\\n        uint256 _confirmPeriodBlocks,\\n        uint256 _extraChallengeTimeBlocks,\\n        uint256 _arbGasSpeedLimitPerBlock,\\n        uint256 _baseStake,\\n        address _stakeToken,\\n        address _owner,\\n        address _sequencer,\\n        uint256 _sequencerDelayBlocks,\\n        uint256 _sequencerDelaySeconds,\\n        bytes calldata _extraConfig\\n    ) external returns (address) {\\n        return\\n            createRollup(\\n                RollupLib.Config(\\n                    _machineHash,\\n                    _confirmPeriodBlocks,\\n                    _extraChallengeTimeBlocks,\\n                    _arbGasSpeedLimitPerBlock,\\n                    _baseStake,\\n                    _stakeToken,\\n                    _owner,\\n                    _sequencer,\\n                    _sequencerDelayBlocks,\\n                    _sequencerDelaySeconds,\\n                    _extraConfig\\n                )\\n            );\\n    }\\n\\n    struct CreateRollupFrame {\\n        ProxyAdmin admin;\\n        Bridge delayedBridge;\\n        SequencerInbox sequencerInbox;\\n        Inbox inbox;\\n        RollupEventBridge rollupEventBridge;\\n        Outbox outbox;\\n        address rollup;\\n    }\\n\\n    // After this setup:\\n    // Rollup should be the owner of bridge\\n    // RollupOwner should be the owner of Rollup's ProxyAdmin\\n    // RollupOwner should be the owner of Rollup\\n    // Bridge should have a single inbox and outbox\\n    function createRollup(RollupLib.Config memory config) private returns (address) {\\n        CreateRollupFrame memory frame;\\n        frame.admin = new ProxyAdmin();\\n        frame.rollup = address(\\n            new TransparentUpgradeableProxy(address(rollupTemplate), address(frame.admin), \\\"\\\")\\n        );\\n\\n        (\\n            frame.delayedBridge,\\n            frame.sequencerInbox,\\n            frame.inbox,\\n            frame.rollupEventBridge,\\n            frame.outbox\\n        ) = bridgeCreator.createBridge(address(frame.admin), frame.rollup, config.sequencer);\\n\\n        frame.admin.transferOwnership(config.owner);\\n        Rollup(payable(frame.rollup)).initialize(\\n            config.machineHash,\\n            [\\n                config.confirmPeriodBlocks,\\n                config.extraChallengeTimeBlocks,\\n                config.arbGasSpeedLimitPerBlock,\\n                config.baseStake\\n            ],\\n            config.stakeToken,\\n            config.owner,\\n            config.extraConfig,\\n            [\\n                address(frame.delayedBridge),\\n                address(frame.sequencerInbox),\\n                address(frame.outbox),\\n                address(frame.rollupEventBridge),\\n                challengeFactory,\\n                nodeFactory\\n            ],\\n            [rollupAdminFacet, rollupUserFacet],\\n            [config.sequencerDelayBlocks, config.sequencerDelaySeconds]\\n        );\\n\\n        emit RollupCreated(frame.rollup, address(frame.inbox), address(frame.admin));\\n        return frame.rollup;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rollup/RollupEventBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./Rollup.sol\\\";\\nimport \\\"./facets/IRollupFacets.sol\\\";\\n\\nimport \\\"../bridge/interfaces/IBridge.sol\\\";\\nimport \\\"../bridge/interfaces/IMessageProvider.sol\\\";\\nimport \\\"./INode.sol\\\";\\nimport \\\"../libraries/Cloneable.sol\\\";\\n\\ncontract RollupEventBridge is IMessageProvider, Cloneable {\\n    uint8 internal constant INITIALIZATION_MSG_TYPE = 4;\\n    uint8 internal constant ROLLUP_PROTOCOL_EVENT_TYPE = 8;\\n\\n    uint8 internal constant CREATE_NODE_EVENT = 0;\\n    uint8 internal constant CONFIRM_NODE_EVENT = 1;\\n    uint8 internal constant REJECT_NODE_EVENT = 2;\\n    uint8 internal constant STAKE_CREATED_EVENT = 3;\\n    uint8 internal constant CLAIM_NODE_EVENT = 4;\\n\\n    IBridge bridge;\\n    address rollup;\\n\\n    modifier onlyRollup {\\n        require(msg.sender == rollup, \\\"ONLY_ROLLUP\\\");\\n        _;\\n    }\\n\\n    function initialize(address _bridge, address _rollup) external {\\n        require(rollup == address(0), \\\"ALREADY_INIT\\\");\\n        bridge = IBridge(_bridge);\\n        rollup = _rollup;\\n    }\\n\\n    function rollupInitialized(\\n        uint256 confirmPeriodBlocks,\\n        uint256 arbGasSpeedLimitPerBlock,\\n        uint256 baseStake,\\n        address stakeToken,\\n        address owner,\\n        bytes calldata extraConfig\\n    ) external onlyRollup {\\n        bytes memory initMsg =\\n            abi.encodePacked(\\n                confirmPeriodBlocks,\\n                arbGasSpeedLimitPerBlock / 100, // convert avm gas to arbgas\\n                uint256(0),\\n                baseStake,\\n                uint256(uint160(bytes20(stakeToken))),\\n                uint256(uint160(bytes20(owner))),\\n                extraConfig\\n            );\\n        uint256 num =\\n            bridge.deliverMessageToInbox(INITIALIZATION_MSG_TYPE, msg.sender, keccak256(initMsg));\\n        emit InboxMessageDelivered(num, initMsg);\\n    }\\n\\n    function nodeCreated(\\n        uint256 nodeNum,\\n        uint256 prev,\\n        uint256 deadline,\\n        address asserter\\n    ) external onlyRollup {\\n        deliverToBridge(\\n            abi.encodePacked(\\n                CREATE_NODE_EVENT,\\n                nodeNum,\\n                prev,\\n                block.number,\\n                deadline,\\n                uint256(uint160(bytes20(asserter)))\\n            )\\n        );\\n    }\\n\\n    function nodeConfirmed(uint256 nodeNum) external onlyRollup {\\n        deliverToBridge(abi.encodePacked(CONFIRM_NODE_EVENT, nodeNum));\\n    }\\n\\n    function nodeRejected(uint256 nodeNum) external onlyRollup {\\n        deliverToBridge(abi.encodePacked(REJECT_NODE_EVENT, nodeNum));\\n    }\\n\\n    function stakeCreated(address staker, uint256 nodeNum) external onlyRollup {\\n        deliverToBridge(\\n            abi.encodePacked(\\n                STAKE_CREATED_EVENT,\\n                uint256(uint160(bytes20(staker))),\\n                nodeNum,\\n                block.number\\n            )\\n        );\\n    }\\n\\n    function claimNode(uint256 nodeNum, address staker) external onlyRollup {\\n        Rollup r = Rollup(payable(rollup));\\n        INode node = r.getNode(nodeNum);\\n        require(node.stakers(staker), \\\"NOT_STAKED\\\");\\n        IRollupUser(address(r)).requireUnresolved(nodeNum);\\n\\n        deliverToBridge(\\n            abi.encodePacked(CLAIM_NODE_EVENT, nodeNum, uint256(uint160(bytes20(staker))))\\n        );\\n    }\\n\\n    function deliverToBridge(bytes memory message) private {\\n        emit InboxMessageDelivered(\\n            bridge.deliverMessageToInbox(\\n                ROLLUP_PROTOCOL_EVENT_TYPE,\\n                msg.sender,\\n                keccak256(message)\\n            ),\\n            message\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rollup/RollupLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../challenge/ChallengeLib.sol\\\";\\nimport \\\"./INode.sol\\\";\\n\\nlibrary RollupLib {\\n    struct Config {\\n        bytes32 machineHash;\\n        uint256 confirmPeriodBlocks;\\n        uint256 extraChallengeTimeBlocks;\\n        uint256 arbGasSpeedLimitPerBlock;\\n        uint256 baseStake;\\n        address stakeToken;\\n        address owner;\\n        address sequencer;\\n        uint256 sequencerDelayBlocks;\\n        uint256 sequencerDelaySeconds;\\n        bytes extraConfig;\\n    }\\n\\n    struct ExecutionState {\\n        uint256 gasUsed;\\n        bytes32 machineHash;\\n        uint256 inboxCount;\\n        uint256 sendCount;\\n        uint256 logCount;\\n        bytes32 sendAcc;\\n        bytes32 logAcc;\\n        uint256 proposedBlock;\\n        uint256 inboxMaxCount;\\n    }\\n\\n    function stateHash(ExecutionState memory execState) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    execState.gasUsed,\\n                    execState.machineHash,\\n                    execState.inboxCount,\\n                    execState.sendCount,\\n                    execState.logCount,\\n                    execState.sendAcc,\\n                    execState.logAcc,\\n                    execState.proposedBlock,\\n                    execState.inboxMaxCount\\n                )\\n            );\\n    }\\n\\n    struct Assertion {\\n        ExecutionState beforeState;\\n        ExecutionState afterState;\\n    }\\n\\n    function decodeExecutionState(\\n        bytes32[3] memory bytes32Fields,\\n        uint256[4] memory intFields,\\n        uint256 proposedBlock,\\n        uint256 inboxMaxCount\\n    ) internal pure returns (ExecutionState memory) {\\n        return\\n            ExecutionState(\\n                intFields[0],\\n                bytes32Fields[0],\\n                intFields[1],\\n                intFields[2],\\n                intFields[3],\\n                bytes32Fields[1],\\n                bytes32Fields[2],\\n                proposedBlock,\\n                inboxMaxCount\\n            );\\n    }\\n\\n    function decodeAssertion(\\n        bytes32[3][2] memory bytes32Fields,\\n        uint256[4][2] memory intFields,\\n        uint256 beforeProposedBlock,\\n        uint256 beforeInboxMaxCount,\\n        uint256 inboxMaxCount\\n    ) internal view returns (Assertion memory) {\\n        return\\n            Assertion(\\n                decodeExecutionState(\\n                    bytes32Fields[0],\\n                    intFields[0],\\n                    beforeProposedBlock,\\n                    beforeInboxMaxCount\\n                ),\\n                decodeExecutionState(bytes32Fields[1], intFields[1], block.number, inboxMaxCount)\\n            );\\n    }\\n\\n    function executionStateChallengeHash(ExecutionState memory state)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            ChallengeLib.assertionHash(\\n                state.gasUsed,\\n                ChallengeLib.assertionRestHash(\\n                    state.inboxCount,\\n                    state.machineHash,\\n                    state.sendAcc,\\n                    state.sendCount,\\n                    state.logAcc,\\n                    state.logCount\\n                )\\n            );\\n    }\\n\\n    function executionHash(Assertion memory assertion) internal pure returns (bytes32) {\\n        return\\n            ChallengeLib.bisectionChunkHash(\\n                assertion.beforeState.gasUsed,\\n                assertion.afterState.gasUsed - assertion.beforeState.gasUsed,\\n                RollupLib.executionStateChallengeHash(assertion.beforeState),\\n                RollupLib.executionStateChallengeHash(assertion.afterState)\\n            );\\n    }\\n\\n    function challengeRoot(\\n        Assertion memory assertion,\\n        bytes32 assertionExecHash,\\n        uint256 blockProposed\\n    ) internal pure returns (bytes32) {\\n        return challengeRootHash(assertionExecHash, blockProposed, assertion.afterState.inboxCount);\\n    }\\n\\n    function challengeRootHash(\\n        bytes32 execution,\\n        uint256 proposedTime,\\n        uint256 maxMessageCount\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(execution, proposedTime, maxMessageCount));\\n    }\\n\\n    function confirmHash(Assertion memory assertion) internal pure returns (bytes32) {\\n        return\\n            confirmHash(\\n                assertion.beforeState.sendAcc,\\n                assertion.afterState.sendAcc,\\n                assertion.afterState.logAcc,\\n                assertion.afterState.sendCount,\\n                assertion.afterState.logCount\\n            );\\n    }\\n\\n    function confirmHash(\\n        bytes32 beforeSendAcc,\\n        bytes32 afterSendAcc,\\n        bytes32 afterLogAcc,\\n        uint256 afterSendCount,\\n        uint256 afterLogCount\\n    ) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    beforeSendAcc,\\n                    afterSendAcc,\\n                    afterSendCount,\\n                    afterLogAcc,\\n                    afterLogCount\\n                )\\n            );\\n    }\\n\\n    function feedAccumulator(\\n        bytes memory messageData,\\n        uint256[] memory messageLengths,\\n        bytes32 beforeAcc\\n    ) internal pure returns (bytes32) {\\n        uint256 offset = 0;\\n        uint256 messageCount = messageLengths.length;\\n        uint256 dataLength = messageData.length;\\n        bytes32 messageAcc = beforeAcc;\\n        for (uint256 i = 0; i < messageCount; i++) {\\n            uint256 messageLength = messageLengths[i];\\n            require(offset + messageLength <= dataLength, \\\"DATA_OVERRUN\\\");\\n            bytes32 messageHash;\\n            assembly {\\n                messageHash := keccak256(add(messageData, add(offset, 32)), messageLength)\\n            }\\n            messageAcc = keccak256(abi.encodePacked(messageAcc, messageHash));\\n            offset += messageLength;\\n        }\\n        require(offset == dataLength, \\\"DATA_LENGTH\\\");\\n        return messageAcc;\\n    }\\n\\n    function nodeHash(\\n        bool hasSibling,\\n        bytes32 lastHash,\\n        bytes32 assertionExecHash,\\n        bytes32 inboxAcc\\n    ) internal pure returns (bytes32) {\\n        uint8 hasSiblingInt = hasSibling ? 1 : 0;\\n        return keccak256(abi.encodePacked(hasSiblingInt, lastHash, assertionExecHash, inboxAcc));\\n    }\\n\\n    function nodeAccumulator(bytes32 prevAcc, bytes32 newNodeHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(prevAcc, newNodeHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rollup/facets/IRollupFacets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../INode.sol\\\";\\nimport \\\"../../bridge/interfaces/IOutbox.sol\\\";\\n\\ninterface IRollupUser {\\n    function initialize(address _stakeToken) external;\\n\\n    function completeChallenge(address winningStaker, address losingStaker) external;\\n\\n    function returnOldDeposit(address stakerAddress) external;\\n\\n    function requireUnresolved(uint256 nodeNum) external view;\\n\\n    function requireUnresolvedExists() external view;\\n\\n    function countStakedZombies(INode node) external view returns (uint256);\\n}\\n\\ninterface IRollupAdmin {\\n    /**\\n     * @notice Add a contract authorized to put messages into this rollup's inbox\\n     * @param _outbox Outbox contract to add\\n     */\\n    function setOutbox(IOutbox _outbox) external;\\n\\n    /**\\n     * @notice Disable an old outbox from interacting with the bridge\\n     * @param _outbox Outbox contract to remove\\n     */\\n    function removeOldOutbox(address _outbox) external;\\n\\n    /**\\n     * @notice Enable or disable an inbox contract\\n     * @param _inbox Inbox contract to add or remove\\n     * @param _enabled New status of inbox\\n     */\\n    function setInbox(address _inbox, bool _enabled) external;\\n\\n    /**\\n     * @notice Pause interaction with the rollup contract\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @notice Resume interaction with the rollup contract\\n     */\\n    function resume() external;\\n\\n    /**\\n     * @notice Set the addresses of rollup logic facets called\\n     * @param newAdminFacet address of logic that owner of rollup calls\\n     * @param newUserFacet ddress of logic that user of rollup calls\\n     */\\n    function setFacets(address newAdminFacet, address newUserFacet) external;\\n\\n    /**\\n     * @notice Set the addresses of the validator whitelist\\n     * @dev It is expected that both arrays are same length, and validator at\\n     * position i corresponds to the value at position i\\n     * @param _validator addresses to set in the whitelist\\n     * @param _val value to set in the whitelist for corresponding address\\n     */\\n    function setValidator(address[] memory _validator, bool[] memory _val) external;\\n\\n    /**\\n     * @notice Set a new owner address for the rollup\\n     * @param newOwner address of new rollup owner\\n     */\\n    function setOwner(address newOwner) external;\\n\\n    /**\\n     * @notice Set minimum assertion period for the rollup\\n     * @param newPeriod new minimum period for assertions\\n     */\\n    function setMinimumAssertionPeriod(uint256 newPeriod) external;\\n\\n    /**\\n     * @notice Set number of blocks until a node is considered confirmed\\n     * @param newConfirmPeriod new number of blocks until a node is confirmed\\n     */\\n    function setConfirmPeriodBlocks(uint256 newConfirmPeriod) external;\\n\\n    /**\\n     * @notice Set number of extra blocks after a challenge\\n     * @param newExtraTimeBlocks new number of blocks\\n     */\\n    function setExtraChallengeTimeBlocks(uint256 newExtraTimeBlocks) external;\\n\\n    /**\\n     * @notice Set speed limit per block\\n     * @param newArbGasSpeedLimitPerBlock maximum arbgas to be used per block\\n     */\\n    function setArbGasSpeedLimitPerBlock(uint256 newArbGasSpeedLimitPerBlock) external;\\n\\n    /**\\n     * @notice Set base stake required for an assertion\\n     * @param newBaseStake maximum arbgas to be used per block\\n     */\\n    function setBaseStake(uint256 newBaseStake) external;\\n\\n    /**\\n     * @notice Set the token used for stake, where address(0) == eth\\n     * @dev Before changing the base stake token, you might need to change the\\n     * implementation of the Rollup User facet!\\n     * @param newStakeToken address of token used for staking\\n     */\\n    function setStakeToken(address newStakeToken) external;\\n\\n    /**\\n     * @notice Set max delay in blocks for sequencer inbox\\n     * @param newSequencerInboxMaxDelayBlocks max number of blocks\\n     */\\n    function setSequencerInboxMaxDelayBlocks(uint256 newSequencerInboxMaxDelayBlocks) external;\\n\\n    /**\\n     * @notice Set max delay in seconds for sequencer inbox\\n     * @param newSequencerInboxMaxDelaySeconds max number of seconds\\n     */\\n    function setSequencerInboxMaxDelaySeconds(uint256 newSequencerInboxMaxDelaySeconds) external;\\n\\n    /**\\n     * @notice Set execution bisection degree\\n     * @param newChallengeExecutionBisectionDegree execution bisection degree\\n     */\\n    function setChallengeExecutionBisectionDegree(uint256 newChallengeExecutionBisectionDegree)\\n        external;\\n\\n    /**\\n     * @notice Updates a whitelist address for its consumers\\n     * @dev setting the newWhitelist to address(0) disables it for consumers\\n     * @param whitelist old whitelist to be deprecated\\n     * @param newWhitelist new whitelist to be used\\n     * @param targets whitelist consumers to be triggered\\n     */\\n    function updateWhitelistConsumers(\\n        address whitelist,\\n        address newWhitelist,\\n        address[] memory targets\\n    ) external;\\n\\n    /**\\n     * @notice Updates a whitelist's entries\\n     * @dev user at position i will be assigned value i\\n     * @param whitelist whitelist to be updated\\n     * @param user users to be updated in the whitelist\\n     * @param val if user is or not allowed in the whitelist\\n     */\\n    function setWhitelistEntries(\\n        address whitelist,\\n        address[] memory user,\\n        bool[] memory val\\n    ) external;\\n\\n    /**\\n     * @notice Updates a sequencer address at the sequencer inbox\\n     * @param newSequencer new sequencer address to be used\\n     */\\n    function setSequencer(address newSequencer) external;\\n\\n    /**\\n     * @notice Upgrades the implementation of a beacon controlled by the rollup\\n     * @param beacon address of beacon to be upgraded\\n     * @param newImplementation new address of implementation\\n     */\\n    function upgradeBeacon(address beacon, address newImplementation) external;\\n}\\n\"\r\n    },\r\n    \"contracts/rollup/facets/RollupAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../Rollup.sol\\\";\\nimport \\\"./IRollupFacets.sol\\\";\\nimport \\\"../../bridge/interfaces/IOutbox.sol\\\";\\nimport \\\"../../bridge/interfaces/ISequencerInbox.sol\\\";\\nimport \\\"../../libraries/Whitelist.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/proxy/UpgradeableBeacon.sol\\\";\\n\\ncontract RollupAdminFacet is RollupBase, IRollupAdmin {\\n    /**\\n     * Functions are only to reach this facet if the caller is the owner\\n     * so there is no need for a redundant onlyOwner check\\n     */\\n\\n    /**\\n     * @notice Add a contract authorized to put messages into this rollup's inbox\\n     * @param _outbox Outbox contract to add\\n     */\\n    function setOutbox(IOutbox _outbox) external override {\\n        outbox = _outbox;\\n        delayedBridge.setOutbox(address(_outbox), true);\\n        emit OwnerFunctionCalled(0);\\n    }\\n\\n    /**\\n     * @notice Disable an old outbox from interacting with the bridge\\n     * @param _outbox Outbox contract to remove\\n     */\\n    function removeOldOutbox(address _outbox) external override {\\n        require(_outbox != address(outbox), \\\"CUR_OUTBOX\\\");\\n        delayedBridge.setOutbox(_outbox, false);\\n        emit OwnerFunctionCalled(1);\\n    }\\n\\n    /**\\n     * @notice Enable or disable an inbox contract\\n     * @param _inbox Inbox contract to add or remove\\n     * @param _enabled New status of inbox\\n     */\\n    function setInbox(address _inbox, bool _enabled) external override {\\n        delayedBridge.setInbox(address(_inbox), _enabled);\\n        emit OwnerFunctionCalled(2);\\n    }\\n\\n    /**\\n     * @notice Pause interaction with the rollup contract\\n     */\\n    function pause() external override {\\n        _pause();\\n        emit OwnerFunctionCalled(3);\\n    }\\n\\n    /**\\n     * @notice Resume interaction with the rollup contract\\n     */\\n    function resume() external override {\\n        _unpause();\\n        emit OwnerFunctionCalled(4);\\n    }\\n\\n    /**\\n     * @notice Set the addresses of rollup logic facets called\\n     * @param newAdminFacet address of logic that owner of rollup calls\\n     * @param newUserFacet ddress of logic that user of rollup calls\\n     */\\n    function setFacets(address newAdminFacet, address newUserFacet) external override {\\n        facets[0] = newAdminFacet;\\n        facets[1] = newUserFacet;\\n        emit OwnerFunctionCalled(5);\\n    }\\n\\n    /**\\n     * @notice Set the addresses of the validator whitelist\\n     * @dev It is expected that both arrays are same length, and validator at\\n     * position i corresponds to the value at position i\\n     * @param _validator addresses to set in the whitelist\\n     * @param _val value to set in the whitelist for corresponding address\\n     */\\n    function setValidator(address[] memory _validator, bool[] memory _val) external override {\\n        require(_validator.length == _val.length, \\\"WRONG_LENGTH\\\");\\n\\n        for (uint256 i = 0; i < _validator.length; i++) {\\n            isValidator[_validator[i]] = _val[i];\\n        }\\n        emit OwnerFunctionCalled(6);\\n    }\\n\\n    /**\\n     * @notice Set a new owner address for the rollup\\n     * @param newOwner address of new rollup owner\\n     */\\n    function setOwner(address newOwner) external override {\\n        owner = newOwner;\\n        emit OwnerFunctionCalled(7);\\n    }\\n\\n    /**\\n     * @notice Set minimum assertion period for the rollup\\n     * @param newPeriod new minimum period for assertions\\n     */\\n    function setMinimumAssertionPeriod(uint256 newPeriod) external override {\\n        minimumAssertionPeriod = newPeriod;\\n        emit OwnerFunctionCalled(8);\\n    }\\n\\n    /**\\n     * @notice Set number of blocks until a node is considered confirmed\\n     * @param newConfirmPeriod new number of blocks\\n     */\\n    function setConfirmPeriodBlocks(uint256 newConfirmPeriod) external override {\\n        confirmPeriodBlocks = newConfirmPeriod;\\n        emit OwnerFunctionCalled(9);\\n    }\\n\\n    /**\\n     * @notice Set number of extra blocks after a challenge\\n     * @param newExtraTimeBlocks new number of blocks\\n     */\\n    function setExtraChallengeTimeBlocks(uint256 newExtraTimeBlocks) external override {\\n        extraChallengeTimeBlocks = newExtraTimeBlocks;\\n        emit OwnerFunctionCalled(10);\\n    }\\n\\n    /**\\n     * @notice Set speed limit per block\\n     * @param newArbGasSpeedLimitPerBlock maximum arbgas to be used per block\\n     */\\n    function setArbGasSpeedLimitPerBlock(uint256 newArbGasSpeedLimitPerBlock) external override {\\n        arbGasSpeedLimitPerBlock = newArbGasSpeedLimitPerBlock;\\n        emit OwnerFunctionCalled(11);\\n    }\\n\\n    /**\\n     * @notice Set base stake required for an assertion\\n     * @param newBaseStake maximum arbgas to be used per block\\n     */\\n    function setBaseStake(uint256 newBaseStake) external override {\\n        baseStake = newBaseStake;\\n        emit OwnerFunctionCalled(12);\\n    }\\n\\n    /**\\n     * @notice Set the token used for stake, where address(0) == eth\\n     * @dev Before changing the base stake token, you might need to change the\\n     * implementation of the Rollup User facet!\\n     * @param newStakeToken address of token used for staking\\n     */\\n    function setStakeToken(address newStakeToken) external override {\\n        stakeToken = newStakeToken;\\n        emit OwnerFunctionCalled(13);\\n    }\\n\\n    /**\\n     * @notice Set max delay in blocks for sequencer inbox\\n     * @param newSequencerInboxMaxDelayBlocks max number of blocks\\n     */\\n    function setSequencerInboxMaxDelayBlocks(uint256 newSequencerInboxMaxDelayBlocks)\\n        external\\n        override\\n    {\\n        sequencerInboxMaxDelayBlocks = newSequencerInboxMaxDelayBlocks;\\n        emit OwnerFunctionCalled(14);\\n    }\\n\\n    /**\\n     * @notice Set max delay in seconds for sequencer inbox\\n     * @param newSequencerInboxMaxDelaySeconds max number of seconds\\n     */\\n    function setSequencerInboxMaxDelaySeconds(uint256 newSequencerInboxMaxDelaySeconds)\\n        external\\n        override\\n    {\\n        sequencerInboxMaxDelaySeconds = newSequencerInboxMaxDelaySeconds;\\n        emit OwnerFunctionCalled(15);\\n    }\\n\\n    /**\\n     * @notice Set execution bisection degree\\n     * @param newChallengeExecutionBisectionDegree execution bisection degree\\n     */\\n    function setChallengeExecutionBisectionDegree(uint256 newChallengeExecutionBisectionDegree)\\n        external\\n        override\\n    {\\n        challengeExecutionBisectionDegree = newChallengeExecutionBisectionDegree;\\n        emit OwnerFunctionCalled(16);\\n    }\\n\\n    /**\\n     * @notice Updates a whitelist address for its consumers\\n     * @dev setting the newWhitelist to address(0) disables it for consumers\\n     * @param whitelist old whitelist to be deprecated\\n     * @param newWhitelist new whitelist to be used\\n     * @param targets whitelist consumers to be triggered\\n     */\\n    function updateWhitelistConsumers(\\n        address whitelist,\\n        address newWhitelist,\\n        address[] memory targets\\n    ) external override {\\n        Whitelist(whitelist).triggerConsumers(newWhitelist, targets);\\n        emit OwnerFunctionCalled(17);\\n    }\\n\\n    /**\\n     * @notice Updates a whitelist's entries\\n     * @dev user at position i will be assigned value i\\n     * @param whitelist whitelist to be updated\\n     * @param user users to be updated in the whitelist\\n     * @param val if user is or not allowed in the whitelist\\n     */\\n    function setWhitelistEntries(\\n        address whitelist,\\n        address[] memory user,\\n        bool[] memory val\\n    ) external override {\\n        require(user.length == val.length, \\\"INVALID_INPUT\\\");\\n        Whitelist(whitelist).setWhitelist(user, val);\\n        emit OwnerFunctionCalled(18);\\n    }\\n\\n    /**\\n     * @notice Updates a sequencer address at the sequencer inbox\\n     * @param newSequencer new sequencer address to be used\\n     */\\n    function setSequencer(address newSequencer) external override {\\n        ISequencerInbox(sequencerBridge).setSequencer(newSequencer);\\n        emit OwnerFunctionCalled(19);\\n    }\\n\\n    /**\\n     * @notice Upgrades the implementation of a beacon controlled by the rollup\\n     * @param beacon address of beacon to be upgraded\\n     * @param newImplementation new address of implementation\\n     */\\n    function upgradeBeacon(address beacon, address newImplementation) external override {\\n        UpgradeableBeacon(beacon).upgradeTo(newImplementation);\\n        emit OwnerFunctionCalled(20);\\n    }\\n\\n    /*\\n    function forceResolveChallenge(address[] memory stackerA, address[] memory stackerB) external override whenPaused {\\n        require(stackerA.length == stackerB.length, \\\"WRONG_LENGTH\\\");\\n        for (uint256 i = 0; i < stackerA.length; i++) {\\n            address chall = inChallenge(stackerA[i], stackerB[i]);\\n\\n            require(address(0) != chall, \\\"NOT_IN_CHALL\\\");\\n            clearChallenge(stackerA[i]);\\n            clearChallenge(stackerB[i]);\\n\\n            IChallenge(chall).clearChallenge();\\n        }\\n    }\\n\\n    function forceRefundStaker(address[] memory stacker) external override whenPaused {\\n        for (uint256 i = 0; i < stacker.length; i++) {\\n            withdrawStaker(stacker[i]);\\n        }\\n    }\\n\\n    function forceCreateNode(\\n        bytes32 expectedNodeHash,\\n        bytes32[3][2] calldata assertionBytes32Fields,\\n        uint256[4][2] calldata assertionIntFields,\\n        uint256 beforeProposedBlock,\\n        uint256 beforeInboxMaxCount,\\n        uint256 prevNode,\\n        uint256 deadlineBlock,\\n        uint256 sequencerBatchEnd,\\n        bytes32 sequencerBatchAcc\\n    ) external override whenPaused {\\n        require(prevNode == latestConfirmed(), \\\"ONLY_LATEST_CONFIRMED\\\");\\n\\n        RollupLib.Assertion memory assertion =\\n                RollupLib.decodeAssertion(\\n                    assertionBytes32Fields,\\n                    assertionIntFields,\\n                    beforeProposedBlock,\\n                    beforeInboxMaxCount,\\n                    sequencerBridge.messageCount()\\n                );\\n\\n        bytes32 nodeHash =\\n            _newNode(\\n                assertion,\\n                deadlineBlock,\\n                sequencerBatchEnd,\\n                sequencerBatchAcc,\\n                prevNode,\\n                getNodeHash(prevNode),\\n                false\\n            );\\n        // TODO: should we add a stake?\\n        \\n        require(expectedNodeHash == nodeHash, \\\"NOT_EXPECTED_HASH\\\");\\n    }\\n\\n    function forceConfirmNode(\\n        bytes calldata sendsData,\\n        uint256[] calldata sendLengths\\n    ) external override whenPaused {\\n        outbox.processOutgoingMessages(sendsData, sendLengths);\\n\\n        confirmLatestNode();\\n\\n        rollupEventBridge.nodeConfirmed(latestConfirmed());\\n\\n        // emit NodeConfirmed(\\n        //     firstUnresolved,\\n        //     afterSendAcc,\\n        //     afterSendCount,\\n        //     afterLogAcc,\\n        //     afterLogCount\\n        // );\\n    }\\n    */\\n}\\n\"\r\n    },\r\n    \"contracts/rollup/facets/RollupUser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../Rollup.sol\\\";\\nimport \\\"./IRollupFacets.sol\\\";\\n\\nabstract contract AbsRollupUserFacet is RollupBase, IRollupUser {\\n    function initialize(address _stakeToken) public virtual override;\\n\\n    // TODO: Configure this value based on the cost of sends\\n    uint8 internal constant MAX_SEND_COUNT = 100;\\n\\n    modifier onlyValidator {\\n        require(isValidator[msg.sender], \\\"NOT_VALIDATOR\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Reject the next unresolved node\\n     * @param stakerAddress Example staker staked on sibling\\n     */\\n    function rejectNextNode(address stakerAddress) external onlyValidator whenNotPaused {\\n        requireUnresolvedExists();\\n        uint256 latest = latestConfirmed();\\n        uint256 firstUnresolved = firstUnresolvedNode();\\n        INode node = getNode(firstUnresolved);\\n        if (node.prev() == latest) {\\n            // Confirm that the example staker is staked on a sibling node\\n            require(isStaked(stakerAddress), \\\"NOT_STAKED\\\");\\n            requireUnresolved(latestStakedNode(stakerAddress));\\n            require(!node.stakers(stakerAddress), \\\"STAKED_ON_TARGET\\\");\\n\\n            // Verify the block's deadline has passed\\n            node.requirePastDeadline();\\n\\n            getNode(latest).requirePastChildConfirmDeadline();\\n\\n            removeOldZombies(0);\\n\\n            // Verify that no staker is staked on this node\\n            require(node.stakerCount() == countStakedZombies(node), \\\"HAS_STAKERS\\\");\\n        }\\n        rejectNextNode();\\n        rollupEventBridge.nodeRejected(firstUnresolved);\\n\\n        emit NodeRejected(firstUnresolved);\\n    }\\n\\n    /**\\n     * @notice Confirm the next unresolved node\\n     * @param beforeSendAcc Accumulator of the AVM sends from the beginning of time up to the end of the previous confirmed node\\n     * @param sendsData Concatenated data of the sends included in the confirmed node\\n     * @param sendLengths Lengths of the included sends\\n     * @param afterSendCount Total number of AVM sends emitted from the beginning of time after this node is confirmed\\n     * @param afterLogAcc Accumulator of the AVM logs from the beginning of time up to the end of this node\\n     * @param afterLogCount Total number of AVM logs emitted from the beginning of time after this node is confirmed\\n     */\\n    function confirmNextNode(\\n        bytes32 beforeSendAcc,\\n        bytes calldata sendsData,\\n        uint256[] calldata sendLengths,\\n        uint256 afterSendCount,\\n        bytes32 afterLogAcc,\\n        uint256 afterLogCount\\n    ) external onlyValidator whenNotPaused {\\n        requireUnresolvedExists();\\n\\n        // There is at least one non-zombie staker\\n        require(stakerCount() > 0, \\\"NO_STAKERS\\\");\\n\\n        uint256 firstUnresolved = firstUnresolvedNode();\\n        INode node = getNode(firstUnresolved);\\n\\n        // Verify the block's deadline has passed\\n        node.requirePastDeadline();\\n\\n        // Check that prev is latest confirmed\\n        require(node.prev() == latestConfirmed(), \\\"INVALID_PREV\\\");\\n\\n        getNode(latestConfirmed()).requirePastChildConfirmDeadline();\\n\\n        removeOldZombies(0);\\n\\n        // All non-zombie stakers are staked on this node\\n        require(\\n            node.stakerCount() == stakerCount().add(countStakedZombies(node)),\\n            \\\"NOT_ALL_STAKED\\\"\\n        );\\n\\n        bytes32 afterSendAcc = RollupLib.feedAccumulator(sendsData, sendLengths, beforeSendAcc);\\n        require(\\n            node.confirmData() ==\\n                RollupLib.confirmHash(\\n                    beforeSendAcc,\\n                    afterSendAcc,\\n                    afterLogAcc,\\n                    afterSendCount,\\n                    afterLogCount\\n                ),\\n            \\\"CONFIRM_DATA\\\"\\n        );\\n\\n        outbox.processOutgoingMessages(sendsData, sendLengths);\\n\\n        confirmNextNode();\\n\\n        rollupEventBridge.nodeConfirmed(firstUnresolved);\\n\\n        emit NodeConfirmed(\\n            firstUnresolved,\\n            afterSendAcc,\\n            afterSendCount,\\n            afterLogAcc,\\n            afterLogCount\\n        );\\n    }\\n\\n    /**\\n     * @notice Create a new stake\\n     * @param depositAmount The amount of either eth or tokens staked\\n     */\\n    function _newStake(uint256 depositAmount) internal onlyValidator whenNotPaused {\\n        // Verify that sender is not already a staker\\n        require(!isStaked(msg.sender), \\\"ALREADY_STAKED\\\");\\n        require(!isZombie(msg.sender), \\\"STAKER_IS_ZOMBIE\\\");\\n        require(depositAmount >= currentRequiredStake(), \\\"NOT_ENOUGH_STAKE\\\");\\n\\n        createNewStake(msg.sender, depositAmount);\\n\\n        rollupEventBridge.stakeCreated(msg.sender, latestConfirmed());\\n    }\\n\\n    /**\\n     * @notice Move stake onto an existing node\\n     * @param nodeNum Inbox of the node to move stake to. This must by a child of the node the staker is currently staked on\\n     * @param nodeHash Node hash of nodeNum (protects against reorgs)\\n     */\\n    function stakeOnExistingNode(uint256 nodeNum, bytes32 nodeHash)\\n        external\\n        onlyValidator\\n        whenNotPaused\\n    {\\n        require(isStaked(msg.sender), \\\"NOT_STAKED\\\");\\n\\n        require(getNodeHash(nodeNum) == nodeHash, \\\"NODE_REORG\\\");\\n        require(nodeNum >= firstUnresolvedNode() && nodeNum <= latestNodeCreated());\\n        INode node = getNode(nodeNum);\\n        require(latestStakedNode(msg.sender) == node.prev(), \\\"NOT_STAKED_PREV\\\");\\n        stakeOnNode(msg.sender, nodeNum, confirmPeriodBlocks);\\n    }\\n\\n    struct StakeOnNewNodeFrame {\\n        uint256 sequencerBatchEnd;\\n        bytes32 sequencerBatchAcc;\\n        uint256 currentInboxSize;\\n        INode node;\\n        bytes32 executionHash;\\n        INode prevNode;\\n    }\\n\\n    /**\\n     * @notice Move stake onto a new node\\n     * @param expectedNodeHash The hash of the node being created (protects against reorgs)\\n     * @param assertionBytes32Fields Assertion data for creating\\n     * @param assertionIntFields Assertion data for creating\\n     */\\n    function stakeOnNewNode(\\n        bytes32 expectedNodeHash,\\n        bytes32[3][2] calldata assertionBytes32Fields,\\n        uint256[4][2] calldata assertionIntFields,\\n        uint256 beforeProposedBlock,\\n        uint256 beforeInboxMaxCount,\\n        bytes calldata sequencerBatchProof\\n    ) external onlyValidator whenNotPaused {\\n        require(isStaked(msg.sender), \\\"NOT_STAKED\\\");\\n\\n        uint256 prevNodeNum = latestStakedNode(msg.sender);\\n        StakeOnNewNodeFrame memory frame;\\n        {\\n            INode prevNode = getNode(prevNodeNum);\\n            uint256 currentInboxSize = sequencerBridge.messageCount();\\n\\n            RollupLib.Assertion memory assertion =\\n                RollupLib.decodeAssertion(\\n                    assertionBytes32Fields,\\n                    assertionIntFields,\\n                    beforeProposedBlock,\\n                    beforeInboxMaxCount,\\n                    currentInboxSize\\n                );\\n\\n            uint256 sequencerBatchEnd;\\n            bytes32 sequencerBatchAcc;\\n            uint256 deadlineBlock;\\n            {\\n                // frame.executionHash = RollupLib.executionHash(assertion);\\n                // Make sure the previous state is correct against the node being built on\\n                require(\\n                    RollupLib.stateHash(assertion.beforeState) == prevNode.stateHash(),\\n                    \\\"PREV_STATE_HASH\\\"\\n                );\\n\\n                (sequencerBatchEnd, sequencerBatchAcc) = sequencerBridge\\n                    .proveBatchContainsSequenceNumber(\\n                    sequencerBatchProof,\\n                    assertion.afterState.inboxCount\\n                );\\n\\n                uint256 timeSinceLastNode = block.number.sub(assertion.beforeState.proposedBlock);\\n                // Verify that assertion meets the minimum Delta time requirement\\n                require(timeSinceLastNode >= minimumAssertionPeriod, \\\"TIME_DELTA\\\");\\n\\n                uint256 gasUsed = assertion.afterState.gasUsed.sub(assertion.beforeState.gasUsed);\\n                // Minimum size requirements: each assertion must satisfy either\\n                require(\\n                    // Consumes at least all inbox messages put into L1 inbox before your prev node’s L1 blocknum\\n                    assertion.afterState.inboxCount >= assertion.beforeState.inboxMaxCount ||\\n                        // Consumes ArbGas >=100% of speed limit for time since your prev node (based on difference in L1 blocknum)\\n                        gasUsed >= timeSinceLastNode.mul(arbGasSpeedLimitPerBlock) ||\\n                        assertion.afterState.sendCount.sub(assertion.beforeState.sendCount) ==\\n                        MAX_SEND_COUNT,\\n                    \\\"TOO_SMALL\\\"\\n                );\\n\\n                // Don't allow an assertion to use above a maximum amount of gas\\n                require(\\n                    gasUsed <= timeSinceLastNode.mul(arbGasSpeedLimitPerBlock).mul(4),\\n                    \\\"TOO_LARGE\\\"\\n                );\\n\\n                {\\n                    // Set deadline rounding up to the nearest block\\n                    uint256 checkTime =\\n                        gasUsed.add(arbGasSpeedLimitPerBlock.sub(1)).div(arbGasSpeedLimitPerBlock);\\n                    deadlineBlock = max(\\n                        block.number.add(confirmPeriodBlocks),\\n                        prevNode.deadlineBlock()\\n                    )\\n                        .add(checkTime);\\n                    uint256 olderSibling = prevNode.latestChildNumber();\\n                    if (olderSibling != 0) {\\n                        deadlineBlock = max(deadlineBlock, getNode(olderSibling).deadlineBlock());\\n                    }\\n                }\\n                // Ensure that the assertion doesn't read past the end of the current inbox\\n                require(assertion.afterState.inboxCount <= currentInboxSize, \\\"INBOX_PAST_END\\\");\\n            }\\n\\n            bytes32 nodeHash;\\n            {\\n                bytes32 lastHash;\\n                bool hasSibling = prevNode.latestChildNumber() > 0;\\n                if (hasSibling) {\\n                    lastHash = getNodeHash(prevNode.latestChildNumber());\\n                } else {\\n                    lastHash = getNodeHash(prevNodeNum);\\n                }\\n\\n                (nodeHash, frame) = createNewNode(\\n                    assertion,\\n                    deadlineBlock,\\n                    sequencerBatchEnd,\\n                    sequencerBatchAcc,\\n                    prevNodeNum,\\n                    lastHash,\\n                    hasSibling\\n                );\\n            }\\n            require(nodeHash == expectedNodeHash, \\\"UNEXPECTED_NODE_HASH\\\");\\n            stakeOnNode(msg.sender, latestNodeCreated(), confirmPeriodBlocks);\\n        }\\n\\n        emit NodeCreated(\\n            latestNodeCreated(),\\n            getNodeHash(prevNodeNum),\\n            expectedNodeHash,\\n            frame.executionHash,\\n            frame.currentInboxSize,\\n            frame.sequencerBatchEnd,\\n            frame.sequencerBatchAcc,\\n            assertionBytes32Fields,\\n            assertionIntFields\\n        );\\n    }\\n\\n    function createNewNode(\\n        RollupLib.Assertion memory assertion,\\n        uint256 deadlineBlock,\\n        uint256 sequencerBatchEnd,\\n        bytes32 sequencerBatchAcc,\\n        uint256 prevNode,\\n        bytes32 prevHash,\\n        bool hasSibling\\n    ) internal returns (bytes32, StakeOnNewNodeFrame memory) {\\n        StakeOnNewNodeFrame memory frame;\\n        frame.currentInboxSize = sequencerBridge.messageCount();\\n        frame.prevNode = getNode(prevNode);\\n        {\\n            uint256 nodeNum = latestNodeCreated() + 1;\\n            frame.executionHash = RollupLib.executionHash(assertion);\\n\\n            frame.sequencerBatchEnd = sequencerBatchEnd;\\n            frame.sequencerBatchAcc = sequencerBatchAcc;\\n\\n            rollupEventBridge.nodeCreated(nodeNum, prevNode, deadlineBlock, msg.sender);\\n\\n            frame.node = INode(\\n                nodeFactory.createNode(\\n                    RollupLib.stateHash(assertion.afterState),\\n                    RollupLib.challengeRoot(assertion, frame.executionHash, block.number),\\n                    RollupLib.confirmHash(assertion),\\n                    prevNode,\\n                    deadlineBlock\\n                )\\n            );\\n        }\\n\\n        bytes32 nodeHash =\\n            RollupLib.nodeHash(hasSibling, prevHash, frame.executionHash, frame.sequencerBatchAcc);\\n\\n        nodeCreated(frame.node, nodeHash);\\n        frame.prevNode.childCreated(latestNodeCreated());\\n\\n        return (nodeHash, frame);\\n    }\\n\\n    /**\\n     * @notice Refund a staker that is currently staked on or before the latest confirmed node\\n     * @dev Since a staker is initially placed in the latest confirmed node, if they don't move it\\n     * a griefer can remove their stake. It is recomended to batch together the txs to place a stake\\n     * and move it to the desired node.\\n     * @param stakerAddress Address of the staker whose stake is refunded\\n     */\\n    function returnOldDeposit(address stakerAddress) external override onlyValidator whenNotPaused {\\n        require(latestStakedNode(stakerAddress) <= latestConfirmed(), \\\"TOO_RECENT\\\");\\n        requireUnchallengedStaker(stakerAddress);\\n        withdrawStaker(stakerAddress);\\n    }\\n\\n    /**\\n     * @notice Increase the amount staked for the given staker\\n     * @param stakerAddress Address of the staker whose stake is increased\\n     * @param depositAmount The amount of either eth or tokens deposited\\n     */\\n    function _addToDeposit(address stakerAddress, uint256 depositAmount)\\n        internal\\n        onlyValidator\\n        whenNotPaused\\n    {\\n        requireUnchallengedStaker(stakerAddress);\\n        increaseStakeBy(stakerAddress, depositAmount);\\n    }\\n\\n    /**\\n     * @notice Reduce the amount staked for the sender\\n     * @param target Target amount of stake for the staker. If this is below the current minimum, it will be set to minimum instead\\n     */\\n    function reduceDeposit(uint256 target) external onlyValidator whenNotPaused {\\n        requireUnchallengedStaker(msg.sender);\\n        uint256 currentRequired = currentRequiredStake();\\n        if (target < currentRequired) {\\n            target = currentRequired;\\n        }\\n        reduceStakeTo(msg.sender, target);\\n    }\\n\\n    /**\\n     * @notice Start a challenge between the given stakers over the node created by the first staker assuming that the two are staked on conflicting nodes\\n     * @param stakers Stakers engaged in the challenge. The first staker should be staked on the first node\\n     * @param nodeNums Nodes of the stakers engaged in the challenge. The first node should be the earliest and is the one challenged\\n     * @param executionHashes Challenge related data for the two nodes\\n     * @param proposedTimes Times that the two nodes were proposed\\n     * @param maxMessageCounts Total number of messages consumed by the two nodes\\n     */\\n    function createChallenge(\\n        address payable[2] calldata stakers,\\n        uint256[2] calldata nodeNums,\\n        bytes32[2] calldata executionHashes,\\n        uint256[2] calldata proposedTimes,\\n        uint256[2] calldata maxMessageCounts\\n    ) external onlyValidator whenNotPaused {\\n        require(nodeNums[0] < nodeNums[1], \\\"WRONG_ORDER\\\");\\n        require(nodeNums[1] <= latestNodeCreated(), \\\"NOT_PROPOSED\\\");\\n        require(latestConfirmed() < nodeNums[0], \\\"ALREADY_CONFIRMED\\\");\\n\\n        INode node1 = getNode(nodeNums[0]);\\n        INode node2 = getNode(nodeNums[1]);\\n\\n        require(node1.prev() == node2.prev(), \\\"DIFF_PREV\\\");\\n\\n        requireUnchallengedStaker(stakers[0]);\\n        requireUnchallengedStaker(stakers[1]);\\n\\n        require(node1.stakers(stakers[0]), \\\"STAKER1_NOT_STAKED\\\");\\n        require(node2.stakers(stakers[1]), \\\"STAKER2_NOT_STAKED\\\");\\n\\n        require(\\n            node1.challengeHash() ==\\n                RollupLib.challengeRootHash(\\n                    executionHashes[0],\\n                    proposedTimes[0],\\n                    maxMessageCounts[0]\\n                ),\\n            \\\"CHAL_HASH1\\\"\\n        );\\n\\n        require(\\n            node2.challengeHash() ==\\n                RollupLib.challengeRootHash(\\n                    executionHashes[1],\\n                    proposedTimes[1],\\n                    maxMessageCounts[1]\\n                ),\\n            \\\"CHAL_HASH2\\\"\\n        );\\n\\n        uint256 commonEndTime =\\n            node1.deadlineBlock().sub(proposedTimes[0]).add(extraChallengeTimeBlocks).add(\\n                getNode(node1.prev()).firstChildBlock()\\n            );\\n        if (commonEndTime < proposedTimes[1]) {\\n            // The second node was created too late to be challenged.\\n            completeChallengeImpl(stakers[0], stakers[1]);\\n            return;\\n        }\\n        // Start a challenge between staker1 and staker2. Staker1 will defend the correctness of node1, and staker2 will challenge it.\\n        address challengeAddress =\\n            challengeFactory.createChallenge(\\n                address(this),\\n                executionHashes[0],\\n                maxMessageCounts[0],\\n                stakers[0],\\n                stakers[1],\\n                commonEndTime.sub(proposedTimes[0]),\\n                commonEndTime.sub(proposedTimes[1]),\\n                sequencerBridge,\\n                delayedBridge\\n            );\\n\\n        challengeStarted(stakers[0], stakers[1], challengeAddress);\\n\\n        emit RollupChallengeStarted(challengeAddress, stakers[0], stakers[1], nodeNums[0]);\\n    }\\n\\n    /**\\n     * @notice Inform the rollup that the challenge between the given stakers is completed\\n     * @dev completeChallenge isn't pausable since in flight challenges should be allowed to complete or else they could be forced to timeout\\n     * @param winningStaker Address of the winning staker\\n     * @param losingStaker Address of the losing staker\\n     */\\n    function completeChallenge(address winningStaker, address losingStaker)\\n        external\\n        override\\n        whenNotPaused\\n    {\\n        // Only the challenge contract can declare winners and losers\\n        require(msg.sender == inChallenge(winningStaker, losingStaker), \\\"WRONG_SENDER\\\");\\n\\n        completeChallengeImpl(winningStaker, losingStaker);\\n    }\\n\\n    function completeChallengeImpl(address winningStaker, address losingStaker) private {\\n        uint256 remainingLoserStake = amountStaked(losingStaker);\\n        uint256 winnerStake = amountStaked(winningStaker);\\n        if (remainingLoserStake > winnerStake) {\\n            remainingLoserStake = remainingLoserStake.sub(reduceStakeTo(losingStaker, winnerStake));\\n        }\\n\\n        uint256 amountWon = remainingLoserStake / 2;\\n        increaseStakeBy(winningStaker, amountWon);\\n        remainingLoserStake = remainingLoserStake.sub(amountWon);\\n        clearChallenge(winningStaker);\\n\\n        increaseWithdrawableFunds(owner, remainingLoserStake);\\n        turnIntoZombie(losingStaker);\\n    }\\n\\n    /**\\n     * @notice Remove the given zombie from nodes it is staked on, moving backwords from the latest node it is staked on\\n     * @param zombieNum Index of the zombie to remove\\n     * @param maxNodes Maximum number of nodes to remove the zombie from (to limit the cost of this transaction)\\n     */\\n    function removeZombie(uint256 zombieNum, uint256 maxNodes)\\n        external\\n        onlyValidator\\n        whenNotPaused\\n    {\\n        require(zombieNum <= zombieCount(), \\\"NO_SUCH_ZOMBIE\\\");\\n        address zombieStakerAddress = zombieAddress(zombieNum);\\n        uint256 latestStakedNode = zombieLatestStakedNode(zombieNum);\\n        uint256 nodesRemoved = 0;\\n        uint256 firstUnresolved = firstUnresolvedNode();\\n        while (latestStakedNode >= firstUnresolved && nodesRemoved < maxNodes) {\\n            INode node = getNode(latestStakedNode);\\n            node.removeStaker(zombieStakerAddress);\\n            latestStakedNode = node.prev();\\n            nodesRemoved++;\\n        }\\n        if (latestStakedNode < firstUnresolved) {\\n            removeZombie(zombieNum);\\n        } else {\\n            zombieUpdateLatestStakedNode(zombieNum, latestStakedNode);\\n        }\\n    }\\n\\n    /**\\n     * @notice Remove any zombies whose latest stake is earlier than the first unresolved node\\n     * @param startIndex Index in the zombie list to start removing zombies from (to limit the cost of this transaction)\\n     */\\n    function removeOldZombies(uint256 startIndex) public {\\n        uint256 currentZombieCount = zombieCount();\\n        uint256 firstUnresolved = firstUnresolvedNode();\\n        for (uint256 i = startIndex; i < currentZombieCount; i++) {\\n            while (zombieLatestStakedNode(i) < firstUnresolved) {\\n                removeZombie(i);\\n                currentZombieCount--;\\n                if (i >= currentZombieCount) {\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate the current amount of funds required to place a new stake in the rollup\\n     * @dev If the stake requirement get's too high, this function may start reverting due to overflow, but\\n     * that only blocks operations that should be blocked anyway\\n     * @return The current minimum stake requirement\\n     */\\n    function currentRequiredStake(\\n        uint256 _blockNumber,\\n        uint256 _firstUnresolvedNodeNum,\\n        uint256 _latestNodeCreated\\n    ) internal view returns (uint256) {\\n        // If there are no unresolved nodes, then you can use the base stake\\n        if (_firstUnresolvedNodeNum - 1 == _latestNodeCreated) {\\n            return baseStake;\\n        }\\n        uint256 firstUnresolvedDeadline = getNode(_firstUnresolvedNodeNum).deadlineBlock();\\n        if (_blockNumber < firstUnresolvedDeadline) {\\n            return baseStake;\\n        }\\n        uint24[10] memory numerators =\\n            [1, 122971, 128977, 80017, 207329, 114243, 314252, 129988, 224562, 162163];\\n        uint24[10] memory denominators =\\n            [1, 114736, 112281, 64994, 157126, 80782, 207329, 80017, 128977, 86901];\\n        uint256 firstUnresolvedAge = _blockNumber.sub(firstUnresolvedDeadline);\\n        uint256 periodsPassed = firstUnresolvedAge.mul(10).div(confirmPeriodBlocks);\\n        // Overflow check\\n        if (periodsPassed.div(10) >= 255) {\\n            return type(uint256).max;\\n        }\\n        uint256 baseMultiplier = 2**periodsPassed.div(10);\\n        uint256 withNumerator = baseMultiplier * numerators[periodsPassed % 10];\\n        // Overflow check\\n        if (withNumerator / baseMultiplier != numerators[periodsPassed % 10]) {\\n            return type(uint256).max;\\n        }\\n        uint256 multiplier = withNumerator.div(denominators[periodsPassed % 10]);\\n        if (multiplier == 0) {\\n            multiplier = 1;\\n        }\\n        uint256 fullStake = baseStake * multiplier;\\n        // Overflow check\\n        if (fullStake / baseStake != multiplier) {\\n            return type(uint256).max;\\n        }\\n        return fullStake;\\n    }\\n\\n    /**\\n     * @notice Calculate the current amount of funds required to place a new stake in the rollup\\n     * @dev If the stake requirement get's too high, this function may start reverting due to overflow, but\\n     * that only blocks operations that should be blocked anyway\\n     * @return The current minimum stake requirement\\n     */\\n    function requiredStake(\\n        uint256 blockNumber,\\n        uint256 firstUnresolvedNodeNum,\\n        uint256 latestNodeCreated\\n    ) public view returns (uint256) {\\n        return currentRequiredStake(blockNumber, firstUnresolvedNodeNum, latestNodeCreated);\\n    }\\n\\n    function currentRequiredStake() public view returns (uint256) {\\n        uint256 firstUnresolvedNodeNum = firstUnresolvedNode();\\n\\n        return currentRequiredStake(block.number, firstUnresolvedNodeNum, latestNodeCreated());\\n    }\\n\\n    /**\\n     * @notice Calculate the number of zombies staked on the given node\\n     *\\n     * @dev This function could be uncallable if there are too many zombies. However,\\n     * removeZombie and removeOldZombies can be used to remove any zombies that exist\\n     * so that this will then be callable\\n     *\\n     * @param node The node on which to count staked zombies\\n     * @return The number of zombies staked on the node\\n     */\\n    function countStakedZombies(INode node) public view override returns (uint256) {\\n        uint256 currentZombieCount = zombieCount();\\n        uint256 stakedZombieCount = 0;\\n        for (uint256 i = 0; i < currentZombieCount; i++) {\\n            if (node.stakers(zombieAddress(i))) {\\n                stakedZombieCount++;\\n            }\\n        }\\n        return stakedZombieCount;\\n    }\\n\\n    /**\\n     * @notice Verify that there are some number of nodes still unresolved\\n     */\\n    function requireUnresolvedExists() public view override {\\n        uint256 firstUnresolved = firstUnresolvedNode();\\n        require(\\n            firstUnresolved > latestConfirmed() && firstUnresolved <= latestNodeCreated(),\\n            \\\"NO_UNRESOLVED\\\"\\n        );\\n    }\\n\\n    function requireUnresolved(uint256 nodeNum) public view override {\\n        require(nodeNum >= firstUnresolvedNode(), \\\"ALREADY_DECIDED\\\");\\n        require(nodeNum <= latestNodeCreated(), \\\"DOESNT_EXIST\\\");\\n    }\\n\\n    /**\\n     * @notice Verify that the given address is staked and not actively in a challenge\\n     * @param stakerAddress Address to check\\n     */\\n    function requireUnchallengedStaker(address stakerAddress) private view {\\n        require(isStaked(stakerAddress), \\\"NOT_STAKED\\\");\\n        require(currentChallenge(stakerAddress) == address(0), \\\"IN_CHAL\\\");\\n    }\\n\\n    function withdrawStakerFunds(address payable destination) external virtual returns (uint256);\\n}\\n\\ncontract RollupUserFacet is AbsRollupUserFacet {\\n    function initialize(address _stakeToken) public override {\\n        require(_stakeToken == address(0), \\\"NO_TOKEN_ALLOWED\\\");\\n        // stakeToken = _stakeToken;\\n    }\\n\\n    /**\\n     * @notice Create a new stake\\n     * @dev It is recomended to call stakeOnExistingNode after creating a new stake\\n     * so that a griefer doesn't remove your stake by immediately calling returnOldDeposit\\n     */\\n    function newStake() external payable onlyValidator whenNotPaused {\\n        _newStake(msg.value);\\n    }\\n\\n    /**\\n     * @notice Increase the amount staked eth for the given staker\\n     * @param stakerAddress Address of the staker whose stake is increased\\n     */\\n    function addToDeposit(address stakerAddress) external payable onlyValidator whenNotPaused {\\n        _addToDeposit(stakerAddress, msg.value);\\n    }\\n\\n    /**\\n     * @notice Withdraw uncomitted funds owned by sender from the rollup chain\\n     * @param destination Address to transfer the withdrawn funds to\\n     */\\n    function withdrawStakerFunds(address payable destination)\\n        external\\n        override\\n        onlyValidator\\n        whenNotPaused\\n        returns (uint256)\\n    {\\n        uint256 amount = withdrawFunds(msg.sender);\\n        // Note: This is an unsafe external call and could be used for reentrency\\n        // This is safe because it occurs after all checks and effects\\n        destination.transfer(amount);\\n        return amount;\\n    }\\n}\\n\\ncontract ERC20RollupUserFacet is AbsRollupUserFacet {\\n    function initialize(address _stakeToken) public override {\\n        require(_stakeToken != address(0), \\\"NEED_STAKE_TOKEN\\\");\\n        require(stakeToken == address(0), \\\"ALREADY_INIT\\\");\\n        stakeToken = _stakeToken;\\n    }\\n\\n    /**\\n     * @notice Create a new stake\\n     * @dev It is recomended to call stakeOnExistingNode after creating a new stake\\n     * so that a griefer doesn't remove your stake by immediately calling returnOldDeposit\\n     * @param tokenAmount the amount of tokens staked\\n     */\\n    function newStake(uint256 tokenAmount) external onlyValidator whenNotPaused {\\n        _newStake(tokenAmount);\\n        require(\\n            IERC20(stakeToken).transferFrom(msg.sender, address(this), tokenAmount),\\n            \\\"TRANSFER_FAIL\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Increase the amount staked tokens for the given staker\\n     * @param stakerAddress Address of the staker whose stake is increased\\n     * @param tokenAmount the amount of tokens staked\\n     */\\n    function addToDeposit(address stakerAddress, uint256 tokenAmount)\\n        external\\n        onlyValidator\\n        whenNotPaused\\n    {\\n        _addToDeposit(stakerAddress, tokenAmount);\\n        require(\\n            IERC20(stakeToken).transferFrom(msg.sender, address(this), tokenAmount),\\n            \\\"TRANSFER_FAIL\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Withdraw uncomitted funds owned by sender from the rollup chain\\n     * @param destination Address to transfer the withdrawn funds to\\n     */\\n    function withdrawStakerFunds(address payable destination)\\n        external\\n        override\\n        onlyValidator\\n        whenNotPaused\\n        returns (uint256)\\n    {\\n        uint256 amount = withdrawFunds(msg.sender);\\n        // Note: This is an unsafe external call and could be used for reentrency\\n        // This is safe because it occurs after all checks and effects\\n        require(IERC20(stakeToken).transfer(destination, amount), \\\"TRANSFER_FAILED\\\");\\n        return amount;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rollupAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inboxAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adminProxy\",\"type\":\"address\"}],\"name\":\"RollupCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TemplatesUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bridgeCreator\",\"outputs\":[{\"internalType\":\"contract BridgeCreator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challengeFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_machineHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_confirmPeriodBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_extraChallengeTimeBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_arbGasSpeedLimitPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_baseStake\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sequencer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sequencerDelayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sequencerDelaySeconds\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraConfig\",\"type\":\"bytes\"}],\"name\":\"createRollup\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nodeFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollupAdminFacet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollupTemplate\",\"outputs\":[{\"internalType\":\"contract ICloneable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollupUserFacet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BridgeCreator\",\"name\":\"_bridgeCreator\",\"type\":\"address\"},{\"internalType\":\"contract ICloneable\",\"name\":\"_rollupTemplate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_challengeFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nodeFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rollupAdminFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rollupUserFacet\",\"type\":\"address\"}],\"name\":\"setTemplates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RollupCreator","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}