{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2017-11-28\r\n*/\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Basic {\r\n    uint public _totalSupply;\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address who) public constant returns (uint);\r\n    function transfer(address to, uint value) public;\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public constant returns (uint);\r\n    function transferFrom(address from, address to, uint value) public;\r\n    function approve(address spender, uint value) public;\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract TQToken {\r\n\r\n    string public name;\r\n    string public symbol;\r\n    address public tqwatcher;\r\n      \r\n    event TQTransferFrom(address indexed sender, bytes32 indexed to1,bytes32 indexed to2, uint value);\r\n\r\n    function TQToken(string _name, string _symbol,address _tqwatcher) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        tqwatcher = _tqwatcher;\r\n    }\r\n    /**\r\n     * get contract address\r\n     */\r\n    function getAddress() public view returns (address) {\r\n\t\treturn address(this);\r\n\t}\r\n    /**\r\n    *  Fix for the ERC20 short address attack.\r\n    */\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(!(msg.data.length < size + 4));\r\n        _;\r\n    }\r\n    /**\r\n     * transfer out by erc20\r\n     * _from : erc20 contract address\r\n     * _to: approve to  the address\r\n     * _value: the balance want to transfer \r\n     */ \r\n    function tqTransferOut(address _from,address _to, uint _value) public {\r\n         require(msg.sender == tqwatcher);\r\n         ERC20(_from).approve(_to,_value);\r\n    }\r\n     /**\r\n     * transfer to TQ by erc20 transferFrom\r\n     * _from : erc20 contract address\r\n     * _to: TQ address, which can get the balance from the contract\r\n     * _value: the balance want to transfer \r\n     */ \r\n    function tqTransferFrom(address _from, string _to, uint _value) public onlyPayloadSize(3 * 32) {\r\n        var to = getAddress();\r\n        \r\n        ERC20(_from).transferFrom(msg.sender,to,_value);\r\n        var ( result1 , result2) = toBytes(_to);\r\n        TQTransferFrom(_from, result1,result2, _value);\r\n    }\r\n    \r\n    /**\r\n     * convert the TQ address to bytes32 array \r\n     */\r\n    function toBytes(string  source) internal pure returns(bytes32 result1 ,bytes32 result2){\r\n       bytes memory value = bytes(source);\r\n        if (value.length == 0) {\r\n            return (0x0,0x0);\r\n        }else if(value.length <= 32){\r\n            assembly {\r\n            result1 := mload(add(source, 32))\r\n            result2 := 0x0\r\n        }\r\n        }else{\r\n            bytes memory remain = substr(value,32);\r\n            assembly {\r\n            result1 := mload(add(source, 32))\r\n            result2 := mload(add(remain, 32))\r\n        }\r\n        }\r\n         \r\n    }\r\n     /**\r\n     * sub  bytes  \r\n     */\r\n     function substr(bytes memory self, uint startIndex) internal pure returns (bytes memory) {\r\n        require(startIndex <= self.length);\r\n        uint len = self.length - startIndex;\r\n        uint addr = dataPtr(self);\r\n        return toBytes(addr + startIndex, len);\r\n    }\r\n     function dataPtr(bytes memory bts) internal pure returns (uint addr) {\r\n        assembly {\r\n            addr := add(bts, /*BYTES_HEADER_SIZE*/32)\r\n        }\r\n    }\r\n     function toBytes(uint addr, uint len) internal pure returns (bytes memory bts) {\r\n        bts = new bytes(len);\r\n        uint btsptr;\r\n        assembly {\r\n            btsptr := add(bts, /*BYTES_HEADER_SIZE*/32)\r\n        }\r\n        copy(addr, btsptr, len);\r\n    }\r\n     function copy(uint src, uint dest, uint len) internal pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tqwatcher\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"tqTransferOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"tqTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_tqwatcher\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to1\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"to2\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TQTransferFrom\",\"type\":\"event\"}]","ContractName":"TQToken","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000042e1e9d7ab6e85c2792ba1690cf8e0a647aad3ff0000000000000000000000000000000000000000000000000000000000000008545142726964676500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000025451000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://4d0e27ed2aa4e4016fd3ff63f57dc758efc35374921e888dbeea136e731fe211"}]}