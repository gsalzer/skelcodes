{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: NLPL\n\npragma solidity ^0.6.12;\n\n\n// \n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n    /**\n    * @dev Indicates that the contract has been initialized.\n    */\n    bool private initialized;\n\n    /**\n    * @dev Indicates that the contract is in the process of being initialized.\n    */\n    bool private initializing;\n\n    /**\n    * @dev Modifier to use in the initializer function of a contract.\n    */\n    modifier initializer() {\n      require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n      bool isTopLevelCall = !initializing;\n      if (isTopLevelCall) {\n        initializing = true;\n        initialized = true;\n      }\n\n      _;\n\n      if (isTopLevelCall) {\n        initializing = false;\n      }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n      // extcodesize checks the size of the code stored in an address, and\n      // address returns the current address. Since the code is still not\n      // deployed when running a constructor, any checks on its code size will\n      // yield zero, making it an effective way to detect if a contract is\n      // under construction or not.\n      address self = address(this);\n      uint256 cs;\n      assembly { cs := extcodesize(self) }\n      return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable is Initializable {\n    address private _owner;\n\n    event OwnershipRenounced(address indexed previousOwner);\n    event OwnershipTransferred(\n      address indexed previousOwner,\n      address indexed newOwner\n    );\n\n    /**\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n    * account.\n    */\n    function init(address sender) public initializer {\n      _owner = sender;\n    }\n\n    /**\n    * @return the address of the owner.\n    */\n    function owner() public view returns(address) {\n      return _owner;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n      require(isOwner());\n      _;\n    }\n\n    /**\n    * @return true if `msg.sender` is the owner of the contract.\n    */\n    function isOwner() public view returns(bool) {\n      return msg.sender == _owner;\n    }\n\n    /**\n    * @dev Allows the current owner to relinquish control of the contract.\n    * @notice Renouncing to ownership will leave the contract without an owner.\n    * It will not be possible to call the functions with the `onlyOwner`\n    * modifier anymore.\n    */\n    function renounceOwnership() public onlyOwner {\n      emit OwnershipRenounced(_owner);\n      _owner = address(0);\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n      _transferOwnership(newOwner);\n    }\n\n    /**\n    * @dev Transfers control of the contract to a newOwner.\n    * @param newOwner The address to transfer ownership to.\n    */\n    function _transferOwnership(address newOwner) internal {\n      require(newOwner != address(0));\n      emit OwnershipTransferred(_owner, newOwner);\n      _owner = newOwner;\n    }\n\n    uint256[50] private ______gap;\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// \nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) \n    {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) \n    {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) \n    {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) \n    {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) \n        {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) \n    {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) \n    {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) \n    {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) \n    {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for SIERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n/**\n * @title A simple holder of tokens.\n * This is a simple contract to hold tokens. It's useful in the case where a separate contract\n * needs to hold multiple distinct pools of the same token.\n */\ncontract TokenPool is Ownable {\n    IERC20 public token;\n\n    constructor(IERC20 _token) public {\n        Ownable.init(msg.sender);\n        token = _token;\n    }\n\n    function balance() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    function transfer(address to, uint256 value) external onlyOwner returns (bool) {\n        return token.transfer(to, value);\n    }\n}\n\n// UBXTStaking is the master of Token. He can make Token and he is a fair guy.\n//\n// Note that it's ownable and the owner wields tremendous power. The ownership\n// will be transferred to a governance smart contract once Token is sufficiently\n// distributed and the community can show to govern itself.\n//\n// Have fun reading it. Hopefully it's bug-free. God bless.\ncontract UBXTStaking is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount; // How many LP TOKENs the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n        uint256 rewardUBXTDebt;\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of TOKENs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accTokenPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP TOKENs to a pool. Here's what happens:\n        //   1. The pool's `accTokenPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken; // Address of LP token contract.\n        uint256 allocPoint; // How many allocation points assigned to this pool. TOKENs to distribute per block.\n        uint256 lastRewardBlock; // Last block number that TOKENs distribution occurs.\n        uint256 lastUBXTTotalReward; // Perf Pool Rewards\n        uint256 accTokenPerShare; // Accumulated TOKENs per share, times 1e12. See below.\n        uint256 ubxtAccRewardPerShare;\n    }\n    // The TOKEN TOKEN!\n    address public token;\n    // TOKEN TOKENs created per block.\n    uint256 public tokenPerBlock;\n    // Token holder\n    TokenPool private _lockedPool;\n    // Bonus muliplier for early token makers.\n    uint256 public constant BONUS_MULTIPLIER = 1;\n    // notice total UBXT rewards for distribution\n    uint256 totalUBXTReward;\n    // notice last UBXT rewards balance\n    uint256 lastUBXTRewardBalance;\n    // Info of each pool.\n    PoolInfo[] public poolInfo;\n    // Info of each user that stakes LP TOKENs.\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    // Total allocation poitns. Must be the sum of all allocation points in all pools.\n    uint256 public totalAllocPoint = 0;\n    // Total UBXT staked\n    uint256 public totalStakedUBXT;\n    // The block number when TOKEN mining starts.\n    uint256 public startBlock;\n    // notice minimum time interval to call epoch\n    uint256 public minEpochTimeIntervalSec;\n    // notice to call epoch at fixed time in a day \n    uint256 public epochWindowOffsetSec;\n    // notice seconds for epoch active\n    uint256 public epochWindowLengthSec;\n    // notice last epoch call time\n    uint256 public lastEpochTimestampSec;\n    // notice minted reward tokens for week\n    uint256 public mintedRewardToken;\n    // notice epoch count\n    uint256 public epoch;\n    // perf pool address\n    address public perfPool;\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount\n    );\n\n    constructor() public\n    { }\n    \n    function initialize(address _token, uint256 _tokenPerBlock, address _owner) public initializer {\n        Ownable.init(_owner);\n        token = _token;\n        tokenPerBlock = _tokenPerBlock;\n        startBlock = block.number;\n        _lockedPool = new TokenPool(IERC20(_token));\n\n        minEpochTimeIntervalSec = 43200;  // 43200\n        epochWindowOffsetSec = 0;\n        epochWindowLengthSec = 30 minutes;  // 30 minutes\n        lastEpochTimestampSec = 0;\n    }\n    \n    /**\n     * @return Total number of locked distribution tokens.\n     */\n    function totalLocked() public view returns (uint256) {\n        return _lockedPool.balance();\n    }\n    \n    // Lock Tokens for Reserved\n    function lockUbxtTokens(uint256 _amount) public onlyOwner {\n        require(_lockedPool.token().transferFrom(msg.sender, address(_lockedPool), _amount),\n            'UBXTStaking: transfer into locked pool failed');\n    }\n\n    /**\n     * @return If the latest block timestamp is within the Epoch time window it, returns true.\n     *         Otherwise, returns false.\n     */\n    function inEpochWindow() public view returns (bool) {\n        return (\n            now.mod(minEpochTimeIntervalSec) >= epochWindowOffsetSec &&\n            now.mod(minEpochTimeIntervalSec) < (epochWindowOffsetSec.add(epochWindowLengthSec))\n        );\n    }\n\n    /**\n     * @notice Sets the parameters which control the timing and frequency of\n     *         Epoch operations.\n     *         a) the minimum time period that must elapse between Epoch cycles.\n     *         b) the Epoch window offset parameter.\n     *         c) the Epoch window length parameter.\n     * @param minEpochTimeIntervalSec_ More than this much time must pass between Epoch\n     *        operations, in seconds.\n     * @param EpochWindowOffsetSec_ The number of seconds from the beginning of\n              the Epoch interval, where the Epoch window begins.\n     * @param EpochWindowLengthSec_ The length of the Epoch window in seconds.\n     */\n    function setEpochTimingParameters(\n        uint256 minEpochTimeIntervalSec_,\n        uint256 EpochWindowOffsetSec_,\n        uint256 EpochWindowLengthSec_)\n        external\n        onlyOwner\n    {\n        require(minEpochTimeIntervalSec_ > 0);\n        require(EpochWindowOffsetSec_ < minEpochTimeIntervalSec_);\n\n        minEpochTimeIntervalSec = minEpochTimeIntervalSec_;\n        epochWindowOffsetSec = EpochWindowOffsetSec_;\n        epochWindowLengthSec = EpochWindowLengthSec_;\n    }\n\n    /**\n     * @notice Call epoch to distribure perf pool ubxt to users \n     * this method will call in every 12 hours at fixed time\n     */\n    function distributePerfPoolRewards() public onlyOwner {\n        require(inEpochWindow(), \"Can not call epoch that time\");\n\n        // This comparison also ensures there is no reentrancy.\n        require(lastEpochTimestampSec.add(minEpochTimeIntervalSec) < now, \"Epoch will call after some time\");\n\n        // Snap the Epoch time to the start of this window.\n        uint256 ubxtBal = IERC20(token).balanceOf(perfPool);\n        IERC20(token).transferFrom(perfPool, address(this), ubxtBal);\n\n        epoch = epoch.add(1);\n    }\n\n    function updatePerfPoolAddress(address _perfPoolAddress) public onlyOwner {\n        perfPool = _perfPoolAddress;\n    }\n    \n    function updateTokenPerBlock(uint256 _tokenPerBlock) public onlyOwner {\n        massUpdatePools();\n        tokenPerBlock = _tokenPerBlock;\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    // Add a new lp to the pool. Can only be called by the owner.\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n    function add(\n        uint256 _allocPoint,\n        IERC20 _lpToken,\n        bool _withUpdate\n    ) public onlyOwner {\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        uint256 lastRewardBlock =\n            block.number > startBlock ? block.number : startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n        poolInfo.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                lastUBXTTotalReward: 0,\n                accTokenPerShare: 0,\n                ubxtAccRewardPerShare: 0\n            })\n        );\n    }\n\n    // Update the given pool's TOKEN allocation point. Can only be called by the owner.\n    function set(\n        uint256 _pid,\n        uint256 _allocPoint,\n        bool _withUpdate\n    ) public onlyOwner {\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\n            _allocPoint\n        );\n        poolInfo[_pid].allocPoint = _allocPoint;\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getMultiplier(uint256 _from, uint256 _to)\n        public\n        pure\n        returns (uint256)\n    {\n        return _to.sub(_from);\n    }\n\n    // View function to see pending TOKENs on frontend.\n    function pendingToken(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accTokenPerShare = pool.accTokenPerShare;\n        uint256 lpSupply;\n        if(_pid == 0)\n            lpSupply = totalStakedUBXT;\n        else\n            lpSupply = pool.lpToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint256 multiplier =\n                getMultiplier(pool.lastRewardBlock, block.number);\n            uint256 tokenReward =\n                multiplier.mul(tokenPerBlock).mul(pool.allocPoint).div(\n                    totalAllocPoint\n                );\n            accTokenPerShare = accTokenPerShare.add(\n                tokenReward.mul(1e12).div(lpSupply)\n            );\n        }\n        return user.amount.mul(accTokenPerShare).div(1e12).sub(user.rewardDebt);\n    }\n    \n    /**\n     * @return Return total earned UBXG token for staked time period\n     * @param _user User address\n     */\n    function pendingUBXTReward(address _user) external view returns (uint256) \n    {\n        uint256 _poolId = 1;\n        PoolInfo storage pool = poolInfo[_poolId];\n        UserInfo storage user = userInfo[_poolId][_user];\n        uint256 accRewardPerShare = pool.ubxtAccRewardPerShare;\n        uint256 supply = pool.lpToken.balanceOf(address(this));\n        \n        uint256 balance = IERC20(token).balanceOf(address(this)).sub(totalStakedUBXT);\n        uint256 _totalReward = totalUBXTReward;\n        if (balance > lastUBXTRewardBalance) {\n            _totalReward = _totalReward.add(balance.sub(lastUBXTRewardBalance));\n        }\n        if (_totalReward > pool.lastUBXTTotalReward && supply != 0) {\n            uint256 reward = _totalReward.sub(pool.lastUBXTTotalReward).mul(100).div(100);\n            accRewardPerShare = accRewardPerShare.add(reward.mul(1e12).div(supply));\n        }\n    \n        return user.amount.mul(accRewardPerShare).div(1e12).sub(user.rewardUBXTDebt);\n    }\n\n    // Update reward vairables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        \n        uint256 ubxtRewardBalance = IERC20(token).balanceOf(address(this)).sub(totalStakedUBXT);\n        uint256 _totalUBXTReward = totalUBXTReward.add(ubxtRewardBalance.sub(lastUBXTRewardBalance));\n        lastUBXTRewardBalance = ubxtRewardBalance;\n        totalUBXTReward = _totalUBXTReward;\n        \n        uint256 lpSupply;\n        if(_pid == 0)\n            lpSupply = totalStakedUBXT;\n        else\n            lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = block.number;\n            pool.lastUBXTTotalReward = _totalUBXTReward;\n            return;\n        }\n        \n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint256 tokenReward =\n            multiplier.mul(tokenPerBlock).mul(pool.allocPoint).div(\n                totalAllocPoint\n            );\n        pool.accTokenPerShare = pool.accTokenPerShare.add(\n            tokenReward.mul(1e12).div(lpSupply)\n        );\n        pool.lastRewardBlock = block.number;\n        \n        if(_pid == 1 && lpSupply != 0) {\n            uint256 ubxtReward = _totalUBXTReward.sub(pool.lastUBXTTotalReward).mul(100).div(100);\n            pool.ubxtAccRewardPerShare = pool.ubxtAccRewardPerShare.add(ubxtReward.mul(1e12).div(lpSupply));\n            pool.lastUBXTTotalReward = _totalUBXTReward;\n        } else {\n            pool.ubxtAccRewardPerShare = 0;\n            pool.lastUBXTTotalReward = 0;\n        }\n    }\n\n    // Deposit LP TOKENs to UBXTStaking for TOKEN allocation.\n    function deposit(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) {\n            uint256 pending =\n                user.amount.mul(pool.accTokenPerShare).div(1e12).sub(\n                    user.rewardDebt\n                );\n            uint256 ubxtPending = \n                user.amount.mul(pool.ubxtAccRewardPerShare).div(1e12).sub(\n                    user.rewardUBXTDebt);\n            if (ubxtPending > 0 && _pid == 1) {\n                safePerfPoolTokenTransfer(msg.sender, ubxtPending);                \n            }\n            safeTokenTransfer(msg.sender, pending);\n        }\n        pool.lpToken.safeTransferFrom(\n            address(msg.sender),\n            address(this),\n            _amount\n        );\n        if (_pid == 0)\n            totalStakedUBXT = totalStakedUBXT.add(_amount);\n        user.amount = user.amount.add(_amount);\n        user.rewardDebt = user.amount.mul(pool.accTokenPerShare).div(1e12);\n        user.rewardUBXTDebt = user.amount.mul(pool.ubxtAccRewardPerShare).div(1e12);\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    // Withdraw LP TOKENs from UBXTStaking.\n    function withdraw(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"withdraw: not good\");\n        updatePool(_pid);\n        uint256 pending =\n            user.amount.mul(pool.accTokenPerShare).div(1e12).sub(\n                user.rewardDebt\n            );\n        safeTokenTransfer(msg.sender, pending);\n        \n        uint256 ubxtPending = \n                user.amount.mul(pool.ubxtAccRewardPerShare).div(1e12).sub(\n                    user.rewardUBXTDebt);\n        if (ubxtPending > 0 && _pid == 1) {\n                safePerfPoolTokenTransfer(msg.sender, ubxtPending);                \n        }\n        user.amount = user.amount.sub(_amount);\n        if (_pid == 0)\n            totalStakedUBXT = totalStakedUBXT.sub(_amount);\n        user.rewardDebt = user.amount.mul(pool.accTokenPerShare).div(1e12);\n        user.rewardUBXTDebt = user.amount.mul(pool.ubxtAccRewardPerShare).div(1e12);\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n        if (_pid == 0)\n            totalStakedUBXT = totalStakedUBXT.sub(user.amount);\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n        user.rewardUBXTDebt = 0;\n    }\n\n    // Safe token transfer function, just in case if rounding error causes pool to not have enough TOKENs.\n    function safeTokenTransfer(address _to, uint256 _amount) internal {\n        uint256 tokenBal = totalLocked();\n        if (_amount > tokenBal) {\n            _lockedPool.transfer(_to, tokenBal);\n        } else {\n            _lockedPool.transfer(_to, _amount);\n        }\n    }\n    \n    // Safe token transfer function, just in case if rounding error causes pool to not have enough TOKENs.\n    function safePerfPoolTokenTransfer(address _to, uint256 _amount) internal {\n        uint256 tokenBal = IERC20(token).balanceOf(address(this));\n        if (_amount > tokenBal) {\n            IERC20(token).transfer(_to, tokenBal);\n        } else {\n            IERC20(token).transfer(_to, _amount);\n        }\n        lastUBXTRewardBalance = IERC20(token).balanceOf(address(this)).sub(totalStakedUBXT);\n    }\n\n    // Emergency Withdraw.\n    function emergencyWithdrawToken(address _to, uint256 _amount) public onlyOwner {\n        uint256 tokenBal = IERC20(token).balanceOf(address(this));\n        if (_amount > tokenBal) {\n            IERC20(token).transfer(_to, tokenBal);\n        } else {\n            IERC20(token).transfer(_to, _amount);\n        }\n    }\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONUS_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributePerfPoolRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochWindowLengthSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochWindowOffsetSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inEpochWindow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastEpochTimestampSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"lockUbxtTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minEpochTimeIntervalSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintedRewardToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingUBXTReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"perfPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUBXTTotalReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accTokenPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ubxtAccRewardPerShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minEpochTimeIntervalSec_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EpochWindowOffsetSec_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EpochWindowLengthSec_\",\"type\":\"uint256\"}],\"name\":\"setEpochTimingParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakedUBXT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_perfPoolAddress\",\"type\":\"address\"}],\"name\":\"updatePerfPoolAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenPerBlock\",\"type\":\"uint256\"}],\"name\":\"updateTokenPerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardUBXTDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"UBXTStaking","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}