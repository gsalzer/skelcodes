{"status":"1","message":"OK","result":[{"SourceCode":"// File: interfaces/DelegatorInterface.sol\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract DelegationStorage {\r\n    /**\r\n     * @notice Implementation address for this contract\r\n     */\r\n    address public implementation;\r\n}\r\n\r\nabstract contract DelegatorInterface is DelegationStorage {\r\n    /**\r\n     * @notice Emitted when implementation is changed\r\n     */\r\n    event NewImplementation(\r\n        address oldImplementation,\r\n        address newImplementation\r\n    );\r\n\r\n    /**\r\n     * @notice Called by the admin to update the implementation of the delegator\r\n     * @param implementation_ The address of the new implementation for delegation\r\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\r\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\r\n     */\r\n    function _setImplementation(\r\n        address implementation_,\r\n        bool allowResign,\r\n        bytes memory becomeImplementationData\r\n    ) public virtual;\r\n}\r\n\r\nabstract contract DelegateInterface is DelegationStorage {\r\n    /**\r\n     * @notice Called by the delegator on a delegate to initialize it for duty\r\n     * @dev Should revert if any issues arise which make it unfit for delegation\r\n     * @param data The encoded bytes data for any initialization\r\n     */\r\n    function _becomeImplementation(bytes memory data) public virtual;\r\n\r\n    /**\r\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\r\n     */\r\n    function _resignImplementation() public virtual;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @uniswap/lib/contracts/libraries/FullMath.sol\r\n\r\npragma solidity >=0.4.0;\r\n\r\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\r\n// license is CC-BY-4.0\r\nlibrary FullMath {\r\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\r\n        uint256 mm = mulmod(x, y, uint256(-1));\r\n        l = x * y;\r\n        h = mm - l;\r\n        if (mm < l) h -= 1;\r\n    }\r\n\r\n    function fullDiv(\r\n        uint256 l,\r\n        uint256 h,\r\n        uint256 d\r\n    ) private pure returns (uint256) {\r\n        uint256 pow2 = d & -d;\r\n        d /= pow2;\r\n        l /= pow2;\r\n        l += h * ((-pow2) / pow2 + 1);\r\n        uint256 r = 1;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        return l * r;\r\n    }\r\n\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 d\r\n    ) internal pure returns (uint256) {\r\n        (uint256 l, uint256 h) = fullMul(x, y);\r\n\r\n        uint256 mm = mulmod(x, y, d);\r\n        if (mm > l) h -= 1;\r\n        l -= mm;\r\n\r\n        if (h == 0) return l / d;\r\n\r\n        require(h < d, 'FullMath: FULLDIV_OVERFLOW');\r\n        return fullDiv(l, h, d);\r\n    }\r\n}\r\n\r\n// File: @uniswap/lib/contracts/libraries/Babylonian.sol\r\n\r\n\r\npragma solidity >=0.4.0;\r\n\r\n// computes square roots using the babylonian method\r\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\r\nlibrary Babylonian {\r\n    // credit for this implementation goes to\r\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\r\n    function sqrt(uint256 x) internal pure returns (uint256) {\r\n        if (x == 0) return 0;\r\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\r\n        // however that code costs significantly more gas\r\n        uint256 xx = x;\r\n        uint256 r = 1;\r\n        if (xx >= 0x100000000000000000000000000000000) {\r\n            xx >>= 128;\r\n            r <<= 64;\r\n        }\r\n        if (xx >= 0x10000000000000000) {\r\n            xx >>= 64;\r\n            r <<= 32;\r\n        }\r\n        if (xx >= 0x100000000) {\r\n            xx >>= 32;\r\n            r <<= 16;\r\n        }\r\n        if (xx >= 0x10000) {\r\n            xx >>= 16;\r\n            r <<= 8;\r\n        }\r\n        if (xx >= 0x100) {\r\n            xx >>= 8;\r\n            r <<= 4;\r\n        }\r\n        if (xx >= 0x10) {\r\n            xx >>= 4;\r\n            r <<= 2;\r\n        }\r\n        if (xx >= 0x8) {\r\n            r <<= 1;\r\n        }\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1; // Seven iterations should be enough\r\n        uint256 r1 = x / r;\r\n        return (r < r1 ? r : r1);\r\n    }\r\n}\r\n\r\n// File: @uniswap/lib/contracts/libraries/BitMath.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\nlibrary BitMath {\r\n    // returns the 0 indexed position of the most significant bit of the input x\r\n    // s.t. x >= 2**msb and x < 2**(msb+1)\r\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\r\n        require(x > 0, 'BitMath::mostSignificantBit: zero');\r\n\r\n        if (x >= 0x100000000000000000000000000000000) {\r\n            x >>= 128;\r\n            r += 128;\r\n        }\r\n        if (x >= 0x10000000000000000) {\r\n            x >>= 64;\r\n            r += 64;\r\n        }\r\n        if (x >= 0x100000000) {\r\n            x >>= 32;\r\n            r += 32;\r\n        }\r\n        if (x >= 0x10000) {\r\n            x >>= 16;\r\n            r += 16;\r\n        }\r\n        if (x >= 0x100) {\r\n            x >>= 8;\r\n            r += 8;\r\n        }\r\n        if (x >= 0x10) {\r\n            x >>= 4;\r\n            r += 4;\r\n        }\r\n        if (x >= 0x4) {\r\n            x >>= 2;\r\n            r += 2;\r\n        }\r\n        if (x >= 0x2) r += 1;\r\n    }\r\n\r\n    // returns the 0 indexed position of the least significant bit of the input x\r\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\r\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\r\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\r\n        require(x > 0, 'BitMath::leastSignificantBit: zero');\r\n\r\n        r = 255;\r\n        if (x & uint128(-1) > 0) {\r\n            r -= 128;\r\n        } else {\r\n            x >>= 128;\r\n        }\r\n        if (x & uint64(-1) > 0) {\r\n            r -= 64;\r\n        } else {\r\n            x >>= 64;\r\n        }\r\n        if (x & uint32(-1) > 0) {\r\n            r -= 32;\r\n        } else {\r\n            x >>= 32;\r\n        }\r\n        if (x & uint16(-1) > 0) {\r\n            r -= 16;\r\n        } else {\r\n            x >>= 16;\r\n        }\r\n        if (x & uint8(-1) > 0) {\r\n            r -= 8;\r\n        } else {\r\n            x >>= 8;\r\n        }\r\n        if (x & 0xf > 0) {\r\n            r -= 4;\r\n        } else {\r\n            x >>= 4;\r\n        }\r\n        if (x & 0x3 > 0) {\r\n            r -= 2;\r\n        } else {\r\n            x >>= 2;\r\n        }\r\n        if (x & 0x1 > 0) r -= 1;\r\n    }\r\n}\r\n\r\n// File: @uniswap/lib/contracts/libraries/FixedPoint.sol\r\n\r\npragma solidity >=0.4.0;\r\n\r\n\r\n\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\nlibrary FixedPoint {\r\n    // range: [0, 2**112 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    // range: [0, 2**144 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq144x112 {\r\n        uint256 _x;\r\n    }\r\n\r\n    uint8 public constant RESOLUTION = 112;\r\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\r\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\r\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\r\n        return uq112x112(uint224(x) << RESOLUTION);\r\n    }\r\n\r\n    // encodes a uint144 as a UQ144x112\r\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\r\n        return uq144x112(uint256(x) << RESOLUTION);\r\n    }\r\n\r\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\r\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\r\n        return uint112(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\r\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\r\n        return uint144(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\r\n    // reverts on overflow\r\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\r\n        uint256 z = 0;\r\n        require(y == 0 || (z = self._x * y) / y == self._x, 'FixedPoint::mul: overflow');\r\n        return uq144x112(z);\r\n    }\r\n\r\n    // multiply a UQ112x112 by an int and decode, returning an int\r\n    // reverts on overflow\r\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\r\n        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\r\n        require(z < 2**255, 'FixedPoint::muli: overflow');\r\n        return y < 0 ? -int256(z) : int256(z);\r\n    }\r\n\r\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\r\n    // lossy\r\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\r\n        if (self._x == 0 || other._x == 0) {\r\n            return uq112x112(0);\r\n        }\r\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\r\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\r\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\r\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\r\n\r\n        // partial products\r\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\r\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\r\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\r\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\r\n\r\n        // so the bit shift does not overflow\r\n        require(upper <= uint112(-1), 'FixedPoint::muluq: upper overflow');\r\n\r\n        // this cannot exceed 256 bits, all values are 224 bits\r\n        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\r\n\r\n        // so the cast does not overflow\r\n        require(sum <= uint224(-1), 'FixedPoint::muluq: sum overflow');\r\n\r\n        return uq112x112(uint224(sum));\r\n    }\r\n\r\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\r\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\r\n        require(other._x > 0, 'FixedPoint::divuq: division by zero');\r\n        if (self._x == other._x) {\r\n            return uq112x112(uint224(Q112));\r\n        }\r\n        if (self._x <= uint144(-1)) {\r\n            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\r\n            require(value <= uint224(-1), 'FixedPoint::divuq: overflow');\r\n            return uq112x112(uint224(value));\r\n        }\r\n\r\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\r\n        require(result <= uint224(-1), 'FixedPoint::divuq: overflow');\r\n        return uq112x112(uint224(result));\r\n    }\r\n\r\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\r\n    // can be lossy\r\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\r\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\r\n        if (numerator == 0) return FixedPoint.uq112x112(0);\r\n\r\n        if (numerator <= uint144(-1)) {\r\n            uint256 result = (numerator << RESOLUTION) / denominator;\r\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\r\n            return uq112x112(uint224(result));\r\n        } else {\r\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\r\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\r\n            return uq112x112(uint224(result));\r\n        }\r\n    }\r\n\r\n    // take the reciprocal of a UQ112x112\r\n    // reverts on overflow\r\n    // lossy\r\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\r\n        require(self._x != 0, 'FixedPoint::reciprocal: reciprocal of zero');\r\n        require(self._x != 1, 'FixedPoint::reciprocal: overflow');\r\n        return uq112x112(uint224(Q224 / self._x));\r\n    }\r\n\r\n    // square root of a UQ112x112\r\n    // lossy between 0/1 and 40 bits\r\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\r\n        if (self._x <= uint144(-1)) {\r\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\r\n        }\r\n\r\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\r\n        safeShiftBits -= safeShiftBits % 2;\r\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\r\n    }\r\n}\r\n\r\n// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: @uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\n\r\n\r\n// library with helper methods for oracles that are concerned with computing average prices\r\nlibrary UniswapV2OracleLibrary {\r\n    using FixedPoint for *;\r\n\r\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\r\n    function currentBlockTimestamp() internal view returns (uint32) {\r\n        return uint32(block.timestamp % 2 ** 32);\r\n    }\r\n\r\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\r\n    function currentCumulativePrices(\r\n        address pair\r\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\r\n        blockTimestamp = currentBlockTimestamp();\r\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\r\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\r\n        if (blockTimestampLast != blockTimestamp) {\r\n            // subtraction overflow is desired\r\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n            // addition overflow is desired\r\n            // counterfactual\r\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\r\n            // counterfactual\r\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\r\n        }\r\n    }\r\n}\r\n\r\n// File: interfaces/IInvitation.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IInvitation{\r\n\r\n    function acceptInvitation(address _invitor) external;\r\n\r\n    function getInvitation(address _sender) external view returns(address _invitor, address[] memory _invitees, bool _isWithdrawn);\r\n    \r\n}\r\n\r\n// File: contracts/ActivityBase.sol\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\ncontract ActivityBase is Ownable{\r\n    using SafeMath for uint256;\r\n\r\n    address public admin;\r\n    \r\n    address public marketingFund;\r\n    // token as the unit of measurement\r\n    address public WETHToken;\r\n    // invitee's supply 5% deposit weight to its invitor\r\n    uint256 public constant INVITEE_WEIGHT = 20; \r\n    // invitee's supply 10% deposit weight to its invitor\r\n    uint256 public constant INVITOR_WEIGHT = 10;\r\n\r\n    // The block number when SHARD mining starts.\r\n    uint256 public startBlock;\r\n\r\n    // dev fund\r\n    uint256 public userDividendWeight;\r\n    uint256 public devDividendWeight;\r\n    address public developerDAOFund;\r\n\r\n    // deposit limit\r\n    uint256 public amountFeeRateNumerator;\r\n    uint256 public amountfeeRateDenominator;\r\n\r\n    // contract sender fee rate\r\n    uint256 public contractFeeRateNumerator;\r\n    uint256 public contractFeeRateDenominator;\r\n\r\n    // Info of each user is Contract sender\r\n    mapping (uint256 => mapping (address => bool)) public isUserContractSender;\r\n    mapping (uint256 => uint256) public poolTokenAmountLimit;\r\n\r\n    function setDividendWeight(uint256 _userDividendWeight, uint256 _devDividendWeight) public virtual{\r\n        checkAdmin();\r\n        require(\r\n            _userDividendWeight != 0 && _devDividendWeight != 0,\r\n            \"invalid input\"\r\n        );\r\n        userDividendWeight = _userDividendWeight;\r\n        devDividendWeight = _devDividendWeight;\r\n    }\r\n\r\n    function setDeveloperDAOFund(address _developerDAOFund) public virtual onlyOwner {\r\n        developerDAOFund = _developerDAOFund;\r\n    }\r\n\r\n    function setTokenAmountLimit(uint256 _pid, uint256 _tokenAmountLimit) public virtual {\r\n        checkAdmin();\r\n        poolTokenAmountLimit[_pid] = _tokenAmountLimit;\r\n    }\r\n\r\n    function setTokenAmountLimitFeeRate(uint256 _feeRateNumerator, uint256 _feeRateDenominator) public virtual {\r\n        checkAdmin();\r\n        require(\r\n            _feeRateDenominator >= _feeRateNumerator, \"invalid input\"\r\n        );\r\n        amountFeeRateNumerator = _feeRateNumerator;\r\n        amountfeeRateDenominator = _feeRateDenominator;\r\n    }\r\n\r\n    function setContracSenderFeeRate(uint256 _feeRateNumerator, uint256 _feeRateDenominator) public virtual {\r\n        checkAdmin();\r\n        require(\r\n            _feeRateDenominator >= _feeRateNumerator, \"invalid input\"\r\n        );\r\n        contractFeeRateNumerator = _feeRateNumerator;\r\n        contractFeeRateDenominator = _feeRateDenominator;\r\n    }\r\n\r\n    function setStartBlock(uint256 _startBlock) public virtual onlyOwner { \r\n        require(startBlock > block.number, \"invalid start block\");\r\n        startBlock = _startBlock;\r\n        updateAfterModifyStartBlock(_startBlock);\r\n    }\r\n\r\n    function transferAdmin(address _admin) public virtual {\r\n        checkAdmin();\r\n        admin = _admin;\r\n    }\r\n\r\n    function setMarketingFund(address _marketingFund) public virtual onlyOwner {\r\n        marketingFund = _marketingFund;\r\n    }\r\n\r\n    function updateAfterModifyStartBlock(uint256 _newStartBlock) internal virtual{\r\n    }\r\n\r\n    function calculateDividend(uint256 _pending, uint256 _pid, uint256 _userAmount, bool _isContractSender) internal view returns (uint256 _marketingFundDividend, uint256 _devDividend, uint256 _userDividend){\r\n        uint256 fee = 0;\r\n        if(_isContractSender && contractFeeRateDenominator > 0){\r\n            fee = _pending.mul(contractFeeRateNumerator).div(contractFeeRateDenominator);\r\n            _marketingFundDividend = _marketingFundDividend.add(fee);\r\n            _pending = _pending.sub(fee);\r\n        }\r\n        if(poolTokenAmountLimit[_pid] > 0 && amountfeeRateDenominator > 0 && _userAmount >= poolTokenAmountLimit[_pid]){\r\n            fee = _pending.mul(amountFeeRateNumerator).div(amountfeeRateDenominator);\r\n            _marketingFundDividend =_marketingFundDividend.add(fee);\r\n            _pending = _pending.sub(fee);\r\n        }\r\n        if(devDividendWeight > 0){\r\n            fee = _pending.mul(devDividendWeight).div(devDividendWeight.add(userDividendWeight));\r\n            _devDividend = _devDividend.add(fee);\r\n            _pending = _pending.sub(fee);\r\n        }\r\n        _userDividend = _pending;\r\n    }\r\n\r\n    function judgeContractSender(uint256 _pid) internal {\r\n        if(msg.sender != tx.origin){\r\n            isUserContractSender[_pid][msg.sender] = true;\r\n        }\r\n    }\r\n\r\n    function checkAdmin() internal view {\r\n        require(admin == msg.sender, \"invalid authorized\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name_, string memory symbol_) public {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal virtual {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n// File: contracts/SHDToken.sol\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n// SHDToken with Governance.\r\ncontract SHDToken is ERC20(\"ShardingDAO\", \"SHD\"), Ownable {\r\n    // cross chain\r\n    mapping(address => bool) public minters;\r\n\r\n    struct Checkpoint {\r\n        uint256 fromBlock;\r\n        uint256 votes;\r\n    }\r\n    /// @notice A record of votes checkpoints for each account, by index\r\n    mapping(address => mapping(uint256 => Checkpoint)) public checkpoints;\r\n\r\n    /// @notice The number of checkpoints for each account\r\n    mapping(address => uint256) public numCheckpoints;\r\n    event VotesBalanceChanged(\r\n        address indexed user,\r\n        uint256 previousBalance,\r\n        uint256 newBalance\r\n    );\r\n\r\n    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).\r\n    function mint(address _to, uint256 _amount) public {\r\n        require(minters[msg.sender] == true, \"SHD : You are not the miner\");\r\n        _mint(_to, _amount);\r\n    }\r\n\r\n    function burn(uint256 _amount) public {\r\n        _burn(msg.sender, _amount);\r\n    }\r\n\r\n    function addMiner(address _miner) external onlyOwner {\r\n        minters[_miner] = true;\r\n    }\r\n\r\n    function removeMiner(address _miner) external onlyOwner {\r\n        minters[_miner] = false;\r\n    }\r\n\r\n    function getPriorVotes(address account, uint256 blockNumber)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            blockNumber < block.number,\r\n            \"getPriorVotes: not yet determined\"\r\n        );\r\n\r\n        uint256 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // First check most recent balance\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\r\n            return checkpoints[account][nCheckpoints - 1].votes;\r\n        }\r\n\r\n        // Next check implicit zero balance\r\n        if (checkpoints[account][0].fromBlock > blockNumber) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 lower = 0;\r\n        uint256 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlock < blockNumber) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return checkpoints[account][lower].votes;\r\n    }\r\n\r\n    function _voteTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        if (from != to && amount > 0) {\r\n            if (from != address(0)) {\r\n                uint256 fromNum = numCheckpoints[from];\r\n                uint256 fromOld =\r\n                    fromNum > 0 ? checkpoints[from][fromNum - 1].votes : 0;\r\n                uint256 fromNew = fromOld.sub(amount);\r\n                _writeCheckpoint(from, fromNum, fromOld, fromNew);\r\n            }\r\n\r\n            if (to != address(0)) {\r\n                uint256 toNum = numCheckpoints[to];\r\n                uint256 toOld =\r\n                    toNum > 0 ? checkpoints[to][toNum - 1].votes : 0;\r\n                uint256 toNew = toOld.add(amount);\r\n                _writeCheckpoint(to, toNum, toOld, toNew);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(\r\n        address user,\r\n        uint256 nCheckpoints,\r\n        uint256 oldVotes,\r\n        uint256 newVotes\r\n    ) internal {\r\n        uint256 blockNumber = block.number;\r\n        if (\r\n            nCheckpoints > 0 &&\r\n            checkpoints[user][nCheckpoints - 1].fromBlock == blockNumber\r\n        ) {\r\n            checkpoints[user][nCheckpoints - 1].votes = newVotes;\r\n        } else {\r\n            checkpoints[user][nCheckpoints] = Checkpoint(blockNumber, newVotes);\r\n            numCheckpoints[user] = nCheckpoints + 1;\r\n        }\r\n\r\n        emit VotesBalanceChanged(user, oldVotes, newVotes);\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        _voteTransfer(from, to, amount);\r\n    }\r\n}\r\n\r\n// File: contracts/ShardingDAOMining.sol\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ShardingDAOMining is IInvitation, ActivityBase {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20; \r\n    using FixedPoint for *;\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount; // How much LP token the user has provided.\r\n        uint256 originWeight; //initial weight\r\n        uint256 inviteeWeight; // invitees' weight\r\n        uint256 endBlock;\r\n        bool isCalculateInvitation;\r\n    }\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        uint256 nftPoolId;\r\n        address lpTokenSwap; // uniswapPair contract address\r\n        uint256 accumulativeDividend;\r\n        uint256 usersTotalWeight; // user's sum weight\r\n        uint256 lpTokenAmount; // lock amount\r\n        uint256 oracleWeight; // eth value\r\n        uint256 lastDividendHeight; // last dividend block height\r\n        TokenPairInfo tokenToEthPairInfo;\r\n        bool isFirstTokenShard;\r\n    }\r\n\r\n    struct TokenPairInfo{\r\n        IUniswapV2Pair tokenToEthSwap; \r\n        FixedPoint.uq112x112 price; \r\n        bool isFirstTokenEth;\r\n        uint256 priceCumulativeLast;\r\n        uint32  blockTimestampLast;\r\n        uint256 lastPriceUpdateHeight;\r\n    }\r\n\r\n    struct InvitationInfo {\r\n        address invitor;\r\n        address[] invitees;\r\n        bool isUsed;\r\n        bool isWithdrawn;\r\n        mapping(address => uint256) inviteeIndexMap;\r\n    }\r\n\r\n    // black list\r\n    struct EvilPoolInfo {\r\n        uint256 pid;\r\n        string description;\r\n    }\r\n\r\n    // The SHD TOKEN!\r\n    SHDToken public SHD;\r\n    // Info of each pool.\r\n    uint256[] public rankPoolIndex;\r\n    // indicates whether the pool is in the rank\r\n    mapping(uint256 => uint256) public rankPoolIndexMap;\r\n    // relationship info about invitation\r\n    mapping(address => InvitationInfo) public usersRelationshipInfo;\r\n    // Info of each user that stakes LP tokens.\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n    // Info of each pool.\r\n    PoolInfo[] private poolInfo;\r\n    // Total allocation poitns. Must be the sum of all allocation points in all pools.\r\n    uint256 public maxRankNumber = 10;\r\n    // Last block number that SHARDs distribution occurs.\r\n    uint256 public lastRewardBlock;\r\n    // produced blocks per day\r\n    uint256 public constant produceBlocksPerDay = 6496;\r\n    // produced blocks per month\r\n    uint256 public constant produceBlocksPerMonth = produceBlocksPerDay * 30;\r\n    // SHD tokens created per block.\r\n    uint256 public SHDPerBlock = 104994 * (1e13);\r\n    // after each term, mine half SHD token\r\n    uint256 public constant MINT_DECREASE_TERM = 9500000;\r\n    // used to caculate user deposit weight\r\n    uint256[] private depositTimeWeight;\r\n    // max lock time in stage two\r\n    uint256 private constant MAX_MONTH = 36;\r\n    // add pool automatically in nft shard\r\n    address public nftShard;\r\n    // oracle token price update term\r\n    uint256 public updateTokenPriceTerm = 120;\r\n    // to mint token cross chain\r\n    uint256 public shardMintWeight = 1;\r\n    uint256 public reserveMintWeight = 0;\r\n    uint256 public reserveToMint;\r\n    // black list\r\n    EvilPoolInfo[] public blackList;\r\n    mapping(uint256 => uint256) public blackListMap;\r\n    // undividend shard\r\n    uint256 public unDividendShard;\r\n    // 20% shard => SHD - ETH pool\r\n    uint256 public shardPoolDividendWeight = 2;\r\n    // 80% shard => SHD - ETH pool\r\n    uint256 public otherPoolDividendWeight = 8;\r\n\r\n    event Deposit(\r\n        address indexed user,\r\n        uint256 indexed pid,\r\n        uint256 amount,\r\n        uint256 weight\r\n    );\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Replace(\r\n        address indexed user,\r\n        uint256 indexed rankIndex,\r\n        uint256 newPid\r\n    );\r\n\r\n    event AddToBlacklist(\r\n        uint256 indexed pid\r\n    );\r\n\r\n    event RemoveFromBlacklist(\r\n        uint256 indexed pid\r\n    );\r\n    event AddPool(uint256 indexed pid, uint256 nftId, address tokenAddress);\r\n\r\n    function initialize(\r\n        SHDToken _SHD,\r\n        address _wethToken,\r\n        address _developerDAOFund,\r\n        address _marketingFund,\r\n        uint256 _maxRankNumber,\r\n        uint256 _startBlock\r\n    ) public virtual onlyOwner{\r\n        require(WETHToken == address(0), \"already initialized\");\r\n        SHD = _SHD;\r\n        maxRankNumber = _maxRankNumber;\r\n        if (_startBlock < block.number) {\r\n            startBlock = block.number;\r\n        } else {\r\n            startBlock = _startBlock;\r\n        }\r\n        lastRewardBlock = startBlock.sub(1);\r\n        WETHToken = _wethToken;\r\n        initializeTimeWeight();\r\n        developerDAOFund = _developerDAOFund;\r\n        marketingFund = _marketingFund;\r\n        InvitationInfo storage initialInvitor =\r\n            usersRelationshipInfo[address(this)];\r\n\r\n        userDividendWeight = 8;\r\n        devDividendWeight = 2;\r\n\r\n        amountFeeRateNumerator = 0;\r\n        amountfeeRateDenominator = 0;\r\n\r\n        contractFeeRateNumerator = 1;\r\n        contractFeeRateDenominator = 5;\r\n        initialInvitor.isUsed = true;\r\n    }\r\n\r\n    function initializeTimeWeight() private {\r\n        depositTimeWeight = [\r\n            1238,\r\n            1383,\r\n            1495,\r\n            1587,\r\n            1665,\r\n            1732,\r\n            1790,\r\n            1842,\r\n            1888,\r\n            1929,\r\n            1966,\r\n            2000,\r\n            2031,\r\n            2059,\r\n            2085,\r\n            2108,\r\n            2131,\r\n            2152,\r\n            2171,\r\n            2189,\r\n            2206,\r\n            2221,\r\n            2236,\r\n            2250,\r\n            2263,\r\n            2276,\r\n            2287,\r\n            2298,\r\n            2309,\r\n            2319,\r\n            2328,\r\n            2337,\r\n            2346,\r\n            2355,\r\n            2363,\r\n            2370\r\n        ];\r\n    }\r\n\r\n    function setNftShard(address _nftShard) public virtual {\r\n        checkAdmin();\r\n        nftShard = _nftShard;\r\n    }\r\n\r\n    // Add a new lp to the pool. Can only be called by the nft shard contract.\r\n    // if _lpTokenSwap contains tokenA instead of eth, then _tokenToEthSwap should consist of token A and eth\r\n    function add(\r\n        uint256 _nftPoolId,\r\n        IUniswapV2Pair _lpTokenSwap,\r\n        IUniswapV2Pair _tokenToEthSwap\r\n    ) public virtual {\r\n        require(msg.sender == nftShard || msg.sender == admin, \"invalid sender\");\r\n        TokenPairInfo memory tokenToEthInfo;\r\n        uint256 lastDividendHeight = 0;\r\n        if(poolInfo.length == 0){\r\n            _nftPoolId = 0;\r\n            lastDividendHeight = lastRewardBlock;\r\n        }\r\n        bool isFirstTokenShard;\r\n        if (address(_tokenToEthSwap) != address(0)) {\r\n            (address token0, address token1, uint256 targetTokenPosition) =\r\n                getTargetTokenInSwap(_tokenToEthSwap, WETHToken);\r\n            address wantToken;\r\n            bool isFirstTokenEthToken;\r\n            if (targetTokenPosition == 0) {\r\n                isFirstTokenEthToken = true;\r\n                wantToken = token1;\r\n            } else {\r\n                isFirstTokenEthToken = false;\r\n                wantToken = token0;\r\n            }\r\n            (, , targetTokenPosition) = getTargetTokenInSwap(\r\n                _lpTokenSwap,\r\n                wantToken\r\n            );\r\n            if (targetTokenPosition == 0) {\r\n                isFirstTokenShard = false;\r\n            } else {\r\n                isFirstTokenShard = true;\r\n            }\r\n            tokenToEthInfo = generateOrcaleInfo(\r\n                _tokenToEthSwap,\r\n                isFirstTokenEthToken\r\n            );\r\n        } else {\r\n            (, , uint256 targetTokenPosition) =\r\n                getTargetTokenInSwap(_lpTokenSwap, WETHToken);\r\n            if (targetTokenPosition == 0) {\r\n                isFirstTokenShard = false;\r\n            } else {\r\n                isFirstTokenShard = true;\r\n            }\r\n            tokenToEthInfo = generateOrcaleInfo(\r\n                _lpTokenSwap,\r\n                !isFirstTokenShard\r\n            );\r\n        }\r\n        poolInfo.push(\r\n            PoolInfo({\r\n                nftPoolId: _nftPoolId,\r\n                lpTokenSwap: address(_lpTokenSwap),\r\n                lpTokenAmount: 0,\r\n                usersTotalWeight: 0,\r\n                accumulativeDividend: 0,\r\n                oracleWeight: 0,\r\n                lastDividendHeight: lastDividendHeight,\r\n                tokenToEthPairInfo: tokenToEthInfo,\r\n                isFirstTokenShard: isFirstTokenShard\r\n            })\r\n        );\r\n        emit AddPool(poolInfo.length.sub(1), _nftPoolId, address(_lpTokenSwap));\r\n    }\r\n\r\n    function setPriceUpdateTerm(uint256 _term) public virtual onlyOwner{\r\n        updateTokenPriceTerm = _term;\r\n    }\r\n\r\n    function kickEvilPoolByPid(uint256 _pid, string calldata description)\r\n        public\r\n        virtual\r\n        onlyOwner\r\n    {\r\n        bool isDescriptionLeagal = verifyDescription(description);\r\n        require(isDescriptionLeagal, \"invalid description, just ASCII code is allowed\");\r\n        require(_pid > 0, \"invalid pid\");\r\n        uint256 poolRankIndex = rankPoolIndexMap[_pid];\r\n        if (poolRankIndex > 0) {\r\n            massUpdatePools();\r\n            uint256 _rankIndex = poolRankIndex.sub(1);\r\n            uint256 currentRankLastIndex = rankPoolIndex.length.sub(1);\r\n            uint256 lastPidInRank = rankPoolIndex[currentRankLastIndex];\r\n            rankPoolIndex[_rankIndex] = lastPidInRank;\r\n            rankPoolIndexMap[lastPidInRank] = poolRankIndex;\r\n            delete rankPoolIndexMap[_pid];\r\n            rankPoolIndex.pop();\r\n        }\r\n        addInBlackList(_pid, description);\r\n        dealEvilPoolDiviend(_pid);\r\n        emit AddToBlacklist(_pid);\r\n    }\r\n\r\n    function addInBlackList(uint256 _pid, string calldata description) private {\r\n        if (blackListMap[_pid] > 0) {\r\n            return;\r\n        }\r\n        blackList.push(EvilPoolInfo({pid: _pid, description: description}));\r\n        blackListMap[_pid] = blackList.length;\r\n    }\r\n\r\n    function resetEvilPool(uint256 _pid) public virtual onlyOwner {\r\n        uint256 poolPosition = blackListMap[_pid];\r\n        if (poolPosition == 0) {\r\n            return;\r\n        }\r\n        uint256 poolIndex = poolPosition.sub(1);\r\n        uint256 lastIndex = blackList.length.sub(1);\r\n        EvilPoolInfo storage lastEvilInBlackList = blackList[lastIndex];\r\n        uint256 lastPidInBlackList = lastEvilInBlackList.pid;\r\n        blackListMap[lastPidInBlackList] = poolPosition;\r\n        blackList[poolIndex] = blackList[lastIndex];\r\n        delete blackListMap[_pid];\r\n        blackList.pop();\r\n        emit RemoveFromBlacklist(_pid);\r\n    }\r\n\r\n    function dealEvilPoolDiviend(uint256 _pid) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        uint256 undistributeDividend = pool.accumulativeDividend;\r\n        if (undistributeDividend == 0) {\r\n            return;\r\n        }\r\n        uint256 currentRankCount = rankPoolIndex.length;\r\n        if (currentRankCount > 0) {\r\n            uint256 averageDividend =\r\n                undistributeDividend.div(currentRankCount);\r\n            for (uint256 i = 0; i < currentRankCount; i++) {\r\n                PoolInfo storage poolInRank = poolInfo[rankPoolIndex[i]];\r\n                if (i < currentRankCount - 1) {\r\n                    poolInRank.accumulativeDividend = poolInRank\r\n                        .accumulativeDividend\r\n                        .add(averageDividend);\r\n                    undistributeDividend = undistributeDividend.sub(\r\n                        averageDividend\r\n                    );\r\n                } else {\r\n                    poolInRank.accumulativeDividend = poolInRank\r\n                        .accumulativeDividend\r\n                        .add(undistributeDividend);\r\n                }\r\n            }\r\n        } else {\r\n            unDividendShard = unDividendShard.add(undistributeDividend);\r\n        }\r\n        pool.accumulativeDividend = 0;\r\n    }\r\n\r\n    function setMintCoefficient(\r\n        uint256 _shardMintWeight,\r\n        uint256 _reserveMintWeight\r\n    ) public virtual {\r\n        checkAdmin();\r\n        require(\r\n            _shardMintWeight != 0 && _reserveMintWeight != 0,\r\n            \"invalid input\"\r\n        );\r\n        massUpdatePools();\r\n        shardMintWeight = _shardMintWeight;\r\n        reserveMintWeight = _reserveMintWeight;\r\n    }\r\n\r\n    function setShardPoolDividendWeight(\r\n        uint256 _shardPoolWeight,\r\n        uint256 _otherPoolWeight\r\n    ) public virtual {\r\n        checkAdmin();\r\n        require(\r\n            _shardPoolWeight != 0 && _otherPoolWeight != 0,\r\n            \"invalid input\"\r\n        );\r\n        massUpdatePools();\r\n        shardPoolDividendWeight = _shardPoolWeight;\r\n        otherPoolDividendWeight = _otherPoolWeight;\r\n    }\r\n\r\n    function setSHDPerBlock(uint256 _SHDPerBlock, bool _withUpdate) public virtual {\r\n        checkAdmin();\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        SHDPerBlock = _SHDPerBlock;\r\n    }\r\n\r\n    function massUpdatePools() public virtual {\r\n        uint256 poolCountInRank = rankPoolIndex.length;\r\n        uint256 farmMintShard = mintSHARD(address(this), block.number);\r\n        updateSHARDPoolAccumulativeDividend(block.number);\r\n        if(poolCountInRank == 0){\r\n            farmMintShard = farmMintShard.mul(otherPoolDividendWeight)\r\n                                     .div(shardPoolDividendWeight.add(otherPoolDividendWeight));\r\n            if(farmMintShard > 0){\r\n                unDividendShard = unDividendShard.add(farmMintShard);\r\n            }\r\n        }\r\n        for (uint256 i = 0; i < poolCountInRank; i++) {\r\n            updatePoolAccumulativeDividend(\r\n                rankPoolIndex[i],\r\n                poolCountInRank,\r\n                block.number\r\n            );\r\n        }\r\n    }\r\n\r\n    // update reward vairables for a pool\r\n    function updatePoolDividend(uint256 _pid) public virtual {\r\n        if(_pid == 0){\r\n            updateSHARDPoolAccumulativeDividend(block.number);\r\n            return;\r\n        }\r\n        if (rankPoolIndexMap[_pid] == 0) {\r\n            return;\r\n        }\r\n        updatePoolAccumulativeDividend(\r\n            _pid,\r\n            rankPoolIndex.length,\r\n            block.number\r\n        );\r\n    }\r\n\r\n    function mintSHARD(address _address, uint256 _toBlock) private returns (uint256){\r\n        uint256 recentlyRewardBlock = lastRewardBlock;\r\n        if (recentlyRewardBlock >= _toBlock) {\r\n            return 0;\r\n        }\r\n        uint256 totalReward =\r\n            getRewardToken(recentlyRewardBlock.add(1), _toBlock);\r\n        uint256 farmMint =\r\n            totalReward.mul(shardMintWeight).div(\r\n                reserveMintWeight.add(shardMintWeight)\r\n            );\r\n        uint256 reserve = totalReward.sub(farmMint);\r\n        if (totalReward > 0) {\r\n            SHD.mint(_address, farmMint);\r\n            if (reserve > 0) {\r\n                reserveToMint = reserveToMint.add(reserve);\r\n            }\r\n            lastRewardBlock = _toBlock;\r\n        }\r\n        return farmMint;\r\n    }\r\n\r\n    function updatePoolAccumulativeDividend(\r\n        uint256 _pid,\r\n        uint256 _validRankPoolCount,\r\n        uint256 _toBlock\r\n    ) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (pool.lastDividendHeight >= _toBlock) return;\r\n        uint256 poolReward =\r\n            getModifiedRewardToken(pool.lastDividendHeight.add(1), _toBlock)\r\n                                    .mul(otherPoolDividendWeight)\r\n                                    .div(shardPoolDividendWeight.add(otherPoolDividendWeight));\r\n\r\n        uint256 otherPoolReward = poolReward.div(_validRankPoolCount);                            \r\n        pool.lastDividendHeight = _toBlock;\r\n        uint256 existedDividend = pool.accumulativeDividend;\r\n        pool.accumulativeDividend = existedDividend.add(otherPoolReward);\r\n    }\r\n\r\n    function updateSHARDPoolAccumulativeDividend (uint256 _toBlock) private{\r\n        PoolInfo storage pool = poolInfo[0];\r\n        if (pool.lastDividendHeight >= _toBlock) return;\r\n        uint256 poolReward =\r\n            getModifiedRewardToken(pool.lastDividendHeight.add(1), _toBlock);\r\n\r\n        uint256 shardPoolDividend = poolReward.mul(shardPoolDividendWeight)\r\n                                               .div(shardPoolDividendWeight.add(otherPoolDividendWeight));                              \r\n        pool.lastDividendHeight = _toBlock;\r\n        uint256 existedDividend = pool.accumulativeDividend;\r\n        pool.accumulativeDividend = existedDividend.add(shardPoolDividend);\r\n    }\r\n\r\n    // deposit LP tokens to MasterChef for SHD allocation.\r\n    // ignore lockTime in stage one\r\n    function deposit(\r\n        uint256 _pid,\r\n        uint256 _amount,\r\n        uint256 _lockTime\r\n    ) public virtual {\r\n        require(_amount > 0, \"invalid deposit amount\");\r\n        InvitationInfo storage senderInfo = usersRelationshipInfo[msg.sender];\r\n        require(senderInfo.isUsed, \"must accept an invitation firstly\");\r\n        require(_lockTime > 0 && _lockTime <= 36, \"invalid lock time\"); // less than 36 months\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        uint256 lpTokenAmount = pool.lpTokenAmount.add(_amount);\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        uint256 newOriginWeight = user.originWeight;\r\n        uint256 existedAmount = user.amount;\r\n        uint256 endBlock = user.endBlock;\r\n        uint256 newEndBlock =\r\n            block.number.add(produceBlocksPerMonth.mul(_lockTime));\r\n        if (existedAmount > 0) {\r\n            if (block.number >= endBlock) {\r\n                newOriginWeight = getDepositWeight(\r\n                    _amount.add(existedAmount),\r\n                    _lockTime\r\n                );\r\n            } else {\r\n                newOriginWeight = newOriginWeight.add(getDepositWeight(_amount, _lockTime));\r\n                newOriginWeight = newOriginWeight.add(\r\n                    getDepositWeight(\r\n                        existedAmount,\r\n                        newEndBlock.sub(endBlock).div(produceBlocksPerMonth)\r\n                    )\r\n                );\r\n            }\r\n        } else {\r\n            judgeContractSender(_pid);\r\n            newOriginWeight = getDepositWeight(_amount, _lockTime);\r\n        }\r\n        modifyWeightByInvitation(\r\n            _pid,\r\n            msg.sender,\r\n            user.originWeight,\r\n            newOriginWeight,\r\n            user.inviteeWeight,\r\n            existedAmount\r\n        );   \r\n        updateUserInfo(\r\n            user,\r\n            existedAmount.add(_amount),\r\n            newOriginWeight,\r\n            newEndBlock\r\n        );\r\n        IERC20(pool.lpTokenSwap).safeTransferFrom(\r\n            address(msg.sender),\r\n            address(this),\r\n            _amount\r\n        );\r\n        pool.oracleWeight =  getOracleWeight(pool, lpTokenAmount);\r\n        pool.lpTokenAmount = lpTokenAmount;\r\n        if (\r\n            rankPoolIndexMap[_pid] == 0 &&\r\n            rankPoolIndex.length < maxRankNumber &&\r\n            blackListMap[_pid] == 0\r\n        ) {\r\n            addToRank(pool, _pid);\r\n        }\r\n        emit Deposit(msg.sender, _pid, _amount, newOriginWeight);\r\n    }\r\n\r\n    // Withdraw LP tokens from MasterChef.\r\n    function withdraw(uint256 _pid) public virtual {\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        uint256 amount = user.amount;\r\n        require(amount > 0, \"user is not existed\");\r\n        require(user.endBlock < block.number, \"token is still locked\");\r\n        mintSHARD(address(this), block.number);\r\n        updatePoolDividend(_pid);\r\n        uint256 originWeight = user.originWeight;\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        uint256 usersTotalWeight = pool.usersTotalWeight;\r\n        uint256 userWeight = user.inviteeWeight.add(originWeight);\r\n        if(user.isCalculateInvitation){\r\n            userWeight = userWeight.add(originWeight.div(INVITOR_WEIGHT));\r\n        }\r\n        if (pool.accumulativeDividend > 0) {\r\n            uint256 pending = pool.accumulativeDividend.mul(userWeight).div(usersTotalWeight);\r\n            pool.accumulativeDividend = pool.accumulativeDividend.sub(pending);\r\n            uint256 treasruyDividend;\r\n            uint256 devDividend;\r\n            (treasruyDividend, devDividend, pending) = calculateDividend(pending, _pid, amount, isUserContractSender[_pid][msg.sender]);\r\n            if(treasruyDividend > 0){\r\n                safeSHARDTransfer(marketingFund, treasruyDividend);\r\n            }\r\n            if(devDividend > 0){\r\n                safeSHARDTransfer(developerDAOFund, devDividend);\r\n            }\r\n            if(pending > 0){\r\n                safeSHARDTransfer(msg.sender, pending);\r\n            }\r\n        }\r\n        pool.usersTotalWeight = usersTotalWeight.sub(userWeight);\r\n        user.amount = 0;\r\n        user.originWeight = 0;\r\n        user.endBlock = 0;\r\n        IERC20(pool.lpTokenSwap).safeTransfer(address(msg.sender), amount);\r\n        pool.lpTokenAmount = pool.lpTokenAmount.sub(amount);\r\n        if (pool.lpTokenAmount == 0) pool.oracleWeight = 0;\r\n        else {\r\n            pool.oracleWeight = getOracleWeight(pool, pool.lpTokenAmount);\r\n        }\r\n        resetInvitationRelationship(_pid, msg.sender, originWeight);\r\n        emit Withdraw(msg.sender, _pid, amount);\r\n    }\r\n\r\n    function addToRank(\r\n        PoolInfo storage _pool,\r\n        uint256 _pid\r\n    ) private {\r\n        if(_pid == 0){\r\n            return;\r\n        }\r\n        massUpdatePools();\r\n        _pool.lastDividendHeight = block.number;\r\n        rankPoolIndex.push(_pid);\r\n        rankPoolIndexMap[_pid] = rankPoolIndex.length;\r\n        if(unDividendShard > 0){\r\n            _pool.accumulativeDividend = _pool.accumulativeDividend.add(unDividendShard);\r\n            unDividendShard = 0;\r\n        }\r\n        emit Replace(msg.sender, rankPoolIndex.length.sub(1), _pid);\r\n        return;\r\n    }\r\n\r\n    //_poolIndexInRank is the index in rank\r\n    //_pid is the index in poolInfo\r\n    function tryToReplacePoolInRank(uint256 _poolIndexInRank, uint256 _pid)\r\n        public\r\n        virtual\r\n    {\r\n        if(_pid == 0){\r\n            return;\r\n        }\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        require(pool.lpTokenAmount > 0, \"there is not any lp token depsoited\");\r\n        require(blackListMap[_pid] == 0, \"pool is in the black list\");\r\n        if (rankPoolIndexMap[_pid] > 0) {\r\n            return;\r\n        }\r\n        uint256 currentPoolCountInRank = rankPoolIndex.length;\r\n        require(currentPoolCountInRank == maxRankNumber, \"invalid operation\");\r\n        uint256 targetPid = rankPoolIndex[_poolIndexInRank];\r\n        PoolInfo storage targetPool = poolInfo[targetPid];\r\n        uint256 targetPoolOracleWeight = getOracleWeight(targetPool, targetPool.lpTokenAmount);\r\n        uint256 challengerOracleWeight = getOracleWeight(pool, pool.lpTokenAmount);\r\n        if (challengerOracleWeight <= targetPoolOracleWeight) {\r\n            return;\r\n        }\r\n        updatePoolDividend(targetPid);\r\n        rankPoolIndex[_poolIndexInRank] = _pid;\r\n        delete rankPoolIndexMap[targetPid];\r\n        rankPoolIndexMap[_pid] = _poolIndexInRank.add(1);\r\n        pool.lastDividendHeight = block.number;\r\n        emit Replace(msg.sender, _poolIndexInRank, _pid);\r\n    }\r\n\r\n    function acceptInvitation(address _invitor) public virtual override {\r\n        require(_invitor != msg.sender, \"invitee should not be invitor\");\r\n        buildInvitation(_invitor, msg.sender);\r\n    }\r\n\r\n    function buildInvitation(address _invitor, address _invitee) private {\r\n        InvitationInfo storage invitee = usersRelationshipInfo[_invitee];\r\n        require(!invitee.isUsed, \"has accepted invitation\");\r\n        invitee.isUsed = true;\r\n        InvitationInfo storage invitor = usersRelationshipInfo[_invitor];\r\n        require(invitor.isUsed, \"invitor has not acceptted invitation\");\r\n        invitee.invitor = _invitor;\r\n        invitor.invitees.push(_invitee);\r\n        invitor.inviteeIndexMap[_invitee] = invitor.invitees.length.sub(1);\r\n    }\r\n\r\n    function setMaxRankNumber(uint256 _count) public virtual {\r\n        checkAdmin();\r\n        require(_count > 0, \"invalid count\");\r\n        if (maxRankNumber == _count) return;\r\n        massUpdatePools();\r\n        maxRankNumber = _count;\r\n        uint256 currentPoolCountInRank = rankPoolIndex.length;\r\n        if (_count >= currentPoolCountInRank) {\r\n            return;\r\n        }\r\n        uint256 sparePoolCount = currentPoolCountInRank.sub(_count);\r\n        uint256 lastPoolIndex = currentPoolCountInRank.sub(1);\r\n        while (sparePoolCount > 0) {\r\n            delete rankPoolIndexMap[rankPoolIndex[lastPoolIndex]];\r\n            rankPoolIndex.pop();\r\n            lastPoolIndex--;\r\n            sparePoolCount--;\r\n        }\r\n    }\r\n\r\n    function getModifiedRewardToken(uint256 _fromBlock, uint256 _toBlock)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            getRewardToken(_fromBlock, _toBlock).mul(shardMintWeight).div(\r\n                reserveMintWeight.add(shardMintWeight)\r\n            );\r\n    }\r\n\r\n    // View function to see pending SHARDs on frontend.\r\n    function pendingSHARD(uint256 _pid, address _user)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 _pending, uint256 _potential, uint256 _blockNumber)\r\n    {\r\n        _blockNumber = block.number;\r\n        (_pending, _potential) = calculatePendingSHARD(_pid, _user);\r\n        \r\n    }\r\n\r\n    function pendingSHARDByPids(uint256[] memory _pids, address _user)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256[] memory _pending, uint256[] memory _potential, uint256 _blockNumber)\r\n    {\r\n         uint256 poolCount = _pids.length;\r\n        _pending = new uint256[](poolCount);\r\n        _potential = new uint256[](poolCount);\r\n        _blockNumber = block.number;\r\n        for(uint i = 0; i < poolCount; i ++){\r\n            (_pending[i], _potential[i]) = calculatePendingSHARD(_pids[i], _user);\r\n        }\r\n    }\r\n\r\n    function calculatePendingSHARD(uint256 _pid, address _user) private view returns (uint256 _pending, uint256 _potential){\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        if (user.amount == 0) {\r\n            return (0, 0);\r\n        }\r\n        uint256 userModifiedWeight = getUserModifiedWeight(_pid, _user);\r\n        _pending = pool.accumulativeDividend.mul(userModifiedWeight);\r\n        _pending = _pending.div(pool.usersTotalWeight);\r\n        bool isContractSender = isUserContractSender[_pid][_user];\r\n        (,,_pending) = calculateDividend(_pending, _pid, user.amount, isContractSender);\r\n        if (pool.lastDividendHeight >= block.number) {\r\n            return (_pending, 0);\r\n        }\r\n        if (_pid != 0 && (rankPoolIndex.length == 0 || rankPoolIndexMap[_pid] == 0)) {\r\n            return (_pending, 0);\r\n        }\r\n        uint256 poolReward = getModifiedRewardToken(pool.lastDividendHeight.add(1), block.number);\r\n        uint256 numerator;\r\n        uint256 denominator = otherPoolDividendWeight.add(shardPoolDividendWeight);\r\n        if(_pid == 0){\r\n            numerator = shardPoolDividendWeight;\r\n        }\r\n        else{\r\n            numerator = otherPoolDividendWeight;\r\n        }\r\n        poolReward = poolReward       \r\n            .mul(numerator)\r\n            .div(denominator);\r\n        if(_pid != 0){\r\n            poolReward = poolReward.div(rankPoolIndex.length);\r\n        }                          \r\n        _potential = poolReward\r\n            .mul(userModifiedWeight)\r\n            .div(pool.usersTotalWeight);\r\n        (,,_potential) = calculateDividend(_potential, _pid, user.amount, isContractSender);\r\n    }\r\n\r\n    //calculate the weight and end block when users deposit\r\n    function getDepositWeight(uint256 _lockAmount, uint256 _lockTime)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (_lockTime == 0) return 0;\r\n        if (_lockTime.div(MAX_MONTH) > 1) _lockTime = MAX_MONTH;\r\n        return depositTimeWeight[_lockTime.sub(1)].sub(500).mul(_lockAmount);\r\n    }\r\n\r\n    function getPoolLength() public view virtual returns (uint256) {\r\n        return poolInfo.length;\r\n    }\r\n\r\n    function getPagePoolInfo(uint256 _fromIndex, uint256 _toIndex)\r\n        public\r\n        view\r\n        virtual\r\n        returns (\r\n            uint256[] memory _nftPoolId,\r\n            uint256[] memory _accumulativeDividend,\r\n            uint256[] memory _usersTotalWeight,\r\n            uint256[] memory _lpTokenAmount,\r\n            uint256[] memory _oracleWeight,\r\n            address[] memory _swapAddress\r\n        )\r\n    {\r\n        uint256 poolCount = _toIndex.sub(_fromIndex).add(1);\r\n        _nftPoolId = new uint256[](poolCount);\r\n        _accumulativeDividend = new uint256[](poolCount);\r\n        _usersTotalWeight = new uint256[](poolCount);\r\n        _lpTokenAmount = new uint256[](poolCount);\r\n        _oracleWeight = new uint256[](poolCount);\r\n        _swapAddress = new address[](poolCount);\r\n        uint256 startIndex = 0;\r\n        for (uint256 i = _fromIndex; i <= _toIndex; i++) {\r\n            PoolInfo storage pool = poolInfo[i];\r\n            _nftPoolId[startIndex] = pool.nftPoolId;\r\n            _accumulativeDividend[startIndex] = pool.accumulativeDividend;\r\n            _usersTotalWeight[startIndex] = pool.usersTotalWeight;\r\n            _lpTokenAmount[startIndex] = pool.lpTokenAmount;\r\n            _oracleWeight[startIndex] = pool.oracleWeight;\r\n            _swapAddress[startIndex] = pool.lpTokenSwap;\r\n            startIndex++;\r\n        }\r\n    }\r\n\r\n    function getInstantPagePoolInfo(uint256 _fromIndex, uint256 _toIndex)\r\n    public\r\n    virtual\r\n    returns (\r\n        uint256[] memory _nftPoolId,\r\n        uint256[] memory _accumulativeDividend,\r\n        uint256[] memory _usersTotalWeight,\r\n        uint256[] memory _lpTokenAmount,\r\n        uint256[] memory _oracleWeight,\r\n        address[] memory _swapAddress\r\n    )\r\n    {\r\n        uint256 poolCount = _toIndex.sub(_fromIndex).add(1);\r\n        _nftPoolId = new uint256[](poolCount);\r\n        _accumulativeDividend = new uint256[](poolCount);\r\n        _usersTotalWeight = new uint256[](poolCount);\r\n        _lpTokenAmount = new uint256[](poolCount);\r\n        _oracleWeight = new uint256[](poolCount);\r\n        _swapAddress = new address[](poolCount);\r\n        uint256 startIndex = 0;\r\n        for (uint256 i = _fromIndex; i <= _toIndex; i++) {\r\n            PoolInfo storage pool = poolInfo[i];\r\n            _nftPoolId[startIndex] = pool.nftPoolId;\r\n            _accumulativeDividend[startIndex] = pool.accumulativeDividend;\r\n            _usersTotalWeight[startIndex] = pool.usersTotalWeight;\r\n            _lpTokenAmount[startIndex] = pool.lpTokenAmount;\r\n            _oracleWeight[startIndex] = getOracleWeight(pool, _lpTokenAmount[startIndex]);\r\n            _swapAddress[startIndex] = pool.lpTokenSwap;\r\n            startIndex++;\r\n        }\r\n    }\r\n\r\n    function getRankList() public view virtual returns (uint256[] memory) {\r\n        uint256[] memory rankIdList = rankPoolIndex;\r\n        return rankIdList;\r\n    }\r\n\r\n    function getBlackList()\r\n        public\r\n        view\r\n        virtual\r\n        returns (EvilPoolInfo[] memory _blackList)\r\n    {\r\n        _blackList = blackList;\r\n    }\r\n\r\n    function getInvitation(address _sender)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (\r\n            address _invitor,\r\n            address[] memory _invitees,\r\n            bool _isWithdrawn\r\n        )\r\n    {\r\n        InvitationInfo storage invitation = usersRelationshipInfo[_sender];\r\n        _invitees = invitation.invitees;\r\n        _invitor = invitation.invitor;\r\n        _isWithdrawn = invitation.isWithdrawn;\r\n    }\r\n\r\n    function getUserInfo(uint256 _pid, address _user)\r\n        public\r\n        view\r\n        virtual\r\n        returns (\r\n            uint256 _amount,\r\n            uint256 _originWeight,\r\n            uint256 _modifiedWeight,\r\n            uint256 _endBlock\r\n        )\r\n    {\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        _amount = user.amount;\r\n        _originWeight = user.originWeight;\r\n        _modifiedWeight = getUserModifiedWeight(_pid, _user);\r\n        _endBlock = user.endBlock;\r\n    }\r\n\r\n    function getUserInfoByPids(uint256[] memory _pids, address _user)\r\n        public\r\n        view\r\n        virtual\r\n        returns (\r\n            uint256[] memory _amount,\r\n            uint256[] memory _originWeight,\r\n            uint256[] memory _modifiedWeight,\r\n            uint256[] memory _endBlock\r\n        )\r\n    {\r\n        uint256 poolCount = _pids.length;\r\n        _amount = new uint256[](poolCount);\r\n        _originWeight = new uint256[](poolCount);\r\n        _modifiedWeight = new uint256[](poolCount);\r\n        _endBlock = new uint256[](poolCount);\r\n        for(uint i = 0; i < poolCount; i ++){\r\n            (_amount[i], _originWeight[i], _modifiedWeight[i], _endBlock[i]) = getUserInfo(_pids[i], _user);\r\n        }\r\n    }\r\n\r\n    function getOracleInfo(uint256 _pid)\r\n        public\r\n        view\r\n        virtual\r\n        returns (\r\n            address _swapToEthAddress,\r\n            uint256 _priceCumulativeLast,\r\n            uint256 _blockTimestampLast,\r\n            uint256 _price,\r\n            uint256 _lastPriceUpdateHeight\r\n        )\r\n    {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        _swapToEthAddress = address(pool.tokenToEthPairInfo.tokenToEthSwap);\r\n        _priceCumulativeLast = pool.tokenToEthPairInfo.priceCumulativeLast;\r\n        _blockTimestampLast = pool.tokenToEthPairInfo.blockTimestampLast;\r\n        _price = pool.tokenToEthPairInfo.price._x;\r\n        _lastPriceUpdateHeight = pool.tokenToEthPairInfo.lastPriceUpdateHeight;\r\n    }\r\n\r\n    // Safe SHD transfer function, just in case if rounding error causes pool to not have enough SHARDs.\r\n    function safeSHARDTransfer(address _to, uint256 _amount) internal {\r\n        uint256 SHARDBal = SHD.balanceOf(address(this));\r\n        if (_amount > SHARDBal) {\r\n            SHD.transfer(_to, SHARDBal);\r\n        } else {\r\n            SHD.transfer(_to, _amount);\r\n        }\r\n    }\r\n\r\n    function updateUserInfo(\r\n        UserInfo storage _user,\r\n        uint256 _amount,\r\n        uint256 _originWeight,\r\n        uint256 _endBlock\r\n    ) private {\r\n        _user.amount = _amount;\r\n        _user.originWeight = _originWeight;\r\n        _user.endBlock = _endBlock;\r\n    }\r\n\r\n    function getOracleWeight(\r\n        PoolInfo storage _pool,\r\n        uint256 _amount\r\n    ) private returns (uint256 _oracleWeight) {\r\n        _oracleWeight = calculateOracleWeight(_pool, _amount);\r\n        _pool.oracleWeight = _oracleWeight;\r\n    }\r\n\r\n    function calculateOracleWeight(PoolInfo storage _pool, uint256 _amount)\r\n        private\r\n        returns (uint256 _oracleWeight)\r\n    {\r\n        uint256 lpTokenTotalSupply =\r\n            IUniswapV2Pair(_pool.lpTokenSwap).totalSupply();\r\n        (uint112 shardReserve, uint112 wantTokenReserve, ) =\r\n            IUniswapV2Pair(_pool.lpTokenSwap).getReserves();\r\n        if (_amount == 0) {\r\n            _amount = _pool.lpTokenAmount;\r\n            if (_amount == 0) {\r\n                return 0;\r\n            }\r\n        }\r\n        if (!_pool.isFirstTokenShard) {\r\n            uint112 wantToken = wantTokenReserve;\r\n            wantTokenReserve = shardReserve;\r\n            shardReserve = wantToken;\r\n        }\r\n        FixedPoint.uq112x112 memory price =\r\n            updateTokenOracle(_pool.tokenToEthPairInfo);\r\n        if (\r\n            address(_pool.tokenToEthPairInfo.tokenToEthSwap) ==\r\n            _pool.lpTokenSwap\r\n        ) {\r\n            _oracleWeight = uint256(price.mul(shardReserve).decode144())\r\n                .mul(2)\r\n                .mul(_amount)\r\n                .div(lpTokenTotalSupply);\r\n        } else {\r\n            _oracleWeight = uint256(price.mul(wantTokenReserve).decode144())\r\n                .mul(2)\r\n                .mul(_amount)\r\n                .div(lpTokenTotalSupply);\r\n        }\r\n    }\r\n\r\n    function resetInvitationRelationship(\r\n        uint256 _pid,\r\n        address _user,\r\n        uint256 _originWeight\r\n    ) private {\r\n        InvitationInfo storage senderRelationshipInfo =\r\n            usersRelationshipInfo[_user];\r\n        if (!senderRelationshipInfo.isWithdrawn){\r\n            senderRelationshipInfo.isWithdrawn = true;\r\n            InvitationInfo storage invitorRelationshipInfo =\r\n            usersRelationshipInfo[senderRelationshipInfo.invitor];\r\n            uint256 targetIndex = invitorRelationshipInfo.inviteeIndexMap[_user];\r\n            uint256 inviteesCount = invitorRelationshipInfo.invitees.length;\r\n            address lastInvitee =\r\n            invitorRelationshipInfo.invitees[inviteesCount.sub(1)];\r\n            invitorRelationshipInfo.inviteeIndexMap[lastInvitee] = targetIndex;\r\n            invitorRelationshipInfo.invitees[targetIndex] = lastInvitee;\r\n            delete invitorRelationshipInfo.inviteeIndexMap[_user];\r\n            invitorRelationshipInfo.invitees.pop();\r\n        }\r\n        \r\n        UserInfo storage invitorInfo =\r\n            userInfo[_pid][senderRelationshipInfo.invitor];\r\n        UserInfo storage user =\r\n            userInfo[_pid][_user];\r\n        if(!user.isCalculateInvitation){\r\n            return;\r\n        }\r\n        user.isCalculateInvitation = false;\r\n        uint256 inviteeToSubWeight = _originWeight.div(INVITEE_WEIGHT);\r\n        invitorInfo.inviteeWeight = invitorInfo.inviteeWeight.sub(inviteeToSubWeight);\r\n        if (invitorInfo.amount == 0){\r\n            return;\r\n        }\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        pool.usersTotalWeight = pool.usersTotalWeight.sub(inviteeToSubWeight);\r\n    }\r\n\r\n    function modifyWeightByInvitation(\r\n        uint256 _pid,\r\n        address _user,\r\n        uint256 _oldOriginWeight,\r\n        uint256 _newOriginWeight,\r\n        uint256 _inviteeWeight,\r\n        uint256 _existedAmount\r\n    ) private{\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        InvitationInfo storage senderInfo = usersRelationshipInfo[_user];\r\n        uint256 poolTotalWeight = pool.usersTotalWeight;\r\n        poolTotalWeight = poolTotalWeight.sub(_oldOriginWeight).add(_newOriginWeight);\r\n        if(_existedAmount == 0){\r\n            poolTotalWeight = poolTotalWeight.add(_inviteeWeight);\r\n        }     \r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        if (!senderInfo.isWithdrawn || (_existedAmount > 0 && user.isCalculateInvitation)) {\r\n            UserInfo storage invitorInfo = userInfo[_pid][senderInfo.invitor];\r\n            user.isCalculateInvitation = true;\r\n            uint256 addInviteeWeight =\r\n                    _newOriginWeight.div(INVITEE_WEIGHT).sub(\r\n                        _oldOriginWeight.div(INVITEE_WEIGHT)\r\n                    );\r\n            invitorInfo.inviteeWeight = invitorInfo.inviteeWeight.add(\r\n                addInviteeWeight\r\n            );\r\n            uint256 addInvitorWeight = \r\n                    _newOriginWeight.div(INVITOR_WEIGHT).sub(\r\n                        _oldOriginWeight.div(INVITOR_WEIGHT)\r\n                    );\r\n            \r\n            poolTotalWeight = poolTotalWeight.add(addInvitorWeight);\r\n            if (invitorInfo.amount > 0) {\r\n                poolTotalWeight = poolTotalWeight.add(addInviteeWeight);\r\n            } \r\n        }\r\n        pool.usersTotalWeight = poolTotalWeight;\r\n    }\r\n\r\n    function verifyDescription(string memory description)\r\n        internal\r\n        pure\r\n        returns (bool success)\r\n    {\r\n        bytes memory nameBytes = bytes(description);\r\n        uint256 nameLength = nameBytes.length;\r\n        require(nameLength > 0, \"INVALID INPUT\");\r\n        success = true;\r\n        bool n7;\r\n        for (uint256 i = 0; i <= nameLength - 1; i++) {\r\n            n7 = (nameBytes[i] & 0x80) == 0x80 ? true : false;\r\n            if (n7) {\r\n                success = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getUserModifiedWeight(uint256 _pid, address _user) private view returns (uint256){\r\n        UserInfo storage user =  userInfo[_pid][_user];\r\n        uint256 originWeight = user.originWeight;\r\n        uint256 modifiedWeight = originWeight.add(user.inviteeWeight);\r\n        if(user.isCalculateInvitation){\r\n            modifiedWeight = modifiedWeight.add(originWeight.div(INVITOR_WEIGHT));\r\n        }\r\n        return modifiedWeight;\r\n    }\r\n\r\n        // get how much token will be mined from _toBlock to _toBlock.\r\n    function getRewardToken(uint256 _fromBlock, uint256 _toBlock) public view virtual returns (uint256){\r\n        return calculateRewardToken(MINT_DECREASE_TERM, SHDPerBlock, startBlock, _fromBlock, _toBlock);\r\n    }\r\n\r\n    function calculateRewardToken(uint _term, uint256 _initialBlock, uint256 _startBlock, uint256 _fromBlock, uint256 _toBlock) private pure returns (uint256){\r\n        if(_fromBlock > _toBlock || _startBlock > _toBlock)\r\n            return 0;\r\n        if(_startBlock > _fromBlock)\r\n            _fromBlock = _startBlock;\r\n        uint256 totalReward = 0;\r\n        uint256 blockPeriod = _fromBlock.sub(_startBlock).add(1);\r\n        uint256 yearPeriod = blockPeriod.div(_term);  // produce 5760 blocks per day, 2102400 blocks per year.\r\n        for (uint256 i = 0; i < yearPeriod; i++){\r\n            _initialBlock = _initialBlock.div(2);\r\n        }\r\n        uint256 termStartIndex = yearPeriod.add(1).mul(_term).add(_startBlock);\r\n        uint256 beforeCalculateIndex = _fromBlock.sub(1);\r\n        while(_toBlock >= termStartIndex && _initialBlock > 0){\r\n            totalReward = totalReward.add(termStartIndex.sub(beforeCalculateIndex).mul(_initialBlock));\r\n            beforeCalculateIndex = termStartIndex.add(1);\r\n            _initialBlock = _initialBlock.div(2);\r\n            termStartIndex = termStartIndex.add(_term);\r\n        }\r\n        if(_toBlock > beforeCalculateIndex){\r\n            totalReward = totalReward.add(_toBlock.sub(beforeCalculateIndex).mul(_initialBlock));\r\n        }\r\n        return totalReward;\r\n    }\r\n\r\n    function getTargetTokenInSwap(IUniswapV2Pair _lpTokenSwap, address _targetToken) internal view returns (address, address, uint256){\r\n        address token0 = _lpTokenSwap.token0();\r\n        address token1 = _lpTokenSwap.token1();\r\n        if(token0 == _targetToken){\r\n            return(token0, token1, 0);\r\n        }\r\n        if(token1 == _targetToken){\r\n            return(token0, token1, 1);\r\n        }\r\n        require(false, \"invalid uniswap\");\r\n    }\r\n\r\n    function generateOrcaleInfo(IUniswapV2Pair _pairSwap, bool _isFirstTokenEth) internal view returns(TokenPairInfo memory){\r\n        uint256 priceTokenCumulativeLast = _isFirstTokenEth? _pairSwap.price1CumulativeLast(): _pairSwap.price0CumulativeLast();\r\n        uint112 reserve0;\r\n        uint112 reserve1;\r\n        uint32 tokenBlockTimestampLast;\r\n        (reserve0, reserve1, tokenBlockTimestampLast) = _pairSwap.getReserves();\r\n        require(reserve0 != 0 && reserve1 != 0, 'ExampleOracleSimple: NO_RESERVES'); // ensure that there's liquidity in the pair\r\n        TokenPairInfo memory tokenBInfo = TokenPairInfo({\r\n            tokenToEthSwap: _pairSwap,\r\n            isFirstTokenEth: _isFirstTokenEth,\r\n            priceCumulativeLast: priceTokenCumulativeLast,\r\n            blockTimestampLast: tokenBlockTimestampLast,\r\n            price: FixedPoint.uq112x112(0),\r\n            lastPriceUpdateHeight: block.number\r\n        });\r\n        return tokenBInfo;\r\n    }\r\n\r\n    function updateTokenOracle(TokenPairInfo storage _pairInfo) internal returns (FixedPoint.uq112x112 memory _price) {\r\n        FixedPoint.uq112x112 memory cachedPrice = _pairInfo.price;\r\n        if(cachedPrice._x > 0 && block.number.sub(_pairInfo.lastPriceUpdateHeight) <= updateTokenPriceTerm){\r\n            return cachedPrice;\r\n        }\r\n        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) =\r\n            UniswapV2OracleLibrary.currentCumulativePrices(address(_pairInfo.tokenToEthSwap));\r\n        uint32 timeElapsed = blockTimestamp - _pairInfo.blockTimestampLast; // overflow is desired\r\n        // overflow is desired, casting never truncates\r\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\r\n        if(_pairInfo.isFirstTokenEth){\r\n            _price = FixedPoint.uq112x112(uint224(price1Cumulative.sub(_pairInfo.priceCumulativeLast).div(timeElapsed)));\r\n            _pairInfo.priceCumulativeLast = price1Cumulative;\r\n        }     \r\n        else{\r\n            _price = FixedPoint.uq112x112(uint224(price0Cumulative.sub(_pairInfo.priceCumulativeLast).div(timeElapsed)));\r\n            _pairInfo.priceCumulativeLast = price0Cumulative;\r\n        }\r\n        _pairInfo.price = _price;\r\n        _pairInfo.lastPriceUpdateHeight = block.number;\r\n        _pairInfo.blockTimestampLast = blockTimestamp;\r\n    }\r\n\r\n    function updateAfterModifyStartBlock(uint256 _newStartBlock) internal override{\r\n        lastRewardBlock = _newStartBlock.sub(1);\r\n        if(poolInfo.length > 0){\r\n            PoolInfo storage shdPool = poolInfo[0];\r\n            shdPool.lastDividendHeight = lastRewardBlock;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/ShardingDAOMiningDelegate.sol\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\ncontract ShardingDAOMiningDelegate is DelegateInterface, ShardingDAOMining {\r\n    /**\r\n     * @notice Construct an empty delegate\r\n     */\r\n    constructor() public {}\r\n\r\n    /**\r\n     * @notice Called by the delegator on a delegate to initialize it for duty\r\n     * @param data The encoded bytes data for any initialization\r\n     */\r\n    function _becomeImplementation(bytes memory data)\r\n        public\r\n        override\r\n    {\r\n        checkAdmin();\r\n        // Shh -- currently unused\r\n        data;\r\n\r\n        // Shh -- we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            implementation = address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\r\n     */\r\n    function _resignImplementation() public override {\r\n        checkAdmin();\r\n        // Shh -- we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            implementation = address(0);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"AddPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"AddToBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"RemoveFromBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rankIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPid\",\"type\":\"uint256\"}],\"name\":\"Replace\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INVITEE_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INVITOR_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_DECREASE_TERM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHD\",\"outputs\":[{\"internalType\":\"contract SHDToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHDPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETHToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"_becomeImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_resignImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_invitor\",\"type\":\"address\"}],\"name\":\"acceptInvitation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftPoolId\",\"type\":\"uint256\"},{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"_lpTokenSwap\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"_tokenToEthSwap\",\"type\":\"address\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountFeeRateNumerator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountfeeRateDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blackList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blackListMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractFeeRateDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractFeeRateNumerator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockTime\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devDividendWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developerDAOFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlackList\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"internalType\":\"struct ShardingDAOMining.EvilPoolInfo[]\",\"name\":\"_blackList\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toIndex\",\"type\":\"uint256\"}],\"name\":\"getInstantPagePoolInfo\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_nftPoolId\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_accumulativeDividend\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_usersTotalWeight\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_lpTokenAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_oracleWeight\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_swapAddress\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getInvitation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_invitor\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_invitees\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_isWithdrawn\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"getOracleInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_swapToEthAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_priceCumulativeLast\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockTimestampLast\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastPriceUpdateHeight\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toIndex\",\"type\":\"uint256\"}],\"name\":\"getPagePoolInfo\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_nftPoolId\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_accumulativeDividend\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_usersTotalWeight\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_lpTokenAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_oracleWeight\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_swapAddress\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRankList\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toBlock\",\"type\":\"uint256\"}],\"name\":\"getRewardToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_originWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_modifiedWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_pids\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserInfoByPids\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_amount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_originWeight\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_modifiedWeight\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_endBlock\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract SHDToken\",\"name\":\"_SHD\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wethToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_developerDAOFund\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingFund\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxRankNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isUserContractSender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"kickEvilPoolByPid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxRankNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftShard\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"otherPoolDividendWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingSHARD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_pending\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_potential\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_pids\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingSHARDByPids\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_pending\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_potential\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolTokenAmountLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"produceBlocksPerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"produceBlocksPerMonth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rankPoolIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rankPoolIndexMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveMintWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveToMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"resetEvilPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeRateNumerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeRateDenominator\",\"type\":\"uint256\"}],\"name\":\"setContracSenderFeeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_developerDAOFund\",\"type\":\"address\"}],\"name\":\"setDeveloperDAOFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_userDividendWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_devDividendWeight\",\"type\":\"uint256\"}],\"name\":\"setDividendWeight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingFund\",\"type\":\"address\"}],\"name\":\"setMarketingFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"setMaxRankNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardMintWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveMintWeight\",\"type\":\"uint256\"}],\"name\":\"setMintCoefficient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftShard\",\"type\":\"address\"}],\"name\":\"setNftShard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_term\",\"type\":\"uint256\"}],\"name\":\"setPriceUpdateTerm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_SHDPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"setSHDPerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shardPoolWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_otherPoolWeight\",\"type\":\"uint256\"}],\"name\":\"setShardPoolDividendWeight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"}],\"name\":\"setStartBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmountLimit\",\"type\":\"uint256\"}],\"name\":\"setTokenAmountLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeRateNumerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeRateDenominator\",\"type\":\"uint256\"}],\"name\":\"setTokenAmountLimitFeeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shardMintWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shardPoolDividendWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolIndexInRank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"tryToReplacePoolInRank\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unDividendShard\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePoolDividend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateTokenPriceTerm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userDividendWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteeWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCalculateInvitation\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"usersRelationshipInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"invitor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUsed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isWithdrawn\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ShardingDAOMiningDelegate","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6553da84ec88f011ee8e48a2f0bc03806140c82406257ade8154fa45f81b7a20"}]}