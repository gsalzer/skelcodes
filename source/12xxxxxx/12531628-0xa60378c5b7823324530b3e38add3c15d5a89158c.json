{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary SafeMath {\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath: addition overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, 'SafeMath: subtraction overflow');\r\n  }\r\n\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, 'SafeMath: division by zero');\r\n  }\r\n\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, 'SafeMath: modulo by zero');\r\n  }\r\n\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IWeth is IERC20 {\r\n    function deposit() external payable;\r\n    function withdraw(uint amount) external;\r\n}\r\n\r\ninterface IWstEth is IERC20{\r\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\r\n    function stETH() external view returns (IERC20);\r\n}\r\n\r\n\r\ninterface IUniswapV2Pair{\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\nlibrary Math {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Library Functions ============\r\n\r\n    /*\r\n     * Return target * (numerator / denominator).\r\n     */\r\n    function getPartial(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(numerator).div(denominator);\r\n    }\r\n\r\n    function to128(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint128)\r\n    {\r\n        uint128 result = uint128(number);\r\n        require(\r\n            result == number,\r\n            \"Math: Unsafe cast to uint128\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function min(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\nlibrary Decimal {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant BASE = 10**18;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct D256 {\r\n        uint256 value;\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    function one()\r\n        internal\r\n        pure\r\n        returns (D256 memory)\r\n    {\r\n        return D256({ value: BASE });\r\n    }\r\n\r\n    function onePlus(\r\n        D256 memory d\r\n    )\r\n        internal\r\n        pure\r\n        returns (D256 memory)\r\n    {\r\n        return D256({ value: d.value.add(BASE) });\r\n    }\r\n\r\n    function mul(\r\n        uint256 target,\r\n        D256 memory d\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return Math.getPartial(target, d.value, BASE);\r\n    }\r\n\r\n    function mul(\r\n        D256 memory d1,\r\n        D256 memory d2\r\n    )\r\n        internal\r\n        pure\r\n        returns (D256 memory)\r\n    {\r\n        return Decimal.D256({ value: Math.getPartial(d1.value, d2.value, BASE) });\r\n    }\r\n\r\n    function div(\r\n        uint256 target,\r\n        D256 memory d\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return Math.getPartial(target, BASE, d.value);\r\n    }\r\n\r\n    function add(\r\n        D256 memory d,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        pure\r\n        returns (D256 memory)\r\n    {\r\n        return D256({ value: d.value.add(amount) });\r\n    }\r\n\r\n    function sub(\r\n        D256 memory d,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        pure\r\n        returns (D256 memory)\r\n    {\r\n        return D256({ value: d.value.sub(amount) });\r\n    }\r\n\r\n}\r\n\r\ninterface IStructs{\r\n    enum Operation {\r\n        Open,\r\n        Borrow,\r\n        Repay,\r\n        Liquidate,\r\n        TransferOwnership\r\n    }\r\n\r\n    struct Principal {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n\r\n    struct Position {\r\n        address owner;\r\n        Principal collateralAmount;\r\n        Principal borrowedAmount;\r\n    }\r\n\r\n    struct OperationParams {\r\n        uint256 id;\r\n        uint256 amountOne;\r\n        uint256 amountTwo;\r\n        address addressOne;\r\n    }\r\n\r\n}\r\n\r\ninterface IOracle is IStructs{\r\n     function fetchCurrentPrice()\r\n        external\r\n        view\r\n        returns (Decimal.D256 memory);\r\n}\r\n\r\ninterface IarcxPool is IStructs{\r\n\r\n    function operateAction(\r\n        Operation operation,\r\n        OperationParams memory params\r\n    ) external ;\r\n\r\n    function getCurrentOracle() external view returns(address);\r\n\r\n    function calculateLiquidationPrice(Decimal.D256 memory currentPrice) external view returns(Decimal.D256 memory);\r\n\r\n    function calculateCollateralDelta(\r\n        Principal memory parSupply,\r\n        uint256 borrowedAmount,\r\n        Decimal.D256 memory price\r\n    )\r\n        external\r\n        view\r\n        returns (Principal memory);\r\n\r\n    function getPosition(uint256 position) external view returns (Position memory);\r\n\r\n    function getFees()\r\n    external\r\n    view\r\n    returns (\r\n        Decimal.D256 memory _liquidationUserFee,\r\n        Decimal.D256 memory _liquidationArcRatio\r\n    );\r\n}\r\n\r\ninterface ICurvePool {\r\n\r\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\r\n\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256); \r\n    // i = 1 to send, j = 0 to receive, \r\n}\r\n\r\ncontract ArcxLiquidations is IStructs {\r\n    \r\n    using SafeMath for uint256;\r\n    using Math for uint256;\r\n\r\n    IUniswapV2Pair stablexPair = IUniswapV2Pair(address(0x1BccE9E2Fd56E8311508764519d28E6ec22D4a47));\r\n\r\n    IUniswapV2Pair ethUsdcPair = IUniswapV2Pair(address(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc));\r\n\r\n    IarcxPool arcxPool = IarcxPool(address(0xC466Ec062D554BEB42f1766488F7345261C63616));\r\n\r\n    IERC20 stablex = IERC20(address(0xcD91538B91B4ba7797D39a2f66E63810b50A33d0));\r\n\r\n    IERC20 usdc = IERC20(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48));\r\n\r\n    IWstEth wsteth = IWstEth(address(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0));\r\n\r\n    IWeth weth = IWeth(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\r\n    \r\n    ICurvePool curvePool = ICurvePool(address(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022));\r\n\r\n    address owner;\r\n    \r\n    constructor() public {\r\n        owner = msg.sender;\r\n        wsteth.stETH().approve(address(curvePool), uint256(-1));\r\n    }\r\n    \r\n    fallback() external payable {\r\n        \r\n    }\r\n    \r\n    receive() external payable {\r\n        \r\n    }\r\n\r\n    function uniswapV2Call(address pair, uint256 amount0Out, uint256 amount1Out, bytes memory data) external {\r\n\r\n        if(msg.sender != address(stablexPair)){\r\n            return;\r\n        }\r\n\r\n        (uint256 amount, uint256 amountUSDC, uint256 position) = abi.decode(data, (uint256, uint256, uint256));\r\n\r\n        OperationParams memory params = OperationParams({\r\n            id: position,\r\n            amountOne: 1,\r\n            amountTwo: 1,\r\n            addressOne: address(0)\r\n        });\r\n\r\n        arcxPool.operateAction(Operation.Liquidate, params);\r\n\r\n        require(wsteth.balanceOf(address(this)) > 0, \"!no collateral received\");\r\n        \r\n        // unwraps wsteth\r\n        uint256 stethBalance = wsteth.unwrap(wsteth.balanceOf(address(this)));\r\n        // get amountOut for steth on curve\r\n        uint256 ethAmountOut = curvePool.get_dy(1, 0, stethBalance);\r\n        // swap steth for eth on curve\r\n        curvePool.exchange(1, 0, stethBalance, ethAmountOut);\r\n\r\n        (uint256 _amount0Out, uint256 _amount1Out) = ethUsdcPair.token0() == address(weth)?\r\n            (uint256(0), amountUSDC):(amountUSDC, uint256(0));\r\n\r\n        (uint256 reserve0, uint256 reserve1, ) = ethUsdcPair.getReserves();\r\n\r\n        (uint256 reserveIn, uint256 reserveOut) = ethUsdcPair.token0() == address(weth)? \r\n        (reserve0, reserve1) : (reserve1, reserve0); \r\n        \r\n        uint256 wethAmount = getAmountIn(amountUSDC, reserveIn, reserveOut);\r\n\r\n        weth.deposit{value: wethAmount}();\r\n\r\n        bytes memory empty;\r\n\r\n        weth.transfer(address(ethUsdcPair), wethAmount);\r\n\r\n        ethUsdcPair.swap(_amount0Out, _amount1Out, address(this), empty);\r\n\r\n        usdc.transfer(msg.sender, amountUSDC);\r\n        \r\n    }\r\n\r\n    function withdrawErc20(address token) external {\r\n\r\n        require(msg.sender == owner, \"!owner\");\r\n        \r\n        IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\r\n        \r\n    }\r\n    \r\n    function withdraw() external {\r\n        \r\n        require(msg.sender == owner, \"!owner\");\r\n        \r\n        payable(msg.sender).transfer(address(this).balance);\r\n        \r\n    }\r\n\r\n\r\n    function getAmountOfStableXNeeded(uint256 posIndex) public view returns(uint256 borrowToLiquidate){\r\n\r\n        Decimal.D256 memory currentPrice = IOracle(arcxPool.getCurrentOracle()).fetchCurrentPrice();\r\n\r\n        Decimal.D256 memory liquidationPrice = arcxPool.calculateLiquidationPrice(currentPrice);\r\n\r\n        Position memory position = arcxPool.getPosition(posIndex);\r\n\r\n        Principal memory collateralDelta = arcxPool.calculateCollateralDelta(\r\n            position.collateralAmount,\r\n            position.borrowedAmount.value,\r\n            liquidationPrice\r\n        );\r\n\r\n        (Decimal.D256 memory liquidateUserFees, Decimal.D256 memory liquidateArcxFees) = arcxPool.getFees();\r\n\r\n        collateralDelta.value = Decimal.mul(\r\n            collateralDelta.value,\r\n            Decimal.add(\r\n                liquidateUserFees,\r\n                Decimal.one().value\r\n            )\r\n        );\r\n\r\n\r\n        borrowToLiquidate = Decimal.mul(\r\n            collateralDelta.value,\r\n            liquidationPrice\r\n        );\r\n\r\n    }\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) private returns (uint amountIn) {\r\n        require(amountOut > 0, 'ArcxLiquidation: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'ArcxLiquidation: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n\r\n    function run(uint256 posIndex) external {\r\n\r\n        require(msg.sender == owner, \"!owner\");\r\n\r\n        uint256 amount = getAmountOfStableXNeeded(posIndex);\r\n\r\n        (uint256 amount0Out, uint256 amount1Out) = stablexPair.token0() == address(stablex)?\r\n            (amount, uint256(0)):(uint256(0), amount);\r\n\r\n        (uint256 reserve0, uint256 reserve1, ) = stablexPair.getReserves();\r\n\r\n        (uint256 reserveIn, uint256 reserveOut) = stablexPair.token0() == address(stablex)? \r\n        (reserve1, reserve0) : (reserve0, reserve1); \r\n\r\n        uint256 amountIn = getAmountIn(amount, reserveIn, reserveOut);\r\n\r\n        bytes memory data = abi.encode(amount, amountIn, posIndex);\r\n\r\n        stablexPair.swap(amount0Out, amount1Out, address(this), data);\r\n\r\n    }\r\n\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"posIndex\",\"type\":\"uint256\"}],\"name\":\"getAmountOfStableXNeeded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowToLiquidate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"posIndex\",\"type\":\"uint256\"}],\"name\":\"run\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV2Call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ArcxLiquidations","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8b93f3bddc0dde4a94df419a4c91ae4dc8c389218793d6ddbc69fc66d26e8bb4"}]}