{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"sources\": {\r\n    \"SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, 'SM_ADD_OVERFLOW');\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = sub(x, y, 'SM_SUB_UNDERFLOW');\\n    }\\n\\n    function sub(\\n        uint256 x,\\n        uint256 y,\\n        string memory message\\n    ) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, message);\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, 'SM_MUL_OVERFLOW');\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, 'SM_DIV_BY_ZERO');\\n        uint256 c = a / b;\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x > y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"IIntegralFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\ninterface IIntegralFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n    event OwnerSet(address owner);\\n\\n    function owner() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB,\\n        address oracle,\\n        address trader\\n    ) external returns (address pair);\\n\\n    function setOwner(address) external;\\n\\n    function setMintFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setBurnFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setSwapFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setOracle(\\n        address tokenA,\\n        address tokenB,\\n        address oracle\\n    ) external;\\n\\n    function setTrader(\\n        address tokenA,\\n        address tokenB,\\n        address trader\\n    ) external;\\n\\n    function collect(\\n        address tokenA,\\n        address tokenB,\\n        address to\\n    ) external;\\n\\n    function withdraw(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amount,\\n        address to\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"IIntegralERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\nimport 'IERC20.sol';\\n\\ninterface IIntegralERC20 is IERC20 {\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"IReserves.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\ninterface IReserves {\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n    event Fees(uint256 fee0, uint256 fee1);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 lastTimestamp\\n        );\\n\\n    function getReferences()\\n        external\\n        view\\n        returns (\\n            uint112 reference0,\\n            uint112 reference1,\\n            uint32 epoch\\n        );\\n\\n    function getFees() external view returns (uint256 fee0, uint256 fee1);\\n}\\n\"\r\n    },\r\n    \"IIntegralPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\nimport 'IIntegralERC20.sol';\\nimport 'IReserves.sol';\\n\\ninterface IIntegralPair is IIntegralERC20, IReserves {\\n    event Mint(address indexed sender, address indexed to);\\n    event Burn(address indexed sender, address indexed to);\\n    event Swap(address indexed sender, address indexed to);\\n    event SetMintFee(uint256 fee);\\n    event SetBurnFee(uint256 fee);\\n    event SetSwapFee(uint256 fee);\\n    event SetOracle(address account);\\n    event SetTrader(address trader);\\n    event SetToken0AbsoluteLimit(uint256 limit);\\n    event SetToken1AbsoluteLimit(uint256 limit);\\n    event SetToken0RelativeLimit(uint256 limit);\\n    event SetToken1RelativeLimit(uint256 limit);\\n    event SetPriceDeviationLimit(uint256 limit);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function oracle() external view returns (address);\\n\\n    function trader() external view returns (address);\\n\\n    function mintFee() external view returns (uint256);\\n\\n    function setMintFee(uint256 fee) external;\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burnFee() external view returns (uint256);\\n\\n    function setBurnFee(uint256 fee) external;\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swapFee() external view returns (uint256);\\n\\n    function setSwapFee(uint256 fee) external;\\n\\n    function setOracle(address account) external;\\n\\n    function setTrader(address account) external;\\n\\n    function token0AbsoluteLimit() external view returns (uint256);\\n\\n    function setToken0AbsoluteLimit(uint256 limit) external;\\n\\n    function token1AbsoluteLimit() external view returns (uint256);\\n\\n    function setToken1AbsoluteLimit(uint256 limit) external;\\n\\n    function token0RelativeLimit() external view returns (uint256);\\n\\n    function setToken0RelativeLimit(uint256 limit) external;\\n\\n    function token1RelativeLimit() external view returns (uint256);\\n\\n    function setToken1RelativeLimit(uint256 limit) external;\\n\\n    function priceDeviationLimit() external view returns (uint256);\\n\\n    function setPriceDeviationLimit(uint256 limit) external;\\n\\n    function collect(address to) external;\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to\\n    ) external;\\n\\n    function sync() external;\\n\\n    function initialize(\\n        address _token0,\\n        address _token1,\\n        address _oracle,\\n        address _trader\\n    ) external;\\n\\n    function syncWithOracle() external;\\n\\n    function fullSync() external;\\n\\n    function getSpotPrice() external view returns (uint256 spotPrice);\\n\\n    function getSwapAmount0In(uint256 amount1Out) external view returns (uint256 swapAmount0In);\\n\\n    function getSwapAmount1In(uint256 amount0Out) external view returns (uint256 swapAmount1In);\\n\\n    function getSwapAmount0Out(uint256 amount1In) external view returns (uint256 swapAmount0Out);\\n\\n    function getSwapAmount1Out(uint256 amount0In) external view returns (uint256 swapAmount1Out);\\n\\n    function getDepositAmount0In(uint256 amount0) external view returns (uint256 depositAmount0In);\\n\\n    function getDepositAmount1In(uint256 amount1) external view returns (uint256 depositAmount1In);\\n}\\n\"\r\n    },\r\n    \"IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity =0.7.5;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{ value: value }(new bytes(0));\\n        require(success, 'TH_ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"TokenShares.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\nimport 'IERC20.sol';\\nimport 'IWETH.sol';\\nimport 'SafeMath.sol';\\nimport 'TransferHelper.sol';\\n\\nlibrary TokenShares {\\n    using SafeMath for uint256;\\n    using TransferHelper for address;\\n\\n    event UnwrapFailed(address to, uint256 amount);\\n\\n    struct Data {\\n        mapping(address => uint256) totalShares;\\n        address weth;\\n    }\\n\\n    function setWeth(Data storage data, address _weth) internal {\\n        data.weth = _weth;\\n    }\\n\\n    function sharesToAmount(\\n        Data storage data,\\n        address token,\\n        uint256 share\\n    ) external returns (uint256) {\\n        if (share == 0) {\\n            return 0;\\n        }\\n        if (token == data.weth) {\\n            return share;\\n        }\\n        require(data.totalShares[token] >= share, 'TS_INSUFFICIENT_BALANCE');\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        uint256 value = balance.mul(share).div(data.totalShares[token]);\\n        data.totalShares[token] = data.totalShares[token].sub(share);\\n        return value;\\n    }\\n\\n    function amountToShares(\\n        Data storage data,\\n        address token,\\n        uint256 amount,\\n        bool wrap\\n    ) external returns (uint256) {\\n        if (amount == 0) {\\n            return 0;\\n        }\\n        if (token == data.weth) {\\n            if (wrap) {\\n                require(msg.value >= amount, 'TS_INSUFFICIENT_AMOUNT');\\n                IWETH(token).deposit{ value: amount }();\\n            } else {\\n                token.safeTransferFrom(msg.sender, address(this), amount);\\n            }\\n            return amount;\\n        } else {\\n            uint256 balanceBefore = IERC20(token).balanceOf(address(this));\\n            require(balanceBefore > 0 || data.totalShares[token] == 0, 'TS_INVALID_SHARES');\\n            if (data.totalShares[token] == 0) {\\n                data.totalShares[token] = balanceBefore;\\n            }\\n            token.safeTransferFrom(msg.sender, address(this), amount);\\n            uint256 balanceAfter = IERC20(token).balanceOf(address(this));\\n            require(balanceAfter > balanceBefore, 'TS_INVALID_TRANSFER');\\n            if (balanceBefore > 0) {\\n                uint256 lastShares = data.totalShares[token];\\n                data.totalShares[token] = lastShares.mul(balanceAfter).div(balanceBefore);\\n                return data.totalShares[token] - lastShares;\\n            } else {\\n                data.totalShares[token] = balanceAfter;\\n                data.totalShares[token] = balanceAfter;\\n                return balanceAfter;\\n            }\\n        }\\n    }\\n\\n    function onUnwrapFailed(\\n        Data storage data,\\n        address to,\\n        uint256 amount\\n    ) external {\\n        emit UnwrapFailed(to, amount);\\n        IWETH(data.weth).deposit{ value: amount }();\\n        TransferHelper.safeTransfer(data.weth, to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"Orders.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport 'SafeMath.sol';\\nimport 'Math.sol';\\nimport 'IIntegralFactory.sol';\\nimport 'IIntegralPair.sol';\\nimport 'TokenShares.sol';\\n\\nlibrary Orders {\\n    using SafeMath for uint256;\\n    using TokenShares for TokenShares.Data;\\n    using TransferHelper for address;\\n\\n    enum OrderType { Empty, Deposit, Withdraw, Sell, Buy }\\n    enum OrderStatus { NonExistent, EnqueuedWaiting, EnqueuedReady, ExecutedSucceeded, ExecutedFailed, Canceled }\\n\\n    event MaxGasLimitSet(uint256 maxGasLimit);\\n    event GasPriceInertiaSet(uint256 gasPriceInertia);\\n    event MaxGasPriceImpactSet(uint256 maxGasPriceImpact);\\n    event TransferGasCostSet(address token, uint256 gasCost);\\n\\n    event DepositEnqueued(uint256 indexed orderId, uint128 validAfterTimestamp, uint256 gasPrice);\\n    event WithdrawEnqueued(uint256 indexed orderId, uint128 validAfterTimestamp, uint256 gasPrice);\\n    event SellEnqueued(uint256 indexed orderId, uint128 validAfterTimestamp, uint256 gasPrice);\\n    event BuyEnqueued(uint256 indexed orderId, uint128 validAfterTimestamp, uint256 gasPrice);\\n\\n    uint8 private constant DEPOSIT_TYPE = 1;\\n    uint8 private constant WITHDRAW_TYPE = 2;\\n    uint8 private constant BUY_TYPE = 3;\\n    uint8 private constant BUY_INVERTED_TYPE = 4;\\n    uint8 private constant SELL_TYPE = 5;\\n    uint8 private constant SELL_INVERTED_TYPE = 6;\\n\\n    uint8 private constant UNWRAP_NOT_FAILED = 0;\\n    uint8 private constant KEEP_NOT_FAILED = 1;\\n    uint8 private constant UNWRAP_FAILED = 2;\\n    uint8 private constant KEEP_FAILED = 3;\\n\\n    uint256 private constant ETHER_TRANSFER_COST = 2300;\\n    uint256 private constant BUFFER_COST = 10000;\\n    uint256 private constant EXECUTE_PREPARATION_COST = 55000; // dequeue + getPair in execute\\n\\n    uint256 public constant ETHER_TRANSFER_CALL_COST = 10000;\\n    uint256 public constant PAIR_TRANSFER_COST = 55000;\\n    uint256 public constant REFUND_END_COST = 2 * ETHER_TRANSFER_COST + BUFFER_COST;\\n    uint256 public constant ORDER_BASE_COST = EXECUTE_PREPARATION_COST + REFUND_END_COST;\\n\\n    uint256 private constant TIMESTAMP_OFFSET = 1609455600; // 2021 Jan 1\\n\\n    struct PairInfo {\\n        address pair;\\n        address token0;\\n        address token1;\\n    }\\n\\n    struct Data {\\n        uint256 delay;\\n        uint256 newestOrderId;\\n        uint256 lastProcessedOrderId;\\n        mapping(uint256 => StoredOrder) orderQueue;\\n        address factory;\\n        uint256 maxGasLimit;\\n        uint256 gasPrice;\\n        uint256 gasPriceInertia;\\n        uint256 maxGasPriceImpact;\\n        mapping(uint32 => PairInfo) pairs;\\n        mapping(address => uint256) transferGasCosts;\\n        mapping(uint256 => bool) canceled;\\n        mapping(address => bool) depositDisabled;\\n        mapping(address => bool) withdrawDisabled;\\n        mapping(address => bool) buyDisabled;\\n        mapping(address => bool) sellDisabled;\\n    }\\n\\n    struct StoredOrder {\\n        // slot 1\\n        uint8 orderType;\\n        uint32 validAfterTimestamp;\\n        uint8 unwrapAndFailure;\\n        uint32 deadline;\\n        uint32 gasLimit;\\n        uint32 gasPrice;\\n        uint112 liquidityOrRatio;\\n        // slot 1\\n        uint112 value0;\\n        uint112 value1;\\n        uint32 pairId;\\n        // slot2\\n        address to;\\n        uint32 minRatioChangeToSwap;\\n        uint32 minSwapPrice;\\n        uint32 maxSwapPrice;\\n    }\\n\\n    struct DepositOrder {\\n        uint32 pairId;\\n        uint256 share0;\\n        uint256 share1;\\n        uint256 initialRatio;\\n        uint256 minRatioChangeToSwap;\\n        uint256 minSwapPrice;\\n        uint256 maxSwapPrice;\\n        bool unwrap;\\n        address to;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        uint256 deadline;\\n    }\\n\\n    struct WithdrawOrder {\\n        uint32 pairId;\\n        uint256 liquidity;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        bool unwrap;\\n        address to;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        uint256 deadline;\\n    }\\n\\n    struct SellOrder {\\n        uint32 pairId;\\n        bool inverse;\\n        uint256 shareIn;\\n        uint256 amountOutMin;\\n        bool unwrap;\\n        address to;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        uint256 deadline;\\n    }\\n\\n    struct BuyOrder {\\n        uint32 pairId;\\n        bool inverse;\\n        uint256 shareInMax;\\n        uint256 amountOut;\\n        bool unwrap;\\n        address to;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        uint256 deadline;\\n    }\\n\\n    function decodeType(uint256 internalType) internal pure returns (OrderType orderType) {\\n        if (internalType == DEPOSIT_TYPE) {\\n            orderType = OrderType.Deposit;\\n        } else if (internalType == WITHDRAW_TYPE) {\\n            orderType = OrderType.Withdraw;\\n        } else if (internalType == BUY_TYPE) {\\n            orderType = OrderType.Buy;\\n        } else if (internalType == BUY_INVERTED_TYPE) {\\n            orderType = OrderType.Buy;\\n        } else if (internalType == SELL_TYPE) {\\n            orderType = OrderType.Sell;\\n        } else if (internalType == SELL_INVERTED_TYPE) {\\n            orderType = OrderType.Sell;\\n        } else {\\n            orderType = OrderType.Empty;\\n        }\\n    }\\n\\n    function getOrder(Data storage data, uint256 orderId)\\n        public\\n        view\\n        returns (OrderType orderType, uint256 validAfterTimestamp)\\n    {\\n        StoredOrder storage order = data.orderQueue[orderId];\\n        uint8 internalType = order.orderType;\\n        validAfterTimestamp = uint32ToTimestamp(order.validAfterTimestamp);\\n        orderType = decodeType(internalType);\\n    }\\n\\n    function getOrderStatus(Data storage data, uint256 orderId) external view returns (OrderStatus orderStatus) {\\n        if (orderId > data.newestOrderId) {\\n            return OrderStatus.NonExistent;\\n        }\\n        if (data.canceled[orderId]) {\\n            return OrderStatus.Canceled;\\n        }\\n        if (isRefundFailed(data, orderId)) {\\n            return OrderStatus.ExecutedFailed;\\n        }\\n        (OrderType orderType, uint256 validAfterTimestamp) = getOrder(data, orderId);\\n        if (orderType == OrderType.Empty) {\\n            return OrderStatus.ExecutedSucceeded;\\n        }\\n        if (validAfterTimestamp >= block.timestamp) {\\n            return OrderStatus.EnqueuedWaiting;\\n        }\\n        return OrderStatus.EnqueuedReady;\\n    }\\n\\n    function getPair(\\n        Data storage data,\\n        address tokenA,\\n        address tokenB\\n    )\\n        internal\\n        returns (\\n            address pair,\\n            uint32 pairId,\\n            bool inverted\\n        )\\n    {\\n        inverted = tokenA > tokenB;\\n        (address token0, address token1) = inverted ? (tokenB, tokenA) : (tokenA, tokenB);\\n        pair = IIntegralFactory(data.factory).getPair(token0, token1);\\n        pairId = uint32(bytes4(keccak256(abi.encodePacked((pair)))));\\n        require(pair != address(0), 'OS_PAIR_NONEXISTENT');\\n        if (data.pairs[pairId].pair == address(0)) {\\n            data.pairs[pairId] = PairInfo(pair, token0, token1);\\n        }\\n    }\\n\\n    function getPairInfo(Data storage data, uint32 pairId)\\n        external\\n        view\\n        returns (\\n            address pair,\\n            address token0,\\n            address token1\\n        )\\n    {\\n        PairInfo storage info = data.pairs[pairId];\\n        pair = info.pair;\\n        token0 = info.token0;\\n        token1 = info.token1;\\n    }\\n\\n    function getDepositOrder(Data storage data, uint256 index) public view returns (DepositOrder memory order) {\\n        StoredOrder memory stored = data.orderQueue[index];\\n        require(stored.orderType == DEPOSIT_TYPE, 'OS_INVALID_ORDER_TYPE');\\n        order.pairId = stored.pairId;\\n        order.share0 = stored.value0;\\n        order.share1 = stored.value1;\\n        order.initialRatio = stored.liquidityOrRatio;\\n        order.minRatioChangeToSwap = stored.minRatioChangeToSwap;\\n        order.minSwapPrice = float32ToUint(stored.minSwapPrice);\\n        order.maxSwapPrice = float32ToUint(stored.maxSwapPrice);\\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\\n        order.to = stored.to;\\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\\n        order.gasLimit = stored.gasLimit;\\n        order.deadline = uint32ToTimestamp(stored.deadline);\\n    }\\n\\n    function getWithdrawOrder(Data storage data, uint256 index) public view returns (WithdrawOrder memory order) {\\n        StoredOrder memory stored = data.orderQueue[index];\\n        require(stored.orderType == WITHDRAW_TYPE, 'OS_INVALID_ORDER_TYPE');\\n        order.pairId = stored.pairId;\\n        order.liquidity = stored.liquidityOrRatio;\\n        order.amount0Min = stored.value0;\\n        order.amount1Min = stored.value1;\\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\\n        order.to = stored.to;\\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\\n        order.gasLimit = stored.gasLimit;\\n        order.deadline = uint32ToTimestamp(stored.deadline);\\n    }\\n\\n    function getSellOrder(Data storage data, uint256 index) public view returns (SellOrder memory order) {\\n        StoredOrder memory stored = data.orderQueue[index];\\n        require(stored.orderType == SELL_TYPE || stored.orderType == SELL_INVERTED_TYPE, 'OS_INVALID_ORDER_TYPE');\\n        order.pairId = stored.pairId;\\n        order.inverse = stored.orderType == SELL_INVERTED_TYPE;\\n        order.shareIn = stored.value0;\\n        order.amountOutMin = stored.value1;\\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\\n        order.to = stored.to;\\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\\n        order.gasLimit = stored.gasLimit;\\n        order.deadline = uint32ToTimestamp(stored.deadline);\\n    }\\n\\n    function getBuyOrder(Data storage data, uint256 index) public view returns (BuyOrder memory order) {\\n        StoredOrder memory stored = data.orderQueue[index];\\n        require(stored.orderType == BUY_TYPE || stored.orderType == BUY_INVERTED_TYPE, 'OS_INVALID_ORDER_TYPE');\\n        order.pairId = stored.pairId;\\n        order.inverse = stored.orderType == BUY_INVERTED_TYPE;\\n        order.shareInMax = stored.value0;\\n        order.amountOut = stored.value1;\\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\\n        order.to = stored.to;\\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\\n        order.gasLimit = stored.gasLimit;\\n        order.deadline = uint32ToTimestamp(stored.deadline);\\n    }\\n\\n    function getFailedOrderType(Data storage data, uint256 orderId)\\n        external\\n        view\\n        returns (OrderType orderType, uint256 validAfterTimestamp)\\n    {\\n        require(isRefundFailed(data, orderId), 'OS_NO_POSSIBLE_REFUND');\\n        (orderType, validAfterTimestamp) = getOrder(data, orderId);\\n    }\\n\\n    function getUnwrap(uint8 unwrapAndFailure) private pure returns (bool) {\\n        return unwrapAndFailure == UNWRAP_FAILED || unwrapAndFailure == UNWRAP_NOT_FAILED;\\n    }\\n\\n    function getUnwrapAndFailure(bool unwrap) private pure returns (uint8) {\\n        return unwrap ? UNWRAP_NOT_FAILED : KEEP_NOT_FAILED;\\n    }\\n\\n    function timestampToUint32(uint256 timestamp) private pure returns (uint32 timestamp32) {\\n        if (timestamp == uint256(-1)) {\\n            return uint32(-1);\\n        }\\n        timestamp32 = uintToUint32(timestamp.sub(TIMESTAMP_OFFSET));\\n    }\\n\\n    function uint32ToTimestamp(uint32 timestamp32) private pure returns (uint256 timestamp) {\\n        if (timestamp32 == uint32(-1)) {\\n            return uint256(-1);\\n        }\\n        if (timestamp32 == 0) {\\n            return 0;\\n        }\\n        timestamp = uint256(timestamp32) + TIMESTAMP_OFFSET;\\n    }\\n\\n    function gasPriceToUint32(uint256 gasPrice) private pure returns (uint32 gasPrice32) {\\n        require((gasPrice / 1e6) * 1e6 == gasPrice, 'OS_GAS_PRICE_PRECISION');\\n        gasPrice32 = uintToUint32(gasPrice / 1e6);\\n    }\\n\\n    function uint32ToGasPrice(uint32 gasPrice32) public pure returns (uint256 gasPrice) {\\n        gasPrice = uint256(gasPrice32) * 1e6;\\n    }\\n\\n    function uintToUint32(uint256 number) private pure returns (uint32 number32) {\\n        number32 = uint32(number);\\n        require(uint256(number32) == number, 'OS_OVERFLOW_32');\\n    }\\n\\n    function uintToUint112(uint256 number) private pure returns (uint112 number112) {\\n        number112 = uint112(number);\\n        require(uint256(number112) == number, 'OS_OVERFLOW_112');\\n    }\\n\\n    function uintToFloat32(uint256 number) internal pure returns (uint32 float32) {\\n        // Number is encoded on 4 bytes. 3 bytes for mantissa and 1 for exponent.\\n        // If the number fits in the mantissa we set the exponent to zero and return.\\n        if (number < 2 << 24) {\\n            return uint32(number << 8);\\n        }\\n        // We find the exponent by counting the number of trailing zeroes.\\n        // Simultaneously we remove those zeroes from the number.\\n        uint32 exponent;\\n        for (exponent = 0; exponent < 256 - 24; exponent++) {\\n            // Last bit is one.\\n            if (number & 1 == 1) {\\n                break;\\n            }\\n            number = number >> 1;\\n        }\\n        // The number must fit in the mantissa.\\n        require(number < 2 << 24, 'OS_OVERFLOW_FLOAT_ENCODE');\\n        // Set the first three bytes to the number and the fourth to the exponent.\\n        float32 = uint32(number << 8) | exponent;\\n    }\\n\\n    function float32ToUint(uint32 float32) internal pure returns (uint256 number) {\\n        // Number is encoded on 4 bytes. 3 bytes for mantissa and 1 for exponent.\\n        // We get the exponent by extracting the last byte.\\n        uint256 exponent = float32 & 0xFF;\\n        // Sanity check. Only triggered for values not encoded with uintToFloat32.\\n        require(exponent <= 256 - 24, 'OS_OVERFLOW_FLOAT_DECODE');\\n        // We get the mantissa by extracting the first three bytes and removing the fourth.\\n        uint256 mantissa = (float32 & 0xFFFFFF00) >> 8;\\n        // We add exponent number zeroes after the mantissa.\\n        number = mantissa << exponent;\\n    }\\n\\n    function enqueueDepositOrder(Data storage data, DepositOrder memory depositOrder) internal {\\n        data.newestOrderId++;\\n        uint128 validAfterTimestamp = uint128(block.timestamp + data.delay);\\n        emit DepositEnqueued(data.newestOrderId, validAfterTimestamp, depositOrder.gasPrice);\\n        data.orderQueue[data.newestOrderId] = StoredOrder(\\n            DEPOSIT_TYPE,\\n            timestampToUint32(validAfterTimestamp),\\n            getUnwrapAndFailure(depositOrder.unwrap),\\n            timestampToUint32(depositOrder.deadline),\\n            uintToUint32(depositOrder.gasLimit),\\n            gasPriceToUint32(depositOrder.gasPrice),\\n            uintToUint112(depositOrder.initialRatio),\\n            uintToUint112(depositOrder.share0),\\n            uintToUint112(depositOrder.share1),\\n            depositOrder.pairId,\\n            depositOrder.to,\\n            uint32(depositOrder.minRatioChangeToSwap),\\n            uintToFloat32(depositOrder.minSwapPrice),\\n            uintToFloat32(depositOrder.maxSwapPrice)\\n        );\\n    }\\n\\n    function enqueueWithdrawOrder(Data storage data, WithdrawOrder memory withdrawOrder) internal {\\n        data.newestOrderId++;\\n        uint128 validAfterTimestamp = uint128(block.timestamp + data.delay);\\n        emit WithdrawEnqueued(data.newestOrderId, validAfterTimestamp, withdrawOrder.gasPrice);\\n        data.orderQueue[data.newestOrderId] = StoredOrder(\\n            WITHDRAW_TYPE,\\n            timestampToUint32(validAfterTimestamp),\\n            getUnwrapAndFailure(withdrawOrder.unwrap),\\n            timestampToUint32(withdrawOrder.deadline),\\n            uintToUint32(withdrawOrder.gasLimit),\\n            gasPriceToUint32(withdrawOrder.gasPrice),\\n            uintToUint112(withdrawOrder.liquidity),\\n            uintToUint112(withdrawOrder.amount0Min),\\n            uintToUint112(withdrawOrder.amount1Min),\\n            withdrawOrder.pairId,\\n            withdrawOrder.to,\\n            0, // maxRatioChange\\n            0, // minSwapPrice\\n            0 // maxSwapPrice\\n        );\\n    }\\n\\n    function enqueueSellOrder(Data storage data, SellOrder memory sellOrder) internal {\\n        data.newestOrderId++;\\n        uint128 validAfterTimestamp = uint128(block.timestamp + data.delay);\\n        emit SellEnqueued(data.newestOrderId, validAfterTimestamp, sellOrder.gasPrice);\\n        data.orderQueue[data.newestOrderId] = StoredOrder(\\n            sellOrder.inverse ? SELL_INVERTED_TYPE : SELL_TYPE,\\n            timestampToUint32(validAfterTimestamp),\\n            getUnwrapAndFailure(sellOrder.unwrap),\\n            timestampToUint32(sellOrder.deadline),\\n            uintToUint32(sellOrder.gasLimit),\\n            gasPriceToUint32(sellOrder.gasPrice),\\n            0, // liquidityOrRatio\\n            uintToUint112(sellOrder.shareIn),\\n            uintToUint112(sellOrder.amountOutMin),\\n            sellOrder.pairId,\\n            sellOrder.to,\\n            0, // maxRatioChange\\n            0, // minSwapPrice\\n            0 // maxSwapPrice\\n        );\\n    }\\n\\n    function enqueueBuyOrder(Data storage data, BuyOrder memory buyOrder) internal {\\n        data.newestOrderId++;\\n        uint128 validAfterTimestamp = uint128(block.timestamp + data.delay);\\n        emit BuyEnqueued(data.newestOrderId, validAfterTimestamp, buyOrder.gasPrice);\\n        data.orderQueue[data.newestOrderId] = StoredOrder(\\n            buyOrder.inverse ? BUY_INVERTED_TYPE : BUY_TYPE,\\n            timestampToUint32(validAfterTimestamp),\\n            getUnwrapAndFailure(buyOrder.unwrap),\\n            timestampToUint32(buyOrder.deadline),\\n            uintToUint32(buyOrder.gasLimit),\\n            gasPriceToUint32(buyOrder.gasPrice),\\n            0, // liquidityOrRatio\\n            uintToUint112(buyOrder.shareInMax),\\n            uintToUint112(buyOrder.amountOut),\\n            buyOrder.pairId,\\n            buyOrder.to,\\n            0, // maxRatioChange\\n            0, // minSwapPrice\\n            0 // maxSwapPrice\\n        );\\n    }\\n\\n    function isRefundFailed(Data storage data, uint256 index) internal view returns (bool) {\\n        uint8 unwrapAndFailure = data.orderQueue[index].unwrapAndFailure;\\n        return unwrapAndFailure == UNWRAP_FAILED || unwrapAndFailure == KEEP_FAILED;\\n    }\\n\\n    function markRefundFailed(Data storage data) internal {\\n        StoredOrder storage stored = data.orderQueue[data.lastProcessedOrderId];\\n        stored.unwrapAndFailure = stored.unwrapAndFailure == UNWRAP_NOT_FAILED ? UNWRAP_FAILED : KEEP_FAILED;\\n    }\\n\\n    function getNextOrder(Data storage data) internal view returns (OrderType orderType, uint256 validAfterTimestamp) {\\n        return getOrder(data, data.lastProcessedOrderId + 1);\\n    }\\n\\n    function dequeueCanceledOrder(Data storage data) external {\\n        data.lastProcessedOrderId++;\\n    }\\n\\n    function dequeueDepositOrder(Data storage data) external returns (DepositOrder memory order) {\\n        data.lastProcessedOrderId++;\\n        order = getDepositOrder(data, data.lastProcessedOrderId);\\n    }\\n\\n    function dequeueWithdrawOrder(Data storage data) external returns (WithdrawOrder memory order) {\\n        data.lastProcessedOrderId++;\\n        order = getWithdrawOrder(data, data.lastProcessedOrderId);\\n    }\\n\\n    function dequeueSellOrder(Data storage data) external returns (SellOrder memory order) {\\n        data.lastProcessedOrderId++;\\n        order = getSellOrder(data, data.lastProcessedOrderId);\\n    }\\n\\n    function dequeueBuyOrder(Data storage data) external returns (BuyOrder memory order) {\\n        data.lastProcessedOrderId++;\\n        order = getBuyOrder(data, data.lastProcessedOrderId);\\n    }\\n\\n    function forgetOrder(Data storage data, uint256 orderId) internal {\\n        delete data.orderQueue[orderId];\\n    }\\n\\n    function forgetLastProcessedOrder(Data storage data) internal {\\n        delete data.orderQueue[data.lastProcessedOrderId];\\n    }\\n\\n    struct DepositParams {\\n        address token0;\\n        address token1;\\n        uint256 amount0;\\n        uint256 amount1;\\n        uint256 initialRatio;\\n        uint256 minRatioChangeToSwap;\\n        uint256 minSwapPrice;\\n        uint256 maxSwapPrice;\\n        bool wrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint256 submitDeadline;\\n        uint256 executionDeadline;\\n    }\\n\\n    function deposit(\\n        Data storage data,\\n        DepositParams calldata depositParams,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        require(\\n            data.transferGasCosts[depositParams.token0] != 0 && data.transferGasCosts[depositParams.token1] != 0,\\n            'OS_TOKEN_TRANSFER_GAS_COST_UNSET'\\n        );\\n        checkOrderParams(\\n            data,\\n            depositParams.to,\\n            depositParams.gasLimit,\\n            depositParams.submitDeadline,\\n            depositParams.executionDeadline,\\n            ORDER_BASE_COST.add(data.transferGasCosts[depositParams.token0]).add(\\n                data.transferGasCosts[depositParams.token1]\\n            )\\n        );\\n        require(depositParams.amount0 != 0 || depositParams.amount1 != 0, 'OS_NO_AMOUNT');\\n        (address pair, uint32 pairId, bool inverted) = getPair(data, depositParams.token0, depositParams.token1);\\n        require(!data.depositDisabled[pair], 'OS_DEPOSIT_DISABLED');\\n\\n        uint256 value = msg.value;\\n\\n        // allocate gas refund\\n        if (depositParams.token0 == tokenShares.weth && depositParams.wrap) {\\n            value = value.sub(depositParams.amount0, 'OS_NOT_ENOUGH_FUNDS');\\n        } else if (depositParams.token1 == tokenShares.weth && depositParams.wrap) {\\n            value = value.sub(depositParams.amount1, 'OS_NOT_ENOUGH_FUNDS');\\n        }\\n        allocateGasRefund(data, value, depositParams.gasLimit);\\n\\n        uint256 shares0 = tokenShares.amountToShares(depositParams.token0, depositParams.amount0, depositParams.wrap);\\n        uint256 shares1 = tokenShares.amountToShares(depositParams.token1, depositParams.amount1, depositParams.wrap);\\n\\n        IIntegralPair(pair).syncWithOracle();\\n        enqueueDepositOrder(\\n            data,\\n            DepositOrder(\\n                pairId,\\n                inverted ? shares1 : shares0,\\n                inverted ? shares0 : shares1,\\n                depositParams.initialRatio,\\n                depositParams.minRatioChangeToSwap,\\n                depositParams.minSwapPrice,\\n                depositParams.maxSwapPrice,\\n                depositParams.wrap,\\n                depositParams.to,\\n                data.gasPrice,\\n                depositParams.gasLimit,\\n                depositParams.executionDeadline\\n            )\\n        );\\n    }\\n\\n    struct WithdrawParams {\\n        address token0;\\n        address token1;\\n        uint256 liquidity;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        bool unwrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint256 submitDeadline;\\n        uint256 executionDeadline;\\n    }\\n\\n    function withdraw(Data storage data, WithdrawParams calldata withdrawParams) external {\\n        (address pair, uint32 pairId, bool inverted) = getPair(data, withdrawParams.token0, withdrawParams.token1);\\n        require(!data.withdrawDisabled[pair], 'OS_WITHDRAW_DISABLED');\\n        checkOrderParams(\\n            data,\\n            withdrawParams.to,\\n            withdrawParams.gasLimit,\\n            withdrawParams.submitDeadline,\\n            withdrawParams.executionDeadline,\\n            ORDER_BASE_COST.add(PAIR_TRANSFER_COST)\\n        );\\n        require(withdrawParams.liquidity != 0, 'OS_NO_LIQUIDITY');\\n\\n        allocateGasRefund(data, msg.value, withdrawParams.gasLimit);\\n        pair.safeTransferFrom(msg.sender, address(this), withdrawParams.liquidity);\\n\\n        IIntegralPair(pair).syncWithOracle();\\n        enqueueWithdrawOrder(\\n            data,\\n            WithdrawOrder(\\n                pairId,\\n                withdrawParams.liquidity,\\n                inverted ? withdrawParams.amount1Min : withdrawParams.amount0Min,\\n                inverted ? withdrawParams.amount0Min : withdrawParams.amount1Min,\\n                withdrawParams.unwrap,\\n                withdrawParams.to,\\n                data.gasPrice,\\n                withdrawParams.gasLimit,\\n                withdrawParams.executionDeadline\\n            )\\n        );\\n    }\\n\\n    struct SellParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountIn;\\n        uint256 amountOutMin;\\n        bool wrapUnwrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint256 submitDeadline;\\n        uint256 executionDeadline;\\n    }\\n\\n    function sell(\\n        Data storage data,\\n        SellParams calldata sellParams,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        require(data.transferGasCosts[sellParams.tokenIn] != 0, 'OS_TOKEN_TRANSFER_GAS_COST_UNSET');\\n        checkOrderParams(\\n            data,\\n            sellParams.to,\\n            sellParams.gasLimit,\\n            sellParams.submitDeadline,\\n            sellParams.executionDeadline,\\n            ORDER_BASE_COST.add(data.transferGasCosts[sellParams.tokenIn])\\n        );\\n        require(sellParams.amountIn != 0, 'OS_NO_AMOUNT_IN');\\n        (address pair, uint32 pairId, bool inverted) = getPair(data, sellParams.tokenIn, sellParams.tokenOut);\\n        require(!data.sellDisabled[pair], 'OS_SELL_DISABLED');\\n        uint256 value = msg.value;\\n\\n        // allocate gas refund\\n        if (sellParams.tokenIn == tokenShares.weth && sellParams.wrapUnwrap) {\\n            value = value.sub(sellParams.amountIn, 'OS_NOT_ENOUGH_FUNDS');\\n        }\\n        allocateGasRefund(data, value, sellParams.gasLimit);\\n\\n        uint256 shares = tokenShares.amountToShares(sellParams.tokenIn, sellParams.amountIn, sellParams.wrapUnwrap);\\n\\n        IIntegralPair(pair).syncWithOracle();\\n        enqueueSellOrder(\\n            data,\\n            SellOrder(\\n                pairId,\\n                inverted,\\n                shares,\\n                sellParams.amountOutMin,\\n                sellParams.wrapUnwrap,\\n                sellParams.to,\\n                data.gasPrice,\\n                sellParams.gasLimit,\\n                sellParams.executionDeadline\\n            )\\n        );\\n    }\\n\\n    struct BuyParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountInMax;\\n        uint256 amountOut;\\n        bool wrapUnwrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint256 submitDeadline;\\n        uint256 executionDeadline;\\n    }\\n\\n    function buy(\\n        Data storage data,\\n        BuyParams calldata buyParams,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        require(data.transferGasCosts[buyParams.tokenIn] != 0, 'OS_TOKEN_TRANSFER_GAS_COST_UNSET');\\n        checkOrderParams(\\n            data,\\n            buyParams.to,\\n            buyParams.gasLimit,\\n            buyParams.submitDeadline,\\n            buyParams.executionDeadline,\\n            ORDER_BASE_COST.add(data.transferGasCosts[buyParams.tokenIn])\\n        );\\n        require(buyParams.amountOut != 0, 'OS_NO_AMOUNT_OUT');\\n        (address pair, uint32 pairId, bool inverted) = getPair(data, buyParams.tokenIn, buyParams.tokenOut);\\n        require(!data.buyDisabled[pair], 'OS_BUY_DISABLED');\\n\\n        uint256 value = msg.value;\\n\\n        // allocate gas refund\\n        if (buyParams.tokenIn == tokenShares.weth && buyParams.wrapUnwrap) {\\n            value = value.sub(buyParams.amountInMax, 'OS_NOT_ENOUGH_FUNDS');\\n        }\\n        allocateGasRefund(data, value, buyParams.gasLimit);\\n\\n        uint256 shares = tokenShares.amountToShares(buyParams.tokenIn, buyParams.amountInMax, buyParams.wrapUnwrap);\\n\\n        IIntegralPair(pair).syncWithOracle();\\n        enqueueBuyOrder(\\n            data,\\n            BuyOrder(\\n                pairId,\\n                inverted,\\n                shares,\\n                buyParams.amountOut,\\n                buyParams.wrapUnwrap,\\n                buyParams.to,\\n                data.gasPrice,\\n                buyParams.gasLimit,\\n                buyParams.executionDeadline\\n            )\\n        );\\n    }\\n\\n    function checkOrderParams(\\n        Data storage data,\\n        address to,\\n        uint256 gasLimit,\\n        uint256 submitDeadline,\\n        uint256 executionDeadline,\\n        uint256 minGasLimit\\n    ) private view {\\n        require(submitDeadline >= block.timestamp, 'OS_EXPIRED');\\n        require(executionDeadline > block.timestamp.add(data.delay), 'OS_INVALID_DEADLINE');\\n        require(gasLimit <= data.maxGasLimit, 'OS_GAS_LIMIT_TOO_HIGH');\\n        require(gasLimit >= minGasLimit, 'OS_GAS_LIMIT_TOO_LOW');\\n        require(to != address(0), 'OS_NO_ADDRESS');\\n    }\\n\\n    function allocateGasRefund(\\n        Data storage data,\\n        uint256 value,\\n        uint256 gasLimit\\n    ) private returns (uint256 futureFee) {\\n        futureFee = data.gasPrice.mul(gasLimit);\\n        require(value >= futureFee, 'OS_NOT_ENOUGH_FUNDS');\\n        if (value > futureFee) {\\n            msg.sender.transfer(value.sub(futureFee));\\n        }\\n    }\\n\\n    function updateGasPrice(Data storage data, uint256 gasUsed) external {\\n        uint256 scale = Math.min(gasUsed, data.maxGasPriceImpact);\\n        uint256 updated = data.gasPrice.mul(data.gasPriceInertia.sub(scale)).add(tx.gasprice.mul(scale)).div(\\n            data.gasPriceInertia\\n        );\\n        // we lower the precision for gas savings in order queue\\n        data.gasPrice = updated - (updated % 1e6);\\n    }\\n\\n    function setMaxGasLimit(Data storage data, uint256 _maxGasLimit) external {\\n        require(_maxGasLimit <= 10000000, 'OS_MAX_GAS_LIMIT_TOO_HIGH');\\n        data.maxGasLimit = _maxGasLimit;\\n        emit MaxGasLimitSet(_maxGasLimit);\\n    }\\n\\n    function setGasPriceInertia(Data storage data, uint256 _gasPriceInertia) external {\\n        require(_gasPriceInertia >= 1, 'OS_INVALID_INERTIA');\\n        data.gasPriceInertia = _gasPriceInertia;\\n        emit GasPriceInertiaSet(_gasPriceInertia);\\n    }\\n\\n    function setMaxGasPriceImpact(Data storage data, uint256 _maxGasPriceImpact) external {\\n        require(_maxGasPriceImpact <= data.gasPriceInertia, 'OS_INVALID_MAX_GAS_PRICE_IMPACT');\\n        data.maxGasPriceImpact = _maxGasPriceImpact;\\n        emit MaxGasPriceImpactSet(_maxGasPriceImpact);\\n    }\\n\\n    function setTransferGasCost(\\n        Data storage data,\\n        address token,\\n        uint256 gasCost\\n    ) external {\\n        data.transferGasCosts[token] = gasCost;\\n        emit TransferGasCostSet(token, gasCost);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"libraries\": {\r\n      \"SafeMath.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\"\r\n      },\r\n      \"Math.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\"\r\n      },\r\n      \"IIntegralFactory.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\"\r\n      },\r\n      \"IERC20.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\"\r\n      },\r\n      \"IIntegralERC20.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\"\r\n      },\r\n      \"IReserves.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\"\r\n      },\r\n      \"IIntegralPair.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\"\r\n      },\r\n      \"IWETH.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\"\r\n      },\r\n      \"TransferHelper.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\"\r\n      },\r\n      \"TokenShares.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\"\r\n      },\r\n      \"Orders.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\"\r\n      }\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"language\": \"Solidity\"\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"validAfterTimestamp\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"}],\"name\":\"BuyEnqueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"validAfterTimestamp\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"}],\"name\":\"DepositEnqueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasPriceInertia\",\"type\":\"uint256\"}],\"name\":\"GasPriceInertiaSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxGasLimit\",\"type\":\"uint256\"}],\"name\":\"MaxGasLimitSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxGasPriceImpact\",\"type\":\"uint256\"}],\"name\":\"MaxGasPriceImpactSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"validAfterTimestamp\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"}],\"name\":\"SellEnqueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasCost\",\"type\":\"uint256\"}],\"name\":\"TransferGasCostSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"validAfterTimestamp\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"}],\"name\":\"WithdrawEnqueued\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETHER_TRANSFER_CALL_COST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ORDER_BASE_COST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAIR_TRANSFER_COST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFUND_END_COST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"gasPrice32\",\"type\":\"uint32\"}],\"name\":\"uint32ToGasPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"Orders","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"TokenShares:c82938b53e0e190459ba4e3502bf26f194760183","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}