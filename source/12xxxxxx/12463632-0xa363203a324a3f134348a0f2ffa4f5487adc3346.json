{"status":"1","message":"OK","result":[{"SourceCode":"{\"CrowdProposal.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport \\u0027./ICompound.sol\\u0027;\\n\\ncontract CrowdProposal {\\n    /// @notice The crowd proposal author\\n    address payable public immutable author;\\n\\n    /// @notice Governance proposal data\\n    address[] public targets;\\n    uint[] public values;\\n    string[] public signatures;\\n    bytes[] public calldatas;\\n    string public description;\\n\\n    /// @notice COMP token contract address\\n    address public immutable comp;\\n    /// @notice Compound protocol `GovernorBravo` contract address\\n    address public immutable governor;\\n\\n    /// @notice Governance proposal id\\n    uint public govProposalId;\\n    /// @notice Terminate flag\\n    bool public terminated;\\n\\n    /// @notice An event emitted when the governance proposal is created\\n    event CrowdProposalProposed(address indexed proposal, address indexed author, uint proposalId);\\n    /// @notice An event emitted when the crowd proposal is terminated\\n    event CrowdProposalTerminated(address indexed proposal, address indexed author);\\n     /// @notice An event emitted when delegated votes are transfered to the governance proposal\\n    event CrowdProposalVoted(address indexed proposal, uint proposalId);\\n\\n    /**\\n    * @notice Construct crowd proposal\\n    * @param author_ The crowd proposal author\\n    * @param targets_ The ordered list of target addresses for calls to be made\\n    * @param values_ The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\n    * @param signatures_ The ordered list of function signatures to be called\\n    * @param calldatas_ The ordered list of calldata to be passed to each call\\n    * @param description_ The block at which voting begins: holders must delegate their votes prior to this block\\n    * @param comp_ `COMP` token contract address\\n    * @param governor_ Compound protocol `GovernorBravo` contract address\\n    */\\n    constructor(address payable author_,\\n                address[] memory targets_,\\n                uint[] memory values_,\\n                string[] memory signatures_,\\n                bytes[] memory calldatas_,\\n                string memory description_,\\n                address comp_,\\n                address governor_) public {\\n        author = author_;\\n\\n        // Save proposal data\\n        targets = targets_;\\n        values = values_;\\n        signatures = signatures_;\\n        calldatas = calldatas_;\\n        description = description_;\\n\\n        // Save Compound contracts data\\n        comp = comp_;\\n        governor = governor_;\\n\\n        terminated = false;\\n\\n        // Delegate votes to the crowd proposal\\n        IComp(comp_).delegate(address(this));\\n    }\\n\\n    /// @notice Create governance proposal\\n    function propose() external returns (uint) {\\n        require(govProposalId == 0, \\u0027CrowdProposal::propose: gov proposal already exists\\u0027);\\n        require(!terminated, \\u0027CrowdProposal::propose: proposal has been terminated\\u0027);\\n\\n        // Create governance proposal and save proposal id\\n        govProposalId = IGovernorBravo(governor).propose(targets, values, signatures, calldatas, description);\\n        emit CrowdProposalProposed(address(this), author, govProposalId);\\n\\n        return govProposalId;\\n    }\\n\\n    /// @notice Terminate the crowd proposal, send back staked COMP tokens\\n    function terminate() external {\\n        require(msg.sender == author, \\u0027CrowdProposal::terminate: only author can terminate\\u0027);\\n        require(!terminated, \\u0027CrowdProposal::terminate: proposal has been already terminated\\u0027);\\n\\n        terminated = true;\\n\\n        // Transfer staked COMP tokens from the crowd proposal contract back to the author\\n        IComp(comp).transfer(author, IComp(comp).balanceOf(address(this)));\\n\\n        emit CrowdProposalTerminated(address(this), author);\\n    }\\n\\n    /// @notice Vote for the governance proposal with all delegated votes\\n    function vote() external {\\n        require(govProposalId \\u003e 0, \\u0027CrowdProposal::vote: gov proposal has not been created yet\\u0027);\\n        // Support the proposal, vote value = 1\\n        IGovernorBravo(governor).castVote(govProposalId, 1);\\n\\n        emit CrowdProposalVoted(address(this), govProposalId);\\n    }\\n}\\n\"},\"CrowdProposalFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport \\u0027./ICompound.sol\\u0027;\\nimport \\u0027./CrowdProposal.sol\\u0027;\\n\\ncontract CrowdProposalFactory {\\n    /// @notice `COMP` token contract address\\n    address public immutable comp;\\n    /// @notice Compound protocol `GovernorBravo` contract address\\n    address public immutable governor;\\n    /// @notice Minimum Comp tokens required to create a crowd proposal\\n    uint public immutable compStakeAmount;\\n\\n    /// @notice An event emitted when a crowd proposal is created\\n    event CrowdProposalCreated(address indexed proposal, address indexed author, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, string description);\\n\\n     /**\\n     * @notice Construct a proposal factory for crowd proposals\\n     * @param comp_ `COMP` token contract address\\n     * @param governor_ Compound protocol `GovernorBravo` contract address\\n     * @param compStakeAmount_ The minimum amount of Comp tokes required for creation of a crowd proposal\\n     */\\n    constructor(address comp_,\\n                address governor_,\\n                uint compStakeAmount_) public {\\n        comp = comp_;\\n        governor = governor_;\\n        compStakeAmount = compStakeAmount_;\\n    }\\n\\n    /**\\n    * @notice Create a new crowd proposal\\n    * @notice Call `Comp.approve(factory_address, compStakeAmount)` before calling this method\\n    * @param targets The ordered list of target addresses for calls to be made\\n    * @param values The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\n    * @param signatures The ordered list of function signatures to be called\\n    * @param calldatas The ordered list of calldata to be passed to each call\\n    * @param description The block at which voting begins: holders must delegate their votes prior to this block\\n    */\\n    function createCrowdProposal(address[] memory targets,\\n                                 uint[] memory values,\\n                                 string[] memory signatures,\\n                                 bytes[] memory calldatas,\\n                                 string memory description) external {\\n        CrowdProposal proposal = new CrowdProposal(msg.sender, targets, values, signatures, calldatas, description, comp, governor);\\n        emit CrowdProposalCreated(address(proposal), msg.sender, targets, values, signatures, calldatas, description);\\n\\n        // Stake COMP and force proposal to delegate votes to itself\\n        IComp(comp).transferFrom(msg.sender, address(proposal), compStakeAmount);\\n    }\\n}\\n\"},\"ICompound.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\ninterface IComp {\\n    function delegate(address delegatee) external;\\n    function balanceOf(address account) external view returns (uint);\\n    function transfer(address dst, uint rawAmount) external returns (bool);\\n    function transferFrom(address src, address dst, uint rawAmount) external returns (bool);\\n}\\n\\ninterface IGovernorBravo {\\n    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) external returns (uint);\\n    function castVote(uint proposalId, uint8 support) external;\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"comp_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"governor_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"compStakeAmount_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposal\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"CrowdProposalCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"comp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compStakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"createCrowdProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CrowdProposalFactory","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000001f9840a85d5af5bf1d1762f925bdaddc4201f9840000000000000000000000005e4be8bc9637f0eaa1a755019e06a68ce081d58f0000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6b72e2312b38238f2f3f21807dd4bcfa17b046ec4142d9563d5455dfe34e52b3"}]}