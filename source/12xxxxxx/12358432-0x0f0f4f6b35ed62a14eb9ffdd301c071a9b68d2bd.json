{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ShareMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"./libraries/FullMath.sol\\\";\\nimport \\\"./interfaces/IHEX.sol\\\";\\nimport \\\"./MinterReceiver.sol\\\";\\n\\n/// @title HEX Share Minter\\n/// @author Sam Presnal - Staker\\n/// @dev Mint shares to any receiving contract that implements the\\n/// MinterReceiver abstract contract\\n/// @notice Minter rewards are claimable by ANY caller\\n/// if the 10 day grace period has expired\\ncontract ShareMinter {\\n    IHEX public hexContract;\\n\\n    uint256 private constant GRACE_PERIOD_DAYS = 10;\\n    uint256 private constant FEE_SCALE = 1000;\\n\\n    struct Stake {\\n        uint16 shareRatePremium;\\n        uint24 unlockDay;\\n        address minter;\\n        MinterReceiver receiver;\\n    }\\n    mapping(uint40 => Stake) public stakes;\\n\\n    mapping(address => uint256) public minterHeartsOwed;\\n\\n    event MintShares(\\n        uint40 indexed stakeId,\\n        MinterReceiver indexed receiver,\\n        uint256 data0 //total shares | staked hearts << 72\\n    );\\n    event MintEarnings(uint40 indexed stakeId, MinterReceiver indexed receiver, uint72 hearts);\\n    event MinterWithdraw(address indexed minter, uint256 heartsWithdrawn);\\n\\n    uint256 private unlocked = 1;\\n    modifier lock() {\\n        require(unlocked == 1, \\\"LOCKED\\\");\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    constructor(IHEX _hex) {\\n        hexContract = _hex;\\n    }\\n\\n    /// @notice Starts stake and mints shares to the specified receiver\\n    /// @param shareRatePremium Applies premium to share price between 0.0-99.9%\\n    /// @param receiver The contract to receive the newly minted shares\\n    /// @param supplier The reimbursement address for the supplier\\n    /// @param newStakedHearts Hearts to stake to the HEX contract\\n    /// @param newStakedDays Days in length of the stake\\n    function mintShares(\\n        uint16 shareRatePremium,\\n        MinterReceiver receiver,\\n        address supplier,\\n        uint256 newStakedHearts,\\n        uint256 newStakedDays\\n    ) external lock {\\n        require(shareRatePremium < FEE_SCALE, \\\"PREMIUM_TOO_HIGH\\\");\\n        require(\\n            ERC165Checker.supportsInterface(address(receiver), type(MinterReceiver).interfaceId),\\n            \\\"UNSUPPORTED_RECEIVER\\\"\\n        );\\n\\n        //Transfer HEX to contract\\n        hexContract.transferFrom(msg.sender, address(this), newStakedHearts);\\n\\n        //Start stake\\n        (uint40 stakeId, uint72 stakedHearts, uint72 stakeShares, uint24 unlockDay) =\\n            _startStake(newStakedHearts, newStakedDays);\\n\\n        //Calculate minterShares and marketShares\\n        uint256 minterShares = FullMath.mulDiv(shareRatePremium, stakeShares, FEE_SCALE);\\n        uint256 marketShares = stakeShares - minterShares;\\n\\n        //Mint shares to the market and store stake info for later\\n        receiver.onSharesMinted(stakeId, supplier, stakedHearts, uint72(marketShares));\\n        stakes[stakeId] = Stake(shareRatePremium, unlockDay, msg.sender, receiver);\\n\\n        emit MintShares(stakeId, receiver, uint256(uint72(stakeShares)) | (uint256(uint72(stakedHearts)) << 72));\\n    }\\n\\n    function _startStake(uint256 newStakedHearts, uint256 newStakedDays)\\n        internal\\n        returns (\\n            uint40 stakeId,\\n            uint72 stakedHearts,\\n            uint72 stakeShares,\\n            uint24 unlockDay\\n        )\\n    {\\n        hexContract.stakeStart(newStakedHearts, newStakedDays);\\n        uint256 stakeCount = hexContract.stakeCount(address(this));\\n        (uint40 _stakeId, uint72 _stakedHearts, uint72 _stakeShares, uint16 _lockedDay, uint16 _stakedDays, , ) =\\n            hexContract.stakeLists(address(this), stakeCount - 1);\\n        return (_stakeId, _stakedHearts, _stakeShares, _lockedDay + _stakedDays);\\n    }\\n\\n    /// @notice Ends stake, transfers hearts, and calls receiver onEarningsMinted\\n    /// @dev The stake must be mature in order to mint earnings\\n    /// @param stakeIndex Index of the stake to be ended\\n    /// @param stakeId StakeId of the stake to be ended\\n    function mintEarnings(uint256 stakeIndex, uint40 stakeId) external lock {\\n        //Ensure the stake has matured\\n        Stake memory stake = stakes[stakeId];\\n        uint256 currentDay = hexContract.currentDay();\\n        require(currentDay >= stake.unlockDay, \\\"STAKE_NOT_MATURE\\\");\\n\\n        //Calculate minter earnings and market earnings\\n        uint256 heartsEarned = _endStake(stakeIndex, stakeId);\\n        uint256 minterEarnings = FullMath.mulDiv(stake.shareRatePremium, heartsEarned, FEE_SCALE);\\n        uint256 marketEarnings = heartsEarned - minterEarnings;\\n\\n        //Transfer market earnings to receiver contract and notify\\n        MinterReceiver receiver = stake.receiver;\\n        hexContract.transfer(address(receiver), marketEarnings);\\n        receiver.onEarningsMinted(stakeId, uint72(marketEarnings));\\n\\n        //Pay minter or record payment for claiming later\\n        _payMinterEarnings(currentDay, stake.unlockDay, stake.minter, minterEarnings);\\n\\n        emit MintEarnings(stakeId, receiver, uint72(heartsEarned));\\n\\n        delete stakes[stakeId];\\n    }\\n\\n    function _endStake(uint256 stakeIndex, uint40 stakeId) internal returns (uint256 heartsEarned) {\\n        uint256 prevHearts = hexContract.balanceOf(address(this));\\n        hexContract.stakeEnd(stakeIndex, stakeId);\\n        uint256 newHearts = hexContract.balanceOf(address(this));\\n        heartsEarned = newHearts - prevHearts;\\n    }\\n\\n    /// @notice The minter earnings are claimable by any caller\\n    /// if the grace period has expired. If the grace period has\\n    /// not expired and the minter is not the caller, then record\\n    /// the minter earnings. If the minter is the caller,\\n    /// they will get the earnings sent immediately.\\n    function _payMinterEarnings(\\n        uint256 currentDay,\\n        uint256 unlockDay,\\n        address minter,\\n        uint256 minterEarnings\\n    ) internal {\\n        uint256 lateDays = currentDay - unlockDay;\\n        if (msg.sender != minter && lateDays < GRACE_PERIOD_DAYS) {\\n            minterHeartsOwed[minter] += minterEarnings;\\n        } else {\\n            hexContract.transfer(msg.sender, minterEarnings);\\n        }\\n    }\\n\\n    /// @notice Allow minter to withdraw earnings if applicable\\n    /// @dev Only applies when a non-minter ends a stake before\\n    /// the grace period has expired\\n    function minterWithdraw() external lock {\\n        uint256 heartsOwed = minterHeartsOwed[msg.sender];\\n        require(heartsOwed != 0, \\\"NO_HEARTS_OWED\\\");\\n\\n        minterHeartsOwed[msg.sender] = 0;\\n        hexContract.transfer(msg.sender, heartsOwed);\\n\\n        emit MinterWithdraw(msg.sender, heartsOwed);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return _supportsERC165Interface(account, type(IERC165).interfaceId) &&\\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) &&\\n            _supportsERC165Interface(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool[] memory) {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165(account).supportsInterface.selector, interfaceId);\\n        (bool success, bytes memory result) = account.staticcall{ gas: 30000 }(encodedParams);\\n        if (result.length < 32) return false;\\n        return success && abi.decode(result, (bool));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = a * b\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\n        // then use the Chinese Remainder Theorem to reconstruct\\n        // the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(a, b, not(0))\\n            prod0 := mul(a, b)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2**256.\\n        // Also prevents denominator == 0\\n        require(denominator > prod1);\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\n        // Compute remainder using mulmod\\n        uint256 remainder;\\n        assembly {\\n            remainder := mulmod(a, b, denominator)\\n        }\\n        // Subtract 256 bit number from 512 bit number\\n        assembly {\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator\\n        // Compute largest power of two divisor of denominator.\\n        // Always >= 1.\\n        uint256 twos = (type(uint256).max - denominator + 1) & denominator;\\n        // Divide denominator by power of two\\n        assembly {\\n            denominator := div(denominator, twos)\\n        }\\n\\n        // Divide [prod1 prod0] by the factors of two\\n        assembly {\\n            prod0 := div(prod0, twos)\\n        }\\n        // Shift in bits from prod1 into prod0. For this we need\\n        // to flip `twos` such that it is 2**256 / twos.\\n        // If twos is zero, then it becomes one\\n        assembly {\\n            twos := add(div(sub(0, twos), twos), 1)\\n        }\\n        prod0 |= prod1 * twos;\\n\\n        // Invert denominator mod 2**256\\n        // Now that denominator is an odd number, it has an inverse\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n        // Compute the inverse by starting with a seed that is correct\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n        uint256 inv = (3 * denominator) ^ 2;\\n        // Now use Newton-Raphson iteration to improve the precision.\\n        // Thanks to Hensel's lifting lemma, this also works in modular\\n        // arithmetic, doubling the correct bits in each step.\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n        // Because the division is now exact we can divide by multiplying\\n        // with the modular inverse of denominator. This will give us the\\n        // correct result modulo 2**256. Since the precoditions guarantee\\n        // that the outcome is less than 2**256, this is the final result.\\n        // We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inv;\\n        return result;\\n    }\\n\\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        if (mulmod(a, b, denominator) > 0) {\\n            require(result < type(uint256).max);\\n            result++;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IHEX.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.4;\\n\\ninterface IHEX {\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function currentDay() external view returns (uint256);\\n\\n    function stakeCount(address stakerAddr) external view returns (uint256);\\n\\n    function stakeEnd(uint256 stakeIndex, uint40 stakeIdParam) external;\\n\\n    function stakeLists(address, uint256)\\n        external\\n        view\\n        returns (\\n            uint40 stakeId,\\n            uint72 stakedHearts,\\n            uint72 stakeShares,\\n            uint16 lockedDay,\\n            uint16 stakedDays,\\n            uint16 unlockedDay,\\n            bool isAutoStake\\n        );\\n\\n    function stakeStart(uint256 newStakedHearts, uint256 newStakedDays) external;\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/MinterReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\n/// @title HEX Minter Receiver\\n/// @author Sam Presnal - Staker\\n/// @dev Receives shares and hearts earned from the ShareMinter\\nabstract contract MinterReceiver is ERC165 {\\n    /// @notice ERC165 ensures the minter receiver supports the interface\\n    /// @param interfaceId The MinterReceiver interface id\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(MinterReceiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @notice Receives newly started stake properties\\n    /// @param stakeId The HEX stakeId\\n    /// @param supplier The reimbursement address for the supplier\\n    /// @param stakedHearts Hearts staked\\n    /// @param stakeShares Shares available\\n    function onSharesMinted(\\n        uint40 stakeId,\\n        address supplier,\\n        uint72 stakedHearts,\\n        uint72 stakeShares\\n    ) external virtual;\\n\\n    /// @notice Receives newly ended stake properties\\n    /// @param stakeId The HEX stakeId\\n    /// @param heartsEarned Hearts earned from the stake\\n    function onEarningsMinted(uint40 stakeId, uint72 heartsEarned) external virtual;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IHEX\",\"name\":\"_hex\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint40\",\"name\":\"stakeId\",\"type\":\"uint40\"},{\"indexed\":true,\"internalType\":\"contract MinterReceiver\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint72\",\"name\":\"hearts\",\"type\":\"uint72\"}],\"name\":\"MintEarnings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint40\",\"name\":\"stakeId\",\"type\":\"uint40\"},{\"indexed\":true,\"internalType\":\"contract MinterReceiver\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data0\",\"type\":\"uint256\"}],\"name\":\"MintShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heartsWithdrawn\",\"type\":\"uint256\"}],\"name\":\"MinterWithdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"hexContract\",\"outputs\":[{\"internalType\":\"contract IHEX\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"stakeId\",\"type\":\"uint40\"}],\"name\":\"mintEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"shareRatePremium\",\"type\":\"uint16\"},{\"internalType\":\"contract MinterReceiver\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newStakedHearts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newStakedDays\",\"type\":\"uint256\"}],\"name\":\"mintShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minterHeartsOwed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"shareRatePremium\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"unlockDay\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"contract MinterReceiver\",\"name\":\"receiver\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ShareMinter","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"0000000000000000000000002b591e99afe9f32eaa6214f7b7629768c40eeb39","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}