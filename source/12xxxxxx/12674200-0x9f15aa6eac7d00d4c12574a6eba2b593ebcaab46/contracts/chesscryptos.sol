// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol";
import "@openzeppelin/contracts/finance/PaymentSplitter.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title The ChessCryptos contract.
 * @author Manuel Liebchen
 */
contract ChessCryptos is ERC721, Ownable, PaymentSplitter, IERC721Enumerable {
    using Address for address;
    using Strings for uint256;
    event MintPriceIncrement(uint256 newPrice);

    /// The total number of token.
    uint256 public constant TOTAL_SUPPLY = 4716;
    /// The number of token that will be created for the creators when deploying the contract.
    uint256 public constant GALLERY_TOKEN = 100;
    /// The increment with witch the price will grow.
    uint256 public constant PRICE_INCREMENT = 0.04 ether;
    /// The number of token one pricesegment.
    uint256 public constant PRICESEGMENT_RANGE = 1000;

    /// The metadata ipfs file uri.
    string public baseURI;

    /** @dev The current minting price. */
    uint256 _mintPrice = 0.02 ether;
    /** @dev When the next price range will begin.*/
    uint256 _nextPriceIncrement = 600;
    /** @dev A number that is used for production of the pseudorandom mint sequence.*/
    uint256 private _indexIncrement;

    /** @dev The index of the token that will be created next.*/
    uint256 private _mintIndex;

    // ERC 165
    mapping(bytes4 => bool) internal supportedInterfaces;


    // Array with all token ids, used for enumeration
    uint256[] private _allTokens;

    /**
     * 
     */
    constructor(string memory baseURI_, address[] memory payees, uint256[] memory shares, uint256 indexIncrement_) ERC721("ChessCryptos", "CC") PaymentSplitter(payees, shares) {
        require(payees[0] == _msgSender(), "Sender/Owner is not first shareholder.");

        baseURI = baseURI_;
        _indexIncrement = indexIncrement_;

        supportedInterfaces[0x01ffc9a7] = true; // ERC165
        supportedInterfaces[0x80ac58cd] = true; // ERC721
        supportedInterfaces[0x780e9d63] = true; // ERC721 Enumerable
        supportedInterfaces[0x5b5e139f] = true; // ERC721 Metadata

    }

    function mintGallery() external onlyOwner {
        require(totalSupply() < GALLERY_TOKEN, "Only once.");
        for(uint256 i = 0; i < GALLERY_TOKEN; ++i){
            _mint(_msgSender(), _mintIndex);
            _mintIndex = (_mintIndex + _indexIncrement) % TOTAL_SUPPLY;
        }
    }

    /**
     * @dev Creates a new token for _msgSender. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     */
    function mint() 
        external payable
        returns (uint256)
    {
        require(totalSupply() < TOTAL_SUPPLY, "There are no token left to mint.");
        require(GALLERY_TOKEN <= totalSupply(), "Gallery Token haven't been minted.");
        require(msg.value == _mintPrice, "Value is not equal to mint price.");

        uint256 newItemId = _mintIndex;
        _mintIndex = (_mintIndex + _indexIncrement) % TOTAL_SUPPLY;

        if(totalSupply() >= _nextPriceIncrement){
            _mintPrice += PRICE_INCREMENT;
            _nextPriceIncrement += PRICESEGMENT_RANGE;
            emit MintPriceIncrement(_mintPrice);
        }
        
        _safeMint(_msgSender(), newItemId);

        return newItemId;
    }

    /**
     * @dev The number of token that can still be created.
     */
    function remainingToken() public view returns(uint256){
        return TOTAL_SUPPLY - totalSupply();
    }

    /**
     * @dev The number of token that can still be created at this fee.
     */
    function remainingTokenAtFee() public view returns(uint256){
        return _nextPriceIncrement - totalSupply();
    }

    /**
     * @dev The value mint expects for a token.
     */
    function mintPrice() external view returns(uint256) {
        return _mintPrice;
    }

    /**
     * @dev See {IERC721Enumerable-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _allTokens.length;
    }

    function maximumToken() public pure virtual returns (uint256) {
        return TOTAL_SUPPLY;
    }

    /**
     * @dev See {IERC721Enumerable-tokenByIndex}.
     */
    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
        require(index < totalSupply(), "ERC721Enumerable: global index out of bounds");
        return _allTokens[index];
    }

    /**
     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
     */
    function tokenOfOwnerByIndex(address owner, uint256 index) external view override returns (uint256 tokenId){
        require(index < balanceOf(owner));
        uint256 count = 0;
        for(uint256 i = 0; i < totalSupply(); i++){
            if(ownerOf(_allTokens[i]) == owner){
                if(count == index){
                    return _allTokens[i];
                }
                count++;
            }
        }
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting
     * and burning.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
     * transferred to `to`.
     * - When `from` is zero, `tokenId` will be minted for `to`.
     * - When `to` is zero, ``from``'s `tokenId` will be burned.
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {
        super._beforeTokenTransfer(from, to, tokenId);

        if (from == address(0)) {
            _allTokens.push(tokenId);
        }
    }

    /**
     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden
     * in child contracts.
     */
    function _baseURI() internal view override returns(string memory) {
        return baseURI;
    }

    /**
     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden
     * in child contracts.
     */
    function ipfsRoot() external view returns(string memory) {
        return baseURI;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(tokenId < TOTAL_SUPPLY, "ERC721Metadata: URI query for nonexistent token");

        return string(abi.encodePacked(baseURI, "/", tokenId.toString(), "/meta.json"));
    }

    function contractURI() public view returns (string memory) {
        return string(abi.encodePacked(baseURI, "/meta.json"));
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceID) public view override( ERC721, IERC165) returns (bool) {
        return supportedInterfaces[interfaceID];
    }
}
