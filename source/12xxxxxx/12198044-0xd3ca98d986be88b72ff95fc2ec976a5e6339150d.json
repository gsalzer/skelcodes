{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.2;\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface ManagementList {\r\n    function isManager(address accountAddress) external returns (bool);\r\n}\r\n\r\ncontract Manageable {\r\n    ManagementList public managementList;\r\n\r\n    constructor(address _managementListAddress) {\r\n        managementList = ManagementList(_managementListAddress);\r\n    }\r\n\r\n    modifier onlyManagers() {\r\n        bool isManager = managementList.isManager(msg.sender);\r\n        require(isManager, \"ManagementList: caller is not a manager\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Oracle is Manageable {\r\n    address[] private _calculations;\r\n    address public usdcAddress;\r\n    mapping(address => address) public tokenAliases;\r\n\r\n    event TokenAliasAdded(address tokenAddress, address tokenAliasAddress);\r\n    event TokenAliasRemoved(address tokenAddress);\r\n\r\n    struct TokenAlias {\r\n        address tokenAddress;\r\n        address tokenAliasAddress;\r\n    }\r\n\r\n    constructor(address _managementListAddress, address _usdcAddress)\r\n        Manageable(_managementListAddress)\r\n    {\r\n        usdcAddress = _usdcAddress;\r\n    }\r\n\r\n    /**\r\n     * The oracle supports an array of calculation contracts. Each calculation contract must implement getPriceUsdc().\r\n     * When setting calculation contracts all calculations must be set at the same time (we intentionally do not support for adding/removing calculations).\r\n     * The order of calculation contracts matters as it determines the order preference in the cascading fallback mechanism.\r\n     */\r\n    function setCalculations(address[] memory calculationAddresses)\r\n        external\r\n        onlyManagers\r\n    {\r\n        _calculations = calculationAddresses;\r\n    }\r\n\r\n    function calculations() external view returns (address[] memory) {\r\n        return (_calculations);\r\n    }\r\n\r\n    function addTokenAlias(address tokenAddress, address tokenAliasAddress)\r\n        public\r\n        onlyManagers\r\n    {\r\n        tokenAliases[tokenAddress] = tokenAliasAddress;\r\n        emit TokenAliasAdded(tokenAddress, tokenAliasAddress);\r\n    }\r\n\r\n    function addTokenAliases(TokenAlias[] memory _tokenAliases)\r\n        public\r\n        onlyManagers\r\n    {\r\n        for (uint256 i = 0; i < _tokenAliases.length; i++) {\r\n            addTokenAlias(\r\n                _tokenAliases[i].tokenAddress,\r\n                _tokenAliases[i].tokenAliasAddress\r\n            );\r\n        }\r\n    }\r\n\r\n    function removeTokenAlias(address tokenAddress) public onlyManagers {\r\n        delete tokenAliases[tokenAddress];\r\n        emit TokenAliasRemoved(tokenAddress);\r\n    }\r\n\r\n    function getNormalizedValueUsdc(address tokenAddress, uint256 amount)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        IERC20 token = IERC20(tokenAddress);\r\n        uint256 tokenDecimals = token.decimals();\r\n\r\n        uint256 usdcDecimals = 6;\r\n        uint256 decimalsAdjustment;\r\n        if (tokenDecimals >= usdcDecimals) {\r\n            decimalsAdjustment = tokenDecimals - usdcDecimals;\r\n        } else {\r\n            decimalsAdjustment = usdcDecimals - tokenDecimals;\r\n        }\r\n        uint256 price = getPriceUsdcRecommended(tokenAddress);\r\n        uint256 value;\r\n        if (decimalsAdjustment > 0) {\r\n            value =\r\n                (amount * price * (10**decimalsAdjustment)) /\r\n                10**(decimalsAdjustment + tokenDecimals);\r\n        } else {\r\n            value = (amount * price) / 10**usdcDecimals;\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function getPriceUsdcRecommended(address tokenAddress)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        address tokenAddressAlias = tokenAliases[tokenAddress];\r\n        address tokenToQuery = tokenAddress;\r\n        if (tokenAddressAlias != address(0)) {\r\n            tokenToQuery = tokenAddressAlias;\r\n        }\r\n        (bool success, bytes memory data) =\r\n            address(this).staticcall(\r\n                abi.encodeWithSignature(\"getPriceUsdc(address)\", tokenToQuery)\r\n            );\r\n        if (success) {\r\n            return abi.decode(data, (uint256));\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Cascading fallback proxy\r\n     *\r\n     * Loop through all contracts in _calculations and attempt to forward the method call to each underlying contract.\r\n     * This allows users to call getPriceUsdc() on the oracle contract and the result of the first non-reverting contract that\r\n     * implements getPriceUsdc() will be returned.\r\n     *\r\n     * This mechanism also exposes all public methods for calculation contracts. This allows a user to\r\n     * call oracle.isIronBankMarket() or oracle.isCurveLpToken() even though these methods live on different contracts.\r\n     */\r\n    fallback() external {\r\n        for (uint256 i = 0; i < _calculations.length; i++) {\r\n            address calculation = _calculations[i];\r\n            assembly {\r\n                let _target := calculation\r\n                calldatacopy(0, 0, calldatasize())\r\n                let success := staticcall(\r\n                    gas(),\r\n                    _target,\r\n                    0,\r\n                    calldatasize(),\r\n                    0,\r\n                    0\r\n                )\r\n                returndatacopy(0, 0, returndatasize())\r\n                if success {\r\n                    return(0, returndatasize())\r\n                }\r\n            }\r\n        }\r\n        revert(\"Oracle: Fallback proxy failed to return data\");\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_managementListAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdcAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAliasAddress\",\"type\":\"address\"}],\"name\":\"TokenAliasAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"TokenAliasRemoved\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAliasAddress\",\"type\":\"address\"}],\"name\":\"addTokenAlias\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAliasAddress\",\"type\":\"address\"}],\"internalType\":\"struct Oracle.TokenAlias[]\",\"name\":\"_tokenAliases\",\"type\":\"tuple[]\"}],\"name\":\"addTokenAliases\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculations\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getNormalizedValueUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getPriceUsdcRecommended\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managementList\",\"outputs\":[{\"internalType\":\"contract ManagementList\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"removeTokenAlias\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"calculationAddresses\",\"type\":\"address[]\"}],\"name\":\"setCalculations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenAliases\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdcAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Oracle","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000f64e58ee8c7badc741a7ea98fb65488084385674000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8caf7e38d63f26449eafa427d8be31736488d8552b520a15d8c61e21c28317fc"}]}