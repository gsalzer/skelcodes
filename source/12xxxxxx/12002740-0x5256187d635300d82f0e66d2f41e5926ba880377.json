{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks-satellite/contracts/CosmoMasksERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./libraries/Address.sol\\\";\\nimport \\\"./libraries/EnumerableSet.sol\\\";\\nimport \\\"./libraries/EnumerableMap.sol\\\";\\nimport \\\"./libraries/Strings.sol\\\";\\nimport \\\"./utils/Context.sol\\\";\\n\\ninterface ICosmoMasksERC721 {\\n    // IERC165\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n    // IERC721Enumerable\\n    function totalSupply() external view returns (uint256);\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n    // IERC721Metadata\\n    function name() external view returns (string memory _name);\\n    function symbol() external view returns (string memory _symbol);\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\n    // ERC721\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n    function approve(address to, uint256 tokenId) external;\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n    function setApprovalForAll(address operator, bool _approved) external;\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n}\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\nabstract contract CosmoMasksERC721 is Context, ICosmoMasksERC721 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using Strings for uint256;\\n\\n    // ERC165\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA_SHORT = 0x93254542;\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    mapping(address => EnumerableSet.UintSet) private _holderTokens;\\n    EnumerableMap.UintToAddressMap private _tokenOwners;\\n    mapping(uint256 => address) private _tokenApprovals;\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    string private _name;\\n    string private _symbol;\\n    string private _baseURI;\\n    string private _url;\\n\\n\\n    constructor(string memory name_, string memory symbol_) internal {\\n        _name = name_;\\n        _symbol = symbol_;\\n\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA_SHORT);\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        require(owner != address(0), \\\"CosmoMasks: balance query for the zero address\\\");\\n        return _holderTokens[owner].length();\\n    }\\n\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _tokenOwners.get(tokenId, \\\"CosmoMasks: owner query for nonexistent token\\\");\\n    }\\n\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        require(_exists(tokenId), \\\"CosmoMasks: URI query for nonexistent token\\\");\\n        string memory base = baseURI();\\n        return string(abi.encodePacked(base, tokenId.toString(), \\\".json\\\"));\\n    }\\n\\n    function baseURI() public view returns (string memory) {\\n        return _baseURI;\\n    }\\n\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\\n        return _holderTokens[owner].at(index);\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _tokenOwners.length();\\n    }\\n\\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\\n        (uint256 tokenId, ) = _tokenOwners.at(index);\\n        return tokenId;\\n    }\\n\\n    function approve(address to, uint256 tokenId) public override {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"CosmoMasks: approval to current owner\\\");\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"CosmoMasks: approve caller is not owner nor approved for all\\\"\\n        );\\n        _approve(to, tokenId);\\n    }\\n\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        require(_exists(tokenId), \\\"CosmoMasks: approved query for nonexistent token\\\");\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public override {\\n        require(operator != _msgSender(), \\\"CosmoMasks: approve to caller\\\");\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"CosmoMasks: transfer caller is not owner nor approved\\\");\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"CosmoMasks: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"CosmoMasks: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return _tokenOwners.contains(tokenId);\\n    }\\n\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        require(_exists(tokenId), \\\"CosmoMasks: operator query for nonexistent token\\\");\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    function _safeMint(address to, uint256 tokenId) internal {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"CosmoMasks: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal {\\n        require(to != address(0), \\\"CosmoMasks: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"CosmoMasks: token already minted\\\");\\n        _holderTokens[to].add(tokenId);\\n        _tokenOwners.set(tokenId, to);\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    function _burn(uint256 tokenId) internal {\\n        address owner = ownerOf(tokenId);\\n        _approve(address(0), tokenId);\\n        _holderTokens[owner].remove(tokenId);\\n        _tokenOwners.remove(tokenId);\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    function _transfer(address from, address to, uint256 tokenId) internal {\\n        require(ownerOf(tokenId) == from, \\\"CosmoMasks: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"CosmoMasks: transfer to the zero address\\\");\\n        _approve(address(0), tokenId);\\n        _holderTokens[from].remove(tokenId);\\n        _holderTokens[to].add(tokenId);\\n        _tokenOwners.set(tokenId, to);\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function _setBaseURI(string memory baseURI_) internal {\\n        _baseURI = baseURI_;\\n    }\\n\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\\n            IERC721Receiver(to).onERC721Received.selector,\\n            _msgSender(),\\n            from,\\n            tokenId,\\n            _data\\n        ), \\\"CosmoMasks: transfer to non ERC721Receiver implementer\\\");\\n        bytes4 retval = abi.decode(returndata, (bytes4));\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    function _approve(address to, uint256 tokenId) private {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    function _setURL(string memory newUrl) internal {\\n        _url = newUrl;\\n    }\\n\\n    // ERC165\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"CosmoMasks: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks-satellite/contracts/CosmoMasksLimitedPack.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport \\\"./utils/Ownable.sol\\\";\\nimport \\\"./CosmoMasksERC721.sol\\\";\\n\\ninterface IERC20BurnTransfer {\\n    function burn(uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n}\\n\\ninterface ICosmoTokenMint {\\n    function mintToFund(uint256 amount) external returns (bool);\\n}\\n\\n\\ncontract OwnableDelegateProxy {}\\ncontract ProxyRegistry {\\n    mapping(address => OwnableDelegateProxy) public proxies;\\n}\\n\\n\\n// https://eips.ethereum.org/EIPS/eip-721 tokenURI\\n/**\\n * @title CosmoMasks contract\\n * @dev Extends ERC721 Non-Fungible Token Standard basic implementation\\n */\\ncontract CosmoMasksLimitedPack is Ownable, CosmoMasksERC721 {\\n    using SafeMath for uint256;\\n\\n    // This is the provenance record of all CosmoMasks artwork in existence\\n    uint256 public constant MAX_SUPPLY = 610;\\n    string public constant PROVENANCE = \\\"d2fa4e09c05d4e578b4132118a2fb2a74247e60a1e8a95734ac3274f74923ffe\\\";\\n    address private _cosmoToken;\\n    address proxyRegistryAddress;\\n    string private _contractURI;\\n\\n\\n    constructor(address _proxyRegistryAddress) public CosmoMasksERC721(\\\"CosmoMasks Limited Pack\\\", \\\"COSMAS-LP\\\") {\\n        proxyRegistryAddress = _proxyRegistryAddress;\\n        _setBaseURI(\\\"https://TheCosmoMasks.com/cosmomasks-limited-pack-metadata/\\\");\\n        _setURL(\\\"https://TheCosmoMasks.com/\\\");\\n        _contractURI = \\\"https://TheCosmoMasks.com/cosmomasks-limited-pack-contract-metadata.json\\\";\\n    }\\n\\n    function getCosmoToken() public view returns (address) {\\n        return _cosmoToken;\\n    }\\n\\n    function contractURI() public view returns (string memory) {\\n        return _contractURI;\\n    }\\n\\n    /**\\n    * @dev Mints CosmoMasks\\n    */\\n    function mint(address to, uint256 numberOfMasks) public onlyOwner {\\n        require(totalSupply() < MAX_SUPPLY, \\\"CosmoMasks: sale has already ended\\\");\\n        require(totalSupply().add(numberOfMasks) <= MAX_SUPPLY, \\\"CosmoMasks: Exceeds MAX_SUPPLY\\\");\\n\\n        for (uint256 i = 0; i < numberOfMasks; i++) {\\n            uint256 mintIndex = totalSupply();\\n            _safeMint(to, mintIndex);\\n            ICosmoTokenMint(_cosmoToken).mintToFund(1e24);\\n        }\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\\n        // Whitelist OpenSea proxy contract for easy trading.\\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\\n        if (address(proxyRegistry.proxies(owner)) == operator) {\\n            return true;\\n        }\\n        return super.isApprovedForAll(owner, operator);\\n    }\\n\\n    function setCosmoToken(address token) public onlyOwner {\\n        require(_cosmoToken == address(0), \\\"CosmoMasks: CosmosToken has already setted\\\");\\n        require(token != address(0), \\\"CosmoMasks: CosmoToken is the zero address\\\");\\n        _cosmoToken = token;\\n    }\\n\\n    function setBaseURI(string memory baseURI_) public onlyOwner {\\n        _setBaseURI(baseURI_);\\n    }\\n\\n    function setContractURI(string memory contractURI_) public onlyOwner {\\n        _contractURI = contractURI_;\\n    }\\n\\n    function setURL(string memory newUrl) public onlyOwner {\\n        _setURL(newUrl);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks-satellite/contracts/libraries/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function functionCall(address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            if (returndata.length > 0) {\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks-satellite/contracts/libraries/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n */\\nlibrary EnumerableMap {\\n    struct MapEntry {\\n        bytes32 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct Map {\\n        MapEntry[] _entries;\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\\n        uint256 keyIndex = map._indexes[key];\\n        if (keyIndex == 0) {\\n            map._entries.push(MapEntry({_key: key, _value: value}));\\n            map._indexes[key] = map._entries.length;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        uint256 keyIndex = map._indexes[key];\\n        if (keyIndex != 0) {\\n            uint256 toDeleteIndex = keyIndex - 1;\\n            uint256 lastIndex = map._entries.length - 1;\\n            MapEntry storage lastEntry = map._entries[lastIndex];\\n            map._entries[toDeleteIndex] = lastEntry;\\n            map._indexes[lastEntry._key] = toDeleteIndex + 1;\\n            map._entries.pop();\\n            delete map._indexes[key];\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._entries.length;\\n    }\\n\\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n        require(map._entries.length > index, \\\"EnumerableMap: index out of bounds\\\");\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        if (keyIndex == 0) return (false, 0);\\n        return (true, map._entries[keyIndex - 1]._value);\\n    }\\n\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, \\\"EnumerableMap: nonexistent key\\\");\\n        return map._entries[keyIndex - 1]._value;\\n    }\\n\\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, errorMessage);\\n        return map._entries[keyIndex - 1]._value;\\n    }\\n\\n    // UintToAddressMap\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\\n    }\\n\\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks-satellite/contracts/libraries/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n */\\nlibrary EnumerableSet {\\n    struct Set {\\n        bytes32[] _values;\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        uint256 valueIndex = set._indexes[value];\\n        if (valueIndex != 0) {\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n            bytes32 lastvalue = set._values[lastIndex];\\n            set._values[toDeleteIndex] = lastvalue;\\n            set._indexes[lastvalue] = toDeleteIndex + 1;\\n            set._values.pop();\\n            delete set._indexes[value];\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // UintSet\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks-satellite/contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n */\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks-satellite/contracts/libraries/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = bytes1(uint8(48 + (temp % 10)));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks-satellite/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/cosmomasks-contracts-deployer/src/cosmomasks-satellite/contracts/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxyRegistryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROVENANCE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCosmoToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numberOfMasks\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractURI_\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setCosmoToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newUrl\",\"type\":\"string\"}],\"name\":\"setURL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CosmoMasksLimitedPack","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000a5409ec958c83c3f309868babaca7c86dcb077c1","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}