{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\nImplements EIP20 token standard: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n*/\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.6;\r\n\r\ncontract ADKContract {\r\n \r\n/*\r\nThis is the main wADK Contract (ERC20 Implementation): Ethereum wrapped AidosKuneen Token.\r\n\r\nThe purpose of this contract is to enable transfer of ADK Token from/to the ADK Mesh to/from the Ethereum Blockchain \r\n\r\nFor details see https://github.com/adkmaster/adk-ethereum-bridge\r\n\r\nHow it works (short version):\r\n\r\nTransfers from Mesh to Ethereum (ADK to wADK):\r\n\r\nADK holders on the ADK Mesh transfer the amount of ADK they wish to convert to wADK (1:1 conversion) to the ADK Mesh address ADK_DEPOSIT_ADDRESS_LIVE. The signature part (=Message/Smart Data Section) of the + ADK transaction has to contain the encoded 'receiving' Ethereum Address (use functions USR_ETHAddrEncode \r\nand USR_ETHAddrDecode to convert from ADK SmartData String to Ethereum Adress and vice versa)\r\n\r\nOnce the ADK transaction has been confirmed on the ADK Mesh, the issuance of wADK will be triggered by the Contract owner specified in mainMeshOwner. The original ADK will remain locked in the ADK_DEPOSIT_ADDRESS_LIVE (and previous ADK deposit addresses) until a request for a conversion transaction wADK-->ADK is triggered (see below). \r\n\r\n\r\nTransfers from Ethereum (wADK) to Mesh (ADK):\r\n\r\nwADK holders can request a transfer from the Ethereum Blockchain back to the Mesh (1:1 conversion) by calling the contract function \"USR_transferToMesh\". Registered requests will be executed periodically, with ADK to be issued from previously locked ADK, at which time a new public ADK_DEPOSIT_ADDRESS_LIVE will be generated as needed.\r\n\r\n********************************************************************************************************************\r\nDISCLAIMER: THE CROSS-CHAIN COMPONENT OF THIS CONTRACT IS **NOT** A TRUSTLESS BRIDGE, AS THAT WOULD REQUIRE ADK TO IMPLEMENT SMART CONTRACT CAPABILITIES. INSTEAD, THIS CONTRACT (the MESH-ETHEREUM Bridge Part) NEEDS TO BE OPERATED BY A TRUSTED PARTY, e.g. the Aidos Foundation (Milestone Server Operator) OR TRUSTED DELEGATE. \r\n\r\nNote: THIS ONLY APPLIES TO THE TRANSFER FROM/TO THE MESH. ONCE ISSUED, wADK FOLLOW THE ERC20 STANDARD (TRUSTLESS TRANSACTIONS)\r\n\r\n********************************************************************************************************************\r\n\r\nFur further details, step by step HOW-TOs, and latest updates please see https://github.com/adkmaster/adk-ethereum-bridge\r\n*/\r\n    \r\n    uint256 public totalSupply;\r\n    \r\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n    \r\n    string public name;     // Aidos Kuneen Wrapped ADK\r\n    uint8 public decimals;  // 8\r\n    string public symbol;   // ADK\r\n    \r\n    address public mainMeshOwner;  //the 'mesh owner', holds all token still inside the ADK Mesh (if not in circulation as wADK)\r\n    address public statusAddress;  // is the request status admin, an address which can update user request stati.\r\n    \r\n    /* \r\n    ADK_DEPOSIT_ADDRESS_LIVE holds the most recent ADK MESH DEPOSIT ADDRESS. THIS IS THE ADK ADDRESS THAT MUST BE USED WHEN SENDING ADK to wADK (Ethereum)\r\n    NOTE: THIS ADDRESS WILL CHANGE REGULARLY. ENSURE YOU ALWAYS USE THE LATEST ONE\r\n    */\r\n    \r\n    string public ADK_DEPOSIT_ADDRESS_LIVE; \r\n                      \r\n    /*\r\n    ADK_DEPOSIT_ADDRESS_PREVIOUS is the PREVIOUS live address. ADK Deposits to this address will still be credited, BUT: Do not use this address for any new deposits. The purpose of keeping this address active is solely to capture any pending transactions at the time of address change.\r\n\r\n    Note: Transfers to even older deposit addresses will still be ATTEMPTED to be credited by manually transferring them to a live address, but are at risk due to multi-spends (winternitz one-time signature).\r\n    Long story short: Always!! use the latest ADK_DEPOSIT_ADDRESS_LIVE ADK address when sending ADK \r\n    */\r\n    \r\n    string public ADK_DEPOSIT_ADDRESS_PREVIOUS; \r\n                                                     \r\n    uint256 public ADKDepositAddrCount; // Total number of historical ADK Mesh Contract deposit addresses\r\n    \r\n    mapping (uint256 => string) public ADKDepositAddrHistory; // holds the history of all ADK Mesh deposit addresses\r\n\r\n    uint256 public requestID;    // counter / unique request ID \r\n    mapping (uint256 => string) public requestStatus; // Can be used to provide feedback to users re. status of their ADK/wADK requests.\r\n    \r\n    /*\r\n    minimumADKforXChainTransfer: Indicates the minimum ADK or mADK required to transfer cross-chain.\r\n    Note: value is in ADK Subunits, where 100000000 subADK = 1 ADK, i.e. 1.00000000 ADK\r\n    */\r\n    \r\n    uint256 public minimumADKforXChainTransfer;  \r\n    \r\n    // CONSTRUCTOR\r\n    constructor( // EIP20 Standard\r\n        uint256 _initialAmount,\r\n        string memory _tokenName,\r\n        uint8  _decimalUnits,\r\n        string memory _tokenSymbol\r\n    ) {\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes (8 for ADK)\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n        balances[msg.sender] = _initialAmount;               // Give the mesh address all initial tokens\r\n        totalSupply = _initialAmount;                        // 2500000000000000 ADK in Mesh initially\r\n        mainMeshOwner = msg.sender;                          // the address representing the ADK Mesh\r\n        statusAddress = msg.sender;                          // initially also the owner\r\n        requestID = 0; \r\n        ADKDepositAddrCount = 0;\r\n        minimumADKforXChainTransfer = 10000000000;           // initially 100 ADK = 10000000000 units\r\n    }\r\n\r\n    // ERC20 events\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n    // Standard ERC20 transfer Function\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        require(balances[msg.sender] >= _value);\r\n        require(address(this) != _to); // prevent accidental send of tokens to the contract itself! RTFM people!\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\r\n        return true;\r\n    }\r\n\r\n    // Standard ERC20 transferFrom Function\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        uint256 vallowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && vallowance >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (vallowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\r\n        return true;\r\n    }\r\n    \r\n    // Standard ERC20 approve Function\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\r\n        return true;\r\n    }\r\n\r\n    // Standard ERC20 balanceOf Function\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n     // Standard ERC20 allowance Function\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    /// END DEFAULT ERC20 FUNCTIONS\r\n    \r\n    // MODIFIERS\r\n\r\n    modifier onlyOwnerOrStatusAdmin {\r\n        require(msg.sender == mainMeshOwner || msg.sender == statusAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == mainMeshOwner);\r\n        _;\r\n    }\r\n    \r\n    /// BEGIN CUSTOM ADK FEATURES\r\n    \r\n    // ADM_setNewMinADKLimit: Sets the min-ADK X-Chain Transfer limit\r\n    \r\n    function ADM_setNewMinADKLimit(uint256 _newLimit) public onlyOwner {\r\n        minimumADKforXChainTransfer = _newLimit;\r\n    }\r\n\r\n    // ADM_setNewStatusAdmin: Update the admin/Ethereum Address which is able to update user request status\r\n    \r\n    function ADM_setNewStatusAdmin(address _newAdmin) public onlyOwner {\r\n        statusAddress = _newAdmin;\r\n    }\r\n\r\n    // ADM_setNewOwner: Change the owner/Ethereum Address which holds the Mesh Locked Token Balance\r\n    \r\n    function ADM_setNewOwner(address _newOwner) public onlyOwner {\r\n        require(balances[_newOwner] == 0); // new mesh address cannot hold wADK already.\r\n        mainMeshOwner = _newOwner;\r\n        if ( balances[msg.sender] > 0 ) {\r\n            transfer( _newOwner , balances[msg.sender] );\r\n        }\r\n    }\r\n    \r\n     // Custom EVENTS \r\n     \r\n     event EvtTransferFromMesh(address _receiver, address _mesh_address, string _adk_address, uint256 _value);\r\n     event EvtTransferToMesh(address _sender, address _mesh_address, string _adk_address, uint256 _value, uint256 _requestID, uint256 _fees);\r\n     event EvtADKDepositAddressUpd(string ADK_DEPOSIT_ADDRESS_LIVE);\r\n     event EvtStatusChanged(uint256 _requestID, string _oldStatus, string _newStatus);\r\n    \r\n    \r\n    // Check if an address only contains 9A-Z, and is 81 or 90 char long\r\n    \r\n    modifier requireValidADKAddress (string memory _adk_address) {\r\n        bool valid = true;\r\n        bytes memory adkBytes = bytes (_adk_address);\r\n        require(adkBytes.length == 81 || adkBytes.length == 90); //address with or without checksum\r\n        \r\n        for (uint i = 0; i < adkBytes.length; i++) {\r\n            if ( \r\n                ! (\r\n                    uint8(adkBytes[i]) == 57 //9\r\n                     || (uint8(adkBytes[i]) >= 65 && uint8(adkBytes[i]) <= 90) //A-Z\r\n                  )\r\n               ) valid = false;\r\n        }\r\n        require (valid);\r\n        _;\r\n    } \r\n     \r\n    /*  \r\n    USR_transferToMesh: Called by users to request a transfer from wADK (Ethereum ERC20) back to ADK (Mesh)\r\n    Note: This just calls the standard transfer function using the main Mesh Address, but logs also the target ADK address for processing.\r\n    Note2: This function is PAYABLE as it will be possible to attach a fee to the transfer request in order to expedite the ADK mesh-release\r\n    */\r\n    \r\n    function USR_transferToMesh(string memory _adk_address, uint256 _value) payable requireValidADKAddress (_adk_address) public {\r\n        requestID += 1;\r\n        require (_value >= minimumADKforXChainTransfer);\r\n        transfer( mainMeshOwner , _value );\r\n        requestStatus[requestID] = \"RQ\"; // transfer to mesh requested\r\n        emit EvtTransferToMesh(msg.sender, mainMeshOwner, _adk_address, _value, requestID, msg.value);\r\n    }\r\n    \r\n    \r\n    // ADM_transferFromMesh: function invoked by the ADK Mesh Milestone Server (or delegate)  to unlock wADK and send wADK Token to the Ethereum address (specified by the user in the Smard Data field when depositing ADK for conversion)\r\n    \r\n    function ADM_transferFromMesh(address _receiver, uint256 _value, string memory _from_adk_address) public {\r\n        // note _from_adk_address is for logging purpose only\r\n        if (msg.sender == mainMeshOwner) { // if owner sends, then just use transfer \r\n            transfer( _receiver , _value );\r\n        }\r\n        else {\r\n            transferFrom(mainMeshOwner, _receiver, _value); // otherwise use transferFrom (meaning the owner had to authorize the transfer first)\r\n        }                                            // This will be used by custom helper contracts to pay multiple accounts etc\r\n        \r\n        emit EvtTransferFromMesh( _receiver, msg.sender, _from_adk_address, _value);\r\n    }\r\n    \r\n    // ADM_updateMeshDepositAddress: Sets a new live ADK Mesh Deposit address, to be used for transfers from the Mesh to wADK  \r\n    \r\n    function ADM_updateMeshDepositAddress(string memory _new_deposit_adk_address) public \r\n                           onlyOwnerOrStatusAdmin requireValidADKAddress (_new_deposit_adk_address){\r\n        \r\n        ADK_DEPOSIT_ADDRESS_PREVIOUS = ADK_DEPOSIT_ADDRESS_LIVE; \r\n        ADK_DEPOSIT_ADDRESS_LIVE = _new_deposit_adk_address; \r\n        \r\n        ADKDepositAddrCount += 1;\r\n        ADKDepositAddrHistory[ADKDepositAddrCount] = _new_deposit_adk_address; // holds the history of all ADK Mesh deposit addresses\r\n        \r\n        emit EvtADKDepositAddressUpd(ADK_DEPOSIT_ADDRESS_LIVE);\r\n    }\r\n    \r\n    // ADM_updateRequestStatus: allows a status admin to update request stati (feedback to users)  \r\n    \r\n    function ADM_updateRequestStatus(uint256 _requestID, string memory _status) public onlyOwnerOrStatusAdmin {\r\n        string memory oldStatus = requestStatus[requestID];\r\n        requestStatus[requestID] = _status;\r\n        emit EvtStatusChanged(_requestID, oldStatus, _status);\r\n    }\r\n\r\n    /*\r\n    USR_ETHAddrEncode and USR_ETHAddrDecode:\r\n    Helper functions for en- and decoding of Eth Addresses as ADK compatible strings i.e. a 1:1 conversion from an Ethereum Address to an ADK compatible String, and vice versa\r\n\r\n    USR_ETHAddrEncode: ENCODES/CONVERTS ETHEREUM ADDRESS to an ADK compatible String using only 9A-Z\r\n    This is a PURE function (can be run without gas), and needs to be used by a user who wants to transfer ADK from the mesh to wADK. The 9AZ encoded eth address is included in the Mesh transaction to specify the target Ethereum Address that should receive the wADK\r\n    */\r\n    \r\n    function USR_ETHAddrEncode(bytes memory ethAddr) public pure returns(string memory) {\r\n        bytes memory alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ9\";\r\n        require(ethAddr.length == 20); //20 bytes / an ethereum address \r\n    \r\n        bytes memory str = new bytes(81);\r\n        for (uint i = 0; i < 40; i++) {\r\n            str[i*2+1] = alphabet[10+uint(uint8(ethAddr[i%20] & 0x0f))];  // add 10 to mix up the characters\r\n            str[i*2] = alphabet[uint(uint8(ethAddr[i%20] >> 4))];  \r\n        }\r\n        str[80] = \"9\";\r\n        return string(str);\r\n    }\r\n    \r\n    /*\r\n    USR_ETHAddrDecode: DECODES an ETHEREUM ADDRESS from an ADK compatible String only 9A-Z \r\n    (i.e. a 1:1 conversion from an ADK-Encoded Ethereum Address String to back an actual Ethereum Address)\r\n    \r\n    This is a PURE function (can be run without gas), and will be used by the Mesh Milestone Node to specify the target Ethereum Address that should receive the wADK\r\n    */\r\n    \r\n    function USR_ETHAddrDecode(string memory adkString) public pure returns(address) {\r\n        bytes memory str = new bytes(20); //2*40 hex char plus leading 0x\r\n        bytes memory adkString_b = bytes(adkString);\r\n        for (uint i = 0; i < 20; i++) {\r\n            uint8 low = uint8(adkString_b[i*2+1])==57? 26 - 10 : uint8(adkString_b[i*2+1]) - 65 - 10;\r\n            uint8 high = uint8(adkString_b[i*2])==57? 26 : uint8(adkString_b[i*2]) - 65;\r\n            str[i] = bytes1(high * 16 + low); // Low Hex Char \r\n        }\r\n        return utilBytesToAddress(str);\r\n    }\r\n    \r\n    // utilBytesToAddress: Helper function to convert 20 bytes to a properly formated Ethereum address\r\n    \r\n    function utilBytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        require(bys.length == 20);\r\n        assembly {\r\n          addr := mload(add(bys,20))\r\n        } \r\n    }\r\n    \r\n    // ETH FEE COLLECTION FUNCTIONS:\r\n    // The following functions are NOT related the ADK token, but are used to manage any ETH Fees,\r\n    // that were sent to the contract address. It will cater for future features such as expedited \r\n    // processing (i.e. if the default processing time is too slow)\r\n    \r\n    event EvtReceivedGeneric(address, uint);\r\n    event EvtReceivedFee(address, uint, string);\r\n    \r\n    // Fees sent to address where no _feeInfo string is required\r\n    receive() external payable {\r\n         emit EvtReceivedGeneric(msg.sender, msg.value);\r\n    }\r\n    \r\n    // ADM_CollectFees: collect any ETH fees sent to the contract and forward to the specified address  for processing\r\n    \r\n    function ADM_CollectFees(address payable _collectToAddress, uint256 _value) onlyOwnerOrStatusAdmin public {\r\n        _collectToAddress.transfer(_value); \r\n    }\r\n\r\n    // USR_FeePayment: Allows users to pay fees for additional services, check main website/github for details\r\n    \r\n    function USR_FeePayment(string memory _feeInfo) payable public {\r\n         emit EvtReceivedFee(msg.sender, msg.value, _feeInfo);\r\n    }\r\n    \r\n    \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimalUnits\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ADK_DEPOSIT_ADDRESS_LIVE\",\"type\":\"string\"}],\"name\":\"EvtADKDepositAddressUpd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"EvtReceivedFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"EvtReceivedGeneric\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_requestID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_oldStatus\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_newStatus\",\"type\":\"string\"}],\"name\":\"EvtStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_mesh_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_adk_address\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"EvtTransferFromMesh\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_mesh_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_adk_address\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_requestID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fees\",\"type\":\"uint256\"}],\"name\":\"EvtTransferToMesh\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADKDepositAddrCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ADKDepositAddrHistory\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ADK_DEPOSIT_ADDRESS_LIVE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ADK_DEPOSIT_ADDRESS_PREVIOUS\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_collectToAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ADM_CollectFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"ADM_setNewMinADKLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"ADM_setNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"ADM_setNewStatusAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_from_adk_address\",\"type\":\"string\"}],\"name\":\"ADM_transferFromMesh\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_new_deposit_adk_address\",\"type\":\"string\"}],\"name\":\"ADM_updateMeshDepositAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestID\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_status\",\"type\":\"string\"}],\"name\":\"ADM_updateRequestStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"adkString\",\"type\":\"string\"}],\"name\":\"USR_ETHAddrDecode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"ethAddr\",\"type\":\"bytes\"}],\"name\":\"USR_ETHAddrEncode\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_feeInfo\",\"type\":\"string\"}],\"name\":\"USR_FeePayment\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_adk_address\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"USR_transferToMesh\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainMeshOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumADKforXChainTransfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requestStatus\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"statusAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ADKContract","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000008e1bc9bf040000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000341444b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e292b60000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e5f225acea8ee0d38dbde61b9d208f93f2acb1608c55c87fe98cd908d5fec518"}]}