{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/governance/Governance.sol\": {\r\n      \"content\": \"// /* Copyright (C) 2017 GovBlocks.io\\r\\n\\r\\n//   This program is free software: you can redistribute it and/or modify\\r\\n//     it under the terms of the GNU General Public License as published by\\r\\n//     the Free Software Foundation, either version 3 of the License, or\\r\\n//     (at your option) any later version.\\r\\n\\r\\n//   This program is distributed in the hope that it will be useful,\\r\\n//     but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n//     GNU General Public License for more details.\\r\\n\\r\\n//   You should have received a copy of the GNU General Public License\\r\\n//     along with this program.  If not, see http://www.gnu.org/licenses/ */\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"../token/TokenController.sol\\\";\\r\\nimport \\\"./MemberRoles.sol\\\";\\r\\nimport \\\"./ProposalCategory.sol\\\";\\r\\nimport \\\"./external/IGovernance.sol\\\";\\r\\n\\r\\ncontract Governance is IGovernance, Iupgradable {\\r\\n\\r\\n  using SafeMath for uint;\\r\\n\\r\\n  enum ProposalStatus {\\r\\n    Draft,\\r\\n    AwaitingSolution,\\r\\n    VotingStarted,\\r\\n    Accepted,\\r\\n    Rejected,\\r\\n    Majority_Not_Reached_But_Accepted,\\r\\n    Denied\\r\\n  }\\r\\n\\r\\n  struct ProposalData {\\r\\n    uint propStatus;\\r\\n    uint finalVerdict;\\r\\n    uint category;\\r\\n    uint commonIncentive;\\r\\n    uint dateUpd;\\r\\n    address owner;\\r\\n  }\\r\\n\\r\\n  struct ProposalVote {\\r\\n    address voter;\\r\\n    uint proposalId;\\r\\n    uint dateAdd;\\r\\n  }\\r\\n\\r\\n  struct VoteTally {\\r\\n    mapping(uint => uint) memberVoteValue;\\r\\n    mapping(uint => uint) abVoteValue;\\r\\n    uint voters;\\r\\n  }\\r\\n\\r\\n  struct DelegateVote {\\r\\n    address follower;\\r\\n    address leader;\\r\\n    uint lastUpd;\\r\\n  }\\r\\n\\r\\n  ProposalVote[] internal allVotes;\\r\\n  DelegateVote[] public allDelegation;\\r\\n\\r\\n  mapping(uint => ProposalData) internal allProposalData;\\r\\n  mapping(uint => bytes[]) internal allProposalSolutions;\\r\\n  mapping(address => uint[]) internal allVotesByMember;\\r\\n  mapping(uint => mapping(address => bool)) public rewardClaimed;\\r\\n  mapping(address => mapping(uint => uint)) public memberProposalVote;\\r\\n  mapping(address => uint) public followerDelegation;\\r\\n  mapping(address => uint) internal followerCount;\\r\\n  mapping(address => uint[]) internal leaderDelegation;\\r\\n  mapping(uint => VoteTally) public proposalVoteTally;\\r\\n  mapping(address => bool) public isOpenForDelegation;\\r\\n  mapping(address => uint) public lastRewardClaimed;\\r\\n\\r\\n  bool internal constructorCheck;\\r\\n  uint public tokenHoldingTime;\\r\\n  uint internal roleIdAllowedToCatgorize;\\r\\n  uint internal maxVoteWeigthPer;\\r\\n  uint internal specialResolutionMajPerc;\\r\\n  uint internal maxFollowers;\\r\\n  uint internal totalProposals;\\r\\n  uint internal maxDraftTime;\\r\\n\\r\\n  MemberRoles internal memberRole;\\r\\n  ProposalCategory internal proposalCategory;\\r\\n  TokenController internal tokenInstance;\\r\\n\\r\\n  mapping(uint => uint) public proposalActionStatus;\\r\\n  mapping(uint => uint) internal proposalExecutionTime;\\r\\n  mapping(uint => mapping(address => bool)) public proposalRejectedByAB;\\r\\n  mapping(uint => uint) internal actionRejectedCount;\\r\\n\\r\\n  bool internal actionParamsInitialised;\\r\\n  uint internal actionWaitingTime;\\r\\n  uint constant internal AB_MAJ_TO_REJECT_ACTION = 3;\\r\\n\\r\\n  enum ActionStatus {\\r\\n    Pending,\\r\\n    Accepted,\\r\\n    Rejected,\\r\\n    Executed,\\r\\n    NoAction\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Called whenever an action execution is failed.\\r\\n  */\\r\\n  event ActionFailed (\\r\\n    uint256 proposalId\\r\\n  );\\r\\n\\r\\n  /**\\r\\n  * @dev Called whenever an AB member rejects the action execution.\\r\\n  */\\r\\n  event ActionRejected (\\r\\n    uint256 indexed proposalId,\\r\\n    address rejectedBy\\r\\n  );\\r\\n\\r\\n  /**\\r\\n  * @dev Checks if msg.sender is proposal owner\\r\\n  */\\r\\n  modifier onlyProposalOwner(uint _proposalId) {\\r\\n    require(msg.sender == allProposalData[_proposalId].owner, \\\"Not allowed\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Checks if proposal is opened for voting\\r\\n  */\\r\\n  modifier voteNotStarted(uint _proposalId) {\\r\\n    require(allProposalData[_proposalId].propStatus < uint(ProposalStatus.VotingStarted));\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Checks if msg.sender is allowed to create proposal under given category\\r\\n  */\\r\\n  modifier isAllowed(uint _categoryId) {\\r\\n    require(allowedToCreateProposal(_categoryId), \\\"Not allowed\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Checks if msg.sender is allowed categorize proposal under given category\\r\\n  */\\r\\n  modifier isAllowedToCategorize() {\\r\\n    require(memberRole.checkRole(msg.sender, roleIdAllowedToCatgorize), \\\"Not allowed\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Checks if msg.sender had any pending rewards to be claimed\\r\\n  */\\r\\n  modifier checkPendingRewards {\\r\\n    require(getPendingReward(msg.sender) == 0, \\\"Claim reward\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Event emitted whenever a proposal is categorized\\r\\n  */\\r\\n  event ProposalCategorized(\\r\\n    uint indexed proposalId,\\r\\n    address indexed categorizedBy,\\r\\n    uint categoryId\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Removes delegation of an address.\\r\\n   * @param _add address to undelegate.\\r\\n   */\\r\\n  function removeDelegation(address _add) external onlyInternal {\\r\\n    _unDelegate(_add);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Creates a new proposal\\r\\n  * @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\\r\\n  * @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\\r\\n  */\\r\\n  function createProposal(\\r\\n    string calldata _proposalTitle,\\r\\n    string calldata _proposalSD,\\r\\n    string calldata _proposalDescHash,\\r\\n    uint _categoryId\\r\\n  )\\r\\n  external isAllowed(_categoryId)\\r\\n  {\\r\\n    require(ms.isMember(msg.sender), \\\"Not Member\\\");\\r\\n\\r\\n    _createProposal(_proposalTitle, _proposalSD, _proposalDescHash, _categoryId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Edits the details of an existing proposal\\r\\n  * @param _proposalId Proposal id that details needs to be updated\\r\\n  * @param _proposalDescHash Proposal description hash having long and short description of proposal.\\r\\n  */\\r\\n  function updateProposal(\\r\\n    uint _proposalId,\\r\\n    string calldata _proposalTitle,\\r\\n    string calldata _proposalSD,\\r\\n    string calldata _proposalDescHash\\r\\n  )\\r\\n  external onlyProposalOwner(_proposalId)\\r\\n  {\\r\\n    require(\\r\\n      allProposalSolutions[_proposalId].length < 2,\\r\\n      \\\"Not allowed\\\"\\r\\n    );\\r\\n    allProposalData[_proposalId].propStatus = uint(ProposalStatus.Draft);\\r\\n    allProposalData[_proposalId].category = 0;\\r\\n    allProposalData[_proposalId].commonIncentive = 0;\\r\\n    emit Proposal(\\r\\n      allProposalData[_proposalId].owner,\\r\\n      _proposalId,\\r\\n      now,\\r\\n      _proposalTitle,\\r\\n      _proposalSD,\\r\\n      _proposalDescHash\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\\r\\n  */\\r\\n  function categorizeProposal(\\r\\n    uint _proposalId,\\r\\n    uint _categoryId,\\r\\n    uint _incentive\\r\\n  )\\r\\n  external\\r\\n  voteNotStarted(_proposalId) isAllowedToCategorize\\r\\n  {\\r\\n    _categorizeProposal(_proposalId, _categoryId, _incentive);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Submit proposal with solution\\r\\n  * @param _proposalId Proposal id\\r\\n  * @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\\r\\n  */\\r\\n  function submitProposalWithSolution(\\r\\n    uint _proposalId,\\r\\n    string calldata _solutionHash,\\r\\n    bytes calldata _action\\r\\n  )\\r\\n  external\\r\\n  onlyProposalOwner(_proposalId)\\r\\n  {\\r\\n\\r\\n    require(allProposalData[_proposalId].propStatus == uint(ProposalStatus.AwaitingSolution));\\r\\n\\r\\n    _proposalSubmission(_proposalId, _solutionHash, _action);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Creates a new proposal with solution\\r\\n  * @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\\r\\n  * @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\\r\\n  * @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\\r\\n  */\\r\\n  function createProposalwithSolution(\\r\\n    string calldata _proposalTitle,\\r\\n    string calldata _proposalSD,\\r\\n    string calldata _proposalDescHash,\\r\\n    uint _categoryId,\\r\\n    string calldata _solutionHash,\\r\\n    bytes calldata _action\\r\\n  )\\r\\n  external isAllowed(_categoryId)\\r\\n  {\\r\\n\\r\\n\\r\\n    uint proposalId = totalProposals;\\r\\n\\r\\n    _createProposal(_proposalTitle, _proposalSD, _proposalDescHash, _categoryId);\\r\\n\\r\\n    require(_categoryId > 0);\\r\\n\\r\\n    _proposalSubmission(\\r\\n      proposalId,\\r\\n      _solutionHash,\\r\\n      _action\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Submit a vote on the proposal.\\r\\n   * @param _proposalId to vote upon.\\r\\n   * @param _solutionChosen is the chosen vote.\\r\\n   */\\r\\n  function submitVote(uint _proposalId, uint _solutionChosen) external {\\r\\n\\r\\n    require(allProposalData[_proposalId].propStatus ==\\r\\n      uint(Governance.ProposalStatus.VotingStarted), \\\"Not allowed\\\");\\r\\n\\r\\n    require(_solutionChosen < allProposalSolutions[_proposalId].length);\\r\\n\\r\\n\\r\\n    _submitVote(_proposalId, _solutionChosen);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Closes the proposal.\\r\\n   * @param _proposalId of proposal to be closed.\\r\\n   */\\r\\n  function closeProposal(uint _proposalId) external {\\r\\n    uint category = allProposalData[_proposalId].category;\\r\\n\\r\\n\\r\\n    uint _memberRole;\\r\\n    if (allProposalData[_proposalId].dateUpd.add(maxDraftTime) <= now &&\\r\\n      allProposalData[_proposalId].propStatus < uint(ProposalStatus.VotingStarted)) {\\r\\n      _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\\r\\n    } else {\\r\\n      require(canCloseProposal(_proposalId) == 1);\\r\\n      (, _memberRole,,,,,) = proposalCategory.category(allProposalData[_proposalId].category);\\r\\n      if (_memberRole == uint(MemberRoles.Role.AdvisoryBoard)) {\\r\\n        _closeAdvisoryBoardVote(_proposalId, category);\\r\\n      } else {\\r\\n        _closeMemberVote(_proposalId, category);\\r\\n      }\\r\\n    }\\r\\n\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Claims reward for member.\\r\\n   * @param _memberAddress to claim reward of.\\r\\n   * @param _maxRecords maximum number of records to claim reward for.\\r\\n   _proposals list of proposals of which reward will be claimed.\\r\\n   * @return amount of pending reward.\\r\\n   */\\r\\n  function claimReward(address _memberAddress, uint _maxRecords)\\r\\n  external returns (uint pendingDAppReward)\\r\\n  {\\r\\n\\r\\n    uint voteId;\\r\\n    address leader;\\r\\n    uint lastUpd;\\r\\n\\r\\n    require(msg.sender == ms.getLatestAddress(\\\"CR\\\"));\\r\\n\\r\\n    uint delegationId = followerDelegation[_memberAddress];\\r\\n    DelegateVote memory delegationData = allDelegation[delegationId];\\r\\n    if (delegationId > 0 && delegationData.leader != address(0)) {\\r\\n      leader = delegationData.leader;\\r\\n      lastUpd = delegationData.lastUpd;\\r\\n    } else\\r\\n      leader = _memberAddress;\\r\\n\\r\\n    uint proposalId;\\r\\n    uint totalVotes = allVotesByMember[leader].length;\\r\\n    uint lastClaimed = totalVotes;\\r\\n    uint j;\\r\\n    uint i;\\r\\n    for (i = lastRewardClaimed[_memberAddress]; i < totalVotes && j < _maxRecords; i++) {\\r\\n      voteId = allVotesByMember[leader][i];\\r\\n      proposalId = allVotes[voteId].proposalId;\\r\\n      if (proposalVoteTally[proposalId].voters > 0 && (allVotes[voteId].dateAdd > (\\r\\n      lastUpd.add(tokenHoldingTime)) || leader == _memberAddress)) {\\r\\n        if (allProposalData[proposalId].propStatus > uint(ProposalStatus.VotingStarted)) {\\r\\n          if (!rewardClaimed[voteId][_memberAddress]) {\\r\\n            pendingDAppReward = pendingDAppReward.add(\\r\\n              allProposalData[proposalId].commonIncentive.div(\\r\\n                proposalVoteTally[proposalId].voters\\r\\n              )\\r\\n            );\\r\\n            rewardClaimed[voteId][_memberAddress] = true;\\r\\n            j++;\\r\\n          }\\r\\n        } else {\\r\\n          if (lastClaimed == totalVotes) {\\r\\n            lastClaimed = i;\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (lastClaimed == totalVotes) {\\r\\n      lastRewardClaimed[_memberAddress] = i;\\r\\n    } else {\\r\\n      lastRewardClaimed[_memberAddress] = lastClaimed;\\r\\n    }\\r\\n\\r\\n    if (j > 0) {\\r\\n      emit RewardClaimed(\\r\\n        _memberAddress,\\r\\n        pendingDAppReward\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets delegation acceptance status of individual user\\r\\n   * @param _status delegation acceptance status\\r\\n   */\\r\\n  function setDelegationStatus(bool _status) external isMemberAndcheckPause checkPendingRewards {\\r\\n    isOpenForDelegation[msg.sender] = _status;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Delegates vote to an address.\\r\\n   * @param _add is the address to delegate vote to.\\r\\n   */\\r\\n  function delegateVote(address _add) external isMemberAndcheckPause checkPendingRewards {\\r\\n\\r\\n    require(ms.masterInitialized());\\r\\n\\r\\n    require(allDelegation[followerDelegation[_add]].leader == address(0));\\r\\n\\r\\n    if (followerDelegation[msg.sender] > 0) {\\r\\n      require((allDelegation[followerDelegation[msg.sender]].lastUpd).add(tokenHoldingTime) < now);\\r\\n    }\\r\\n\\r\\n    require(!alreadyDelegated(msg.sender));\\r\\n    require(!memberRole.checkRole(msg.sender, uint(MemberRoles.Role.Owner)));\\r\\n    require(!memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)));\\r\\n\\r\\n\\r\\n    require(followerCount[_add] < maxFollowers);\\r\\n\\r\\n    if (allVotesByMember[msg.sender].length > 0) {\\r\\n      require((allVotes[allVotesByMember[msg.sender][allVotesByMember[msg.sender].length - 1]].dateAdd).add(tokenHoldingTime)\\r\\n        < now);\\r\\n    }\\r\\n\\r\\n    require(ms.isMember(_add));\\r\\n\\r\\n    require(isOpenForDelegation[_add]);\\r\\n\\r\\n    allDelegation.push(DelegateVote(msg.sender, _add, now));\\r\\n    followerDelegation[msg.sender] = allDelegation.length - 1;\\r\\n    leaderDelegation[_add].push(allDelegation.length - 1);\\r\\n    followerCount[_add]++;\\r\\n    lastRewardClaimed[msg.sender] = allVotesByMember[_add].length;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Undelegates the sender\\r\\n   */\\r\\n  function unDelegate() external isMemberAndcheckPause checkPendingRewards {\\r\\n    _unDelegate(msg.sender);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Triggers action of accepted proposal after waiting time is finished\\r\\n   */\\r\\n  function triggerAction(uint _proposalId) external {\\r\\n    require(proposalActionStatus[_proposalId] == uint(ActionStatus.Accepted) && proposalExecutionTime[_proposalId] <= now, \\\"Cannot trigger\\\");\\r\\n    _triggerAction(_proposalId, allProposalData[_proposalId].category);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Provides option to Advisory board member to reject proposal action execution within actionWaitingTime, if found suspicious\\r\\n   */\\r\\n  function rejectAction(uint _proposalId) external {\\r\\n    require(memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)) && proposalExecutionTime[_proposalId] > now);\\r\\n\\r\\n    require(proposalActionStatus[_proposalId] == uint(ActionStatus.Accepted));\\r\\n\\r\\n    require(!proposalRejectedByAB[_proposalId][msg.sender]);\\r\\n\\r\\n    require(\\r\\n      keccak256(proposalCategory.categoryActionHashes(allProposalData[_proposalId].category))\\r\\n      != keccak256(abi.encodeWithSignature(\\\"swapABMember(address,address)\\\"))\\r\\n    );\\r\\n\\r\\n    proposalRejectedByAB[_proposalId][msg.sender] = true;\\r\\n    actionRejectedCount[_proposalId]++;\\r\\n    emit ActionRejected(_proposalId, msg.sender);\\r\\n    if (actionRejectedCount[_proposalId] == AB_MAJ_TO_REJECT_ACTION) {\\r\\n      proposalActionStatus[_proposalId] = uint(ActionStatus.Rejected);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets intial actionWaitingTime value\\r\\n   * To be called after governance implementation has been updated\\r\\n   */\\r\\n  function setInitialActionParameters() external onlyOwner {\\r\\n    require(!actionParamsInitialised);\\r\\n    actionParamsInitialised = true;\\r\\n    actionWaitingTime = 24 * 1 hours;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets Uint Parameters of a code\\r\\n   * @param code whose details we want\\r\\n   * @return string value of the code\\r\\n   * @return associated amount (time or perc or value) to the code\\r\\n   */\\r\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\\r\\n\\r\\n    codeVal = code;\\r\\n\\r\\n    if (code == \\\"GOVHOLD\\\") {\\r\\n\\r\\n      val = tokenHoldingTime / (1 days);\\r\\n\\r\\n    } else if (code == \\\"MAXFOL\\\") {\\r\\n\\r\\n      val = maxFollowers;\\r\\n\\r\\n    } else if (code == \\\"MAXDRFT\\\") {\\r\\n\\r\\n      val = maxDraftTime / (1 days);\\r\\n\\r\\n    } else if (code == \\\"EPTIME\\\") {\\r\\n\\r\\n      val = ms.pauseTime() / (1 days);\\r\\n\\r\\n    } else if (code == \\\"ACWT\\\") {\\r\\n\\r\\n      val = actionWaitingTime / (1 hours);\\r\\n\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets all details of a propsal\\r\\n   * @param _proposalId whose details we want\\r\\n   * @return proposalId\\r\\n   * @return category\\r\\n   * @return status\\r\\n   * @return finalVerdict\\r\\n   * @return totalReward\\r\\n   */\\r\\n  function proposal(uint _proposalId)\\r\\n  external\\r\\n  view\\r\\n  returns (\\r\\n    uint proposalId,\\r\\n    uint category,\\r\\n    uint status,\\r\\n    uint finalVerdict,\\r\\n    uint totalRewar\\r\\n  )\\r\\n  {\\r\\n    return (\\r\\n    _proposalId,\\r\\n    allProposalData[_proposalId].category,\\r\\n    allProposalData[_proposalId].propStatus,\\r\\n    allProposalData[_proposalId].finalVerdict,\\r\\n    allProposalData[_proposalId].commonIncentive\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets some details of a propsal\\r\\n   * @param _proposalId whose details we want\\r\\n   * @return proposalId\\r\\n   * @return number of all proposal solutions\\r\\n   * @return amount of votes\\r\\n   */\\r\\n  function proposalDetails(uint _proposalId) external view returns (uint, uint, uint) {\\r\\n    return (\\r\\n    _proposalId,\\r\\n    allProposalSolutions[_proposalId].length,\\r\\n    proposalVoteTally[_proposalId].voters\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets solution action on a proposal\\r\\n   * @param _proposalId whose details we want\\r\\n   * @param _solution whose details we want\\r\\n   * @return action of a solution on a proposal\\r\\n   */\\r\\n  function getSolutionAction(uint _proposalId, uint _solution) external view returns (uint, bytes memory) {\\r\\n    return (\\r\\n    _solution,\\r\\n    allProposalSolutions[_proposalId][_solution]\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets length of propsal\\r\\n   * @return length of propsal\\r\\n   */\\r\\n  function getProposalLength() external view returns (uint) {\\r\\n    return totalProposals;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Get followers of an address\\r\\n   * @return get followers of an address\\r\\n   */\\r\\n  function getFollowers(address _add) external view returns (uint[] memory) {\\r\\n    return leaderDelegation[_add];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets pending rewards of a member\\r\\n   * @param _memberAddress in concern\\r\\n   * @return amount of pending reward\\r\\n   */\\r\\n  function getPendingReward(address _memberAddress)\\r\\n  public view returns (uint pendingDAppReward)\\r\\n  {\\r\\n    uint delegationId = followerDelegation[_memberAddress];\\r\\n    address leader;\\r\\n    uint lastUpd;\\r\\n    DelegateVote memory delegationData = allDelegation[delegationId];\\r\\n\\r\\n    if (delegationId > 0 && delegationData.leader != address(0)) {\\r\\n      leader = delegationData.leader;\\r\\n      lastUpd = delegationData.lastUpd;\\r\\n    } else\\r\\n      leader = _memberAddress;\\r\\n\\r\\n    uint proposalId;\\r\\n    for (uint i = lastRewardClaimed[_memberAddress]; i < allVotesByMember[leader].length; i++) {\\r\\n      if (allVotes[allVotesByMember[leader][i]].dateAdd > (\\r\\n      lastUpd.add(tokenHoldingTime)) || leader == _memberAddress) {\\r\\n        if (!rewardClaimed[allVotesByMember[leader][i]][_memberAddress]) {\\r\\n          proposalId = allVotes[allVotesByMember[leader][i]].proposalId;\\r\\n          if (proposalVoteTally[proposalId].voters > 0 && allProposalData[proposalId].propStatus\\r\\n          > uint(ProposalStatus.VotingStarted)) {\\r\\n            pendingDAppReward = pendingDAppReward.add(\\r\\n              allProposalData[proposalId].commonIncentive.div(\\r\\n                proposalVoteTally[proposalId].voters\\r\\n              )\\r\\n            );\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Updates Uint Parameters of a code\\r\\n   * @param code whose details we want to update\\r\\n   * @param val value to set\\r\\n   */\\r\\n  function updateUintParameters(bytes8 code, uint val) public {\\r\\n\\r\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\r\\n    if (code == \\\"GOVHOLD\\\") {\\r\\n\\r\\n      tokenHoldingTime = val * 1 days;\\r\\n\\r\\n    } else if (code == \\\"MAXFOL\\\") {\\r\\n\\r\\n      maxFollowers = val;\\r\\n\\r\\n    } else if (code == \\\"MAXDRFT\\\") {\\r\\n\\r\\n      maxDraftTime = val * 1 days;\\r\\n\\r\\n    } else if (code == \\\"EPTIME\\\") {\\r\\n\\r\\n      ms.updatePauseTime(val * 1 days);\\r\\n\\r\\n    } else if (code == \\\"ACWT\\\") {\\r\\n\\r\\n      actionWaitingTime = val * 1 hours;\\r\\n\\r\\n    } else {\\r\\n\\r\\n      revert(\\\"Invalid code\\\");\\r\\n\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Updates all dependency addresses to latest ones from Master\\r\\n  */\\r\\n  function changeDependentContractAddress() public {\\r\\n    tokenInstance = TokenController(ms.dAppLocker());\\r\\n    memberRole = MemberRoles(ms.getLatestAddress(\\\"MR\\\"));\\r\\n    proposalCategory = ProposalCategory(ms.getLatestAddress(\\\"PC\\\"));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Checks if msg.sender is allowed to create a proposal under given category\\r\\n  */\\r\\n  function allowedToCreateProposal(uint category) public view returns (bool check) {\\r\\n    if (category == 0)\\r\\n      return true;\\r\\n    uint[] memory mrAllowed;\\r\\n    (,,,, mrAllowed,,) = proposalCategory.category(category);\\r\\n    for (uint i = 0; i < mrAllowed.length; i++) {\\r\\n      if (mrAllowed[i] == 0 || memberRole.checkRole(msg.sender, mrAllowed[i]))\\r\\n        return true;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Checks if an address is already delegated\\r\\n   * @param _add in concern\\r\\n   * @return bool value if the address is delegated or not\\r\\n   */\\r\\n  function alreadyDelegated(address _add) public view returns (bool delegated) {\\r\\n    for (uint i = 0; i < leaderDelegation[_add].length; i++) {\\r\\n      if (allDelegation[leaderDelegation[_add][i]].leader == _add) {\\r\\n        return true;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Checks If the proposal voting time is up and it's ready to close\\r\\n  *      i.e. Closevalue is 1 if proposal is ready to be closed, 2 if already closed, 0 otherwise!\\r\\n  * @param _proposalId Proposal id to which closing value is being checked\\r\\n  */\\r\\n  function canCloseProposal(uint _proposalId)\\r\\n  public\\r\\n  view\\r\\n  returns (uint)\\r\\n  {\\r\\n    uint dateUpdate;\\r\\n    uint pStatus;\\r\\n    uint _closingTime;\\r\\n    uint _roleId;\\r\\n    uint majority;\\r\\n    pStatus = allProposalData[_proposalId].propStatus;\\r\\n    dateUpdate = allProposalData[_proposalId].dateUpd;\\r\\n    (, _roleId, majority, , , _closingTime,) = proposalCategory.category(allProposalData[_proposalId].category);\\r\\n    if (\\r\\n      pStatus == uint(ProposalStatus.VotingStarted)\\r\\n    ) {\\r\\n      uint numberOfMembers = memberRole.numberOfMembers(_roleId);\\r\\n      if (_roleId == uint(MemberRoles.Role.AdvisoryBoard)) {\\r\\n        if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100).div(numberOfMembers) >= majority\\r\\n        || proposalVoteTally[_proposalId].abVoteValue[1].add(proposalVoteTally[_proposalId].abVoteValue[0]) == numberOfMembers\\r\\n          || dateUpdate.add(_closingTime) <= now) {\\r\\n\\r\\n          return 1;\\r\\n        }\\r\\n      } else {\\r\\n        if (numberOfMembers == proposalVoteTally[_proposalId].voters\\r\\n          || dateUpdate.add(_closingTime) <= now)\\r\\n          return 1;\\r\\n      }\\r\\n    } else if (pStatus > uint(ProposalStatus.VotingStarted)) {\\r\\n      return 2;\\r\\n    } else {\\r\\n      return 0;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets Id of member role allowed to categorize the proposal\\r\\n   * @return roleId allowed to categorize the proposal\\r\\n   */\\r\\n  function allowedToCatgorize() public view returns (uint roleId) {\\r\\n    return roleIdAllowedToCatgorize;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets vote tally data\\r\\n   * @param _proposalId in concern\\r\\n   * @param _solution of a proposal id\\r\\n   * @return member vote value\\r\\n   * @return advisory board vote value\\r\\n   * @return amount of votes\\r\\n   */\\r\\n  function voteTallyData(uint _proposalId, uint _solution) public view returns (uint, uint, uint) {\\r\\n    return (proposalVoteTally[_proposalId].memberVoteValue[_solution],\\r\\n    proposalVoteTally[_proposalId].abVoteValue[_solution], proposalVoteTally[_proposalId].voters);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to create proposal\\r\\n   * @param _proposalTitle of proposal\\r\\n   * @param _proposalSD is short description of proposal\\r\\n   * @param _proposalDescHash IPFS hash value of propsal\\r\\n   * @param _categoryId of proposal\\r\\n   */\\r\\n  function _createProposal(\\r\\n    string memory _proposalTitle,\\r\\n    string memory _proposalSD,\\r\\n    string memory _proposalDescHash,\\r\\n    uint _categoryId\\r\\n  )\\r\\n  internal\\r\\n  {\\r\\n    require(proposalCategory.categoryABReq(_categoryId) == 0 || _categoryId == 0);\\r\\n    uint _proposalId = totalProposals;\\r\\n    allProposalData[_proposalId].owner = msg.sender;\\r\\n    allProposalData[_proposalId].dateUpd = now;\\r\\n    allProposalSolutions[_proposalId].push(\\\"\\\");\\r\\n    totalProposals++;\\r\\n\\r\\n    emit Proposal(\\r\\n      msg.sender,\\r\\n      _proposalId,\\r\\n      now,\\r\\n      _proposalTitle,\\r\\n      _proposalSD,\\r\\n      _proposalDescHash\\r\\n    );\\r\\n\\r\\n    if (_categoryId > 0)\\r\\n      _categorizeProposal(_proposalId, _categoryId, 0);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to categorize a proposal\\r\\n   * @param _proposalId of proposal\\r\\n   * @param _categoryId of proposal\\r\\n   * @param _incentive is commonIncentive\\r\\n   */\\r\\n  function _categorizeProposal(\\r\\n    uint _proposalId,\\r\\n    uint _categoryId,\\r\\n    uint _incentive\\r\\n  )\\r\\n  internal\\r\\n  {\\r\\n    require(\\r\\n      _categoryId > 0 && _categoryId < proposalCategory.totalCategories(),\\r\\n      \\\"Invalid category\\\"\\r\\n    );\\r\\n    allProposalData[_proposalId].category = _categoryId;\\r\\n    allProposalData[_proposalId].commonIncentive = _incentive;\\r\\n    allProposalData[_proposalId].propStatus = uint(ProposalStatus.AwaitingSolution);\\r\\n\\r\\n    emit ProposalCategorized(_proposalId, msg.sender, _categoryId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to add solution to a proposal\\r\\n   * @param _proposalId in concern\\r\\n   * @param _action on that solution\\r\\n   * @param _solutionHash string value\\r\\n   */\\r\\n  function _addSolution(uint _proposalId, bytes memory _action, string memory _solutionHash)\\r\\n  internal\\r\\n  {\\r\\n    allProposalSolutions[_proposalId].push(_action);\\r\\n    emit Solution(_proposalId, msg.sender, allProposalSolutions[_proposalId].length - 1, _solutionHash, now);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Internal call to add solution and open proposal for voting\\r\\n  */\\r\\n  function _proposalSubmission(\\r\\n    uint _proposalId,\\r\\n    string memory _solutionHash,\\r\\n    bytes memory _action\\r\\n  )\\r\\n  internal\\r\\n  {\\r\\n\\r\\n    uint _categoryId = allProposalData[_proposalId].category;\\r\\n    if (proposalCategory.categoryActionHashes(_categoryId).length == 0) {\\r\\n      require(keccak256(_action) == keccak256(\\\"\\\"));\\r\\n      proposalActionStatus[_proposalId] = uint(ActionStatus.NoAction);\\r\\n    }\\r\\n\\r\\n    _addSolution(\\r\\n      _proposalId,\\r\\n      _action,\\r\\n      _solutionHash\\r\\n    );\\r\\n\\r\\n    _updateProposalStatus(_proposalId, uint(ProposalStatus.VotingStarted));\\r\\n    (, , , , , uint closingTime,) = proposalCategory.category(_categoryId);\\r\\n    emit CloseProposalOnTime(_proposalId, closingTime.add(now));\\r\\n\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to submit vote\\r\\n   * @param _proposalId of proposal in concern\\r\\n   * @param _solution for that proposal\\r\\n   */\\r\\n  function _submitVote(uint _proposalId, uint _solution) internal {\\r\\n\\r\\n    uint delegationId = followerDelegation[msg.sender];\\r\\n    uint mrSequence;\\r\\n    uint majority;\\r\\n    uint closingTime;\\r\\n    (, mrSequence, majority, , , closingTime,) = proposalCategory.category(allProposalData[_proposalId].category);\\r\\n\\r\\n    require(allProposalData[_proposalId].dateUpd.add(closingTime) > now, \\\"Closed\\\");\\r\\n\\r\\n    require(memberProposalVote[msg.sender][_proposalId] == 0, \\\"Not allowed\\\");\\r\\n    require((delegationId == 0) || (delegationId > 0 && allDelegation[delegationId].leader == address(0) &&\\r\\n    _checkLastUpd(allDelegation[delegationId].lastUpd)));\\r\\n\\r\\n    require(memberRole.checkRole(msg.sender, mrSequence), \\\"Not Authorized\\\");\\r\\n    uint totalVotes = allVotes.length;\\r\\n\\r\\n    allVotesByMember[msg.sender].push(totalVotes);\\r\\n    memberProposalVote[msg.sender][_proposalId] = totalVotes;\\r\\n\\r\\n    allVotes.push(ProposalVote(msg.sender, _proposalId, now));\\r\\n\\r\\n    emit Vote(msg.sender, _proposalId, totalVotes, now, _solution);\\r\\n    if (mrSequence == uint(MemberRoles.Role.Owner)) {\\r\\n      if (_solution == 1)\\r\\n        _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), allProposalData[_proposalId].category, 1, MemberRoles.Role.Owner);\\r\\n      else\\r\\n        _updateProposalStatus(_proposalId, uint(ProposalStatus.Rejected));\\r\\n\\r\\n    } else {\\r\\n      uint numberOfMembers = memberRole.numberOfMembers(mrSequence);\\r\\n      _setVoteTally(_proposalId, _solution, mrSequence);\\r\\n\\r\\n      if (mrSequence == uint(MemberRoles.Role.AdvisoryBoard)) {\\r\\n        if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100).div(numberOfMembers)\\r\\n        >= majority\\r\\n          || (proposalVoteTally[_proposalId].abVoteValue[1].add(proposalVoteTally[_proposalId].abVoteValue[0])) == numberOfMembers) {\\r\\n          emit VoteCast(_proposalId);\\r\\n        }\\r\\n      } else {\\r\\n        if (numberOfMembers == proposalVoteTally[_proposalId].voters)\\r\\n          emit VoteCast(_proposalId);\\r\\n      }\\r\\n    }\\r\\n\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to set vote tally of a proposal\\r\\n   * @param _proposalId of proposal in concern\\r\\n   * @param _solution of proposal in concern\\r\\n   * @param mrSequence number of members for a role\\r\\n   */\\r\\n  function _setVoteTally(uint _proposalId, uint _solution, uint mrSequence) internal\\r\\n  {\\r\\n    uint categoryABReq;\\r\\n    uint isSpecialResolution;\\r\\n    (, categoryABReq, isSpecialResolution) = proposalCategory.categoryExtendedData(allProposalData[_proposalId].category);\\r\\n    if (memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)) && (categoryABReq > 0) ||\\r\\n      mrSequence == uint(MemberRoles.Role.AdvisoryBoard)) {\\r\\n      proposalVoteTally[_proposalId].abVoteValue[_solution]++;\\r\\n    }\\r\\n    tokenInstance.lockForMemberVote(msg.sender, tokenHoldingTime);\\r\\n    if (mrSequence != uint(MemberRoles.Role.AdvisoryBoard)) {\\r\\n      uint voteWeight;\\r\\n      uint voters = 1;\\r\\n      uint tokenBalance = tokenInstance.totalBalanceOf(msg.sender);\\r\\n      uint totalSupply = tokenInstance.totalSupply();\\r\\n      if (isSpecialResolution == 1) {\\r\\n        voteWeight = tokenBalance.add(10 ** 18);\\r\\n      } else {\\r\\n        voteWeight = (_minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100))).add(10 ** 18);\\r\\n      }\\r\\n      DelegateVote memory delegationData;\\r\\n      for (uint i = 0; i < leaderDelegation[msg.sender].length; i++) {\\r\\n        delegationData = allDelegation[leaderDelegation[msg.sender][i]];\\r\\n        if (delegationData.leader == msg.sender &&\\r\\n          _checkLastUpd(delegationData.lastUpd)) {\\r\\n          if (memberRole.checkRole(delegationData.follower, mrSequence)) {\\r\\n            tokenBalance = tokenInstance.totalBalanceOf(delegationData.follower);\\r\\n            tokenInstance.lockForMemberVote(delegationData.follower, tokenHoldingTime);\\r\\n            voters++;\\r\\n            if (isSpecialResolution == 1) {\\r\\n              voteWeight = voteWeight.add(tokenBalance.add(10 ** 18));\\r\\n            } else {\\r\\n              voteWeight = voteWeight.add((_minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100))).add(10 ** 18));\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n      proposalVoteTally[_proposalId].memberVoteValue[_solution] = proposalVoteTally[_proposalId].memberVoteValue[_solution].add(voteWeight);\\r\\n      proposalVoteTally[_proposalId].voters = proposalVoteTally[_proposalId].voters + voters;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets minimum of two numbers\\r\\n   * @param a one of the two numbers\\r\\n   * @param b one of the two numbers\\r\\n   * @return minimum number out of the two\\r\\n   */\\r\\n  function _minOf(uint a, uint b) internal pure returns (uint res) {\\r\\n    res = a;\\r\\n    if (res > b)\\r\\n      res = b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Check the time since last update has exceeded token holding time or not\\r\\n   * @param _lastUpd is last update time\\r\\n   * @return the bool which tells if the time since last update has exceeded token holding time or not\\r\\n   */\\r\\n  function _checkLastUpd(uint _lastUpd) internal view returns (bool) {\\r\\n    return (now - _lastUpd) > tokenHoldingTime;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Checks if the vote count against any solution passes the threshold value or not.\\r\\n  */\\r\\n  function _checkForThreshold(uint _proposalId, uint _category) internal view returns (bool check) {\\r\\n    uint categoryQuorumPerc;\\r\\n    uint roleAuthorized;\\r\\n    (, roleAuthorized, , categoryQuorumPerc, , ,) = proposalCategory.category(_category);\\r\\n    check = ((proposalVoteTally[_proposalId].memberVoteValue[0]\\r\\n    .add(proposalVoteTally[_proposalId].memberVoteValue[1]))\\r\\n    .mul(100))\\r\\n    .div(\\r\\n      tokenInstance.totalSupply().add(\\r\\n        memberRole.numberOfMembers(roleAuthorized).mul(10 ** 18)\\r\\n      )\\r\\n    ) >= categoryQuorumPerc;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Called when vote majority is reached\\r\\n   * @param _proposalId of proposal in concern\\r\\n   * @param _status of proposal in concern\\r\\n   * @param category of proposal in concern\\r\\n   * @param max vote value of proposal in concern\\r\\n   */\\r\\n  function _callIfMajReached(uint _proposalId, uint _status, uint category, uint max, MemberRoles.Role role) internal {\\r\\n\\r\\n    allProposalData[_proposalId].finalVerdict = max;\\r\\n    _updateProposalStatus(_proposalId, _status);\\r\\n    emit ProposalAccepted(_proposalId);\\r\\n    if (proposalActionStatus[_proposalId] != uint(ActionStatus.NoAction)) {\\r\\n      if (role == MemberRoles.Role.AdvisoryBoard) {\\r\\n        _triggerAction(_proposalId, category);\\r\\n      } else {\\r\\n        proposalActionStatus[_proposalId] = uint(ActionStatus.Accepted);\\r\\n        proposalExecutionTime[_proposalId] = actionWaitingTime.add(now);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to trigger action of accepted proposal\\r\\n   */\\r\\n  function _triggerAction(uint _proposalId, uint _categoryId) internal {\\r\\n    proposalActionStatus[_proposalId] = uint(ActionStatus.Executed);\\r\\n    bytes2 contractName;\\r\\n    address actionAddress;\\r\\n    bytes memory _functionHash;\\r\\n    (, actionAddress, contractName, , _functionHash) = proposalCategory.categoryActionDetails(_categoryId);\\r\\n    if (contractName == \\\"MS\\\") {\\r\\n      actionAddress = address(ms);\\r\\n    } else if (contractName != \\\"EX\\\") {\\r\\n      actionAddress = ms.getLatestAddress(contractName);\\r\\n    }\\r\\n    // solhint-disable-next-line avoid-low-level-calls\\r\\n    (bool actionStatus,) = actionAddress.call(abi.encodePacked(_functionHash, allProposalSolutions[_proposalId][1]));\\r\\n    if (actionStatus) {\\r\\n      emit ActionSuccess(_proposalId);\\r\\n    } else {\\r\\n      proposalActionStatus[_proposalId] = uint(ActionStatus.Accepted);\\r\\n      emit ActionFailed(_proposalId);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to update proposal status\\r\\n   * @param _proposalId of proposal in concern\\r\\n   * @param _status of proposal to set\\r\\n   */\\r\\n  function _updateProposalStatus(uint _proposalId, uint _status) internal {\\r\\n    if (_status == uint(ProposalStatus.Rejected) || _status == uint(ProposalStatus.Denied)) {\\r\\n      proposalActionStatus[_proposalId] = uint(ActionStatus.NoAction);\\r\\n    }\\r\\n    allProposalData[_proposalId].dateUpd = now;\\r\\n    allProposalData[_proposalId].propStatus = _status;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to undelegate a follower\\r\\n   * @param _follower is address of follower to undelegate\\r\\n   */\\r\\n  function _unDelegate(address _follower) internal {\\r\\n\\r\\n    uint delegationId = followerDelegation[_follower];\\r\\n    DelegateVote memory delegation = allDelegation[delegationId];\\r\\n\\r\\n    if (delegation.leader != address(0)) {\\r\\n\\r\\n      uint currentFollowerCount = followerCount[delegation.leader];\\r\\n\\r\\n      if (currentFollowerCount > 0) {\\r\\n        followerCount[delegation.leader] = currentFollowerCount.sub(1);\\r\\n      }\\r\\n\\r\\n      allDelegation[delegationId].leader = address(0);\\r\\n      allDelegation[delegationId].lastUpd = now;\\r\\n      lastRewardClaimed[_follower] = allVotesByMember[_follower].length;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to close member voting\\r\\n   * @param _proposalId of proposal in concern\\r\\n   * @param category of proposal in concern\\r\\n   */\\r\\n  function _closeMemberVote(uint _proposalId, uint category) internal {\\r\\n    uint isSpecialResolution;\\r\\n    uint abMaj;\\r\\n    (, abMaj, isSpecialResolution) = proposalCategory.categoryExtendedData(category);\\r\\n    if (isSpecialResolution == 1) {\\r\\n      uint acceptedVotePerc = proposalVoteTally[_proposalId].memberVoteValue[1].mul(100)\\r\\n      .div(\\r\\n        tokenInstance.totalSupply().add(\\r\\n          memberRole.numberOfMembers(uint(MemberRoles.Role.Member)).mul(10 ** 18)\\r\\n        ));\\r\\n      if (acceptedVotePerc >= specialResolutionMajPerc) {\\r\\n        _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\\r\\n      } else {\\r\\n        _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\\r\\n      }\\r\\n    } else {\\r\\n      if (_checkForThreshold(_proposalId, category)) {\\r\\n        uint majorityVote;\\r\\n        (,, majorityVote,,,,) = proposalCategory.category(category);\\r\\n        if (\\r\\n          ((proposalVoteTally[_proposalId].memberVoteValue[1].mul(100))\\r\\n          .div(proposalVoteTally[_proposalId].memberVoteValue[0]\\r\\n          .add(proposalVoteTally[_proposalId].memberVoteValue[1])\\r\\n          ))\\r\\n          >= majorityVote\\r\\n        ) {\\r\\n          _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\\r\\n        } else {\\r\\n          _updateProposalStatus(_proposalId, uint(ProposalStatus.Rejected));\\r\\n        }\\r\\n      } else {\\r\\n        if (abMaj > 0 && proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\\r\\n        .div(memberRole.numberOfMembers(uint(MemberRoles.Role.AdvisoryBoard))) >= abMaj) {\\r\\n          _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\\r\\n        } else {\\r\\n          _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (proposalVoteTally[_proposalId].voters > 0) {\\r\\n      tokenInstance.mint(ms.getLatestAddress(\\\"CR\\\"), allProposalData[_proposalId].commonIncentive);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to close advisory board voting\\r\\n   * @param _proposalId of proposal in concern\\r\\n   * @param category of proposal in concern\\r\\n   */\\r\\n  function _closeAdvisoryBoardVote(uint _proposalId, uint category) internal {\\r\\n    uint _majorityVote;\\r\\n    MemberRoles.Role _roleId = MemberRoles.Role.AdvisoryBoard;\\r\\n    (,, _majorityVote,,,,) = proposalCategory.category(category);\\r\\n    if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\\r\\n    .div(memberRole.numberOfMembers(uint(_roleId))) >= _majorityVote) {\\r\\n      _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, _roleId);\\r\\n    } else {\\r\\n      _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\\r\\n    }\\r\\n\\r\\n  }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/TokenController.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n  it under the terms of the GNU General Public License as published by\\n  the Free Software Foundation, either version 3 of the License, or\\n  (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n  GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n  along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\nimport \\\"../../interfaces/IPooledStaking.sol\\\";\\nimport \\\"../claims/ClaimsData.sol\\\";\\nimport \\\"./NXMToken.sol\\\";\\nimport \\\"./external/LockHandler.sol\\\";\\n\\ncontract TokenController is LockHandler, Iupgradable {\\n  using SafeMath for uint256;\\n\\n  struct CoverInfo {\\n    uint16 claimCount;\\n    bool hasOpenClaim;\\n    bool hasAcceptedClaim;\\n    // note: still 224 bits available here, can be used later\\n  }\\n\\n  NXMToken public token;\\n  IPooledStaking public pooledStaking;\\n\\n  uint public minCALockTime;\\n  uint public claimSubmissionGracePeriod;\\n\\n  // coverId => CoverInfo\\n  mapping(uint => CoverInfo) public coverInfo;\\n\\n  event Locked(address indexed _of, bytes32 indexed _reason, uint256 _amount, uint256 _validity);\\n\\n  event Unlocked(address indexed _of, bytes32 indexed _reason, uint256 _amount);\\n\\n  event Burned(address indexed member, bytes32 lockedUnder, uint256 amount);\\n\\n  modifier onlyGovernance {\\n    require(msg.sender == ms.getLatestAddress(\\\"GV\\\"), \\\"TokenController: Caller is not governance\\\");\\n    _;\\n  }\\n\\n  /**\\n  * @dev Just for interface\\n  */\\n  function changeDependentContractAddress() public {\\n    token = NXMToken(ms.tokenAddress());\\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\\\"PS\\\"));\\n  }\\n\\n  function markCoverClaimOpen(uint coverId) external onlyInternal {\\n\\n    CoverInfo storage info = coverInfo[coverId];\\n\\n    uint16 claimCount;\\n    bool hasOpenClaim;\\n    bool hasAcceptedClaim;\\n\\n    // reads all of them using a single SLOAD\\n    (claimCount, hasOpenClaim, hasAcceptedClaim) = (info.claimCount, info.hasOpenClaim, info.hasAcceptedClaim);\\n\\n    // no safemath for uint16 but should be safe from\\n    // overflows as there're max 2 claims per cover\\n    claimCount = claimCount + 1;\\n\\n    require(claimCount <= 2, \\\"TokenController: Max claim count exceeded\\\");\\n    require(hasOpenClaim == false, \\\"TokenController: Cover already has an open claim\\\");\\n    require(hasAcceptedClaim == false, \\\"TokenController: Cover already has accepted claims\\\");\\n\\n    // should use a single SSTORE for both\\n    (info.claimCount, info.hasOpenClaim) = (claimCount, true);\\n  }\\n\\n  /**\\n   * @param coverId cover id (careful, not claim id!)\\n   * @param isAccepted claim verdict\\n   */\\n  function markCoverClaimClosed(uint coverId, bool isAccepted) external onlyInternal {\\n\\n    CoverInfo storage info = coverInfo[coverId];\\n    require(info.hasOpenClaim == true, \\\"TokenController: Cover claim is not marked as open\\\");\\n\\n    // should use a single SSTORE for both\\n    (info.hasOpenClaim, info.hasAcceptedClaim) = (false, isAccepted);\\n  }\\n\\n  /**\\n   * @dev to change the operator address\\n   * @param _newOperator is the new address of operator\\n   */\\n  function changeOperator(address _newOperator) public onlyInternal {\\n    token.changeOperator(_newOperator);\\n  }\\n\\n  /**\\n   * @dev Proxies token transfer through this contract to allow staking when members are locked for voting\\n   * @param _from   Source address\\n   * @param _to     Destination address\\n   * @param _value  Amount to transfer\\n   */\\n  function operatorTransfer(address _from, address _to, uint _value) external onlyInternal returns (bool) {\\n    require(msg.sender == address(pooledStaking), \\\"TokenController: Call is only allowed from PooledStaking address\\\");\\n    token.operatorTransfer(_from, _value);\\n    token.transfer(_to, _value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Locks a specified amount of tokens,\\n  *    for CLA reason and for a specified time\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  */\\n  function lockClaimAssessmentTokens(uint256 _amount, uint256 _time) external checkPause {\\n    require(minCALockTime <= _time, \\\"TokenController: Must lock for minimum time\\\");\\n    require(_time <= 180 days, \\\"TokenController: Tokens can be locked for 180 days maximum\\\");\\n    // If tokens are already locked, then functions extendLock or\\n    // increaseClaimAssessmentLock should be used to make any changes\\n    _lock(msg.sender, \\\"CLA\\\", _amount, _time);\\n  }\\n\\n  /**\\n  * @dev Locks a specified amount of tokens against an address,\\n  *    for a specified reason and time\\n  * @param _reason The reason to lock tokens\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  * @param _of address whose tokens are to be locked\\n  */\\n  function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time)\\n  public\\n  onlyInternal\\n  returns (bool)\\n  {\\n    // If tokens are already locked, then functions extendLock or\\n    // increaseLockAmount should be used to make any changes\\n    _lock(_of, _reason, _amount, _time);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Mints and locks a specified amount of tokens against an address,\\n  *      for a CN reason and time\\n  * @param _of address whose tokens are to be locked\\n  * @param _reason The reason to lock tokens\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  */\\n  function mintCoverNote(\\n    address _of,\\n    bytes32 _reason,\\n    uint256 _amount,\\n    uint256 _time\\n  ) external onlyInternal {\\n\\n    require(_tokensLocked(_of, _reason) == 0, \\\"TokenController: An amount of tokens is already locked\\\");\\n    require(_amount != 0, \\\"TokenController: Amount shouldn't be zero\\\");\\n\\n    if (locked[_of][_reason].amount == 0) {\\n      lockReason[_of].push(_reason);\\n    }\\n\\n    token.mint(address(this), _amount);\\n\\n    uint256 lockedUntil = now.add(_time);\\n    locked[_of][_reason] = LockToken(_amount, lockedUntil, false);\\n\\n    emit Locked(_of, _reason, _amount, lockedUntil);\\n  }\\n\\n  /**\\n  * @dev Extends lock for reason CLA for a specified time\\n  * @param _time Lock extension time in seconds\\n  */\\n  function extendClaimAssessmentLock(uint256 _time) external checkPause {\\n    uint256 validity = getLockedTokensValidity(msg.sender, \\\"CLA\\\");\\n    require(validity.add(_time).sub(block.timestamp) <= 180 days, \\\"TokenController: Tokens can be locked for 180 days maximum\\\");\\n    _extendLock(msg.sender, \\\"CLA\\\", _time);\\n  }\\n\\n  /**\\n  * @dev Extends lock for a specified reason and time\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock extension time in seconds\\n  */\\n  function extendLockOf(address _of, bytes32 _reason, uint256 _time)\\n  public\\n  onlyInternal\\n  returns (bool)\\n  {\\n    _extendLock(_of, _reason, _time);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Increase number of tokens locked for a CLA reason\\n  * @param _amount Number of tokens to be increased\\n  */\\n  function increaseClaimAssessmentLock(uint256 _amount) external checkPause\\n  {\\n    require(_tokensLocked(msg.sender, \\\"CLA\\\") > 0, \\\"TokenController: No tokens locked\\\");\\n    token.operatorTransfer(msg.sender, _amount);\\n\\n    locked[msg.sender][\\\"CLA\\\"].amount = locked[msg.sender][\\\"CLA\\\"].amount.add(_amount);\\n    emit Locked(msg.sender, \\\"CLA\\\", _amount, locked[msg.sender][\\\"CLA\\\"].validity);\\n  }\\n\\n  /**\\n   * @dev burns tokens of an address\\n   * @param _of is the address to burn tokens of\\n   * @param amount is the amount to burn\\n   * @return the boolean status of the burning process\\n   */\\n  function burnFrom(address _of, uint amount) public onlyInternal returns (bool) {\\n    return token.burnFrom(_of, amount);\\n  }\\n\\n  /**\\n  * @dev Burns locked tokens of a user\\n  * @param _of address whose tokens are to be burned\\n  * @param _reason lock reason for which tokens are to be burned\\n  * @param _amount amount of tokens to burn\\n  */\\n  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) public onlyInternal {\\n    _burnLockedTokens(_of, _reason, _amount);\\n  }\\n\\n  /**\\n  * @dev reduce lock duration for a specified reason and time\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock reduction time in seconds\\n  */\\n  function reduceLock(address _of, bytes32 _reason, uint256 _time) public onlyInternal {\\n    _reduceLock(_of, _reason, _time);\\n  }\\n\\n  /**\\n  * @dev Released locked tokens of an address locked for a specific reason\\n  * @param _of address whose tokens are to be released from lock\\n  * @param _reason reason of the lock\\n  * @param _amount amount of tokens to release\\n  */\\n  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount)\\n  public\\n  onlyInternal\\n  {\\n    _releaseLockedTokens(_of, _reason, _amount);\\n  }\\n\\n  /**\\n  * @dev Adds an address to whitelist maintained in the contract\\n  * @param _member address to add to whitelist\\n  */\\n  function addToWhitelist(address _member) public onlyInternal {\\n    token.addToWhiteList(_member);\\n  }\\n\\n  /**\\n  * @dev Removes an address from the whitelist in the token\\n  * @param _member address to remove\\n  */\\n  function removeFromWhitelist(address _member) public onlyInternal {\\n    token.removeFromWhiteList(_member);\\n  }\\n\\n  /**\\n  * @dev Mints new token for an address\\n  * @param _member address to reward the minted tokens\\n  * @param _amount number of tokens to mint\\n  */\\n  function mint(address _member, uint _amount) public onlyInternal {\\n    token.mint(_member, _amount);\\n  }\\n\\n  /**\\n   * @dev Lock the user's tokens\\n   * @param _of user's address.\\n   */\\n  function lockForMemberVote(address _of, uint _days) public onlyInternal {\\n    token.lockForMemberVote(_of, _days);\\n  }\\n\\n  /**\\n  * @dev Unlocks the withdrawable tokens against CLA of a specified address\\n  * @param _of Address of user, claiming back withdrawable tokens against CLA\\n  */\\n  function withdrawClaimAssessmentTokens(address _of) external checkPause {\\n    uint256 withdrawableTokens = _tokensUnlockable(_of, \\\"CLA\\\");\\n    if (withdrawableTokens > 0) {\\n      locked[_of][\\\"CLA\\\"].claimed = true;\\n      emit Unlocked(_of, \\\"CLA\\\", withdrawableTokens);\\n      token.transfer(_of, withdrawableTokens);\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param value value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint value) external onlyGovernance {\\n\\n    if (code == \\\"MNCLT\\\") {\\n      minCALockTime = value;\\n      return;\\n    }\\n\\n    if (code == \\\"GRACEPER\\\") {\\n      claimSubmissionGracePeriod = value;\\n      return;\\n    }\\n\\n    revert(\\\"TokenController: invalid param code\\\");\\n  }\\n\\n  function getLockReasons(address _of) external view returns (bytes32[] memory reasons) {\\n    return lockReason[_of];\\n  }\\n\\n  /**\\n  * @dev Gets the validity of locked tokens of a specified address\\n  * @param _of The address to query the validity\\n  * @param reason reason for which tokens were locked\\n  */\\n  function getLockedTokensValidity(address _of, bytes32 reason) public view returns (uint256 validity) {\\n    validity = locked[_of][reason].validity;\\n  }\\n\\n  /**\\n  * @dev Gets the unlockable tokens of a specified address\\n  * @param _of The address to query the the unlockable token count of\\n  */\\n  function getUnlockableTokens(address _of)\\n  public\\n  view\\n  returns (uint256 unlockableTokens)\\n  {\\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\\n      unlockableTokens = unlockableTokens.add(_tokensUnlockable(_of, lockReason[_of][i]));\\n    }\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  */\\n  function tokensLocked(address _of, bytes32 _reason)\\n  public\\n  view\\n  returns (uint256 amount)\\n  {\\n    return _tokensLocked(_of, _reason);\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked and validity for a specified address and reason\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  */\\n  function tokensLockedWithValidity(address _of, bytes32 _reason)\\n  public\\n  view\\n  returns (uint256 amount, uint256 validity)\\n  {\\n\\n    bool claimed = locked[_of][_reason].claimed;\\n    amount = locked[_of][_reason].amount;\\n    validity = locked[_of][_reason].validity;\\n\\n    if (claimed) {\\n      amount = 0;\\n    }\\n  }\\n\\n  /**\\n  * @dev Returns unlockable tokens for a specified address for a specified reason\\n  * @param _of The address to query the the unlockable token count of\\n  * @param _reason The reason to query the unlockable tokens for\\n  */\\n  function tokensUnlockable(address _of, bytes32 _reason)\\n  public\\n  view\\n  returns (uint256 amount)\\n  {\\n    return _tokensUnlockable(_of, _reason);\\n  }\\n\\n  function totalSupply() public view returns (uint256)\\n  {\\n    return token.totalSupply();\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason at a specific time\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  * @param _time The timestamp to query the lock tokens for\\n  */\\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\\n  public\\n  view\\n  returns (uint256 amount)\\n  {\\n    return _tokensLockedAtTime(_of, _reason, _time);\\n  }\\n\\n  /**\\n  * @dev Returns the total amount of tokens held by an address:\\n  *   transferable + locked + staked for pooled staking - pending burns.\\n  *   Used by Claims and Governance in member voting to calculate the user's vote weight.\\n  *\\n  * @param _of The address to query the total balance of\\n  * @param _of The address to query the total balance of\\n  */\\n  function totalBalanceOf(address _of) public view returns (uint256 amount) {\\n\\n    amount = token.balanceOf(_of);\\n\\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\\n      amount = amount.add(_tokensLocked(_of, lockReason[_of][i]));\\n    }\\n\\n    uint stakerReward = pooledStaking.stakerReward(_of);\\n    uint stakerDeposit = pooledStaking.stakerDeposit(_of);\\n\\n    amount = amount.add(stakerDeposit).add(stakerReward);\\n  }\\n\\n  /**\\n  * @dev Returns the total amount of locked and staked tokens.\\n  *      Used by MemberRoles to check eligibility for withdraw / switch membership.\\n  *      Includes tokens locked for claim assessment, tokens staked for risk assessment, and locked cover notes\\n  *      Does not take into account pending burns.\\n  * @param _of member whose locked tokens are to be calculate\\n  */\\n  function totalLockedBalance(address _of) public view returns (uint256 amount) {\\n\\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\\n      amount = amount.add(_tokensLocked(_of, lockReason[_of][i]));\\n    }\\n\\n    amount = amount.add(pooledStaking.stakerDeposit(_of));\\n  }\\n\\n  /**\\n  * @dev Locks a specified amount of tokens against an address,\\n  *    for a specified reason and time\\n  * @param _of address whose tokens are to be locked\\n  * @param _reason The reason to lock tokens\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  */\\n  function _lock(address _of, bytes32 _reason, uint256 _amount, uint256 _time) internal {\\n    require(_tokensLocked(_of, _reason) == 0, \\\"TokenController: An amount of tokens is already locked\\\");\\n    require(_amount != 0, \\\"TokenController: Amount shouldn't be zero\\\");\\n\\n    if (locked[_of][_reason].amount == 0) {\\n      lockReason[_of].push(_reason);\\n    }\\n\\n    token.operatorTransfer(_of, _amount);\\n\\n    uint256 validUntil = now.add(_time);\\n    locked[_of][_reason] = LockToken(_amount, validUntil, false);\\n    emit Locked(_of, _reason, _amount, validUntil);\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  */\\n  function _tokensLocked(address _of, bytes32 _reason)\\n  internal\\n  view\\n  returns (uint256 amount)\\n  {\\n    if (!locked[_of][_reason].claimed) {\\n      amount = locked[_of][_reason].amount;\\n    }\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason at a specific time\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  * @param _time The timestamp to query the lock tokens for\\n  */\\n  function _tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\\n  internal\\n  view\\n  returns (uint256 amount)\\n  {\\n    if (locked[_of][_reason].validity > _time) {\\n      amount = locked[_of][_reason].amount;\\n    }\\n  }\\n\\n  /**\\n  * @dev Extends lock for a specified reason and time\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock extension time in seconds\\n  */\\n  function _extendLock(address _of, bytes32 _reason, uint256 _time) internal {\\n    require(_tokensLocked(_of, _reason) > 0, \\\"TokenController: No tokens locked\\\");\\n    emit Unlocked(_of, _reason, locked[_of][_reason].amount);\\n    locked[_of][_reason].validity = locked[_of][_reason].validity.add(_time);\\n    emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\\n  }\\n\\n  /**\\n  * @dev reduce lock duration for a specified reason and time\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock reduction time in seconds\\n  */\\n  function _reduceLock(address _of, bytes32 _reason, uint256 _time) internal {\\n    require(_tokensLocked(_of, _reason) > 0, \\\"TokenController: No tokens locked\\\");\\n    emit Unlocked(_of, _reason, locked[_of][_reason].amount);\\n    locked[_of][_reason].validity = locked[_of][_reason].validity.sub(_time);\\n    emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\\n  }\\n\\n  /**\\n  * @dev Returns unlockable tokens for a specified address for a specified reason\\n  * @param _of The address to query the the unlockable token count of\\n  * @param _reason The reason to query the unlockable tokens for\\n  */\\n  function _tokensUnlockable(address _of, bytes32 _reason) internal view returns (uint256 amount)\\n  {\\n    if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed) {\\n      amount = locked[_of][_reason].amount;\\n    }\\n  }\\n\\n  /**\\n  * @dev Burns locked tokens of a user\\n  * @param _of address whose tokens are to be burned\\n  * @param _reason lock reason for which tokens are to be burned\\n  * @param _amount amount of tokens to burn\\n  */\\n  function _burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal {\\n    uint256 amount = _tokensLocked(_of, _reason);\\n    require(amount >= _amount, \\\"TokenController: Amount exceedes locked tokens amount\\\");\\n\\n    if (amount == _amount) {\\n      locked[_of][_reason].claimed = true;\\n    }\\n\\n    locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\\n\\n    // lock reason removal is skipped here: needs to be done from offchain\\n\\n    token.burn(_amount);\\n    emit Burned(_of, _reason, _amount);\\n  }\\n\\n  /**\\n  * @dev Released locked tokens of an address locked for a specific reason\\n  * @param _of address whose tokens are to be released from lock\\n  * @param _reason reason of the lock\\n  * @param _amount amount of tokens to release\\n  */\\n  function _releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal\\n  {\\n    uint256 amount = _tokensLocked(_of, _reason);\\n    require(amount >= _amount, \\\"TokenController: Amount exceedes locked tokens amount\\\");\\n\\n    if (amount == _amount) {\\n      locked[_of][_reason].claimed = true;\\n    }\\n\\n    locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\\n\\n    // lock reason removal is skipped here: needs to be done from offchain\\n\\n    token.transfer(_of, _amount);\\n    emit Unlocked(_of, _reason, _amount);\\n  }\\n\\n  function withdrawCoverNote(\\n    address _of,\\n    uint[] calldata _coverIds,\\n    uint[] calldata _indexes\\n  ) external onlyInternal {\\n\\n    uint reasonCount = lockReason[_of].length;\\n    uint lastReasonIndex = reasonCount.sub(1, \\\"TokenController: No locked cover notes found\\\");\\n    uint totalAmount = 0;\\n\\n    // The iteration is done from the last to first to prevent reason indexes from\\n    // changing due to the way we delete the items (copy last to current and pop last).\\n    // The provided indexes array must be ordered, otherwise reason index checks will fail.\\n\\n    for (uint i = _coverIds.length; i > 0; i--) {\\n\\n      bool hasOpenClaim = coverInfo[_coverIds[i - 1]].hasOpenClaim;\\n      require(hasOpenClaim == false, \\\"TokenController: Cannot withdraw for cover with an open claim\\\");\\n\\n      // note: cover owner is implicitly checked using the reason hash\\n      bytes32 _reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, _coverIds[i - 1]));\\n      uint _reasonIndex = _indexes[i - 1];\\n      require(lockReason[_of][_reasonIndex] == _reason, \\\"TokenController: Bad reason index\\\");\\n\\n      uint amount = locked[_of][_reason].amount;\\n      totalAmount = totalAmount.add(amount);\\n      delete locked[_of][_reason];\\n\\n      if (lastReasonIndex != _reasonIndex) {\\n        lockReason[_of][_reasonIndex] = lockReason[_of][lastReasonIndex];\\n      }\\n\\n      lockReason[_of].pop();\\n      emit Unlocked(_of, _reason, amount);\\n\\n      if (lastReasonIndex > 0) {\\n        lastReasonIndex = lastReasonIndex.sub(1, \\\"TokenController: Reason count mismatch\\\");\\n      }\\n    }\\n\\n    token.transfer(_of, totalAmount);\\n  }\\n\\n  function removeEmptyReason(address _of, bytes32 _reason, uint _index) external {\\n    _removeEmptyReason(_of, _reason, _index);\\n  }\\n\\n  function removeMultipleEmptyReasons(\\n    address[] calldata _members,\\n    bytes32[] calldata _reasons,\\n    uint[] calldata _indexes\\n  ) external {\\n\\n    require(_members.length == _reasons.length, \\\"TokenController: members and reasons array lengths differ\\\");\\n    require(_reasons.length == _indexes.length, \\\"TokenController: reasons and indexes array lengths differ\\\");\\n\\n    for (uint i = _members.length; i > 0; i--) {\\n      uint idx = i - 1;\\n      _removeEmptyReason(_members[idx], _reasons[idx], _indexes[idx]);\\n    }\\n  }\\n\\n  function _removeEmptyReason(address _of, bytes32 _reason, uint _index) internal {\\n\\n    uint lastReasonIndex = lockReason[_of].length.sub(1, \\\"TokenController: lockReason is empty\\\");\\n\\n    require(lockReason[_of][_index] == _reason, \\\"TokenController: bad reason index\\\");\\n    require(locked[_of][_reason].amount == 0, \\\"TokenController: reason amount is not zero\\\");\\n\\n    if (lastReasonIndex != _index) {\\n      lockReason[_of][_index] = lockReason[_of][lastReasonIndex];\\n    }\\n\\n    lockReason[_of].pop();\\n  }\\n\\n  function initialize() external {\\n    require(claimSubmissionGracePeriod == 0, \\\"TokenController: Already initialized\\\");\\n    claimSubmissionGracePeriod = 120 days;\\n    migrate();\\n  }\\n\\n  function migrate() internal {\\n\\n    ClaimsData cd = ClaimsData(ms.getLatestAddress(\\\"CD\\\"));\\n    uint totalClaims = cd.actualClaimLength() - 1;\\n\\n    // fix stuck claims 21 & 22\\n    cd.changeFinalVerdict(20, -1);\\n    cd.setClaimStatus(20, 6);\\n    cd.changeFinalVerdict(21, -1);\\n    cd.setClaimStatus(21, 6);\\n\\n    // reduce claim assessment lock period for members locked for more than 180 days\\n    // extracted using scripts/extract-ca-locked-more-than-180.js\\n    address payable[3] memory members = [\\n      0x4a9fA34da6d2378c8f3B9F6b83532B169beaEDFc,\\n      0x6b5DCDA27b5c3d88e71867D6b10b35372208361F,\\n      0x8B6D1e5b4db5B6f9aCcc659e2b9619B0Cd90D617\\n    ];\\n\\n    for (uint i = 0; i < members.length; i++) {\\n      if (locked[members[i]][\\\"CLA\\\"].validity > now + 180 days) {\\n        locked[members[i]][\\\"CLA\\\"].validity = now + 180 days;\\n      }\\n    }\\n\\n    for (uint i = 1; i <= totalClaims; i++) {\\n\\n      (/*id*/, uint status) = cd.getClaimStatusNumber(i);\\n      (/*id*/, uint coverId) = cd.getClaimCoverId(i);\\n      int8 verdict = cd.getFinalVerdict(i);\\n\\n      // SLOAD\\n      CoverInfo memory info = coverInfo[coverId];\\n\\n      info.claimCount = info.claimCount + 1;\\n      info.hasAcceptedClaim = (status == 14);\\n      info.hasOpenClaim = (verdict == 0);\\n\\n      // SSTORE\\n      coverInfo[coverId] = info;\\n    }\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/governance/MemberRoles.sol\": {\r\n      \"content\": \"/* Copyright (C) 2017 GovBlocks.io\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"../claims/ClaimsReward.sol\\\";\\nimport \\\"../cover/QuotationData.sol\\\";\\nimport \\\"../token/TokenController.sol\\\";\\nimport \\\"../token/TokenData.sol\\\";\\nimport \\\"../token/TokenFunctions.sol\\\";\\nimport \\\"./Governance.sol\\\";\\nimport \\\"./external/Governed.sol\\\";\\n\\ncontract MemberRoles is Governed, Iupgradable {\\n\\n  TokenController public tc;\\n  TokenData internal td;\\n  QuotationData internal qd;\\n  ClaimsReward internal cr;\\n  Governance internal gv;\\n  TokenFunctions internal tf;\\n  NXMToken public tk;\\n\\n  struct MemberRoleDetails {\\n    uint memberCounter;\\n    mapping(address => bool) memberActive;\\n    address[] memberAddress;\\n    address authorized;\\n  }\\n\\n  enum Role {UnAssigned, AdvisoryBoard, Member, Owner}\\n\\n  event MemberRole(uint256 indexed roleId, bytes32 roleName, string roleDescription);\\n\\n  event switchedMembership(address indexed previousMember, address indexed newMember, uint timeStamp);\\n\\n  event ClaimPayoutAddressSet(address indexed member, address indexed payoutAddress);\\n\\n  MemberRoleDetails[] internal memberRoleData;\\n  bool internal constructorCheck;\\n  uint public maxABCount;\\n  bool public launched;\\n  uint public launchedOn;\\n\\n  mapping (address => address payable) internal claimPayoutAddress;\\n\\n  modifier checkRoleAuthority(uint _memberRoleId) {\\n    if (memberRoleData[_memberRoleId].authorized != address(0))\\n      require(msg.sender == memberRoleData[_memberRoleId].authorized);\\n    else\\n      require(isAuthorizedToGovern(msg.sender), \\\"Not Authorized\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev to swap advisory board member\\n   * @param _newABAddress is address of new AB member\\n   * @param _removeAB is advisory board member to be removed\\n   */\\n  function swapABMember(\\n    address _newABAddress,\\n    address _removeAB\\n  )\\n  external\\n  checkRoleAuthority(uint(Role.AdvisoryBoard)) {\\n\\n    _updateRole(_newABAddress, uint(Role.AdvisoryBoard), true);\\n    _updateRole(_removeAB, uint(Role.AdvisoryBoard), false);\\n\\n  }\\n\\n  /**\\n   * @dev to swap the owner address\\n   * @param _newOwnerAddress is the new owner address\\n   */\\n  function swapOwner(\\n    address _newOwnerAddress\\n  )\\n  external {\\n    require(msg.sender == address(ms));\\n    _updateRole(ms.owner(), uint(Role.Owner), false);\\n    _updateRole(_newOwnerAddress, uint(Role.Owner), true);\\n  }\\n\\n  /**\\n   * @dev is used to add initital advisory board members\\n   * @param abArray is the list of initial advisory board members\\n   */\\n  function addInitialABMembers(address[] calldata abArray) external onlyOwner {\\n\\n    //Ensure that NXMaster has initialized.\\n    require(ms.masterInitialized());\\n\\n    require(maxABCount >=\\n      SafeMath.add(numberOfMembers(uint(Role.AdvisoryBoard)), abArray.length)\\n    );\\n    //AB count can't exceed maxABCount\\n    for (uint i = 0; i < abArray.length; i++) {\\n      require(checkRole(abArray[i], uint(MemberRoles.Role.Member)));\\n      _updateRole(abArray[i], uint(Role.AdvisoryBoard), true);\\n    }\\n  }\\n\\n  /**\\n   * @dev to change max number of AB members allowed\\n   * @param _val is the new value to be set\\n   */\\n  function changeMaxABCount(uint _val) external onlyInternal {\\n    maxABCount = _val;\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public {\\n    td = TokenData(ms.getLatestAddress(\\\"TD\\\"));\\n    cr = ClaimsReward(ms.getLatestAddress(\\\"CR\\\"));\\n    qd = QuotationData(ms.getLatestAddress(\\\"QD\\\"));\\n    gv = Governance(ms.getLatestAddress(\\\"GV\\\"));\\n    tf = TokenFunctions(ms.getLatestAddress(\\\"TF\\\"));\\n    tk = NXMToken(ms.tokenAddress());\\n    tc = TokenController(ms.getLatestAddress(\\\"TC\\\"));\\n  }\\n\\n  /**\\n   * @dev to change the master address\\n   * @param _masterAddress is the new master address\\n   */\\n  function changeMasterAddress(address _masterAddress) public {\\n\\n    if (masterAddress != address(0)) {\\n      require(masterAddress == msg.sender);\\n    }\\n\\n    masterAddress = _masterAddress;\\n    ms = INXMMaster(_masterAddress);\\n    nxMasterAddress = _masterAddress;\\n  }\\n\\n  /**\\n   * @dev to initiate the member roles\\n   * @param _firstAB is the address of the first AB member\\n   * @param memberAuthority is the authority (role) of the member\\n   */\\n  function memberRolesInitiate(address _firstAB, address memberAuthority) public {\\n    require(!constructorCheck);\\n    _addInitialMemberRoles(_firstAB, memberAuthority);\\n    constructorCheck = true;\\n  }\\n\\n  /// @dev Adds new member role\\n  /// @param _roleName New role name\\n  /// @param _roleDescription New description hash\\n  /// @param _authorized Authorized member against every role id\\n  function addRole(//solhint-disable-line\\n    bytes32 _roleName,\\n    string memory _roleDescription,\\n    address _authorized\\n  )\\n  public\\n  onlyAuthorizedToGovern {\\n    _addRole(_roleName, _roleDescription, _authorized);\\n  }\\n\\n  /// @dev Assign or Delete a member from specific role.\\n  /// @param _memberAddress Address of Member\\n  /// @param _roleId RoleId to update\\n  /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\\n  function updateRole(//solhint-disable-line\\n    address _memberAddress,\\n    uint _roleId,\\n    bool _active\\n  )\\n  public\\n  checkRoleAuthority(_roleId) {\\n    _updateRole(_memberAddress, _roleId, _active);\\n  }\\n\\n  /**\\n   * @dev to add members before launch\\n   * @param userArray is list of addresses of members\\n   * @param tokens is list of tokens minted for each array element\\n   */\\n  function addMembersBeforeLaunch(address[] memory userArray, uint[] memory tokens) public onlyOwner {\\n    require(!launched);\\n\\n    for (uint i = 0; i < userArray.length; i++) {\\n      require(!ms.isMember(userArray[i]));\\n      tc.addToWhitelist(userArray[i]);\\n      _updateRole(userArray[i], uint(Role.Member), true);\\n      tc.mint(userArray[i], tokens[i]);\\n    }\\n    launched = true;\\n    launchedOn = now;\\n\\n  }\\n\\n  /**\\n    * @dev Called by user to pay joining membership fee\\n    */\\n  function payJoiningFee(address _userAddress) public payable {\\n    require(_userAddress != address(0));\\n    require(!ms.isPause(), \\\"Emergency Pause Applied\\\");\\n    if (msg.sender == address(ms.getLatestAddress(\\\"QT\\\"))) {\\n      require(td.walletAddress() != address(0), \\\"No walletAddress present\\\");\\n      tc.addToWhitelist(_userAddress);\\n      _updateRole(_userAddress, uint(Role.Member), true);\\n      td.walletAddress().transfer(msg.value);\\n    } else {\\n      require(!qd.refundEligible(_userAddress));\\n      require(!ms.isMember(_userAddress));\\n      require(msg.value == td.joiningFee());\\n      qd.setRefundEligible(_userAddress, true);\\n    }\\n  }\\n\\n  /**\\n   * @dev to perform kyc verdict\\n   * @param _userAddress whose kyc is being performed\\n   * @param verdict of kyc process\\n   */\\n  function kycVerdict(address payable _userAddress, bool verdict) public {\\n\\n    require(msg.sender == qd.kycAuthAddress());\\n    require(!ms.isPause());\\n    require(_userAddress != address(0));\\n    require(!ms.isMember(_userAddress));\\n    require(qd.refundEligible(_userAddress));\\n    if (verdict) {\\n      qd.setRefundEligible(_userAddress, false);\\n      uint fee = td.joiningFee();\\n      tc.addToWhitelist(_userAddress);\\n      _updateRole(_userAddress, uint(Role.Member), true);\\n      td.walletAddress().transfer(fee); // solhint-disable-line\\n\\n    } else {\\n      qd.setRefundEligible(_userAddress, false);\\n      _userAddress.transfer(td.joiningFee()); // solhint-disable-line\\n    }\\n  }\\n\\n  /**\\n   * @dev withdraws membership for msg.sender if currently a member.\\n   */\\n  function withdrawMembership() public {\\n\\n    require(!ms.isPause() && ms.isMember(msg.sender));\\n    require(tc.totalLockedBalance(msg.sender) == 0); // solhint-disable-line\\n    require(!tf.isLockedForMemberVote(msg.sender)); // No locked tokens for Member/Governance voting\\n    require(cr.getAllPendingRewardOfUser(msg.sender) == 0); // No pending reward to be claimed(claim assesment).\\n\\n    gv.removeDelegation(msg.sender);\\n    tc.burnFrom(msg.sender, tk.balanceOf(msg.sender));\\n    _updateRole(msg.sender, uint(Role.Member), false);\\n    tc.removeFromWhitelist(msg.sender); // need clarification on whitelist\\n\\n    if (claimPayoutAddress[msg.sender] != address(0)) {\\n      claimPayoutAddress[msg.sender] = address(0);\\n      emit ClaimPayoutAddressSet(msg.sender, address(0));\\n    }\\n  }\\n\\n  /**\\n   * @dev switches membership for msg.sender to the specified address.\\n   * @param newAddress address of user to forward membership.\\n   */\\n  function switchMembership(address newAddress) external {\\n    _switchMembership(msg.sender, newAddress);\\n    tk.transferFrom(msg.sender, newAddress, tk.balanceOf(msg.sender));\\n  }\\n\\n  function switchMembershipOf(address member, address newAddress) external onlyInternal {\\n    _switchMembership(member, newAddress);\\n  }\\n\\n  /**\\n   * @dev switches membership for member to the specified address.\\n   * @param newAddress address of user to forward membership.\\n   */\\n  function _switchMembership(address member, address newAddress) internal {\\n\\n    require(!ms.isPause() && ms.isMember(member) && !ms.isMember(newAddress));\\n    require(tc.totalLockedBalance(member) == 0); // solhint-disable-line\\n    require(!tf.isLockedForMemberVote(member)); // No locked tokens for Member/Governance voting\\n    require(cr.getAllPendingRewardOfUser(member) == 0); // No pending reward to be claimed(claim assesment).\\n\\n    gv.removeDelegation(member);\\n    tc.addToWhitelist(newAddress);\\n    _updateRole(newAddress, uint(Role.Member), true);\\n    _updateRole(member, uint(Role.Member), false);\\n    tc.removeFromWhitelist(member);\\n\\n    address payable previousPayoutAddress = claimPayoutAddress[member];\\n\\n    if (previousPayoutAddress != address(0)) {\\n\\n      address payable storedAddress = previousPayoutAddress == newAddress ? address(0) : previousPayoutAddress;\\n\\n      claimPayoutAddress[member] = address(0);\\n      claimPayoutAddress[newAddress] = storedAddress;\\n\\n      // emit event for old address reset\\n      emit ClaimPayoutAddressSet(member, address(0));\\n\\n      if (storedAddress != address(0)) {\\n        // emit event for setting the payout address on the new member address if it's non zero\\n        emit ClaimPayoutAddressSet(newAddress, storedAddress);\\n      }\\n    }\\n\\n    emit switchedMembership(member, newAddress, now);\\n  }\\n\\n  function getClaimPayoutAddress(address payable _member) external view returns (address payable) {\\n    address payable payoutAddress = claimPayoutAddress[_member];\\n    return payoutAddress != address(0) ? payoutAddress : _member;\\n  }\\n\\n  function setClaimPayoutAddress(address payable _address) external {\\n\\n    require(!ms.isPause(), \\\"system is paused\\\");\\n    require(ms.isMember(msg.sender), \\\"sender is not a member\\\");\\n    require(_address != msg.sender, \\\"should be different than the member address\\\");\\n\\n    claimPayoutAddress[msg.sender] = _address;\\n    emit ClaimPayoutAddressSet(msg.sender, _address);\\n  }\\n\\n  /// @dev Return number of member roles\\n  function totalRoles() public view returns (uint256) {//solhint-disable-line\\n    return memberRoleData.length;\\n  }\\n\\n  /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\\n  /// @param _roleId roleId to update its Authorized Address\\n  /// @param _newAuthorized New authorized address against role id\\n  function changeAuthorized(uint _roleId, address _newAuthorized) public checkRoleAuthority(_roleId) {//solhint-disable-line\\n    memberRoleData[_roleId].authorized = _newAuthorized;\\n  }\\n\\n  /// @dev Gets the member addresses assigned by a specific role\\n  /// @param _memberRoleId Member role id\\n  /// @return roleId Role id\\n  /// @return allMemberAddress Member addresses of specified role id\\n  function members(uint _memberRoleId) public view returns (uint, address[] memory memberArray) {//solhint-disable-line\\n    uint length = memberRoleData[_memberRoleId].memberAddress.length;\\n    uint i;\\n    uint j = 0;\\n    memberArray = new address[](memberRoleData[_memberRoleId].memberCounter);\\n    for (i = 0; i < length; i++) {\\n      address member = memberRoleData[_memberRoleId].memberAddress[i];\\n      if (memberRoleData[_memberRoleId].memberActive[member] && !_checkMemberInArray(member, memberArray)) {//solhint-disable-line\\n        memberArray[j] = member;\\n        j++;\\n      }\\n    }\\n\\n    return (_memberRoleId, memberArray);\\n  }\\n\\n  /// @dev Gets all members' length\\n  /// @param _memberRoleId Member role id\\n  /// @return memberRoleData[_memberRoleId].memberCounter Member length\\n  function numberOfMembers(uint _memberRoleId) public view returns (uint) {//solhint-disable-line\\n    return memberRoleData[_memberRoleId].memberCounter;\\n  }\\n\\n  /// @dev Return member address who holds the right to add/remove any member from specific role.\\n  function authorized(uint _memberRoleId) public view returns (address) {//solhint-disable-line\\n    return memberRoleData[_memberRoleId].authorized;\\n  }\\n\\n  /// @dev Get All role ids array that has been assigned to a member so far.\\n  function roles(address _memberAddress) public view returns (uint[] memory) {//solhint-disable-line\\n    uint length = memberRoleData.length;\\n    uint[] memory assignedRoles = new uint[](length);\\n    uint counter = 0;\\n    for (uint i = 1; i < length; i++) {\\n      if (memberRoleData[i].memberActive[_memberAddress]) {\\n        assignedRoles[counter] = i;\\n        counter++;\\n      }\\n    }\\n    return assignedRoles;\\n  }\\n\\n  /// @dev Returns true if the given role id is assigned to a member.\\n  /// @param _memberAddress Address of member\\n  /// @param _roleId Checks member's authenticity with the roleId.\\n  /// i.e. Returns true if this roleId is assigned to member\\n  function checkRole(address _memberAddress, uint _roleId) public view returns (bool) {//solhint-disable-line\\n    if (_roleId == uint(Role.UnAssigned))\\n      return true;\\n    else\\n      if (memberRoleData[_roleId].memberActive[_memberAddress]) //solhint-disable-line\\n        return true;\\n      else\\n        return false;\\n  }\\n\\n  /// @dev Return total number of members assigned against each role id.\\n  /// @return totalMembers Total members in particular role id\\n  function getMemberLengthForAllRoles() public view returns (uint[] memory totalMembers) {//solhint-disable-line\\n    totalMembers = new uint[](memberRoleData.length);\\n    for (uint i = 0; i < memberRoleData.length; i++) {\\n      totalMembers[i] = numberOfMembers(i);\\n    }\\n  }\\n\\n  /**\\n   * @dev to update the member roles\\n   * @param _memberAddress in concern\\n   * @param _roleId the id of role\\n   * @param _active if active is true, add the member, else remove it\\n   */\\n  function _updateRole(address _memberAddress,\\n    uint _roleId,\\n    bool _active) internal {\\n    // require(_roleId != uint(Role.TokenHolder), \\\"Membership to Token holder is detected automatically\\\");\\n    if (_active) {\\n      require(!memberRoleData[_roleId].memberActive[_memberAddress]);\\n      memberRoleData[_roleId].memberCounter = SafeMath.add(memberRoleData[_roleId].memberCounter, 1);\\n      memberRoleData[_roleId].memberActive[_memberAddress] = true;\\n      memberRoleData[_roleId].memberAddress.push(_memberAddress);\\n    } else {\\n      require(memberRoleData[_roleId].memberActive[_memberAddress]);\\n      memberRoleData[_roleId].memberCounter = SafeMath.sub(memberRoleData[_roleId].memberCounter, 1);\\n      delete memberRoleData[_roleId].memberActive[_memberAddress];\\n    }\\n  }\\n\\n  /// @dev Adds new member role\\n  /// @param _roleName New role name\\n  /// @param _roleDescription New description hash\\n  /// @param _authorized Authorized member against every role id\\n  function _addRole(\\n    bytes32 _roleName,\\n    string memory _roleDescription,\\n    address _authorized\\n  ) internal {\\n    emit MemberRole(memberRoleData.length, _roleName, _roleDescription);\\n    memberRoleData.push(MemberRoleDetails(0, new address[](0), _authorized));\\n  }\\n\\n  /**\\n   * @dev to check if member is in the given member array\\n   * @param _memberAddress in concern\\n   * @param memberArray in concern\\n   * @return boolean to represent the presence\\n   */\\n  function _checkMemberInArray(\\n    address _memberAddress,\\n    address[] memory memberArray\\n  )\\n  internal\\n  pure\\n  returns (bool memberExists)\\n  {\\n    uint i;\\n    for (i = 0; i < memberArray.length; i++) {\\n      if (memberArray[i] == _memberAddress) {\\n        memberExists = true;\\n        break;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev to add initial member roles\\n   * @param _firstAB is the member address to be added\\n   * @param memberAuthority is the member authority(role) to be added for\\n   */\\n  function _addInitialMemberRoles(address _firstAB, address memberAuthority) internal {\\n    maxABCount = 5;\\n    _addRole(\\\"Unassigned\\\", \\\"Unassigned\\\", address(0));\\n    _addRole(\\n      \\\"Advisory Board\\\",\\n      \\\"Selected few members that are deeply entrusted by the dApp. An ideal advisory board should be a mix of skills of domain, governance, research, technology, consulting etc to improve the performance of the dApp.\\\", //solhint-disable-line\\n      address(0)\\n    );\\n    _addRole(\\n      \\\"Member\\\",\\n      \\\"Represents all users of Mutual.\\\", //solhint-disable-line\\n      memberAuthority\\n    );\\n    _addRole(\\n      \\\"Owner\\\",\\n      \\\"Represents Owner of Mutual.\\\", //solhint-disable-line\\n      address(0)\\n    );\\n    // _updateRole(_firstAB, uint(Role.AdvisoryBoard), true);\\n    _updateRole(_firstAB, uint(Role.Owner), true);\\n    // _updateRole(_firstAB, uint(Role.Member), true);\\n    launchedOn = 0;\\n  }\\n\\n  function memberAtIndex(uint _memberRoleId, uint index) external view returns (address, bool) {\\n    address memberAddress = memberRoleData[_memberRoleId].memberAddress[index];\\n    return (memberAddress, memberRoleData[_memberRoleId].memberActive[memberAddress]);\\n  }\\n\\n  function membersLength(uint _memberRoleId) external view returns (uint) {\\n    return memberRoleData[_memberRoleId].memberAddress.length;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/governance/ProposalCategory.sol\": {\r\n      \"content\": \"/* Copyright (C) 2017 GovBlocks.io\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\npragma solidity ^0.5.0;\\n\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\nimport \\\"./MemberRoles.sol\\\";\\nimport \\\"./external/Governed.sol\\\";\\nimport \\\"./external/IProposalCategory.sol\\\";\\n\\ncontract ProposalCategory is Governed, IProposalCategory, Iupgradable {\\n\\n  bool public constructorCheck;\\n  MemberRoles internal mr;\\n\\n  struct CategoryStruct {\\n    uint memberRoleToVote;\\n    uint majorityVotePerc;\\n    uint quorumPerc;\\n    uint[] allowedToCreateProposal;\\n    uint closingTime;\\n    uint minStake;\\n  }\\n\\n  struct CategoryAction {\\n    uint defaultIncentive;\\n    address contractAddress;\\n    bytes2 contractName;\\n  }\\n\\n  CategoryStruct[] internal allCategory;\\n  mapping(uint => CategoryAction) internal categoryActionData;\\n  mapping(uint => uint) public categoryABReq;\\n  mapping(uint => uint) public isSpecialResolution;\\n  mapping(uint => bytes) public categoryActionHashes;\\n\\n  bool public categoryActionHashUpdated;\\n\\n  /**\\n  * @dev Adds new category (Discontinued, moved functionality to newCategory)\\n  * @param _name Category name\\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\\n  * @param _closingTime Vote closing time for Each voting layer\\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\\n  * @param _contractAddress address of contract to call after proposal is accepted\\n  * @param _contractName name of contract to be called after proposal is accepted\\n  * @param _incentives rewards to distributed after proposal is accepted\\n  */\\n  function addCategory(\\n    string calldata _name,\\n    uint _memberRoleToVote,\\n    uint _majorityVotePerc,\\n    uint _quorumPerc,\\n    uint[] calldata _allowedToCreateProposal,\\n    uint _closingTime,\\n    string calldata _actionHash,\\n    address _contractAddress,\\n    bytes2 _contractName,\\n    uint[] calldata _incentives\\n  ) external {}\\n\\n  /**\\n  * @dev Initiates Default settings for Proposal Category contract (Adding default categories)\\n  */\\n  function proposalCategoryInitiate() external {}\\n\\n  /**\\n  * @dev Initiates Default action function hashes for existing categories\\n  * To be called after the contract has been upgraded by governance\\n  */\\n  function updateCategoryActionHashes() external onlyOwner {\\n\\n    require(!categoryActionHashUpdated, \\\"Category action hashes already updated\\\");\\n    categoryActionHashUpdated = true;\\n    categoryActionHashes[1] = abi.encodeWithSignature(\\\"addRole(bytes32,string,address)\\\");\\n    categoryActionHashes[2] = abi.encodeWithSignature(\\\"updateRole(address,uint256,bool)\\\");\\n    categoryActionHashes[3] = abi.encodeWithSignature(\\\"newCategory(string,uint256,uint256,uint256,uint256[],uint256,string,address,bytes2,uint256[],string)\\\"); // solhint-disable-line\\n    categoryActionHashes[4] = abi.encodeWithSignature(\\\"editCategory(uint256,string,uint256,uint256,uint256,uint256[],uint256,string,address,bytes2,uint256[],string)\\\"); // solhint-disable-line\\n    categoryActionHashes[5] = abi.encodeWithSignature(\\\"upgradeContractImplementation(bytes2,address)\\\");\\n    categoryActionHashes[6] = abi.encodeWithSignature(\\\"startEmergencyPause()\\\");\\n    categoryActionHashes[7] = abi.encodeWithSignature(\\\"addEmergencyPause(bool,bytes4)\\\");\\n    categoryActionHashes[8] = abi.encodeWithSignature(\\\"burnCAToken(uint256,uint256,address)\\\");\\n    categoryActionHashes[9] = abi.encodeWithSignature(\\\"setUserClaimVotePausedOn(address)\\\");\\n    categoryActionHashes[12] = abi.encodeWithSignature(\\\"transferEther(uint256,address)\\\");\\n    categoryActionHashes[13] = abi.encodeWithSignature(\\\"addInvestmentAssetCurrency(bytes4,address,bool,uint64,uint64,uint8)\\\"); // solhint-disable-line\\n    categoryActionHashes[14] = abi.encodeWithSignature(\\\"changeInvestmentAssetHoldingPerc(bytes4,uint64,uint64)\\\");\\n    categoryActionHashes[15] = abi.encodeWithSignature(\\\"changeInvestmentAssetStatus(bytes4,bool)\\\");\\n    categoryActionHashes[16] = abi.encodeWithSignature(\\\"swapABMember(address,address)\\\");\\n    categoryActionHashes[17] = abi.encodeWithSignature(\\\"addCurrencyAssetCurrency(bytes4,address,uint256)\\\");\\n    categoryActionHashes[20] = abi.encodeWithSignature(\\\"updateUintParameters(bytes8,uint256)\\\");\\n    categoryActionHashes[21] = abi.encodeWithSignature(\\\"updateUintParameters(bytes8,uint256)\\\");\\n    categoryActionHashes[22] = abi.encodeWithSignature(\\\"updateUintParameters(bytes8,uint256)\\\");\\n    categoryActionHashes[23] = abi.encodeWithSignature(\\\"updateUintParameters(bytes8,uint256)\\\");\\n    categoryActionHashes[24] = abi.encodeWithSignature(\\\"updateUintParameters(bytes8,uint256)\\\");\\n    categoryActionHashes[25] = abi.encodeWithSignature(\\\"updateUintParameters(bytes8,uint256)\\\");\\n    categoryActionHashes[26] = abi.encodeWithSignature(\\\"updateUintParameters(bytes8,uint256)\\\");\\n    categoryActionHashes[27] = abi.encodeWithSignature(\\\"updateAddressParameters(bytes8,address)\\\");\\n    categoryActionHashes[28] = abi.encodeWithSignature(\\\"updateOwnerParameters(bytes8,address)\\\");\\n    categoryActionHashes[29] = abi.encodeWithSignature(\\\"upgradeMultipleContracts(bytes2[],address[])\\\");\\n    categoryActionHashes[30] = abi.encodeWithSignature(\\\"changeCurrencyAssetAddress(bytes4,address)\\\");\\n    categoryActionHashes[31] = abi.encodeWithSignature(\\\"changeCurrencyAssetBaseMin(bytes4,uint256)\\\");\\n    categoryActionHashes[32] = abi.encodeWithSignature(\\\"changeInvestmentAssetAddressAndDecimal(bytes4,address,uint8)\\\"); // solhint-disable-line\\n    categoryActionHashes[33] = abi.encodeWithSignature(\\\"externalLiquidityTrade()\\\");\\n  }\\n\\n  /**\\n  * @dev Gets Total number of categories added till now\\n  */\\n  function totalCategories() external view returns (uint) {\\n    return allCategory.length;\\n  }\\n\\n  /**\\n  * @dev Gets category details\\n  */\\n  function category(uint _categoryId) external view returns (uint, uint, uint, uint, uint[] memory, uint, uint) {\\n    return (\\n    _categoryId,\\n    allCategory[_categoryId].memberRoleToVote,\\n    allCategory[_categoryId].majorityVotePerc,\\n    allCategory[_categoryId].quorumPerc,\\n    allCategory[_categoryId].allowedToCreateProposal,\\n    allCategory[_categoryId].closingTime,\\n    allCategory[_categoryId].minStake\\n    );\\n  }\\n\\n  /**\\n  * @dev Gets category ab required and isSpecialResolution\\n  * @return the category id\\n  * @return if AB voting is required\\n  * @return is category a special resolution\\n  */\\n  function categoryExtendedData(uint _categoryId) external view returns (uint, uint, uint) {\\n    return (\\n    _categoryId,\\n    categoryABReq[_categoryId],\\n    isSpecialResolution[_categoryId]\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the category acion details\\n   * @param _categoryId is the category id in concern\\n   * @return the category id\\n   * @return the contract address\\n   * @return the contract name\\n   * @return the default incentive\\n   */\\n  function categoryAction(uint _categoryId) external view returns (uint, address, bytes2, uint) {\\n\\n    return (\\n    _categoryId,\\n    categoryActionData[_categoryId].contractAddress,\\n    categoryActionData[_categoryId].contractName,\\n    categoryActionData[_categoryId].defaultIncentive\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the category acion details of a category id\\n   * @param _categoryId is the category id in concern\\n   * @return the category id\\n   * @return the contract address\\n   * @return the contract name\\n   * @return the default incentive\\n   * @return action function hash\\n   */\\n  function categoryActionDetails(uint _categoryId) external view returns (uint, address, bytes2, uint, bytes memory) {\\n    return (\\n    _categoryId,\\n    categoryActionData[_categoryId].contractAddress,\\n    categoryActionData[_categoryId].contractName,\\n    categoryActionData[_categoryId].defaultIncentive,\\n    categoryActionHashes[_categoryId]\\n    );\\n  }\\n\\n  /**\\n  * @dev Updates dependant contract addresses\\n  */\\n  function changeDependentContractAddress() public {\\n    mr = MemberRoles(ms.getLatestAddress(\\\"MR\\\"));\\n  }\\n\\n  /**\\n  * @dev Adds new category\\n  * @param _name Category name\\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\\n  * @param _closingTime Vote closing time for Each voting layer\\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\\n  * @param _contractAddress address of contract to call after proposal is accepted\\n  * @param _contractName name of contract to be called after proposal is accepted\\n  * @param _incentives rewards to distributed after proposal is accepted\\n  * @param _functionHash function signature to be executed\\n  */\\n  function newCategory(\\n    string memory _name,\\n    uint _memberRoleToVote,\\n    uint _majorityVotePerc,\\n    uint _quorumPerc,\\n    uint[] memory _allowedToCreateProposal,\\n    uint _closingTime,\\n    string memory _actionHash,\\n    address _contractAddress,\\n    bytes2 _contractName,\\n    uint[] memory _incentives,\\n    string memory _functionHash\\n  )\\n  public\\n  onlyAuthorizedToGovern\\n  {\\n\\n    require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \\\"Invalid percentage\\\");\\n\\n    require((_contractName == \\\"EX\\\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\\n\\n    require(_incentives[3] <= 1, \\\"Invalid special resolution flag\\\");\\n\\n    //If category is special resolution role authorized should be member\\n    if (_incentives[3] == 1) {\\n      require(_memberRoleToVote == uint(MemberRoles.Role.Member));\\n      _majorityVotePerc = 0;\\n      _quorumPerc = 0;\\n    }\\n\\n    _addCategory(\\n      _name,\\n      _memberRoleToVote,\\n      _majorityVotePerc,\\n      _quorumPerc,\\n      _allowedToCreateProposal,\\n      _closingTime,\\n      _actionHash,\\n      _contractAddress,\\n      _contractName,\\n      _incentives\\n    );\\n\\n\\n    if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\\n      categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);\\n    }\\n  }\\n\\n  /**\\n   * @dev Changes the master address and update it's instance\\n   * @param _masterAddress is the new master address\\n   */\\n  function changeMasterAddress(address _masterAddress) public {\\n    if (masterAddress != address(0))\\n      require(masterAddress == msg.sender);\\n    masterAddress = _masterAddress;\\n    ms = INXMMaster(_masterAddress);\\n    nxMasterAddress = _masterAddress;\\n\\n  }\\n\\n  /**\\n  * @dev Updates category details (Discontinued, moved functionality to editCategory)\\n  * @param _categoryId Category id that needs to be updated\\n  * @param _name Category name\\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\\n  * @param _closingTime Vote closing time for Each voting layer\\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\\n  * @param _contractAddress address of contract to call after proposal is accepted\\n  * @param _contractName name of contract to be called after proposal is accepted\\n  * @param _incentives rewards to distributed after proposal is accepted\\n  */\\n  function updateCategory(\\n    uint _categoryId,\\n    string memory _name,\\n    uint _memberRoleToVote,\\n    uint _majorityVotePerc,\\n    uint _quorumPerc,\\n    uint[] memory _allowedToCreateProposal,\\n    uint _closingTime,\\n    string memory _actionHash,\\n    address _contractAddress,\\n    bytes2 _contractName,\\n    uint[] memory _incentives\\n  ) public {}\\n\\n  /**\\n  * @dev Updates category details\\n  * @param _categoryId Category id that needs to be updated\\n  * @param _name Category name\\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\\n  * @param _closingTime Vote closing time for Each voting layer\\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\\n  * @param _contractAddress address of contract to call after proposal is accepted\\n  * @param _contractName name of contract to be called after proposal is accepted\\n  * @param _incentives rewards to distributed after proposal is accepted\\n  * @param _functionHash function signature to be executed\\n  */\\n  function editCategory(\\n    uint _categoryId,\\n    string memory _name,\\n    uint _memberRoleToVote,\\n    uint _majorityVotePerc,\\n    uint _quorumPerc,\\n    uint[] memory _allowedToCreateProposal,\\n    uint _closingTime,\\n    string memory _actionHash,\\n    address _contractAddress,\\n    bytes2 _contractName,\\n    uint[] memory _incentives,\\n    string memory _functionHash\\n  )\\n  public\\n  onlyAuthorizedToGovern\\n  {\\n    require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \\\"Invalid Role\\\");\\n\\n    require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \\\"Invalid percentage\\\");\\n\\n    require((_contractName == \\\"EX\\\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\\n\\n    require(_incentives[3] <= 1, \\\"Invalid special resolution flag\\\");\\n\\n    //If category is special resolution role authorized should be member\\n    if (_incentives[3] == 1) {\\n      require(_memberRoleToVote == uint(MemberRoles.Role.Member));\\n      _majorityVotePerc = 0;\\n      _quorumPerc = 0;\\n    }\\n\\n    delete categoryActionHashes[_categoryId];\\n    if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\\n      categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);\\n    }\\n    allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\\n    allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\\n    allCategory[_categoryId].closingTime = _closingTime;\\n    allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\\n    allCategory[_categoryId].minStake = _incentives[0];\\n    allCategory[_categoryId].quorumPerc = _quorumPerc;\\n    categoryActionData[_categoryId].defaultIncentive = _incentives[1];\\n    categoryActionData[_categoryId].contractName = _contractName;\\n    categoryActionData[_categoryId].contractAddress = _contractAddress;\\n    categoryABReq[_categoryId] = _incentives[2];\\n    isSpecialResolution[_categoryId] = _incentives[3];\\n    emit Category(_categoryId, _name, _actionHash);\\n  }\\n\\n  /**\\n  * @dev Internal call to add new category\\n  * @param _name Category name\\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\\n  * @param _closingTime Vote closing time for Each voting layer\\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\\n  * @param _contractAddress address of contract to call after proposal is accepted\\n  * @param _contractName name of contract to be called after proposal is accepted\\n  * @param _incentives rewards to distributed after proposal is accepted\\n  */\\n  function _addCategory(\\n    string memory _name,\\n    uint _memberRoleToVote,\\n    uint _majorityVotePerc,\\n    uint _quorumPerc,\\n    uint[] memory _allowedToCreateProposal,\\n    uint _closingTime,\\n    string memory _actionHash,\\n    address _contractAddress,\\n    bytes2 _contractName,\\n    uint[] memory _incentives\\n  )\\n  internal\\n  {\\n    require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \\\"Invalid Role\\\");\\n    allCategory.push(\\n      CategoryStruct(\\n        _memberRoleToVote,\\n        _majorityVotePerc,\\n        _quorumPerc,\\n        _allowedToCreateProposal,\\n        _closingTime,\\n        _incentives[0]\\n      )\\n    );\\n    uint categoryId = allCategory.length - 1;\\n    categoryActionData[categoryId] = CategoryAction(_incentives[1], _contractAddress, _contractName);\\n    categoryABReq[categoryId] = _incentives[2];\\n    isSpecialResolution[categoryId] = _incentives[3];\\n    emit Category(categoryId, _name, _actionHash);\\n  }\\n\\n  /**\\n  * @dev Internal call to check if given roles are valid or not\\n  */\\n  function _verifyMemberRoles(uint _memberRoleToVote, uint[] memory _allowedToCreateProposal)\\n  internal view returns (uint) {\\n    uint totalRoles = mr.totalRoles();\\n    if (_memberRoleToVote >= totalRoles) {\\n      return 0;\\n    }\\n    for (uint i = 0; i < _allowedToCreateProposal.length; i++) {\\n      if (_allowedToCreateProposal[i] >= totalRoles) {\\n        return 0;\\n      }\\n    }\\n    return 1;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/governance/external/IGovernance.sol\": {\r\n      \"content\": \"/* Copyright (C) 2017 GovBlocks.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\ncontract IGovernance {\\n\\n  event Proposal(\\n    address indexed proposalOwner,\\n    uint256 indexed proposalId,\\n    uint256 dateAdd,\\n    string proposalTitle,\\n    string proposalSD,\\n    string proposalDescHash\\n  );\\n\\n  event Solution(\\n    uint256 indexed proposalId,\\n    address indexed solutionOwner,\\n    uint256 indexed solutionId,\\n    string solutionDescHash,\\n    uint256 dateAdd\\n  );\\n\\n  event Vote(\\n    address indexed from,\\n    uint256 indexed proposalId,\\n    uint256 indexed voteId,\\n    uint256 dateAdd,\\n    uint256 solutionChosen\\n  );\\n\\n  event RewardClaimed(\\n    address indexed member,\\n    uint gbtReward\\n  );\\n\\n  /// @dev VoteCast event is called whenever a vote is cast that can potentially close the proposal.\\n  event VoteCast (uint256 proposalId);\\n\\n  /// @dev ProposalAccepted event is called when a proposal is accepted so that a server can listen that can\\n  ///      call any offchain actions\\n  event ProposalAccepted (uint256 proposalId);\\n\\n  /// @dev CloseProposalOnTime event is called whenever a proposal is created or updated to close it on time.\\n  event CloseProposalOnTime (\\n    uint256 indexed proposalId,\\n    uint256 time\\n  );\\n\\n  /// @dev ActionSuccess event is called whenever an onchain action is executed.\\n  event ActionSuccess (\\n    uint256 proposalId\\n  );\\n\\n  /// @dev Creates a new proposal\\n  /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\\n  /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\\n  function createProposal(\\n    string calldata _proposalTitle,\\n    string calldata _proposalSD,\\n    string calldata _proposalDescHash,\\n    uint _categoryId\\n  )\\n  external;\\n\\n  /// @dev Edits the details of an existing proposal and creates new version\\n  /// @param _proposalId Proposal id that details needs to be updated\\n  /// @param _proposalDescHash Proposal description hash having long and short description of proposal.\\n  function updateProposal(\\n    uint _proposalId,\\n    string calldata _proposalTitle,\\n    string calldata _proposalSD,\\n    string calldata _proposalDescHash\\n  )\\n  external;\\n\\n  /// @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\\n  function categorizeProposal(\\n    uint _proposalId,\\n    uint _categoryId,\\n    uint _incentives\\n  )\\n  external;\\n\\n  /// @dev Submit proposal with solution\\n  /// @param _proposalId Proposal id\\n  /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\\n  function submitProposalWithSolution(\\n    uint _proposalId,\\n    string calldata _solutionHash,\\n    bytes calldata _action\\n  )\\n  external;\\n\\n  /// @dev Creates a new proposal with solution and votes for the solution\\n  /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\\n  /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\\n  /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\\n  function createProposalwithSolution(\\n    string calldata _proposalTitle,\\n    string calldata _proposalSD,\\n    string calldata _proposalDescHash,\\n    uint _categoryId,\\n    string calldata _solutionHash,\\n    bytes calldata _action\\n  )\\n  external;\\n\\n  /// @dev Casts vote\\n  /// @param _proposalId Proposal id\\n  /// @param _solutionChosen solution chosen while voting. _solutionChosen[0] is the chosen solution\\n  function submitVote(uint _proposalId, uint _solutionChosen) external;\\n\\n  function closeProposal(uint _proposalId) external;\\n\\n  function claimReward(address _memberAddress, uint _maxRecords) external returns (uint pendingDAppReward);\\n\\n  function proposal(uint _proposalId)\\n  external\\n  view\\n  returns (\\n    uint proposalId,\\n    uint category,\\n    uint status,\\n    uint finalVerdict,\\n    uint totalReward\\n  );\\n\\n  function canCloseProposal(uint _proposalId) public view returns (uint closeValue);\\n\\n  function allowedToCatgorize() public view returns (uint roleId);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/Iupgradable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./INXMMaster.sol\\\";\\n\\ncontract Iupgradable {\\n\\n  INXMMaster public ms;\\n  address public nxMasterAddress;\\n\\n  modifier onlyInternal {\\n    require(ms.isInternal(msg.sender));\\n    _;\\n  }\\n\\n  modifier isMemberAndcheckPause {\\n    require(ms.isPause() == false && ms.isMember(msg.sender) == true);\\n    _;\\n  }\\n\\n  modifier onlyOwner {\\n    require(ms.isOwner(msg.sender));\\n    _;\\n  }\\n\\n  modifier checkPause {\\n    require(ms.isPause() == false);\\n    _;\\n  }\\n\\n  modifier isMember {\\n    require(ms.isMember(msg.sender), \\\"Not member\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public;\\n\\n  /**\\n   * @dev change master address\\n   * @param _masterAddress is the new address\\n   */\\n  function changeMasterAddress(address _masterAddress) public {\\n    if (address(ms) != address(0)) {\\n      require(address(ms) == msg.sender, \\\"Not master\\\");\\n    }\\n\\n    ms = INXMMaster(_masterAddress);\\n    nxMasterAddress = _masterAddress;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPooledStaking.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\ninterface IPooledStaking {\\n\\n  function accumulateReward(address contractAddress, uint amount) external;\\n\\n  function pushBurn(address contractAddress, uint amount) external;\\n\\n  function hasPendingActions() external view returns (bool);\\n\\n  function processPendingActions(uint maxIterations) external returns (bool finished);\\n\\n  function contractStake(address contractAddress) external view returns (uint);\\n\\n  function stakerReward(address staker) external view returns (uint);\\n\\n  function stakerDeposit(address staker) external view returns (uint);\\n\\n  function stakerContractStake(address staker, address contractAddress) external view returns (uint);\\n\\n  function withdraw(uint amount) external;\\n\\n  function stakerMaxWithdrawable(address stakerAddress) external view returns (uint);\\n\\n  function withdrawReward(address stakerAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/modules/claims/ClaimsData.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\n\\ncontract ClaimsData is Iupgradable {\\n  using SafeMath for uint;\\n\\n  struct Claim {\\n    uint coverId;\\n    uint dateUpd;\\n  }\\n\\n  struct Vote {\\n    address voter;\\n    uint tokens;\\n    uint claimId;\\n    int8 verdict;\\n    bool rewardClaimed;\\n  }\\n\\n  struct ClaimsPause {\\n    uint coverid;\\n    uint dateUpd;\\n    bool submit;\\n  }\\n\\n  struct ClaimPauseVoting {\\n    uint claimid;\\n    uint pendingTime;\\n    bool voting;\\n  }\\n\\n  struct RewardDistributed {\\n    uint lastCAvoteIndex;\\n    uint lastMVvoteIndex;\\n\\n  }\\n\\n  struct ClaimRewardDetails {\\n    uint percCA;\\n    uint percMV;\\n    uint tokenToBeDist;\\n\\n  }\\n\\n  struct ClaimTotalTokens {\\n    uint accept;\\n    uint deny;\\n  }\\n\\n  struct ClaimRewardStatus {\\n    uint percCA;\\n    uint percMV;\\n  }\\n\\n  ClaimRewardStatus[] internal rewardStatus;\\n\\n  Claim[] internal allClaims;\\n  Vote[] internal allvotes;\\n  ClaimsPause[] internal claimPause;\\n  ClaimPauseVoting[] internal claimPauseVotingEP;\\n\\n  mapping(address => RewardDistributed) internal voterVoteRewardReceived;\\n  mapping(uint => ClaimRewardDetails) internal claimRewardDetail;\\n  mapping(uint => ClaimTotalTokens) internal claimTokensCA;\\n  mapping(uint => ClaimTotalTokens) internal claimTokensMV;\\n  mapping(uint => int8) internal claimVote;\\n  mapping(uint => uint) internal claimsStatus;\\n  mapping(uint => uint) internal claimState12Count;\\n  mapping(uint => uint[]) internal claimVoteCA;\\n  mapping(uint => uint[]) internal claimVoteMember;\\n  mapping(address => uint[]) internal voteAddressCA;\\n  mapping(address => uint[]) internal voteAddressMember;\\n  mapping(address => uint[]) internal allClaimsByAddress;\\n  mapping(address => mapping(uint => uint)) internal userClaimVoteCA;\\n  mapping(address => mapping(uint => uint)) internal userClaimVoteMember;\\n  mapping(address => uint) public userClaimVotePausedOn;\\n\\n  uint internal claimPauseLastsubmit;\\n  uint internal claimStartVotingFirstIndex;\\n  uint public pendingClaimStart;\\n  uint public claimDepositTime;\\n  uint public maxVotingTime;\\n  uint public minVotingTime;\\n  uint public payoutRetryTime;\\n  uint public claimRewardPerc;\\n  uint public minVoteThreshold;\\n  uint public maxVoteThreshold;\\n  uint public majorityConsensus;\\n  uint public pauseDaysCA;\\n\\n  event ClaimRaise(\\n    uint indexed coverId,\\n    address indexed userAddress,\\n    uint claimId,\\n    uint dateSubmit\\n  );\\n\\n  event VoteCast(\\n    address indexed userAddress,\\n    uint indexed claimId,\\n    bytes4 indexed typeOf,\\n    uint tokens,\\n    uint submitDate,\\n    int8 verdict\\n  );\\n\\n  constructor() public {\\n    pendingClaimStart = 1;\\n    maxVotingTime = 48 * 1 hours;\\n    minVotingTime = 12 * 1 hours;\\n    payoutRetryTime = 24 * 1 hours;\\n    allvotes.push(Vote(address(0), 0, 0, 0, false));\\n    allClaims.push(Claim(0, 0));\\n    claimDepositTime = 7 days;\\n    claimRewardPerc = 20;\\n    minVoteThreshold = 5;\\n    maxVoteThreshold = 10;\\n    majorityConsensus = 70;\\n    pauseDaysCA = 3 days;\\n    _addRewardIncentive();\\n  }\\n\\n  /**\\n   * @dev Updates the pending claim start variable,\\n   * the lowest claim id with a pending decision/payout.\\n   */\\n  function setpendingClaimStart(uint _start) external onlyInternal {\\n    require(pendingClaimStart <= _start);\\n    pendingClaimStart = _start;\\n  }\\n\\n  /**\\n   * @dev Updates the max vote index for which claim assessor has received reward\\n   * @param _voter address of the voter.\\n   * @param caIndex last index till which reward was distributed for CA\\n   */\\n  function setRewardDistributedIndexCA(address _voter, uint caIndex) external onlyInternal {\\n    voterVoteRewardReceived[_voter].lastCAvoteIndex = caIndex;\\n\\n  }\\n\\n  /**\\n   * @dev Used to pause claim assessor activity for 3 days\\n   * @param user Member address whose claim voting ability needs to be paused\\n   */\\n  function setUserClaimVotePausedOn(address user) external {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    userClaimVotePausedOn[user] = now;\\n  }\\n\\n  /**\\n   * @dev Updates the max vote index for which member has received reward\\n   * @param _voter address of the voter.\\n   * @param mvIndex last index till which reward was distributed for member\\n   */\\n  function setRewardDistributedIndexMV(address _voter, uint mvIndex) external onlyInternal {\\n\\n    voterVoteRewardReceived[_voter].lastMVvoteIndex = mvIndex;\\n  }\\n\\n  /**\\n   * @param claimid claim id.\\n   * @param percCA reward Percentage reward for claim assessor\\n   * @param percMV reward Percentage reward for members\\n   * @param tokens total tokens to be rewarded\\n   */\\n  function setClaimRewardDetail(\\n    uint claimid,\\n    uint percCA,\\n    uint percMV,\\n    uint tokens\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimRewardDetail[claimid].percCA = percCA;\\n    claimRewardDetail[claimid].percMV = percMV;\\n    claimRewardDetail[claimid].tokenToBeDist = tokens;\\n  }\\n\\n  /**\\n   * @dev Sets the reward claim status against a vote id.\\n   * @param _voteid vote Id.\\n   * @param claimed true if reward for vote is claimed, else false.\\n   */\\n  function setRewardClaimed(uint _voteid, bool claimed) external onlyInternal {\\n    allvotes[_voteid].rewardClaimed = claimed;\\n  }\\n\\n  /**\\n   * @dev Sets the final vote's result(either accepted or declined)of a claim.\\n   * @param _claimId Claim Id.\\n   * @param _verdict 1 if claim is accepted,-1 if declined.\\n   */\\n  function changeFinalVerdict(uint _claimId, int8 _verdict) external onlyInternal {\\n    claimVote[_claimId] = _verdict;\\n  }\\n\\n  /**\\n   * @dev Creates a new claim.\\n   */\\n  function addClaim(\\n    uint _claimId,\\n    uint _coverId,\\n    address _from,\\n    uint _nowtime\\n  )\\n  external\\n  onlyInternal\\n  {\\n    allClaims.push(Claim(_coverId, _nowtime));\\n    allClaimsByAddress[_from].push(_claimId);\\n  }\\n\\n  /**\\n   * @dev Add Vote's details of a given claim.\\n   */\\n  function addVote(\\n    address _voter,\\n    uint _tokens,\\n    uint claimId,\\n    int8 _verdict\\n  )\\n  external\\n  onlyInternal\\n  {\\n    allvotes.push(Vote(_voter, _tokens, claimId, _verdict, false));\\n  }\\n\\n  /**\\n   * @dev Stores the id of the claim assessor vote given to a claim.\\n   * Maintains record of all votes given by all the CA to a claim.\\n   * @param _claimId Claim Id to which vote has given by the CA.\\n   * @param _voteid Vote Id.\\n   */\\n  function addClaimVoteCA(uint _claimId, uint _voteid) external onlyInternal {\\n    claimVoteCA[_claimId].push(_voteid);\\n  }\\n\\n  /**\\n   * @dev Sets the id of the vote.\\n   * @param _from Claim assessor's address who has given the vote.\\n   * @param _claimId Claim Id for which vote has been given by the CA.\\n   * @param _voteid Vote Id which will be stored against the given _from and claimid.\\n   */\\n  function setUserClaimVoteCA(\\n    address _from,\\n    uint _claimId,\\n    uint _voteid\\n  )\\n  external\\n  onlyInternal\\n  {\\n    userClaimVoteCA[_from][_claimId] = _voteid;\\n    voteAddressCA[_from].push(_voteid);\\n  }\\n\\n  /**\\n   * @dev Stores the tokens locked by the Claim Assessors during voting of a given claim.\\n   * @param _claimId Claim Id.\\n   * @param _vote 1 for accept and increases the tokens of claim as accept,\\n   * -1 for deny and increases the tokens of claim as deny.\\n   * @param _tokens Number of tokens.\\n   */\\n  function setClaimTokensCA(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\\n    if (_vote == 1)\\n      claimTokensCA[_claimId].accept = claimTokensCA[_claimId].accept.add(_tokens);\\n    if (_vote == - 1)\\n      claimTokensCA[_claimId].deny = claimTokensCA[_claimId].deny.add(_tokens);\\n  }\\n\\n  /**\\n   * @dev Stores the tokens locked by the Members during voting of a given claim.\\n   * @param _claimId Claim Id.\\n   * @param _vote 1 for accept and increases the tokens of claim as accept,\\n   * -1 for deny and increases the tokens of claim as deny.\\n   * @param _tokens Number of tokens.\\n   */\\n  function setClaimTokensMV(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\\n    if (_vote == 1)\\n      claimTokensMV[_claimId].accept = claimTokensMV[_claimId].accept.add(_tokens);\\n    if (_vote == - 1)\\n      claimTokensMV[_claimId].deny = claimTokensMV[_claimId].deny.add(_tokens);\\n  }\\n\\n  /**\\n   * @dev Stores the id of the member vote given to a claim.\\n   * Maintains record of all votes given by all the Members to a claim.\\n   * @param _claimId Claim Id to which vote has been given by the Member.\\n   * @param _voteid Vote Id.\\n   */\\n  function addClaimVotemember(uint _claimId, uint _voteid) external onlyInternal {\\n    claimVoteMember[_claimId].push(_voteid);\\n  }\\n\\n  /**\\n   * @dev Sets the id of the vote.\\n   * @param _from Member's address who has given the vote.\\n   * @param _claimId Claim Id for which vote has been given by the Member.\\n   * @param _voteid Vote Id which will be stored against the given _from and claimid.\\n   */\\n  function setUserClaimVoteMember(\\n    address _from,\\n    uint _claimId,\\n    uint _voteid\\n  )\\n  external\\n  onlyInternal\\n  {\\n    userClaimVoteMember[_from][_claimId] = _voteid;\\n    voteAddressMember[_from].push(_voteid);\\n\\n  }\\n\\n  /**\\n   * @dev Increases the count of failure until payout of a claim is successful.\\n   */\\n  function updateState12Count(uint _claimId, uint _cnt) external onlyInternal {\\n    claimState12Count[_claimId] = claimState12Count[_claimId].add(_cnt);\\n  }\\n\\n  /**\\n   * @dev Sets status of a claim.\\n   * @param _claimId Claim Id.\\n   * @param _stat Status number.\\n   */\\n  function setClaimStatus(uint _claimId, uint _stat) external onlyInternal {\\n    claimsStatus[_claimId] = _stat;\\n  }\\n\\n  /**\\n   * @dev Sets the timestamp of a given claim at which the Claim's details has been updated.\\n   * @param _claimId Claim Id of claim which has been changed.\\n   * @param _dateUpd timestamp at which claim is updated.\\n   */\\n  function setClaimdateUpd(uint _claimId, uint _dateUpd) external onlyInternal {\\n    allClaims[_claimId].dateUpd = _dateUpd;\\n  }\\n\\n  /**\\n   @dev Queues Claims during Emergency Pause.\\n   */\\n  function setClaimAtEmergencyPause(\\n    uint _coverId,\\n    uint _dateUpd,\\n    bool _submit\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimPause.push(ClaimsPause(_coverId, _dateUpd, _submit));\\n  }\\n\\n  /**\\n   * @dev Set submission flag for Claims queued during emergency pause.\\n   * Set to true after EP is turned off and the claim is submitted .\\n   */\\n  function setClaimSubmittedAtEPTrue(uint _index, bool _submit) external onlyInternal {\\n    claimPause[_index].submit = _submit;\\n  }\\n\\n  /**\\n   * @dev Sets the index from which claim needs to be\\n   * submitted when emergency pause is swithched off.\\n   */\\n  function setFirstClaimIndexToSubmitAfterEP(\\n    uint _firstClaimIndexToSubmit\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimPauseLastsubmit = _firstClaimIndexToSubmit;\\n  }\\n\\n  /**\\n   * @dev Sets the pending vote duration for a claim in case of emergency pause.\\n   */\\n  function setPendingClaimDetails(\\n    uint _claimId,\\n    uint _pendingTime,\\n    bool _voting\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimPauseVotingEP.push(ClaimPauseVoting(_claimId, _pendingTime, _voting));\\n  }\\n\\n  /**\\n   * @dev Sets voting flag true after claim is reopened for voting after emergency pause.\\n   */\\n  function setPendingClaimVoteStatus(uint _claimId, bool _vote) external onlyInternal {\\n    claimPauseVotingEP[_claimId].voting = _vote;\\n  }\\n\\n  /**\\n   * @dev Sets the index from which claim needs to be\\n   * reopened when emergency pause is swithched off.\\n   */\\n  function setFirstClaimIndexToStartVotingAfterEP(\\n    uint _claimStartVotingFirstIndex\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimStartVotingFirstIndex = _claimStartVotingFirstIndex;\\n  }\\n\\n  /**\\n   * @dev Calls Vote Event.\\n   */\\n  function callVoteEvent(\\n    address _userAddress,\\n    uint _claimId,\\n    bytes4 _typeOf,\\n    uint _tokens,\\n    uint _submitDate,\\n    int8 _verdict\\n  )\\n  external\\n  onlyInternal\\n  {\\n    emit VoteCast(\\n      _userAddress,\\n      _claimId,\\n      _typeOf,\\n      _tokens,\\n      _submitDate,\\n      _verdict\\n    );\\n  }\\n\\n  /**\\n   * @dev Calls Claim Event.\\n   */\\n  function callClaimEvent(\\n    uint _coverId,\\n    address _userAddress,\\n    uint _claimId,\\n    uint _datesubmit\\n  )\\n  external\\n  onlyInternal\\n  {\\n    emit ClaimRaise(_coverId, _userAddress, _claimId, _datesubmit);\\n  }\\n\\n  /**\\n   * @dev Gets Uint Parameters by parameter code\\n   * @param code whose details we want\\n   * @return string value of the parameter\\n   * @return associated amount (time or perc or value) to the code\\n   */\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\\n    codeVal = code;\\n    if (code == \\\"CAMAXVT\\\") {\\n      val = maxVotingTime / (1 hours);\\n\\n    } else if (code == \\\"CAMINVT\\\") {\\n\\n      val = minVotingTime / (1 hours);\\n\\n    } else if (code == \\\"CAPRETRY\\\") {\\n\\n      val = payoutRetryTime / (1 hours);\\n\\n    } else if (code == \\\"CADEPT\\\") {\\n\\n      val = claimDepositTime / (1 days);\\n\\n    } else if (code == \\\"CAREWPER\\\") {\\n\\n      val = claimRewardPerc;\\n\\n    } else if (code == \\\"CAMINTH\\\") {\\n\\n      val = minVoteThreshold;\\n\\n    } else if (code == \\\"CAMAXTH\\\") {\\n\\n      val = maxVoteThreshold;\\n\\n    } else if (code == \\\"CACONPER\\\") {\\n\\n      val = majorityConsensus;\\n\\n    } else if (code == \\\"CAPAUSET\\\") {\\n      val = pauseDaysCA / (1 days);\\n    }\\n\\n  }\\n\\n  /**\\n   * @dev Get claim queued during emergency pause by index.\\n   */\\n  function getClaimOfEmergencyPauseByIndex(\\n    uint _index\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    uint dateUpd,\\n    bool submit\\n  )\\n  {\\n    coverId = claimPause[_index].coverid;\\n    dateUpd = claimPause[_index].dateUpd;\\n    submit = claimPause[_index].submit;\\n  }\\n\\n  /**\\n   * @dev Gets the Claim's details of given claimid.\\n   */\\n  function getAllClaimsByIndex(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    int8 vote,\\n    uint status,\\n    uint dateUpd,\\n    uint state12Count\\n  )\\n  {\\n    return (\\n    allClaims[_claimId].coverId,\\n    claimVote[_claimId],\\n    claimsStatus[_claimId],\\n    allClaims[_claimId].dateUpd,\\n    claimState12Count[_claimId]\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the vote id of a given claim of a given Claim Assessor.\\n   */\\n  function getUserClaimVoteCA(\\n    address _add,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint idVote)\\n  {\\n    return userClaimVoteCA[_add][_claimId];\\n  }\\n\\n  /**\\n   * @dev Gets the vote id of a given claim of a given member.\\n   */\\n  function getUserClaimVoteMember(\\n    address _add,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint idVote)\\n  {\\n    return userClaimVoteMember[_add][_claimId];\\n  }\\n\\n  /**\\n   * @dev Gets the count of all votes.\\n   */\\n  function getAllVoteLength() external view returns (uint voteCount) {\\n    return allvotes.length.sub(1); // Start Index always from 1.\\n  }\\n\\n  /**\\n   * @dev Gets the status number of a given claim.\\n   * @param _claimId Claim id.\\n   * @return statno Status Number.\\n   */\\n  function getClaimStatusNumber(uint _claimId) external view returns (uint claimId, uint statno) {\\n    return (_claimId, claimsStatus[_claimId]);\\n  }\\n\\n  /**\\n   * @dev Gets the reward percentage to be distributed for a given status id\\n   * @param statusNumber the number of type of status\\n   * @return percCA reward Percentage for claim assessor\\n   * @return percMV reward Percentage for members\\n   */\\n  function getRewardStatus(uint statusNumber) external view returns (uint percCA, uint percMV) {\\n    return (rewardStatus[statusNumber].percCA, rewardStatus[statusNumber].percMV);\\n  }\\n\\n  /**\\n   * @dev Gets the number of tries that have been made for a successful payout of a Claim.\\n   */\\n  function getClaimState12Count(uint _claimId) external view returns (uint num) {\\n    num = claimState12Count[_claimId];\\n  }\\n\\n  /**\\n   * @dev Gets the last update date of a claim.\\n   */\\n  function getClaimDateUpd(uint _claimId) external view returns (uint dateupd) {\\n    dateupd = allClaims[_claimId].dateUpd;\\n  }\\n\\n  /**\\n   * @dev Gets all Claims created by a user till date.\\n   * @param _member user's address.\\n   * @return claimarr List of Claims id.\\n   */\\n  function getAllClaimsByAddress(address _member) external view returns (uint[] memory claimarr) {\\n    return allClaimsByAddress[_member];\\n  }\\n\\n  /**\\n   * @dev Gets the number of tokens that has been locked\\n   * while giving vote to a claim by  Claim Assessors.\\n   * @param _claimId Claim Id.\\n   * @return accept Total number of tokens when CA accepts the claim.\\n   * @return deny Total number of tokens when CA declines the claim.\\n   */\\n  function getClaimsTokenCA(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint accept,\\n    uint deny\\n  )\\n  {\\n    return (\\n    _claimId,\\n    claimTokensCA[_claimId].accept,\\n    claimTokensCA[_claimId].deny\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the number of tokens that have been\\n   * locked while assessing a claim as a member.\\n   * @param _claimId Claim Id.\\n   * @return accept Total number of tokens in acceptance of the claim.\\n   * @return deny Total number of tokens against the claim.\\n   */\\n  function getClaimsTokenMV(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint accept,\\n    uint deny\\n  )\\n  {\\n    return (\\n    _claimId,\\n    claimTokensMV[_claimId].accept,\\n    claimTokensMV[_claimId].deny\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the total number of votes cast as Claims assessor for/against a given claim\\n   */\\n  function getCaClaimVotesToken(uint _claimId) external view returns (uint claimId, uint cnt) {\\n    claimId = _claimId;\\n    cnt = 0;\\n    for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {\\n      cnt = cnt.add(allvotes[claimVoteCA[_claimId][i]].tokens);\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets the total number of tokens cast as a member for/against a given claim\\n   */\\n  function getMemberClaimVotesToken(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint claimId, uint cnt)\\n  {\\n    claimId = _claimId;\\n    cnt = 0;\\n    for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {\\n      cnt = cnt.add(allvotes[claimVoteMember[_claimId][i]].tokens);\\n    }\\n  }\\n\\n  /**\\n   * @dev Provides information of a vote when given its vote id.\\n   * @param _voteid Vote Id.\\n   */\\n  function getVoteDetails(uint _voteid)\\n  external view\\n  returns (\\n    uint tokens,\\n    uint claimId,\\n    int8 verdict,\\n    bool rewardClaimed\\n  )\\n  {\\n    return (\\n    allvotes[_voteid].tokens,\\n    allvotes[_voteid].claimId,\\n    allvotes[_voteid].verdict,\\n    allvotes[_voteid].rewardClaimed\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the voter's address of a given vote id.\\n   */\\n  function getVoterVote(uint _voteid) external view returns (address voter) {\\n    return allvotes[_voteid].voter;\\n  }\\n\\n  /**\\n   * @dev Provides information of a Claim when given its claim id.\\n   * @param _claimId Claim Id.\\n   */\\n  function getClaim(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint coverId,\\n    int8 vote,\\n    uint status,\\n    uint dateUpd,\\n    uint state12Count\\n  )\\n  {\\n    return (\\n    _claimId,\\n    allClaims[_claimId].coverId,\\n    claimVote[_claimId],\\n    claimsStatus[_claimId],\\n    allClaims[_claimId].dateUpd,\\n    claimState12Count[_claimId]\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the total number of votes of a given claim.\\n   * @param _claimId Claim Id.\\n   * @param _ca if 1: votes given by Claim Assessors to a claim,\\n   * else returns the number of votes of given by Members to a claim.\\n   * @return len total number of votes for/against a given claim.\\n   */\\n  function getClaimVoteLength(\\n    uint _claimId,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (uint claimId, uint len)\\n  {\\n    claimId = _claimId;\\n    if (_ca == 1)\\n      len = claimVoteCA[_claimId].length;\\n    else\\n      len = claimVoteMember[_claimId].length;\\n  }\\n\\n  /**\\n   * @dev Gets the verdict of a vote using claim id and index.\\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\\n   * @return ver 1 if vote was given in favour,-1 if given in against.\\n   */\\n  function getVoteVerdict(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (int8 ver)\\n  {\\n    if (_ca == 1)\\n      ver = allvotes[claimVoteCA[_claimId][_index]].verdict;\\n    else\\n      ver = allvotes[claimVoteMember[_claimId][_index]].verdict;\\n  }\\n\\n  /**\\n   * @dev Gets the Number of tokens of a vote using claim id and index.\\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\\n   * @return tok Number of tokens.\\n   */\\n  function getVoteToken(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (uint tok)\\n  {\\n    if (_ca == 1)\\n      tok = allvotes[claimVoteCA[_claimId][_index]].tokens;\\n    else\\n      tok = allvotes[claimVoteMember[_claimId][_index]].tokens;\\n  }\\n\\n  /**\\n   * @dev Gets the Voter's address of a vote using claim id and index.\\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\\n   * @return voter Voter's address.\\n   */\\n  function getVoteVoter(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (address voter)\\n  {\\n    if (_ca == 1)\\n      voter = allvotes[claimVoteCA[_claimId][_index]].voter;\\n    else\\n      voter = allvotes[claimVoteMember[_claimId][_index]].voter;\\n  }\\n\\n  /**\\n   * @dev Gets total number of Claims created by a user till date.\\n   * @param _add User's address.\\n   */\\n  function getUserClaimCount(address _add) external view returns (uint len) {\\n    len = allClaimsByAddress[_add].length;\\n  }\\n\\n  /**\\n   * @dev Calculates number of Claims that are in pending state.\\n   */\\n  function getClaimLength() external view returns (uint len) {\\n    len = allClaims.length.sub(pendingClaimStart);\\n  }\\n\\n  /**\\n   * @dev Gets the Number of all the Claims created till date.\\n   */\\n  function actualClaimLength() external view returns (uint len) {\\n    len = allClaims.length;\\n  }\\n\\n  /**\\n   * @dev Gets details of a claim.\\n   * @param _index claim id = pending claim start + given index\\n   * @param _add User's address.\\n   * @return coverid cover against which claim has been submitted.\\n   * @return claimId Claim  Id.\\n   * @return voteCA verdict of vote given as a Claim Assessor.\\n   * @return voteMV verdict of vote given as a Member.\\n   * @return statusnumber Status of claim.\\n   */\\n  function getClaimFromNewStart(\\n    uint _index,\\n    address _add\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverid,\\n    uint claimId,\\n    int8 voteCA,\\n    int8 voteMV,\\n    uint statusnumber\\n  )\\n  {\\n    uint i = pendingClaimStart.add(_index);\\n    coverid = allClaims[i].coverId;\\n    claimId = i;\\n    if (userClaimVoteCA[_add][i] > 0)\\n      voteCA = allvotes[userClaimVoteCA[_add][i]].verdict;\\n    else\\n      voteCA = 0;\\n\\n    if (userClaimVoteMember[_add][i] > 0)\\n      voteMV = allvotes[userClaimVoteMember[_add][i]].verdict;\\n    else\\n      voteMV = 0;\\n\\n    statusnumber = claimsStatus[i];\\n  }\\n\\n  /**\\n   * @dev Gets details of a claim of a user at a given index.\\n   */\\n  function getUserClaimByIndex(\\n    uint _index,\\n    address _add\\n  )\\n  external\\n  view\\n  returns (\\n    uint status,\\n    uint coverid,\\n    uint claimId\\n  )\\n  {\\n    claimId = allClaimsByAddress[_add][_index];\\n    status = claimsStatus[claimId];\\n    coverid = allClaims[claimId].coverId;\\n  }\\n\\n  /**\\n   * @dev Gets Id of all the votes given to a claim.\\n   * @param _claimId Claim Id.\\n   * @return ca id of all the votes given by Claim assessors to a claim.\\n   * @return mv id of all the votes given by members to a claim.\\n   */\\n  function getAllVotesForClaim(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint[] memory ca,\\n    uint[] memory mv\\n  )\\n  {\\n    return (_claimId, claimVoteCA[_claimId], claimVoteMember[_claimId]);\\n  }\\n\\n  /**\\n   * @dev Gets Number of tokens deposit in a vote using\\n   * Claim assessor's address and claim id.\\n   * @return tokens Number of deposited tokens.\\n   */\\n  function getTokensClaim(\\n    address _of,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint tokens\\n  )\\n  {\\n    return (_claimId, allvotes[userClaimVoteCA[_of][_claimId]].tokens);\\n  }\\n\\n  /**\\n   * @param _voter address of the voter.\\n   * @return lastCAvoteIndex last index till which reward was distributed for CA\\n   * @return lastMVvoteIndex last index till which reward was distributed for member\\n   */\\n  function getRewardDistributedIndex(\\n    address _voter\\n  )\\n  external\\n  view\\n  returns (\\n    uint lastCAvoteIndex,\\n    uint lastMVvoteIndex\\n  )\\n  {\\n    return (\\n    voterVoteRewardReceived[_voter].lastCAvoteIndex,\\n    voterVoteRewardReceived[_voter].lastMVvoteIndex\\n    );\\n  }\\n\\n  /**\\n   * @param claimid claim id.\\n   * @return perc_CA reward Percentage for claim assessor\\n   * @return perc_MV reward Percentage for members\\n   * @return tokens total tokens to be rewarded\\n   */\\n  function getClaimRewardDetail(\\n    uint claimid\\n  )\\n  external\\n  view\\n  returns (\\n    uint percCA,\\n    uint percMV,\\n    uint tokens\\n  )\\n  {\\n    return (\\n    claimRewardDetail[claimid].percCA,\\n    claimRewardDetail[claimid].percMV,\\n    claimRewardDetail[claimid].tokenToBeDist\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets cover id of a claim.\\n   */\\n  function getClaimCoverId(uint _claimId) external view returns (uint claimId, uint coverid) {\\n    return (_claimId, allClaims[_claimId].coverId);\\n  }\\n\\n  /**\\n   * @dev Gets total number of tokens staked during voting by Claim Assessors.\\n   * @param _claimId Claim Id.\\n   * @param _verdict 1 to get total number of accept tokens, -1 to get total number of deny tokens.\\n   * @return token token Number of tokens(either accept or deny on the basis of verdict given as parameter).\\n   */\\n  function getClaimVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token) {\\n    claimId = _claimId;\\n    token = 0;\\n    for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {\\n      if (allvotes[claimVoteCA[_claimId][i]].verdict == _verdict)\\n        token = token.add(allvotes[claimVoteCA[_claimId][i]].tokens);\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets total number of tokens staked during voting by Members.\\n   * @param _claimId Claim Id.\\n   * @param _verdict 1 to get total number of accept tokens,\\n   *  -1 to get total number of deny tokens.\\n   * @return token token Number of tokens(either accept or\\n   * deny on the basis of verdict given as parameter).\\n   */\\n  function getClaimMVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token) {\\n    claimId = _claimId;\\n    token = 0;\\n    for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {\\n      if (allvotes[claimVoteMember[_claimId][i]].verdict == _verdict)\\n        token = token.add(allvotes[claimVoteMember[_claimId][i]].tokens);\\n    }\\n  }\\n\\n  /**\\n   * @param _voter address  of voteid\\n   * @param index index to get voteid in CA\\n   */\\n  function getVoteAddressCA(address _voter, uint index) external view returns (uint) {\\n    return voteAddressCA[_voter][index];\\n  }\\n\\n  /**\\n   * @param _voter address  of voter\\n   * @param index index to get voteid in member vote\\n   */\\n  function getVoteAddressMember(address _voter, uint index) external view returns (uint) {\\n    return voteAddressMember[_voter][index];\\n  }\\n\\n  /**\\n   * @param _voter address  of voter\\n   */\\n  function getVoteAddressCALength(address _voter) external view returns (uint) {\\n    return voteAddressCA[_voter].length;\\n  }\\n\\n  /**\\n   * @param _voter address  of voter\\n   */\\n  function getVoteAddressMemberLength(address _voter) external view returns (uint) {\\n    return voteAddressMember[_voter].length;\\n  }\\n\\n  /**\\n   * @dev Gets the Final result of voting of a claim.\\n   * @param _claimId Claim id.\\n   * @return verdict 1 if claim is accepted, -1 if declined.\\n   */\\n  function getFinalVerdict(uint _claimId) external view returns (int8 verdict) {\\n    return claimVote[_claimId];\\n  }\\n\\n  /**\\n   * @dev Get number of Claims queued for submission during emergency pause.\\n   */\\n  function getLengthOfClaimSubmittedAtEP() external view returns (uint len) {\\n    len = claimPause.length;\\n  }\\n\\n  /**\\n   * @dev Gets the index from which claim needs to be\\n   * submitted when emergency pause is swithched off.\\n   */\\n  function getFirstClaimIndexToSubmitAfterEP() external view returns (uint indexToSubmit) {\\n    indexToSubmit = claimPauseLastsubmit;\\n  }\\n\\n  /**\\n   * @dev Gets number of Claims to be reopened for voting post emergency pause period.\\n   */\\n  function getLengthOfClaimVotingPause() external view returns (uint len) {\\n    len = claimPauseVotingEP.length;\\n  }\\n\\n  /**\\n   * @dev Gets claim details to be reopened for voting after emergency pause.\\n   */\\n  function getPendingClaimDetailsByIndex(\\n    uint _index\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint pendingTime,\\n    bool voting\\n  )\\n  {\\n    claimId = claimPauseVotingEP[_index].claimid;\\n    pendingTime = claimPauseVotingEP[_index].pendingTime;\\n    voting = claimPauseVotingEP[_index].voting;\\n  }\\n\\n  /**\\n   * @dev Gets the index from which claim needs to be reopened when emergency pause is swithched off.\\n   */\\n  function getFirstClaimIndexToStartVotingAfterEP() external view returns (uint firstindex) {\\n    firstindex = claimStartVotingFirstIndex;\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param val value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"CAMAXVT\\\") {\\n      _setMaxVotingTime(val * 1 hours);\\n\\n    } else if (code == \\\"CAMINVT\\\") {\\n\\n      _setMinVotingTime(val * 1 hours);\\n\\n    } else if (code == \\\"CAPRETRY\\\") {\\n\\n      _setPayoutRetryTime(val * 1 hours);\\n\\n    } else if (code == \\\"CADEPT\\\") {\\n\\n      _setClaimDepositTime(val * 1 days);\\n\\n    } else if (code == \\\"CAREWPER\\\") {\\n\\n      _setClaimRewardPerc(val);\\n\\n    } else if (code == \\\"CAMINTH\\\") {\\n\\n      _setMinVoteThreshold(val);\\n\\n    } else if (code == \\\"CAMAXTH\\\") {\\n\\n      _setMaxVoteThreshold(val);\\n\\n    } else if (code == \\\"CACONPER\\\") {\\n\\n      _setMajorityConsensus(val);\\n\\n    } else if (code == \\\"CAPAUSET\\\") {\\n      _setPauseDaysCA(val * 1 days);\\n    } else {\\n\\n      revert(\\\"Invalid param code\\\");\\n    }\\n\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public onlyInternal {}\\n\\n  /**\\n   * @dev Adds status under which a claim can lie.\\n   * @param percCA reward percentage for claim assessor\\n   * @param percMV reward percentage for members\\n   */\\n  function _pushStatus(uint percCA, uint percMV) internal {\\n    rewardStatus.push(ClaimRewardStatus(percCA, percMV));\\n  }\\n\\n  /**\\n   * @dev adds reward incentive for all possible claim status for Claim assessors and members\\n   */\\n  function _addRewardIncentive() internal {\\n    _pushStatus(0, 0); // 0  Pending-Claim Assessor Vote\\n    _pushStatus(0, 0); // 1 Pending-Claim Assessor Vote Denied, Pending Member Vote\\n    _pushStatus(0, 0); // 2 Pending-CA Vote Threshold not Reached Accept, Pending Member Vote\\n    _pushStatus(0, 0); // 3 Pending-CA Vote Threshold not Reached Deny, Pending Member Vote\\n    _pushStatus(0, 0); // 4 Pending-CA Consensus not reached Accept, Pending Member Vote\\n    _pushStatus(0, 0); // 5 Pending-CA Consensus not reached Deny, Pending Member Vote\\n    _pushStatus(100, 0); // 6 Final-Claim Assessor Vote Denied\\n    _pushStatus(100, 0); // 7 Final-Claim Assessor Vote Accepted\\n    _pushStatus(0, 100); // 8 Final-Claim Assessor Vote Denied, MV Accepted\\n    _pushStatus(0, 100); // 9 Final-Claim Assessor Vote Denied, MV Denied\\n    _pushStatus(0, 0); // 10 Final-Claim Assessor Vote Accept, MV Nodecision\\n    _pushStatus(0, 0); // 11 Final-Claim Assessor Vote Denied, MV Nodecision\\n    _pushStatus(0, 0); // 12 Claim Accepted Payout Pending\\n    _pushStatus(0, 0); // 13 Claim Accepted No Payout\\n    _pushStatus(0, 0); // 14 Claim Accepted Payout Done\\n  }\\n\\n  /**\\n   * @dev Sets Maximum time(in seconds) for which claim assessment voting is open\\n   */\\n  function _setMaxVotingTime(uint _time) internal {\\n    maxVotingTime = _time;\\n  }\\n\\n  /**\\n   *  @dev Sets Minimum time(in seconds) for which claim assessment voting is open\\n   */\\n  function _setMinVotingTime(uint _time) internal {\\n    minVotingTime = _time;\\n  }\\n\\n  /**\\n   *  @dev Sets Minimum vote threshold required\\n   */\\n  function _setMinVoteThreshold(uint val) internal {\\n    minVoteThreshold = val;\\n  }\\n\\n  /**\\n   *  @dev Sets Maximum vote threshold required\\n   */\\n  function _setMaxVoteThreshold(uint val) internal {\\n    maxVoteThreshold = val;\\n  }\\n\\n  /**\\n   *  @dev Sets the value considered as Majority Consenus in voting\\n   */\\n  function _setMajorityConsensus(uint val) internal {\\n    majorityConsensus = val;\\n  }\\n\\n  /**\\n   * @dev Sets the payout retry time\\n   */\\n  function _setPayoutRetryTime(uint _time) internal {\\n    payoutRetryTime = _time;\\n  }\\n\\n  /**\\n   *  @dev Sets percentage of reward given for claim assessment\\n   */\\n  function _setClaimRewardPerc(uint _val) internal {\\n\\n    claimRewardPerc = _val;\\n  }\\n\\n  /**\\n   * @dev Sets the time for which claim is deposited.\\n   */\\n  function _setClaimDepositTime(uint _time) internal {\\n\\n    claimDepositTime = _time;\\n  }\\n\\n  /**\\n   *  @dev Sets number of days claim assessment will be paused\\n   */\\n  function _setPauseDaysCA(uint val) internal {\\n    pauseDaysCA = val;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/NXMToken.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"./external/OZIERC20.sol\\\";\\nimport \\\"./external/OZSafeMath.sol\\\";\\n\\ncontract NXMToken is OZIERC20 {\\n  using OZSafeMath for uint256;\\n\\n  event WhiteListed(address indexed member);\\n\\n  event BlackListed(address indexed member);\\n\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowed;\\n\\n  mapping(address => bool) public whiteListed;\\n\\n  mapping(address => uint) public isLockedForMV;\\n\\n  uint256 private _totalSupply;\\n\\n  string public name = \\\"NXM\\\";\\n  string public symbol = \\\"NXM\\\";\\n  uint8 public decimals = 18;\\n  address public operator;\\n\\n  modifier canTransfer(address _to) {\\n    require(whiteListed[_to]);\\n    _;\\n  }\\n\\n  modifier onlyOperator() {\\n    if (operator != address(0))\\n      require(msg.sender == operator);\\n    _;\\n  }\\n\\n  constructor(address _founderAddress, uint _initialSupply) public {\\n    _mint(_founderAddress, _initialSupply);\\n  }\\n\\n  /**\\n  * @dev Total number of tokens in existence\\n  */\\n  function totalSupply() public view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param owner The address to query the balance of.\\n  * @return An uint256 representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address owner) public view returns (uint256) {\\n    return _balances[owner];\\n  }\\n\\n  /**\\n  * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n  * @param owner address The address which owns the funds.\\n  * @param spender address The address which will spend the funds.\\n  * @return A uint256 specifying the amount of tokens still available for the spender.\\n  */\\n  function allowance(\\n    address owner,\\n    address spender\\n  )\\n  public\\n  view\\n  returns (uint256)\\n  {\\n    return _allowed[owner][spender];\\n  }\\n\\n  /**\\n  * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n  * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n  * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n  * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n  * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n  * @param spender The address which will spend the funds.\\n  * @param value The amount of tokens to be spent.\\n  */\\n  function approve(address spender, uint256 value) public returns (bool) {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = value;\\n    emit Approval(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Increase the amount of tokens that an owner allowed to a spender.\\n  * approve should be called when allowed_[_spender] == 0. To increment\\n  * allowed value is better to use this function to avoid 2 calls (and wait until\\n  * the first transaction is mined)\\n  * From MonolithDAO Token.sol\\n  * @param spender The address which will spend the funds.\\n  * @param addedValue The amount of tokens to increase the allowance by.\\n  */\\n  function increaseAllowance(\\n    address spender,\\n    uint256 addedValue\\n  )\\n  public\\n  returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n    _allowed[msg.sender][spender].add(addedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n  * approve should be called when allowed_[_spender] == 0. To decrement\\n  * allowed value is better to use this function to avoid 2 calls (and wait until\\n  * the first transaction is mined)\\n  * From MonolithDAO Token.sol\\n  * @param spender The address which will spend the funds.\\n  * @param subtractedValue The amount of tokens to decrease the allowance by.\\n  */\\n  function decreaseAllowance(\\n    address spender,\\n    uint256 subtractedValue\\n  )\\n  public\\n  returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n    _allowed[msg.sender][spender].sub(subtractedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Adds a user to whitelist\\n  * @param _member address to add to whitelist\\n  */\\n  function addToWhiteList(address _member) public onlyOperator returns (bool) {\\n    whiteListed[_member] = true;\\n    emit WhiteListed(_member);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev removes a user from whitelist\\n  * @param _member address to remove from whitelist\\n  */\\n  function removeFromWhiteList(address _member) public onlyOperator returns (bool) {\\n    whiteListed[_member] = false;\\n    emit BlackListed(_member);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev change operator address\\n  * @param _newOperator address of new operator\\n  */\\n  function changeOperator(address _newOperator) public onlyOperator returns (bool) {\\n    operator = _newOperator;\\n    return true;\\n  }\\n\\n  /**\\n  * @dev burns an amount of the tokens of the message sender\\n  * account.\\n  * @param amount The amount that will be burnt.\\n  */\\n  function burn(uint256 amount) public returns (bool) {\\n    _burn(msg.sender, amount);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Burns a specific amount of tokens from the target address and decrements allowance\\n  * @param from address The address which you want to send tokens from\\n  * @param value uint256 The amount of token to be burned\\n  */\\n  function burnFrom(address from, uint256 value) public returns (bool) {\\n    _burnFrom(from, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev function that mints an amount of the token and assigns it to\\n  * an account.\\n  * @param account The account that will receive the created tokens.\\n  * @param amount The amount that will be created.\\n  */\\n  function mint(address account, uint256 amount) public onlyOperator {\\n    _mint(account, amount);\\n  }\\n\\n  /**\\n  * @dev Transfer token for a specified address\\n  * @param to The address to transfer to.\\n  * @param value The amount to be transferred.\\n  */\\n  function transfer(address to, uint256 value) public canTransfer(to) returns (bool) {\\n\\n    require(isLockedForMV[msg.sender] < now); // if not voted under governance\\n    require(value <= _balances[msg.sender]);\\n    _transfer(to, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Transfer tokens to the operator from the specified address\\n  * @param from The address to transfer from.\\n  * @param value The amount to be transferred.\\n  */\\n  function operatorTransfer(address from, uint256 value) public onlyOperator returns (bool) {\\n    require(value <= _balances[from]);\\n    _transferFrom(from, operator, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Transfer tokens from one address to another\\n  * @param from address The address which you want to send tokens from\\n  * @param to address The address which you want to transfer to\\n  * @param value uint256 the amount of tokens to be transferred\\n  */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n  public\\n  canTransfer(to)\\n  returns (bool)\\n  {\\n    require(isLockedForMV[from] < now); // if not voted under governance\\n    require(value <= _balances[from]);\\n    require(value <= _allowed[from][msg.sender]);\\n    _transferFrom(from, to, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Lock the user's tokens\\n   * @param _of user's address.\\n   */\\n  function lockForMemberVote(address _of, uint _days) public onlyOperator {\\n    if (_days.add(now) > isLockedForMV[_of])\\n      isLockedForMV[_of] = _days.add(now);\\n  }\\n\\n  /**\\n  * @dev Transfer token for a specified address\\n  * @param to The address to transfer to.\\n  * @param value The amount to be transferred.\\n  */\\n  function _transfer(address to, uint256 value) internal {\\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    emit Transfer(msg.sender, to, value);\\n  }\\n\\n  /**\\n  * @dev Transfer tokens from one address to another\\n  * @param from address The address which you want to send tokens from\\n  * @param to address The address which you want to transfer to\\n  * @param value uint256 the amount of tokens to be transferred\\n  */\\n  function _transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n  internal\\n  {\\n    _balances[from] = _balances[from].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n    emit Transfer(from, to, value);\\n  }\\n\\n  /**\\n  * @dev Internal function that mints an amount of the token and assigns it to\\n  * an account. This encapsulates the modification of balances such that the\\n  * proper events are emitted.\\n  * @param account The account that will receive the created tokens.\\n  * @param amount The amount that will be created.\\n  */\\n  function _mint(address account, uint256 amount) internal {\\n    require(account != address(0));\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[account] = _balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n  * @dev Internal function that burns an amount of the token of a given\\n  * account.\\n  * @param account The account whose tokens will be burnt.\\n  * @param amount The amount that will be burnt.\\n  */\\n  function _burn(address account, uint256 amount) internal {\\n    require(amount <= _balances[account]);\\n\\n    _totalSupply = _totalSupply.sub(amount);\\n    _balances[account] = _balances[account].sub(amount);\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n  * @dev Internal function that burns an amount of the token of a given\\n  * account, deducting from the sender's allowance for said account. Uses the\\n  * internal burn function.\\n  * @param account The account whose tokens will be burnt.\\n  * @param value The amount that will be burnt.\\n  */\\n  function _burnFrom(address account, uint256 value) internal {\\n    require(value <= _allowed[account][msg.sender]);\\n\\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\\n    // this function needs to emit an event with the updated approval.\\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\\n      value);\\n    _burn(account, value);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/external/LockHandler.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title ERC1132 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/1132\\n */\\n\\ncontract LockHandler {\\n  /**\\n   * @dev Reasons why a user's tokens have been locked\\n   */\\n  mapping(address => bytes32[]) public lockReason;\\n\\n  /**\\n   * @dev locked token structure\\n   */\\n  struct LockToken {\\n    uint256 amount;\\n    uint256 validity;\\n    bool claimed;\\n  }\\n\\n  /**\\n   * @dev Holds number & validity of tokens locked for a given reason for\\n   *      a specified address\\n   */\\n  mapping(address => mapping(bytes32 => LockToken)) public locked;\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/INXMMaster.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\ncontract INXMMaster {\\n\\n  address public tokenAddress;\\n\\n  address public owner;\\n\\n  uint public pauseTime;\\n\\n  function delegateCallBack(bytes32 myid) external;\\n\\n  function masterInitialized() public view returns (bool);\\n\\n  function isInternal(address _add) public view returns (bool);\\n\\n  function isPause() public view returns (bool check);\\n\\n  function isOwner(address _add) public view returns (bool);\\n\\n  function isMember(address _add) public view returns (bool);\\n\\n  function checkIsAuthToGoverned(address _add) public view returns (bool);\\n\\n  function updatePauseTime(uint _time) public;\\n\\n  function dAppLocker() public view returns (address _add);\\n\\n  function dAppToken() public view returns (address _add);\\n\\n  function getLatestAddress(bytes2 _contractName) public view returns (address payable contractAddress);\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/external/OZIERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface OZIERC20 {\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function approve(address spender, uint256 value)\\n  external returns (bool);\\n\\n  function transferFrom(address from, address to, uint256 value)\\n  external returns (bool);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n  external view returns (uint256);\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/external/OZSafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary OZSafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, reverts on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, reverts on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n  * reverts when dividing by zero.\\n  */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/claims/ClaimsReward.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\n//Claims Reward Contract contains the functions for calculating number of tokens\\n// that will get rewarded, unlocked or burned depending upon the status of claim.\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"../../interfaces/IPooledStaking.sol\\\";\\nimport \\\"../capital/Pool.sol\\\";\\nimport \\\"../cover/QuotationData.sol\\\";\\nimport \\\"../governance/Governance.sol\\\";\\nimport \\\"../token/TokenData.sol\\\";\\nimport \\\"../token/TokenFunctions.sol\\\";\\nimport \\\"./Claims.sol\\\";\\nimport \\\"./ClaimsData.sol\\\";\\nimport \\\"../capital/MCR.sol\\\";\\n\\ncontract ClaimsReward is Iupgradable {\\n  using SafeMath for uint;\\n\\n  NXMToken internal tk;\\n  TokenController internal tc;\\n  TokenData internal td;\\n  QuotationData internal qd;\\n  Claims internal c1;\\n  ClaimsData internal cd;\\n  Pool internal pool;\\n  Governance internal gv;\\n  IPooledStaking internal pooledStaking;\\n  MemberRoles internal memberRoles;\\n  MCR public mcr;\\n\\n  // assigned in constructor\\n  address public DAI;\\n\\n  // constants\\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\\n\\n  constructor (address masterAddress, address _daiAddress) public {\\n    changeMasterAddress(masterAddress);\\n    DAI = _daiAddress;\\n  }\\n\\n  function changeDependentContractAddress() public onlyInternal {\\n    c1 = Claims(ms.getLatestAddress(\\\"CL\\\"));\\n    cd = ClaimsData(ms.getLatestAddress(\\\"CD\\\"));\\n    tk = NXMToken(ms.tokenAddress());\\n    tc = TokenController(ms.getLatestAddress(\\\"TC\\\"));\\n    td = TokenData(ms.getLatestAddress(\\\"TD\\\"));\\n    qd = QuotationData(ms.getLatestAddress(\\\"QD\\\"));\\n    gv = Governance(ms.getLatestAddress(\\\"GV\\\"));\\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\\\"PS\\\"));\\n    memberRoles = MemberRoles(ms.getLatestAddress(\\\"MR\\\"));\\n    pool = Pool(ms.getLatestAddress(\\\"P1\\\"));\\n    mcr = MCR(ms.getLatestAddress(\\\"MC\\\"));\\n  }\\n\\n  /// @dev Decides the next course of action for a given claim.\\n  function changeClaimStatus(uint claimid) public checkPause onlyInternal {\\n\\n    (, uint coverid) = cd.getClaimCoverId(claimid);\\n    (, uint status) = cd.getClaimStatusNumber(claimid);\\n\\n    // when current status is \\\"Pending-Claim Assessor Vote\\\"\\n    if (status == 0) {\\n      _changeClaimStatusCA(claimid, coverid, status);\\n    } else if (status >= 1 && status <= 5) {\\n      _changeClaimStatusMV(claimid, coverid, status);\\n    } else if (status == 12) {// when current status is \\\"Claim Accepted Payout Pending\\\"\\n\\n      bool payoutSucceeded = attemptClaimPayout(coverid);\\n\\n      if (payoutSucceeded) {\\n        c1.setClaimStatus(claimid, 14);\\n      } else {\\n        c1.setClaimStatus(claimid, 12);\\n      }\\n    }\\n  }\\n\\n  function getCurrencyAssetAddress(bytes4 currency) public view returns (address) {\\n\\n    if (currency == \\\"ETH\\\") {\\n      return ETH;\\n    }\\n\\n    if (currency == \\\"DAI\\\") {\\n      return DAI;\\n    }\\n\\n    revert(\\\"ClaimsReward: unknown asset\\\");\\n  }\\n\\n  function attemptClaimPayout(uint coverId) internal returns (bool success) {\\n\\n    uint sumAssured = qd.getCoverSumAssured(coverId);\\n    // TODO: when adding new cover currencies, fetch the correct decimals for this multiplication\\n    uint sumAssuredWei = sumAssured.mul(1e18);\\n\\n    // get asset address\\n    bytes4 coverCurrency = qd.getCurrencyOfCover(coverId);\\n    address asset = getCurrencyAssetAddress(coverCurrency);\\n\\n    // get payout address\\n    address payable coverHolder = qd.getCoverMemberAddress(coverId);\\n    address payable payoutAddress = memberRoles.getClaimPayoutAddress(coverHolder);\\n\\n    // execute the payout\\n    bool payoutSucceeded = pool.sendClaimPayout(asset, payoutAddress, sumAssuredWei);\\n\\n    if (payoutSucceeded) {\\n\\n      // burn staked tokens\\n      (, address scAddress) = qd.getscAddressOfCover(coverId);\\n      uint tokenPrice = pool.getTokenPrice(asset);\\n\\n      // note: for new assets \\\"18\\\" needs to be replaced with target asset decimals\\n      uint burnNXMAmount = sumAssuredWei.mul(1e18).div(tokenPrice);\\n      pooledStaking.pushBurn(scAddress, burnNXMAmount);\\n\\n      // adjust total sum assured\\n      (, address coverContract) = qd.getscAddressOfCover(coverId);\\n      qd.subFromTotalSumAssured(coverCurrency, sumAssured);\\n      qd.subFromTotalSumAssuredSC(coverContract, coverCurrency, sumAssured);\\n\\n      // update MCR since total sum assured and MCR% change\\n      mcr.updateMCRInternal(pool.getPoolValueInEth(), true);\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  /// @dev Amount of tokens to be rewarded to a user for a particular vote id.\\n  /// @param check 1 -> CA vote, else member vote\\n  /// @param voteid vote id for which reward has to be Calculated\\n  /// @param flag if 1 calculate even if claimed,else don't calculate if already claimed\\n  /// @return tokenCalculated reward to be given for vote id\\n  /// @return lastClaimedCheck true if final verdict is still pending for that voteid\\n  /// @return tokens number of tokens locked under that voteid\\n  /// @return perc percentage of reward to be given.\\n  function getRewardToBeGiven(\\n    uint check,\\n    uint voteid,\\n    uint flag\\n  )\\n  public\\n  view\\n  returns (\\n    uint tokenCalculated,\\n    bool lastClaimedCheck,\\n    uint tokens,\\n    uint perc\\n  )\\n\\n  {\\n    uint claimId;\\n    int8 verdict;\\n    bool claimed;\\n    uint tokensToBeDist;\\n    uint totalTokens;\\n    (tokens, claimId, verdict, claimed) = cd.getVoteDetails(voteid);\\n    lastClaimedCheck = false;\\n    int8 claimVerdict = cd.getFinalVerdict(claimId);\\n    if (claimVerdict == 0) {\\n      lastClaimedCheck = true;\\n    }\\n\\n    if (claimVerdict == verdict && (claimed == false || flag == 1)) {\\n\\n      if (check == 1) {\\n        (perc, , tokensToBeDist) = cd.getClaimRewardDetail(claimId);\\n      } else {\\n        (, perc, tokensToBeDist) = cd.getClaimRewardDetail(claimId);\\n      }\\n\\n      if (perc > 0) {\\n        if (check == 1) {\\n          if (verdict == 1) {\\n            (, totalTokens,) = cd.getClaimsTokenCA(claimId);\\n          } else {\\n            (,, totalTokens) = cd.getClaimsTokenCA(claimId);\\n          }\\n        } else {\\n          if (verdict == 1) {\\n            (, totalTokens,) = cd.getClaimsTokenMV(claimId);\\n          } else {\\n            (,, totalTokens) = cd.getClaimsTokenMV(claimId);\\n          }\\n        }\\n        tokenCalculated = (perc.mul(tokens).mul(tokensToBeDist)).div(totalTokens.mul(100));\\n\\n\\n      }\\n    }\\n  }\\n\\n  /// @dev Transfers all tokens held by contract to a new contract in case of upgrade.\\n  function upgrade(address _newAdd) public onlyInternal {\\n    uint amount = tk.balanceOf(address(this));\\n    if (amount > 0) {\\n      require(tk.transfer(_newAdd, amount));\\n    }\\n\\n  }\\n\\n  /// @dev Total reward in token due for claim by a user.\\n  /// @return total total number of tokens\\n  function getRewardToBeDistributedByUser(address _add) public view returns (uint total) {\\n    uint lengthVote = cd.getVoteAddressCALength(_add);\\n    uint lastIndexCA;\\n    uint lastIndexMV;\\n    uint tokenForVoteId;\\n    uint voteId;\\n    (lastIndexCA, lastIndexMV) = cd.getRewardDistributedIndex(_add);\\n\\n    for (uint i = lastIndexCA; i < lengthVote; i++) {\\n      voteId = cd.getVoteAddressCA(_add, i);\\n      (tokenForVoteId,,,) = getRewardToBeGiven(1, voteId, 0);\\n      total = total.add(tokenForVoteId);\\n    }\\n\\n    lengthVote = cd.getVoteAddressMemberLength(_add);\\n\\n    for (uint j = lastIndexMV; j < lengthVote; j++) {\\n      voteId = cd.getVoteAddressMember(_add, j);\\n      (tokenForVoteId,,,) = getRewardToBeGiven(0, voteId, 0);\\n      total = total.add(tokenForVoteId);\\n    }\\n    return (total);\\n  }\\n\\n  /// @dev Gets reward amount and claiming status for a given claim id.\\n  /// @return reward amount of tokens to user.\\n  /// @return claimed true if already claimed false if yet to be claimed.\\n  function getRewardAndClaimedStatus(uint check, uint claimId) public view returns (uint reward, bool claimed) {\\n    uint voteId;\\n    uint claimid;\\n    uint lengthVote;\\n\\n    if (check == 1) {\\n      lengthVote = cd.getVoteAddressCALength(msg.sender);\\n      for (uint i = 0; i < lengthVote; i++) {\\n        voteId = cd.getVoteAddressCA(msg.sender, i);\\n        (, claimid, , claimed) = cd.getVoteDetails(voteId);\\n        if (claimid == claimId) {break;}\\n      }\\n    } else {\\n      lengthVote = cd.getVoteAddressMemberLength(msg.sender);\\n      for (uint j = 0; j < lengthVote; j++) {\\n        voteId = cd.getVoteAddressMember(msg.sender, j);\\n        (, claimid, , claimed) = cd.getVoteDetails(voteId);\\n        if (claimid == claimId) {break;}\\n      }\\n    }\\n    (reward,,,) = getRewardToBeGiven(check, voteId, 1);\\n\\n  }\\n\\n  /**\\n   * @dev Function used to claim all pending rewards : Claims Assessment + Risk Assessment + Governance\\n   * Claim assesment, Risk assesment, Governance rewards\\n   */\\n  function claimAllPendingReward(uint records) public isMemberAndcheckPause {\\n    _claimRewardToBeDistributed(records);\\n    pooledStaking.withdrawReward(msg.sender);\\n    uint governanceRewards = gv.claimReward(msg.sender, records);\\n    if (governanceRewards > 0) {\\n      require(tk.transfer(msg.sender, governanceRewards));\\n    }\\n  }\\n\\n  /**\\n   * @dev Function used to get pending rewards of a particular user address.\\n   * @param _add user address.\\n   * @return total reward amount of the user\\n   */\\n  function getAllPendingRewardOfUser(address _add) public view returns (uint) {\\n    uint caReward = getRewardToBeDistributedByUser(_add);\\n    uint pooledStakingReward = pooledStaking.stakerReward(_add);\\n    uint governanceReward = gv.getPendingReward(_add);\\n    return caReward.add(pooledStakingReward).add(governanceReward);\\n  }\\n\\n  /// @dev Rewards/Punishes users who  participated in Claims assessment.\\n  //    Unlocking and burning of the tokens will also depend upon the status of claim.\\n  /// @param claimid Claim Id.\\n  function _rewardAgainstClaim(uint claimid, uint coverid, uint status) internal {\\n\\n    uint premiumNXM = qd.getCoverPremiumNXM(coverid);\\n    uint distributableTokens = premiumNXM.mul(cd.claimRewardPerc()).div(100); // 20% of premium\\n\\n    uint percCA;\\n    uint percMV;\\n\\n    (percCA, percMV) = cd.getRewardStatus(status);\\n    cd.setClaimRewardDetail(claimid, percCA, percMV, distributableTokens);\\n\\n    if (percCA > 0 || percMV > 0) {\\n      tc.mint(address(this), distributableTokens);\\n    }\\n\\n    // denied\\n    if (status == 6 || status == 9 || status == 11) {\\n\\n      cd.changeFinalVerdict(claimid, -1);\\n      tc.markCoverClaimClosed(coverid, false);\\n      _burnCoverNoteDeposit(coverid);\\n\\n    // accepted\\n    } else if (status == 7 || status == 8 || status == 10) {\\n\\n      cd.changeFinalVerdict(claimid, 1);\\n      tc.markCoverClaimClosed(coverid, true);\\n      _unlockCoverNote(coverid);\\n\\n      bool payoutSucceeded = attemptClaimPayout(coverid);\\n\\n      // 12 = payout pending, 14 = payout succeeded\\n      uint nextStatus = payoutSucceeded ? 14 : 12;\\n      c1.setClaimStatus(claimid, nextStatus);\\n    }\\n  }\\n\\n  function _burnCoverNoteDeposit(uint coverId) internal {\\n\\n    address _of = qd.getCoverMemberAddress(coverId);\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, coverId));\\n    uint lockedAmount = tc.tokensLocked(_of, reason);\\n\\n    (uint amount,) = td.depositedCN(coverId);\\n    amount = amount.div(2);\\n\\n    // limit burn amount to actual amount locked\\n    uint burnAmount = lockedAmount < amount ? lockedAmount : amount;\\n\\n    if (burnAmount != 0) {\\n      tc.burnLockedTokens(_of, reason, amount);\\n    }\\n  }\\n\\n  function _unlockCoverNote(uint coverId) internal {\\n\\n    address coverHolder = qd.getCoverMemberAddress(coverId);\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", coverHolder, coverId));\\n    uint lockedCN = tc.tokensLocked(coverHolder, reason);\\n\\n    if (lockedCN != 0) {\\n      tc.releaseLockedTokens(coverHolder, reason, lockedCN);\\n    }\\n  }\\n\\n  /// @dev Computes the result of Claim Assessors Voting for a given claim id.\\n  function _changeClaimStatusCA(uint claimid, uint coverid, uint status) internal {\\n    // Check if voting should be closed or not\\n    if (c1.checkVoteClosing(claimid) == 1) {\\n      uint caTokens = c1.getCATokens(claimid, 0); // converted in cover currency.\\n      uint accept;\\n      uint deny;\\n      uint acceptAndDeny;\\n      bool rewardOrPunish;\\n      uint sumAssured;\\n      (, accept) = cd.getClaimVote(claimid, 1);\\n      (, deny) = cd.getClaimVote(claimid, - 1);\\n      acceptAndDeny = accept.add(deny);\\n      accept = accept.mul(100);\\n      deny = deny.mul(100);\\n\\n      if (caTokens == 0) {\\n        status = 3;\\n      } else {\\n        sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\\n        // Min threshold reached tokens used for voting > 5* sum assured\\n        if (caTokens > sumAssured.mul(5)) {\\n\\n          if (accept.div(acceptAndDeny) > 70) {\\n            status = 7;\\n            qd.changeCoverStatusNo(coverid, uint8(QuotationData.CoverStatus.ClaimAccepted));\\n            rewardOrPunish = true;\\n          } else if (deny.div(acceptAndDeny) > 70) {\\n            status = 6;\\n            qd.changeCoverStatusNo(coverid, uint8(QuotationData.CoverStatus.ClaimDenied));\\n            rewardOrPunish = true;\\n          } else if (accept.div(acceptAndDeny) > deny.div(acceptAndDeny)) {\\n            status = 4;\\n          } else {\\n            status = 5;\\n          }\\n\\n        } else {\\n\\n          if (accept.div(acceptAndDeny) > deny.div(acceptAndDeny)) {\\n            status = 2;\\n          } else {\\n            status = 3;\\n          }\\n        }\\n      }\\n\\n      c1.setClaimStatus(claimid, status);\\n\\n      if (rewardOrPunish) {\\n        _rewardAgainstClaim(claimid, coverid, status);\\n      }\\n    }\\n  }\\n\\n  /// @dev Computes the result of Member Voting for a given claim id.\\n  function _changeClaimStatusMV(uint claimid, uint coverid, uint status) internal {\\n\\n    // Check if voting should be closed or not\\n    if (c1.checkVoteClosing(claimid) == 1) {\\n      uint8 coverStatus;\\n      uint statusOrig = status;\\n      uint mvTokens = c1.getCATokens(claimid, 1); // converted in cover currency.\\n\\n      // If tokens used for acceptance >50%, claim is accepted\\n      uint sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\\n      uint thresholdUnreached = 0;\\n      // Minimum threshold for member voting is reached only when\\n      // value of tokens used for voting > 5* sum assured of claim id\\n      if (mvTokens < sumAssured.mul(5)) {\\n        thresholdUnreached = 1;\\n      }\\n\\n      uint accept;\\n      (, accept) = cd.getClaimMVote(claimid, 1);\\n      uint deny;\\n      (, deny) = cd.getClaimMVote(claimid, - 1);\\n\\n      if (accept.add(deny) > 0) {\\n        if (accept.mul(100).div(accept.add(deny)) >= 50 && statusOrig > 1 &&\\n        statusOrig <= 5 && thresholdUnreached == 0) {\\n          status = 8;\\n          coverStatus = uint8(QuotationData.CoverStatus.ClaimAccepted);\\n        } else if (deny.mul(100).div(accept.add(deny)) >= 50 && statusOrig > 1 &&\\n        statusOrig <= 5 && thresholdUnreached == 0) {\\n          status = 9;\\n          coverStatus = uint8(QuotationData.CoverStatus.ClaimDenied);\\n        }\\n      }\\n\\n      if (thresholdUnreached == 1 && (statusOrig == 2 || statusOrig == 4)) {\\n        status = 10;\\n        coverStatus = uint8(QuotationData.CoverStatus.ClaimAccepted);\\n      } else if (thresholdUnreached == 1 && (statusOrig == 5 || statusOrig == 3 || statusOrig == 1)) {\\n        status = 11;\\n        coverStatus = uint8(QuotationData.CoverStatus.ClaimDenied);\\n      }\\n\\n      c1.setClaimStatus(claimid, status);\\n      qd.changeCoverStatusNo(coverid, uint8(coverStatus));\\n      // Reward/Punish Claim Assessors and Members who participated in Claims assessment\\n      _rewardAgainstClaim(claimid, coverid, status);\\n    }\\n  }\\n\\n  /// @dev Allows a user to claim all pending  Claims assessment rewards.\\n  function _claimRewardToBeDistributed(uint _records) internal {\\n    uint lengthVote = cd.getVoteAddressCALength(msg.sender);\\n    uint voteid;\\n    uint lastIndex;\\n    (lastIndex,) = cd.getRewardDistributedIndex(msg.sender);\\n    uint total = 0;\\n    uint tokenForVoteId = 0;\\n    bool lastClaimedCheck;\\n    uint _days = td.lockCADays();\\n    bool claimed;\\n    uint counter = 0;\\n    uint claimId;\\n    uint perc;\\n    uint i;\\n    uint lastClaimed = lengthVote;\\n\\n    for (i = lastIndex; i < lengthVote && counter < _records; i++) {\\n      voteid = cd.getVoteAddressCA(msg.sender, i);\\n      (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\\n      if (lastClaimed == lengthVote && lastClaimedCheck == true) {\\n        lastClaimed = i;\\n      }\\n      (, claimId, , claimed) = cd.getVoteDetails(voteid);\\n\\n      if (perc > 0 && !claimed) {\\n        counter++;\\n        cd.setRewardClaimed(voteid, true);\\n      } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\\n        (perc,,) = cd.getClaimRewardDetail(claimId);\\n        if (perc == 0) {\\n          counter++;\\n        }\\n        cd.setRewardClaimed(voteid, true);\\n      }\\n      if (tokenForVoteId > 0) {\\n        total = tokenForVoteId.add(total);\\n      }\\n    }\\n    if (lastClaimed == lengthVote) {\\n      cd.setRewardDistributedIndexCA(msg.sender, i);\\n    }\\n    else {\\n      cd.setRewardDistributedIndexCA(msg.sender, lastClaimed);\\n    }\\n    lengthVote = cd.getVoteAddressMemberLength(msg.sender);\\n    lastClaimed = lengthVote;\\n    _days = _days.mul(counter);\\n    if (tc.tokensLockedAtTime(msg.sender, \\\"CLA\\\", now) > 0) {\\n      tc.reduceLock(msg.sender, \\\"CLA\\\", _days);\\n    }\\n    (, lastIndex) = cd.getRewardDistributedIndex(msg.sender);\\n    lastClaimed = lengthVote;\\n    counter = 0;\\n    for (i = lastIndex; i < lengthVote && counter < _records; i++) {\\n      voteid = cd.getVoteAddressMember(msg.sender, i);\\n      (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);\\n      if (lastClaimed == lengthVote && lastClaimedCheck == true) {\\n        lastClaimed = i;\\n      }\\n      (, claimId, , claimed) = cd.getVoteDetails(voteid);\\n      if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\\n        cd.setRewardClaimed(voteid, true);\\n        counter++;\\n      }\\n      if (tokenForVoteId > 0) {\\n        total = tokenForVoteId.add(total);\\n      }\\n    }\\n    if (total > 0) {\\n      require(tk.transfer(msg.sender, total));\\n    }\\n    if (lastClaimed == lengthVote) {\\n      cd.setRewardDistributedIndexMV(msg.sender, i);\\n    }\\n    else {\\n      cd.setRewardDistributedIndexMV(msg.sender, lastClaimed);\\n    }\\n  }\\n\\n  /**\\n   * @dev Function used to claim the commission earned by the staker.\\n   */\\n  function _claimStakeCommission(uint _records, address _user) external onlyInternal {\\n    uint total = 0;\\n    uint len = td.getStakerStakedContractLength(_user);\\n    uint lastCompletedStakeCommission = td.lastCompletedStakeCommission(_user);\\n    uint commissionEarned;\\n    uint commissionRedeemed;\\n    uint maxCommission;\\n    uint lastCommisionRedeemed = len;\\n    uint counter;\\n    uint i;\\n\\n    for (i = lastCompletedStakeCommission; i < len && counter < _records; i++) {\\n      commissionRedeemed = td.getStakerRedeemedStakeCommission(_user, i);\\n      commissionEarned = td.getStakerEarnedStakeCommission(_user, i);\\n      maxCommission = td.getStakerInitialStakedAmountOnContract(\\n        _user, i).mul(td.stakerMaxCommissionPer()).div(100);\\n      if (lastCommisionRedeemed == len && maxCommission != commissionEarned)\\n        lastCommisionRedeemed = i;\\n      td.pushRedeemedStakeCommissions(_user, i, commissionEarned.sub(commissionRedeemed));\\n      total = total.add(commissionEarned.sub(commissionRedeemed));\\n      counter++;\\n    }\\n    if (lastCommisionRedeemed == len) {\\n      td.setLastCompletedStakeCommissionIndex(_user, i);\\n    } else {\\n      td.setLastCompletedStakeCommissionIndex(_user, lastCommisionRedeemed);\\n    }\\n\\n    if (total > 0)\\n      require(tk.transfer(_user, total)); // solhint-disable-line\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/cover/QuotationData.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\n\\ncontract QuotationData is Iupgradable {\\n  using SafeMath for uint;\\n\\n  enum HCIDStatus {NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover}\\n\\n  enum CoverStatus {Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested}\\n\\n  struct Cover {\\n    address payable memberAddress;\\n    bytes4 currencyCode;\\n    uint sumAssured;\\n    uint16 coverPeriod;\\n    uint validUntil;\\n    address scAddress;\\n    uint premiumNXM;\\n  }\\n\\n  struct HoldCover {\\n    uint holdCoverId;\\n    address payable userAddress;\\n    address scAddress;\\n    bytes4 coverCurr;\\n    uint[] coverDetails;\\n    uint16 coverPeriod;\\n  }\\n\\n  address public authQuoteEngine;\\n\\n  mapping(bytes4 => uint) internal currencyCSA;\\n  mapping(address => uint[]) internal userCover;\\n  mapping(address => uint[]) public userHoldedCover;\\n  mapping(address => bool) public refundEligible;\\n  mapping(address => mapping(bytes4 => uint)) internal currencyCSAOfSCAdd;\\n  mapping(uint => uint8) public coverStatus;\\n  mapping(uint => uint) public holdedCoverIDStatus;\\n  mapping(uint => bool) public timestampRepeated;\\n\\n\\n  Cover[] internal allCovers;\\n  HoldCover[] internal allCoverHolded;\\n\\n  uint public stlp;\\n  uint public stl;\\n  uint public pm;\\n  uint public minDays;\\n  uint public tokensRetained;\\n  address public kycAuthAddress;\\n\\n  event CoverDetailsEvent(\\n    uint indexed cid,\\n    address scAdd,\\n    uint sumAssured,\\n    uint expiry,\\n    uint premium,\\n    uint premiumNXM,\\n    bytes4 curr\\n  );\\n\\n  event CoverStatusEvent(uint indexed cid, uint8 statusNum);\\n\\n  constructor(address _authQuoteAdd, address _kycAuthAdd) public {\\n    authQuoteEngine = _authQuoteAdd;\\n    kycAuthAddress = _kycAuthAdd;\\n    stlp = 90;\\n    stl = 100;\\n    pm = 30;\\n    minDays = 30;\\n    tokensRetained = 10;\\n    allCovers.push(Cover(address(0), \\\"0x00\\\", 0, 0, 0, address(0), 0));\\n    uint[] memory arr = new uint[](1);\\n    allCoverHolded.push(HoldCover(0, address(0), address(0), 0x00, arr, 0));\\n\\n  }\\n\\n  /// @dev Adds the amount in Total Sum Assured of a given currency of a given smart contract address.\\n  /// @param _add Smart Contract Address.\\n  /// @param _amount Amount to be added.\\n  function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\\n    currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].add(_amount);\\n  }\\n\\n  /// @dev Subtracts the amount from Total Sum Assured of a given currency and smart contract address.\\n  /// @param _add Smart Contract Address.\\n  /// @param _amount Amount to be subtracted.\\n  function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\\n    currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].sub(_amount);\\n  }\\n\\n  /// @dev Subtracts the amount from Total Sum Assured of a given currency.\\n  /// @param _curr Currency Name.\\n  /// @param _amount Amount to be subtracted.\\n  function subFromTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\\n    currencyCSA[_curr] = currencyCSA[_curr].sub(_amount);\\n  }\\n\\n  /// @dev Adds the amount in Total Sum Assured of a given currency.\\n  /// @param _curr Currency Name.\\n  /// @param _amount Amount to be added.\\n  function addInTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\\n    currencyCSA[_curr] = currencyCSA[_curr].add(_amount);\\n  }\\n\\n  /// @dev sets bit for timestamp to avoid replay attacks.\\n  function setTimestampRepeated(uint _timestamp) external onlyInternal {\\n    timestampRepeated[_timestamp] = true;\\n  }\\n\\n  /// @dev Creates a blank new cover.\\n  function addCover(\\n    uint16 _coverPeriod,\\n    uint _sumAssured,\\n    address payable _userAddress,\\n    bytes4 _currencyCode,\\n    address _scAddress,\\n    uint premium,\\n    uint premiumNXM\\n  )\\n  external\\n  onlyInternal\\n  {\\n    uint expiryDate = now.add(uint(_coverPeriod).mul(1 days));\\n    allCovers.push(Cover(_userAddress, _currencyCode,\\n      _sumAssured, _coverPeriod, expiryDate, _scAddress, premiumNXM));\\n    uint cid = allCovers.length.sub(1);\\n    userCover[_userAddress].push(cid);\\n    emit CoverDetailsEvent(cid, _scAddress, _sumAssured, expiryDate, premium, premiumNXM, _currencyCode);\\n  }\\n\\n  /// @dev create holded cover which will process after verdict of KYC.\\n  function addHoldCover(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod\\n  )\\n  external\\n  onlyInternal\\n  {\\n    uint holdedCoverLen = allCoverHolded.length;\\n    holdedCoverIDStatus[holdedCoverLen] = uint(HCIDStatus.kycPending);\\n    allCoverHolded.push(HoldCover(holdedCoverLen, from, scAddress,\\n      coverCurr, coverDetails, coverPeriod));\\n    userHoldedCover[from].push(allCoverHolded.length.sub(1));\\n\\n  }\\n\\n  ///@dev sets refund eligible bit.\\n  ///@param _add user address.\\n  ///@param status indicates if user have pending kyc.\\n  function setRefundEligible(address _add, bool status) external onlyInternal {\\n    refundEligible[_add] = status;\\n  }\\n\\n  /// @dev to set current status of particular holded coverID (1 for not completed KYC,\\n  /// 2 for KYC passed, 3 for failed KYC or full refunded,\\n  /// 4 for KYC completed but cover not processed)\\n  function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external onlyInternal {\\n    holdedCoverIDStatus[holdedCoverID] = status;\\n  }\\n\\n  /**\\n   * @dev to set address of kyc authentication\\n   * @param _add is the new address\\n   */\\n  function setKycAuthAddress(address _add) external onlyInternal {\\n    kycAuthAddress = _add;\\n  }\\n\\n  /// @dev Changes authorised address for generating quote off chain.\\n  function changeAuthQuoteEngine(address _add) external onlyInternal {\\n    authQuoteEngine = _add;\\n  }\\n\\n  /**\\n   * @dev Gets Uint Parameters of a code\\n   * @param code whose details we want\\n   * @return string value of the code\\n   * @return associated amount (time or perc or value) to the code\\n   */\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\\n    codeVal = code;\\n\\n    if (code == \\\"STLP\\\") {\\n      val = stlp;\\n\\n    } else if (code == \\\"STL\\\") {\\n\\n      val = stl;\\n\\n    } else if (code == \\\"PM\\\") {\\n\\n      val = pm;\\n\\n    } else if (code == \\\"QUOMIND\\\") {\\n\\n      val = minDays;\\n\\n    } else if (code == \\\"QUOTOK\\\") {\\n\\n      val = tokensRetained;\\n\\n    }\\n\\n  }\\n\\n  /// @dev Gets Product details.\\n  /// @return  _minDays minimum cover period.\\n  /// @return  _PM Profit margin.\\n  /// @return  _STL short term Load.\\n  /// @return  _STLP short term load period.\\n  function getProductDetails()\\n  external\\n  view\\n  returns (\\n    uint _minDays,\\n    uint _pm,\\n    uint _stl,\\n    uint _stlp\\n  )\\n  {\\n\\n    _minDays = minDays;\\n    _pm = pm;\\n    _stl = stl;\\n    _stlp = stlp;\\n  }\\n\\n  /// @dev Gets total number covers created till date.\\n  function getCoverLength() external view returns (uint len) {\\n    return (allCovers.length);\\n  }\\n\\n  /// @dev Gets Authorised Engine address.\\n  function getAuthQuoteEngine() external view returns (address _add) {\\n    _add = authQuoteEngine;\\n  }\\n\\n  /// @dev Gets the Total Sum Assured amount of a given currency.\\n  function getTotalSumAssured(bytes4 _curr) external view returns (uint amount) {\\n    amount = currencyCSA[_curr];\\n  }\\n\\n  /// @dev Gets all the Cover ids generated by a given address.\\n  /// @param _add User's address.\\n  /// @return allCover array of covers.\\n  function getAllCoversOfUser(address _add) external view returns (uint[] memory allCover) {\\n    return (userCover[_add]);\\n  }\\n\\n  /// @dev Gets total number of covers generated by a given address\\n  function getUserCoverLength(address _add) external view returns (uint len) {\\n    len = userCover[_add].length;\\n  }\\n\\n  /// @dev Gets the status of a given cover.\\n  function getCoverStatusNo(uint _cid) external view returns (uint8) {\\n    return coverStatus[_cid];\\n  }\\n\\n  /// @dev Gets the Cover Period (in days) of a given cover.\\n  function getCoverPeriod(uint _cid) external view returns (uint32 cp) {\\n    cp = allCovers[_cid].coverPeriod;\\n  }\\n\\n  /// @dev Gets the Sum Assured Amount of a given cover.\\n  function getCoverSumAssured(uint _cid) external view returns (uint sa) {\\n    sa = allCovers[_cid].sumAssured;\\n  }\\n\\n  /// @dev Gets the Currency Name in which a given cover is assured.\\n  function getCurrencyOfCover(uint _cid) external view returns (bytes4 curr) {\\n    curr = allCovers[_cid].currencyCode;\\n  }\\n\\n  /// @dev Gets the validity date (timestamp) of a given cover.\\n  function getValidityOfCover(uint _cid) external view returns (uint date) {\\n    date = allCovers[_cid].validUntil;\\n  }\\n\\n  /// @dev Gets Smart contract address of cover.\\n  function getscAddressOfCover(uint _cid) external view returns (uint, address) {\\n    return (_cid, allCovers[_cid].scAddress);\\n  }\\n\\n  /// @dev Gets the owner address of a given cover.\\n  function getCoverMemberAddress(uint _cid) external view returns (address payable _add) {\\n    _add = allCovers[_cid].memberAddress;\\n  }\\n\\n  /// @dev Gets the premium amount of a given cover in NXM.\\n  function getCoverPremiumNXM(uint _cid) external view returns (uint _premiumNXM) {\\n    _premiumNXM = allCovers[_cid].premiumNXM;\\n  }\\n\\n  /// @dev Provides the details of a cover Id\\n  /// @param _cid cover Id\\n  /// @return memberAddress cover user address.\\n  /// @return scAddress smart contract Address\\n  /// @return currencyCode currency of cover\\n  /// @return sumAssured sum assured of cover\\n  /// @return premiumNXM premium in NXM\\n  function getCoverDetailsByCoverID1(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    address _memberAddress,\\n    address _scAddress,\\n    bytes4 _currencyCode,\\n    uint _sumAssured,\\n    uint premiumNXM\\n  )\\n  {\\n    return (\\n    _cid,\\n    allCovers[_cid].memberAddress,\\n    allCovers[_cid].scAddress,\\n    allCovers[_cid].currencyCode,\\n    allCovers[_cid].sumAssured,\\n    allCovers[_cid].premiumNXM\\n    );\\n  }\\n\\n  /// @dev Provides details of a cover Id\\n  /// @param _cid cover Id\\n  /// @return status status of cover.\\n  /// @return sumAssured Sum assurance of cover.\\n  /// @return coverPeriod Cover Period of cover (in days).\\n  /// @return validUntil is validity of cover.\\n  function getCoverDetailsByCoverID2(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    uint8 status,\\n    uint sumAssured,\\n    uint16 coverPeriod,\\n    uint validUntil\\n  )\\n  {\\n\\n    return (\\n    _cid,\\n    coverStatus[_cid],\\n    allCovers[_cid].sumAssured,\\n    allCovers[_cid].coverPeriod,\\n    allCovers[_cid].validUntil\\n    );\\n  }\\n\\n  /// @dev Provides details of a holded cover Id\\n  /// @param _hcid holded cover Id\\n  /// @return scAddress SmartCover address of cover.\\n  /// @return coverCurr currency of cover.\\n  /// @return coverPeriod Cover Period of cover (in days).\\n  function getHoldedCoverDetailsByID1(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint16 coverPeriod\\n  )\\n  {\\n    return (\\n    _hcid,\\n    allCoverHolded[_hcid].scAddress,\\n    allCoverHolded[_hcid].coverCurr,\\n    allCoverHolded[_hcid].coverPeriod\\n    );\\n  }\\n\\n  /// @dev Gets total number holded covers created till date.\\n  function getUserHoldedCoverLength(address _add) external view returns (uint) {\\n    return userHoldedCover[_add].length;\\n  }\\n\\n  /// @dev Gets holded cover index by index of user holded covers.\\n  function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint) {\\n    return userHoldedCover[_add][index];\\n  }\\n\\n  /// @dev Provides the details of a holded cover Id\\n  /// @param _hcid holded cover Id\\n  /// @return memberAddress holded cover user address.\\n  /// @return coverDetails array contains SA, Cover Currency Price,Price in NXM, Expiration time of Qoute.\\n  function getHoldedCoverDetailsByID2(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address payable memberAddress,\\n    uint[] memory coverDetails\\n  )\\n  {\\n    return (\\n    _hcid,\\n    allCoverHolded[_hcid].userAddress,\\n    allCoverHolded[_hcid].coverDetails\\n    );\\n  }\\n\\n  /// @dev Gets the Total Sum Assured amount of a given currency and smart contract address.\\n  function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns (uint amount) {\\n    amount = currencyCSAOfSCAdd[_add][_curr];\\n  }\\n\\n  //solhint-disable-next-line\\n  function changeDependentContractAddress() public {}\\n\\n  /// @dev Changes the status of a given cover.\\n  /// @param _cid cover Id.\\n  /// @param _stat New status.\\n  function changeCoverStatusNo(uint _cid, uint8 _stat) public onlyInternal {\\n    coverStatus[_cid] = _stat;\\n    emit CoverStatusEvent(_cid, _stat);\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param val value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"STLP\\\") {\\n      _changeSTLP(val);\\n\\n    } else if (code == \\\"STL\\\") {\\n\\n      _changeSTL(val);\\n\\n    } else if (code == \\\"PM\\\") {\\n\\n      _changePM(val);\\n\\n    } else if (code == \\\"QUOMIND\\\") {\\n\\n      _changeMinDays(val);\\n\\n    } else if (code == \\\"QUOTOK\\\") {\\n\\n      _setTokensRetained(val);\\n\\n    } else {\\n\\n      revert(\\\"Invalid param code\\\");\\n    }\\n\\n  }\\n\\n  /// @dev Changes the existing Profit Margin value\\n  function _changePM(uint _pm) internal {\\n    pm = _pm;\\n  }\\n\\n  /// @dev Changes the existing Short Term Load Period (STLP) value.\\n  function _changeSTLP(uint _stlp) internal {\\n    stlp = _stlp;\\n  }\\n\\n  /// @dev Changes the existing Short Term Load (STL) value.\\n  function _changeSTL(uint _stl) internal {\\n    stl = _stl;\\n  }\\n\\n  /// @dev Changes the existing Minimum cover period (in days)\\n  function _changeMinDays(uint _days) internal {\\n    minDays = _days;\\n  }\\n\\n  /**\\n   * @dev to set the the amount of tokens retained\\n   * @param val is the amount retained\\n   */\\n  function _setTokensRetained(uint val) internal {\\n    tokensRetained = val;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/TokenData.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\n\\ncontract TokenData is Iupgradable {\\n  using SafeMath for uint;\\n\\n  address payable public walletAddress;\\n  uint public lockTokenTimeAfterCoverExp;\\n  uint public bookTime;\\n  uint public lockCADays;\\n  uint public lockMVDays;\\n  uint public scValidDays;\\n  uint public joiningFee;\\n  uint public stakerCommissionPer;\\n  uint public stakerMaxCommissionPer;\\n  uint public tokenExponent;\\n  uint public priceStep;\\n\\n  struct StakeCommission {\\n    uint commissionEarned;\\n    uint commissionRedeemed;\\n  }\\n\\n  struct Stake {\\n    address stakedContractAddress;\\n    uint stakedContractIndex;\\n    uint dateAdd;\\n    uint stakeAmount;\\n    uint unlockedAmount;\\n    uint burnedAmount;\\n    uint unLockableBeforeLastBurn;\\n  }\\n\\n  struct Staker {\\n    address stakerAddress;\\n    uint stakerIndex;\\n  }\\n\\n  struct CoverNote {\\n    uint amount;\\n    bool isDeposited;\\n  }\\n\\n  /**\\n   * @dev mapping of uw address to array of sc address to fetch\\n   * all staked contract address of underwriter, pushing\\n   * data into this array of Stake returns stakerIndex\\n   */\\n  mapping(address => Stake[]) public stakerStakedContracts;\\n\\n  /**\\n   * @dev mapping of sc address to array of UW address to fetch\\n   * all underwritters of the staked smart contract\\n   * pushing data into this mapped array returns scIndex\\n   */\\n  mapping(address => Staker[]) public stakedContractStakers;\\n\\n  /**\\n   * @dev mapping of staked contract Address to the array of StakeCommission\\n   * here index of this array is stakedContractIndex\\n   */\\n  mapping(address => mapping(uint => StakeCommission)) public stakedContractStakeCommission;\\n\\n  mapping(address => uint) public lastCompletedStakeCommission;\\n\\n  /**\\n   * @dev mapping of the staked contract address to the current\\n   * staker index who will receive commission.\\n   */\\n  mapping(address => uint) public stakedContractCurrentCommissionIndex;\\n\\n  /**\\n   * @dev mapping of the staked contract address to the\\n   * current staker index to burn token from.\\n   */\\n  mapping(address => uint) public stakedContractCurrentBurnIndex;\\n\\n  /**\\n   * @dev mapping to return true if Cover Note deposited against coverId\\n   */\\n  mapping(uint => CoverNote) public depositedCN;\\n\\n  mapping(address => uint) internal isBookedTokens;\\n\\n  event Commission(\\n    address indexed stakedContractAddress,\\n    address indexed stakerAddress,\\n    uint indexed scIndex,\\n    uint commissionAmount\\n  );\\n\\n  constructor(address payable _walletAdd) public {\\n    walletAddress = _walletAdd;\\n    bookTime = 12 hours;\\n    joiningFee = 2000000000000000; // 0.002 Ether\\n    lockTokenTimeAfterCoverExp = 35 days;\\n    scValidDays = 250;\\n    lockCADays = 7 days;\\n    lockMVDays = 2 days;\\n    stakerCommissionPer = 20;\\n    stakerMaxCommissionPer = 50;\\n    tokenExponent = 4;\\n    priceStep = 1000;\\n  }\\n\\n  /**\\n   * @dev Change the wallet address which receive Joining Fee\\n   */\\n  function changeWalletAddress(address payable _address) external onlyInternal {\\n    walletAddress = _address;\\n  }\\n\\n  /**\\n   * @dev Gets Uint Parameters of a code\\n   * @param code whose details we want\\n   * @return string value of the code\\n   * @return associated amount (time or perc or value) to the code\\n   */\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\\n    codeVal = code;\\n    if (code == \\\"TOKEXP\\\") {\\n\\n      val = tokenExponent;\\n\\n    } else if (code == \\\"TOKSTEP\\\") {\\n\\n      val = priceStep;\\n\\n    } else if (code == \\\"RALOCKT\\\") {\\n\\n      val = scValidDays;\\n\\n    } else if (code == \\\"RACOMM\\\") {\\n\\n      val = stakerCommissionPer;\\n\\n    } else if (code == \\\"RAMAXC\\\") {\\n\\n      val = stakerMaxCommissionPer;\\n\\n    } else if (code == \\\"CABOOKT\\\") {\\n\\n      val = bookTime / (1 hours);\\n\\n    } else if (code == \\\"CALOCKT\\\") {\\n\\n      val = lockCADays / (1 days);\\n\\n    } else if (code == \\\"MVLOCKT\\\") {\\n\\n      val = lockMVDays / (1 days);\\n\\n    } else if (code == \\\"QUOLOCKT\\\") {\\n\\n      val = lockTokenTimeAfterCoverExp / (1 days);\\n\\n    } else if (code == \\\"JOINFEE\\\") {\\n\\n      val = joiningFee;\\n\\n    }\\n  }\\n\\n  /**\\n  * @dev Just for interface\\n  */\\n  function changeDependentContractAddress() public {//solhint-disable-line\\n  }\\n\\n  /**\\n   * @dev to get the contract staked by a staker\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return the address of staked contract\\n   */\\n  function getStakerStakedContractByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (address stakedContractAddress)\\n  {\\n    stakedContractAddress = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractAddress;\\n  }\\n\\n  /**\\n   * @dev to get the staker's staked burned\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return amount burned\\n   */\\n  function getStakerStakedBurnedByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint burnedAmount)\\n  {\\n    burnedAmount = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].burnedAmount;\\n  }\\n\\n  /**\\n   * @dev to get the staker's staked unlockable before the last burn\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return unlockable staked tokens\\n   */\\n  function getStakerStakedUnlockableBeforeLastBurnByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint unlockable)\\n  {\\n    unlockable = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].unLockableBeforeLastBurn;\\n  }\\n\\n  /**\\n   * @dev to get the staker's staked contract index\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return is the index of the smart contract address\\n   */\\n  function getStakerStakedContractIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint scIndex)\\n  {\\n    scIndex = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractIndex;\\n  }\\n\\n  /**\\n   * @dev to get the staker index of the staked contract\\n   * @param _stakedContractAddress is the address of the staked contract\\n   * @param _stakedContractIndex is the index of staked contract\\n   * @return is the index of the staker\\n   */\\n  function getStakedContractStakerIndex(\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex\\n  )\\n  public\\n  view\\n  returns (uint sIndex)\\n  {\\n    sIndex = stakedContractStakers[\\n    _stakedContractAddress][_stakedContractIndex].stakerIndex;\\n  }\\n\\n  /**\\n   * @dev to get the staker's initial staked amount on the contract\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return staked amount\\n   */\\n  function getStakerInitialStakedAmountOnContract(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint amount)\\n  {\\n    amount = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakeAmount;\\n  }\\n\\n  /**\\n   * @dev to get the staker's staked contract length\\n   * @param _stakerAddress is the address of the staker\\n   * @return length of staked contract\\n   */\\n  function getStakerStakedContractLength(\\n    address _stakerAddress\\n  )\\n  public\\n  view\\n  returns (uint length)\\n  {\\n    length = stakerStakedContracts[_stakerAddress].length;\\n  }\\n\\n  /**\\n   * @dev to get the staker's unlocked tokens which were staked\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return amount\\n   */\\n  function getStakerUnlockedStakedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint amount)\\n  {\\n    amount = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].unlockedAmount;\\n  }\\n\\n  /**\\n   * @dev pushes the unlocked staked tokens by a staker.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker to distribute commission.\\n   * @param _amount amount to be given as commission.\\n   */\\n  function pushUnlockedStakedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unlockedAmount = stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unlockedAmount.add(_amount);\\n  }\\n\\n  /**\\n   * @dev pushes the Burned tokens for a staker.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker.\\n   * @param _amount amount to be burned.\\n   */\\n  function pushBurnedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].burnedAmount = stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].burnedAmount.add(_amount);\\n  }\\n\\n  /**\\n   * @dev pushes the unLockable tokens for a staker before last burn.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker.\\n   * @param _amount amount to be added to unlockable.\\n   */\\n  function pushUnlockableBeforeLastBurnTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unLockableBeforeLastBurn = stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unLockableBeforeLastBurn.add(_amount);\\n  }\\n\\n  /**\\n   * @dev sets the unLockable tokens for a staker before last burn.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker.\\n   * @param _amount amount to be added to unlockable.\\n   */\\n  function setUnlockableBeforeLastBurnTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unLockableBeforeLastBurn = _amount;\\n  }\\n\\n  /**\\n   * @dev pushes the earned commission earned by a staker.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakedContractAddress address of smart contract.\\n   * @param _stakedContractIndex index of the staker to distribute commission.\\n   * @param _commissionAmount amount to be given as commission.\\n   */\\n  function pushEarnedStakeCommissions(\\n    address _stakerAddress,\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex,\\n    uint _commissionAmount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakedContractStakeCommission[_stakedContractAddress][_stakedContractIndex].\\n    commissionEarned = stakedContractStakeCommission[_stakedContractAddress][\\n    _stakedContractIndex].commissionEarned.add(_commissionAmount);\\n\\n    emit Commission(\\n      _stakerAddress,\\n      _stakedContractAddress,\\n      _stakedContractIndex,\\n      _commissionAmount\\n    );\\n  }\\n\\n  /**\\n   * @dev pushes the redeemed commission redeemed by a staker.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker to distribute commission.\\n   * @param _amount amount to be given as commission.\\n   */\\n  function pushRedeemedStakeCommissions(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    uint stakedContractIndex = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractIndex;\\n    address stakedContractAddress = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractAddress;\\n    stakedContractStakeCommission[stakedContractAddress][stakedContractIndex].\\n    commissionRedeemed = stakedContractStakeCommission[\\n    stakedContractAddress][stakedContractIndex].commissionRedeemed.add(_amount);\\n  }\\n\\n  /**\\n   * @dev Gets stake commission given to an underwriter\\n   * for particular stakedcontract on given index.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker commission.\\n   */\\n  function getStakerEarnedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint)\\n  {\\n    return _getStakerEarnedStakeCommission(_stakerAddress, _stakerIndex);\\n  }\\n\\n  /**\\n   * @dev Gets stake commission redeemed by an underwriter\\n   * for particular staked contract on given index.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker commission.\\n   * @return commissionEarned total amount given to staker.\\n   */\\n  function getStakerRedeemedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint)\\n  {\\n    return _getStakerRedeemedStakeCommission(_stakerAddress, _stakerIndex);\\n  }\\n\\n  /**\\n   * @dev Gets total stake commission given to an underwriter\\n   * @param _stakerAddress address of staker.\\n   * @return totalCommissionEarned total commission earned by staker.\\n   */\\n  function getStakerTotalEarnedStakeCommission(\\n    address _stakerAddress\\n  )\\n  public\\n  view\\n  returns (uint totalCommissionEarned)\\n  {\\n    totalCommissionEarned = 0;\\n    for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {\\n      totalCommissionEarned = totalCommissionEarned.\\n      add(_getStakerEarnedStakeCommission(_stakerAddress, i));\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets total stake commission given to an underwriter\\n   * @param _stakerAddress address of staker.\\n   * @return totalCommissionEarned total commission earned by staker.\\n   */\\n  function getStakerTotalReedmedStakeCommission(\\n    address _stakerAddress\\n  )\\n  public\\n  view\\n  returns (uint totalCommissionRedeemed)\\n  {\\n    totalCommissionRedeemed = 0;\\n    for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {\\n      totalCommissionRedeemed = totalCommissionRedeemed.add(\\n        _getStakerRedeemedStakeCommission(_stakerAddress, i));\\n    }\\n  }\\n\\n  /**\\n   * @dev set flag to deposit/ undeposit cover note\\n   * against a cover Id\\n   * @param coverId coverId of Cover\\n   * @param flag true/false for deposit/undeposit\\n   */\\n  function setDepositCN(uint coverId, bool flag) public onlyInternal {\\n\\n    if (flag == true) {\\n      require(!depositedCN[coverId].isDeposited, \\\"Cover note already deposited\\\");\\n    }\\n\\n    depositedCN[coverId].isDeposited = flag;\\n  }\\n\\n  /**\\n   * @dev set locked cover note amount\\n   * against a cover Id\\n   * @param coverId coverId of Cover\\n   * @param amount amount of nxm to be locked\\n   */\\n  function setDepositCNAmount(uint coverId, uint amount) public onlyInternal {\\n\\n    depositedCN[coverId].amount = amount;\\n  }\\n\\n  /**\\n   * @dev to get the staker address on a staked contract\\n   * @param _stakedContractAddress is the address of the staked contract in concern\\n   * @param _stakedContractIndex is the index of staked contract's index\\n   * @return address of staker\\n   */\\n  function getStakedContractStakerByIndex(\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex\\n  )\\n  public\\n  view\\n  returns (address stakerAddress)\\n  {\\n    stakerAddress = stakedContractStakers[\\n    _stakedContractAddress][_stakedContractIndex].stakerAddress;\\n  }\\n\\n  /**\\n   * @dev to get the length of stakers on a staked contract\\n   * @param _stakedContractAddress is the address of the staked contract in concern\\n   * @return length in concern\\n   */\\n  function getStakedContractStakersLength(\\n    address _stakedContractAddress\\n  )\\n  public\\n  view\\n  returns (uint length)\\n  {\\n    length = stakedContractStakers[_stakedContractAddress].length;\\n  }\\n\\n  /**\\n   * @dev Adds a new stake record.\\n   * @param _stakerAddress staker address.\\n   * @param _stakedContractAddress smart contract address.\\n   * @param _amount amountof NXM to be staked.\\n   */\\n  function addStake(\\n    address _stakerAddress,\\n    address _stakedContractAddress,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  returns (uint scIndex)\\n  {\\n    scIndex = (stakedContractStakers[_stakedContractAddress].push(\\n      Staker(_stakerAddress, stakerStakedContracts[_stakerAddress].length))).sub(1);\\n    stakerStakedContracts[_stakerAddress].push(\\n      Stake(_stakedContractAddress, scIndex, now, _amount, 0, 0, 0));\\n  }\\n\\n  /**\\n   * @dev books the user's tokens for maintaining Assessor Velocity,\\n   * i.e. once a token is used to cast a vote as a Claims assessor,\\n   * @param _of user's address.\\n   */\\n  function bookCATokens(address _of) public onlyInternal {\\n    require(!isCATokensBooked(_of), \\\"Tokens already booked\\\");\\n    isBookedTokens[_of] = now.add(bookTime);\\n  }\\n\\n  /**\\n   * @dev to know if claim assessor's tokens are booked or not\\n   * @param _of is the claim assessor's address in concern\\n   * @return boolean representing the status of tokens booked\\n   */\\n  function isCATokensBooked(address _of) public view returns (bool res) {\\n    if (now < isBookedTokens[_of])\\n      res = true;\\n  }\\n\\n  /**\\n   * @dev Sets the index which will receive commission.\\n   * @param _stakedContractAddress smart contract address.\\n   * @param _index current index.\\n   */\\n  function setStakedContractCurrentCommissionIndex(\\n    address _stakedContractAddress,\\n    uint _index\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakedContractCurrentCommissionIndex[_stakedContractAddress] = _index;\\n  }\\n\\n  /**\\n   * @dev Sets the last complete commission index\\n   * @param _stakerAddress smart contract address.\\n   * @param _index current index.\\n   */\\n  function setLastCompletedStakeCommissionIndex(\\n    address _stakerAddress,\\n    uint _index\\n  )\\n  public\\n  onlyInternal\\n  {\\n    lastCompletedStakeCommission[_stakerAddress] = _index;\\n  }\\n\\n  /**\\n   * @dev Sets the index till which commission is distrubuted.\\n   * @param _stakedContractAddress smart contract address.\\n   * @param _index current index.\\n   */\\n  function setStakedContractCurrentBurnIndex(\\n    address _stakedContractAddress,\\n    uint _index\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakedContractCurrentBurnIndex[_stakedContractAddress] = _index;\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param val value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"TOKEXP\\\") {\\n\\n      _setTokenExponent(val);\\n\\n    } else if (code == \\\"TOKSTEP\\\") {\\n\\n      _setPriceStep(val);\\n\\n    } else if (code == \\\"RALOCKT\\\") {\\n\\n      _changeSCValidDays(val);\\n\\n    } else if (code == \\\"RACOMM\\\") {\\n\\n      _setStakerCommissionPer(val);\\n\\n    } else if (code == \\\"RAMAXC\\\") {\\n\\n      _setStakerMaxCommissionPer(val);\\n\\n    } else if (code == \\\"CABOOKT\\\") {\\n\\n      _changeBookTime(val * 1 hours);\\n\\n    } else if (code == \\\"CALOCKT\\\") {\\n\\n      _changelockCADays(val * 1 days);\\n\\n    } else if (code == \\\"MVLOCKT\\\") {\\n\\n      _changelockMVDays(val * 1 days);\\n\\n    } else if (code == \\\"QUOLOCKT\\\") {\\n\\n      _setLockTokenTimeAfterCoverExp(val * 1 days);\\n\\n    } else if (code == \\\"JOINFEE\\\") {\\n\\n      _setJoiningFee(val);\\n\\n    } else {\\n      revert(\\\"Invalid param code\\\");\\n    }\\n  }\\n\\n  /**\\n   * @dev Internal function to get stake commission given to an\\n   * underwriter for particular stakedcontract on given index.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker commission.\\n   */\\n  function _getStakerEarnedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  internal\\n  view\\n  returns (uint amount)\\n  {\\n    uint _stakedContractIndex;\\n    address _stakedContractAddress;\\n    _stakedContractAddress = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractAddress;\\n    _stakedContractIndex = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractIndex;\\n    amount = stakedContractStakeCommission[\\n    _stakedContractAddress][_stakedContractIndex].commissionEarned;\\n  }\\n\\n  /**\\n   * @dev Internal function to get stake commission redeemed by an\\n   * underwriter for particular stakedcontract on given index.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker commission.\\n   */\\n  function _getStakerRedeemedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  internal\\n  view\\n  returns (uint amount)\\n  {\\n    uint _stakedContractIndex;\\n    address _stakedContractAddress;\\n    _stakedContractAddress = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractAddress;\\n    _stakedContractIndex = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractIndex;\\n    amount = stakedContractStakeCommission[\\n    _stakedContractAddress][_stakedContractIndex].commissionRedeemed;\\n  }\\n\\n  /**\\n   * @dev to set the percentage of staker commission\\n   * @param _val is new percentage value\\n   */\\n  function _setStakerCommissionPer(uint _val) internal {\\n    stakerCommissionPer = _val;\\n  }\\n\\n  /**\\n   * @dev to set the max percentage of staker commission\\n   * @param _val is new percentage value\\n   */\\n  function _setStakerMaxCommissionPer(uint _val) internal {\\n    stakerMaxCommissionPer = _val;\\n  }\\n\\n  /**\\n   * @dev to set the token exponent value\\n   * @param _val is new value\\n   */\\n  function _setTokenExponent(uint _val) internal {\\n    tokenExponent = _val;\\n  }\\n\\n  /**\\n   * @dev to set the price step\\n   * @param _val is new value\\n   */\\n  function _setPriceStep(uint _val) internal {\\n    priceStep = _val;\\n  }\\n\\n  /**\\n   * @dev Changes number of days for which NXM needs to staked in case of underwriting\\n   */\\n  function _changeSCValidDays(uint _days) internal {\\n    scValidDays = _days;\\n  }\\n\\n  /**\\n   * @dev Changes the time period up to which tokens will be locked.\\n   *      Used to generate the validity period of tokens booked by\\n   *      a user for participating in claim's assessment/claim's voting.\\n   */\\n  function _changeBookTime(uint _time) internal {\\n    bookTime = _time;\\n  }\\n\\n  /**\\n   * @dev Changes lock CA days - number of days for which tokens\\n   * are locked while submitting a vote.\\n   */\\n  function _changelockCADays(uint _val) internal {\\n    lockCADays = _val;\\n  }\\n\\n  /**\\n   * @dev Changes lock MV days - number of days for which tokens are locked\\n   * while submitting a vote.\\n   */\\n  function _changelockMVDays(uint _val) internal {\\n    lockMVDays = _val;\\n  }\\n\\n  /**\\n   * @dev Changes extra lock period for a cover, post its expiry.\\n   */\\n  function _setLockTokenTimeAfterCoverExp(uint time) internal {\\n    lockTokenTimeAfterCoverExp = time;\\n  }\\n\\n  /**\\n   * @dev Set the joining fee for membership\\n   */\\n  function _setJoiningFee(uint _amount) internal {\\n    joiningFee = _amount;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/TokenFunctions.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/MasterAware.sol\\\";\\nimport \\\"../cover/QuotationData.sol\\\";\\nimport \\\"./NXMToken.sol\\\";\\nimport \\\"./TokenController.sol\\\";\\nimport \\\"./TokenData.sol\\\";\\n\\ncontract TokenFunctions is MasterAware {\\n  using SafeMath for uint;\\n\\n  TokenController public tc;\\n  NXMToken public tk;\\n  QuotationData public qd;\\n\\n  event BurnCATokens(uint claimId, address addr, uint amount);\\n\\n  /**\\n   * @dev to get the all the cover locked tokens of a user\\n   * @param _of is the user address in concern\\n   * @return amount locked\\n   */\\n  function getUserAllLockedCNTokens(address _of) external view returns (uint) {\\n\\n    uint[] memory coverIds = qd.getAllCoversOfUser(_of);\\n    uint total;\\n\\n    for (uint i = 0; i < coverIds.length; i++) {\\n      bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, coverIds[i]));\\n      uint coverNote = tc.tokensLocked(_of, reason);\\n      total = total.add(coverNote);\\n    }\\n\\n    return total;\\n  }\\n\\n  /**\\n   * @dev Change Dependent Contract Address\\n   */\\n  function changeDependentContractAddress() public {\\n    tc = TokenController(master.getLatestAddress(\\\"TC\\\"));\\n    tk = NXMToken(master.tokenAddress());\\n    qd = QuotationData(master.getLatestAddress(\\\"QD\\\"));\\n  }\\n\\n  /**\\n   * @dev Burns tokens used for fraudulent voting against a claim\\n   * @param claimid Claim Id.\\n   * @param _value number of tokens to be burned\\n   * @param _of Claim Assessor's address.\\n   */\\n  function burnCAToken(uint claimid, uint _value, address _of) external onlyGovernance {\\n    tc.burnLockedTokens(_of, \\\"CLA\\\", _value);\\n    emit BurnCATokens(claimid, _of, _value);\\n  }\\n\\n  /**\\n   * @dev to check if a  member is locked for member vote\\n   * @param _of is the member address in concern\\n   * @return the boolean status\\n   */\\n  function isLockedForMemberVote(address _of) public view returns (bool) {\\n    return now < tk.isLockedForMV(_of);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/governance/external/Governed.sol\": {\r\n      \"content\": \"/* Copyright (C) 2017 GovBlocks.io\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\n\\ninterface IMaster {\\n  function getLatestAddress(bytes2 _module) external view returns (address);\\n}\\n\\ncontract Governed {\\n\\n  address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\\n\\n  /// @dev modifier that allows only the authorized addresses to execute the function\\n  modifier onlyAuthorizedToGovern() {\\n    IMaster ms = IMaster(masterAddress);\\n    require(ms.getLatestAddress(\\\"GV\\\") == msg.sender, \\\"Not authorized\\\");\\n    _;\\n  }\\n\\n  /// @dev checks if an address is authorized to govern\\n  function isAuthorizedToGovern(address _toCheck) public view returns (bool) {\\n    IMaster ms = IMaster(masterAddress);\\n    return (ms.getLatestAddress(\\\"GV\\\") == _toCheck);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/capital/Pool.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"../../abstract/MasterAware.sol\\\";\\nimport \\\"../../interfaces/IPool.sol\\\";\\nimport \\\"../cover/Quotation.sol\\\";\\nimport \\\"../oracles/PriceFeedOracle.sol\\\";\\nimport \\\"../token/NXMToken.sol\\\";\\nimport \\\"../token/TokenController.sol\\\";\\nimport \\\"./MCR.sol\\\";\\n\\ncontract Pool is IPool, MasterAware, ReentrancyGuard {\\n  using Address for address;\\n  using SafeMath for uint;\\n  using SafeERC20 for IERC20;\\n\\n  struct AssetData {\\n    uint112 minAmount;\\n    uint112 maxAmount;\\n    uint32 lastSwapTime;\\n    // 18 decimals of precision. 0.01% -> 0.0001 -> 1e14\\n    uint maxSlippageRatio;\\n  }\\n\\n  /* storage */\\n  address[] public assets;\\n  mapping(address => AssetData) public assetData;\\n\\n  // contracts\\n  Quotation public quotation;\\n  NXMToken public nxmToken;\\n  TokenController public tokenController;\\n  MCR public mcr;\\n\\n  // parameters\\n  address public swapController;\\n  uint public minPoolEth;\\n  PriceFeedOracle public priceFeedOracle;\\n  address public swapOperator;\\n\\n  /* constants */\\n  address constant public ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n  uint public constant MCR_RATIO_DECIMALS = 4;\\n  uint public constant MAX_MCR_RATIO = 40000; // 400%\\n  uint public constant MAX_BUY_SELL_MCR_ETH_FRACTION = 500; // 5%. 4 decimal points\\n\\n  uint internal constant CONSTANT_C = 5800000;\\n  uint internal constant CONSTANT_A = 1028 * 1e13;\\n  uint internal constant TOKEN_EXPONENT = 4;\\n\\n  /* events */\\n  event Payout(address indexed to, address indexed asset, uint amount);\\n  event NXMSold (address indexed member, uint nxmIn, uint ethOut);\\n  event NXMBought (address indexed member, uint ethIn, uint nxmOut);\\n  event Swapped(address indexed fromAsset, address indexed toAsset, uint amountIn, uint amountOut);\\n\\n  /* logic */\\n  modifier onlySwapOperator {\\n    require(msg.sender == swapOperator, \\\"Pool: not swapOperator\\\");\\n    _;\\n  }\\n\\n  constructor (\\n    address[] memory _assets,\\n    uint112[] memory _minAmounts,\\n    uint112[] memory _maxAmounts,\\n    uint[] memory _maxSlippageRatios,\\n    address _master,\\n    address _priceOracle,\\n    address _swapOperator\\n  ) public {\\n\\n    require(_assets.length == _minAmounts.length, \\\"Pool: length mismatch\\\");\\n    require(_assets.length == _maxAmounts.length, \\\"Pool: length mismatch\\\");\\n    require(_assets.length == _maxSlippageRatios.length, \\\"Pool: length mismatch\\\");\\n\\n    for (uint i = 0; i < _assets.length; i++) {\\n\\n      address asset = _assets[i];\\n      require(asset != address(0), \\\"Pool: asset is zero address\\\");\\n      require(_maxAmounts[i] >= _minAmounts[i], \\\"Pool: max < min\\\");\\n      require(_maxSlippageRatios[i] <= 1 ether, \\\"Pool: max < min\\\");\\n\\n      assets.push(asset);\\n      assetData[asset].minAmount = _minAmounts[i];\\n      assetData[asset].maxAmount = _maxAmounts[i];\\n      assetData[asset].maxSlippageRatio = _maxSlippageRatios[i];\\n    }\\n\\n    master = INXMMaster(_master);\\n    priceFeedOracle = PriceFeedOracle(_priceOracle);\\n    swapOperator = _swapOperator;\\n  }\\n\\n  // fallback function\\n  function() external payable {}\\n\\n  // for legacy Pool1 upgrade compatibility\\n  function sendEther() external payable {}\\n\\n  /**\\n   * @dev Calculates total value of all pool assets in ether\\n   */\\n  function getPoolValueInEth() public view returns (uint) {\\n\\n    uint total = address(this).balance;\\n\\n    for (uint i = 0; i < assets.length; i++) {\\n\\n      address assetAddress = assets[i];\\n      IERC20 token = IERC20(assetAddress);\\n\\n      uint rate = priceFeedOracle.getAssetToEthRate(assetAddress);\\n      require(rate > 0, \\\"Pool: zero rate\\\");\\n\\n      uint assetBalance = token.balanceOf(address(this));\\n      uint assetValue = assetBalance.mul(rate).div(1e18);\\n\\n      total = total.add(assetValue);\\n    }\\n\\n    return total;\\n  }\\n\\n  /* asset related functions */\\n\\n  function getAssets() external view returns (address[] memory) {\\n    return assets;\\n  }\\n\\n  function getAssetDetails(address _asset) external view returns (\\n    uint112 min,\\n    uint112 max,\\n    uint32 lastAssetSwapTime,\\n    uint maxSlippageRatio\\n  ) {\\n\\n    AssetData memory data = assetData[_asset];\\n\\n    return (data.minAmount, data.maxAmount, data.lastSwapTime, data.maxSlippageRatio);\\n  }\\n\\n  function addAsset(\\n    address _asset,\\n    uint112 _min,\\n    uint112 _max,\\n    uint _maxSlippageRatio\\n  ) external onlyGovernance {\\n\\n    require(_asset != address(0), \\\"Pool: asset is zero address\\\");\\n    require(_max >= _min, \\\"Pool: max < min\\\");\\n    require(_maxSlippageRatio <= 1 ether, \\\"Pool: max slippage ratio > 1\\\");\\n\\n    for (uint i = 0; i < assets.length; i++) {\\n      require(_asset != assets[i], \\\"Pool: asset exists\\\");\\n    }\\n\\n    assets.push(_asset);\\n    assetData[_asset] = AssetData(_min, _max, 0, _maxSlippageRatio);\\n  }\\n\\n  function removeAsset(address _asset) external onlyGovernance {\\n\\n    for (uint i = 0; i < assets.length; i++) {\\n\\n      if (_asset != assets[i]) {\\n        continue;\\n      }\\n\\n      delete assetData[_asset];\\n      assets[i] = assets[assets.length - 1];\\n      assets.pop();\\n\\n      return;\\n    }\\n\\n    revert(\\\"Pool: asset not found\\\");\\n  }\\n\\n  function setAssetDetails(\\n    address _asset,\\n    uint112 _min,\\n    uint112 _max,\\n    uint _maxSlippageRatio\\n  ) external onlyGovernance {\\n\\n    require(_min <= _max, \\\"Pool: min > max\\\");\\n    require(_maxSlippageRatio <= 1 ether, \\\"Pool: max slippage ratio > 1\\\");\\n\\n    for (uint i = 0; i < assets.length; i++) {\\n\\n      if (_asset != assets[i]) {\\n        continue;\\n      }\\n\\n      assetData[_asset].minAmount = _min;\\n      assetData[_asset].maxAmount = _max;\\n      assetData[_asset].maxSlippageRatio = _maxSlippageRatio;\\n\\n      return;\\n    }\\n\\n    revert(\\\"Pool: asset not found\\\");\\n  }\\n\\n  /* claim related functions */\\n\\n  /**\\n   * @dev Execute the payout in case a claim is accepted\\n   * @param asset token address or 0xEee...EEeE for ether\\n   * @param payoutAddress send funds to this address\\n   * @param amount amount to send\\n   */\\n  function sendClaimPayout (\\n    address asset,\\n    address payable payoutAddress,\\n    uint amount\\n  ) external onlyInternal nonReentrant returns (bool success) {\\n\\n    bool ok;\\n\\n    if (asset == ETH) {\\n      // solhint-disable-next-line avoid-low-level-calls\\n      (ok, /* data */) = payoutAddress.call.value(amount)(\\\"\\\");\\n    } else {\\n      ok =  _safeTokenTransfer(asset, payoutAddress, amount);\\n    }\\n\\n    if (ok) {\\n      emit Payout(payoutAddress, asset, amount);\\n    }\\n\\n    return ok;\\n  }\\n\\n  /**\\n   * @dev safeTransfer implementation that does not revert\\n   * @param tokenAddress ERC20 address\\n   * @param to destination\\n   * @param value amount to send\\n   * @return success true if the transfer was successfull\\n   */\\n  function _safeTokenTransfer (\\n    address tokenAddress,\\n    address to,\\n    uint256 value\\n  ) internal returns (bool) {\\n\\n    // token address is not a contract\\n    if (!tokenAddress.isContract()) {\\n      return false;\\n    }\\n\\n    IERC20 token = IERC20(tokenAddress);\\n    bytes memory data = abi.encodeWithSelector(token.transfer.selector, to, value);\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = tokenAddress.call(data);\\n\\n    // low-level call failed/reverted\\n    if (!success) {\\n      return false;\\n    }\\n\\n    // tokens that don't have return data\\n    if (returndata.length == 0) {\\n      return true;\\n    }\\n\\n    // tokens that have return data will return a bool\\n    return abi.decode(returndata, (bool));\\n  }\\n\\n  /* pool lifecycle functions */\\n\\n  function transferAsset(\\n    address asset,\\n    address payable destination,\\n    uint amount\\n  ) external onlyGovernance nonReentrant {\\n\\n    require(assetData[asset].maxAmount == 0, \\\"Pool: max not zero\\\");\\n    require(destination != address(0), \\\"Pool: dest zero\\\");\\n\\n    IERC20 token = IERC20(asset);\\n    uint balance = token.balanceOf(address(this));\\n    uint transferableAmount = amount > balance ? balance : amount;\\n\\n    token.safeTransfer(destination, transferableAmount);\\n  }\\n\\n  function upgradeCapitalPool(address payable newPoolAddress) external onlyMaster nonReentrant {\\n\\n    // transfer ether\\n    uint ethBalance = address(this).balance;\\n    (bool ok, /* data */) = newPoolAddress.call.value(ethBalance)(\\\"\\\");\\n    require(ok, \\\"Pool: transfer failed\\\");\\n\\n    // transfer assets\\n    for (uint i = 0; i < assets.length; i++) {\\n      IERC20 token = IERC20(assets[i]);\\n      uint tokenBalance = token.balanceOf(address(this));\\n      token.safeTransfer(newPoolAddress, tokenBalance);\\n    }\\n\\n  }\\n\\n  /**\\n   * @dev Update dependent contract address\\n   * @dev Implements MasterAware interface function\\n   */\\n  function changeDependentContractAddress() public {\\n    nxmToken = NXMToken(master.tokenAddress());\\n    tokenController = TokenController(master.getLatestAddress(\\\"TC\\\"));\\n    quotation = Quotation(master.getLatestAddress(\\\"QT\\\"));\\n    mcr = MCR(master.getLatestAddress(\\\"MC\\\"));\\n  }\\n\\n  /* cover purchase functions */\\n\\n  /// @dev Enables user to purchase cover with funding in ETH.\\n  /// @param smartCAdd Smart Contract Address\\n  function makeCoverBegin(\\n    address smartCAdd,\\n    bytes4 coverCurr,\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) public payable onlyMember whenNotPaused {\\n\\n    require(coverCurr == \\\"ETH\\\", \\\"Pool: Unexpected asset type\\\");\\n    require(msg.value == coverDetails[1], \\\"Pool: ETH amount does not match premium\\\");\\n\\n    quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\\n  }\\n\\n  /**\\n   * @dev Enables user to purchase cover via currency asset eg DAI\\n   */\\n  function makeCoverUsingCA(\\n    address smartCAdd,\\n    bytes4 coverCurr,\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) public onlyMember whenNotPaused {\\n    require(coverCurr != \\\"ETH\\\", \\\"Pool: Unexpected asset type\\\");\\n    quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\\n  }\\n\\n  function transferAssetFrom (address asset, address from, uint amount) public onlyInternal whenNotPaused {\\n    IERC20 token = IERC20(asset);\\n    token.safeTransferFrom(from, address(this), amount);\\n  }\\n\\n  function transferAssetToSwapOperator (address asset, uint amount) public onlySwapOperator nonReentrant whenNotPaused {\\n\\n    if (asset == ETH) {\\n      (bool ok, /* data */) = swapOperator.call.value(amount)(\\\"\\\");\\n      require(ok, \\\"Pool: Eth transfer failed\\\");\\n      return;\\n    }\\n\\n    IERC20 token = IERC20(asset);\\n    token.safeTransfer(swapOperator, amount);\\n  }\\n\\n  function setAssetDataLastSwapTime(address asset, uint32 lastSwapTime) public onlySwapOperator whenNotPaused {\\n    assetData[asset].lastSwapTime = lastSwapTime;\\n  }\\n\\n  /* token sale functions */\\n\\n  /**\\n   * @dev (DEPRECATED, use sellTokens function instead) Allows selling of NXM for ether.\\n   * Seller first needs to give this contract allowance to\\n   * transfer/burn tokens in the NXMToken contract\\n   * @param  _amount Amount of NXM to sell\\n   * @return success returns true on successfull sale\\n   */\\n  function sellNXMTokens(uint _amount) public onlyMember whenNotPaused returns (bool success) {\\n    sellNXM(_amount, 0);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev (DEPRECATED, use calculateNXMForEth function instead) Returns the amount of wei a seller will get for selling NXM\\n   * @param amount Amount of NXM to sell\\n   * @return weiToPay Amount of wei the seller will get\\n   */\\n  function getWei(uint amount) external view returns (uint weiToPay) {\\n    return getEthForNXM(amount);\\n  }\\n\\n  /**\\n   * @dev Buys NXM tokens with ETH.\\n   * @param  minTokensOut Minimum amount of tokens to be bought. Revert if boughtTokens falls below this number.\\n   * @return boughtTokens number of bought tokens.\\n   */\\n  function buyNXM(uint minTokensOut) public payable onlyMember whenNotPaused {\\n\\n    uint ethIn = msg.value;\\n    require(ethIn > 0, \\\"Pool: ethIn > 0\\\");\\n\\n    uint totalAssetValue = getPoolValueInEth().sub(ethIn);\\n    uint mcrEth = mcr.getMCR();\\n    uint mcrRatio = calculateMCRRatio(totalAssetValue, mcrEth);\\n\\n    require(mcrRatio <= MAX_MCR_RATIO, \\\"Pool: Cannot purchase if MCR% > 400%\\\");\\n    uint tokensOut = calculateNXMForEth(ethIn, totalAssetValue, mcrEth);\\n    require(tokensOut >= minTokensOut, \\\"Pool: tokensOut is less than minTokensOut\\\");\\n    tokenController.mint(msg.sender, tokensOut);\\n\\n    // evaluate the new MCR for the current asset value including the ETH paid in\\n    mcr.updateMCRInternal(totalAssetValue.add(ethIn), false);\\n    emit NXMBought(msg.sender, ethIn, tokensOut);\\n  }\\n\\n  /**\\n   * @dev Sell NXM tokens and receive ETH.\\n   * @param tokenAmount Amount of tokens to sell.\\n   * @param  minEthOut Minimum amount of ETH to be received. Revert if ethOut falls below this number.\\n   * @return ethOut amount of ETH received in exchange for the tokens.\\n   */\\n  function sellNXM(uint tokenAmount, uint minEthOut) public onlyMember nonReentrant whenNotPaused {\\n\\n    require(nxmToken.balanceOf(msg.sender) >= tokenAmount, \\\"Pool: Not enough balance\\\");\\n    require(nxmToken.isLockedForMV(msg.sender) <= now, \\\"Pool: NXM tokens are locked for voting\\\");\\n\\n    uint currentTotalAssetValue = getPoolValueInEth();\\n    uint mcrEth = mcr.getMCR();\\n    uint ethOut = calculateEthForNXM(tokenAmount, currentTotalAssetValue, mcrEth);\\n    require(currentTotalAssetValue.sub(ethOut) >= mcrEth, \\\"Pool: MCR% cannot fall below 100%\\\");\\n    require(ethOut >= minEthOut, \\\"Pool: ethOut < minEthOut\\\");\\n\\n    tokenController.burnFrom(msg.sender, tokenAmount);\\n    (bool ok, /* data */) = msg.sender.call.value(ethOut)(\\\"\\\");\\n    require(ok, \\\"Pool: Sell transfer failed\\\");\\n\\n    // evaluate the new MCR for the current asset value excluding the paid out ETH\\n    mcr.updateMCRInternal(currentTotalAssetValue.sub(ethOut), false);\\n    emit NXMSold(msg.sender, tokenAmount, ethOut);\\n  }\\n\\n  /**\\n   * @dev Get value in tokens for an ethAmount purchase.\\n   * @param ethAmount amount of ETH used for buying.\\n   * @return tokenValue tokens obtained by buying worth of ethAmount\\n   */\\n  function getNXMForEth(\\n    uint ethAmount\\n  ) public view returns (uint) {\\n    uint totalAssetValue = getPoolValueInEth();\\n    uint mcrEth = mcr.getMCR();\\n    return calculateNXMForEth(ethAmount, totalAssetValue, mcrEth);\\n  }\\n\\n  function calculateNXMForEth(\\n    uint ethAmount,\\n    uint currentTotalAssetValue,\\n    uint mcrEth\\n  ) public pure returns (uint) {\\n\\n    require(\\n      ethAmount <= mcrEth.mul(MAX_BUY_SELL_MCR_ETH_FRACTION).div(10 ** MCR_RATIO_DECIMALS),\\n      \\\"Pool: Purchases worth higher than 5% of MCReth are not allowed\\\"\\n    );\\n\\n    /*\\n      The price formula is:\\n      P(V) = A + MCReth / C *  MCR% ^ 4\\n      where MCR% = V / MCReth\\n      P(V) = A + 1 / (C * MCReth ^ 3) *  V ^ 4\\n\\n      To compute the number of tokens issued we can integrate with respect to V the following:\\n        ΔT = ΔV / P(V)\\n        which assumes that for an infinitesimally small change in locked value V price is constant and we\\n        get an infinitesimally change in token supply ΔT.\\n      This is not computable on-chain, below we use an approximation that works well assuming\\n       * MCR% stays within [100%, 400%]\\n       * ethAmount <= 5% * MCReth\\n\\n      Use a simplified formula excluding the constant A price offset to compute the amount of tokens to be minted.\\n      AdjustedP(V) = 1 / (C * MCReth ^ 3) *  V ^ 4\\n      AdjustedP(V) = 1 / (C * MCReth ^ 3) *  V ^ 4\\n\\n      For a very small variation in tokens ΔT, we have,  ΔT = ΔV / P(V), to get total T we integrate with respect to V.\\n      adjustedTokenAmount = ∫ (dV / AdjustedP(V)) from V0 (currentTotalAssetValue) to V1 (nextTotalAssetValue)\\n      adjustedTokenAmount = ∫ ((C * MCReth ^ 3) / V ^ 4 * dV) from V0 to V1\\n      Evaluating the above using the antiderivative of the function we get:\\n      adjustedTokenAmount = - MCReth ^ 3 * C / (3 * V1 ^3) + MCReth * C /(3 * V0 ^ 3)\\n    */\\n\\n    if (currentTotalAssetValue == 0 || mcrEth.div(currentTotalAssetValue) > 1e12) {\\n      /*\\n       If the currentTotalAssetValue = 0, adjustedTokenPrice approaches 0. Therefore we can assume the price is A.\\n       If currentTotalAssetValue is far smaller than mcrEth, MCR% approaches 0, let the price be A (baseline price).\\n       This avoids overflow in the calculateIntegralAtPoint computation.\\n       This approximation is safe from arbitrage since at MCR% < 100% no sells are possible.\\n      */\\n      uint tokenPrice = CONSTANT_A;\\n      return ethAmount.mul(1e18).div(tokenPrice);\\n    }\\n\\n    // MCReth * C /(3 * V0 ^ 3)\\n    uint point0 = calculateIntegralAtPoint(currentTotalAssetValue, mcrEth);\\n    // MCReth * C / (3 * V1 ^3)\\n    uint nextTotalAssetValue = currentTotalAssetValue.add(ethAmount);\\n    uint point1 = calculateIntegralAtPoint(nextTotalAssetValue, mcrEth);\\n    uint adjustedTokenAmount = point0.sub(point1);\\n    /*\\n      Compute a preliminary adjustedTokenPrice for the minted tokens based on the adjustedTokenAmount above,\\n      and to that add the A constant (the price offset previously removed in the adjusted Price formula)\\n      to obtain the finalPrice and ultimately the tokenValue based on the finalPrice.\\n\\n      adjustedPrice = ethAmount / adjustedTokenAmount\\n      finalPrice = adjustedPrice + A\\n      tokenValue = ethAmount  / finalPrice\\n    */\\n    // ethAmount is multiplied by 1e18 to cancel out the multiplication factor of 1e18 of the adjustedTokenAmount\\n    uint adjustedTokenPrice = ethAmount.mul(1e18).div(adjustedTokenAmount);\\n    uint tokenPrice = adjustedTokenPrice.add(CONSTANT_A);\\n\\n    return ethAmount.mul(1e18).div(tokenPrice);\\n  }\\n\\n  /**\\n   * @dev integral(V) =  MCReth ^ 3 * C / (3 * V ^ 3) * 1e18\\n   * computation result is multiplied by 1e18 to allow for a precision of 18 decimals.\\n   * NOTE: omits the minus sign of the correct integral to use a uint result type for simplicity\\n   * WARNING: this low-level function should be called from a contract which checks that\\n   * mcrEth / assetValue < 1e17 (no overflow) and assetValue != 0\\n   */\\n  function calculateIntegralAtPoint(\\n    uint assetValue,\\n    uint mcrEth\\n  ) internal pure returns (uint) {\\n\\n    return CONSTANT_C\\n      .mul(1e18)\\n      .div(3)\\n      .mul(mcrEth).div(assetValue)\\n      .mul(mcrEth).div(assetValue)\\n      .mul(mcrEth).div(assetValue);\\n  }\\n\\n  function getEthForNXM(uint nxmAmount) public view returns (uint ethAmount) {\\n    uint currentTotalAssetValue = getPoolValueInEth();\\n    uint mcrEth = mcr.getMCR();\\n    return calculateEthForNXM(nxmAmount, currentTotalAssetValue, mcrEth);\\n  }\\n\\n  /**\\n   * @dev Computes token sell value for a tokenAmount in ETH with a sell spread of 2.5%.\\n   * for values in ETH of the sale <= 1% * MCReth the sell spread is very close to the exact value of 2.5%.\\n   * for values higher than that sell spread may exceed 2.5%\\n   * (The higher amount being sold at any given time the higher the spread)\\n   */\\n  function calculateEthForNXM(\\n    uint nxmAmount,\\n    uint currentTotalAssetValue,\\n    uint mcrEth\\n  ) public pure returns (uint) {\\n\\n    // Step 1. Calculate spot price at current values and amount of ETH if tokens are sold at that price\\n    uint spotPrice0 = calculateTokenSpotPrice(currentTotalAssetValue, mcrEth);\\n    uint spotEthAmount = nxmAmount.mul(spotPrice0).div(1e18);\\n\\n    //  Step 2. Calculate spot price using V = currentTotalAssetValue - spotEthAmount from step 1\\n    uint totalValuePostSpotPriceSell = currentTotalAssetValue.sub(spotEthAmount);\\n    uint spotPrice1 = calculateTokenSpotPrice(totalValuePostSpotPriceSell, mcrEth);\\n\\n    // Step 3. Min [average[Price(0), Price(1)] x ( 1 - Sell Spread), Price(1) ]\\n    // Sell Spread = 2.5%\\n    uint averagePriceWithSpread = spotPrice0.add(spotPrice1).div(2).mul(975).div(1000);\\n    uint finalPrice = averagePriceWithSpread < spotPrice1 ? averagePriceWithSpread : spotPrice1;\\n    uint ethAmount = finalPrice.mul(nxmAmount).div(1e18);\\n\\n    require(\\n      ethAmount <= mcrEth.mul(MAX_BUY_SELL_MCR_ETH_FRACTION).div(10 ** MCR_RATIO_DECIMALS),\\n      \\\"Pool: Sales worth more than 5% of MCReth are not allowed\\\"\\n    );\\n\\n    return ethAmount;\\n  }\\n\\n  function calculateMCRRatio(uint totalAssetValue, uint mcrEth) public pure returns (uint) {\\n    return totalAssetValue.mul(10 ** MCR_RATIO_DECIMALS).div(mcrEth);\\n  }\\n\\n  /**\\n  * @dev Calculates token price in ETH 1 NXM token. TokenPrice = A + (MCReth / C) * MCR%^4\\n  */\\n  function calculateTokenSpotPrice(uint totalAssetValue, uint mcrEth) public pure returns (uint tokenPrice) {\\n\\n    uint mcrRatio = calculateMCRRatio(totalAssetValue, mcrEth);\\n    uint precisionDecimals = 10 ** TOKEN_EXPONENT.mul(MCR_RATIO_DECIMALS);\\n\\n    return mcrEth\\n      .mul(mcrRatio ** TOKEN_EXPONENT)\\n      .div(CONSTANT_C)\\n      .div(precisionDecimals)\\n      .add(CONSTANT_A);\\n  }\\n\\n  /**\\n   * @dev Returns the NXM price in a given asset\\n   * @param asset Asset name.\\n   */\\n  function getTokenPrice(address asset) public view returns (uint tokenPrice) {\\n\\n    uint totalAssetValue = getPoolValueInEth();\\n    uint mcrEth = mcr.getMCR();\\n    uint tokenSpotPriceEth = calculateTokenSpotPrice(totalAssetValue, mcrEth);\\n\\n    return priceFeedOracle.getAssetForEth(asset, tokenSpotPriceEth);\\n  }\\n\\n  function getMCRRatio() public view returns (uint) {\\n    uint totalAssetValue = getPoolValueInEth();\\n    uint mcrEth = mcr.getMCR();\\n    return calculateMCRRatio(totalAssetValue, mcrEth);\\n  }\\n\\n  function updateUintParameters(bytes8 code, uint value) external onlyGovernance {\\n\\n    if (code == \\\"MIN_ETH\\\") {\\n      minPoolEth = value;\\n      return;\\n    }\\n\\n    revert(\\\"Pool: unknown parameter\\\");\\n  }\\n\\n  function updateAddressParameters(bytes8 code, address value) external onlyGovernance {\\n\\n    if (code == \\\"SWP_OP\\\") {\\n      swapOperator = value;\\n      return;\\n    }\\n\\n    if (code == \\\"PRC_FEED\\\") {\\n      priceFeedOracle = PriceFeedOracle(value);\\n      return;\\n    }\\n\\n    revert(\\\"Pool: unknown parameter\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/claims/Claims.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"../capital/Pool.sol\\\";\\nimport \\\"../claims/ClaimsReward.sol\\\";\\nimport \\\"../token/NXMToken.sol\\\";\\nimport \\\"../token/TokenController.sol\\\";\\nimport \\\"../token/TokenFunctions.sol\\\";\\nimport \\\"./ClaimsData.sol\\\";\\nimport \\\"./Incidents.sol\\\";\\n\\ncontract Claims is Iupgradable {\\n  using SafeMath for uint;\\n\\n  TokenController internal tc;\\n  ClaimsReward internal cr;\\n  Pool internal p1;\\n  ClaimsData internal cd;\\n  TokenData internal td;\\n  QuotationData internal qd;\\n  Incidents internal incidents;\\n\\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\\n\\n  /**\\n   * @dev Sets the status of claim using claim id.\\n   * @param claimId claim id.\\n   * @param stat status to be set.\\n   */\\n  function setClaimStatus(uint claimId, uint stat) external onlyInternal {\\n    _setClaimStatus(claimId, stat);\\n  }\\n\\n  /**\\n   * @dev Calculates total amount that has been used to assess a claim.\\n   * Computaion:Adds acceptCA(tokens used for voting in favor of a claim)\\n   * denyCA(tokens used for voting against a claim) *  current token price.\\n   * @param claimId Claim Id.\\n   * @param member Member type 0 -> Claim Assessors, else members.\\n   * @return tokens Total Amount used in Claims assessment.\\n   */\\n  function getCATokens(uint claimId, uint member) external view returns (uint tokens) {\\n    uint coverId;\\n    (, coverId) = cd.getClaimCoverId(claimId);\\n\\n    bytes4 currency = qd.getCurrencyOfCover(coverId);\\n    address asset = cr.getCurrencyAssetAddress(currency);\\n    uint tokenx1e18 = p1.getTokenPrice(asset);\\n\\n    uint accept;\\n    uint deny;\\n    if (member == 0) {\\n      (, accept, deny) = cd.getClaimsTokenCA(claimId);\\n    } else {\\n      (, accept, deny) = cd.getClaimsTokenMV(claimId);\\n    }\\n    tokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18); // amount (not in tokens)\\n  }\\n\\n  /**\\n   * Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public onlyInternal {\\n    td = TokenData(ms.getLatestAddress(\\\"TD\\\"));\\n    tc = TokenController(ms.getLatestAddress(\\\"TC\\\"));\\n    p1 = Pool(ms.getLatestAddress(\\\"P1\\\"));\\n    cr = ClaimsReward(ms.getLatestAddress(\\\"CR\\\"));\\n    cd = ClaimsData(ms.getLatestAddress(\\\"CD\\\"));\\n    qd = QuotationData(ms.getLatestAddress(\\\"QD\\\"));\\n    incidents = Incidents(ms.getLatestAddress(\\\"IC\\\"));\\n  }\\n\\n  /**\\n   * @dev Submits a claim for a given cover note.\\n   * Adds claim to queue incase of emergency pause else directly submits the claim.\\n   * @param coverId Cover Id.\\n   */\\n  function submitClaim(uint coverId) external {\\n    _submitClaim(coverId, msg.sender);\\n  }\\n\\n  function submitClaimForMember(uint coverId, address member) external onlyInternal {\\n    _submitClaim(coverId, member);\\n  }\\n\\n  function _submitClaim(uint coverId, address member) internal {\\n\\n    require(!ms.isPause(), \\\"Claims: System is paused\\\");\\n\\n    (/* id */, address contractAddress) = qd.getscAddressOfCover(coverId);\\n    address token = incidents.coveredToken(contractAddress);\\n    require(token == address(0), \\\"Claims: Product type does not allow claims\\\");\\n\\n    address coverOwner = qd.getCoverMemberAddress(coverId);\\n    require(coverOwner == member, \\\"Claims: Not cover owner\\\");\\n\\n    uint expirationDate = qd.getValidityOfCover(coverId);\\n    uint gracePeriod = tc.claimSubmissionGracePeriod();\\n    require(expirationDate.add(gracePeriod) > now, \\\"Claims: Grace period has expired\\\");\\n\\n    tc.markCoverClaimOpen(coverId);\\n    qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimSubmitted));\\n\\n    uint claimId = cd.actualClaimLength();\\n    cd.addClaim(claimId, coverId, coverOwner, now);\\n    cd.callClaimEvent(coverId, coverOwner, claimId, now);\\n  }\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  function submitClaimAfterEPOff() external pure {}\\n\\n  /**\\n   * @dev Castes vote for members who have tokens locked under Claims Assessment\\n   * @param claimId  claim id.\\n   * @param verdict 1 for Accept,-1 for Deny.\\n   */\\n  function submitCAVote(uint claimId, int8 verdict) public isMemberAndcheckPause {\\n    require(checkVoteClosing(claimId) != 1);\\n    require(cd.userClaimVotePausedOn(msg.sender).add(cd.pauseDaysCA()) < now);\\n    uint tokens = tc.tokensLockedAtTime(msg.sender, \\\"CLA\\\", now.add(cd.claimDepositTime()));\\n    require(tokens > 0);\\n    uint stat;\\n    (, stat) = cd.getClaimStatusNumber(claimId);\\n    require(stat == 0);\\n    require(cd.getUserClaimVoteCA(msg.sender, claimId) == 0);\\n    td.bookCATokens(msg.sender);\\n    cd.addVote(msg.sender, tokens, claimId, verdict);\\n    cd.callVoteEvent(msg.sender, claimId, \\\"CAV\\\", tokens, now, verdict);\\n    uint voteLength = cd.getAllVoteLength();\\n    cd.addClaimVoteCA(claimId, voteLength);\\n    cd.setUserClaimVoteCA(msg.sender, claimId, voteLength);\\n    cd.setClaimTokensCA(claimId, verdict, tokens);\\n    tc.extendLockOf(msg.sender, \\\"CLA\\\", td.lockCADays());\\n    int close = checkVoteClosing(claimId);\\n    if (close == 1) {\\n      cr.changeClaimStatus(claimId);\\n    }\\n  }\\n\\n  /**\\n   * @dev Submits a member vote for assessing a claim.\\n   * Tokens other than those locked under Claims\\n   * Assessment can be used to cast a vote for a given claim id.\\n   * @param claimId Selected claim id.\\n   * @param verdict 1 for Accept,-1 for Deny.\\n   */\\n  function submitMemberVote(uint claimId, int8 verdict) public isMemberAndcheckPause {\\n    require(checkVoteClosing(claimId) != 1);\\n    uint stat;\\n    uint tokens = tc.totalBalanceOf(msg.sender);\\n    (, stat) = cd.getClaimStatusNumber(claimId);\\n    require(stat >= 1 && stat <= 5);\\n    require(cd.getUserClaimVoteMember(msg.sender, claimId) == 0);\\n    cd.addVote(msg.sender, tokens, claimId, verdict);\\n    cd.callVoteEvent(msg.sender, claimId, \\\"MV\\\", tokens, now, verdict);\\n    tc.lockForMemberVote(msg.sender, td.lockMVDays());\\n    uint voteLength = cd.getAllVoteLength();\\n    cd.addClaimVotemember(claimId, voteLength);\\n    cd.setUserClaimVoteMember(msg.sender, claimId, voteLength);\\n    cd.setClaimTokensMV(claimId, verdict, tokens);\\n    int close = checkVoteClosing(claimId);\\n    if (close == 1) {\\n      cr.changeClaimStatus(claimId);\\n    }\\n  }\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  function pauseAllPendingClaimsVoting() external pure {}\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  function startAllPendingClaimsVoting() external pure {}\\n\\n  /**\\n   * @dev Checks if voting of a claim should be closed or not.\\n   * @param claimId Claim Id.\\n   * @return close 1 -> voting should be closed, 0 -> if voting should not be closed,\\n   * -1 -> voting has already been closed.\\n   */\\n  function checkVoteClosing(uint claimId) public view returns (int8 close) {\\n    close = 0;\\n    uint status;\\n    (, status) = cd.getClaimStatusNumber(claimId);\\n    uint dateUpd = cd.getClaimDateUpd(claimId);\\n    if (status == 12 && dateUpd.add(cd.payoutRetryTime()) < now) {\\n      if (cd.getClaimState12Count(claimId) < 60)\\n        close = 1;\\n    }\\n\\n    if (status > 5 && status != 12) {\\n      close = - 1;\\n    } else if (status != 12 && dateUpd.add(cd.maxVotingTime()) <= now) {\\n      close = 1;\\n    } else if (status != 12 && dateUpd.add(cd.minVotingTime()) >= now) {\\n      close = 0;\\n    } else if (status == 0 || (status >= 1 && status <= 5)) {\\n      close = _checkVoteClosingFinal(claimId, status);\\n    }\\n\\n  }\\n\\n  /**\\n   * @dev Checks if voting of a claim should be closed or not.\\n   * Internally called by checkVoteClosing method\\n   * for Claims whose status number is 0 or status number lie between 2 and 6.\\n   * @param claimId Claim Id.\\n   * @param status Current status of claim.\\n   * @return close 1 if voting should be closed,0 in case voting should not be closed,\\n   * -1 if voting has already been closed.\\n   */\\n  function _checkVoteClosingFinal(uint claimId, uint status) internal view returns (int8 close) {\\n    close = 0;\\n    uint coverId;\\n    (, coverId) = cd.getClaimCoverId(claimId);\\n\\n    bytes4 currency = qd.getCurrencyOfCover(coverId);\\n    address asset = cr.getCurrencyAssetAddress(currency);\\n    uint tokenx1e18 = p1.getTokenPrice(asset);\\n\\n    uint accept;\\n    uint deny;\\n    (, accept, deny) = cd.getClaimsTokenCA(claimId);\\n    uint caTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);\\n    (, accept, deny) = cd.getClaimsTokenMV(claimId);\\n    uint mvTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);\\n    uint sumassured = qd.getCoverSumAssured(coverId).mul(DECIMAL1E18);\\n    if (status == 0 && caTokens >= sumassured.mul(10)) {\\n      close = 1;\\n    } else if (status >= 1 && status <= 5 && mvTokens >= sumassured.mul(10)) {\\n      close = 1;\\n    }\\n  }\\n\\n  /**\\n   * @dev Changes the status of an existing claim id, based on current\\n   * status and current conditions of the system\\n   * @param claimId Claim Id.\\n   * @param stat status number.\\n   */\\n  function _setClaimStatus(uint claimId, uint stat) internal {\\n\\n    uint origstat;\\n    uint state12Count;\\n    uint dateUpd;\\n    uint coverId;\\n    (, coverId, , origstat, dateUpd, state12Count) = cd.getClaim(claimId);\\n    (, origstat) = cd.getClaimStatusNumber(claimId);\\n\\n    if (stat == 12 && origstat == 12) {\\n      cd.updateState12Count(claimId, 1);\\n    }\\n    cd.setClaimStatus(claimId, stat);\\n\\n    if (state12Count >= 60 && stat == 12) {\\n      cd.setClaimStatus(claimId, 13);\\n      qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimDenied));\\n    }\\n\\n    cd.setClaimdateUpd(claimId, now);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/capital/MCR.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../../abstract/MasterAware.sol\\\";\\nimport \\\"../capital/Pool.sol\\\";\\nimport \\\"../cover/QuotationData.sol\\\";\\nimport \\\"../oracles/PriceFeedOracle.sol\\\";\\nimport \\\"../token/NXMToken.sol\\\";\\nimport \\\"../token/TokenData.sol\\\";\\nimport \\\"./LegacyMCR.sol\\\";\\n\\ncontract MCR is MasterAware {\\n  using SafeMath for uint;\\n\\n  Pool public pool;\\n  QuotationData public qd;\\n  // sizeof(qd) + 96 = 160 + 96 = 256 (occupies entire slot)\\n  uint96 _unused;\\n\\n  // the following values are expressed in basis points\\n  uint24 public mcrFloorIncrementThreshold = 13000;\\n  uint24 public maxMCRFloorIncrement = 100;\\n  uint24 public maxMCRIncrement = 500;\\n  uint24 public gearingFactor = 48000;\\n  // min update between MCR updates in seconds\\n  uint24 public minUpdateTime = 3600;\\n  uint112 public mcrFloor;\\n\\n  uint112 public mcr;\\n  uint112 public desiredMCR;\\n  uint32 public lastUpdateTime;\\n\\n  LegacyMCR public previousMCR;\\n\\n  event MCRUpdated(\\n    uint mcr,\\n    uint desiredMCR,\\n    uint mcrFloor,\\n    uint mcrETHWithGear,\\n    uint totalSumAssured\\n  );\\n\\n  uint constant UINT24_MAX = ~uint24(0);\\n  uint constant MAX_MCR_ADJUSTMENT = 100;\\n  uint constant BASIS_PRECISION = 10000;\\n\\n  constructor (address masterAddress) public {\\n    changeMasterAddress(masterAddress);\\n\\n    if (masterAddress != address(0)) {\\n      previousMCR = LegacyMCR(master.getLatestAddress(\\\"MC\\\"));\\n    }\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public {\\n    qd = QuotationData(master.getLatestAddress(\\\"QD\\\"));\\n    pool = Pool(master.getLatestAddress(\\\"P1\\\"));\\n    initialize();\\n  }\\n\\n  function initialize() internal {\\n\\n    address currentMCR = master.getLatestAddress(\\\"MC\\\");\\n\\n    if (address(previousMCR) == address(0) || currentMCR != address(this)) {\\n      // already initialized or not ready for initialization\\n      return;\\n    }\\n\\n    // fetch MCR parameters from previous contract\\n    uint112 minCap = 7000 * 1e18;\\n    mcrFloor = uint112(previousMCR.variableMincap()) + minCap;\\n    mcr = uint112(previousMCR.getLastMCREther());\\n    desiredMCR = mcr;\\n    mcrFloorIncrementThreshold = uint24(previousMCR.dynamicMincapThresholdx100());\\n    maxMCRFloorIncrement = uint24(previousMCR.dynamicMincapIncrementx100());\\n\\n    // set last updated time to now\\n    lastUpdateTime = uint32(block.timestamp);\\n    previousMCR = LegacyMCR(address(0));\\n  }\\n\\n  /**\\n   * @dev Gets total sum assured (in ETH).\\n   * @return amount of sum assured\\n   */\\n  function getAllSumAssurance() public view returns (uint) {\\n\\n    PriceFeedOracle priceFeed = pool.priceFeedOracle();\\n    address daiAddress = priceFeed.daiAddress();\\n\\n    uint ethAmount = qd.getTotalSumAssured(\\\"ETH\\\").mul(1e18);\\n    uint daiAmount = qd.getTotalSumAssured(\\\"DAI\\\").mul(1e18);\\n\\n    uint daiRate = priceFeed.getAssetToEthRate(daiAddress);\\n    uint daiAmountInEth = daiAmount.mul(daiRate).div(1e18);\\n\\n    return ethAmount.add(daiAmountInEth);\\n  }\\n\\n  /*\\n  * @dev trigger an MCR update. Current virtual MCR value is synced to storage, mcrFloor is potentially updated\\n  * and a new desiredMCR value to move towards is set.\\n  *\\n  */\\n  function updateMCR() public {\\n    _updateMCR(pool.getPoolValueInEth(), false);\\n  }\\n\\n  function updateMCRInternal(uint poolValueInEth, bool forceUpdate) public onlyInternal {\\n    _updateMCR(poolValueInEth, forceUpdate);\\n  }\\n\\n  function _updateMCR(uint poolValueInEth, bool forceUpdate) internal {\\n\\n    // read with 1 SLOAD\\n    uint _mcrFloorIncrementThreshold = mcrFloorIncrementThreshold;\\n    uint _maxMCRFloorIncrement = maxMCRFloorIncrement;\\n    uint _gearingFactor = gearingFactor;\\n    uint _minUpdateTime = minUpdateTime;\\n    uint _mcrFloor =  mcrFloor;\\n\\n    // read with 1 SLOAD\\n    uint112 _mcr = mcr;\\n    uint112 _desiredMCR = desiredMCR;\\n    uint32 _lastUpdateTime = lastUpdateTime;\\n\\n    if (!forceUpdate && _lastUpdateTime + _minUpdateTime > block.timestamp) {\\n      return;\\n    }\\n\\n    if (block.timestamp > _lastUpdateTime && pool.calculateMCRRatio(poolValueInEth, _mcr) >= _mcrFloorIncrementThreshold) {\\n        // MCR floor updates by up to maxMCRFloorIncrement percentage per day whenever the MCR ratio exceeds 1.3\\n        // MCR floor is monotonically increasing.\\n      uint basisPointsAdjustment = min(\\n        _maxMCRFloorIncrement.mul(block.timestamp - _lastUpdateTime).div(1 days),\\n        _maxMCRFloorIncrement\\n      );\\n      uint newMCRFloor = _mcrFloor.mul(basisPointsAdjustment.add(BASIS_PRECISION)).div(BASIS_PRECISION);\\n      require(newMCRFloor <= uint112(~0), 'MCR: newMCRFloor overflow');\\n\\n      mcrFloor = uint112(newMCRFloor);\\n    }\\n\\n    // sync the current virtual MCR value to storage\\n    uint112 newMCR = uint112(getMCR());\\n    if (newMCR != _mcr) {\\n      mcr = newMCR;\\n    }\\n\\n    // the desiredMCR cannot fall below the mcrFloor but may have a higher or lower target value based\\n    // on the changes in the totalSumAssured in the system.\\n    uint totalSumAssured = getAllSumAssurance();\\n    uint gearedMCR = totalSumAssured.mul(BASIS_PRECISION).div(_gearingFactor);\\n    uint112 newDesiredMCR = uint112(max(gearedMCR, mcrFloor));\\n    if (newDesiredMCR != _desiredMCR) {\\n      desiredMCR = newDesiredMCR;\\n    }\\n\\n    lastUpdateTime = uint32(block.timestamp);\\n\\n    emit MCRUpdated(mcr, desiredMCR, mcrFloor, gearedMCR, totalSumAssured);\\n  }\\n\\n  /**\\n   * @dev Calculates the current virtual MCR value. The virtual MCR value moves towards the desiredMCR value away\\n   * from the stored mcr value at constant velocity based on how much time passed from the lastUpdateTime.\\n   * The total change in virtual MCR cannot exceed 1% of stored mcr.\\n   *\\n   * This approach allows for the MCR to change smoothly across time without sudden jumps between values, while\\n   * always progressing towards the desiredMCR goal. The desiredMCR can change subject to the call of _updateMCR\\n   * so the virtual MCR value may change direction and start decreasing instead of increasing or vice-versa.\\n   *\\n   * @return mcr\\n   */\\n  function getMCR() public view returns (uint) {\\n\\n    // read with 1 SLOAD\\n    uint _mcr = mcr;\\n    uint _desiredMCR = desiredMCR;\\n    uint _lastUpdateTime = lastUpdateTime;\\n\\n\\n    if (block.timestamp == _lastUpdateTime) {\\n      return _mcr;\\n    }\\n\\n    uint _maxMCRIncrement = maxMCRIncrement;\\n\\n    uint basisPointsAdjustment = _maxMCRIncrement.mul(block.timestamp - _lastUpdateTime).div(1 days);\\n    basisPointsAdjustment = min(basisPointsAdjustment, MAX_MCR_ADJUSTMENT);\\n\\n    if (_desiredMCR > _mcr) {\\n      return min(_mcr.mul(basisPointsAdjustment.add(BASIS_PRECISION)).div(BASIS_PRECISION), _desiredMCR);\\n    }\\n\\n    // in case desiredMCR <= mcr\\n    return max(_mcr.mul(BASIS_PRECISION - basisPointsAdjustment).div(BASIS_PRECISION), _desiredMCR);\\n  }\\n\\n  function getGearedMCR() external view returns (uint) {\\n    return getAllSumAssurance().mul(BASIS_PRECISION).div(gearingFactor);\\n  }\\n\\n  function min(uint x, uint y) pure internal returns (uint) {\\n    return x < y ? x : y;\\n  }\\n\\n  function max(uint x, uint y) pure internal returns (uint) {\\n    return x > y ? x : y;\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters\\n   * @param code parameter code\\n   * @param val new value\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n    require(master.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"DMCT\\\") {\\n\\n      require(val <= UINT24_MAX, \\\"MCR: value too large\\\");\\n      mcrFloorIncrementThreshold = uint24(val);\\n\\n    } else if (code == \\\"DMCI\\\") {\\n\\n      require(val <= UINT24_MAX, \\\"MCR: value too large\\\");\\n      maxMCRFloorIncrement = uint24(val);\\n\\n    } else if (code == \\\"MMIC\\\") {\\n\\n      require(val <= UINT24_MAX, \\\"MCR: value too large\\\");\\n      maxMCRIncrement = uint24(val);\\n\\n    } else if (code == \\\"GEAR\\\") {\\n\\n      require(val <= UINT24_MAX, \\\"MCR: value too large\\\");\\n      gearingFactor = uint24(val);\\n\\n    } else if (code == \\\"MUTI\\\") {\\n\\n      require(val <= UINT24_MAX, \\\"MCR: value too large\\\");\\n      minUpdateTime = uint24(val);\\n\\n    } else {\\n      revert(\\\"Invalid param code\\\");\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract ReentrancyGuard {\\n    bool private _notEntered;\\n\\n    constructor () internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction's gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following \\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/MasterAware.sol\": {\r\n      \"content\": \"/*\\n    Copyright (C) 2020 NexusMutual.io\\n\\n    This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n    This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n    You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/\\n*/\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"./INXMMaster.sol\\\";\\n\\ncontract MasterAware {\\n\\n  INXMMaster public master;\\n\\n  modifier onlyMember {\\n    require(master.isMember(msg.sender), \\\"Caller is not a member\\\");\\n    _;\\n  }\\n\\n  modifier onlyInternal {\\n    require(master.isInternal(msg.sender), \\\"Caller is not an internal contract\\\");\\n    _;\\n  }\\n\\n  modifier onlyMaster {\\n    if (address(master) != address(0)) {\\n      require(address(master) == msg.sender, \\\"Not master\\\");\\n    }\\n    _;\\n  }\\n\\n  modifier onlyGovernance {\\n    require(\\n      master.checkIsAuthToGoverned(msg.sender),\\n      \\\"Caller is not authorized to govern\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier whenPaused {\\n    require(master.isPause(), \\\"System is not paused\\\");\\n    _;\\n  }\\n\\n  modifier whenNotPaused {\\n    require(!master.isPause(), \\\"System is paused\\\");\\n    _;\\n  }\\n\\n  function changeDependentContractAddress() external;\\n\\n  function changeMasterAddress(address masterAddress) public onlyMaster {\\n    master = INXMMaster(masterAddress);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.5.0;\\n\\ninterface IPool {\\n\\n  function transferAssetToSwapOperator(address asset, uint amount) external;\\n\\n  function getAssetDetails(address _asset) external view returns (\\n    uint112 min,\\n    uint112 max,\\n    uint32 lastAssetSwapTime,\\n    uint maxSlippageRatio\\n  );\\n\\n  function setAssetDataLastSwapTime(address asset, uint32 lastSwapTime) external;\\n\\n  function minPoolEth() external returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/modules/cover/Quotation.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"../../abstract/MasterAware.sol\\\";\\nimport \\\"../capital/Pool.sol\\\";\\nimport \\\"../claims/ClaimsReward.sol\\\";\\nimport \\\"../claims/Incidents.sol\\\";\\nimport \\\"../token/TokenController.sol\\\";\\nimport \\\"../token/TokenData.sol\\\";\\nimport \\\"./QuotationData.sol\\\";\\n\\ncontract Quotation is MasterAware, ReentrancyGuard {\\n  using SafeMath for uint;\\n\\n  ClaimsReward public cr;\\n  Pool public pool;\\n  IPooledStaking public pooledStaking;\\n  QuotationData public qd;\\n  TokenController public tc;\\n  TokenData public td;\\n  Incidents public incidents;\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public onlyInternal {\\n    cr = ClaimsReward(master.getLatestAddress(\\\"CR\\\"));\\n    pool = Pool(master.getLatestAddress(\\\"P1\\\"));\\n    pooledStaking = IPooledStaking(master.getLatestAddress(\\\"PS\\\"));\\n    qd = QuotationData(master.getLatestAddress(\\\"QD\\\"));\\n    tc = TokenController(master.getLatestAddress(\\\"TC\\\"));\\n    td = TokenData(master.getLatestAddress(\\\"TD\\\"));\\n    incidents = Incidents(master.getLatestAddress(\\\"IC\\\"));\\n  }\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  function sendEther() public payable {}\\n\\n  /**\\n   * @dev Expires a cover after a set period of time and changes the status of the cover\\n   * @dev Reduces the total and contract sum assured\\n   * @param coverId Cover Id.\\n   */\\n  function expireCover(uint coverId) external {\\n\\n    uint expirationDate = qd.getValidityOfCover(coverId);\\n    require(expirationDate < now, \\\"Quotation: cover is not due to expire\\\");\\n\\n    uint coverStatus = qd.getCoverStatusNo(coverId);\\n    require(coverStatus != uint(QuotationData.CoverStatus.CoverExpired), \\\"Quotation: cover already expired\\\");\\n\\n    (/* claim count */, bool hasOpenClaim, /* accepted */) = tc.coverInfo(coverId);\\n    require(!hasOpenClaim, \\\"Quotation: cover has an open claim\\\");\\n\\n    if (coverStatus != uint(QuotationData.CoverStatus.ClaimAccepted)) {\\n      (,, address contractAddress, bytes4 currency, uint amount,) = qd.getCoverDetailsByCoverID1(coverId);\\n      qd.subFromTotalSumAssured(currency, amount);\\n      qd.subFromTotalSumAssuredSC(contractAddress, currency, amount);\\n    }\\n\\n    qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.CoverExpired));\\n  }\\n\\n  function withdrawCoverNote(address coverOwner, uint[] calldata coverIds, uint[] calldata reasonIndexes) external {\\n\\n    uint gracePeriod = tc.claimSubmissionGracePeriod();\\n\\n    for (uint i = 0; i < coverIds.length; i++) {\\n      uint expirationDate = qd.getValidityOfCover(coverIds[i]);\\n      require(expirationDate.add(gracePeriod) < now, \\\"Quotation: cannot withdraw before grace period expiration\\\");\\n    }\\n\\n    tc.withdrawCoverNote(coverOwner, coverIds, reasonIndexes);\\n  }\\n\\n  function getWithdrawableCoverNoteCoverIds(\\n    address coverOwner\\n  ) public view returns (\\n    uint[] memory expiredCoverIds,\\n    bytes32[] memory lockReasons\\n  ) {\\n\\n    uint[] memory coverIds = qd.getAllCoversOfUser(coverOwner);\\n    uint[] memory expiredIdsQueue = new uint[](coverIds.length);\\n    uint gracePeriod = tc.claimSubmissionGracePeriod();\\n    uint expiredQueueLength = 0;\\n\\n    for (uint i = 0; i < coverIds.length; i++) {\\n\\n      uint coverExpirationDate = qd.getValidityOfCover(coverIds[i]);\\n      uint gracePeriodExpirationDate = coverExpirationDate.add(gracePeriod);\\n      (/* claimCount */, bool hasOpenClaim, /* hasAcceptedClaim */) = tc.coverInfo(coverIds[i]);\\n\\n      if (!hasOpenClaim && gracePeriodExpirationDate < now) {\\n        expiredIdsQueue[expiredQueueLength] = coverIds[i];\\n        expiredQueueLength++;\\n      }\\n    }\\n\\n    expiredCoverIds = new uint[](expiredQueueLength);\\n    lockReasons = new bytes32[](expiredQueueLength);\\n\\n    for (uint i = 0; i < expiredQueueLength; i++) {\\n      expiredCoverIds[i] = expiredIdsQueue[i];\\n      lockReasons[i] = keccak256(abi.encodePacked(\\\"CN\\\", coverOwner, expiredIdsQueue[i]));\\n    }\\n  }\\n\\n  function getWithdrawableCoverNotesAmount(address coverOwner) external view returns (uint) {\\n\\n    uint withdrawableAmount;\\n    bytes32[] memory lockReasons;\\n    (/*expiredCoverIds*/, lockReasons) = getWithdrawableCoverNoteCoverIds(coverOwner);\\n\\n    for (uint i = 0; i < lockReasons.length; i++) {\\n      uint coverNoteAmount = tc.tokensLocked(coverOwner, lockReasons[i]);\\n      withdrawableAmount = withdrawableAmount.add(coverNoteAmount);\\n    }\\n\\n    return withdrawableAmount;\\n  }\\n\\n  /**\\n   * @dev Makes Cover funded via NXM tokens.\\n   * @param smartCAdd Smart Contract Address\\n   */\\n  function makeCoverUsingNXMTokens(\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod,\\n    bytes4 coverCurr,\\n    address smartCAdd,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) external onlyMember whenNotPaused {\\n    tc.burnFrom(msg.sender, coverDetails[2]); // needs allowance\\n    _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s, true);\\n  }\\n\\n  /**\\n   * @dev Verifies cover details signed off chain.\\n   * @param from address of funder.\\n   * @param scAddress Smart Contract Address\\n   */\\n  function verifyCoverDetails(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) public onlyInternal {\\n    _verifyCoverDetails(\\n      from,\\n      scAddress,\\n      coverCurr,\\n      coverDetails,\\n      coverPeriod,\\n      _v,\\n      _r,\\n      _s,\\n      false\\n    );\\n  }\\n\\n  /**\\n   * @dev Verifies signature.\\n   * @param coverDetails details related to cover.\\n   * @param coverPeriod validity of cover.\\n   * @param contractAddress smart contract address.\\n   * @param _v argument from vrs hash.\\n   * @param _r argument from vrs hash.\\n   * @param _s argument from vrs hash.\\n   */\\n  function verifySignature(\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    bytes4 currency,\\n    address contractAddress,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) public view returns (bool) {\\n    require(contractAddress != address(0));\\n    bytes32 hash = getOrderHash(coverDetails, coverPeriod, currency, contractAddress);\\n    return isValidSignature(hash, _v, _r, _s);\\n  }\\n\\n  /**\\n   * @dev Gets order hash for given cover details.\\n   * @param coverDetails details realted to cover.\\n   * @param coverPeriod validity of cover.\\n   * @param contractAddress smart contract address.\\n   */\\n  function getOrderHash(\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    bytes4 currency,\\n    address contractAddress\\n  ) public view returns (bytes32) {\\n    return keccak256(\\n      abi.encodePacked(\\n        coverDetails[0],\\n        currency,\\n        coverPeriod,\\n        contractAddress,\\n        coverDetails[1],\\n        coverDetails[2],\\n        coverDetails[3],\\n        coverDetails[4],\\n        address(this)\\n      )\\n    );\\n  }\\n\\n  /**\\n   * @dev Verifies signature.\\n   * @param hash order hash\\n   * @param v argument from vrs hash.\\n   * @param r argument from vrs hash.\\n   * @param s argument from vrs hash.\\n   */\\n  function isValidSignature(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public view returns (bool) {\\n    bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\n    bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\\n    address a = ecrecover(prefixedHash, v, r, s);\\n    return (a == qd.getAuthQuoteEngine());\\n  }\\n\\n  /**\\n   * @dev Creates cover of the quotation, changes the status of the quotation ,\\n   * updates the total sum assured and locks the tokens of the cover against a quote.\\n   * @param from Quote member Ethereum address.\\n   */\\n  function _makeCover(//solhint-disable-line\\n    address payable from,\\n    address contractAddress,\\n    bytes4 coverCurrency,\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod\\n  ) internal {\\n\\n    address underlyingToken = incidents.underlyingToken(contractAddress);\\n\\n    if (underlyingToken != address(0)) {\\n      address coverAsset = cr.getCurrencyAssetAddress(coverCurrency);\\n      require(coverAsset == underlyingToken, \\\"Quotation: Unsupported cover asset for this product\\\");\\n    }\\n\\n    uint cid = qd.getCoverLength();\\n\\n    qd.addCover(\\n      coverPeriod,\\n      coverDetails[0],\\n      from,\\n      coverCurrency,\\n      contractAddress,\\n      coverDetails[1],\\n      coverDetails[2]\\n    );\\n\\n    uint coverNoteAmount = coverDetails[2].mul(qd.tokensRetained()).div(100);\\n\\n    if (underlyingToken == address(0)) {\\n      uint gracePeriod = tc.claimSubmissionGracePeriod();\\n      uint claimSubmissionPeriod = uint(coverPeriod).mul(1 days).add(gracePeriod);\\n      bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", from, cid));\\n\\n      // mint and lock cover note\\n      td.setDepositCNAmount(cid, coverNoteAmount);\\n      tc.mintCoverNote(from, reason, coverNoteAmount, claimSubmissionPeriod);\\n    } else {\\n      // minted directly to member's wallet\\n      tc.mint(from, coverNoteAmount);\\n    }\\n\\n    qd.addInTotalSumAssured(coverCurrency, coverDetails[0]);\\n    qd.addInTotalSumAssuredSC(contractAddress, coverCurrency, coverDetails[0]);\\n\\n    uint coverPremiumInNXM = coverDetails[2];\\n    uint stakersRewardPercentage = td.stakerCommissionPer();\\n    uint rewardValue = coverPremiumInNXM.mul(stakersRewardPercentage).div(100);\\n    pooledStaking.accumulateReward(contractAddress, rewardValue);\\n  }\\n\\n  /**\\n   * @dev Makes a cover.\\n   * @param from address of funder.\\n   * @param scAddress Smart Contract Address\\n   */\\n  function _verifyCoverDetails(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s,\\n    bool isNXM\\n  ) internal {\\n\\n    require(coverDetails[3] > now, \\\"Quotation: Quote has expired\\\");\\n    require(coverPeriod >= 30 && coverPeriod <= 365, \\\"Quotation: Cover period out of bounds\\\");\\n    require(!qd.timestampRepeated(coverDetails[4]), \\\"Quotation: Quote already used\\\");\\n    qd.setTimestampRepeated(coverDetails[4]);\\n\\n    address asset = cr.getCurrencyAssetAddress(coverCurr);\\n    if (coverCurr != \\\"ETH\\\" && !isNXM) {\\n      pool.transferAssetFrom(asset, from, coverDetails[1]);\\n    }\\n\\n    require(verifySignature(coverDetails, coverPeriod, coverCurr, scAddress, _v, _r, _s), \\\"Quotation: signature mismatch\\\");\\n    _makeCover(from, scAddress, coverCurr, coverDetails, coverPeriod);\\n  }\\n\\n  function createCover(\\n    address payable from,\\n    address scAddress,\\n    bytes4 currency,\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) external onlyInternal {\\n\\n    require(coverDetails[3] > now, \\\"Quotation: Quote has expired\\\");\\n    require(coverPeriod >= 30 && coverPeriod <= 365, \\\"Quotation: Cover period out of bounds\\\");\\n    require(!qd.timestampRepeated(coverDetails[4]), \\\"Quotation: Quote already used\\\");\\n    qd.setTimestampRepeated(coverDetails[4]);\\n\\n    require(verifySignature(coverDetails, coverPeriod, currency, scAddress, _v, _r, _s), \\\"Quotation: signature mismatch\\\");\\n    _makeCover(from, scAddress, currency, coverDetails, coverPeriod);\\n  }\\n\\n  // referenced in master, keeping for now\\n  // solhint-disable-next-line no-empty-blocks\\n  function transferAssetsToNewContract(address) external pure {}\\n\\n  function freeUpHeldCovers() external nonReentrant {\\n\\n    IERC20 dai = IERC20(cr.getCurrencyAssetAddress(\\\"DAI\\\"));\\n    uint membershipFee = td.joiningFee();\\n    uint lastCoverId = 106;\\n\\n    for (uint id = 1; id <= lastCoverId; id++) {\\n\\n      if (qd.holdedCoverIDStatus(id) != uint(QuotationData.HCIDStatus.kycPending)) {\\n        continue;\\n      }\\n\\n      (/*id*/, /*sc*/, bytes4 currency, /*period*/) = qd.getHoldedCoverDetailsByID1(id);\\n      (/*id*/, address payable userAddress, uint[] memory coverDetails) = qd.getHoldedCoverDetailsByID2(id);\\n\\n      uint refundedETH = membershipFee;\\n      uint coverPremium = coverDetails[1];\\n\\n      if (qd.refundEligible(userAddress)) {\\n        qd.setRefundEligible(userAddress, false);\\n      }\\n\\n      qd.setHoldedCoverIDStatus(id, uint(QuotationData.HCIDStatus.kycFailedOrRefunded));\\n\\n      if (currency == \\\"ETH\\\") {\\n        refundedETH = refundedETH.add(coverPremium);\\n      } else {\\n        require(dai.transfer(userAddress, coverPremium), \\\"Quotation: DAI refund transfer failed\\\");\\n      }\\n\\n      userAddress.transfer(refundedETH);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/oracles/PriceFeedOracle.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ninterface Aggregator {\\n  function latestAnswer() external view returns (int);\\n}\\n\\ncontract PriceFeedOracle {\\n  using SafeMath for uint;\\n\\n  mapping(address => address) public aggregators;\\n  address public daiAddress;\\n  address public stETH;\\n  address constant public ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n  constructor (\\n    address _daiAggregator,\\n    address _daiAddress,\\n    address _stEthAddress\\n  ) public {\\n    aggregators[_daiAddress] = _daiAggregator;\\n    daiAddress = _daiAddress;\\n    stETH = _stEthAddress;\\n  }\\n\\n  /**\\n   * @dev Returns the amount of ether in wei that are equivalent to 1 unit (10 ** decimals) of asset\\n   * @param asset quoted currency\\n   * @return price in ether\\n   */\\n  function getAssetToEthRate(address asset) public view returns (uint) {\\n\\n    if (asset == ETH || asset == stETH) {\\n      return 1 ether;\\n    }\\n\\n    address aggregatorAddress = aggregators[asset];\\n\\n    if (aggregatorAddress == address(0)) {\\n      revert(\\\"PriceFeedOracle: Oracle asset not found\\\");\\n    }\\n\\n    int rate = Aggregator(aggregatorAddress).latestAnswer();\\n    require(rate > 0, \\\"PriceFeedOracle: Rate must be > 0\\\");\\n\\n    return uint(rate);\\n  }\\n\\n  /**\\n  * @dev Returns the amount of currency that is equivalent to ethIn amount of ether.\\n  * @param asset quoted  Supported values: [\\\"DAI\\\", \\\"ETH\\\"]\\n  * @param ethIn amount of ether to be converted to the currency\\n  * @return price in ether\\n  */\\n  function getAssetForEth(address asset, uint ethIn) external view returns (uint) {\\n\\n    if (asset == daiAddress) {\\n      return ethIn.mul(1e18).div(getAssetToEthRate(daiAddress));\\n    }\\n\\n    if (asset == ETH || asset == stETH) {\\n      return ethIn;\\n    }\\n\\n    revert(\\\"PriceFeedOracle: Unknown asset\\\");\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/claims/Incidents.sol\": {\r\n      \"content\": \"/* Copyright (C) 2021 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../../abstract/MasterAware.sol\\\";\\nimport \\\"../../interfaces/IPooledStaking.sol\\\";\\nimport \\\"../capital/Pool.sol\\\";\\nimport \\\"../claims/ClaimsData.sol\\\";\\nimport \\\"../claims/ClaimsReward.sol\\\";\\nimport \\\"../cover/QuotationData.sol\\\";\\nimport \\\"../governance/MemberRoles.sol\\\";\\nimport \\\"../token/TokenController.sol\\\";\\nimport \\\"../capital/MCR.sol\\\";\\n\\ncontract Incidents is MasterAware {\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint;\\n\\n  struct Incident {\\n    address productId;\\n    uint32 date;\\n    uint priceBefore;\\n  }\\n\\n  // contract identifiers\\n  enum ID {CD, CR, QD, TC, MR, P1, PS, MC}\\n\\n  mapping(uint => address payable) public internalContracts;\\n\\n  Incident[] public incidents;\\n\\n  // product id => underlying token (ex. yDAI -> DAI)\\n  mapping(address => address) public underlyingToken;\\n\\n  // product id => covered token (ex. 0xc7ed.....1 -> yDAI)\\n  mapping(address => address) public coveredToken;\\n\\n  // claim id => payout amount\\n  mapping(uint => uint) public claimPayout;\\n\\n  // product id => accumulated burn amount\\n  mapping(address => uint) public accumulatedBurn;\\n\\n  // burn ratio in bps, ex 2000 for 20%\\n  uint public BURN_RATIO;\\n\\n  // burn ratio in bps\\n  uint public DEDUCTIBLE_RATIO;\\n\\n  uint constant BASIS_PRECISION = 10000;\\n\\n  event ProductAdded(\\n    address indexed productId,\\n    address indexed coveredToken,\\n    address indexed underlyingToken\\n  );\\n\\n  event IncidentAdded(\\n    address indexed productId,\\n    uint incidentDate,\\n    uint priceBefore\\n  );\\n\\n  modifier onlyAdvisoryBoard {\\n    uint abRole = uint(MemberRoles.Role.AdvisoryBoard);\\n    require(\\n      memberRoles().checkRole(msg.sender, abRole),\\n      \\\"Incidents: Caller is not an advisory board member\\\"\\n    );\\n    _;\\n  }\\n\\n  function initialize() external {\\n    require(BURN_RATIO == 0, \\\"Already initialized\\\");\\n    BURN_RATIO = 2000;\\n    DEDUCTIBLE_RATIO = 9000;\\n  }\\n\\n  function addProducts(\\n    address[] calldata _productIds,\\n    address[] calldata _coveredTokens,\\n    address[] calldata _underlyingTokens\\n  ) external onlyAdvisoryBoard {\\n\\n    require(\\n      _productIds.length == _coveredTokens.length,\\n      \\\"Incidents: Protocols and covered tokens lengths differ\\\"\\n    );\\n\\n    require(\\n      _productIds.length == _underlyingTokens.length,\\n      \\\"Incidents: Protocols and underyling tokens lengths differ\\\"\\n    );\\n\\n    for (uint i = 0; i < _productIds.length; i++) {\\n      address id = _productIds[i];\\n\\n      require(coveredToken[id] == address(0), \\\"Incidents: covered token is already set\\\");\\n      require(underlyingToken[id] == address(0), \\\"Incidents: underlying token is already set\\\");\\n\\n      coveredToken[id] = _coveredTokens[i];\\n      underlyingToken[id] = _underlyingTokens[i];\\n      emit ProductAdded(id, _coveredTokens[i], _underlyingTokens[i]);\\n    }\\n  }\\n\\n  function incidentCount() external view returns (uint) {\\n    return incidents.length;\\n  }\\n\\n  function addIncident(\\n    address productId,\\n    uint incidentDate,\\n    uint priceBefore\\n  ) external onlyGovernance {\\n    address underlying = underlyingToken[productId];\\n    require(underlying != address(0), \\\"Incidents: Unsupported product\\\");\\n\\n    Incident memory incident = Incident(productId, uint32(incidentDate), priceBefore);\\n    incidents.push(incident);\\n\\n    emit IncidentAdded(productId, incidentDate, priceBefore);\\n  }\\n\\n  function redeemPayoutForMember(\\n    uint coverId,\\n    uint incidentId,\\n    uint coveredTokenAmount,\\n    address member\\n  ) external onlyInternal returns (uint claimId, uint payoutAmount, address payoutToken) {\\n    (claimId, payoutAmount, payoutToken) = _redeemPayout(coverId, incidentId, coveredTokenAmount, member);\\n  }\\n\\n  function redeemPayout(\\n    uint coverId,\\n    uint incidentId,\\n    uint coveredTokenAmount\\n  ) external returns (uint claimId, uint payoutAmount, address payoutToken) {\\n    (claimId, payoutAmount, payoutToken) = _redeemPayout(coverId, incidentId, coveredTokenAmount, msg.sender);\\n  }\\n\\n  function _redeemPayout(\\n    uint coverId,\\n    uint incidentId,\\n    uint coveredTokenAmount,\\n    address coverOwner\\n  ) internal returns (uint claimId, uint payoutAmount, address coverAsset) {\\n    QuotationData qd = quotationData();\\n    Incident memory incident = incidents[incidentId];\\n    uint sumAssured;\\n    bytes4 currency;\\n\\n    {\\n      address productId;\\n      address _coverOwner;\\n\\n      (/* id */, _coverOwner, productId,\\n       currency, sumAssured, /* premiumNXM */\\n      ) = qd.getCoverDetailsByCoverID1(coverId);\\n\\n      // check ownership and covered protocol\\n      require(coverOwner == _coverOwner, \\\"Incidents: Not cover owner\\\");\\n      require(productId == incident.productId, \\\"Incidents: Bad incident id\\\");\\n    }\\n\\n    {\\n      uint coverPeriod = uint(qd.getCoverPeriod(coverId)).mul(1 days);\\n      uint coverExpirationDate = qd.getValidityOfCover(coverId);\\n      uint coverStartDate = coverExpirationDate.sub(coverPeriod);\\n\\n      // check cover validity\\n      require(coverStartDate <= incident.date, \\\"Incidents: Cover start date is after the incident\\\");\\n      require(coverExpirationDate >= incident.date, \\\"Incidents: Cover end date is before the incident\\\");\\n\\n      // check grace period\\n      uint gracePeriod = tokenController().claimSubmissionGracePeriod();\\n      require(coverExpirationDate.add(gracePeriod) >= block.timestamp, \\\"Incidents: Grace period has expired\\\");\\n    }\\n\\n    {\\n      // assumes 18 decimals (eth & dai)\\n      uint decimalPrecision = 1e18;\\n      uint maxAmount;\\n\\n      // sumAssured is currently stored without decimals\\n      uint coverAmount = sumAssured.mul(decimalPrecision);\\n\\n      {\\n        // max amount check\\n        uint deductiblePriceBefore = incident.priceBefore.mul(DEDUCTIBLE_RATIO).div(BASIS_PRECISION);\\n        maxAmount = coverAmount.mul(decimalPrecision).div(deductiblePriceBefore);\\n        require(coveredTokenAmount <= maxAmount, \\\"Incidents: Amount exceeds sum assured\\\");\\n      }\\n\\n      // payoutAmount = coveredTokenAmount / maxAmount * coverAmount\\n      //              = coveredTokenAmount * coverAmount / maxAmount\\n      payoutAmount = coveredTokenAmount.mul(coverAmount).div(maxAmount);\\n    }\\n\\n    {\\n      TokenController tc = tokenController();\\n      // mark cover as having a successful claim\\n      tc.markCoverClaimOpen(coverId);\\n      tc.markCoverClaimClosed(coverId, true);\\n\\n      // create the claim\\n      ClaimsData cd = claimsData();\\n      claimId = cd.actualClaimLength();\\n      cd.addClaim(claimId, coverId, coverOwner, now);\\n      cd.callClaimEvent(coverId, coverOwner, claimId, now);\\n      cd.setClaimStatus(claimId, 14);\\n      qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimAccepted));\\n\\n      claimPayout[claimId] = payoutAmount;\\n    }\\n\\n    coverAsset = claimsReward().getCurrencyAssetAddress(currency);\\n\\n    _sendPayoutAndPushBurn(\\n      incident.productId,\\n      address(uint160(coverOwner)),\\n      coveredTokenAmount,\\n      coverAsset,\\n      payoutAmount\\n    );\\n\\n    qd.subFromTotalSumAssured(currency, sumAssured);\\n    qd.subFromTotalSumAssuredSC(incident.productId, currency, sumAssured);\\n\\n    mcr().updateMCRInternal(pool().getPoolValueInEth(), true);\\n  }\\n\\n  function pushBurns(address productId, uint maxIterations) external {\\n\\n    uint burnAmount = accumulatedBurn[productId];\\n    delete accumulatedBurn[productId];\\n\\n    require(burnAmount > 0, \\\"Incidents: No burns to push\\\");\\n    require(maxIterations >= 30, \\\"Incidents: Pass at least 30 iterations\\\");\\n\\n    IPooledStaking ps = pooledStaking();\\n    ps.pushBurn(productId, burnAmount);\\n    ps.processPendingActions(maxIterations);\\n  }\\n\\n  function withdrawAsset(address asset, address destination, uint amount) external onlyGovernance {\\n    IERC20 token = IERC20(asset);\\n    uint balance = token.balanceOf(address(this));\\n    uint transferAmount = amount > balance ? balance : amount;\\n    token.safeTransfer(destination, transferAmount);\\n  }\\n\\n  function _sendPayoutAndPushBurn(\\n    address productId,\\n    address payable coverOwner,\\n    uint coveredTokenAmount,\\n    address coverAsset,\\n    uint payoutAmount\\n  ) internal {\\n\\n    address _coveredToken = coveredToken[productId];\\n\\n    // pull depegged tokens\\n    IERC20(_coveredToken).safeTransferFrom(msg.sender, address(this), coveredTokenAmount);\\n\\n    Pool p1 = pool();\\n\\n    // send the payoutAmount\\n    {\\n      address payable payoutAddress = memberRoles().getClaimPayoutAddress(coverOwner);\\n      bool success = p1.sendClaimPayout(coverAsset, payoutAddress, payoutAmount);\\n      require(success, \\\"Incidents: Payout failed\\\");\\n    }\\n\\n    {\\n      // burn\\n      uint decimalPrecision = 1e18;\\n      uint assetPerNxm = p1.getTokenPrice(coverAsset);\\n      uint maxBurnAmount = payoutAmount.mul(decimalPrecision).div(assetPerNxm);\\n      uint burnAmount = maxBurnAmount.mul(BURN_RATIO).div(BASIS_PRECISION);\\n\\n      accumulatedBurn[productId] = accumulatedBurn[productId].add(burnAmount);\\n    }\\n  }\\n\\n  function claimsData() internal view returns (ClaimsData) {\\n    return ClaimsData(internalContracts[uint(ID.CD)]);\\n  }\\n\\n  function claimsReward() internal view returns (ClaimsReward) {\\n    return ClaimsReward(internalContracts[uint(ID.CR)]);\\n  }\\n\\n  function quotationData() internal view returns (QuotationData) {\\n    return QuotationData(internalContracts[uint(ID.QD)]);\\n  }\\n\\n  function tokenController() internal view returns (TokenController) {\\n    return TokenController(internalContracts[uint(ID.TC)]);\\n  }\\n\\n  function memberRoles() internal view returns (MemberRoles) {\\n    return MemberRoles(internalContracts[uint(ID.MR)]);\\n  }\\n\\n  function pool() internal view returns (Pool) {\\n    return Pool(internalContracts[uint(ID.P1)]);\\n  }\\n\\n  function pooledStaking() internal view returns (IPooledStaking) {\\n    return IPooledStaking(internalContracts[uint(ID.PS)]);\\n  }\\n\\n  function mcr() internal view returns (MCR) {\\n    return MCR(internalContracts[uint(ID.MC)]);\\n  }\\n\\n  function updateUintParameters(bytes8 code, uint value) external onlyGovernance {\\n\\n    if (code == \\\"BURNRATE\\\") {\\n      require(value <= BASIS_PRECISION, \\\"Incidents: Burn ratio cannot exceed 10000\\\");\\n      BURN_RATIO = value;\\n      return;\\n    }\\n\\n    if (code == \\\"DEDUCTIB\\\") {\\n      require(value <= BASIS_PRECISION, \\\"Incidents: Deductible ratio cannot exceed 10000\\\");\\n      DEDUCTIBLE_RATIO = value;\\n      return;\\n    }\\n\\n    revert(\\\"Incidents: Invalid parameter\\\");\\n  }\\n\\n  function changeDependentContractAddress() external {\\n    INXMMaster master = INXMMaster(master);\\n    internalContracts[uint(ID.CD)] = master.getLatestAddress(\\\"CD\\\");\\n    internalContracts[uint(ID.CR)] = master.getLatestAddress(\\\"CR\\\");\\n    internalContracts[uint(ID.QD)] = master.getLatestAddress(\\\"QD\\\");\\n    internalContracts[uint(ID.TC)] = master.getLatestAddress(\\\"TC\\\");\\n    internalContracts[uint(ID.MR)] = master.getLatestAddress(\\\"MR\\\");\\n    internalContracts[uint(ID.P1)] = master.getLatestAddress(\\\"P1\\\");\\n    internalContracts[uint(ID.PS)] = master.getLatestAddress(\\\"PS\\\");\\n    internalContracts[uint(ID.MC)] = master.getLatestAddress(\\\"MC\\\");\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/capital/LegacyMCR.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\ninterface LegacyMCR {\\n  function addMCRData(uint mcrP, uint mcrE, uint vF, bytes4[] calldata curr, uint[] calldata _threeDayAvg, uint64 onlyDate) external;\\n  function addLastMCRData(uint64 date) external;\\n  function changeDependentContractAddress() external;\\n  function getAllSumAssurance() external view returns (uint amount);\\n  function _calVtpAndMCRtp(uint poolBalance) external view returns (uint vtp, uint mcrtp);\\n  function calculateStepTokenPrice(bytes4 curr, uint mcrtp) external view returns (uint tokenPrice);\\n  function calculateTokenPrice(bytes4 curr) external view returns (uint tokenPrice);\\n  function calVtpAndMCRtp() external view returns (uint vtp, uint mcrtp);\\n  function calculateVtpAndMCRtp(uint poolBalance) external view returns (uint vtp, uint mcrtp);\\n  function getThresholdValues(uint vtp, uint vF, uint totalSA, uint minCap) external view returns (uint lowerThreshold, uint upperThreshold);\\n  function getMaxSellTokens() external view returns (uint maxTokens);\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val);\\n  function updateUintParameters(bytes8 code, uint val) external;\\n\\n  function variableMincap() external view returns (uint);\\n  function dynamicMincapThresholdx100() external view returns (uint);\\n  function dynamicMincapIncrementx100() external view returns (uint);\\n\\n  function getLastMCREther() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/modules/governance/external/IProposalCategory.sol\": {\r\n      \"content\": \"/* Copyright (C) 2017 GovBlocks.io\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\ncontract IProposalCategory {\\n\\n  event Category(\\n    uint indexed categoryId,\\n    string categoryName,\\n    string actionHash\\n  );\\n\\n  /// @dev Adds new category\\n  /// @param _name Category name\\n  /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\\n  /// @param _allowedToCreateProposal Member roles allowed to create the proposal\\n  /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\\n  /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\\n  /// @param _closingTime Vote closing time for Each voting layer\\n  /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\\n  /// @param _contractAddress address of contract to call after proposal is accepted\\n  /// @param _contractName name of contract to be called after proposal is accepted\\n  /// @param _incentives rewards to distributed after proposal is accepted\\n  function addCategory(\\n    string calldata _name,\\n    uint _memberRoleToVote,\\n    uint _majorityVotePerc,\\n    uint _quorumPerc,\\n    uint[] calldata _allowedToCreateProposal,\\n    uint _closingTime,\\n    string calldata _actionHash,\\n    address _contractAddress,\\n    bytes2 _contractName,\\n    uint[] calldata _incentives\\n  )\\n  external;\\n\\n  /// @dev gets category details\\n  function category(uint _categoryId)\\n  external\\n  view\\n  returns (\\n    uint categoryId,\\n    uint memberRoleToVote,\\n    uint majorityVotePerc,\\n    uint quorumPerc,\\n    uint[] memory allowedToCreateProposal,\\n    uint closingTime,\\n    uint minStake\\n  );\\n\\n  ///@dev gets category action details\\n  function categoryAction(uint _categoryId)\\n  external\\n  view\\n  returns (\\n    uint categoryId,\\n    address contractAddress,\\n    bytes2 contractName,\\n    uint defaultIncentive\\n  );\\n\\n  /// @dev Gets Total number of categories added till now\\n  function totalCategories() external view returns (uint numberOfCategories);\\n\\n  /// @dev Updates category details\\n  /// @param _categoryId Category id that needs to be updated\\n  /// @param _name Category name\\n  /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\\n  /// @param _allowedToCreateProposal Member roles allowed to create the proposal\\n  /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\\n  /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\\n  /// @param _closingTime Vote closing time for Each voting layer\\n  /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\\n  /// @param _contractAddress address of contract to call after proposal is accepted\\n  /// @param _contractName name of contract to be called after proposal is accepted\\n  /// @param _incentives rewards to distributed after proposal is accepted\\n  function updateCategory(\\n    uint _categoryId,\\n    string memory _name,\\n    uint _memberRoleToVote,\\n    uint _majorityVotePerc,\\n    uint _quorumPerc,\\n    uint[] memory _allowedToCreateProposal,\\n    uint _closingTime,\\n    string memory _actionHash,\\n    address _contractAddress,\\n    bytes2 _contractName,\\n    uint[] memory _incentives\\n  )\\n  public;\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"closeProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"memberProposalVote\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"proposalRejectedByAB\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeDependentContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"name\":\"_solution\",\"type\":\"uint256\"}],\"name\":\"voteTallyData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"proposalDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalTitle\",\"type\":\"string\"},{\"name\":\"_proposalSD\",\"type\":\"string\"},{\"name\":\"_proposalDescHash\",\"type\":\"string\"},{\"name\":\"_categoryId\",\"type\":\"uint256\"},{\"name\":\"_solutionHash\",\"type\":\"string\"},{\"name\":\"_action\",\"type\":\"bytes\"}],\"name\":\"createProposalwithSolution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_memberAddress\",\"type\":\"address\"},{\"name\":\"_maxRecords\",\"type\":\"uint256\"}],\"name\":\"claimReward\",\"outputs\":[{\"name\":\"pendingDAppReward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalActionStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setDelegationStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"rejectAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"name\":\"_solution\",\"type\":\"uint256\"}],\"name\":\"getSolutionAction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"proposal\",\"outputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"},{\"name\":\"category\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint256\"},{\"name\":\"finalVerdict\",\"type\":\"uint256\"},{\"name\":\"totalRewar\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenHoldingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalTitle\",\"type\":\"string\"},{\"name\":\"_proposalSD\",\"type\":\"string\"},{\"name\":\"_proposalDescHash\",\"type\":\"string\"},{\"name\":\"_categoryId\",\"type\":\"uint256\"}],\"name\":\"createProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_memberAddress\",\"type\":\"address\"}],\"name\":\"getPendingReward\",\"outputs\":[{\"name\":\"pendingDAppReward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"code\",\"type\":\"bytes8\"}],\"name\":\"getUintParameters\",\"outputs\":[{\"name\":\"codeVal\",\"type\":\"bytes8\"},{\"name\":\"val\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"name\":\"_categoryId\",\"type\":\"uint256\"},{\"name\":\"_incentive\",\"type\":\"uint256\"}],\"name\":\"categorizeProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"name\":\"_solutionChosen\",\"type\":\"uint256\"}],\"name\":\"submitVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"name\":\"_solutionHash\",\"type\":\"string\"},{\"name\":\"_action\",\"type\":\"bytes\"}],\"name\":\"submitProposalWithSolution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"followerDelegation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProposalLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"code\",\"type\":\"bytes8\"},{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"updateUintParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"category\",\"type\":\"uint256\"}],\"name\":\"allowedToCreateProposal\",\"outputs\":[{\"name\":\"check\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ms\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowedToCatgorize\",\"outputs\":[{\"name\":\"roleId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"delegateVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allDelegation\",\"outputs\":[{\"name\":\"follower\",\"type\":\"address\"},{\"name\":\"leader\",\"type\":\"address\"},{\"name\":\"lastUpd\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"canCloseProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"getFollowers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"triggerAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setInitialActionParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_masterAddress\",\"type\":\"address\"}],\"name\":\"changeMasterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOpenForDelegation\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastRewardClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"name\":\"_proposalTitle\",\"type\":\"string\"},{\"name\":\"_proposalSD\",\"type\":\"string\"},{\"name\":\"_proposalDescHash\",\"type\":\"string\"}],\"name\":\"updateProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalVoteTally\",\"outputs\":[{\"name\":\"voters\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"removeDelegation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nxMasterAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"alreadyDelegated\",\"outputs\":[{\"name\":\"delegated\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"ActionFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rejectedBy\",\"type\":\"address\"}],\"name\":\"ActionRejected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"categorizedBy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"categoryId\",\"type\":\"uint256\"}],\"name\":\"ProposalCategorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dateAdd\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"proposalTitle\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"proposalSD\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"proposalDescHash\",\"type\":\"string\"}],\"name\":\"Proposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"solutionOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"solutionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"solutionDescHash\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"dateAdd\",\"type\":\"uint256\"}],\"name\":\"Solution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"voteId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dateAdd\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"solutionChosen\",\"type\":\"uint256\"}],\"name\":\"Vote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"gbtReward\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"VoteCast\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"ProposalAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"CloseProposalOnTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"ActionSuccess\",\"type\":\"event\"}]","ContractName":"Governance","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}