{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: NONE\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\n\n\n// Part: BytesLibrary\n\nlibrary BytesLibrary {\n    function toString(bytes32 value) internal pure returns (string memory) {\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(64);\n        for (uint256 i = 0; i < 32; i++) {\n            str[i*2] = alphabet[uint8(value[i] >> 4)];\n            str[1+i*2] = alphabet[uint8(value[i] & 0x0f)];\n        }\n        return string(str);\n    }\n}\n\n// Part: Context\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// Part: ExchangeDomainV1\n\n//pragma experimental ABIEncoderV2;\n\ncontract ExchangeDomainV1 {\n\n    enum AssetType {ETH, ERC20, ERC1155, ERC721, ERC721Deprecated}\n\n    struct Asset {\n        address token;\n        uint tokenId;\n        AssetType assetType;\n    }\n\n    struct OrderKey {\n        /* who signed the order */\n        address owner;\n        /* random number */\n        uint salt;\n\n        /* what has owner */\n        Asset sellAsset;\n\n        /* what wants owner */\n        Asset buyAsset;\n    }\n\n    struct Order {\n        OrderKey key;\n\n        /* how much has owner (in wei, or UINT256_MAX if ERC-721) */\n        uint selling;\n        /* how much wants owner (in wei, or UINT256_MAX if ERC-721) */\n        uint buying;\n\n        /* fee for selling */\n        uint sellerFee;\n    }\n\n    /* An ECDSA signature. */\n    struct Sig {\n        /* v parameter */\n        uint8 v;\n        /* r parameter */\n        bytes32 r;\n        /* s parameter */\n        bytes32 s;\n    }\n}\n\n// Part: ExchangeOrdersHolderV1\n\ncontract ExchangeOrdersHolderV1 {\n\n    mapping(bytes32 => OrderParams) internal orders;\n\n    struct OrderParams {\n        /* how much has owner (in wei, or UINT256_MAX if ERC-721) */\n        uint selling;\n        /* how much wants owner (in wei, or UINT256_MAX if ERC-721) */\n        uint buying;\n\n        /* fee for selling */\n        uint sellerFee;\n    }\n\n    function add(ExchangeDomainV1.Order calldata order) external {\n        require(msg.sender == order.key.owner, \"order could be added by owner only\");\n        bytes32 key = prepareKey(order);\n        orders[key] = OrderParams(order.selling, order.buying, order.sellerFee);\n    }\n\n    function exists(ExchangeDomainV1.Order calldata order) external view returns (bool) {\n        bytes32 key = prepareKey(order);\n        OrderParams memory params = orders[key];\n        return params.buying == order.buying && params.selling == order.selling && params.sellerFee == order.sellerFee;\n    }\n\n    function prepareKey(ExchangeDomainV1.Order memory order) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n                order.key.sellAsset.token,\n                order.key.sellAsset.tokenId,\n                order.key.owner,\n                order.key.buyAsset.token,\n                order.key.buyAsset.tokenId,\n                order.key.salt\n            ));\n    }\n}\n\n// Part: IERC165\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\n\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// Part: IERC20\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// Part: Roles\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n// Part: SafeMath\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n// Part: ERC165\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n// Part: IERC1155\n\n/**\n    @title ERC-1155 Multi Token Standard\n    @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md\n    Note: The ERC-165 identifier for this interface is 0xd9b67a26.\n */\ncontract IERC1155 is IERC165 {\n    /**\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n        The `_operator` argument MUST be msg.sender.\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\n        The `_id` argument MUST be the token type being transferred.\n        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    */\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\n\n    /**\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n        The `_operator` argument MUST be msg.sender.\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\n        The `_ids` argument MUST be the list of tokens being transferred.\n        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    */\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\n\n    /**\n        @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absense of an event assumes disabled).\n    */\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /**\n        @dev MUST emit when the URI is updated for a token ID.\n        URIs are defined in RFC 3986.\n        The URI MUST point a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\n    */\n    event URI(string _value, uint256 indexed _id);\n\n    /**\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\n        MUST revert on any other error.\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param _from    Source address\n        @param _to      Target address\n        @param _id      ID of the token type\n        @param _value   Transfer amount\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\n    */\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\n\n    /**\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if length of `_ids` is not the same as length of `_values`.\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\n        MUST revert on any other error.\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param _from    Source address\n        @param _to      Target address\n        @param _ids     IDs of each token type (order and length must match _values array)\n        @param _values  Transfer amounts per token type (order and length must match _ids array)\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\n    */\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\n\n    /**\n        @notice Get the balance of an account's Tokens.\n        @param _owner  The address of the token holder\n        @param _id     ID of the Token\n        @return        The _owner's balance of the Token type requested\n     */\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n    /**\n        @notice Get the balance of multiple account/token pairs\n        @param _owners The addresses of the token holders\n        @param _ids    ID of the Tokens\n        @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\n     */\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n\n    /**\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n        @dev MUST emit the ApprovalForAll event on success.\n        @param _operator  Address to add to the set of authorized operators\n        @param _approved  True if the operator is approved, false to revoke approval\n    */\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /**\n        @notice Queries the approval status of an operator for a given owner.\n        @param _owner     The owner of the Tokens\n        @param _operator  Address of authorized operator\n        @return           True if the operator is approved, false if not\n    */\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n// Part: IERC721\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\n// Part: OperatorRole\n\ncontract OperatorRole is Context {\n    using Roles for Roles.Role;\n\n    event OperatorAdded(address indexed account);\n    event OperatorRemoved(address indexed account);\n\n    Roles.Role private _operators;\n\n    constructor () internal {\n\n    }\n\n    modifier onlyOperator() {\n        require(isOperator(_msgSender()), \"OperatorRole: caller does not have the Operator role\");\n        _;\n    }\n\n    function isOperator(address account) public view returns (bool) {\n        return _operators.has(account);\n    }\n\n    function _addOperator(address account) internal {\n        _operators.add(account);\n        emit OperatorAdded(account);\n    }\n\n    function _removeOperator(address account) internal {\n        _operators.remove(account);\n        emit OperatorRemoved(account);\n    }\n}\n\n// Part: Ownable\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// Part: UintLibrary\n\nlibrary UintLibrary {\n    using SafeMath for uint;\n\n\n    function toString(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = byte(uint8(48 + _i % 10));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    function bp(uint value, uint bpValue) internal pure returns (uint) {\n        return value.mul(bpValue).div(10000);\n    }\n}\n\n// Part: HasSecondarySaleFees\n\ncontract HasSecondarySaleFees is ERC165 {\n\n    event SecondarySaleFees(uint256 tokenId, address[] recipients, uint[] bps);\n\n    /*\n     * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f\n     * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\n     *\n     * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584\n     */\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\n\n    constructor() public {\n        _registerInterface(_INTERFACE_ID_FEES);\n    }\n\n    function getFeeRecipients(uint256 id) public view returns (address payable[] memory);\n    function getFeeBps(uint256 id) public view returns (uint[] memory);\n}\n\n// Part: OwnableOperatorRole\n\ncontract OwnableOperatorRole is Ownable, OperatorRole {\n    function addOperator(address account) external onlyOwner {\n        _addOperator(account);\n    }\n\n    function removeOperator(address account) external onlyOwner {\n        _removeOperator(account);\n    }\n}\n\n// Part: StringLibrary\n\nlibrary StringLibrary {\n    using UintLibrary for uint256;\n\n    function append(string memory _a, string memory _b) internal pure returns (string memory) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory bab = new bytes(_ba.length + _bb.length);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\n        for (uint i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\n        return string(bab);\n    }\n\n    function append(string memory _a, string memory _b, string memory _c) internal pure returns (string memory) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory bbb = new bytes(_ba.length + _bb.length + _bc.length);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) bbb[k++] = _ba[i];\n        for (uint i = 0; i < _bb.length; i++) bbb[k++] = _bb[i];\n        for (uint i = 0; i < _bc.length; i++) bbb[k++] = _bc[i];\n        return string(bbb);\n    }\n\n    function recover(string memory message, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        bytes memory msgBytes = bytes(message);\n        bytes memory fullMessage = concat(\n            bytes(\"\\x19Ethereum Signed Message:\\n\"),\n            bytes(msgBytes.length.toString()),\n            msgBytes,\n            new bytes(0), new bytes(0), new bytes(0), new bytes(0)\n        );\n        return ecrecover(keccak256(fullMessage), v, r, s);\n    }\n\n    function concat(bytes memory _ba, bytes memory _bb, bytes memory _bc, bytes memory _bd, bytes memory _be, bytes memory _bf, bytes memory _bg) internal pure returns (bytes memory) {\n        bytes memory resultBytes = new bytes(_ba.length + _bb.length + _bc.length + _bd.length + _be.length + _bf.length + _bg.length);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) resultBytes[k++] = _ba[i];\n        for (uint i = 0; i < _bb.length; i++) resultBytes[k++] = _bb[i];\n        for (uint i = 0; i < _bc.length; i++) resultBytes[k++] = _bc[i];\n        for (uint i = 0; i < _bd.length; i++) resultBytes[k++] = _bd[i];\n        for (uint i = 0; i < _be.length; i++) resultBytes[k++] = _be[i];\n        for (uint i = 0; i < _bf.length; i++) resultBytes[k++] = _bf[i];\n        for (uint i = 0; i < _bg.length; i++) resultBytes[k++] = _bg[i];\n        return resultBytes;\n    }\n}\n\n// Part: ERC20TransferProxy\n\ncontract ERC20TransferProxy is OwnableOperatorRole {\n\n    function erc20safeTransferFrom(IERC20 token, address from, address to, uint256 value) external onlyOperator {\n        require(token.transferFrom(from, to, value), \"failure while transferring\");\n    }\n}\n\n// Part: ExchangeStateV1\n\ncontract ExchangeStateV1 is OwnableOperatorRole {\n\n    // keccak256(OrderKey) => completed\n    mapping(bytes32 => uint256) public completed;\n\n    function getCompleted(ExchangeDomainV1.OrderKey calldata key) view external returns (uint256) {\n        return completed[getCompletedKey(key)];\n    }\n\n    function setCompleted(ExchangeDomainV1.OrderKey calldata key, uint256 newCompleted) external onlyOperator {\n        completed[getCompletedKey(key)] = newCompleted;\n    }\n\n    function getCompletedKey(ExchangeDomainV1.OrderKey memory key) pure public returns (bytes32) {\n        return keccak256(abi.encodePacked(key.owner, key.sellAsset.token, key.sellAsset.tokenId, key.buyAsset.token, key.buyAsset.tokenId, key.salt));\n    }\n}\n\n// Part: TransferProxy\n\ncontract TransferProxy is OwnableOperatorRole {\n\n    function erc721safeTransferFrom(IERC721 token, address from, address to, uint256 tokenId) external onlyOperator {\n        token.safeTransferFrom(from, to, tokenId);\n    }\n\n    function erc1155safeTransferFrom(IERC1155 token, address from, address to, uint256 id, uint256 value, bytes calldata data) external onlyOperator {\n        token.safeTransferFrom(from, to, id, value, data);\n    }\n}\n\n// Part: TransferProxyForDeprecated\n\ncontract TransferProxyForDeprecated is OwnableOperatorRole {\n\n    function erc721TransferFrom(IERC721 token, address from, address to, uint256 tokenId) external onlyOperator {\n        token.transferFrom(from, to, tokenId);\n    }\n}\n\n// File: ExchangeV1.sol\n\ncontract ExchangeV1 is Ownable, ExchangeDomainV1 {\n    using SafeMath for uint;\n    using UintLibrary for uint;\n    using StringLibrary for string;\n    using BytesLibrary for bytes32;\n\n    enum FeeSide {NONE, SELL, BUY}\n\n    event Buy(\n        address indexed sellToken, uint256 indexed sellTokenId, uint256 sellValue,\n        address owner,\n        address buyToken, uint256 buyTokenId, uint256 buyValue,\n        address buyer,\n        uint256 amount,\n        uint256 salt\n    );\n\n    event Cancel(\n        address indexed sellToken, uint256 indexed sellTokenId,\n        address owner,\n        address buyToken, uint256 buyTokenId,\n        uint256 salt\n    );\n\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\n    uint256 private constant UINT256_MAX = 2 ** 256 - 1;\n\n    address payable public beneficiary;\n    address public buyerFeeSigner;\n\n    TransferProxy public transferProxy;\n    TransferProxyForDeprecated public transferProxyForDeprecated;\n    ERC20TransferProxy public erc20TransferProxy;\n    ExchangeStateV1 public state;\n    ExchangeOrdersHolderV1 public ordersHolder;\n\n    constructor(\n        TransferProxy _transferProxy, TransferProxyForDeprecated _transferProxyForDeprecated, ERC20TransferProxy _erc20TransferProxy, ExchangeStateV1 _state,\n        ExchangeOrdersHolderV1 _ordersHolder, address payable _beneficiary, address _buyerFeeSigner\n    ) public {\n        transferProxy = _transferProxy;\n        transferProxyForDeprecated = _transferProxyForDeprecated;\n        erc20TransferProxy = _erc20TransferProxy;\n        state = _state;\n        ordersHolder = _ordersHolder;\n        beneficiary = _beneficiary;\n        buyerFeeSigner = _buyerFeeSigner;\n    }\n\n    function setBeneficiary(address payable newBeneficiary) external onlyOwner {\n        beneficiary = newBeneficiary;\n    }\n\n    function setBuyerFeeSigner(address newBuyerFeeSigner) external onlyOwner {\n        buyerFeeSigner = newBuyerFeeSigner;\n    }\n\n    function exchange(\n        Order calldata order,\n        Sig calldata sig,\n        uint buyerFee,\n        Sig calldata buyerFeeSig,\n        uint amount,\n        address buyer\n    ) payable external {\n        validateOrderSig(order, sig);\n        validateBuyerFeeSig(order, buyerFee, buyerFeeSig);\n        uint paying = order.buying.mul(amount).div(order.selling);\n        verifyOpenAndModifyOrderState(order.key, order.selling, amount);\n        require(order.key.sellAsset.assetType != AssetType.ETH, \"ETH is not supported on sell side\");\n        if (order.key.buyAsset.assetType == AssetType.ETH) {\n            validateEthTransfer(paying, buyerFee);\n        }\n        FeeSide feeSide = getFeeSide(order.key.sellAsset.assetType, order.key.buyAsset.assetType);\n        if (buyer == address(0x0)) {\n            buyer = msg.sender;\n        }\n        transferWithFeesPossibility(order.key.sellAsset, amount, order.key.owner, buyer, feeSide == FeeSide.SELL, buyerFee, order.sellerFee, order.key.buyAsset);\n        transferWithFeesPossibility(order.key.buyAsset, paying, msg.sender, order.key.owner, feeSide == FeeSide.BUY, order.sellerFee, buyerFee, order.key.sellAsset);\n        emitBuy(order, amount, buyer);\n    }\n\n    function validateEthTransfer(uint value, uint buyerFee) internal view {\n        uint256 buyerFeeValue = value.bp(buyerFee);\n        require(msg.value == value + buyerFeeValue, \"msg.value is incorrect\");\n    }\n\n    function cancel(OrderKey calldata key) external {\n        require(key.owner == msg.sender, \"not an owner\");\n        state.setCompleted(key, UINT256_MAX);\n        emit Cancel(key.sellAsset.token, key.sellAsset.tokenId, msg.sender, key.buyAsset.token, key.buyAsset.tokenId, key.salt);\n    }\n\n    function validateOrderSig(\n        Order memory order,\n        Sig memory sig\n    ) internal view {\n        if (sig.v == 0 && sig.r == bytes32(0x0) && sig.s == bytes32(0x0)) {\n            require(ordersHolder.exists(order), \"incorrect signature\");\n        } else {\n            require(prepareMessage(order).recover(sig.v, sig.r, sig.s) == order.key.owner, \"incorrect signature\");\n        }\n    }\n\n    function validateBuyerFeeSig(\n        Order memory order,\n        uint buyerFee,\n        Sig memory sig\n    ) internal view {\n        require(prepareBuyerFeeMessage(order, buyerFee).recover(sig.v, sig.r, sig.s) == buyerFeeSigner, \"incorrect buyer fee signature\");\n    }\n\n    function prepareBuyerFeeMessage(Order memory order, uint fee) public pure returns (string memory) {\n        return keccak256(abi.encode(order, fee)).toString();\n    }\n\n    function prepareMessage(Order memory order) public pure returns (string memory) {\n        return keccak256(abi.encode(order)).toString();\n    }\n\n    function transferWithFeesPossibility(Asset memory firstType, uint value, address from, address to, bool hasFee, uint256 sellerFee, uint256 buyerFee, Asset memory secondType) internal {\n        if (!hasFee) {\n            transfer(firstType, value, from, to);\n        } else {\n            transferWithFees(firstType, value, from, to, sellerFee, buyerFee, secondType);\n        }\n    }\n\n    function transfer(Asset memory asset, uint value, address from, address to) internal {\n        if (asset.assetType == AssetType.ETH) {\n            address payable toPayable = address(uint160(to));\n            toPayable.transfer(value);\n        } else if (asset.assetType == AssetType.ERC20) {\n            require(asset.tokenId == 0, \"tokenId should be 0\");\n            erc20TransferProxy.erc20safeTransferFrom(IERC20(asset.token), from, to, value);\n        } else if (asset.assetType == AssetType.ERC721) {\n            require(value == 1, \"value should be 1 for ERC-721\");\n            transferProxy.erc721safeTransferFrom(IERC721(asset.token), from, to, asset.tokenId);\n        } else if (asset.assetType == AssetType.ERC721Deprecated) {\n            require(value == 1, \"value should be 1 for ERC-721\");\n            transferProxyForDeprecated.erc721TransferFrom(IERC721(asset.token), from, to, asset.tokenId);\n        } else {\n            transferProxy.erc1155safeTransferFrom(IERC1155(asset.token), from, to, asset.tokenId, value, \"\");\n        }\n    }\n\n    function transferWithFees(Asset memory firstType, uint value, address from, address to, uint256 sellerFee, uint256 buyerFee, Asset memory secondType) internal {\n        uint restValue = transferFeeToBeneficiary(firstType, from, value, sellerFee, buyerFee);\n        if (\n            secondType.assetType == AssetType.ERC1155 && IERC1155(secondType.token).supportsInterface(_INTERFACE_ID_FEES) ||\n            (secondType.assetType == AssetType.ERC721 || secondType.assetType == AssetType.ERC721Deprecated) && IERC721(secondType.token).supportsInterface(_INTERFACE_ID_FEES)\n        ) {\n            HasSecondarySaleFees withFees = HasSecondarySaleFees(secondType.token);\n            address payable[] memory recipients = withFees.getFeeRecipients(secondType.tokenId);\n            uint[] memory fees = withFees.getFeeBps(secondType.tokenId);\n            require(fees.length == recipients.length);\n            for (uint256 i = 0; i < fees.length; i++) {\n                (uint newRestValue, uint current) = subFeeInBp(restValue, value, fees[i]);\n                restValue = newRestValue;\n                transfer(firstType, current, from, recipients[i]);\n            }\n        }\n        address payable toPayable = address(uint160(to));\n        transfer(firstType, restValue, from, toPayable);\n    }\n\n    function transferFeeToBeneficiary(Asset memory asset, address from, uint total, uint sellerFee, uint buyerFee) internal returns (uint) {\n        (uint restValue, uint sellerFeeValue) = subFeeInBp(total, total, sellerFee);\n        uint buyerFeeValue = total.bp(buyerFee);\n        uint beneficiaryFee = buyerFeeValue.add(sellerFeeValue);\n        if (beneficiaryFee > 0) {\n            transfer(asset, beneficiaryFee, from, beneficiary);\n        }\n        return restValue;\n    }\n\n    function emitBuy(Order memory order, uint amount, address buyer) internal {\n        emit Buy(order.key.sellAsset.token, order.key.sellAsset.tokenId, order.selling,\n            order.key.owner,\n            order.key.buyAsset.token, order.key.buyAsset.tokenId, order.buying,\n            buyer,\n            amount,\n            order.key.salt\n        );\n    }\n\n    function subFeeInBp(uint value, uint total, uint feeInBp) internal pure returns (uint newValue, uint realFee) {\n        return subFee(value, total.bp(feeInBp));\n    }\n\n    function subFee(uint value, uint fee) internal pure returns (uint newValue, uint realFee) {\n        if (value > fee) {\n            newValue = value - fee;\n            realFee = fee;\n        } else {\n            newValue = 0;\n            realFee = value;\n        }\n    }\n\n    function verifyOpenAndModifyOrderState(OrderKey memory key, uint selling, uint amount) internal {\n        uint completed = state.getCompleted(key);\n        uint newCompleted = completed.add(amount);\n        require(newCompleted <= selling, \"not enough stock of order for buying\");\n        state.setCompleted(key, newCompleted);\n    }\n\n    function getFeeSide(AssetType sellType, AssetType buyType) internal pure returns (FeeSide) {\n        if ((sellType == AssetType.ERC721 || sellType == AssetType.ERC721Deprecated) &&\n            (buyType == AssetType.ERC721 || buyType == AssetType.ERC721Deprecated)) {\n            return FeeSide.NONE;\n        }\n        if (uint(sellType) > uint(buyType)) {\n            return FeeSide.BUY;\n        }\n        return FeeSide.SELL;\n    }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"contract TransferProxy\",\"name\":\"_transferProxy\",\"type\":\"address\"},{\"internalType\":\"contract TransferProxyForDeprecated\",\"name\":\"_transferProxyForDeprecated\",\"type\":\"address\"},{\"internalType\":\"contract ERC20TransferProxy\",\"name\":\"_erc20TransferProxy\",\"type\":\"address\"},{\"internalType\":\"contract ExchangeStateV1\",\"name\":\"_state\",\"type\":\"address\"},{\"internalType\":\"contract ExchangeOrdersHolderV1\",\"name\":\"_ordersHolder\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyerFeeSigner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"sellTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"sellTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyerFeeSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomainV1.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomainV1.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomainV1.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomainV1.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"}],\"internalType\":\"struct ExchangeDomainV1.OrderKey\",\"name\":\"key\",\"type\":\"tuple\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc20TransferProxy\",\"outputs\":[{\"internalType\":\"contract ERC20TransferProxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomainV1.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomainV1.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomainV1.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomainV1.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"}],\"internalType\":\"struct ExchangeDomainV1.OrderKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"selling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ExchangeDomainV1.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ExchangeDomainV1.Sig\",\"name\":\"sig\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"buyerFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ExchangeDomainV1.Sig\",\"name\":\"buyerFeeSig\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"exchange\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ordersHolder\",\"outputs\":[{\"internalType\":\"contract ExchangeOrdersHolderV1\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomainV1.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomainV1.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomainV1.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomainV1.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"}],\"internalType\":\"struct ExchangeDomainV1.OrderKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"selling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ExchangeDomainV1.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"prepareBuyerFeeMessage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomainV1.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomainV1.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomainV1.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomainV1.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"}],\"internalType\":\"struct ExchangeDomainV1.OrderKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"selling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ExchangeDomainV1.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"prepareMessage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBuyerFeeSigner\",\"type\":\"address\"}],\"name\":\"setBuyerFeeSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"contract ExchangeStateV1\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferProxy\",\"outputs\":[{\"internalType\":\"contract TransferProxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferProxyForDeprecated\",\"outputs\":[{\"internalType\":\"contract TransferProxyForDeprecated\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ExchangeV1","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000019b99162adaab85134e781ac0048c275c31b205a0000000000000000000000000d7b1c73af02531ae521cd2017000f34eb83495b000000000000000000000000db1feb360e0655061088267d786c875e7141850d000000000000000000000000f5a90b39f9f0c2509e62a42eae365ab0f2e886ed000000000000000000000000cd9db6021749f25f13a6d4ff7d950d33bcb714e2000000000000000000000000e527fcfc19ca2865afeeed0a174203c371231c36000000000000000000000000418bd146d56a54dfcc1dfb44890cde870c50df4f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}