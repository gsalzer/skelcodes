{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/ivannikov/work/snake-jungle/cup/contracts/Approvable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n//pragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n */\\nabstract contract Approvable is Context {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using SafeMath for uint256;\\n\\n    EnumerableSet.AddressSet _approvers;\\n    mapping(address => uint256) private _weights;\\n    uint256 private _totalWeight;\\n    uint256 private _threshold;\\n\\n\\n    struct GrantApprover {\\n        uint256 id;\\n        bool executed;\\n        address account;\\n        uint256 weight;\\n        uint256 approvalsWeight;\\n    }\\n    GrantApprover[] private _grantApprovers;\\n    mapping(address => mapping(uint256 => bool)) private _approvalsGrantApprover;\\n\\n\\n    struct ChangeApproverWeight {\\n        uint256 id;\\n        bool executed;\\n        address account;\\n        uint256 weight;\\n        uint256 approvalsWeight;\\n    }\\n    ChangeApproverWeight[] private _changeApproverWeights;\\n    mapping(address => mapping(uint256 => bool)) private _approvalsChangeApproverWeight;\\n\\n\\n    struct RevokeApprover {\\n        uint256 id;\\n        bool executed;\\n        address account;\\n        uint256 approvalsWeight;\\n    }\\n    RevokeApprover[] private _revokeApprovers;\\n    mapping(address => mapping(uint256 => bool)) private _approvalsRevokeApprover;\\n\\n\\n    struct ChangeThreshold {\\n        uint256 id;\\n        bool executed;\\n        uint256 threshold;\\n        uint256 approvalsWeight;\\n    }\\n    ChangeThreshold[] private _changeThresholds;\\n    mapping(address => mapping(uint256 => bool)) private _approvalsChangeThreshold;\\n\\n\\n    event NewGrantApprover(uint256 indexed id, address indexed account, uint256 weight);\\n    event VoteForGrantApprover(uint256 indexed id, address indexed voter, uint256 voterWeight, uint256 approvalsWeight);\\n    event ApproverGranted(address indexed account);\\n\\n    event NewChangeApproverWeight(uint256 indexed id, address indexed account, uint256 weight);\\n    event VoteForChangeApproverWeight(uint256 indexed id, address indexed voter, uint256 voterWeight, uint256 approvalsWeight);\\n    event ApproverWeightChanged(address indexed account, uint256 oldWeight, uint256 newWeight);\\n\\n    event NewRevokeApprover(uint256 indexed id, address indexed account);\\n    event VoteForRevokeApprover(uint256 indexed id, address indexed voter, uint256 voterWeight, uint256 approvalsWeight);\\n    event ApproverRevoked(address indexed account);\\n\\n    event NewChangeThreshold(uint256 indexed id, uint256 threshold);\\n    event VoteForChangeThreshold(uint256 indexed id, address indexed voter, uint256 voterWeight, uint256 approvalsWeight);\\n    event ThresholdChanged(uint256 oldThreshold, uint256 newThreshold);\\n\\n    event TotalWeightChanged(uint256 oldTotalWeight, uint256 newTotalWeight);\\n\\n\\n    function getThreshold() public view returns (uint256) {\\n        return _threshold;\\n    }\\n\\n    function getTotalWeight() public view returns (uint256) {\\n        return _totalWeight;\\n    }\\n\\n    function getApproversCount() public view returns (uint256) {\\n        return _approvers.length();\\n    }\\n\\n    function isApprover(address account) public view returns (bool) {\\n        return _approvers.contains(account);\\n    }\\n\\n    function getApprover(uint256 index) public view returns (address) {\\n        return _approvers.at(index);\\n    }\\n\\n    function getApproverWeight(address account) public view returns (uint256) {\\n        return _weights[account];\\n    }\\n\\n\\n    // GrantApprovers\\n    function getGrantApproversCount() public view returns (uint256) {\\n        return _grantApprovers.length;\\n    }\\n\\n    function getGrantApprover(uint256 id) public view returns (GrantApprover memory) {\\n        return _grantApprovers[id];\\n    }\\n\\n    // ChangeApproverWeights\\n    function getChangeApproverWeightsCount() public view returns (uint256) {\\n        return _changeApproverWeights.length;\\n    }\\n\\n    function getChangeApproverWeight(uint256 id) public view returns (ChangeApproverWeight memory) {\\n        return _changeApproverWeights[id];\\n    }\\n\\n    // RevokeApprovers\\n    function getRevokeApproversCount() public view returns (uint256) {\\n        return _revokeApprovers.length;\\n    }\\n\\n    function getRevokeApprover(uint256 id) public view returns (RevokeApprover memory) {\\n        return _revokeApprovers[id];\\n    }\\n\\n    // ChangeThresholds\\n    function getChangeThresholdsCount() public view returns (uint256) {\\n        return _changeThresholds.length;\\n    }\\n\\n    function getChangeThreshold(uint256 id) public view returns (ChangeThreshold memory) {\\n        return _changeThresholds[id];\\n    }\\n\\n\\n    // Grant Approver\\n    function grantApprover(address account, uint256 weight) public onlyApprover returns (uint256) {\\n        uint256 id = _addNewGrantApprover(account, weight);\\n        _voteForGrantApprover(id);\\n        return id;\\n    }\\n\\n    function _addNewGrantApprover(address account, uint256 weight) private returns (uint256) {\\n        require(account != address(0), \\\"Approvable: account is the zero address\\\");\\n        uint256 id = _grantApprovers.length;\\n        _grantApprovers.push(GrantApprover(id, false, account, weight, 0));\\n        emit NewGrantApprover(id, account, weight);\\n        return id;\\n    }\\n\\n    function _voteForGrantApprover(uint256 id) private returns (bool) {\\n        address msgSender = _msgSender();\\n        _approvalsGrantApprover[msgSender][id] = true;\\n        _grantApprovers[id].approvalsWeight = _grantApprovers[id].approvalsWeight.add(_weights[msgSender]);\\n        emit VoteForGrantApprover(id, msgSender, _weights[msgSender], _grantApprovers[id].approvalsWeight);\\n        return true;\\n    }\\n\\n    function _grantApprover(address account, uint256 weight) private returns (bool) {\\n        if (_approvers.add(account)) {\\n            _changeApproverWeight(account, weight);\\n            emit ApproverGranted(account);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function _setupApprover(address account, uint256 weight) internal returns (bool) {\\n        return _grantApprover(account, weight);\\n    }\\n\\n    function approveGrantApprover(uint256 id) public onlyApprover returns (bool) {\\n        require(_grantApprovers[id].executed == false, \\\"Approvable: action has already executed\\\");\\n        require(_approvalsGrantApprover[_msgSender()][id] == false, \\\"Approvable: Cannot approve action twice\\\");\\n        return _voteForGrantApprover(id);\\n    }\\n\\n    function confirmGrantApprover(uint256 id) public returns (bool) {\\n        require(_grantApprovers[id].account == _msgSender(), \\\"Approvable: only pending approver\\\");\\n        require(_grantApprovers[id].executed == false, \\\"Approvable: action has already executed\\\");\\n        if (_grantApprovers[id].approvalsWeight >= _threshold) {\\n            _grantApprover(_grantApprovers[id].account, _grantApprovers[id].weight);\\n            _grantApprovers[id].executed = true;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\n    // Change Approver Weight\\n    function changeApproverWeight(address account, uint256 weight) public onlyApprover returns (uint256) {\\n        require(_totalWeight.sub(_weights[account]).add(weight) >= _threshold, \\\"Approvable: The threshold is greater than new totalWeight\\\");\\n        uint256 id = _addNewChangeApproverWeight(account, weight);\\n        _voteForChangeApproverWeight(id);\\n        return id;\\n    }\\n\\n    function _addNewChangeApproverWeight(address account, uint256 weight) private returns (uint256) {\\n        require(account != address(0), \\\"Approvable: account is the zero address\\\");\\n        uint256 id = _changeApproverWeights.length;\\n        _changeApproverWeights.push(ChangeApproverWeight(id, false, account, weight, 0));\\n        emit NewChangeApproverWeight(id, account, weight);\\n        return id;\\n    }\\n\\n    function _voteForChangeApproverWeight(uint256 id) private returns (bool) {\\n        address msgSender = _msgSender();\\n        _approvalsChangeApproverWeight[msgSender][id] = true;\\n        _changeApproverWeights[id].approvalsWeight = _changeApproverWeights[id].approvalsWeight.add(_weights[msgSender]);\\n        emit VoteForChangeApproverWeight(id, msgSender, _weights[msgSender], _changeApproverWeights[id].approvalsWeight);\\n        if (_changeApproverWeights[id].approvalsWeight >= _threshold) {\\n            _changeApproverWeight(_changeApproverWeights[id].account, _changeApproverWeights[id].weight);\\n            _changeApproverWeights[id].executed = true;\\n        }\\n        return true;\\n    }\\n\\n    function _changeApproverWeight(address account, uint256 weight) private returns (bool) {\\n        uint256 newTotalWeight = _totalWeight.sub(_weights[account]).add(weight);\\n        require(newTotalWeight >= _threshold, \\\"Approvable: The threshold is greater than new totalWeight\\\");\\n        _setTotalWeight(newTotalWeight);\\n        emit ApproverWeightChanged(account, _weights[account], weight);\\n        _weights[account] = weight;\\n        return true;\\n    }\\n\\n    function approveChangeApproverWeight(uint256 id) public onlyApprover returns (bool) {\\n        require(_changeApproverWeights[id].executed == false, \\\"Approvable: action has already executed\\\");\\n        require(_approvalsChangeApproverWeight[_msgSender()][id] == false, \\\"Approvable: Cannot approve action twice\\\");\\n        return _voteForChangeApproverWeight(id);\\n    }\\n\\n\\n    // Revoke Approver\\n    function revokeApprover(address account) public onlyApprover returns (uint256) {\\n        require(_totalWeight.sub(_weights[account]) >= _threshold, \\\"Approvable: The threshold is greater than new totalWeight\\\");\\n        uint256 id = _addNewRevokeApprover(account);\\n        _voteForRevokeApprover(id);\\n        return id;\\n    }\\n\\n    function _addNewRevokeApprover(address account) private returns (uint256) {\\n        require(account != address(0), \\\"Approvable: account is the zero address\\\");\\n        uint256 id = _revokeApprovers.length;\\n        _revokeApprovers.push(RevokeApprover(id, false, account, 0));\\n        emit NewRevokeApprover(id, account);\\n        return id;\\n    }\\n\\n    function _voteForRevokeApprover(uint256 id) private returns (bool) {\\n        address msgSender = _msgSender();\\n        _approvalsRevokeApprover[msgSender][id] = true;\\n        _revokeApprovers[id].approvalsWeight = _revokeApprovers[id].approvalsWeight.add(_weights[msgSender]);\\n        emit VoteForRevokeApprover(id, msgSender, _weights[msgSender], _revokeApprovers[id].approvalsWeight);\\n        if (_revokeApprovers[id].approvalsWeight >= _threshold) {\\n            _revokeApprover(_revokeApprovers[id].account);\\n            _revokeApprovers[id].executed = true;\\n        }\\n        return true;\\n    }\\n\\n    function _revokeApprover(address account) private returns (bool) {\\n        uint256 newTotalWeight = _totalWeight.sub(_weights[account]);\\n        require(newTotalWeight >= _threshold, \\\"Approvable: The threshold is greater than new totalWeight\\\");\\n        if (_approvers.remove(account)) {\\n            _changeApproverWeight(account, 0);\\n            emit ApproverRevoked(account);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function approveRevokeApprover(uint256 id) public onlyApprover returns (bool) {\\n        require(_revokeApprovers[id].executed == false, \\\"Approvable: action has already executed\\\");\\n        require(_approvalsRevokeApprover[_msgSender()][id] == false, \\\"Approvable: Cannot approve action twice\\\");\\n        return _voteForRevokeApprover(id);\\n    }\\n\\n    function renounceApprover(address account) public returns (bool) {\\n        require(account == _msgSender(), \\\"Approvable: can only renounce roles for self\\\");\\n        return _revokeApprover(account);\\n    }\\n\\n\\n    // Change Threshold\\n    function changeThreshold(uint256 threshold) public onlyApprover returns (uint256) {\\n        require(getTotalWeight() >= threshold, \\\"Approvable: The new threshold is greater than totalWeight\\\");\\n        uint256 id = _addNewChangeThreshold(threshold);\\n        _voteForChangeThreshold(id);\\n        return id;\\n    }\\n\\n    function _addNewChangeThreshold(uint256 threshold) private returns (uint256) {\\n        uint256 id = _changeThresholds.length;\\n        _changeThresholds.push(ChangeThreshold(id, false, threshold, 0));\\n        emit NewChangeThreshold(id, threshold);\\n        return id;\\n    }\\n\\n    function _voteForChangeThreshold(uint256 id) private returns (bool) {\\n        address msgSender = _msgSender();\\n        _approvalsChangeThreshold[msgSender][id] = true;\\n        _changeThresholds[id].approvalsWeight = _changeThresholds[id].approvalsWeight.add(_weights[msgSender]);\\n        emit VoteForChangeThreshold(id, msgSender, _weights[msgSender], _changeThresholds[id].approvalsWeight);\\n        if (_changeThresholds[id].approvalsWeight >= _threshold) {\\n            _setThreshold(_changeThresholds[id].threshold);\\n            _changeThresholds[id].executed = true;\\n        }\\n        return true;\\n    }\\n\\n    function approveChangeThreshold(uint256 id) public onlyApprover returns (bool) {\\n        require(_changeThresholds[id].executed == false, \\\"Approvable: action has already executed\\\");\\n        require(_approvalsChangeThreshold[_msgSender()][id] == false, \\\"Approvable: Cannot approve action twice\\\");\\n        return _voteForChangeThreshold(id);\\n    }\\n\\n    function _setThreshold(uint256 threshold) private returns (bool) {\\n        require(getTotalWeight() >= threshold, \\\"Approvable: The new threshold is greater than totalWeight\\\");\\n        emit ThresholdChanged(_threshold, threshold);\\n        _threshold = threshold;\\n        return true;\\n    }\\n\\n    function _setupThreshold(uint256 threshold) internal returns (bool) {\\n        return _setThreshold(threshold);\\n    }\\n\\n\\n    // Total Weight\\n    function _setTotalWeight(uint256 totalWeight) private returns (bool) {\\n        emit TotalWeightChanged(_totalWeight, totalWeight);\\n        _totalWeight = totalWeight;\\n        return true;\\n    }\\n\\n    modifier onlyApprover() {\\n        require(isApprover(_msgSender()), \\\"Approvable: caller is not the approver\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/cup/contracts/CUPMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"./Approvable.sol\\\";\\n\\n\\n\\ninterface IERC20Short {\\n    function burnFrom(address account, uint256 amount) external;\\n    function mint(address to, uint256 amount) external;\\n}\\n\\n\\ncontract CUPMinter is Approvable {\\n    using SafeMath for uint256;\\n\\n    address private _cup;\\n    mapping(address => bool) private _tokens;\\n\\n    struct Proposal {\\n        uint256 id;\\n        bool applied;\\n        address token;\\n        uint256 approvalsWeight;\\n    }\\n    Proposal[] private _proposals;\\n    mapping(address => mapping(uint256 => bool)) private _approvalsProposal;\\n\\n    event NewProposal(uint256 indexed id, address indexed token);\\n    event VoteForProposal(uint256 indexed id, address indexed voter, uint256 voterWeight, uint256 approvalsWeight);\\n    event ProposalApplied(uint256 indexed id, address indexed token);\\n\\n\\n    constructor(uint256 weight, uint256 threshold) public {\\n        _setupApprover(_msgSender(), weight);\\n        _setupThreshold(threshold);\\n    }\\n\\n    function convert(address token, uint256 amount) public {\\n        require(_tokens[token], \\\"This token is not allowed to convert\\\");\\n        address msgSender = _msgSender();\\n        IERC20Short(token).burnFrom(msgSender, amount);\\n        IERC20Short(cup()).mint(msgSender, amount);\\n    }\\n\\n    function cup() public view returns (address) {\\n        return _cup;\\n    }\\n\\n    function setCup(address token) public onlyApprover {\\n        require(token != address(0), \\\"New CUP address is the zero address\\\");\\n        require(cup() == address(0), \\\"The CUP address is already setted\\\");\\n        _cup = token;\\n    }\\n\\n    function proposalsCount() public view returns (uint256) {\\n        return _proposals.length;\\n    }\\n\\n    function getProposal(uint256 id) public view returns (Proposal memory) {\\n        return _proposals[id];\\n    }\\n\\n    function addProposal(address token) public onlyApprover returns (uint256) {\\n        uint256 id = _addNewProposal(token);\\n        _voteForProposal(id);\\n        return id;\\n    }\\n\\n    function approveProposal(uint256 id) public onlyApprover {\\n        require(_proposals[id].applied == false, \\\"Proposal has already applied\\\");\\n        require(_approvalsProposal[_msgSender()][id] == false, \\\"Cannot approve transfer twice\\\");\\n        _voteForProposal(id);\\n    }\\n\\n\\n    function _addNewProposal(address token) private returns (uint256) {\\n        require(token != address(0), \\\"Token is the zero address\\\");\\n        uint256 id = _proposals.length;\\n        _proposals.push(Proposal(id, false, token, 0));\\n        emit NewProposal(id, token);\\n        return id;\\n    }\\n\\n    function _voteForProposal(uint256 id) private {\\n        address msgSender = _msgSender();\\n        _approvalsProposal[msgSender][id] = true;\\n        uint256 approverWeight = getApproverWeight(msgSender);\\n        _proposals[id].approvalsWeight = _proposals[id].approvalsWeight.add(approverWeight);\\n        emit VoteForProposal(id, msgSender, approverWeight, _proposals[id].approvalsWeight);\\n        if (_proposals[id].approvalsWeight >= getThreshold())\\n            _applyProposal(id);\\n    }\\n\\n    function _applyProposal(uint256 id) private {\\n        _tokens[_proposals[id].token] = true;\\n        _proposals[id].applied = true;\\n        emit ProposalApplied(id, _proposals[id].token);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ApproverGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ApproverRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newWeight\",\"type\":\"uint256\"}],\"name\":\"ApproverWeightChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"NewChangeApproverWeight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"NewChangeThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"NewGrantApprover\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"NewProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NewRevokeApprover\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"ProposalApplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"ThresholdChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTotalWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalWeight\",\"type\":\"uint256\"}],\"name\":\"TotalWeightChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voterWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"approvalsWeight\",\"type\":\"uint256\"}],\"name\":\"VoteForChangeApproverWeight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voterWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"approvalsWeight\",\"type\":\"uint256\"}],\"name\":\"VoteForChangeThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voterWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"approvalsWeight\",\"type\":\"uint256\"}],\"name\":\"VoteForGrantApprover\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voterWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"approvalsWeight\",\"type\":\"uint256\"}],\"name\":\"VoteForProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voterWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"approvalsWeight\",\"type\":\"uint256\"}],\"name\":\"VoteForRevokeApprover\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approveChangeApproverWeight\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approveChangeThreshold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approveGrantApprover\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approveProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approveRevokeApprover\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"changeApproverWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"changeThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"confirmGrantApprover\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"convert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cup\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getApprover\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getApproverWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getApproversCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getChangeApproverWeight\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approvalsWeight\",\"type\":\"uint256\"}],\"internalType\":\"struct Approvable.ChangeApproverWeight\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChangeApproverWeightsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getChangeThreshold\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approvalsWeight\",\"type\":\"uint256\"}],\"internalType\":\"struct Approvable.ChangeThreshold\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChangeThresholdsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getGrantApprover\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approvalsWeight\",\"type\":\"uint256\"}],\"internalType\":\"struct Approvable.GrantApprover\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGrantApproversCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getProposal\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"applied\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"approvalsWeight\",\"type\":\"uint256\"}],\"internalType\":\"struct CUPMinter.Proposal\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getRevokeApprover\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"approvalsWeight\",\"type\":\"uint256\"}],\"internalType\":\"struct Approvable.RevokeApprover\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRevokeApproversCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"grantApprover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isApprover\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceApprover\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeApprover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setCup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CUPMinter","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}