{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ERC20\\r\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\r\\n */\\r\\nabstract contract ERC20 {\\r\\n  uint256 public totalSupply;\\r\\n\\r\\n  function balanceOf(address who) public virtual view returns (uint256);\\r\\n  function transfer(address to, uint256 value) public virtual returns (bool);\\r\\n  function allowance(address owner, address spender) public virtual view returns (uint256);\\r\\n  function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\\r\\n  function approve(address spender, uint256 value) public virtual returns (bool);\\r\\n\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n}\"},\"KtlyoStaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\ncontract KtlyoStaking {\\n\\n    address public token1;\\n\\taddress public token2;\\n\\tuint256 public apy;\\n\\tuint256 public duration;\\n\\tuint256 public maxStakeAmt1;\\n\\tuint256 public maxStakeAmt2;\\n    uint256 private interestRate;\\n\\tuint256 private tokenRatio;\\n\\tuint256 public rewardAmt1;\\n\\tuint256 public rewardAmt2;\\n\\tuint256 private amtRewardRemainingBalance1;\\n\\tuint256 private amtRewardRemainingBalance2;\\n\\tuint256 private totalStaked1;\\n\\tuint256 private totalStaked2;\\n\\tuint256 private totalRedeemed1;\\n\\tuint256 private totalRedeemed2;\\n\\tuint256 private openRewards1;\\n\\tuint256 private openRewards2;\\n\\taddress public owner;\\n    uint256 public createdAt;\\n\\tuint256 private daysInYear;\\n\\tuint256 private secondsInYear;\\n\\tuint256 private precision = 1000000000000000000;\\n\\tbool private stakingStarted;\\n\\tstruct Transaction { \\n\\t\\taddress wallet;\\n\\t\\taddress token;\\n\\t\\tuint256 amount;\\n\\t\\tuint256 createdAt;\\n\\t\\tbool redeemed;\\n\\t\\tuint256 rewardAmt1;\\n\\t\\tuint256 rewardAmt2;\\n\\t\\tuint256 redeemedAt;\\n\\t\\tuint256 stakeEnd;\\n\\t}\\n\\tmapping(address =\\u003e Transaction[]) transactions;\\n\\t\\n\\tstruct MaxLimit { \\n\\t\\tuint256 limit1;\\n\\t\\tuint256 limit2;\\n\\t}\\n\\t\\n\\tmapping(address =\\u003e bool) blackListed;\\n\\tmapping(address =\\u003e MaxLimit) limits;\\n\\t\\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    constructor(\\n        address _token1,\\n\\t\\taddress _token2,\\n\\t\\tuint256 _apy,\\n\\t\\tuint256 _duration,\\n\\t\\tuint256 _tokenRatio,\\n\\t\\tuint256 _maxStakeAmt1,\\n\\t\\tuint256 _rewardAmt1,\\n        address _owner\\n\\t\\t\\n    ) {\\n        token1 = _token1;\\n\\t\\ttoken2 = _token2;\\n\\t\\tapy = _apy;\\n\\t\\tduration = _duration;\\n\\t\\ttokenRatio = _tokenRatio;\\n\\t\\tmaxStakeAmt1 = _maxStakeAmt1;\\n\\t\\tmaxStakeAmt2 = SafeMath.div(SafeMath.mul(maxStakeAmt1,tokenRatio),precision);\\n\\t\\trewardAmt1 = _rewardAmt1;\\n\\t\\trewardAmt2 = SafeMath.div(SafeMath.mul(rewardAmt1,tokenRatio),precision);\\n        owner = _owner;\\n        createdAt = block.timestamp;\\n\\t\\tstakingStarted = false;\\n\\t\\tdaysInYear = uint256(365);\\n\\t\\tsecondsInYear = daysInYear*24*60*60;\\n\\t\\tinterestRate = SafeMath.div(SafeMath.div(SafeMath.mul(apy,duration),secondsInYear),100);\\n\\t\\temit CreatedContract(token1,token2,apy,duration,maxStakeAmt1,maxStakeAmt2, rewardAmt1,rewardAmt2,msg.sender,block.timestamp,interestRate,tokenRatio);\\n\\t\\t\\n\\t\\t\\n    }\\n\\t\\n\\t// return ETH\\n    receive() external payable {\\n\\t\\t\\n        emit Reverted(msg.sender, msg.value);\\n\\t\\trevert(\\\"ETH is not accepted\\\");\\n    }\\n\\t\\n    // return ETH\\n    fallback() external payable { \\n      \\n\\t   emit Reverted(msg.sender, msg.value);\\n\\t   revert(\\\"ETH is not accepted\\\");\\n    }\\n\\t\\n\\t// callable by owner only\\n    function activate() onlyOwner public {\\n      \\n\\t\\t//check for rewards\\n\\t\\tERC20 tokenOne = ERC20(token1);\\n\\t\\tERC20 tokenTwo = ERC20(token2);\\n\\t\\tuint256 tenPerc=10;\\n\\t\\tuint256 balanceForToken1= tokenOne.balanceOf(address(this));\\n\\t\\tuint256 balanceForToken2= tokenTwo.balanceOf(address(this));\\n\\t\\tuint256 token1CheckAmount;\\n\\t\\tuint256 token2CheckAmount;\\n\\t\\tuint256 rewardBalance1;\\n\\t\\tuint256 rewardBalance2;\\n\\t\\t\\n\\t\\ttoken1CheckAmount = SafeMath.sub(balanceForToken1,totalStaked1);\\n\\t\\ttoken2CheckAmount = SafeMath.sub(balanceForToken2,totalStaked2);\\n\\t\\t\\n\\t\\trewardBalance1 = SafeMath.sub(SafeMath.sub(rewardAmt1,totalRedeemed1),openRewards1);\\n\\t\\trewardBalance2 = SafeMath.sub(SafeMath.sub(rewardAmt2,totalRedeemed2),openRewards2);\\n\\t\\t\\n\\t\\trequire (token1CheckAmount\\u003e=SafeMath.div(rewardBalance1,tenPerc),\\\"Activation error. Insufficient balance of rewards for token1\\\");\\n\\t\\trequire (token2CheckAmount\\u003e=SafeMath.div(rewardBalance2,tenPerc),\\\"Activation error. Insufficient balance of rewards for token2\\\");\\n\\t\\t//activate staking\\n\\t\\tstakingStarted = true;\\n\\t\\temit StartStaking(msg.sender,block.timestamp);\\n    }\\n\\t\\n\\t// callable by owner only\\n    function deActivate() onlyOwner public {\\n      \\n\\t\\t\\n\\t\\t//de-activate staking\\n\\t\\tstakingStarted = false;\\n\\t\\temit StopStaking(msg.sender,block.timestamp);\\n    }\\n\\t\\n\\t// callable by owner only\\n    function blackList(address[] memory addressList,bool blStatus) onlyOwner public {\\n\\t\\t\\n\\t\\tuint256 i;\\n\\t\\t\\n\\t\\tfor (i=0;i\\u003caddressList.length;i++)\\n\\t\\t{\\n\\t\\t\\tblackListed[addressList[i]]=blStatus;\\n\\t\\t}\\n\\t\\tif (blStatus) emit AddedToBlackList(msg.sender,block.timestamp);\\n\\t\\telse emit RemovedFromBlackList(msg.sender,block.timestamp);\\n    }\\n\\t\\n\\t\\n\\t// function to stake\\n    function stake(address tokenContract, uint256 amt) public {\\n       \\n\\t   uint256 amount_reward1;\\n\\t   uint256 amount_reward2;\\n\\t   uint256 limit1;\\n\\t   uint256 limit2;\\n\\t   \\n\\t   require(stakingStarted,\\\"Staking not active\\\");\\n\\t   require(rewardAmt1\\u003eSafeMath.add(totalRedeemed1,openRewards1) \\u0026\\u0026 rewardAmt2\\u003eSafeMath.add(totalRedeemed2,openRewards2),\\\"Rewards are spent. Staking contract is closed.\\\");\\n\\t   require(amtRewardRemainingBalance1 \\u003e 0 \\u0026\\u0026 amtRewardRemainingBalance2 \\u003e 0,\\\"Staking rewards are 0\\\");\\n\\t   require(tokenContract==token1 || tokenContract==token2,\\\"Invalid token contract\\\");\\n\\t   \\n\\t   limit1 = limits[msg.sender].limit1;\\n\\t   limit2 = limits[msg.sender].limit2;\\n\\t   \\n\\t   if (token1==tokenContract) \\n\\t   {\\n\\t    \\n\\t\\tif (SafeMath.add(amt,limit1)\\u003emaxStakeAmt1) amt = SafeMath.sub(maxStakeAmt1,limit1);\\n\\t\\tlimits[msg.sender].limit1 = SafeMath.add(limits[msg.sender].limit1,amt);\\n\\t\\tamount_reward1 = SafeMath.div(SafeMath.mul(amt,interestRate),precision);\\n\\t\\tif (amtRewardRemainingBalance1\\u003camount_reward1)\\n\\t    {\\n\\t\\t\\tamount_reward1 = amtRewardRemainingBalance1;\\n\\t\\t\\tamt = SafeMath.div(SafeMath.mul(amount_reward1,precision),interestRate);\\n\\t    }\\n\\t\\t\\n\\t\\tamount_reward2 = SafeMath.div(SafeMath.mul(amount_reward1,tokenRatio),precision);\\n\\t\\ttotalStaked1+=amt;\\n\\t   }\\n\\t   \\n\\t   if (token2==tokenContract) \\n\\t   {\\n\\t\\tif (amt+limit2\\u003emaxStakeAmt2) amt = SafeMath.sub(maxStakeAmt2,limit2);\\n\\t\\t\\n\\t\\tlimits[msg.sender].limit2 = SafeMath.add(limits[msg.sender].limit2, amt);\\n\\t\\t\\n\\t\\tamount_reward2 = SafeMath.div(SafeMath.mul(amt,interestRate),precision);\\n\\t\\t\\n\\t\\tif (amtRewardRemainingBalance2\\u003camount_reward2)\\n\\t    {\\n\\t\\t\\tamount_reward2 = amtRewardRemainingBalance2;\\n\\t\\t\\tamt = SafeMath.div(SafeMath.mul(amount_reward2,precision),interestRate);\\n\\t    }\\n\\t\\tamount_reward1 = SafeMath.div(SafeMath.mul(amount_reward2,precision),tokenRatio);\\n\\t\\ttotalStaked2+=amt;\\n\\t   }\\n\\t   \\n\\t   require(amt\\u003e0,\\\"Amount is equal to 0\\\");\\n\\t   \\n\\t   \\n\\t   amtRewardRemainingBalance1 = SafeMath.sub(amtRewardRemainingBalance1, amount_reward1,\\\"Insufficient rewards balance for token 1\\\");\\n\\t   amtRewardRemainingBalance2 = SafeMath.sub(amtRewardRemainingBalance2, amount_reward2,\\\"Insufficient rewards balance for token 2\\\");\\n\\t   \\n\\t   ERC20 tokenERC20 = ERC20(tokenContract);\\n\\t   //transfer token\\n\\t   require(tokenERC20.transferFrom(msg.sender, address(this), amt),\\\"Token transfer for staking not approved!\\\");\\n\\t   \\n\\t   //create transaction\\n\\t   Transaction memory trx = Transaction(\\n\\t   {\\n\\t\\t   wallet : msg.sender,\\n\\t\\t   token : tokenContract,\\n\\t\\t   amount : amt,\\n\\t\\t   createdAt:block.timestamp,\\n\\t\\t   redeemed : false,\\n\\t\\t   rewardAmt1 : amount_reward1,\\n\\t\\t   rewardAmt2 : amount_reward2,\\n\\t\\t   stakeEnd: SafeMath.add(block.timestamp,duration),\\n\\t\\t   redeemedAt : 0\\n\\t   });\\n\\t   openRewards1+=amount_reward1;\\n\\t   openRewards2+=amount_reward2;\\n\\t   transactions[msg.sender].push(trx);\\n\\t   \\n\\t   emit Staked(msg.sender,tokenContract, amt);\\n    }\\n\\tfunction redeemTrx(address requestor, uint256 indexId) \\n\\tinternal \\n\\treturns (uint256 returnAmount, uint256 returnAmount2) \\n\\t{\\n\\t   \\n\\t    \\n\\t\\t\\n\\t\\tif (transactions[requestor][indexId].token==token1)\\n\\t\\t{\\n\\t\\t\\treturnAmount = transactions[requestor][indexId].amount;\\n\\t\\t\\tif (transactions[requestor][indexId].stakeEnd \\u003c block.timestamp \\u0026\\u0026 blackListed[requestor]!=true)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturnAmount = SafeMath.add(returnAmount,transactions[requestor][indexId].rewardAmt1);\\n\\t\\t\\t\\treturnAmount2 = transactions[requestor][indexId].rewardAmt2;\\n\\t\\t\\t}\\n\\t\\t\\tlimits[requestor].limit1-=transactions[requestor][indexId].amount;\\n\\t\\t}else\\n\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\treturnAmount2 = transactions[requestor][indexId].amount;\\n\\t\\t\\tif (transactions[requestor][indexId].stakeEnd \\u003c block.timestamp \\u0026\\u0026 blackListed[requestor]!=true)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturnAmount2 = SafeMath.add(returnAmount2,transactions[requestor][indexId].rewardAmt2);\\n\\t\\t\\t\\treturnAmount = transactions[requestor][indexId].rewardAmt1;\\n\\t\\t\\t}\\n\\t\\t\\tlimits[requestor].limit2-=transactions[requestor][indexId].amount;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\ttransactions[requestor][indexId].redeemed = true;\\n\\t\\ttransactions[requestor][indexId].redeemedAt = block.timestamp;\\n\\t\\topenRewards1-=transactions[requestor][indexId].rewardAmt1;\\n\\t\\topenRewards2-=transactions[requestor][indexId].rewardAmt2;\\n\\t\\treturn (returnAmount,returnAmount2);\\n\\t  \\n\\t   \\n    }\\n\\tfunction redeem(uint256 indexId) public {\\n\\t   uint256 returnAmount;\\n\\t   uint256 returnAmount2;\\n\\t   require(transactions[msg.sender][indexId].redeemed==false \\u0026\\u0026 transactions[msg.sender][indexId].stakeEnd\\u003cblock.timestamp ,\\\"Stake is already redeemed or end_date not reached\\\");\\n\\t   \\n\\t   (returnAmount,returnAmount2) = redeemTrx(msg.sender,indexId);\\n\\t   ERC20 tokenERC20 = ERC20(token1);\\n\\t   ERC20 tokenERC20t2 = ERC20(token2);\\n\\t   if (returnAmount\\u003e0) tokenERC20.transfer(msg.sender, returnAmount);\\n\\t   if (returnAmount2\\u003e0) tokenERC20t2.transfer(msg.sender, returnAmount2);\\n\\t   if (transactions[msg.sender][indexId].token==token1) totalStaked1-=transactions[msg.sender][indexId].amount;\\n\\t   else totalStaked2-=transactions[msg.sender][indexId].amount;\\n\\t   totalRedeemed1+=transactions[msg.sender][indexId].rewardAmt1;\\n       totalRedeemed2+=transactions[msg.sender][indexId].rewardAmt2;\\n\\t   emit Redeemed(msg.sender,block.timestamp, returnAmount,returnAmount2);\\n    }\\n\\t\\n\\tfunction redeemAll() public {\\n\\t\\t//check if available to redeem and transfer if available\\n\\t\\tuint256 returnAmount;\\n\\t\\tuint256 returnAmount2;\\n\\t\\tuint256 returnAmountTotal;\\n\\t\\tuint256 returnAmountTotal2;\\n\\t\\tuint256 i;\\n\\t\\tERC20 tokenERC20t2;\\n\\t\\tERC20 tokenERC20;\\n\\t\\treturnAmountTotal = 0;\\n\\t\\treturnAmountTotal2 = 0;\\n\\t   \\n\\t\\tfor (i=0;i\\u003ctransactions[msg.sender].length;i++)\\n\\t\\t{\\n\\t\\t\\tif (transactions[msg.sender][i].redeemed==false \\u0026\\u0026 transactions[msg.sender][i].stakeEnd\\u003cblock.timestamp)\\n\\t\\t\\t{\\n\\t\\t\\t\\t(returnAmount,returnAmount2) = redeemTrx(msg.sender,i);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\treturnAmountTotal = returnAmountTotal + returnAmount;\\n\\t\\t\\t\\treturnAmountTotal2 = returnAmountTotal2 + returnAmount2;\\n\\t\\t\\t\\tif (transactions[msg.sender][i].token==token1) \\n\\t\\t\\t    {\\n\\t\\t\\t\\t totalStaked1-=transactions[msg.sender][i].amount;\\n\\t\\t\\t\\t totalRedeemed1+=transactions[msg.sender][i].rewardAmt1; \\n\\t\\t\\t    }\\n\\t\\t\\t    else\\n\\t\\t\\t    {\\n\\t\\t\\t\\t totalStaked2-=transactions[msg.sender][i].amount;\\n\\t\\t\\t\\t totalRedeemed2+=transactions[msg.sender][i].rewardAmt2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\ttokenERC20 = ERC20(token1);\\n\\t\\tif (returnAmountTotal\\u003e0) tokenERC20.transfer(msg.sender, returnAmountTotal);\\n\\t\\ttokenERC20t2 = ERC20(token2);\\n\\t\\tif (returnAmountTotal2\\u003e0) tokenERC20t2.transfer(msg.sender, returnAmountTotal2);\\n\\t\\temit RedeemedAll(msg.sender,block.timestamp, returnAmountTotal,returnAmountTotal2);\\n\\t   \\n    }\\n\\t\\n\\tfunction redeemEarly(uint256 indexId) public {\\n\\t\\n       uint256 returnAmount;\\n\\t   uint256 returnAmount2;\\n\\t   \\n\\t   require(transactions[msg.sender][indexId].redeemed==false,\\\"Stake is already redeemed\\\");\\n\\t   \\n\\t   (returnAmount,returnAmount2) = redeemTrx(msg.sender,indexId);\\n\\t   \\n\\t   if (transactions[msg.sender][indexId].stakeEnd\\u003eblock.timestamp)\\n\\t   {\\n\\t\\t   amtRewardRemainingBalance1 = SafeMath.add(amtRewardRemainingBalance1, transactions[msg.sender][indexId].rewardAmt1);\\n\\t\\t   amtRewardRemainingBalance2 = SafeMath.add(amtRewardRemainingBalance2, transactions[msg.sender][indexId].rewardAmt2);\\n\\t\\t   \\n\\t\\t   if (transactions[msg.sender][indexId].token==token1) totalStaked1-=transactions[msg.sender][indexId].amount;\\n\\t\\t   else \\n\\t\\t   {\\n\\t\\t\\ttotalStaked2-=transactions[msg.sender][indexId].amount;\\n\\t\\t\\treturnAmount = returnAmount2;\\n\\t\\t   }\\n\\t\\t   \\n\\t\\t   ERC20 tokenERC20 = ERC20(transactions[msg.sender][indexId].token);\\n\\t\\t   if (returnAmount\\u003e0) tokenERC20.transfer(msg.sender, returnAmount);\\n\\t\\t   emit EarlyRedeemed(msg.sender,block.timestamp, returnAmount);\\n\\t   }else{\\n\\t\\t\\n\\t\\t\\tERC20 tokenERC20 = ERC20(token1);\\n\\t\\t\\tERC20 tokenERC20t2 = ERC20(token2);\\n\\t\\t\\tif (returnAmount\\u003e0) tokenERC20.transfer(msg.sender, returnAmount);\\n\\t\\t\\tif (returnAmount2\\u003e0) tokenERC20t2.transfer(msg.sender, returnAmount2);\\n\\t\\t\\tif (transactions[msg.sender][indexId].token==token1) totalStaked1-=transactions[msg.sender][indexId].amount;\\n\\t\\t\\telse totalStaked2-=transactions[msg.sender][indexId].amount;\\n\\t\\t\\ttotalRedeemed1+=transactions[msg.sender][indexId].rewardAmt1;\\n\\t\\t\\ttotalRedeemed2+=transactions[msg.sender][indexId].rewardAmt2;\\n\\t\\t\\temit Redeemed(msg.sender,block.timestamp, returnAmount,returnAmount2);\\n\\t   }\\n    }\\n\\t\\n\\tfunction redeemEarlyAll() public {\\n\\t   //check if available to redeem and transfer if available\\n       uint256 returnAmount;\\n\\t   uint256 returnAmount2;\\n\\t   uint256 returnAmountTotal;\\n\\t   uint256 returnAmountTotal2;\\n\\t   uint i;\\n\\t   ERC20 tokenERC20t2;\\n\\t   ERC20 tokenERC20;\\n\\t  \\n\\t   for (i=0;i\\u003ctransactions[msg.sender].length;i++)\\n\\t   {\\n\\t\\t\\tif (transactions[msg.sender][i].redeemed==false)\\n\\t\\t\\t{\\n\\t\\t\\t\\t(returnAmount,returnAmount2) = redeemTrx(msg.sender,i);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\treturnAmountTotal+= returnAmount;\\n\\t\\t\\t\\treturnAmountTotal2+= returnAmount2;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (transactions[msg.sender][i].stakeEnd\\u003eblock.timestamp)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (transactions[msg.sender][i].token==token1) totalStaked1-=transactions[msg.sender][i].amount;\\n\\t\\t\\t\\t\\telse totalStaked2-=transactions[msg.sender][i].amount;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (transactions[msg.sender][i].token==token1) \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t totalStaked1-=transactions[msg.sender][i].amount;\\n\\t\\t\\t\\t\\t totalRedeemed1+=transactions[msg.sender][i].rewardAmt1; \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t totalStaked2-=transactions[msg.sender][i].amount;\\n\\t\\t\\t\\t\\t totalRedeemed2+=transactions[msg.sender][i].rewardAmt2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t   }\\n\\t   \\n\\t    tokenERC20 = ERC20(token1);\\n\\t\\tif (returnAmountTotal\\u003e0) tokenERC20.transfer(msg.sender, returnAmountTotal);\\n\\t\\ttokenERC20t2 = ERC20(token2);\\n\\t\\tif (returnAmountTotal2\\u003e0) tokenERC20t2.transfer(msg.sender, returnAmountTotal2);\\n\\t   \\n\\t   emit EarlyRedeemedAll(msg.sender,block.timestamp, returnAmountTotal,returnAmountTotal2);\\n\\t\\t\\n    }\\n\\t\\n\\tfunction transferReward(address token, uint256 reward_amount) public {\\n\\t\\n\\t   require(reward_amount\\u003e0,\\\"Reward amount is 0\\\");\\n\\t   \\n\\t   ERC20 tokenERC20 = ERC20(token);\\n\\t   //uint256 allowance = tokenERC20.allowance(msg.sender,address(this));\\n\\t   //require(allowance\\u003e=reward_amount,\\\"Transfer not approved!\\\");\\n\\t   tokenERC20.transferFrom(msg.sender,address(this), reward_amount);\\n\\t   if (token==token1) amtRewardRemainingBalance1 = SafeMath.add(amtRewardRemainingBalance1, reward_amount);\\n\\t   if (token==token2) amtRewardRemainingBalance2 = SafeMath.add(amtRewardRemainingBalance2, reward_amount);\\n\\t  \\n\\t   emit TransferReward(msg.sender,block.timestamp, reward_amount);\\n    }\\n\\t\\n\\tfunction transferBackReward(address token, uint256 reward_amount) onlyOwner public {\\n\\t\\n\\t   require(reward_amount\\u003e0 \\u0026\\u0026 stakingStarted==false,\\\"Reward amount is 0 or staking is activated\\\");\\n\\t   require(openRewards1==0 \\u0026\\u0026 openRewards2==0,\\\"There are open rewards\\\");\\n\\t   \\n\\t   ERC20 tokenERC20 = ERC20(token);\\n\\t  \\n\\t   if (token==token1) \\n\\t   {\\n\\t\\tif (reward_amount\\u003eSafeMath.sub(amtRewardRemainingBalance1, openRewards1)) reward_amount = SafeMath.sub(amtRewardRemainingBalance1, openRewards1);\\n\\t\\tamtRewardRemainingBalance1 = SafeMath.sub(amtRewardRemainingBalance1, reward_amount);\\n\\t\\t\\n\\t   }\\n\\t   if (token==token2) \\n\\t   {\\n\\t\\tif (reward_amount\\u003eSafeMath.sub(amtRewardRemainingBalance2, openRewards2)) reward_amount = SafeMath.sub(amtRewardRemainingBalance2, openRewards2);\\n\\t    amtRewardRemainingBalance2 = SafeMath.sub(amtRewardRemainingBalance2, reward_amount);\\n\\t   }\\n\\t   tokenERC20.transfer(msg.sender, reward_amount);\\n\\t   \\n\\t   emit TransferBackReward(msg.sender,block.timestamp, reward_amount);\\n    }\\n\\t\\n    \\n    function info() public view returns(address,uint256,uint256,uint256,uint256,uint256,uint256){\\n        return (owner,createdAt,apy,duration,rewardAmt1,interestRate,tokenRatio);\\n    }\\n\\tfunction getRewardsInfo() public view returns(address,address,uint256,uint256,uint256,uint256){ \\n        return (token1,token2,rewardAmt1,rewardAmt2,amtRewardRemainingBalance1,amtRewardRemainingBalance2);\\n    }\\n\\tfunction getStakeRewardAmounts() public view returns(uint256,uint256,uint256,uint256,uint256,uint256){ \\n        return (totalStaked1,totalStaked2,openRewards1,openRewards2,maxStakeAmt1,maxStakeAmt2);\\n    }\\n\\tfunction getMyInfo() public view returns(Transaction [] memory,MaxLimit memory){ \\n        return (transactions[msg.sender],limits[msg.sender]);\\n    }\\n\\tfunction getMyStakings() public view returns(Transaction [] memory){ \\n        return (transactions[msg.sender]);\\n    }\\n\\tfunction getStakings(address wallet) public view onlyOwner returns(Transaction [] memory){ \\n        return (transactions[wallet]);\\n    }\\n\\tfunction getMyLimits() public view returns(MaxLimit memory){ \\n        return (limits[msg.sender]);\\n    }\\n\\tfunction getBlackListedStatus(address wallet) public view returns(bool){ \\n        \\n\\t\\treturn (blackListed[wallet]);\\n    }\\n\\t\\n\\tevent CreatedContract(address token1,address token2,uint256 apy,uint256 duration,uint256 maxStakeAmt1, uint256 maxStakeAmt2, uint256 rewardAmt1,uint256 rewardAmt2,address owner,uint256 createdAt,uint256 interestRate,uint256 tokenRatio);\\n    event Received(address from, uint256 amount);\\n\\tevent Reverted(address from, uint256 amount);\\n\\tevent StartStaking(address from,uint256 startDate);\\n\\tevent StopStaking(address from,uint256 stopDate);\\n\\tevent Staked(address from,address tokenCtr,uint256 amount);\\n\\tevent EarlyRedeemed(address to,uint256 redeemedDate,uint256 amount);\\n\\tevent EarlyRedeemedAll(address to,uint256 redeemedDate,uint256 amount1,uint256 amount2);\\n\\tevent Redeemed(address to,uint256 redeemedDate,uint256 amount1,uint256 amount2);\\n\\tevent RedeemedAll(address to,uint256 redeemedDate,uint256 amount1,uint256 amount2);\\n\\tevent TransferReward(address from,uint256 sentDate,uint256 amount);\\n\\tevent TransferBackReward(address to,uint256 sentDate,uint256 amount);\\n\\tevent AddedToBlackList(address from, uint256 sentDate);\\n\\tevent RemovedFromBlackList(address from, uint256 sentDate);\\n}\"},\"KtlyoStakingFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./KtlyoStaking.sol\\\";\\n\\n\\ncontract KtlyoStakingFactory {\\n \\n    mapping(address =\\u003e address[]) stakingPairs;\\n\\tuint256 ktlyoFee = 10000000000000000000;\\n\\taddress owner;\\n\\t\\n\\t\\n\\tconstructor() {\\n\\t\\towner = msg.sender;\\n\\t}\\n\\t\\n\\tmodifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\tfunction getStakingPairs(address _user) \\n        public\\n        view\\n        returns(address[] memory)\\n    {\\n        return stakingPairs[_user];\\n    }\\n\\t\\n\\tfunction getKtlyoFee() \\n        public\\n        view\\n        returns(uint256)\\n    {\\n        return ktlyoFee;\\n    }\\n\\t\\n\\tfunction setKtlyoFee(uint256 _newFee) \\n        public \\n        onlyOwner \\n        returns(uint256)\\n    {\\n        ktlyoFee = _newFee;\\n\\t\\treturn ktlyoFee;\\n    }\\n\\t\\n\\tfunction collectKtlyoFee(address _tokenFee) \\n        public \\n        onlyOwner \\n        returns(bool)\\n    {\\n        ERC20 ktlyoToken = ERC20(_tokenFee);\\n\\t\\tuint256 ktlyoBal = ktlyoToken.balanceOf(address(this));\\n\\t\\trequire(ktlyoBal\\u003e0,\\\"Fee balance is 0!\\\");\\n\\t\\tktlyoToken.transfer(msg.sender,ktlyoBal);\\n\\t\\treturn true;\\n    }\\n\\t\\n\\t\\n    function newKtlyoStaking(address _token1, address _token2, uint256 _apy, uint256 _duration, uint256 _tokenRatio, uint256 _maxStakeAmt1, uint256 _rewardAmt1,address _tokenFee)\\n        public\\n        returns(address addressKsPair)\\n    {\\n\\t\\tERC20 ktlyoToken = ERC20(_tokenFee);\\n        require(ktlyoToken.transferFrom(msg.sender, address(this), ktlyoFee),\\\"Payment of fee not approved!\\\");\\n\\t\\t\\n\\t\\t// Create new staking pair.\\n        KtlyoStaking ksPair = new KtlyoStaking(_token1,_token2,_apy,_duration,_tokenRatio,_maxStakeAmt1,_rewardAmt1,msg.sender);\\n        \\n\\t\\taddressKsPair = address(ksPair);\\n\\t\\t//address payable addressPayKsPair = payable(addressKsPair);\\n\\t\\t\\n        // Add wallet to sender\\u0027s stakingPairs.\\n        stakingPairs[msg.sender].push(addressKsPair);\\n\\n        // Send ether from this transaction to the created contract.\\n\\t\\t//addressPayKsPair.transfer(msg.value);\\n\\t\\t\\n\\n        // Emit event.\\n        emit Created(addressKsPair, msg.sender, _token1,_token2,_apy,_duration, block.timestamp);\\n    }\\n\\n    // Prevents accidental sending of ether to the factory\\n    fallback () external {\\n\\t\\t\\n\\t\\trevert(\\\"ETH is not accepted\\\");\\n    }\\n\\t\\n\\t// return ETH\\n    receive() external payable {\\n\\t\\t\\n        emit Reverted(msg.sender, msg.value);\\n\\t\\trevert(\\\"ETH is not accepted\\\");\\n    }\\n\\t\\n\\n    event Created(address addressKsPair, address from, address token1,address token2, uint256 apy, uint256 duration, uint256 createdAt);\\n\\tevent Reverted(address from, uint256 amount);\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addressKsPair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"apy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reverted\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenFee\",\"type\":\"address\"}],\"name\":\"collectKtlyoFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getKtlyoFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getStakingPairs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_apy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxStakeAmt1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardAmt1\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenFee\",\"type\":\"address\"}],\"name\":\"newKtlyoStaking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addressKsPair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"setKtlyoFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"KtlyoStakingFactory","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"istanbul","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://30281def21373fddfa7dc3cbe63c216eacbe69714bc69f37a6c9ac16f3f562d9"}]}