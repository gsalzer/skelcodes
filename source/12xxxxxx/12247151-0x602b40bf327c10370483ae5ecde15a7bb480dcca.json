{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/token/IERC20Basic.sol\r\n\r\npragma solidity <0.6 >=0.4.21;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract IERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: contracts/token/IERC20.sol\r\n\r\npragma solidity <0.6 >=0.4.21;\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract IERC20 is IERC20Basic {\r\n  function name() external view returns (string memory);\r\n  function symbol() external view returns (string memory);\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/ICycloneV2dot2.sol\r\n\r\npragma solidity <0.6 >=0.4.24;\r\n\r\n\r\ninterface ICycloneV2dot2 {\r\n\r\n  function coinDenomination() external view returns (uint256);\r\n  function tokenDenomination() external view returns (uint256);\r\n  function cycDenomination() external view returns (uint256);\r\n  function token() external view returns (IERC20);\r\n  function cycToken() external view returns (IERC20);\r\n  function deposit(bytes32 _commitment) external payable;\r\n  function withdraw(bytes calldata _proof, bytes32 _root, bytes32 _nullifierHash, address payable _recipient, address payable _relayer, uint256 _fee, uint256 _refund) external payable;\r\n  function anonymityFee() external view returns (uint256);\r\n}\r\n\r\n// File: contracts/math/SafeMath.sol\r\n\r\npragma solidity <0.6 >=0.4.21;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n\r\n  /*@CTK SafeMath_mul\r\n    @tag spec\r\n    @post __reverted == __has_assertion_failure\r\n    @post __has_assertion_failure == __has_overflow\r\n    @post __reverted == false -> c == a * b\r\n    @post msg == msg__post\r\n   */\r\n  /* CertiK Smart Labelling, for more details visit: https://certik.org */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  /*@CTK SafeMath_div\r\n    @tag spec\r\n    @pre b != 0\r\n    @post __reverted == __has_assertion_failure\r\n    @post __has_overflow == true -> __has_assertion_failure == true\r\n    @post __reverted == false -> __return == a / b\r\n    @post msg == msg__post\r\n   */\r\n  /* CertiK Smart Labelling, for more details visit: https://certik.org */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  /*@CTK SafeMath_sub\r\n    @tag spec\r\n    @post __reverted == __has_assertion_failure\r\n    @post __has_overflow == true -> __has_assertion_failure == true\r\n    @post __reverted == false -> __return == a - b\r\n    @post msg == msg__post\r\n   */\r\n  /* CertiK Smart Labelling, for more details visit: https://certik.org */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  /*@CTK SafeMath_add\r\n    @tag spec\r\n    @post __reverted == __has_assertion_failure\r\n    @post __has_assertion_failure == __has_overflow\r\n    @post __reverted == false -> c == a + b\r\n    @post msg == msg__post\r\n   */\r\n  /* CertiK Smart Labelling, for more details visit: https://certik.org */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/token/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/uniswapv2/IRouter.sol\r\n\r\npragma solidity >=0.5.0 <0.8.0;\r\n\r\ninterface IRouter {\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function swapETHForExactTokens(\r\n        uint amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\r\n}\r\n\r\n// File: contracts/uniswapv2/CycloneWrapper.sol\r\n\r\npragma solidity <0.6 >=0.4.24;\r\n\r\n\r\n\r\n\r\n\r\ncontract CycloneWrapper {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n  IRouter public router;\r\n  address public wrappedCoin;\r\n  mapping(address => bool) public whitelisted;\r\n\r\n  constructor(IRouter _router, address _wrappedCoin) public {\r\n    router = _router;\r\n    wrappedCoin = _wrappedCoin;\r\n  }\r\n\r\n  function () external payable {}\r\n\r\n  function purchaseCost(ICycloneV2dot2 _cyclone) external view returns (uint256) {\r\n    uint256 cycAmount = _cyclone.cycDenomination().add(_cyclone.anonymityFee());\r\n    if (cycAmount == 0) {\r\n        return 0;\r\n    }\r\n    address[] memory paths = new address[](2);\r\n    paths[0] = wrappedCoin;\r\n    paths[1] = address(_cyclone.cycToken());\r\n    uint256[] memory amounts = router.getAmountsIn(cycAmount, paths);\r\n    return amounts[0];\r\n  }\r\n\r\n  function deposit(ICycloneV2dot2 _cyclone, bytes32 _commitment, bool _buyCYC) external payable {\r\n    require(whitelisted[address(_cyclone)], \"not whitelisted\");\r\n    uint256 coinAmount = _cyclone.coinDenomination();\r\n    require(msg.value >= coinAmount, \"CycloneWrapper: insufficient coin\");\r\n    uint256 tokenAmount = _cyclone.tokenDenomination();\r\n    uint256 cycAmount = _cyclone.cycDenomination().add(_cyclone.anonymityFee());\r\n    uint256 remainingCoin = msg.value.sub(coinAmount);\r\n    if (tokenAmount > 0) {\r\n      _cyclone.token().safeTransferFrom(msg.sender, address(this), tokenAmount);\r\n    }\r\n    if (cycAmount > 0) {\r\n      if (_buyCYC) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = wrappedCoin;\r\n        path[1] = address(_cyclone.cycToken());\r\n        uint256[] memory amounts = router.swapETHForExactTokens.value(remainingCoin)(cycAmount, path, address(this), block.timestamp.mul(2));\r\n        require(remainingCoin >= amounts[0], \"CycloneWrapper: unexpected status\");\r\n        remainingCoin -= amounts[0];\r\n      } else {\r\n        _cyclone.cycToken().safeTransferFrom(msg.sender, address(this), cycAmount);\r\n      }\r\n    }\r\n    _cyclone.deposit.value(coinAmount)(_commitment);\r\n    if (remainingCoin > 0) {\r\n      (bool success,) = msg.sender.call.value(remainingCoin)(\"\");\r\n      require(success, 'CycloneWrapper: refund');\r\n    }\r\n  }\r\n\r\n  function whitelist(ICycloneV2dot2 _cyclone) public {\r\n    address cycloneAddr = address(_cyclone);\r\n    require(!whitelisted[cycloneAddr], \"already whitelisted\");\r\n    IERC20 token = _cyclone.token();\r\n    if (address(token) != address(0)) {\r\n        token.safeApprove(cycloneAddr, uint256(-1));\r\n    }\r\n    _cyclone.cycToken().safeApprove(cycloneAddr, uint256(-1));\r\n    whitelisted[cycloneAddr] = true;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wrappedCoin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ICycloneV2dot2\",\"name\":\"_cyclone\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_commitment\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_buyCYC\",\"type\":\"bool\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ICycloneV2dot2\",\"name\":\"_cyclone\",\"type\":\"address\"}],\"name\":\"purchaseCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ICycloneV2dot2\",\"name\":\"_cyclone\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wrappedCoin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CycloneWrapper","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://1f0a5bd36ff7cff055d2e767f63a3ad3d8e463d01b090abde029977b7beefbd1"}]}