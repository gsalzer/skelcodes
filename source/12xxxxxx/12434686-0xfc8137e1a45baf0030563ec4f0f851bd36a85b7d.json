{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/// UNIV2LPOracle.sol\r\n\r\n// Copyright (C) 2017-2020 Maker Ecosystem Growth Holdings, INC.\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\n///////////////////////////////////////////////////////\r\n//                                                   //\r\n//    Methodology for Calculating LP Token Price     //\r\n//                                                   //\r\n///////////////////////////////////////////////////////\r\n\r\n// A naÃ¯ve approach to calculate the price of LP tokens, assuming the protocol\r\n// fee is zero, is to compute the price of the assets locked in its liquidity\r\n// pool, and divide it by the total amount of LP tokens issued:\r\n//\r\n// (p_0 * r_0 + p_1 * r_1) / LP_supply              (1)\r\n//\r\n// where r_0 and r_1 are the reserves of the two tokens held by the pool, and\r\n// p_0 and p_1 are their respective prices in some reference unit of account.\r\n//\r\n// However, the price of LP tokens (i.e. pool shares) needs to be evaluated\r\n// based on reserve values r_0 and r_1 that cannot be arbitraged, i.e. values\r\n// that give the two halves of the pool equal economic value:\r\n//\r\n// r_0 * p_0 = r_1 * p_1                            (2)\r\n// \r\n// Furthermore, two-asset constant product pools, neglecting fees, satisfy\r\n// (before and after trades):\r\n//\r\n// r_0 * r_1 = k                                    (3)\r\n//\r\n// Using (2) and (3) we can compute R_i, the arbitrage-free reserve values, in a\r\n// manner that depends only on k (which can be derived from the current reserve\r\n// balances, even if they are far from equilibrium) and market prices p_i\r\n// obtained from a trusted source:\r\n//\r\n// R_0 = sqrt(k * p_1 / p_0)                        (4)\r\n//   and\r\n// R_1 = sqrt(k * p_0 / p_1)                        (5)\r\n//\r\n// The value of an LP token is then, replacing (4) and (5) in (1):\r\n//\r\n// (p_0 * R_0 + p_1 * R_1) / LP_supply\r\n//     = 2 * sqrt(k * p_0 * p_1) / LP_supply        (6)\r\n//\r\n// k can be re-expressed in terms of the current pool reserves r_0 and r_1:\r\n//\r\n// 2 * sqrt((r_0 * p_0) * (r_1 * p_1)) / LP_supply  (7)\r\n//\r\n// The structure of (7) is well-suited for use in fixed-point EVM calculations, as the\r\n// terms (r_0 * p_0) and (r_1 * p_1), being the values of the reserves in the reference unit,\r\n// should have reasonably-bounded sizes. This reduces the likelihood of overflow due to\r\n// tokens with very low prices but large total supplies.\r\n\r\npragma solidity =0.6.12;\r\n\r\ninterface ERC20Like {\r\n    function decimals()         external view returns (uint8);\r\n    function balanceOf(address) external view returns (uint256);\r\n    function totalSupply()      external view returns (uint256);\r\n}\r\n\r\ninterface UniswapV2PairLike {\r\n    function sync()        external;\r\n    function token0()      external view returns (address);\r\n    function token1()      external view returns (address);\r\n    function getReserves() external view returns (uint112,uint112,uint32);  // reserve0, reserve1, blockTimestampLast\r\n}\r\n\r\ninterface OracleLike {\r\n    function read() external view returns (uint256);\r\n}\r\n\r\n// Factory for creating Uniswap V2 LP Token Oracle instances\r\ncontract UNIV2LPOracleFactory {\r\n\r\n    mapping(address => bool) public isOracle;\r\n\r\n    event NewUNIV2LPOracle(address owner, address orcl, bytes32 wat, address indexed tok0, address indexed tok1, address orb0, address orb1);\r\n\r\n    // Create new Uniswap V2 LP Token Oracle instance\r\n    function build(\r\n        address _owner,\r\n        address _src,\r\n        bytes32 _wat,\r\n        address _orb0,\r\n        address _orb1\r\n        ) public returns (address orcl) {\r\n        address tok0 = UniswapV2PairLike(_src).token0();\r\n        address tok1 = UniswapV2PairLike(_src).token1();\r\n        orcl = address(new UNIV2LPOracle(_src, _wat, _orb0, _orb1));\r\n        UNIV2LPOracle(orcl).rely(_owner);\r\n        UNIV2LPOracle(orcl).deny(address(this));\r\n        isOracle[orcl] = true;\r\n        emit NewUNIV2LPOracle(_owner, orcl, _wat, tok0, tok1, _orb0, _orb1);\r\n    }\r\n}\r\n\r\ncontract UNIV2LPOracle {\r\n\r\n    // --- Auth ---\r\n    mapping (address => uint256) public wards;                                       // Addresses with admin authority\r\n    function rely(address _usr) external auth { wards[_usr] = 1; emit Rely(_usr); }  // Add admin\r\n    function deny(address _usr) external auth { wards[_usr] = 0; emit Deny(_usr); }  // Remove admin\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"UNIV2LPOracle/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    address public immutable src;   // Price source\r\n\r\n    // hop and zph are packed into single slot to reduce SLOADs;\r\n    // this outweighs the cost from added bitmasking operations.\r\n    uint8   public stopped;         // Stop/start ability to update\r\n    uint16  public hop = 1 hours;   // Minimum time in between price updates\r\n    uint232 public zph;             // Time of last price update plus hop\r\n\r\n    bytes32 public immutable wat;   // Label of token whose price is being tracked\r\n\r\n    // --- Whitelisting ---\r\n    mapping (address => uint256) public bud;\r\n    modifier toll { require(bud[msg.sender] == 1, \"UNIV2LPOracle/contract-not-whitelisted\"); _; }\r\n\r\n    struct Feed {\r\n        uint128 val;  // Price\r\n        uint128 has;  // Is price valid\r\n    }\r\n\r\n    Feed    internal cur;  // Current price  (mem slot 0x3)\r\n    Feed    internal nxt;  // Queued price   (mem slot 0x4)\r\n\r\n    // --- Data ---\r\n    uint256 private immutable UNIT_0;  // Numerical representation of one token of token0 (10^decimals) \r\n    uint256 private immutable UNIT_1;  // Numerical representation of one token of token1 (10^decimals) \r\n\r\n    address public            orb0;  // Oracle for token0, ideally a Medianizer\r\n    address public            orb1;  // Oracle for token1, ideally a Medianizer\r\n\r\n    // --- Math ---\r\n    uint256 constant WAD = 10 ** 18;\r\n\r\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\r\n        require((z = _x + _y) >= _x, \"UNIV2LPOracle/add-overflow\");\r\n    }\r\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\r\n        require((z = _x - _y) <= _x, \"UNIV2LPOracle/sub-underflow\");\r\n    }\r\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\r\n        require(_y == 0 || (z = _x * _y) / _y == _x, \"UNIV2LPOracle/mul-overflow\");\r\n    }\r\n\r\n    // FROM https://github.com/abdk-consulting/abdk-libraries-solidity/blob/16d7e1dd8628dfa2f88d5dadab731df7ada70bdd/ABDKMath64x64.sol#L687\r\n    function sqrt (uint256 _x) private pure returns (uint128) {\r\n        if (_x == 0) return 0;\r\n        else {\r\n            uint256 xx = _x;\r\n            uint256 r = 1;\r\n            if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\r\n            if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\r\n            if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\r\n            if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\r\n            if (xx >= 0x100) { xx >>= 8; r <<= 4; }\r\n            if (xx >= 0x10) { xx >>= 4; r <<= 2; }\r\n            if (xx >= 0x8) { r <<= 1; }\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1; // Seven iterations should be enough\r\n            uint256 r1 = _x / r;\r\n            return uint128 (r < r1 ? r : r1);\r\n        }\r\n    }\r\n\r\n    // --- Events ---\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n    event Step(uint256 hop);\r\n    event Stop();\r\n    event Start();\r\n    event Value(uint128 curVal, uint128 nxtVal);\r\n    event Link(uint256 id, address orb);\r\n    event Kiss(address a);\r\n    event Diss(address a);\r\n\r\n    // --- Init ---\r\n    constructor (address _src, bytes32 _wat, address _orb0, address _orb1) public {\r\n        require(_src  != address(0),                        \"UNIV2LPOracle/invalid-src-address\");\r\n        require(_orb0 != address(0) && _orb1 != address(0), \"UNIV2LPOracle/invalid-oracle-address\");\r\n        wards[msg.sender] = 1;\r\n        emit Rely(msg.sender);\r\n        src  = _src;\r\n        wat  = _wat;\r\n        uint256 dec0 = uint256(ERC20Like(UniswapV2PairLike(_src).token0()).decimals());\r\n        require(dec0 <= 18, \"UNIV2LPOracle/token0-dec-gt-18\");\r\n        UNIT_0 = 10 ** dec0;\r\n        uint256 dec1 = uint256(ERC20Like(UniswapV2PairLike(_src).token1()).decimals());\r\n        require(dec1 <= 18, \"UNIV2LPOracle/token1-dec-gt-18\");\r\n        UNIT_1 = 10 ** dec1;\r\n        orb0 = _orb0;\r\n        orb1 = _orb1;\r\n    }\r\n\r\n    function stop() external auth {\r\n        stopped = 1;\r\n        delete cur;\r\n        delete nxt;\r\n        zph = 0;\r\n        emit Stop();\r\n    }\r\n\r\n    function start() external auth {\r\n        stopped = 0;\r\n        emit Start();\r\n    }\r\n\r\n    function step(uint256 _hop) external auth {\r\n        require(_hop <= uint16(-1), \"UNIV2LPOracle/invalid-hop\");\r\n        hop = uint16(_hop);\r\n        emit Step(_hop);\r\n    }\r\n\r\n    function link(uint256 _id, address _orb) external auth {\r\n        require(_orb != address(0), \"UNIV2LPOracle/no-contract-0\");\r\n        if(_id == 0) {\r\n            orb0 = _orb;\r\n        } else if (_id == 1) {\r\n            orb1 = _orb;\r\n        } else {\r\n            revert(\"UNIV2LPOracle/invalid-id\");\r\n        }\r\n        emit Link(_id, _orb);\r\n    }\r\n\r\n    // For consistency with other oracles.\r\n    function zzz() external view returns (uint256) {\r\n        if (zph == 0) return 0;  // backwards compatibility\r\n        return sub(zph, hop);\r\n    }\r\n\r\n    function pass() external view returns (bool) {\r\n        return block.timestamp >= zph;\r\n    }\r\n\r\n    function seek() internal returns (uint128 quote) {\r\n        // Sync up reserves of uniswap liquidity pool\r\n        UniswapV2PairLike(src).sync();\r\n\r\n        // Get reserves of uniswap liquidity pool\r\n        (uint112 r0, uint112 r1,) = UniswapV2PairLike(src).getReserves();\r\n        require(r0 > 0 && r1 > 0, \"UNIV2LPOracle/invalid-reserves\");\r\n\r\n        // All Oracle prices are priced with 18 decimals against USD\r\n        uint256 p0 = OracleLike(orb0).read();  // Query token0 price from oracle (WAD)\r\n        require(p0 != 0, \"UNIV2LPOracle/invalid-oracle-0-price\");\r\n        uint256 p1 = OracleLike(orb1).read();  // Query token1 price from oracle (WAD)\r\n        require(p1 != 0, \"UNIV2LPOracle/invalid-oracle-1-price\");\r\n\r\n        // Get LP token supply\r\n        uint256 supply = ERC20Like(src).totalSupply();\r\n\r\n        // This calculation should be overflow-resistant even for tokens with very high or very\r\n        // low prices, as the dollar value of each reserve should lie in a fairly controlled range\r\n        // regardless of the token prices.\r\n        uint256 value0 = mul(p0, uint256(r0)) / UNIT_0;  // WAD\r\n        uint256 value1 = mul(p1, uint256(r1)) / UNIT_1;  // WAD\r\n        uint256 preq = mul(2 * WAD, sqrt(mul(value0, value1))) / supply;  // Will revert if supply == 0\r\n        require(preq < 2 ** 128, \"UNIV2LPOracle/quote-overflow\");\r\n        quote = uint128(preq);  // WAD\r\n    }\r\n\r\n    function poke() external {\r\n\r\n        // Ensure a single SLOAD while avoiding solc's excessive bitmasking bureaucracy.\r\n        uint256 hop_;\r\n        {\r\n\r\n            // Block-scoping these variables saves some gas.\r\n            uint256 stopped_;\r\n            uint256 zph_;\r\n            assembly {\r\n                let slot1 := sload(1)\r\n                stopped_  := and(slot1,         0xff  )\r\n                hop_      := and(shr(8, slot1), 0xffff)\r\n                zph_      := shr(24, slot1)\r\n            }\r\n\r\n            // When stopped, values are set to zero and should remain such; thus, disallow updating in that case.\r\n            require(stopped_ == 0, \"UNIV2LPOracle/is-stopped\");\r\n\r\n            // Equivalent to requiring that pass() returns true.\r\n            // The logic is repeated instead of calling pass() to save gas\r\n            // (both by eliminating an internal call here, and allowing pass to be external).\r\n            require(block.timestamp >= zph_, \"UNIV2LPOracle/not-passed\");\r\n        }\r\n\r\n        uint128 val = seek();\r\n        require(val != 0, \"UNIV2LPOracle/invalid-price\");\r\n        Feed memory cur_ = nxt;  // This memory value is used to save an SLOAD later.\r\n        cur = cur_;\r\n        nxt = Feed(val, 1);\r\n\r\n        // The below is equivalent to:\r\n        //\r\n        //    zph = block.timestamp + hop\r\n        //\r\n        // but ensures no extra SLOADs are performed.\r\n        //\r\n        // Even if _hop = (2^16 - 1), the maximum possible value, add(timestamp(), _hop)\r\n        // will not overflow (even a 232 bit value) for a very long time.\r\n        //\r\n        // Also, we know stopped was zero, so there is no need to account for it explicitly here.\r\n        assembly {\r\n            sstore(\r\n                1,\r\n                add(\r\n                    // zph value starts 24 bits in\r\n                    shl(24, add(timestamp(), hop_)),\r\n\r\n                    // hop value starts 8 bits in\r\n                    shl(8, hop_)\r\n                )\r\n            )\r\n        }\r\n\r\n        // Equivalent to emitting Value(cur.val, nxt.val), but averts extra SLOADs.\r\n        emit Value(cur_.val, val);\r\n\r\n        // Safe to terminate immediately since no postfix modifiers are applied.\r\n        assembly {\r\n            stop()\r\n        }\r\n    }\r\n\r\n    function peek() external view toll returns (bytes32,bool) {\r\n        return (bytes32(uint256(cur.val)), cur.has == 1);\r\n    }\r\n\r\n    function peep() external view toll returns (bytes32,bool) {\r\n        return (bytes32(uint256(nxt.val)), nxt.has == 1);\r\n    }\r\n\r\n    function read() external view toll returns (bytes32) {\r\n        require(cur.has == 1, \"UNIV2LPOracle/no-current-value\");\r\n        return (bytes32(uint256(cur.val)));\r\n    }\r\n\r\n    function kiss(address _a) external auth {\r\n        require(_a != address(0), \"UNIV2LPOracle/no-contract-0\");\r\n        bud[_a] = 1;\r\n        emit Kiss(_a);\r\n    }\r\n\r\n    function kiss(address[] calldata _a) external auth {\r\n        for(uint256 i = 0; i < _a.length; i++) {\r\n            require(_a[i] != address(0), \"UNIV2LPOracle/no-contract-0\");\r\n            bud[_a[i]] = 1;\r\n            emit Kiss(_a[i]);\r\n        }\r\n    }\r\n\r\n    function diss(address _a) external auth {\r\n        bud[_a] = 0;\r\n        emit Diss(_a);\r\n    }\r\n\r\n    function diss(address[] calldata _a) external auth {\r\n        for(uint256 i = 0; i < _a.length; i++) {\r\n            bud[_a[i]] = 0;\r\n            emit Diss(_a[i]);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_src\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_wat\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_orb0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_orb1\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Deny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"Diss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"Kiss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"orb\",\"type\":\"address\"}],\"name\":\"Link\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Rely\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Start\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hop\",\"type\":\"uint256\"}],\"name\":\"Step\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Stop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"curVal\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"nxtVal\",\"type\":\"uint128\"}],\"name\":\"Value\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bud\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_a\",\"type\":\"address[]\"}],\"name\":\"diss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"diss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hop\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_a\",\"type\":\"address[]\"}],\"name\":\"kiss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"kiss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_orb\",\"type\":\"address\"}],\"name\":\"link\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orb0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orb1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pass\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"peek\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"peep\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"read\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"src\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hop\",\"type\":\"uint256\"}],\"name\":\"step\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wat\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zph\",\"outputs\":[{\"internalType\":\"uint232\",\"name\":\"\",\"type\":\"uint232\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zzz\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UNIV2LPOracle","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a478c2975ab1ea89e8196811f51a7b7ade33eb11554e49563244414945544800000000000000000000000000000000000000000000000000000000000000000047c3dc029825da43be595e21fffd0b66ffcb7f6e00000000000000000000000064de91f5a373cd4c28de3600cb34c7c6ce410c85","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6c71ea5b4a3564b81590e23af73a03746aee6212e2106a64806d6047deb00c0b"}]}