{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.12\r\n\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface GaugeController:\r\n    def vote_user_slopes(user: address, gauge: address) -> VotedSlope: view\r\n    def last_user_vote(user: address, gauge: address) -> uint256: view\r\n    def points_weight(gauge: address, time: uint256) -> Point: view\r\n    def checkpoint_gauge(gauge: address): nonpayable\r\n\r\n\r\nstruct Point:\r\n    bias: uint256\r\n    slope: uint256\r\n\r\nstruct VotedSlope:\r\n    slope: uint256\r\n    power: uint256\r\n    end: uint256\r\n\r\n\r\nWEEK: constant(uint256) = 86400 * 7\r\nGAUGE_CONTROLLER: constant(address) = 0x2F50D538606Fa9EDD2B11E2446BEb18C9D5846bB\r\nPRECISION: constant(uint256) = 10**18\r\n\r\ngauge: public(address)\r\nreward_token: public(address)\r\n\r\nactive_period: public(uint256)\r\nreward_per_token: public(uint256)\r\n\r\nlast_user_claim: public(HashMap[address, uint256])\r\n\r\n\r\n@external\r\ndef __init__(_gauge: address, _reward_token: address):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _gauge Gauge address to incentivize\r\n    @param _reward_token Incentive token address\r\n    \"\"\"\r\n    self.gauge = _gauge\r\n    self.reward_token = _reward_token\r\n    self.active_period = block.timestamp / WEEK * WEEK\r\n\r\n\r\n@internal\r\ndef _update_period() -> uint256:\r\n    period: uint256 = self.active_period\r\n    if block.timestamp >= period + WEEK:\r\n        gauge: address = self.gauge\r\n        period = block.timestamp / WEEK * WEEK\r\n        GaugeController(GAUGE_CONTROLLER).checkpoint_gauge(gauge)\r\n        slope: uint256 = GaugeController(GAUGE_CONTROLLER).points_weight(gauge, period).slope\r\n        amount: uint256 = ERC20(self.reward_token).balanceOf(self)\r\n        self.reward_per_token = amount * PRECISION / slope\r\n        self.active_period = period\r\n\r\n    return period\r\n\r\n\r\n@external\r\ndef add_reward_amount(_amount: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Add reward tokens to the contract\r\n    @dev Rewards are fully claimable at the beginning of the next epoch week, based\r\n         on the result of current week's gauge weight vote. Rewards that are unclaimed\r\n         by the end of the week are rolled over into the following week.\r\n    @param _amount Amount of `reward_token` to transfer\r\n    @return Success bool\r\n    \"\"\"\r\n    self._update_period()\r\n    assert ERC20(self.reward_token).transferFrom(msg.sender, self, _amount)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef claim_reward(_user: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice Claim a reward for a gauge-weight vote\r\n    @dev Rewards are only claimable for the current epoch week, based on the user's\r\n         active gauge weight vote. The vote must have been made prior to the start\r\n         of the current week. Rewards left unclaimed in a week are lost.\r\n    @param _user User to claim for\r\n    @return Amount of reward claimed\r\n    \"\"\"\r\n    period: uint256 = self._update_period()\r\n    amount: uint256 = 0\r\n    if self.last_user_claim[_user] < period:\r\n        self.last_user_claim[_user] = period\r\n        gauge: address = self.gauge\r\n        last_vote: uint256 = GaugeController(GAUGE_CONTROLLER).last_user_vote(_user, gauge)\r\n        if last_vote < period:\r\n            slope: uint256 = GaugeController(GAUGE_CONTROLLER).vote_user_slopes(_user, gauge).slope\r\n            amount = slope * self.reward_per_token / PRECISION\r\n            if amount > 0:\r\n                assert ERC20(self.reward_token).transfer(_user, amount)\r\n\r\n    return amount","ABI":"[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"},{\"name\":\"_reward_token\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_reward_amount\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":92560},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_reward\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_reward\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2448},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2478},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"active_period\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2508},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_per_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2538},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_user_claim\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2783}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.12","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000b9c05b8ee41fdcbd9956114b3af15834fdedcb540000000000000000000000004e15361fd6b4bb609fa63c81a2be19d873717870","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}