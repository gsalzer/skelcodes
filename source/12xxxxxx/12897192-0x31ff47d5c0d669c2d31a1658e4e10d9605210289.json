{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/interfaces/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.4;\\n\\ninterface IERC1155 {\\n  /****************************************|\\n  |                 Events                 |\\n  |_______________________________________*/\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferSingle(\\n    address indexed _operator,\\n    address indexed _from,\\n    address indexed _to,\\n    uint256 _id,\\n    uint256 _amount\\n  );\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferBatch(\\n    address indexed _operator,\\n    address indexed _from,\\n    address indexed _to,\\n    uint256[] _ids,\\n    uint256[] _amounts\\n  );\\n\\n  /**\\n   * @dev MUST emit when an approval is updated\\n   */\\n  event ApprovalForAll(\\n    address indexed _owner,\\n    address indexed _operator,\\n    bool _approved\\n  );\\n\\n  /****************************************|\\n  |                Functions               |\\n  |_______________________________________*/\\n\\n  /**\\n   * @notice Transfers amount of an _id from the _from address to the _to address specified\\n   * @dev MUST emit TransferSingle event on success\\n   * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\\n   * MUST throw if `_to` is the zero address\\n   * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\\n   * MUST throw on any other error\\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n   * @param _from    Source address\\n   * @param _to      Target address\\n   * @param _id      ID of the token type\\n   * @param _amount  Transfered amount\\n   * @param _data    Additional data with no specified format, sent in call to `_to`\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _id,\\n    uint256 _amount,\\n    bytes calldata _data\\n  ) external;\\n\\n  /**\\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\n   * @dev MUST emit TransferBatch event on success\\n   * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\\n   * MUST throw if `_to` is the zero address\\n   * MUST throw if length of `_ids` is not the same as length of `_amounts`\\n   * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\\n   * MUST throw on any other error\\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n   * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\\n   * @param _from     Source addresses\\n   * @param _to       Target addresses\\n   * @param _ids      IDs of each token type\\n   * @param _amounts  Transfer amounts per token type\\n   * @param _data     Additional data with no specified format, sent in call to `_to`\\n   */\\n  function safeBatchTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256[] calldata _ids,\\n    uint256[] calldata _amounts,\\n    bytes calldata _data\\n  ) external;\\n\\n  /**\\n   * @notice Get the balance of an account's Tokens\\n   * @param _owner  The address of the token holder\\n   * @param _id     ID of the Token\\n   * @return        The _owner's balance of the Token type requested\\n   */\\n  function balanceOf(address _owner, uint256 _id)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @notice Get the balance of multiple account/token pairs\\n   * @param _owners The addresses of the token holders\\n   * @param _ids    ID of the Tokens\\n   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\\n   */\\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\\n    external\\n    view\\n    returns (uint256[] memory);\\n\\n  /**\\n   * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of caller's tokens\\n   * @dev MUST emit the ApprovalForAll event on success\\n   * @param _operator  Address to add to the set of authorized operators\\n   * @param _approved  True if the operator is approved, false to revoke approval\\n   */\\n  function setApprovalForAll(address _operator, bool _approved) external;\\n\\n  /**\\n   * @notice Queries the approval status of an operator for a given owner\\n   * @param _owner     The owner of the Tokens\\n   * @param _operator  Address of authorized operator\\n   * @return isOperator True if the operator is approved, false if not\\n   */\\n  function isApprovedForAll(address _owner, address _operator)\\n    external\\n    view\\n    returns (bool isOperator);\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/interfaces/IERC1155TokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.4;\\n\\n/**\\n * @dev ERC-1155 interface for accepting safe transfers.\\n */\\ninterface IERC1155TokenReceiver {\\n  /**\\n   * @notice Handle the receipt of a single ERC1155 token type\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\\n   * This function MAY throw to revert and reject the transfer\\n   * Return of other amount than the magic value MUST result in the transaction being reverted\\n   * Note: The token contract address is always the message sender\\n   * @param _operator  The address which called the `safeTransferFrom` function\\n   * @param _from      The address which previously owned the token\\n   * @param _id        The id of the token being transferred\\n   * @param _amount    The amount of tokens being transferred\\n   * @param _data      Additional data with no specified format\\n   * @return           `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n   */\\n  function onERC1155Received(\\n    address _operator,\\n    address _from,\\n    uint256 _id,\\n    uint256 _amount,\\n    bytes calldata _data\\n  ) external returns (bytes4);\\n\\n  /**\\n   * @notice Handle the receipt of multiple ERC1155 token types\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\\n   * This function MAY throw to revert and reject the transfer\\n   * Return of other amount than the magic value WILL result in the transaction being reverted\\n   * Note: The token contract address is always the message sender\\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\\n   * @param _from      The address which previously owned the token\\n   * @param _ids       An array containing ids of each token being transferred\\n   * @param _amounts   An array containing amounts of each token being transferred\\n   * @param _data      Additional data with no specified format\\n   * @return           `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n   */\\n  function onERC1155BatchReceived(\\n    address _operator,\\n    address _from,\\n    uint256[] calldata _ids,\\n    uint256[] calldata _amounts,\\n    bytes calldata _data\\n  ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.4;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface IERC20 {\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function approve(address spender, uint256 value) external returns (bool);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT AND Apache-2.0\\npragma solidity 0.7.4;\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n  // Default hash for EOA accounts returned by extcodehash\\n  bytes32 internal constant ACCOUNT_HASH =\\n    0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n  /**\\n   * Returns whether the target address is a contract\\n   * @dev This function will return false if invoked during the constructor of a contract.\\n   * @param _address address of the account to check\\n   * @return Whether the target address is a contract\\n   */\\n  function isContract(address _address) internal view returns (bool) {\\n    bytes32 codehash;\\n\\n    // Currently there is no better way to check if there is a contract in an address\\n    // than to check the size of the code at that address or if it has a non-zero code hash or account hash\\n    assembly {\\n      codehash := extcodehash(_address)\\n    }\\n    return (codehash != 0x0 && codehash != ACCOUNT_HASH);\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(isContract(target), 'Address: call to non-contract');\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = target.call(data);\\n\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT AND Apache-2.0\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport '../interfaces/IERC20.sol';\\nimport '../utils/SafeMath.sol';\\nimport '../utils/Address.sol';\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transfer.selector, to, value)\\n    );\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n    );\\n  }\\n\\n  /**\\n   * @dev Deprecated. This function has issues similar to the ones found in\\n   * {IERC20-approve}, and its usage is discouraged.\\n   *\\n   * Whenever possible, use {safeIncreaseAllowance} and\\n   * {safeDecreaseAllowance} instead.\\n   */\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    // safeApprove should only be called when setting an initial allowance,\\n    // or when resetting it to zero. To increase and decrease it, use\\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n    // solhint-disable-next-line max-line-length\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\n    );\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, value)\\n    );\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n    );\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n    );\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\n   * @param token The token targeted by the call.\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\n   */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata =\\n      address(token).functionCall(data, 'SafeERC20: low-level call failed');\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      // solhint-disable-next-line max-line-length\\n      require(\\n        abi.decode(returndata, (bool)),\\n        'SafeERC20: ERC20 operation did not succeed'\\n      );\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.4;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Multiplies two unsigned integers, reverts on overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath#mul: OVERFLOW');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, 'SafeMath#div: DIVISION_BY_ZERO');\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a, 'SafeMath#sub: UNDERFLOW');\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Adds two unsigned integers, reverts on overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath#add: OVERFLOW');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n   * reverts when dividing by zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'SafeMath#mod: DIVISION_BY_ZERO');\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/curve/CurveDepositInterface.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/* solhint-disable func-name-mixedcase */\\nabstract contract ICurveFiDepositY {\\n  function add_liquidity(uint256[4] calldata uAmounts, uint256 minMintAmount)\\n    external\\n    virtual;\\n\\n  function remove_liquidity(uint256 amount, uint256[4] calldata minUAmounts)\\n    external\\n    virtual;\\n\\n  function remove_liquidity_imbalance(\\n    uint256[4] calldata uAmounts,\\n    uint256 maxBurnAmount\\n  ) external virtual;\\n\\n  function calc_withdraw_one_coin(uint256 wrappedAmount, int128 coinIndex)\\n    external\\n    view\\n    virtual\\n    returns (uint256 underlyingAmount);\\n\\n  function remove_liquidity_one_coin(\\n    uint256 wrappedAmount,\\n    int128 coinIndex,\\n    uint256 minAmount,\\n    bool donateDust\\n  ) external virtual;\\n\\n  function coins(int128 i) external view virtual returns (address);\\n\\n  function underlying_coins(int128 i) external view virtual returns (address);\\n\\n  function underlying_coins() external view virtual returns (address[4] memory);\\n\\n  function curve() external view virtual returns (address);\\n\\n  function token() external view virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/src/cfolio/CFolioItemHandlerSC.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/Context.sol';\\n\\nimport '../../0xerc1155/interfaces/IERC1155.sol';\\nimport '../../0xerc1155/interfaces/IERC1155TokenReceiver.sol';\\nimport '../../0xerc1155/interfaces/IERC20.sol';\\nimport '../../0xerc1155/utils/SafeERC20.sol';\\nimport '../../0xerc1155/utils/SafeMath.sol';\\nimport '../../interfaces/curve/CurveDepositInterface.sol';\\n\\nimport '../investment/interfaces/ICFolioFarm.sol'; // Wolves rewards\\nimport '../token/interfaces/IWOWSCryptofolio.sol';\\nimport '../token/interfaces/IWOWSERC1155.sol'; // SFT contract\\nimport '../utils/interfaces/IAddressRegistry.sol';\\nimport '../utils/AddressBook.sol';\\nimport '../utils/TokenIds.sol';\\n\\nimport './interfaces/ICFolioItemHandler.sol';\\nimport './interfaces/ISFTEvaluator.sol';\\n\\n/**\\n * @dev CFolioItemHandlerSC manages CFolioItems, minted in the SFT contract.\\n *\\n * Minting CFolioItem SFTs is implemented in the WOWSSFTMinter contract, which\\n * mints the SFT in the WowsERC1155 contract and calls setupCFolio in here.\\n *\\n * Normaly CFolioItem SFTs are locked in the main TradeFloor contract to allow\\n * trading or transfer into a Base SFT card's c-folio.\\n *\\n * CFolioItem SFTs only earn rewards if they are inside the cfolio of a base\\n * NFT. We get called from main TradeFloor every time an CFolioItem gets\\n * transfered and calculate the new rewardable ?? amount based on the reward %\\n * of the base NFT.\\n */\\ncontract CFolioItemHandlerSC is ICFolioItemHandler, Context {\\n  using SafeMath for uint256;\\n  using TokenIds for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Routing\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  // Route to SFT Minter. Only setup from SFT Minter allowed.\\n  address public sftMinter;\\n\\n  // The TradeFloor contract which provides c-folio NFTs. This TradeFloor\\n  // contract calls the IMinterCallback interface functions.\\n  address public immutable tradeFloor;\\n\\n  // SFT evaluator\\n  ISFTEvaluator public immutable sftEvaluator;\\n\\n  // Reward emitter\\n  ICFolioFarmOwnable public immutable cfolioFarm;\\n\\n  // Admin\\n  address public immutable admin;\\n\\n  // The SFT contract needed to check if the address is a c-folio\\n  IWOWSERC1155 private immutable sftHolder;\\n\\n  // Address registry containing system addresses\\n  IAddressRegistry private immutable _addressRegistry;\\n\\n  // Curve Y pool token contract\\n  IERC20 public immutable curveYToken;\\n\\n  // Curve Y pool deposit contract\\n  ICurveFiDepositY public immutable curveYDeposit;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Events\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /*\\n   * @dev Emitted when a reward is updated, either increased or decreased\\n   *\\n   * @param previousAmount The amount before updating the reward\\n   * @param newAmount The amount after updating the reward\\n   */\\n  event SCRewardUpdated(uint256 previousAmount, uint256 newAmount);\\n\\n  /**\\n   * @dev Emitted when a new minter is set by the admin\\n   *\\n   * @param minter The new minter\\n   */\\n  event NewSCMinter(address minter);\\n\\n  /**\\n   * @dev Emitted when the contract is upgraded\\n   *\\n   * @param thisContract The address of this contract\\n   * @param newContract The address of the contract being upgraded to\\n   */\\n  event SCContractUpgraded(address thisContract, address newContract);\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Modifiers\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  modifier onlyTradeFloor {\\n    require(_msgSender() == address(tradeFloor), 'TFCLP: only TF');\\n    _;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Initialization\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Constructs the CFolioItemHandlerSC\\n   *\\n   * We gather all current addresses from address registry into immutable vars.\\n   * If one of the relevant addresses changes, the contract has to be updated.\\n   * There is little state here, user state is completely handled in CFolioFarm.\\n   */\\n  constructor(IAddressRegistry addressRegistry) {\\n    // Address registry\\n    _addressRegistry = addressRegistry;\\n\\n    // TradeFloor\\n    tradeFloor = addressRegistry.getRegistryEntry(\\n      AddressBook.TRADE_FLOOR_PROXY\\n    );\\n\\n    // Admin\\n    admin = addressRegistry.getRegistryEntry(AddressBook.MARKETING_WALLET);\\n\\n    // The SFT holder\\n    sftHolder = IWOWSERC1155(\\n      addressRegistry.getRegistryEntry(AddressBook.SFT_HOLDER)\\n    );\\n\\n    // The SFT minter\\n    sftMinter = addressRegistry.getRegistryEntry(AddressBook.SFT_MINTER);\\n    emit NewSCMinter(sftMinter);\\n\\n    // SFT evaluator\\n    sftEvaluator = ISFTEvaluator(\\n      addressRegistry.getRegistryEntry(AddressBook.SFT_EVALUATOR_PROXY)\\n    );\\n\\n    // The Y pool deposit contract\\n    curveYDeposit = ICurveFiDepositY(\\n      addressRegistry.getRegistryEntry(AddressBook.CURVE_Y_DEPOSIT)\\n    );\\n\\n    // The Y pool token contract\\n    curveYToken = IERC20(\\n      addressRegistry.getRegistryEntry(AddressBook.CURVE_Y_TOKEN)\\n    );\\n\\n    // WOWS reward farm\\n    cfolioFarm = ICFolioFarmOwnable(\\n      addressRegistry.getRegistryEntry(AddressBook.BOIS_REWARDS)\\n    );\\n  }\\n\\n  /**\\n   * @dev One time contract initializer\\n   */\\n  function initialize() public {\\n    // Approve stablecoin spending\\n    for (uint256 i = 0; i < 4; ++i) {\\n      address underlyingCoin = curveYDeposit.underlying_coins(int128(i));\\n      IERC20(underlyingCoin).safeApprove(address(curveYDeposit), uint256(-1));\\n    }\\n\\n    // Approve yCRV spending\\n    curveYToken.approve(address(curveYDeposit), uint256(-1));\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Implementation of {ICFolioItemCallback} via {ICFolioItemHandler}\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev See {ICFolioItemCallback-onCFolioItemsTransferedFrom}\\n   */\\n  function onCFolioItemsTransferedFrom(\\n    address from,\\n    address to,\\n    uint256[] calldata, /* tokenIds*/\\n    address[] calldata /* cfolioHandlers*/\\n  ) external override onlyTradeFloor {\\n    // In case of transfer verify the target\\n    uint256 sftTokenId;\\n\\n    if (\\n      to != address(0) &&\\n      (sftTokenId = sftHolder.addressToTokenId(to)) != uint256(-1)\\n    ) {\\n      (, uint8 level) = sftHolder.getTokenData(sftTokenId);\\n      require((LEVEL2BOIS & (uint256(1) << level)) > 0, 'CFIH: Bois only');\\n      _updateRewards(to, sftEvaluator.rewardRate(sftTokenId));\\n    }\\n\\n    if (\\n      from != address(0) &&\\n      (sftTokenId = sftHolder.addressToTokenId(from)) != uint256(-1)\\n    ) _updateRewards(from, sftEvaluator.rewardRate(sftTokenId));\\n  }\\n\\n  /**\\n   * @dev See {ICFolioItemCallback-appendHash}\\n   */\\n  function appendHash(address cfolioItem, bytes calldata current)\\n    external\\n    view\\n    override\\n    returns (bytes memory)\\n  {\\n    return\\n      abi.encodePacked(\\n        current,\\n        address(this),\\n        cfolioFarm.balanceOf(cfolioItem)\\n      );\\n  }\\n\\n  /**\\n   * @dev See {ICFolioItemCallback-uri}\\n   */\\n  function uri(\\n    uint256 /* tokenId */\\n  ) external pure override returns (string memory) {\\n    return '';\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Implementation of {ICFolioItemHandler}\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev See {ICFolioItemHandler-sftUpgrade}\\n   */\\n  function sftUpgrade(uint256 tokenId, uint32 newRate) external override {\\n    // Validate access\\n    require(_msgSender() == address(sftEvaluator), 'CFIH: Invalid caller');\\n    require(tokenId.isBaseCard(), 'CFIH: Invalid token');\\n\\n    // CFolio address\\n    address cfolio = sftHolder.tokenIdToAddress(tokenId);\\n\\n    // Update state\\n    _updateRewards(cfolio, newRate);\\n  }\\n\\n  /**\\n   * @dev See {ICFolioItemHandler-setupCFolio}\\n   *\\n   * Note: We place a dummy ERC1155 token with ID 0 into the CFolioItem's\\n   * c-folio. The reason is that we want to know if a c-folio item gets burned,\\n   * as burning an empty c-folio will result in no transfers. This prevents LP\\n   * tokens from becoming inaccessible.\\n   *\\n   * Refer to the Minimal ERC1155 section below to learn which functions are\\n   * needed for this.\\n   *\\n   * @param sftTokenId The token ID of the SFT being setup\\n   * @param amounts The token amounts, in this order: DAI, USDC, USDT, TUSD, yCRV\\n   * `amounts` can be empty when setting up a CFolio with no initial investments.\\n   */\\n  function setupCFolio(\\n    address payer,\\n    uint256 sftTokenId,\\n    uint256[] calldata amounts\\n  ) external override {\\n    // Validate access\\n    require(_msgSender() == sftMinter, 'Only SFTMinter');\\n\\n    // Validate parameters, no unmasking required, must be SFT\\n    address cFolio = sftHolder.tokenIdToAddress(sftTokenId);\\n    require(cFolio != address(0), 'Invalid sftTokenId');\\n    require(\\n      amounts.length == 0 || amounts.length == 5,\\n      'Need DAI/USDC/USDT/TUSD/yCRV'\\n    );\\n\\n    // Verify that this function is called the first time\\n    (, uint256 length) = IWOWSCryptofolio(cFolio).getCryptofolio(address(this));\\n    require(length == 0, 'CFIH: TradeFloor not empty');\\n\\n    // Keep track of how many Y pool tokens were received\\n    uint256 beforeBalance = curveYToken.balanceOf(address(this));\\n\\n    // Handle stablecoins\\n    if (amounts.length > 0) {\\n      uint256[4] memory stableAmounts;\\n      uint256 totalStableAmount;\\n      for (uint256 i = 0; i < 4; ++i) {\\n        address underlyingCoin = curveYDeposit.underlying_coins(int128(i));\\n\\n        IERC20(underlyingCoin).safeTransferFrom(\\n          payer,\\n          address(this),\\n          amounts[i]\\n        );\\n\\n        uint256 stableAmount = IERC20(underlyingCoin).balanceOf(address(this));\\n\\n        stableAmounts[i] = stableAmount;\\n        totalStableAmount += stableAmount;\\n      }\\n\\n      if (totalStableAmount > 0) {\\n        // Call to external contract\\n        curveYDeposit.add_liquidity(stableAmounts, 0);\\n\\n        // Validate state\\n        uint256 afterStableBalance = curveYToken.balanceOf(address(this));\\n        require(\\n          afterStableBalance > beforeBalance,\\n          'No liquidity from stables'\\n        );\\n      }\\n\\n      // Handle Y pool\\n      uint256 yPoolAmount = amounts[4];\\n\\n      if (yPoolAmount > 0) {\\n        curveYToken.transferFrom(payer, address(this), yPoolAmount);\\n      }\\n\\n      // Validate state\\n      uint256 afterBalance = curveYToken.balanceOf(address(this));\\n\\n      // Record assets in Farm contract. They don't earn rewards.\\n      // addAsset must only be called from Investment CFolios\\n      // This call is allowed without any investment.\\n      if (afterBalance > beforeBalance)\\n        cfolioFarm.addAssets(cFolio, afterBalance.sub(beforeBalance));\\n    }\\n\\n    // Transfer a dummy NFT token to cFolio so we get informed if the cFolio\\n    // gets burned\\n    IERC1155TokenReceiver(cFolio).onERC1155Received(\\n      address(this),\\n      address(0),\\n      0,\\n      1,\\n      ''\\n    );\\n  }\\n\\n  /**\\n   * @dev See {ICFolioItemHandler-deposit}\\n   *\\n   * Note: tokenId can be owned by a base SFT. In this case base SFT cannot be\\n   *     locked.\\n   *\\n   * There is only need to update rewards if tokenId is part of an unlocked\\n   * base SFT.\\n   */\\n  function deposit(\\n    uint256 baseTokenId,\\n    uint256 tokenId,\\n    uint256[] calldata amounts\\n  ) external override {\\n    // Validate parameters\\n    require(amounts.length == 5, 'Need DAI/USDC/USDT/TUSD/yCRV');\\n    (address baseCFolio, address itemCFolio) =\\n      _verifyAssetAccess(baseTokenId, tokenId);\\n\\n    // Keep track of how many Y pool tokens were received\\n    uint256 beforeBalance = curveYToken.balanceOf(address(this));\\n\\n    // Handle stablecoins\\n    uint256[4] memory stableAmounts;\\n    uint256 totalStableAmount;\\n    for (uint256 i = 0; i < 4; ++i) {\\n      address underlyingCoin = curveYDeposit.underlying_coins(int128(i));\\n\\n      IERC20(underlyingCoin).safeTransferFrom(\\n        _msgSender(),\\n        address(this),\\n        amounts[i]\\n      );\\n\\n      uint256 stableAmount = IERC20(underlyingCoin).balanceOf(address(this));\\n\\n      stableAmounts[i] = stableAmount;\\n      totalStableAmount += stableAmount;\\n    }\\n\\n    if (totalStableAmount > 0) {\\n      // Call to external contract\\n      curveYDeposit.add_liquidity(stableAmounts, 0);\\n\\n      // Validate state\\n      uint256 afterStableBalance = curveYToken.balanceOf(address(this));\\n      require(afterStableBalance > beforeBalance, 'No liquidity from stables');\\n    }\\n\\n    // Handle Y pool\\n    uint256 yPoolAmount = amounts[4];\\n\\n    if (yPoolAmount > 0) {\\n      curveYToken.transferFrom(_msgSender(), address(this), yPoolAmount);\\n    }\\n\\n    // Validate state\\n    uint256 afterBalance = curveYToken.balanceOf(address(this));\\n    require(afterBalance > beforeBalance, 'No liquidity added');\\n\\n    // Record assets in Farm contract. They don't earn rewards.\\n    // addAsset must only be called from Investment CFolios\\n    cfolioFarm.addAssets(itemCFolio, afterBalance.sub(beforeBalance));\\n\\n    if (baseTokenId != uint256(-1)) {\\n      _updateRewards(baseCFolio, sftEvaluator.rewardRate(baseTokenId));\\n    }\\n  }\\n\\n  /**\\n   * @dev See {ICFolioItemHandler-withdraw}\\n   *\\n   * Note: tokenId can be owned by a base SFT. In this case, the base SFT\\n   * cannot be locked.\\n   *\\n   * There is only need to update rewards if tokenId is part of an unlocked\\n   * base SFT.\\n   *\\n   * @param baseTokenId The token ID of the base c-folio, or uint(-1) if\\n   *     tokenId is not owned by a base c-folio.\\n   * @param tokenId The token ID of the investment SFT to withdraw from\\n   * @param amounts The amounts, with the tokens being DAI/USDC/USDT/TUSD/yCRV.\\n   *     yCRV must be specified, as yCRV tokens are held by this contract.\\n   *     If all four stablecoin amounts are 0, then yCRV is withdrawn to the\\n   *     sender's wallet. If exactly one of the four stablecoin amounts is > 0,\\n   *     then yCRV will be converted to the specified stablecoin. The amount in\\n   *     the array is the minimum amount of stablecoin tokens that must be\\n   *     withdrawn.\\n   */\\n  function withdraw(\\n    uint256 baseTokenId,\\n    uint256 tokenId,\\n    uint256[] calldata amounts\\n  ) external override {\\n    // Validate parameters\\n    require(amounts.length == 5, 'Need DAI/USDC/USDT/TUSD/yCRV');\\n    (address baseCFolio, address itemCFolio) =\\n      _verifyAssetAccess(baseTokenId, tokenId);\\n\\n    // Validate parameters\\n    uint256 yPoolAmount = amounts[4];\\n    require(yPoolAmount > 0, 'yCRV amount is 0');\\n\\n    // Get single coin and amount\\n    (int128 stableCoinIndex, uint256 stableCoinAmount) =\\n      _getStableCoinInfo(amounts);\\n\\n    // Keep track of how many Y pool tokens were sent\\n    uint256 balanceBefore = curveYToken.balanceOf(address(this));\\n\\n    if (stableCoinIndex != -1) {\\n      // Call to external contract\\n      curveYDeposit.remove_liquidity_one_coin(\\n        yPoolAmount,\\n        stableCoinIndex,\\n        stableCoinAmount,\\n        true\\n      );\\n\\n      address underlyingCoin =\\n        curveYDeposit.underlying_coins(int128(stableCoinIndex));\\n      uint256 underlyingCoinAmount =\\n        IERC20(underlyingCoin).balanceOf(address(this));\\n\\n      // Transfer stablecoins back to the sender\\n      IERC20(underlyingCoin).safeTransfer(_msgSender(), underlyingCoinAmount);\\n    } else {\\n      // No stablecoins were passed, sender is withdrawing Y pool tokens directly\\n      // Transfer Y pool tokens back to the sender\\n      curveYToken.transfer(_msgSender(), yPoolAmount);\\n    }\\n\\n    // Valiate state\\n    uint256 balanceAfter = curveYToken.balanceOf(address(this));\\n    require(balanceAfter < balanceBefore, 'Nothing withdrawn');\\n\\n    // Record assets in Farm contract. They don't earn rewards.\\n    // removeAsset must only be called from Investment CFolios\\n    cfolioFarm.removeAssets(itemCFolio, balanceBefore.sub(balanceAfter));\\n\\n    // Update state\\n    if (baseTokenId != uint256(-1))\\n      _updateRewards(baseCFolio, sftEvaluator.rewardRate(baseTokenId));\\n  }\\n\\n  /**\\n   * @dev See {ICFolioItemHandler-getRewards}\\n   *\\n   * Note: tokenId must be a base SFT card\\n   *\\n   * We allow reward pull only for unlocked SFTs.\\n   */\\n  function getRewards(address recipient, uint256 tokenId) external override {\\n    // Validate parameters\\n    require(recipient != address(0), 'CFIH: Invalid recipient');\\n    require(tokenId.isBaseCard(), 'CFIH: Invalid tokenId');\\n\\n    // Verify that tokenId has a valid cFolio address\\n    uint256 sftTokenId = tokenId.toSftTokenId();\\n    address cfolio = sftHolder.tokenIdToAddress(sftTokenId);\\n    require(cfolio != address(0), 'Invalid c-folio address');\\n\\n    // Verify that the tokenId is owned by msg.sender in case of direct\\n    // call or recipient in case of sftMinter call in the SFT contract.\\n    // This also verifies that the token is not locked in TradeFloor.\\n    require(\\n      IERC1155(address(sftHolder)).balanceOf(_msgSender(), sftTokenId) == 1 ||\\n        (_msgSender() == sftMinter &&\\n          IERC1155(address(sftHolder)).balanceOf(recipient, sftTokenId) == 1),\\n      'CFHI: Access denied'\\n    );\\n\\n    cfolioFarm.getReward(cfolio, recipient);\\n  }\\n\\n  /**\\n   * @dev See {ICFolioItemHandler-getAmounts}\\n   *\\n   * The returned token array is DAI/USDC/USDT/TUSD/yCRV. Tokens are held in\\n   * this contract as yCRV, so the fifth item will be the amount of yCRV. The\\n   * four stablecoin amounts are the amount that would be withdrawn if all\\n   * yCRV were converted to the corresponding stablecoin upon withdrawal. This\\n   * value is calculated by Curve.\\n   */\\n  function getAmounts(address cfolioItem)\\n    external\\n    view\\n    override\\n    returns (uint256[] memory)\\n  {\\n    uint256[] memory result = new uint256[](5);\\n\\n    uint256 wrappedAmount = cfolioFarm.balanceOf(cfolioItem);\\n\\n    for (uint256 i = 0; i < 4; ++i) {\\n      result[i] = curveYDeposit.calc_withdraw_one_coin(\\n        wrappedAmount,\\n        int128(i)\\n      );\\n    }\\n\\n    result[4] = wrappedAmount;\\n\\n    return result;\\n  }\\n\\n  /**\\n   * @dev See {ICFolioItemHandler-getRewardInfo}\\n   */\\n  function getRewardInfo(uint256[] calldata tokenIds)\\n    external\\n    view\\n    override\\n    returns (bytes memory result)\\n  {\\n    uint256[5] memory uiData;\\n\\n    // get basic data once\\n    uiData = cfolioFarm.getUIData(address(0));\\n    // total / rewardDuration / rewardPerDuration\\n    result = abi.encodePacked(uiData[0], uiData[2], uiData[3]);\\n\\n    for (uint256 i = 0; i < tokenIds.length; ++i) {\\n      uint256 sftTokenId = tokenIds[i].toSftTokenId();\\n      uint256 share = 0;\\n      uint256 earned = 0;\\n      if (sftTokenId.isBaseCard()) {\\n        address cfolio = sftHolder.tokenIdToAddress(sftTokenId);\\n        if (cfolio != address(0)) {\\n          uiData = cfolioFarm.getUIData(cfolio);\\n          share = uiData[1];\\n          earned = uiData[4];\\n        }\\n      }\\n      result = abi.encodePacked(result, share, earned);\\n    }\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Maintanace\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Upgrade contract\\n   */\\n  function upgradeContract(CFolioItemHandlerSC newContract) external {\\n    // Validate access\\n    require(_msgSender() == admin, 'Admin only');\\n\\n    // Let new handler control the reward farm\\n    cfolioFarm.transferOwnership(address(newContract));\\n\\n    // Dispatch event\\n    SCContractUpgraded(address(this), address(newContract));\\n\\n    selfdestruct(payable(address(newContract)));\\n  }\\n\\n  /**\\n   * @dev Set a new SFT minter\\n   */\\n  function setMinter(address newMinter) external {\\n    // Validate access\\n    require(_msgSender() == admin, 'Admin only');\\n\\n    // Validate parameters\\n    require(newMinter != address(0), 'Invalid newMinter');\\n\\n    // Update state\\n    sftMinter = newMinter;\\n\\n    // Dispatch event\\n    emit NewSCMinter(newMinter);\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Minimal ERC1155 implementation (called from SFTBase CFolio)\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  // We do nothing for our dummy burn tokenId\\n  function setApprovalForAll(address, bool) external {}\\n\\n  // Check for length == 1, and then return always 1\\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\\n    external\\n    pure\\n    returns (uint256[] memory)\\n  {\\n    // Validate parameters\\n    require(_owners.length == 1 && _ids.length == 1, 'Length must be 1');\\n\\n    uint256[] memory result = new uint256[](1);\\n    result[0] = 1;\\n    return result;\\n  }\\n\\n  /**\\n   * @dev We don't allow burning non-empty c-folios\\n   */\\n  function burnBatch(\\n    address, /* account */\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata\\n  ) external view {\\n    // Validate parameters\\n    require(tokenIds.length == 1, 'Length must be 1');\\n\\n    // This call originates from the c-folio. We revert if there are investment\\n    // amounts left for this c-folio address.\\n    require(cfolioFarm.balanceOf(_msgSender()) == 0, 'CFIH: not empty');\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Internal details\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Run through all cFolioItems collected in cFolio and select the amount\\n   * of tokens. Update cfolioFarm.\\n   */\\n  function _updateRewards(address cfolio, uint32 rate) private {\\n    // Get c-folio items of this base cFolio\\n    (uint256[] memory tokenIds, uint256 length) =\\n      IWOWSCryptofolio(cfolio).getCryptofolio(tradeFloor);\\n\\n    // Marginal increase in gas per item is around 25K. Bounding items to 100\\n    // fits in sensible gas limits.\\n    require(length <= 100, 'CFIHSC: Too many items');\\n\\n    // Calculate new reward amount\\n    uint256 newRewardAmount = 0;\\n    for (uint256 i = 0; i < length; ++i) {\\n      address secondaryCFolio =\\n        sftHolder.tokenIdToAddress(tokenIds[i].toSftTokenId());\\n      require(secondaryCFolio != address(0), 'CFIH: Invalid secondary cFolio');\\n\\n      if (IWOWSCryptofolio(secondaryCFolio)._tradefloors(0) == address(this))\\n        newRewardAmount = newRewardAmount.add(\\n          cfolioFarm.balanceOf(secondaryCFolio)\\n        );\\n    }\\n    newRewardAmount = newRewardAmount.mul(rate).div(1E6);\\n\\n    // Calculate existing reward amount\\n    uint256 exitingRewardAmount = cfolioFarm.balanceOf(cfolio);\\n\\n    // Compare amounts and add/remove shares\\n    if (newRewardAmount > exitingRewardAmount) {\\n      // Update state\\n      cfolioFarm.addShares(cfolio, newRewardAmount.sub(exitingRewardAmount));\\n\\n      // Dispatch event\\n      emit SCRewardUpdated(exitingRewardAmount, newRewardAmount);\\n    } else if (newRewardAmount < exitingRewardAmount) {\\n      // Update state\\n      cfolioFarm.removeShares(cfolio, exitingRewardAmount.sub(newRewardAmount));\\n\\n      // Dispatch event\\n      emit SCRewardUpdated(exitingRewardAmount, newRewardAmount);\\n    }\\n  }\\n\\n  /**\\n   * @dev Verifies if an asset access operation is allowed\\n   *\\n   * @param baseTokenId Base card tokenId or uint(-1)\\n   * @param cfolioItemTokenId CFolioItem tokenId handled by this contract\\n   *\\n   * A tokenId is \\\"unlocked\\\", if msg.sender is the owner of a tokenId in SFT contract.\\n   * If baseTokenId is uint(-1), cfolioItemTokenId has to be be unlocked, otherwise\\n   * baseTokenId has to be unlocked and the locked cfolioItemTokenId inside its cfolio.\\n   */\\n  function _verifyAssetAccess(uint256 baseTokenId, uint256 cfolioItemTokenId)\\n    private\\n    view\\n    returns (address, address)\\n  {\\n    // Verify it's a cfolioItemTokenId\\n    require(cfolioItemTokenId.isCFolioCard(), 'CFHI: Not CFolioCard');\\n\\n    // Verify that the tokenId is one of ours\\n    address cFolio =\\n      sftHolder.tokenIdToAddress(cfolioItemTokenId.toSftTokenId());\\n    require(cFolio != address(0), 'CFIH: Invalid cFolioTokenId');\\n    require(\\n      IWOWSCryptofolio(cFolio)._tradefloors(0) == address(this),\\n      'CFIH: Not our SFT'\\n    );\\n\\n    address baseCFolio = address(0);\\n\\n    if (baseTokenId != uint256(-1)) {\\n      // Verify it's a cfolio base card\\n      require(baseTokenId.isBaseCard(), 'CFHI: Not baseCard');\\n      baseCFolio = sftHolder.tokenIdToAddress(baseTokenId.toSftTokenId());\\n      require(baseCFolio != address(0), 'CFIH: Invalid baseCFolioTokenId');\\n\\n      // Verify that the tokenId is owned by msg.sender in SFT contract.\\n      // This also verifies that the token is not locked in TradeFloor.\\n      require(\\n        IERC1155(address(sftHolder)).balanceOf(_msgSender(), baseTokenId) == 1,\\n        'CFHI: Access denied (B)'\\n      );\\n\\n      // Verify that the tokenId is owned by given baseCFolio.\\n      require(\\n        IERC1155(address(tradeFloor)).balanceOf(\\n          baseCFolio,\\n          cfolioItemTokenId\\n        ) == 1,\\n        'CFHI: Access denied (CF)'\\n      );\\n    } else {\\n      // Verify that the tokenId is owned by msg.sender in SFT contract.\\n      // This also verifies that the token is not locked in TradeFloor.\\n      require(\\n        IERC1155(address(sftHolder)).balanceOf(\\n          _msgSender(),\\n          cfolioItemTokenId\\n        ) == 1,\\n        'CFHI: Access denied'\\n      );\\n    }\\n    return (baseCFolio, cFolio);\\n  }\\n\\n  /**\\n   * @dev Get single coin and amount\\n   *\\n   * This is a helper function for {withdraw}. Per the documentation above, no\\n   * more than one stablecoin amount can be > 0. If more than one stablecoin\\n   * amount is specified, the revert condition below will be reached.\\n   *\\n   * If exactly one stablecoin amount is specified, then the return values will\\n   * be the index of that coin and its amount.\\n   *\\n   * If no stablecoin amounts are > 0, then a coin index of -1 is returned,\\n   * with a 0 amount.\\n   *\\n   * @param amounts The amounts array: DAI/USDC/USDT/TUSD/yCRV\\n   *\\n   * @return stableCoinIndex The index of the stablecoin with amount > 0, or -1\\n   *     if all four stablecoin amounts are 0\\n   * @return stableCoinAmount The amount of the stablecoin, or 0 if all four\\n   *     stablecoin amounts are 0\\n   */\\n  function _getStableCoinInfo(uint256[] calldata amounts)\\n    private\\n    pure\\n    returns (int128 stableCoinIndex, uint256 stableCoinAmount)\\n  {\\n    stableCoinIndex = -1;\\n\\n    for (uint128 i = 0; i < 4; ++i) {\\n      if (amounts[i] > 0) {\\n        require(stableCoinIndex == -1, 'Multiple amounts > 0');\\n        stableCoinIndex = int8(i);\\n        stableCoinAmount = amounts[i];\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/src/cfolio/interfaces/ICFolioItemHandler.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\nimport '../../token/interfaces/ICFolioItemCallback.sol';\\n\\n/**\\n * @dev Interface to C-folio item contracts\\n */\\ninterface ICFolioItemHandler is ICFolioItemCallback {\\n  /**\\n   * @dev Called when a SFT tokens grade needs re-evaluation\\n   *\\n   * @param tokenId The ERC-1155 token ID. Rate is in 1E6 convention: 1E6 = 100%\\n   * @param newRate The new value rate\\n   */\\n  function sftUpgrade(uint256 tokenId, uint32 newRate) external;\\n\\n  /**\\n   * @dev Called from SFTMinter after an Investment SFT is minted\\n   *\\n   * @param payer The approved address to get investment from\\n   * @param sftTokenId The sftTokenId whose c-folio is the owner of investment\\n   * @param amounts The amounts of invested assets\\n   */\\n  function setupCFolio(\\n    address payer,\\n    uint256 sftTokenId,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Asset access\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Adds investments into a cFolioItem SFT\\n   *\\n   * Transfers amounts of assets from users wallet to the contract. In general,\\n   * an Approval call is required before the function is called.\\n   *\\n   * @param baseTokenId cFolio tokenId, must be unlocked, or -1\\n   * @param tokenId cFolioItem tokenId, must be unlocked if not in unlocked cFolio\\n   * @param amounts Investment amounts, implementation specific\\n   */\\n  function deposit(\\n    uint256 baseTokenId,\\n    uint256 tokenId,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n   * @dev Removes investments from a cFolioItem SFT\\n   *\\n   * Withdrawn token are transfered back to msg.sender.\\n   *\\n   * @param baseTokenId cFolio tokenId, must be unlocked, or -1\\n   * @param tokenId cFolioItem tokenId, must be unlocked if not in unlocked cFolio\\n   * @param amounts Investment amounts, implementation specific\\n   */\\n  function withdraw(\\n    uint256 baseTokenId,\\n    uint256 tokenId,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n   * @dev Get the rewards collected by an SFT base card\\n   *\\n   * @param recipient Recipient of the rewards (- fees)\\n   * @param tokenId SFT base card tokenId, must be unlocked\\n   */\\n  function getRewards(address recipient, uint256 tokenId) external;\\n\\n  /**\\n   * @dev Get amounts (handler specific) for a cfolioItem\\n   *\\n   * @param cfolioItem address of CFolioItem contract\\n   */\\n  function getAmounts(address cfolioItem)\\n    external\\n    view\\n    returns (uint256[] memory);\\n\\n  /**\\n   * @dev Get information obout the rewardFarm\\n   *\\n   * @param tokenIds List of basecard tokenIds\\n   * @return bytes of uint256[]: total, rewardDur, rewardRateForDur, [share, earned]\\n   */\\n  function getRewardInfo(uint256[] calldata tokenIds)\\n    external\\n    view\\n    returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/src/cfolio/interfaces/ISFTEvaluator.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n// BOIS feature bitmask\\nuint256 constant LEVEL2BOIS = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000F;\\nuint256 constant LEVEL2WOLF = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000000000F0;\\n\\ninterface ISFTEvaluator {\\n  /**\\n   * @dev Returns the reward in 1e6 factor notation (1e6 = 100%)\\n   */\\n  function rewardRate(uint256 sftTokenId) external view returns (uint32);\\n\\n  /**\\n   * @dev Returns the cFolioItemType of a given cFolioItem tokenId\\n   */\\n  function getCFolioItemType(uint256 tokenId) external view returns (uint256);\\n\\n  /**\\n   * @dev Calculate the current reward rate, and notify TFC in case of change\\n   *\\n   * Optional revert on unchange to save gas on external calls.\\n   */\\n  function setRewardRate(uint256 tokenId, bool revertUnchanged) external;\\n\\n  /**\\n   * @dev Sets the cfolioItemType of a cfolioItem tokenId, not yet used\\n   * sftHolder tokenId expected (without hash)\\n   */\\n  function setCFolioItemType(uint256 tokenId, uint256 cfolioItemType_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/investment/interfaces/ICFolioFarm.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2020-2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @title ICFolioFarm\\n *\\n * @dev ICFolioFarm is the business logic interface to c-folio farms.\\n */\\ninterface ICFolioFarm {\\n  /**\\n   * @dev Return invested balance of account\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Return total, balances[account], rewardDuration, rewardForDuration, earned[account]\\n   */\\n  function getUIData(address account) external view returns (uint256[5] memory);\\n\\n  /**\\n   * @dev Increase amount of non-rewarded asset\\n   */\\n  function addAssets(address account, uint256 amount) external;\\n\\n  /**\\n   * @dev Remove amount of previous added assets\\n   */\\n  function removeAssets(address account, uint256 amount) external;\\n\\n  /**\\n   * @dev Increase amount of shares and earn rewards\\n   */\\n  function addShares(address account, uint256 amount) external;\\n\\n  /**\\n   * @dev Remove amount of previous added shares, rewards will not be claimed\\n   */\\n  function removeShares(address account, uint256 amount) external;\\n\\n  /**\\n   * @dev Claim rewards harvested during reward time\\n   */\\n  function getReward(address account, address rewardRecipient) external;\\n\\n  /**\\n   * @dev Remove all shares and call getRewards() in a single step\\n   */\\n  function exit(address account, address rewardRecipient) external;\\n}\\n\\n/**\\n * @title ICFolioFarmOwnable\\n */\\n\\ninterface ICFolioFarmOwnable is ICFolioFarm {\\n  /**\\n   * @dev Transfer ownership\\n   */\\n  function transferOwnership(address newOwner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/token/interfaces/ICFolioItemCallback.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/**\\n * @dev Interface to receive callbacks when minted tokens are burnt\\n */\\ninterface ICFolioItemCallback {\\n  /**\\n   * @dev Called when a TradeFloor CFolioItem is transfered\\n   *\\n   * In case of mint `from` is address(0).\\n   * In case of burn `to` is address(0).\\n   *\\n   * cfolioHandlers are passed to let each cfolioHandler filter for its own\\n   * token. This eliminates the need for creating separate lists.\\n   *\\n   * @param from The account sending the token\\n   * @param to The account receiving the token\\n   * @param tokenIds The ERC-1155 token IDs\\n   * @param cfolioHandlers cFolioItem handlers\\n   */\\n  function onCFolioItemsTransferedFrom(\\n    address from,\\n    address to,\\n    uint256[] calldata tokenIds,\\n    address[] calldata cfolioHandlers\\n  ) external;\\n\\n  /**\\n   * @dev Append data we use later for hashing\\n   *\\n   * @param cfolioItem The token ID of the c-folio item\\n   * @param current The current data being hashes\\n   *\\n   * @return The current data, with internal data appended\\n   */\\n  function appendHash(address cfolioItem, bytes calldata current)\\n    external\\n    view\\n    returns (bytes memory);\\n\\n  /**\\n   * @dev get custom uri for tokenId\\n   */\\n  function uri(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/src/token/interfaces/IWOWSCryptofolio.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/**\\n * @notice Cryptofolio interface\\n */\\ninterface IWOWSCryptofolio {\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Initialization\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Initialize the deployed contract after creation\\n   *\\n   * This is a one time call which sets _deployer to msg.sender.\\n   * Subsequent calls reverts.\\n   */\\n  function initialize() external;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Getters\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Return tradefloor at given index\\n   *\\n   * @param index The 0-based index in the tradefloor array\\n   *\\n   * @return The address of the tradefloor and position index\\n   */\\n  function _tradefloors(uint256 index) external view returns (address);\\n\\n  /**\\n   * @dev Return array of cryptofolio item token IDs\\n   *\\n   * The token IDs belong to the contract TradeFloor.\\n   *\\n   * @param tradefloor The TradeFloor that items belong to\\n   *\\n   * @return tokenIds The token IDs in scope of operator\\n   * @return idsLength The number of valid token IDs\\n   */\\n  function getCryptofolio(address tradefloor)\\n    external\\n    view\\n    returns (uint256[] memory tokenIds, uint256 idsLength);\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // State modifiers\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Set the owner of the underlying NFT\\n   *\\n   * This function is called if ownership of the parent NFT has changed.\\n   *\\n   * The new owner gets allowance to transfer cryptofolio items. The new owner\\n   * is allowed to transfer / burn cryptofolio items. Make sure that allowance\\n   * is removed from previous owner.\\n   *\\n   * @param owner The new owner of the underlying NFT, or address(0) if the\\n   * underlying NFT is being burned\\n   */\\n  function setOwner(address owner) external;\\n\\n  /**\\n   * @dev Allow owner (of parent NFT) to approve external operators to transfer\\n   * our cryptofolio items\\n   *\\n   * The NFT owner is allowed to approve operator to handle cryptofolios.\\n   *\\n   * @param operator The operator\\n   * @param allow True to approve for all NFTs, false to revoke approval\\n   */\\n  function setApprovalForAll(address operator, bool allow) external;\\n\\n  /**\\n   * @dev Burn all cryptofolio items\\n   *\\n   * In case an underlying NFT is burned, we also burn the cryptofolio.\\n   */\\n  function burn() external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/token/interfaces/IWOWSERC1155.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/**\\n * @notice Cryptofolio interface\\n */\\ninterface IWOWSERC1155 {\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Getters\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Check if the specified address is a known tradefloor\\n   *\\n   * @param account The address to check\\n   *\\n   * @return True if the address is a known tradefloor, false otherwise\\n   */\\n  function isTradeFloor(address account) external view returns (bool);\\n\\n  /**\\n   * @dev Get the token ID of a given address\\n   *\\n   * A cross check is required because token ID 0 is valid.\\n   *\\n   * @param tokenAddress The address to convert to a token ID\\n   *\\n   * @return The token ID on success, or uint256(-1) if `tokenAddress` does not\\n   * belong to a token ID\\n   */\\n  function addressToTokenId(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Get the address for a given token ID\\n   *\\n   * @param tokenId The token ID to convert\\n   *\\n   * @return The address, or address(0) in case the token ID does not belong\\n   * to an NFT\\n   */\\n  function tokenIdToAddress(uint256 tokenId) external view returns (address);\\n\\n  /**\\n   * @dev Get the next mintable token ID for the specified card\\n   *\\n   * @param level The level of the card\\n   * @param cardId The ID of the card\\n   *\\n   * @return bool True if a free token ID was found, false otherwise\\n   * @return uint256 The first free token ID if one was found, or invalid otherwise\\n   */\\n  function getNextMintableTokenId(uint8 level, uint8 cardId)\\n    external\\n    view\\n    returns (bool, uint256);\\n\\n  /**\\n   * @dev Return the next mintable custom token ID\\n   */\\n  function getNextMintableCustomToken() external view returns (uint256);\\n\\n  /**\\n   * @dev Return the level and the mint timestamp of tokenId\\n   *\\n   * @param tokenId The tokenId to query\\n   *\\n   * @return mintTimestamp The timestamp token was minted\\n   * @return level The level token belongs to\\n   */\\n  function getTokenData(uint256 tokenId)\\n    external\\n    view\\n    returns (uint64 mintTimestamp, uint8 level);\\n\\n  /**\\n   * @dev Return all tokenIds owned by account\\n   */\\n  function getTokenIds(address account)\\n    external\\n    view\\n    returns (uint256[] memory);\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // State modifiers\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Set the base URI for either predefined cards or custom cards\\n   * which don't have it's own URI.\\n   *\\n   * The resulting uri is baseUri+[hex(tokenId)] + '.json'. where\\n   * tokenId will be reduces to upper 16 bit (>> 16) before building the hex string.\\n   *\\n   */\\n  function setBaseMetadataURI(string memory baseContractMetadata) external;\\n\\n  /**\\n   * @dev Set the contracts metadata URI\\n   *\\n   * @param contractMetadataURI The URI which point to the contract metadata file.\\n   */\\n  function setContractMetadataURI(string memory contractMetadataURI) external;\\n\\n  /**\\n   * @dev Set the URI for a custom card\\n   *\\n   * @param tokenId The token ID whose URI is being set.\\n   * @param customURI The URI which point to an unique metadata file.\\n   */\\n  function setCustomURI(uint256 tokenId, string memory customURI) external;\\n\\n  /**\\n   * @dev Each custom card has its own level. Level will be used when\\n   * calculating rewards and raiding power.\\n   *\\n   * @param tokenId The ID of the token whose level is being set\\n   * @param cardLevel The new level of the specified token\\n   */\\n  function setCustomCardLevel(uint256 tokenId, uint8 cardLevel) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/utils/AddressBook.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2020-2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\nlibrary AddressBook {\\n  bytes32 public constant DEPLOYER = 'DEPLOYER';\\n  bytes32 public constant TEAM_WALLET = 'TEAM_WALLET';\\n  bytes32 public constant MARKETING_WALLET = 'MARKETING_WALLET';\\n  bytes32 public constant UNISWAP_V2_ROUTER02 = 'UNISWAP_V2_ROUTER02';\\n  bytes32 public constant WETH_WOWS_STAKE_FARM = 'WETH_WOWS_STAKE_FARM';\\n  bytes32 public constant WOWS_TOKEN = 'WOWS_TOKEN';\\n  bytes32 public constant UNISWAP_V2_PAIR = 'UNISWAP_V2_PAIR';\\n  bytes32 public constant WOWS_BOOSTER = 'WOWS_BOOSTER';\\n  bytes32 public constant REWARD_HANDLER = 'REWARD_HANDLER';\\n  bytes32 public constant SFT_MINTER = 'SFT_MINTER';\\n  bytes32 public constant SFT_HOLDER = 'SFT_HOLDER';\\n  bytes32 public constant BOIS_REWARDS = 'BOIS_REWARDS';\\n  bytes32 public constant WOLVES_REWARDS = 'WOLVES_REWARDS';\\n  bytes32 public constant SFT_EVALUATOR_PROXY = 'SFT_EVALUATOR_PROXY';\\n  bytes32 public constant TRADE_FLOOR_PROXY = 'TRADE_FLOOR_PROXY';\\n  bytes32 public constant CURVE_Y_TOKEN = 'CURVE_Y_TOKEN';\\n  bytes32 public constant CURVE_Y_DEPOSIT = 'CURVE_Y_DEPOSIT';\\n}\\n\"\r\n    },\r\n    \"contracts/src/utils/TokenIds.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\nlibrary TokenIds {\\n  // 128 bit underlying hash\\n  uint256 public constant HASH_MASK = (1 << 128) - 1;\\n\\n  function isBaseCard(uint256 tokenId) internal pure returns (bool) {\\n    return (tokenId & HASH_MASK) < (1 << 64);\\n  }\\n\\n  function isStockCard(uint256 tokenId) internal pure returns (bool) {\\n    return (tokenId & HASH_MASK) < (1 << 32);\\n  }\\n\\n  function isCFolioCard(uint256 tokenId) internal pure returns (bool) {\\n    return\\n      (tokenId & HASH_MASK) >= (1 << 64) && (tokenId & HASH_MASK) < (1 << 128);\\n  }\\n\\n  function toSftTokenId(uint256 tokenId) internal pure returns (uint256) {\\n    return tokenId & HASH_MASK;\\n  }\\n\\n  function maskHash(uint256 tokenId) internal pure returns (uint256) {\\n    return tokenId & ~HASH_MASK;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/src/utils/interfaces/IAddressRegistry.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\ninterface IAddressRegistry {\\n  /**\\n   * @dev Set an abitrary key / address pair into the registry\\n   */\\n  function setRegistryEntry(bytes32 _key, address _location) external;\\n\\n  /**\\n   * @dev Get a registry enty with by key, returns 0 address if not existing\\n   */\\n  function getRegistryEntry(bytes32 _key) external view returns (address);\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IAddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"NewSCMinter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"thisContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"SCContractUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"SCRewardUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cfolioItem\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"current\",\"type\":\"bytes\"}],\"name\":\"appendHash\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"name\":\"burnBatch\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cfolioFarm\",\"outputs\":[{\"internalType\":\"contract ICFolioFarmOwnable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveYDeposit\",\"outputs\":[{\"internalType\":\"contract ICurveFiDepositY\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveYToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cfolioItem\",\"type\":\"address\"}],\"name\":\"getAmounts\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getRewardInfo\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"name\":\"onCFolioItemsTransferedFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMinter\",\"type\":\"address\"}],\"name\":\"setMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"setupCFolio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sftEvaluator\",\"outputs\":[{\"internalType\":\"contract ISFTEvaluator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sftMinter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"newRate\",\"type\":\"uint32\"}],\"name\":\"sftUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeFloor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract CFolioItemHandlerSC\",\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"upgradeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CFolioItemHandlerSC","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"000000000000000000000000945466656995c9309ff66e05b4c268558bec964e","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}