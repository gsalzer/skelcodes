{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-05-19\r\n*/\r\n\r\npragma solidity 0.5.6;\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction underflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ncontract ERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Claimable{\r\n\r\n    ERC20 private _token;\r\n    address private owner;\r\n    uint private oneMinute = 1 minutes;\r\n    uint private oneDay = 1 days;\r\n\r\n    struct usersDetails {\r\n        address User;\r\n        uint totalBalance;\r\n        uint checkWithdrawBalance;\r\n        uint orginalBalanceAfterCliff;\r\n        uint balance;\r\n        uint vestingStartTime;\r\n        uint percentageShareTGE;\r\n        uint cliffTimePeriod;\r\n        uint interval;\r\n        uint vestingEndTime;\r\n        uint claimableBalance;\r\n        uint vestingPercentage;\r\n        uint withdrawalBalance;\r\n    }\r\n    \r\n    ERC20[] public tokenAddressArray;\r\n    constructor(ERC20 token) public{\r\n        owner = msg.sender;\r\n        _token = token;\r\n        tokenAddressArray.push(_token);\r\n        // e.totalSupply();\r\n    }\r\n    function checkBalance(address addr) public view returns(uint){\r\n       ERC20 e = ERC20(addr);\r\n       return e.totalSupply();\r\n    }\r\n    \r\n    mapping(address => mapping(address => usersDetails)) public userMapping;\r\n    address[] public userArray;\r\n    address[] public tokenArray;\r\n    \r\n    function balanceTGE(address _tokenAddress, address _userAddress)public view returns (uint){\r\n    if(now >= userMapping[_tokenAddress][_userAddress].vestingStartTime){\r\n        return userMapping[_tokenAddress][_userAddress].claimableBalance;\r\n        }\r\n    }\r\n    \r\n    function getArray() public view returns(ERC20[] memory){\r\n        return tokenAddressArray;\r\n    }\r\n    \r\n    function _addUserAndBalances(address[] memory _userArray, uint _percentageShareTGE,uint _startTgeTime, uint _cliffTimePeriod, uint _interval, uint _vestingEndTime, uint _claimableBalance, ERC20 token, address _tokenAddress,uint _vestingPercentage, uint[] memory _balc) public {\r\n        _token = token;\r\n        tokenAddressArray.push(_token);\r\n        for(uint i= 0;i < _userArray.length; i++) {\r\n            if( userMapping[_tokenAddress][_userArray[i]].User == _userArray[i]){\r\n            userMapping[_tokenAddress][_userArray[i]].balance +=  _balc[i];\r\n            userMapping[_tokenAddress][_userArray[i]].orginalBalanceAfterCliff +=  _balc[i];\r\n            tokenArray.push(_tokenAddress);\r\n            }\r\n            else{\r\n                userMapping[_tokenAddress][_userArray[i]] = (usersDetails(_userArray[i],_balc[i],_balc[i], _balc[i], _balc[i],_startTgeTime,_percentageShareTGE,_startTgeTime +_cliffTimePeriod * oneDay, _interval * oneDay, _startTgeTime+ _cliffTimePeriod* oneDay + _vestingEndTime * oneDay, _claimableBalance, _vestingPercentage, 0));\r\n                if(now >= userMapping[_tokenAddress][_userArray[i]].vestingStartTime){\r\n                    uint calcTokenValueAdd = userMapping[_tokenAddress][_userArray[i]].balance * userMapping[_tokenAddress][_userArray[i]].percentageShareTGE;\r\n                    calcTokenValueAdd = calcTokenValueAdd/100;\r\n                    userMapping[_tokenAddress][_userArray[i]].orginalBalanceAfterCliff = userMapping[_tokenAddress][_userArray[i]].balance- calcTokenValueAdd;\r\n                    userMapping[_tokenAddress][_userArray[i]].balance = userMapping[_tokenAddress][_userArray[i]].balance- calcTokenValueAdd;\r\n                    userMapping[_tokenAddress][_userArray[i]].claimableBalance = calcTokenValueAdd;\r\n                }else{\r\n                    uint calcTokenValueAdd = userMapping[_tokenAddress][_userArray[i]].balance * userMapping[_tokenAddress][_userArray[i]].percentageShareTGE;\r\n                    calcTokenValueAdd = calcTokenValueAdd/100;\r\n                    userMapping[_tokenAddress][_userArray[i]].orginalBalanceAfterCliff = userMapping[_tokenAddress][_userArray[i]].balance- calcTokenValueAdd;\r\n                    userMapping[_tokenAddress][_userArray[i]].balance = userMapping[_tokenAddress][_userArray[i]].balance- calcTokenValueAdd;\r\n                    userMapping[_tokenAddress][_userArray[i]].claimableBalance = calcTokenValueAdd;\r\n                }\r\n                tokenArray.push(_tokenAddress);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function transferTokens (address sender, address _tokenAddress, address token,  address recvr, uint amnt, uint _withdrawalAmount) public  returns(bool){\r\n        \r\n        require(_token.allowance(owner, address(this)) >= amnt, \"Insufficient Tokens in Smart contract\");\r\n        require(recvr == userMapping[_tokenAddress][recvr].User, \"User is not Found!\");\r\n        require(userMapping[_tokenAddress][recvr].checkWithdrawBalance>= amnt, \"User Balance is not Insufficient!\");\r\n\r\n        for(uint o = 1; o < tokenAddressArray.length; o++){\r\n            if(tokenAddressArray[o] == ERC20(token)){\r\n                _token.transferFrom(sender, recvr, _withdrawalAmount);\r\n                userMapping[_tokenAddress][recvr].balance = userMapping[_tokenAddress][recvr].balance - (amnt- userMapping[_tokenAddress][recvr].claimableBalance);\r\n                userMapping[_tokenAddress][recvr].claimableBalance= 0;\r\n                userMapping[_tokenAddress][recvr].withdrawalBalance +=  amnt;\r\n                userMapping[_tokenAddress][recvr].checkWithdrawBalance = userMapping[_tokenAddress][recvr].checkWithdrawBalance-amnt;\r\n                return true;        \r\n            }\r\n        }\r\n        \r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_userArray\",\"type\":\"address[]\"},{\"name\":\"_percentageShareTGE\",\"type\":\"uint256\"},{\"name\":\"_startTgeTime\",\"type\":\"uint256\"},{\"name\":\"_cliffTimePeriod\",\"type\":\"uint256\"},{\"name\":\"_interval\",\"type\":\"uint256\"},{\"name\":\"_vestingEndTime\",\"type\":\"uint256\"},{\"name\":\"_claimableBalance\",\"type\":\"uint256\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_vestingPercentage\",\"type\":\"uint256\"},{\"name\":\"_balc\",\"type\":\"uint256[]\"}],\"name\":\"_addUserAndBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userArray\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"checkBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenAddressArray\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"recvr\",\"type\":\"address\"},{\"name\":\"amnt\",\"type\":\"uint256\"},{\"name\":\"_withdrawalAmount\",\"type\":\"uint256\"}],\"name\":\"transferTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userMapping\",\"outputs\":[{\"name\":\"User\",\"type\":\"address\"},{\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"name\":\"checkWithdrawBalance\",\"type\":\"uint256\"},{\"name\":\"orginalBalanceAfterCliff\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"vestingStartTime\",\"type\":\"uint256\"},{\"name\":\"percentageShareTGE\",\"type\":\"uint256\"},{\"name\":\"cliffTimePeriod\",\"type\":\"uint256\"},{\"name\":\"interval\",\"type\":\"uint256\"},{\"name\":\"vestingEndTime\",\"type\":\"uint256\"},{\"name\":\"claimableBalance\",\"type\":\"uint256\"},{\"name\":\"vestingPercentage\",\"type\":\"uint256\"},{\"name\":\"withdrawalBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getArray\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"balanceTGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenArray\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Claimable","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000b9230c2bd40bf0cd12a97a5af34ac7a5e8b5d8","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://e1b1908fc6116ef3b319c90c3fcf9d3ce3033c86524cfc51c211d29db9aa214a"}]}