{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.12\r\n\r\ninterface AddressProvider:\r\n    def get_registry() -> address: view\r\n    def get_address(_id: uint256) -> address: view\r\n\r\ninterface Registry:\r\n    def find_pool_for_coins(_from: address, _to: address) -> address: view\r\n    def get_coin_indices(\r\n        _pool: address,\r\n        _from: address,\r\n        _to: address\r\n    ) -> (uint256, uint256, uint256): view\r\n\r\ninterface RegistrySwap:\r\n    def get_best_rate(_from: address, _to: address, _amount: uint256) -> (address, uint256): view\r\n\r\ninterface CurveCryptoSwap:\r\n    def get_dy(i: uint256, j: uint256, dx: uint256) -> uint256: view\r\n    def exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256, use_eth: bool): payable\r\n    def coins(i: uint256) -> address: view\r\n\r\ninterface CurvePool:\r\n    def exchange(i: int128, j: int128, dx: uint256, min_dy: uint256): payable\r\n    def exchange_underlying(i: int128, j: int128, dx: uint256, min_dy: uint256): payable\r\n\r\ninterface ERC20:\r\n    def approve(spender: address, amount: uint256): nonpayable\r\n    def transfer(to: address, amount: uint256): nonpayable\r\n    def transferFrom(sender: address, to: address, amount: uint256): nonpayable\r\n    def balanceOf(owner: address) -> uint256: view\r\n\r\n\r\nevent CommitOwnership:\r\n    admin: address\r\n\r\nevent ApplyOwnership:\r\n    admin: address\r\n\r\nevent TrustedForwardershipTransferred:\r\n    previous_forwarder: address\r\n    new_forwarder: address\r\n\r\n\r\nADDRESS_PROVIDER: constant(address) = 0x0000000022D53366457F9d5E68Ec105046FC4383\r\nETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\nWETH: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\n\r\nswap: public(address)\r\ncrypto_coins: public(address[3])\r\n\r\n# token -> spender -> is approved to transfer?\r\nis_approved: HashMap[address, HashMap[address, bool]]\r\n\r\nowner: public(address)\r\ntrusted_forwarder: public(address)\r\n\r\nfuture_owner: public(address)\r\n\r\n\r\n@external\r\ndef __init__(_swap: address):\r\n    self.owner = msg.sender\r\n    self.swap = _swap\r\n    for i in range(3):\r\n        coin: address = CurveCryptoSwap(_swap).coins(i)\r\n        if coin == WETH:\r\n            self.crypto_coins[i] = ETH\r\n        else:\r\n            ERC20(coin).approve(_swap, MAX_UINT256)\r\n            self.crypto_coins[i] = coin\r\n\r\n\r\n@payable\r\n@external\r\ndef __default__():\r\n    # required to receive Ether\r\n    pass\r\n\r\n\r\n@payable\r\n@external\r\ndef exchange(\r\n    _amount: uint256,\r\n    _route: address[6],\r\n    _indices: uint256[8],\r\n    _min_received: uint256,\r\n    _receiver: address = msg.sender\r\n):\r\n    \"\"\"\r\n    @notice Perform a cross-asset exchange.\r\n    @dev `_route` and `_indices` are generated by calling `get_exchange_routing`\r\n         prior to making a transaction. This reduces gas costs on swaps.\r\n    @param _amount Amount of the input token being swapped.\r\n    @param _route Array of token and pool addresses used within the swap.\r\n    @param _indices Array of `i` and `j` inputs used for individual swaps.\r\n    @param _min_received Minimum amount of the output token to be received. If\r\n                         the actual amount received is less the call will revert.\r\n    @param _receiver An alternate address to which the output of the exchange will be sent\r\n    \"\"\"\r\n    # Meta-tx support\r\n    msg_sender: address = msg.sender\r\n    receiver: address = _receiver\r\n    if msg_sender == self.trusted_forwarder:\r\n        calldata_len: uint256 = len(msg.data)\r\n        addr_bytes: Bytes[20] = empty(Bytes[20])\r\n        # grab the last 20 bytes of calldata which holds the address\r\n        if calldata_len == 536:\r\n            addr_bytes = slice(msg.data, 516, 20)\r\n        elif calldata_len == 568:\r\n            addr_bytes = slice(msg.data, 548, 20)\r\n        # convert to an address\r\n        msg_sender = convert(convert(addr_bytes, uint256), address)\r\n        if _receiver == msg.sender:\r\n            # we already know that msg.sender is the trusted forwarder\r\n            # if _receiver is set to msg.sender change it to be correct\r\n            receiver = msg_sender\r\n\r\n    eth_value: uint256 = 0\r\n    amount: uint256 = _amount\r\n\r\n    # perform the first stableswap, if required\r\n    if _route[1] != ZERO_ADDRESS:\r\n        ERC20(_route[0]).transferFrom(msg_sender, self, _amount)  # dev: insufficient amount\r\n\r\n        if not self.is_approved[_route[0]][_route[1]]:\r\n            ERC20(_route[0]).approve(_route[1], MAX_UINT256)  # dev: bad response\r\n            self.is_approved[_route[0]][_route[1]] = True\r\n\r\n        # `_indices[2]` is a boolean-as-integer indicating if the swap uses `exchange_underlying`\r\n        if _indices[2] == 0:\r\n            CurvePool(_route[1]).exchange(\r\n                convert(_indices[0], int128),\r\n                convert(_indices[1], int128),\r\n                _amount,\r\n                0,\r\n                value=msg.value,\r\n            )  # dev: bad response\r\n        else:\r\n            CurvePool(_route[1]).exchange_underlying(\r\n                convert(_indices[0], int128),\r\n                convert(_indices[1], int128),\r\n                _amount,\r\n                0,\r\n                value=msg.value,\r\n            )  # dev: bad response\r\n\r\n        if _route[2] == ETH:\r\n            amount = self.balance\r\n            eth_value = self.balance\r\n        else:\r\n            amount = ERC20(_route[2]).balanceOf(self)  # dev: bad response\r\n\r\n    # if no initial stableswap, transfer token and validate the amount of ether sent\r\n    elif _route[2] == ETH:\r\n        assert _amount == msg.value  # dev: insufficient amount\r\n        eth_value = msg.value\r\n    else:\r\n        assert msg.value == 0\r\n        ERC20(_route[2]).transferFrom(msg_sender, self, _amount)  # dev: insufficient amount\r\n\r\n    # perform the main crypto swap\r\n    use_eth: bool = ETH in [_route[2], _route[3]]\r\n    CurveCryptoSwap(self.swap).exchange(\r\n        _indices[3],\r\n        _indices[4],\r\n        amount,\r\n        0,\r\n        use_eth,\r\n        value=eth_value\r\n    )  # dev: bad response\r\n    if _route[3] == ETH:\r\n        amount = self.balance\r\n        eth_value = self.balance\r\n    else:\r\n        amount = ERC20(_route[3]).balanceOf(self)  # dev: bad response\r\n        eth_value = 0\r\n\r\n    # perform the second stableswap, if required\r\n    if _route[4] != ZERO_ADDRESS:\r\n        if _route[3] != ETH and not self.is_approved[_route[3]][_route[4]]:\r\n            ERC20(_route[3]).approve(_route[4], MAX_UINT256)  # dev: bad response\r\n            self.is_approved[_route[3]][_route[4]] = True\r\n\r\n        # `_indices[7]` is a boolean-as-integer indicating if the swap uses `exchange_underlying`\r\n        if _indices[7] == 0:\r\n            CurvePool(_route[4]).exchange(\r\n                convert(_indices[5], int128),\r\n                convert(_indices[6], int128),\r\n                amount,\r\n                _min_received,\r\n                value=eth_value,\r\n            )  # dev: bad response\r\n        else:\r\n            CurvePool(_route[4]).exchange_underlying(\r\n                convert(_indices[5], int128),\r\n                convert(_indices[6], int128),\r\n                amount,\r\n                _min_received,\r\n                value=eth_value,\r\n            )  # dev: bad response\r\n\r\n        if _route[5] == ETH:\r\n            raw_call(receiver, b\"\", value=self.balance)\r\n        else:\r\n            amount = ERC20(_route[5]).balanceOf(self)\r\n            ERC20(_route[5]).transfer(receiver, amount)\r\n\r\n    # if no final swap, check slippage and transfer to receiver\r\n    else:\r\n        assert amount >= _min_received\r\n        if _route[3] == ETH:\r\n            raw_call(receiver, b\"\", value=self.balance)\r\n        else:\r\n            ERC20(_route[3]).transfer(receiver, amount)\r\n\r\n\r\n@view\r\n@external\r\ndef get_exchange_routing(\r\n    _initial: address,\r\n    _target: address,\r\n    _amount: uint256\r\n) -> (address[6], uint256[8], uint256):\r\n    \"\"\"\r\n    @notice Get routing data for a cross-asset exchange.\r\n    @dev Outputs from this function are used as inputs when calling `exchange`.\r\n    @param _initial Address of the initial token being swapped.\r\n    @param _target Address of the token to be received in the swap.\r\n    @param _amount Amount of `_initial` to swap.\r\n    @return _route Array of token and pool addresses used within the swap,\r\n                    Array of `i` and `j` inputs used for individual swaps.\r\n                    Expected amount of the output token to be received.\r\n    \"\"\"\r\n\r\n    # route is [initial coin, stableswap, cryptopool input, cryptopool output, stableswap, target coin]\r\n    route: address[6] = empty(address[6])\r\n\r\n    # indices is [(i, j, is_underlying), (i, j), (i, j, is_underlying)]\r\n    # tuples indicate first stableswap, crypto swap, second stableswap\r\n    indices: uint256[8] = empty(uint256[8])\r\n\r\n    crypto_input: address = ZERO_ADDRESS\r\n    crypto_output: address = ZERO_ADDRESS\r\n    market: address = ZERO_ADDRESS\r\n\r\n    amount: uint256 = _amount\r\n    crypto_coins: address[3] = self.crypto_coins\r\n    swaps: address = AddressProvider(ADDRESS_PROVIDER).get_address(2)\r\n    registry: address = AddressProvider(ADDRESS_PROVIDER).get_registry()\r\n\r\n    # if initial coin is not in the crypto pool, get info for the first stableswap\r\n    if _initial in crypto_coins:\r\n        crypto_input = _initial\r\n    else:\r\n        received: uint256 = 0\r\n        for coin in crypto_coins:\r\n            market, received = RegistrySwap(swaps).get_best_rate(_initial, coin, amount)\r\n            if market != ZERO_ADDRESS:\r\n                indices[0], indices[1], indices[2] = Registry(registry).get_coin_indices(market, _initial, coin)\r\n                route[0] = _initial\r\n                route[1] = market\r\n                crypto_input = coin\r\n                amount = received\r\n                break\r\n        assert market != ZERO_ADDRESS\r\n\r\n    # determine target coin when swapping in the crypto pool\r\n    if _target in crypto_coins:\r\n        crypto_output = _target\r\n    else:\r\n        for coin in crypto_coins:\r\n            if Registry(registry).find_pool_for_coins(coin, _target) != ZERO_ADDRESS:\r\n                crypto_output = coin\r\n                break\r\n        assert crypto_output != ZERO_ADDRESS\r\n\r\n    assert crypto_input != crypto_output\r\n\r\n    # get i, j and dy for crypto swap\r\n    for x in range(3):\r\n        coin: address = self.crypto_coins[x]\r\n        if coin == crypto_input:\r\n            indices[3] = x\r\n        elif coin == crypto_output:\r\n            indices[4] = x\r\n    route[2] = crypto_input\r\n    route[3] = crypto_output\r\n    amount = CurveCryptoSwap(self.swap).get_dy(indices[3], indices[4], amount)\r\n\r\n    # if target coin is not in the crypto pool, get info for the final stableswap\r\n    if crypto_output != _target:\r\n        market, amount = RegistrySwap(swaps).get_best_rate(crypto_output, _target, amount)\r\n        indices[5], indices[6], indices[7] = Registry(registry).get_coin_indices(market, crypto_output, _target)\r\n        route[4] = market\r\n        route[5] = _target\r\n\r\n    return route, indices, amount\r\n\r\n\r\n@view\r\n@external\r\ndef can_route(_initial: address, _target: address) -> bool:\r\n    \"\"\"\r\n    @notice Check if a route is available between two tokens.\r\n    @param _initial Address of the initial token being swapped.\r\n    @param _target Address of the token to be received in the swap.\r\n    @return bool Is route available?\r\n    \"\"\"\r\n\r\n    crypto_coins: address[3] = self.crypto_coins\r\n    registry: address = AddressProvider(ADDRESS_PROVIDER).get_registry()\r\n\r\n    crypto_input: address = _initial\r\n    if _initial not in crypto_coins:\r\n        market: address = ZERO_ADDRESS\r\n        for coin in crypto_coins:\r\n            market = Registry(registry).find_pool_for_coins(_initial, coin)\r\n            if market != ZERO_ADDRESS:\r\n                crypto_input = coin\r\n                break\r\n        if market == ZERO_ADDRESS:\r\n            return False\r\n\r\n    crypto_output: address = _target\r\n    if _target not in crypto_coins:\r\n        market: address = ZERO_ADDRESS\r\n        for coin in crypto_coins:\r\n            market = Registry(registry).find_pool_for_coins(coin, _target)\r\n            if market != ZERO_ADDRESS:\r\n                crypto_output = coin\r\n                break\r\n        if market == ZERO_ADDRESS:\r\n            return False\r\n\r\n    return crypto_input != crypto_output\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(addr: address):\r\n    \"\"\"\r\n    @notice Transfer ownership of GaugeController to `addr`\r\n    @param addr Address to have ownership transferred to\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: admin only\r\n\r\n    self.future_owner = addr\r\n    log CommitOwnership(addr)\r\n\r\n\r\n@external\r\ndef accept_transfer_ownership():\r\n    \"\"\"\r\n    @notice Accept a pending ownership transfer\r\n    \"\"\"\r\n    _admin: address = self.future_owner\r\n    assert msg.sender == _admin  # dev: future admin only\r\n\r\n    self.owner = _admin\r\n    log ApplyOwnership(_admin)\r\n\r\n\r\n@view\r\n@external\r\ndef isTrustedForwarder(_forwarder: address) -> bool:\r\n    \"\"\"\r\n    @notice ERC-2771 meta-txs discovery mechanism\r\n    @param _forwarder Address to compare against the set trusted forwarder \r\n    @return bool True if `_forwarder` equals the set trusted forwarder\r\n    \"\"\"\r\n    return _forwarder == self.trusted_forwarder\r\n\r\n\r\n@external\r\ndef set_trusted_forwarder(_forwarder: address) -> bool:\r\n    \"\"\"\r\n    @notice Set the trusted forwarder address\r\n    @param _forwarder The address of the trusted forwarder\r\n    @return bool True on successful execution\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n\r\n    prev_forwarder: address = self.trusted_forwarder\r\n    self.trusted_forwarder = _forwarder\r\n\r\n    log TrustedForwardershipTransferred(prev_forwarder, _forwarder)\r\n    return True","ABI":"[{\"name\":\"CommitOwnership\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApplyOwnership\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TrustedForwardershipTransferred\",\"inputs\":[{\"name\":\"previous_forwarder\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_forwarder\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_swap\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_route\",\"type\":\"address[6]\"},{\"name\":\"_indices\",\"type\":\"uint256[8]\"},{\"name\":\"_min_received\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_route\",\"type\":\"address[6]\"},{\"name\":\"_indices\",\"type\":\"uint256[8]\"},{\"name\":\"_min_received\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_exchange_routing\",\"inputs\":[{\"name\":\"_initial\",\"type\":\"address\"},{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address[6]\"},{\"name\":\"\",\"type\":\"uint256[8]\"},{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":58134},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"can_route\",\"inputs\":[{\"name\":\"_initial\",\"type\":\"address\"},{\"name\":\"_target\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":26895},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[],\"gas\":39075},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_transfer_ownership\",\"inputs\":[],\"outputs\":[],\"gas\":39020},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"isTrustedForwarder\",\"inputs\":[{\"name\":\"_forwarder\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":2737},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_trusted_forwarder\",\"inputs\":[{\"name\":\"_forwarder\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":41913},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"swap\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2688},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"crypto_coins\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2827},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2748},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"trusted_forwarder\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2778},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2808}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.12","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"00000000000000000000000080466c64868e1ab14a1ddf27a676c3fcbe638fe5","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}