{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Basic {\r\n    uint public _totalSupply;\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address who) public constant returns (uint);\r\n    function transfer(address to, uint value) public;\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public constant returns (uint);\r\n    function transferFrom(address from, address to, uint value) public;\r\n    function approve(address spender, uint value) public;\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract BridgeToken {\r\n\r\n    address private watcher;\r\n      \r\n    event Deposit(address indexed sender, bytes32 indexed to1,bytes32 indexed to2, uint value);\r\n\r\n    function BridgeToken(address _watcher) public {\r\n        watcher = _watcher;\r\n    }\r\n    /**\r\n    *  Fix for the ERC20 short address attack.\r\n    */\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(!(msg.data.length < size + 4));\r\n        _;\r\n    }\r\n    function updateWatcher(address _watcher) public returns (bool){\r\n        require(msg.sender == watcher && _watcher != address(0));\r\n        watcher = _watcher;\r\n        return true;\r\n    }\r\n    /**\r\n     * withdraw by erc20\r\n     * _from : erc20 contract address\r\n     * _to: approve to  the address\r\n     * _value: the balance want to transfer \r\n     */ \r\n    function withdraw(address _from,address _to, uint _value) public {\r\n         require(msg.sender == watcher);\r\n         ERC20(_from).approve(_to,_value);\r\n    }\r\n     /**\r\n     * transfer to bridge by erc20 transferFrom\r\n     * _from : erc20 contract address\r\n     * _to: address string, which can get the balance from the contract\r\n     * _value: the balance want to transfer \r\n     */ \r\n    function deposit(address _from, string _to, uint _value) public onlyPayloadSize(3 * 32) {\r\n        address to = address(this);\r\n        ERC20(_from).transferFrom(msg.sender,to,_value);\r\n        var ( result1 , result2) = toBytes(_to);\r\n        Deposit(_from, result1,result2, _value);\r\n    }\r\n    \r\n    /**\r\n     * convert the address to bytes32 array \r\n     */\r\n    function toBytes(string  source) internal pure returns(bytes32 result1 ,bytes32 result2){\r\n       bytes memory value = bytes(source);\r\n        if (value.length == 0) {\r\n            return (0x0,0x0);\r\n        }else if(value.length <= 32){\r\n            assembly {\r\n            result1 := mload(add(source, 32))\r\n            result2 := 0x0\r\n        }\r\n        }else{\r\n            bytes memory remain = substr(value,32);\r\n            assembly {\r\n            result1 := mload(add(source, 32))\r\n            result2 := mload(add(remain, 32))\r\n        }\r\n        }\r\n         \r\n    }\r\n     /**\r\n     * sub  bytes  \r\n     */\r\n     function substr(bytes memory self, uint startIndex) internal pure returns (bytes memory) {\r\n        require(startIndex <= self.length);\r\n        uint len = self.length - startIndex;\r\n        uint addr = dataPtr(self);\r\n        return toBytes(addr + startIndex, len);\r\n    }\r\n     function dataPtr(bytes memory bts) internal pure returns (uint addr) {\r\n        assembly {\r\n            addr := add(bts, /*BYTES_HEADER_SIZE*/32)\r\n        }\r\n    }\r\n     function toBytes(uint addr, uint len) internal pure returns (bytes memory bts) {\r\n        bts = new bytes(len);\r\n        uint btsptr;\r\n        assembly {\r\n            btsptr := add(bts, /*BYTES_HEADER_SIZE*/32)\r\n        }\r\n        copy(addr, btsptr, len);\r\n    }\r\n     function copy(uint src, uint dest, uint len) internal pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_watcher\",\"type\":\"address\"}],\"name\":\"updateWatcher\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_watcher\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to1\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"to2\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"}]","ContractName":"BridgeToken","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000072ea70ec2be31fd4a58b8efe6d389999ae8dfc1","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://984616a9d6fa48cf10b5dc85eb8937db119ce2ebaf709fae21367f63683bff18"}]}