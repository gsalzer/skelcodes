{"status":"1","message":"OK","result":[{"SourceCode":"// This contract is a fixed version of the old NFT Sprites contract (0x325a468f3453ea52c5cf3d0fa0ba68d4cbc0f8a4) which had a bug. Do not interact with the old contract.\r\n// All the legitimate NFT Sprite owners from the old contract are given their NFT's in this new contract as well.\r\n\r\npragma solidity 0.8.0;\r\n\r\n/**\r\n * @dev ERC-721 interface for accepting safe transfers.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721TokenReceiver\r\n{\r\n\r\n  /**\r\n   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\r\n   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n   * of other than the magic value MUST result in the transaction being reverted.\r\n   * Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` unless throwing.\r\n   * @notice The contract address is always the message sender. A wallet/broker/auction application\r\n   * MUST implement the wallet interface if it will accept safe transfers.\r\n   * @param _operator The address which called `safeTransferFrom` function.\r\n   * @param _from The address which previously owned the token.\r\n   * @param _tokenId The NFT identifier which is being transferred.\r\n   * @param _data Additional data with no specified format.\r\n   * @return Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n   */\r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    returns(bytes4);\r\n\r\n}\r\n\r\n/**\r\n * @dev ERC-721 non-fungible token standard.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721\r\n{\r\n\r\n  /**\r\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\r\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\r\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\r\n   * transfer, the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\r\n   * address indicates there is no approved address. When a Transfer event emits, this also\r\n   * indicates that the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\r\n   * all NFTs of the owner.\r\n   */\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n   * function checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n   * `onERC721Received` on `_to` and throws if the return value is not\r\n   * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice This works identically to the other function with an extra data parameter, except this\r\n   * function just sets data to \"\"\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n   * address. Throws if `_tokenId` is not a valid NFT.\r\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n   * they mayb be permanently lost.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Set or reaffirm the approved address for an NFT.\r\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n   * the current NFT owner, or an authorized operator of the current owner.\r\n   * @param _approved The new approved NFT controller.\r\n   * @param _tokenId The NFT to approve.\r\n   */\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n   * @notice The contract MUST allow multiple operators per owner.\r\n   * @param _operator Address to add to the set of authorized operators.\r\n   * @param _approved True if the operators is approved, false to revoke approval.\r\n   */\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @param _owner Address for whom to query the balance.\r\n   * @return Balance of _owner.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\r\n   * invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   * @return Address of _tokenId owner.\r\n   */\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  /**\r\n   * @dev Get the approved address for a single NFT.\r\n   * @notice Throws if `_tokenId` is not a valid NFT.\r\n   * @param _tokenId The NFT to find the approved address for.\r\n   * @return Address that _tokenId is approved for.\r\n   */\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  /**\r\n   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\r\n   * @param _owner The address that owns the NFTs.\r\n   * @param _operator The address that acts on behalf of the owner.\r\n   * @return True if approved for all, false otherwise.\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\n\r\n/**\r\n * @dev Utility library of inline functions on addresses.\r\n * @notice Based on:\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n * Requires EIP-1052.\r\n */\r\nlibrary AddressUtils\r\n{\r\n\r\n  /**\r\n   * @dev Returns whether the target address is a contract.\r\n   * @param _addr Address to check.\r\n   * @return addressCheck True if _addr is a contract, false if not.\r\n   */\r\n  function isContract(\r\n    address _addr\r\n  )\r\n    internal\r\n    view\r\n    returns (bool addressCheck)\r\n  {\r\n    // This method relies in extcodesize, which returns 0 for contracts in\r\n    // construction, since the code is only stored at the end of the\r\n    // constructor execution.\r\n\r\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n    // for accounts without code, i.e. `keccak256('')`\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    assembly { codehash := extcodehash(_addr) } // solhint-disable-line\r\n    addressCheck = (codehash != 0x0 && codehash != accountHash);\r\n  }\r\n\r\n}\r\n\r\n\r\ninterface ERC165\r\n{\r\n\r\n  /**\r\n   * @dev Checks if the smart contract includes a specific interface.\r\n   * This function uses less than 30,000 gas.\r\n   * @param _interfaceID The interface identifier, as specified in ERC-165.\r\n   * @return True if _interfaceID is supported, false otherwise.\r\n   */\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n    \r\n}\r\n\r\n/**\r\n * @dev Implementation of standard for detect smart contract interfaces.\r\n */\r\ncontract SupportsInterface is\r\n  ERC165\r\n{\r\n\r\n  /**\r\n   * @dev Mapping of supported intefraces. You must not set element 0xffffffff to true.\r\n   */\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n  {\r\n    supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check which interfaces are suported by this contract.\r\n   * @param _interfaceID Id of the interface.\r\n   * @return True if _interfaceID is supported, false otherwise.\r\n   */\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceID];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\ncontract NFTSprites is\r\n  ERC721,\r\n  SupportsInterface\r\n{\r\n  using AddressUtils for address;\r\n\r\n  /**\r\n   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\r\n   * Based on 0xcert framework error codes.\r\n   */\r\n  string constant ZERO_ADDRESS = \"003001\";\r\n  string constant NOT_VALID_NFT = \"003002\";\r\n  string constant NOT_OWNER_OR_OPERATOR = \"003003\";\r\n  string constant NOT_OWNER_APPROVED_OR_OPERATOR = \"003004\";\r\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\r\n  string constant NFT_ALREADY_EXISTS = \"003006\";\r\n  string constant NOT_OWNER = \"003007\";\r\n  string constant IS_OWNER = \"003008\";\r\n  \r\n  string internal nftName = \"NFT Sprites\";\r\n  string internal nftSymbol = \"NFTS\";\r\n  \r\n  uint public latestNewSpriteForSale;\r\n  \r\n  address owner;\r\n    \r\n  struct Sprite {\r\n    address owner;\r\n    bool currentlyForSale;\r\n    uint price;\r\n    uint timesSold;\r\n  }\r\n  \r\n  mapping (uint => Sprite) public sprites;\r\n  \r\n  function getSpriteInfo (uint spriteNumber) public view returns (address, bool, uint, uint) {\r\n    return (sprites[spriteNumber].owner, sprites[spriteNumber].currentlyForSale, sprites[spriteNumber].price, sprites[spriteNumber].timesSold);\r\n  }\r\n  \r\n  // ownerOf does this as well\r\n  function getSpriteOwner (uint spriteNumber) public view returns (address) {\r\n    return (sprites[spriteNumber].owner);\r\n  }\r\n  \r\n  mapping (address => uint[]) public spriteOwners;\r\n  function spriteOwningHistory (address _address) public view returns (uint[] memory owningHistory) {\r\n    owningHistory = spriteOwners[_address];\r\n  }\r\n  \r\n  function name() external view returns (string memory _name) {\r\n    _name = nftName;\r\n  }\r\n  \r\n  function symbol() external view returns (string memory _symbol) {\r\n    _symbol = nftSymbol;\r\n  }\r\n\r\n  /**\r\n   * @dev Magic value of a smart contract that can recieve NFT.\r\n   * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\r\n   */\r\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  /**\r\n   * @dev A mapping from NFT ID to the address that owns it.\r\n   */\r\n  mapping (uint256 => address) internal idToOwner;\r\n\r\n  /**\r\n   * @dev Mapping from NFT ID to approved address.\r\n   */\r\n  mapping (uint256 => address) internal idToApproval;\r\n\r\n   /**\r\n   * @dev Mapping from owner address to count of his tokens.\r\n   */\r\n  mapping (address => uint256) private ownerToNFTokenCount;\r\n\r\n  /**\r\n   * @dev Mapping from owner address to mapping of operator addresses.\r\n   */\r\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n\r\n  /**\r\n   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\r\n   * @param _tokenId ID of the NFT to validate.\r\n   */\r\n  modifier canOperate(uint256 _tokenId) {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_OR_OPERATOR\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Guarantees that the msg.sender is allowed to transfer NFT.\r\n   * @param _tokenId ID of the NFT to transfer.\r\n   */\r\n   \r\n   // idToApproval[_tokenId] = _approved;\r\n   \r\n  modifier canTransfer(uint256 _tokenId) {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender\r\n      || idToApproval[_tokenId] == msg.sender\r\n      || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_APPROVED_OR_OPERATOR\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Guarantees that _tokenId is a valid Token.\r\n   * @param _tokenId ID of the NFT to validate.\r\n   */\r\n  modifier validNFToken(uint256 _tokenId) {\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor() {\r\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n    \r\n    // Below all the legitimate NFT Sprite owners from the old contract are given their NFT's in this new contract (can only be called once, when this contract is deployed).\r\n    \r\n    // original buyers\r\n    ownerToNFTokenCount[0xDE6Ad599B2b669dA30525af0820D0a27ca5fdA6f] = 1;\r\n    ownerToNFTokenCount[0x7DF397FB4981f2708931c3163eFA81be41C13302] = 1;\r\n    ownerToNFTokenCount[0xC9f203B4692c04bA7155Ef71d8f5D42bfCfbC09B] = 1;\r\n    ownerToNFTokenCount[0x48e4dd3e356823070D9d1B7d162d072aE9EFE0Cb] = 1;\r\n    ownerToNFTokenCount[0xbf67e713ddEf50496c6F27C41Eaeecee3A9FA063] = 1;\r\n    ownerToNFTokenCount[0x1A200f926A078400961B47C8965E57e1573C293C] = 1;\r\n    ownerToNFTokenCount[0xd161F45C77cdBaa63bd59137d2773462924AfeDe] = 1;\r\n    ownerToNFTokenCount[0xd9c3415Bf8600f007A1b4199DF967C25A3E00EeA] = 3;\r\n    ownerToNFTokenCount[0x172d894dB40435D04A099e081eade6492D3E71a8] = 2;\r\n    ownerToNFTokenCount[0xE2008Ef79a7d0D75EdAE70263384D4aC5D1A9f9A] = 1;\r\n    ownerToNFTokenCount[0xB117a08963Db62c31070eEdff0e192176251a3Fb] = 1;\r\n    ownerToNFTokenCount[0x375D4DE9c37B3b93e4C0af0E58D54F7DFF06cC16] = 1;\r\n    ownerToNFTokenCount[0xe4446D52e2bdB3E31470643Ab1753a4c2aEee3eA] = 2;\r\n    ownerToNFTokenCount[0x4202C5Aa18c934B96Bc4aEDB3DA4593c44076618] = 1;\r\n    ownerToNFTokenCount[0x7B167965d0449D27476eF236a8B6A02d5ABd27C4] = 1;\r\n    ownerToNFTokenCount[0x40D80168B6663700B6AE55d71a8c2Cf61d0C1225] = 1;\r\n    \r\n    // addresses that received an NFT from an owner transferring it to them\r\n    ownerToNFTokenCount[0x070DcB7ba170091F84783b224489aA8B280c1A30] = 1;\r\n    ownerToNFTokenCount[0x6747B33F4293fB4fD1bEaa5D7935F85d5958b684] = 1;\r\n    ownerToNFTokenCount[0xcDb89f98012b5755B4874CBf6E8787b18996c69D] = 1;\r\n    \r\n    sprites[0].owner = 0xDE6Ad599B2b669dA30525af0820D0a27ca5fdA6f;\r\n    sprites[0].currentlyForSale = false;\r\n    sprites[0].price = (10**15)*5;\r\n    sprites[0].timesSold = 1;\r\n    idToOwner[0] = 0xDE6Ad599B2b669dA30525af0820D0a27ca5fdA6f;\r\n    spriteOwners[0xDE6Ad599B2b669dA30525af0820D0a27ca5fdA6f].push(0);\r\n    \r\n    sprites[1].owner = 0x7DF397FB4981f2708931c3163eFA81be41C13302;\r\n    sprites[1].currentlyForSale = false;\r\n    sprites[1].price = (10**15)*5;\r\n    sprites[1].timesSold = 1;\r\n    idToOwner[1] = 0x7DF397FB4981f2708931c3163eFA81be41C13302;\r\n    spriteOwners[0x7DF397FB4981f2708931c3163eFA81be41C13302].push(1);\r\n    \r\n    sprites[2].owner = 0xC9f203B4692c04bA7155Ef71d8f5D42bfCfbC09B;\r\n    sprites[2].currentlyForSale = false;\r\n    sprites[2].price = 2**2 * (10**15)*5;\r\n    sprites[2].timesSold = 1;\r\n    idToOwner[2] = 0xC9f203B4692c04bA7155Ef71d8f5D42bfCfbC09B;\r\n    spriteOwners[0xC9f203B4692c04bA7155Ef71d8f5D42bfCfbC09B].push(2);\r\n    \r\n    sprites[3].owner = 0xcDb89f98012b5755B4874CBf6E8787b18996c69D; // original owner was 0xC9f203B4692c04bA7155Ef71d8f5D42bfCfbC09B, who later transferred it to this new owner: https://etherscan.io/tx/0x48602caef82ae441cd0bc15010d9027c3317573ac80cea73f01d157c82000bd4\r\n    sprites[3].currentlyForSale = false;\r\n    sprites[3].price = 3**2 * (10**15)*5;\r\n    sprites[3].timesSold = 1;\r\n    idToOwner[3] = 0xcDb89f98012b5755B4874CBf6E8787b18996c69D;\r\n    spriteOwners[0xcDb89f98012b5755B4874CBf6E8787b18996c69D].push(3);\r\n    \r\n    sprites[4].owner = 0x48e4dd3e356823070D9d1B7d162d072aE9EFE0Cb;\r\n    sprites[4].currentlyForSale = false;\r\n    sprites[4].price = 4**2 * (10**15)*5;\r\n    sprites[4].timesSold = 1;\r\n    idToOwner[4] = 0x48e4dd3e356823070D9d1B7d162d072aE9EFE0Cb;\r\n    spriteOwners[0x48e4dd3e356823070D9d1B7d162d072aE9EFE0Cb].push(4);\r\n    \r\n    sprites[5].owner = 0xbf67e713ddEf50496c6F27C41Eaeecee3A9FA063;\r\n    sprites[5].currentlyForSale = false;\r\n    sprites[5].price = 5**2 * (10**15)*5;\r\n    sprites[5].timesSold = 1;\r\n    idToOwner[5] = 0xbf67e713ddEf50496c6F27C41Eaeecee3A9FA063;\r\n    spriteOwners[0xbf67e713ddEf50496c6F27C41Eaeecee3A9FA063].push(5);\r\n    \r\n    sprites[6].owner = 0x1A200f926A078400961B47C8965E57e1573C293C;\r\n    sprites[6].currentlyForSale = false;\r\n    sprites[6].price = 6**2 * (10**15)*5;\r\n    sprites[6].timesSold = 1;\r\n    idToOwner[6] = 0x1A200f926A078400961B47C8965E57e1573C293C;\r\n    spriteOwners[0x1A200f926A078400961B47C8965E57e1573C293C].push(6);\r\n    \r\n    sprites[7].owner = 0xd161F45C77cdBaa63bd59137d2773462924AfeDe;\r\n    sprites[7].currentlyForSale = false;\r\n    sprites[7].price = 7**2 * (10**15)*5;\r\n    sprites[7].timesSold = 1;\r\n    idToOwner[7] = 0xd161F45C77cdBaa63bd59137d2773462924AfeDe;\r\n    spriteOwners[0xd161F45C77cdBaa63bd59137d2773462924AfeDe].push(7);\r\n    \r\n    sprites[8].owner = 0xd9c3415Bf8600f007A1b4199DF967C25A3E00EeA;\r\n    sprites[8].currentlyForSale = false;\r\n    sprites[8].price = 8**2 * (10**15)*5;\r\n    sprites[8].timesSold = 1;\r\n    idToOwner[8] = 0xd9c3415Bf8600f007A1b4199DF967C25A3E00EeA;\r\n    spriteOwners[0xd9c3415Bf8600f007A1b4199DF967C25A3E00EeA].push(8);\r\n    \r\n    sprites[9].owner = 0xd9c3415Bf8600f007A1b4199DF967C25A3E00EeA;\r\n    sprites[9].currentlyForSale = false;\r\n    sprites[9].price = 9**2 * (10**15)*5;\r\n    sprites[9].timesSold = 1;\r\n    idToOwner[9] = 0xd9c3415Bf8600f007A1b4199DF967C25A3E00EeA;\r\n    spriteOwners[0xd9c3415Bf8600f007A1b4199DF967C25A3E00EeA].push(9);\r\n    \r\n    sprites[10].owner = 0xd9c3415Bf8600f007A1b4199DF967C25A3E00EeA;\r\n    sprites[10].currentlyForSale = false;\r\n    sprites[10].price = 10**2 * (10**15)*5;\r\n    sprites[10].timesSold = 1;\r\n    idToOwner[10] = 0xd9c3415Bf8600f007A1b4199DF967C25A3E00EeA;\r\n    spriteOwners[0xd9c3415Bf8600f007A1b4199DF967C25A3E00EeA].push(10);\r\n    \r\n    sprites[11].owner = 0x172d894dB40435D04A099e081eade6492D3E71a8;\r\n    sprites[11].currentlyForSale = false;\r\n    sprites[11].price = 11**2 * (10**15)*5;\r\n    sprites[11].timesSold = 1;\r\n    idToOwner[11] = 0x172d894dB40435D04A099e081eade6492D3E71a8;\r\n    spriteOwners[0x172d894dB40435D04A099e081eade6492D3E71a8].push(11);\r\n    \r\n    sprites[12].owner = 0xE2008Ef79a7d0D75EdAE70263384D4aC5D1A9f9A;\r\n    sprites[12].currentlyForSale = false;\r\n    sprites[12].price = 12**2 * (10**15)*5;\r\n    sprites[12].timesSold = 1;\r\n    idToOwner[12] = 0xE2008Ef79a7d0D75EdAE70263384D4aC5D1A9f9A;\r\n    spriteOwners[0xE2008Ef79a7d0D75EdAE70263384D4aC5D1A9f9A].push(12);\r\n    \r\n    sprites[13].owner = 0xB117a08963Db62c31070eEdff0e192176251a3Fb;\r\n    sprites[13].currentlyForSale = false;\r\n    sprites[13].price = 13**2 * (10**15)*5;\r\n    sprites[13].timesSold = 1;\r\n    idToOwner[13] = 0xB117a08963Db62c31070eEdff0e192176251a3Fb;\r\n    spriteOwners[0xB117a08963Db62c31070eEdff0e192176251a3Fb].push(13);\r\n    \r\n    sprites[14].owner = 0x375D4DE9c37B3b93e4C0af0E58D54F7DFF06cC16;\r\n    sprites[14].currentlyForSale = false;\r\n    sprites[14].price = 14**2 * (10**15)*5;\r\n    sprites[14].timesSold = 1;\r\n    idToOwner[14] = 0x375D4DE9c37B3b93e4C0af0E58D54F7DFF06cC16;\r\n    spriteOwners[0x375D4DE9c37B3b93e4C0af0E58D54F7DFF06cC16].push(14);\r\n    \r\n    sprites[15].owner = 0x070DcB7ba170091F84783b224489aA8B280c1A30; // original owner was 0xd9c3415Bf8600f007A1b4199DF967C25A3E00EeA, who later transferred it to this new owner: https://etherscan.io/tx/0xe2427b79bb545188468cba61a8ffc8a1f69ce1ce60f66a4ac18ac9f883336d22\r\n    sprites[15].currentlyForSale = false;\r\n    sprites[15].price = 15**2 * (10**15)*5;\r\n    sprites[15].timesSold = 1;\r\n    idToOwner[15] = 0x070DcB7ba170091F84783b224489aA8B280c1A30;\r\n    spriteOwners[0x070DcB7ba170091F84783b224489aA8B280c1A30].push(15);\r\n    \r\n    sprites[16].owner = 0x172d894dB40435D04A099e081eade6492D3E71a8;\r\n    sprites[16].currentlyForSale = false;\r\n    sprites[16].price = 16**2 * (10**15)*5;\r\n    sprites[16].timesSold = 1;\r\n    idToOwner[16] = 0x172d894dB40435D04A099e081eade6492D3E71a8;\r\n    spriteOwners[0x172d894dB40435D04A099e081eade6492D3E71a8].push(16);\r\n    \r\n    sprites[17].owner = 0xe4446D52e2bdB3E31470643Ab1753a4c2aEee3eA;\r\n    sprites[17].currentlyForSale = false;\r\n    sprites[17].price = 17**2 * (10**15)*5;\r\n    sprites[17].timesSold = 1;\r\n    idToOwner[17] = 0xe4446D52e2bdB3E31470643Ab1753a4c2aEee3eA;\r\n    spriteOwners[0xe4446D52e2bdB3E31470643Ab1753a4c2aEee3eA].push(17);\r\n    \r\n    sprites[18].owner = 0xe4446D52e2bdB3E31470643Ab1753a4c2aEee3eA;\r\n    sprites[18].currentlyForSale = false;\r\n    sprites[18].price = 18**2 * (10**15)*5;\r\n    sprites[18].timesSold = 1;\r\n    idToOwner[18] = 0xe4446D52e2bdB3E31470643Ab1753a4c2aEee3eA;\r\n    spriteOwners[0xe4446D52e2bdB3E31470643Ab1753a4c2aEee3eA].push(18);\r\n    \r\n    sprites[19].owner = 0x4202C5Aa18c934B96Bc4aEDB3DA4593c44076618;\r\n    sprites[19].currentlyForSale = false;\r\n    sprites[19].price = 19**2 * (10**15)*5;\r\n    sprites[19].timesSold = 1;\r\n    idToOwner[19] = 0x4202C5Aa18c934B96Bc4aEDB3DA4593c44076618;\r\n    spriteOwners[0x4202C5Aa18c934B96Bc4aEDB3DA4593c44076618].push(19);\r\n    \r\n    sprites[20].owner = 0x7B167965d0449D27476eF236a8B6A02d5ABd27C4;\r\n    sprites[20].currentlyForSale = false;\r\n    sprites[20].price = 20**2 * (10**15)*5;\r\n    sprites[20].timesSold = 1;\r\n    idToOwner[20] = 0x7B167965d0449D27476eF236a8B6A02d5ABd27C4;\r\n    spriteOwners[0x7B167965d0449D27476eF236a8B6A02d5ABd27C4].push(20);\r\n    \r\n    sprites[21].owner = 0x40D80168B6663700B6AE55d71a8c2Cf61d0C1225;\r\n    sprites[21].currentlyForSale = false;\r\n    sprites[21].price = 21**2 * (10**15)*5;\r\n    sprites[21].timesSold = 1;\r\n    idToOwner[21] = 0x40D80168B6663700B6AE55d71a8c2Cf61d0C1225;\r\n    spriteOwners[0x40D80168B6663700B6AE55d71a8c2Cf61d0C1225].push(21);\r\n    \r\n    sprites[22].owner = 0x6747B33F4293fB4fD1bEaa5D7935F85d5958b684; // original owner was 0x9e4a9b4334f3167bc7dd35f48f2238c73f532baf, who later transferred it to this new owner: https://etherscan.io/tx/0x85f5486c54ae8fd9b6bd73ed524835a0517f816d50f40273e74e1df706309db2\r\n    sprites[22].currentlyForSale = false;\r\n    sprites[22].price = 22**2 * (10**15)*5;\r\n    sprites[22].timesSold = 1;\r\n    idToOwner[22] = 0x6747B33F4293fB4fD1bEaa5D7935F85d5958b684;\r\n    spriteOwners[0x6747B33F4293fB4fD1bEaa5D7935F85d5958b684].push(22);\r\n    \r\n    latestNewSpriteForSale = 23;\r\n    \r\n    sprites[23].currentlyForSale = true;\r\n    sprites[23].price = 23**2 * (10**15)*5;\r\n    \r\n    owner = msg.sender;\r\n  }\r\n    \r\n  function buySprite (uint spriteNumber) public payable {\r\n    require(sprites[spriteNumber].currentlyForSale == true);\r\n    require(msg.value == sprites[spriteNumber].price);\r\n    require(spriteNumber < 100);\r\n    sprites[spriteNumber].timesSold++;\r\n    spriteOwners[msg.sender].push(spriteNumber);\r\n    sprites[spriteNumber].currentlyForSale = false;\r\n    if (spriteNumber != latestNewSpriteForSale) {\r\n        // buying sprite that is already owned from someone\r\n        // give existing sprite owner their money\r\n        address currentSpriteOwner = getSpriteOwner(spriteNumber);\r\n        payable(currentSpriteOwner).transfer(msg.value);\r\n        // have to approve msg.sender for NFT to be transferred\r\n        idToApproval[spriteNumber] = msg.sender;\r\n        // _safeTransferFrom calls _transfer which updates the sprite owner to msg.sender and clears approvals\r\n        _safeTransferFrom(currentSpriteOwner, msg.sender, spriteNumber, \"\");\r\n    } else {\r\n        // buying brand new latest sprite\r\n        sprites[spriteNumber].owner = msg.sender;\r\n        if (latestNewSpriteForSale != 99) {\r\n            latestNewSpriteForSale++;\r\n            sprites[latestNewSpriteForSale].price = latestNewSpriteForSale**2 * (10**15)*5;\r\n            sprites[latestNewSpriteForSale].currentlyForSale = true;\r\n        }\r\n        _mint(msg.sender, spriteNumber);\r\n    }\r\n  }\r\n  \r\n  function sellSprite (uint spriteNumber, uint price) public {\r\n    require(msg.sender == sprites[spriteNumber].owner);\r\n    require(price > 0);\r\n    sprites[spriteNumber].price = price;\r\n    sprites[spriteNumber].currentlyForSale = true;\r\n  }\r\n  \r\n  function dontSellSprite (uint spriteNumber) public {\r\n    require(msg.sender == sprites[spriteNumber].owner);\r\n    sprites[spriteNumber].currentlyForSale = false;\r\n  }\r\n  \r\n  function giftSprite (uint spriteNumber, address receiver) public {\r\n    require(msg.sender == sprites[spriteNumber].owner);\r\n    require(receiver != address(0), ZERO_ADDRESS);\r\n    spriteOwners[receiver].push(spriteNumber);\r\n    _safeTransferFrom(msg.sender, receiver, spriteNumber, \"\");\r\n  }\r\n  \r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external override {\r\n    _safeTransferFrom(_from, _to, _tokenId, _data);\r\n  }\r\n  \r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n   * be changed to payable.\r\n   * @notice This works identically to the other function with an extra data parameter, except this\r\n   * function just sets data to \"\"\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external override {\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\r\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n   * the current NFT owner, or an authorized operator of the current owner.\r\n   * @param _approved Address to be approved for the given NFT ID.\r\n   * @param _tokenId ID of the token to be approved.\r\n   */\r\n  function approve(address _approved, uint256 _tokenId) external override canOperate(_tokenId) validNFToken(_tokenId) {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(_approved != tokenOwner, IS_OWNER);\r\n\r\n    idToApproval[_tokenId] = _approved;\r\n    emit Approval(tokenOwner, _approved, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n   * @notice This works even if sender doesn't own any tokens at the time.\r\n   * @param _operator Address to add to the set of authorized operators.\r\n   * @param _approved True if the operators is approved, false to revoke approval.\r\n   */\r\n  function setApprovalForAll(address _operator, bool _approved) external override {\r\n    ownerToOperators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @param _owner Address for whom to query the balance.\r\n   * @return Balance of _owner.\r\n   */\r\n  function balanceOf(address _owner) external override view returns (uint256) {\r\n    require(_owner != address(0), ZERO_ADDRESS);\r\n    return _getOwnerNFTCount(_owner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\r\n   * invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   * @return _owner Address of _tokenId owner.\r\n   */\r\n  function ownerOf(uint256 _tokenId) external override view returns (address _owner) {\r\n    _owner = idToOwner[_tokenId];\r\n    require(_owner != address(0), NOT_VALID_NFT);\r\n  }\r\n\r\n  /**\r\n   * @dev Get the approved address for a single NFT.\r\n   * @notice Throws if `_tokenId` is not a valid NFT.\r\n   * @param _tokenId ID of the NFT to query the approval of.\r\n   * @return Address that _tokenId is approved for.\r\n   */\r\n  function getApproved(uint256 _tokenId) external override view validNFToken(_tokenId) returns (address) {\r\n    return idToApproval[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if `_operator` is an approved operator for `_owner`.\r\n   * @param _owner The address that owns the NFTs.\r\n   * @param _operator The address that acts on behalf of the owner.\r\n   * @return True if approved for all, false otherwise.\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator) external override view returns (bool) {\r\n    return ownerToOperators[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Actually preforms the transfer.\r\n   * @notice Does NO checks.\r\n   * @param _to Address of a new owner.\r\n   * @param _tokenId The NFT that is being transferred.\r\n   */\r\n  function _transfer(address _to, uint256 _tokenId) internal {\r\n    address from = idToOwner[_tokenId];\r\n    _clearApproval(_tokenId);\r\n\r\n    _removeNFToken(from, _tokenId);\r\n    _addNFToken(_to, _tokenId);\r\n    \r\n    sprites[_tokenId].owner = _to;\r\n\r\n    emit Transfer(from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Mints a new NFT.\r\n   * @notice This is an internal function which should be called from user-implemented external\r\n   * mint function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _to The address that will own the minted NFT.\r\n   * @param _tokenId of the NFT to be minted by the msg.sender.\r\n   */\r\n  function _mint(address _to, uint256 _tokenId) internal virtual {\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n    _addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Burns a NFT.\r\n   * @notice This is an internal function which should be called from user-implemented external burn\r\n   * function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\r\n   * NFT.\r\n   * @param _tokenId ID of the NFT to be burned.\r\n   */\r\n  function _burn(uint256 _tokenId) internal virtual validNFToken(_tokenId) {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    _clearApproval(_tokenId);\r\n    _removeNFToken(tokenOwner, _tokenId);\r\n    emit Transfer(tokenOwner, address(0), _tokenId);\r\n  }\r\n  \r\n  /**\r\n   * @dev Removes a NFT from owner.\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @param _from Address from wich we want to remove the NFT.\r\n   * @param _tokenId Which NFT we want to remove.\r\n   */\r\n  function _removeNFToken(address _from, uint256 _tokenId) internal virtual {\r\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\r\n    ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from]--;\r\n    delete idToOwner[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Assignes a new NFT to owner.\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @param _to Address to wich we want to add the NFT.\r\n   * @param _tokenId Which NFT we want to add.\r\n   */\r\n  function _addNFToken(address _to, uint256 _tokenId) internal virtual {\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n    idToOwner[_tokenId] = _to;\r\n    ownerToNFTokenCount[_to]++;\r\n  }\r\n\r\n  /**\r\n   *Â @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\r\n   * extension to remove double storage (gas optimization) of owner nft count.\r\n   * @param _owner Address for whom to query the count.\r\n   * @return Number of _owner NFTs.\r\n   */\r\n  function _getOwnerNFTCount(address _owner) internal virtual view returns (uint256) {\r\n    return ownerToNFTokenCount[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Actually perform the safeTransferFrom.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) private canTransfer(_tokenId) validNFToken(_tokenId) {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, NOT_OWNER);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    _transfer(_to, _tokenId);\r\n\r\n    // isContract is function from address-utils.sol\r\n    if (_to.isContract()) {\r\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Clears the current approval of a given NFT ID.\r\n   * @param _tokenId ID of the NFT to be transferred.\r\n   */\r\n  function _clearApproval(uint256 _tokenId) private {\r\n    if (idToApproval[_tokenId] != address(0)) {\r\n      delete idToApproval[_tokenId];\r\n    }\r\n  }\r\n  \r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  \r\n  function withdraw() public onlyOwner {\r\n    payable(owner).transfer(address(this).balance);\r\n  }\r\n  \r\n    /**\r\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n   * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\r\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n   * they maybe be permanently lost.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) external override canTransfer(_tokenId) validNFToken(_tokenId) {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, NOT_OWNER);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    _transfer(_to, _tokenId);\r\n  }\r\n  \r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"spriteNumber\",\"type\":\"uint256\"}],\"name\":\"buySprite\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"spriteNumber\",\"type\":\"uint256\"}],\"name\":\"dontSellSprite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"spriteNumber\",\"type\":\"uint256\"}],\"name\":\"getSpriteInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"spriteNumber\",\"type\":\"uint256\"}],\"name\":\"getSpriteOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"spriteNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"giftSprite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestNewSpriteForSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"spriteNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"sellSprite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"spriteOwners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"spriteOwningHistory\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"owningHistory\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sprites\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"currentlyForSale\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timesSold\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NFTSprites","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://39d37519de85d21740f3efc907119eee6e27161beb7877bfdbae02de8310b7de"}]}