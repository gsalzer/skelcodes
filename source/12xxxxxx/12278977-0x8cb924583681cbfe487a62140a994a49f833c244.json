{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.7.6;\r\n\r\ncontract Context {\r\n    /**\r\n     * @dev returns address executing the method\r\n     */\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev returns data passed into the method\r\n     */\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract ERC20 is Context {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    uint256 private _totalSupply = 0.404 ether;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    constructor (string memory tokenName, string memory tokenSymbol) {\r\n        _name = tokenName;\r\n        _symbol = tokenSymbol;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the decimals of the token.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total supply of the token.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token balance of specific address.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns approved balance to be spent by another address\r\n     * by using transferFrom method\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the token allowance to another spender\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows to transfer tokens on senders behalf\r\n     * based on allowance approved for the executer\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount));\r\n        _transfer(sender, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0x0));\r\n        require(recipient != address(0x0));\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0x0));\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n\r\n        emit Transfer(address(0x0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows to burn tokens if token sender\r\n     * wants to reduce totalSupply() of the token\r\n     */\r\n    function burn(uint256 amount) external {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0x0));\r\n\r\n        _balances[account] = _balances[account].sub(amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n\r\n        emit Transfer(account, address(0x0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0x0));\r\n        require(spender != address(0x0));\r\n\r\n        _allowances[owner][spender] = amount;\r\n\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n}\r\n\r\ncontract Events {\r\n    event StakeStart(\r\n        bytes16 indexed stakeID,\r\n        address indexed stakerAddress,\r\n        address indexed referralAddress,\r\n        uint256 stakedAmount,\r\n        uint256 stakesShares,\r\n        uint256 referralShares,\r\n        uint256 startDay,\r\n        uint256 lockDays,\r\n        uint256 daiEquivalent\r\n    );\r\n\r\n    event StakeEnd(\r\n        bytes16 indexed stakeID,\r\n        address indexed stakerAddress,\r\n        address indexed referralAddress,\r\n        uint256 stakedAmount,\r\n        uint256 stakesShares,\r\n        uint256 referralShares,\r\n        uint256 rewardAmount,\r\n        uint256 closeDay,\r\n        uint256 penaltyAmount\r\n    );\r\n\r\n    event InterestScraped(\r\n        bytes16 indexed stakeID,\r\n        address indexed stakerAddress,\r\n        uint256 scrapeAmount,\r\n        uint256 scrapeDay,\r\n        uint256 stakersPenalty,\r\n        uint256 referrerPenalty,\r\n        uint256 currentSwappDay\r\n    );\r\n\r\n    event ReferralCollected(\r\n        address indexed staker,\r\n        bytes16 indexed stakeID,\r\n        address indexed referrer,\r\n        bytes16 referrerID,\r\n        uint256 rewardAmount\r\n    );\r\n\r\n    event NewGlobals(\r\n        uint256 totalShares,\r\n        uint256 totalStaked,\r\n        uint256 shareRate,\r\n        uint256 referrerShares,\r\n        uint256 indexed currentSwappDay\r\n    );\r\n\r\n    event NewSharePrice(\r\n        uint256 newSharePrice,\r\n        uint256 oldSharePrice,\r\n        uint64 currentSwappDay\r\n    );\r\n\r\n    event LiquidityGuardStatus(\r\n        bool isActive\r\n    );\r\n}\r\n\r\nabstract contract Global is ERC20, Events {\r\n    using SafeMath for uint256;\r\n\r\n    struct Globals {\r\n        uint256 totalStaked;\r\n        uint256 totalShares;\r\n        uint256 sharePrice;\r\n        uint256 currentSwappDay;\r\n        uint256 referralShares;\r\n        uint256 liquidityShares;\r\n    }\r\n\r\n    Globals public globals;\r\n\r\n    constructor() {\r\n        globals.sharePrice = 100E15;\r\n    }\r\n\r\n    function _increaseGlobals(\r\n        uint256 _staked,\r\n        uint256 _shares,\r\n        uint256 _rshares\r\n    ) internal {\r\n        globals.totalStaked = globals.totalStaked.add(_staked);\r\n        globals.totalShares = globals.totalShares.add(_shares);\r\n\r\n        if (_rshares > 0) {\r\n            globals.referralShares = globals.referralShares.add(_rshares);\r\n        }\r\n\r\n        _logGlobals();\r\n    }\r\n\r\n    function _decreaseGlobals(\r\n        uint256 _staked,\r\n        uint256 _shares,\r\n        uint256 _rshares\r\n    ) internal {\r\n        globals.totalStaked = globals.totalStaked > _staked ? globals.totalStaked - _staked : 0;\r\n        globals.totalShares = globals.totalShares > _shares ? globals.totalShares - _shares : 0;\r\n\r\n        if (_rshares > 0) {\r\n            globals.referralShares = globals.referralShares > _rshares ? globals.referralShares - _rshares : 0;\r\n        }\r\n\r\n        _logGlobals();\r\n    }\r\n\r\n    function _logGlobals() private {\r\n        emit NewGlobals(\r\n            globals.totalShares,\r\n            globals.totalStaked,\r\n            globals.sharePrice,\r\n            globals.referralShares,\r\n            globals.currentSwappDay\r\n        );\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external returns (\r\n        address pair\r\n    );\r\n}\r\n\r\ninterface IUniswapRouterV2 {\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function token1() external view returns (address);\r\n}\r\n\r\ninterface ILiquidityGuard {\r\n    function getInflation(uint32 _amount) external view returns (uint256);\r\n}\r\n\r\ninterface TokenInterface {\r\n    function transferFrom(address _from, address _to, uint256 _value)  external returns (bool success);\r\n    function approve(address _spender, uint256 _value)  external returns (bool success);\r\n}\r\n\r\nabstract contract Declaration is Global {\r\n\r\n    uint256 constant _decimals = 18;\r\n    uint256 constant TESLAS_PER_SWAPP = 10 ** _decimals;\r\n\r\n    uint32 constant SECONDS_IN_DAY = 86400 seconds;\r\n    uint16 constant MIN_LOCK_DAYS = 1;\r\n    uint16 constant FORMULA_DAY = 65;\r\n    uint16 constant MAX_LOCK_DAYS = 15330;\r\n    uint16 constant MAX_BONUS_DAYS_A = 1825;\r\n    uint16 constant MAX_BONUS_DAYS_B = 13505;\r\n    uint16 constant MIN_REFERRAL_DAYS = 365;\r\n\r\n    uint32 constant MIN_STAKE_AMOUNT = 1000000; // TESLA\r\n    uint32 constant REFERRALS_RATE = 366816973; // 1.000% (direct value, can be used right away)\r\n\r\n    uint32 public INFLATION_RATE = 103000; // 3.000% (indirect -> checks throgh LiquidityGuard)\r\n\r\n    uint64 constant PRECISION_RATE = 1E18;\r\n\r\n    uint96 constant THRESHOLD_LIMIT = 10000E18; // $10,000 DAI\r\n\r\n    uint96 constant DAILY_BONUS_A = 13698630136986302; // 25%:1825 = 0.01369863013 per day;\r\n    uint96 constant DAILY_BONUS_B = 370233246945575;   // 5%:13505 = 0.00037023324 per day;\r\n\r\n    uint256 public LAUNCH_TIME;\r\n\r\n    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n    IUniswapRouterV2 public constant UNISWAP_ROUTER = IUniswapRouterV2(\r\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n    );\r\n\r\n    IUniswapV2Factory public constant UNISWAP_FACTORY = IUniswapV2Factory(\r\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\r\n    );\r\n\r\n    ILiquidityGuard public LIQUIDITY_GUARD = ILiquidityGuard(\r\n        0xECd13A6c13A97483deA1e31101e63718FcBd6b73\r\n    );\r\n\r\n    IUniswapV2Pair public UNISWAP_PAIR;\r\n    bool public isLiquidityGuardActive;\r\n\r\n    uint256 public latestDaiEquivalent;\r\n    address[] internal _path = [address(this), WETH, DAI];\r\n\r\n    constructor() {\r\n        LAUNCH_TIME = 1620518400; // 2021.05.09 GMT\r\n    }\r\n\r\n    function createPair() external {\r\n        UNISWAP_PAIR = IUniswapV2Pair(\r\n            UNISWAP_FACTORY.createPair(\r\n                WETH, address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    struct Stake {\r\n        uint256 stakesShares;\r\n        uint256 stakedAmount;\r\n        uint256 rewardAmount;\r\n        uint64 startDay;\r\n        uint64 lockDays;\r\n        uint64 finalDay;\r\n        uint64 closeDay;\r\n        uint256 scrapeDay;\r\n        uint256 daiEquivalent;\r\n        uint256 referrerShares;\r\n        address referrer;\r\n        bool isActive;\r\n    }\r\n\r\n    struct ReferrerLink {\r\n        address staker;\r\n        bytes16 stakeID;\r\n        uint256 rewardAmount;\r\n        uint256 processedDays;\r\n        bool isActive;\r\n    }\r\n\r\n    struct CriticalMass {\r\n        uint256 totalAmount;\r\n        uint256 activationDay;\r\n    }\r\n\r\n    mapping(address => uint256) public stakeCount;\r\n    mapping(address => uint256) public referralCount;\r\n\r\n    mapping(address => CriticalMass) public criticalMass;\r\n    mapping(address => mapping(bytes16 => uint256)) public scrapes;\r\n    mapping(address => mapping(bytes16 => Stake)) public stakes;\r\n    mapping(address => mapping(bytes16 => ReferrerLink)) public referrerLinks;\r\n\r\n    mapping(uint256 => uint256) public scheduledToEnd;\r\n    mapping(uint256 => uint256) public referralSharesToEnd;\r\n    mapping(uint256 => uint256) public totalPenalties;\r\n\r\n    mapping(address => uint256) public userStakedAmount;\r\n}\r\n\r\nabstract contract Helper is Declaration {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    function currentSwappDay() public view returns (uint64) {\r\n        return getNow() >= LAUNCH_TIME ? _currentSwappDay() : 0;\r\n    }\r\n\r\n    function _currentSwappDay() internal view returns (uint64) {\r\n        return swappDayFromStamp(getNow());\r\n    }\r\n\r\n    function nextSwappDay() public view returns (uint64) {\r\n        return _currentSwappDay() + 1;\r\n    }\r\n\r\n    function previousSwappDay() public view returns (uint64) {\r\n        return _currentSwappDay() - 1;\r\n    }\r\n\r\n    function swappDayFromStamp(uint256 _timestamp) public view returns (uint64) {\r\n        return uint64((_timestamp - LAUNCH_TIME) / SECONDS_IN_DAY);\r\n    }\r\n\r\n    function getNow() public view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function notContract(address _addr) internal view returns (bool) {\r\n        uint32 size;\r\n        assembly { size := extcodesize(_addr) }\r\n        return (size == 0);\r\n    }\r\n\r\n    function toBytes16(uint256 x) internal pure returns (bytes16 b) {\r\n       return bytes16(bytes32(x));\r\n    }\r\n\r\n    function generateID(address x, uint256 y, bytes1 z) public pure returns (bytes16 b) {\r\n        b = toBytes16(uint256(keccak256(abi.encodePacked(x, y, z))));\r\n    }\r\n\r\n    function generateStakeID(address _staker) internal view returns (bytes16 stakeID) {\r\n        return generateID(_staker, stakeCount[_staker], 0x01);\r\n    }\r\n\r\n    function generateReferralID(address _referrer) internal view returns (bytes16 referralID) {\r\n        return generateID(_referrer, referralCount[_referrer], 0x02);\r\n    }\r\n\r\n    function stakesPagination(\r\n        address _staker,\r\n        uint256 _offset,\r\n        uint256 _length\r\n    ) external view returns (bytes16[] memory _stakes) {\r\n        uint256 start = _offset > 0 &&\r\n            stakeCount[_staker] > _offset ?\r\n            stakeCount[_staker] - _offset : stakeCount[_staker];\r\n\r\n        uint256 finish = _length > 0 &&\r\n            start > _length ?\r\n            start - _length : 0;\r\n\r\n        uint256 i;\r\n\r\n        _stakes = new bytes16[](start - finish);\r\n\r\n        for (uint256 _stakeIndex = start; _stakeIndex > finish; _stakeIndex--) {\r\n            bytes16 _stakeID = generateID(_staker, _stakeIndex - 1, 0x01);\r\n            if (stakes[_staker][_stakeID].stakedAmount > 0) {\r\n                _stakes[i] = _stakeID; i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function referralsPagination(\r\n        address _referrer,\r\n        uint256 _offset,\r\n        uint256 _length\r\n    ) external view returns (bytes16[] memory _referrals) {\r\n        uint256 start = _offset > 0 &&\r\n            referralCount[_referrer] > _offset ?\r\n            referralCount[_referrer] - _offset : referralCount[_referrer];\r\n\r\n        uint256 finish = _length > 0 &&\r\n            start > _length ?\r\n            start - _length : 0;\r\n\r\n        uint256 i;\r\n\r\n        _referrals = new bytes16[](start - finish);\r\n\r\n        for (uint256 _rIndex = start; _rIndex > finish; _rIndex--) {\r\n            bytes16 _rID = generateID(_referrer, _rIndex - 1, 0x02);\r\n            if (_nonZeroAddress(referrerLinks[_referrer][_rID].staker)) {\r\n                _referrals[i] = _rID; i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function latestStakeID(address _staker) external view returns (bytes16) {\r\n        return stakeCount[_staker] == 0 ? bytes16(0) : generateID(_staker, stakeCount[_staker].sub(1), 0x01);\r\n    }\r\n\r\n    function latestReferralID(address _referrer) external view returns (bytes16) {\r\n        return referralCount[_referrer] == 0 ? bytes16(0) : generateID(_referrer, referralCount[_referrer].sub(1), 0x02);\r\n    }\r\n\r\n    function _increaseStakeCount(address _staker) internal {\r\n        stakeCount[_staker] = stakeCount[_staker] + 1;\r\n    }\r\n\r\n    function _increaseReferralCount(address _referrer) internal {\r\n        referralCount[_referrer] = referralCount[_referrer] + 1;\r\n    }\r\n\r\n    function _isMatureStake(Stake memory _stake) internal view returns (bool) {\r\n        return _stake.closeDay > 0\r\n            ? _stake.finalDay <= _stake.closeDay\r\n            : _stake.finalDay <= _currentSwappDay();\r\n    }\r\n\r\n    function _notCriticalMassReferrer(address _referrer) internal view returns (bool) {\r\n        return criticalMass[_referrer].activationDay == 0;\r\n    }\r\n\r\n    function _stakeNotStarted(Stake memory _stake) internal view returns (bool) {\r\n        return _stake.closeDay > 0\r\n            ? _stake.startDay > _stake.closeDay\r\n            : _stake.startDay > _currentSwappDay();\r\n    }\r\n\r\n    function _stakeEnded(Stake memory _stake) internal view returns (bool) {\r\n        return _stake.isActive == false || _isMatureStake(_stake);\r\n    }\r\n\r\n    function _daysLeft(Stake memory _stake) internal view returns (uint256) {\r\n        return _stake.isActive == false\r\n            ? _daysDiff(_stake.closeDay, _stake.finalDay)\r\n            : _daysDiff(_currentSwappDay(), _stake.finalDay);\r\n    }\r\n\r\n    function _daysDiff(uint256 _startDate, uint256 _endDate) internal pure returns (uint256) {\r\n        return _startDate > _endDate ? 0 : _endDate.sub(_startDate);\r\n    }\r\n\r\n    function _calculationDay(Stake memory _stake) internal view returns (uint256) {\r\n        return _stake.finalDay > globals.currentSwappDay ? globals.currentSwappDay : _stake.finalDay;\r\n    }\r\n\r\n    function _startingDay(Stake memory _stake) internal pure returns (uint256) {\r\n        return _stake.scrapeDay == 0 ? _stake.startDay : _stake.scrapeDay;\r\n    }\r\n\r\n    function _notFuture(uint256 _day) internal view returns (bool) {\r\n        return _day <= _currentSwappDay();\r\n    }\r\n\r\n    function _notPast(uint256 _day) internal view returns (bool) {\r\n        return _day >= _currentSwappDay();\r\n    }\r\n\r\n    function _nonZeroAddress(address _address) internal pure returns (bool) {\r\n        return _address != address(0x0);\r\n    }\r\n\r\n    function _getLockDays(Stake memory _stake) internal pure returns (uint256) {\r\n        return\r\n            _stake.lockDays > 1 ?\r\n            _stake.lockDays - 1 : 1;\r\n    }\r\n\r\n    function _preparePath(\r\n        address _tokenAddress,\r\n        address _swappAddress\r\n    ) internal pure returns (address[] memory _path) {\r\n        _path = new address[](3);\r\n        _path[0] = _tokenAddress;\r\n        _path[1] = WETH;\r\n        _path[2] = _swappAddress;\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\r\n        );\r\n\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n}\r\n\r\nabstract contract Snapshot is Helper {\r\n    using SafeMath for uint;\r\n\r\n    // regular shares\r\n    struct SnapShot {\r\n        uint256 totalShares;\r\n        uint256 inflationAmount;\r\n        uint256 scheduledToEnd;\r\n    }\r\n\r\n    // referral shares\r\n    struct rSnapShot {\r\n        uint256 totalShares;\r\n        uint256 inflationAmount;\r\n        uint256 scheduledToEnd;\r\n    }\r\n\r\n    mapping(uint256 => SnapShot) public snapshots;\r\n    mapping(uint256 => rSnapShot) public rsnapshots;\r\n    \r\n    modifier snapshotTrigger() {\r\n        _dailySnapshotPoint(_currentSwappDay());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice allows to activate/deactivate\r\n     * liquidity guard manually based on the\r\n     * liquidity in UNISWAP pair contract\r\n     */\r\n    function liquidityGuardTrigger() public {\r\n        (\r\n            uint112 reserveA,\r\n            uint112 reserveB,\r\n        ) = UNISWAP_PAIR.getReserves();\r\n\r\n        uint256 onUniswap = UNISWAP_PAIR.token1() == WETH\r\n            ? reserveA\r\n            : reserveB;\r\n\r\n        uint256 ratio = totalSupply() == 0\r\n            ? 0\r\n            : onUniswap\r\n                .mul(200)\r\n                .div(totalSupply());\r\n\r\n        if (ratio < 40 && isLiquidityGuardActive == false) enableLiquidityGuard();\r\n        if (ratio > 60 && isLiquidityGuardActive == true) disableLiquidityGuard();\r\n\r\n        emit LiquidityGuardStatus(isLiquidityGuardActive);\r\n    }\r\n\r\n    function enableLiquidityGuard() private {\r\n        isLiquidityGuardActive = true;\r\n    }\r\n\r\n    function disableLiquidityGuard() private {\r\n        isLiquidityGuardActive = false;\r\n    }\r\n\r\n    /**\r\n     * @notice allows volunteer to offload snapshots\r\n     * to save on gas during next start/end stake\r\n     */\r\n    function manualDailySnapshot() external {\r\n        _dailySnapshotPoint(_currentSwappDay());\r\n    }\r\n\r\n    /**\r\n     * @notice allows volunteer to offload snapshots\r\n     * to save on gas during next start/end stake\r\n     * in case manualDailySnapshot reach block limit\r\n     */\r\n    function manualDailySnapshotPoint(uint64 _updateDay) external {\r\n        require(_updateDay > 0 && _updateDay < _currentSwappDay());\r\n        require(_updateDay > globals.currentSwappDay);\r\n\r\n        _dailySnapshotPoint(_updateDay);\r\n    }\r\n\r\n    /**\r\n     * @notice internal function that offloads\r\n     * global values to daily snapshots\r\n     * updates globals.currentSwappDay\r\n     */\r\n    function _dailySnapshotPoint(uint64 _updateDay) private {\r\n        liquidityGuardTrigger();\r\n\r\n        uint256 scheduledToEndToday;\r\n        uint256 totalStakedToday = globals.totalStaked;\r\n\r\n        for (uint256 _day = globals.currentSwappDay; _day < _updateDay; _day++) {\r\n\r\n            // ------------------------------------\r\n            // prepare snapshot for regular shares\r\n            // reusing scheduledToEndToday variable\r\n\r\n            scheduledToEndToday = scheduledToEnd[_day] + snapshots[_day - 1].scheduledToEnd;\r\n\r\n            SnapShot memory snapshot = snapshots[_day];\r\n            snapshot.scheduledToEnd = scheduledToEndToday;\r\n\r\n            snapshot.totalShares =\r\n                globals.totalShares > scheduledToEndToday ?\r\n                globals.totalShares - scheduledToEndToday : 0;\r\n\r\n            snapshot.inflationAmount =  snapshot.totalShares\r\n                .mul(PRECISION_RATE)\r\n                .div(\r\n                    _inflationAmount(\r\n                        totalStakedToday,\r\n                        totalSupply(),\r\n                        totalPenalties[_day],\r\n                        LIQUIDITY_GUARD.getInflation(\r\n                            INFLATION_RATE\r\n                        )\r\n                    )\r\n                );\r\n\r\n            // store regular snapshot\r\n            snapshots[_day] = snapshot;\r\n\r\n            // ------------------------------------\r\n            // prepare snapshot for referrer shares\r\n            // reusing scheduledToEndToday variable\r\n\r\n            scheduledToEndToday = referralSharesToEnd[_day] + rsnapshots[_day - 1].scheduledToEnd;\r\n\r\n            rSnapShot memory rsnapshot = rsnapshots[_day];\r\n            rsnapshot.scheduledToEnd = scheduledToEndToday;\r\n\r\n            rsnapshot.totalShares =\r\n                globals.referralShares > scheduledToEndToday ?\r\n                globals.referralShares - scheduledToEndToday : 0;\r\n\r\n            rsnapshot.inflationAmount = rsnapshot.totalShares\r\n                .mul(PRECISION_RATE)\r\n                .div(\r\n                    _referralInflation(\r\n                        totalStakedToday,\r\n                        totalSupply()\r\n                    )\r\n                );\r\n\r\n            // store referral snapshot\r\n            rsnapshots[_day] = rsnapshot;\r\n\r\n            adjustLiquidityRates();\r\n            globals.currentSwappDay++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice moves inflation up and down by 0.006%\r\n     * from regular shares to liquidity shares\r\n     * if the liquidityGuard is active (visa-versa)\r\n     */\r\n    function adjustLiquidityRates() private {\r\n        if (isLiquidityGuardActive ==  true) {\r\n            INFLATION_RATE = INFLATION_RATE - 6;\r\n            return;\r\n        }\r\n        if (isLiquidityGuardActive == false) {\r\n            INFLATION_RATE = INFLATION_RATE + 6;\r\n            return;\r\n        }\r\n    }\r\n\r\n    function _inflationAmount(\r\n        uint256 _totalStaked,\r\n        uint256 _totalSupply,\r\n        uint256 _totalPenalties,\r\n        uint256 _INFLATION_RATE\r\n    ) private pure returns (uint256) {\r\n        return (_totalStaked + _totalSupply) * 10000 / _INFLATION_RATE + _totalPenalties;\r\n    }\r\n\r\n    function _referralInflation(\r\n        uint256 _totalStaked,\r\n        uint256 _totalSupply\r\n    ) private pure returns (uint256) {\r\n        return (_totalStaked + _totalSupply) * 10000 / REFERRALS_RATE;\r\n    }\r\n}\r\n\r\nabstract contract ReferralToken is Snapshot {\r\n    using SafeMath for uint256;\r\n\r\n    function _addReferrerSharesToEnd(uint256 _finalDay, uint256 _shares) internal {\r\n        referralSharesToEnd[_finalDay] =\r\n        referralSharesToEnd[_finalDay].add(_shares);\r\n    }\r\n\r\n    function _removeReferrerSharesToEnd(uint256 _finalDay, uint256 _shares) internal {\r\n        if (_notPast(_finalDay)) {\r\n            referralSharesToEnd[_finalDay] =\r\n            referralSharesToEnd[_finalDay] > _shares ?\r\n            referralSharesToEnd[_finalDay] - _shares : 0;\r\n        } else {\r\n            uint256 _day = previousSwappDay();\r\n            rsnapshots[_day].scheduledToEnd =\r\n            rsnapshots[_day].scheduledToEnd > _shares ?\r\n            rsnapshots[_day].scheduledToEnd - _shares : 0;\r\n        }\r\n    }\r\n\r\n    function _belowThresholdLevel(address _referrer) private view returns (bool) {\r\n        return criticalMass[_referrer].totalAmount < THRESHOLD_LIMIT;\r\n    }\r\n\r\n    function _addCriticalMass(address _referrer, uint256 _daiEquivalent) internal {\r\n        criticalMass[_referrer].totalAmount =\r\n        criticalMass[_referrer].totalAmount.add(_daiEquivalent);\r\n        criticalMass[_referrer].activationDay = _determineActivationDay(_referrer);\r\n    }\r\n\r\n    function _removeCriticalMass(\r\n        address _referrer,\r\n        uint256 _daiEquivalent,\r\n        uint256 _startDay\r\n    ) internal {\r\n        if (\r\n            _notFuture(_startDay) == false &&\r\n            _nonZeroAddress(_referrer)\r\n        ) {\r\n            criticalMass[_referrer].totalAmount =\r\n            criticalMass[_referrer].totalAmount > _daiEquivalent ?\r\n            criticalMass[_referrer].totalAmount - _daiEquivalent : 0;\r\n            criticalMass[_referrer].activationDay = _determineActivationDay(_referrer);\r\n        }\r\n    }\r\n\r\n    function _determineActivationDay(address _referrer) private view returns (uint256) {\r\n        return _belowThresholdLevel(_referrer) ? 0 : _activationDay(_referrer);\r\n    }\r\n\r\n    function _activationDay(address _referrer) private view returns (uint256) {\r\n        return\r\n            criticalMass[_referrer].activationDay > 0 ?\r\n            criticalMass[_referrer].activationDay : _currentSwappDay();\r\n    }\r\n\r\n    function _updateDaiEquivalent() internal returns (uint256) {\r\n        try UNISWAP_ROUTER.getAmountsOut(\r\n            TESLAS_PER_SWAPP, _path\r\n        ) returns (uint256[] memory results) {\r\n            latestDaiEquivalent = results[2];\r\n            return latestDaiEquivalent;\r\n        } catch Error(string memory) {\r\n            return latestDaiEquivalent;\r\n        } catch (bytes memory) {\r\n            return latestDaiEquivalent;\r\n        }\r\n    }\r\n\r\n    function referrerInterest(\r\n        bytes16 _referralID,\r\n        uint256 _scrapeDays\r\n    ) external snapshotTrigger {\r\n        _referrerInterest(\r\n            msg.sender,\r\n            _referralID,\r\n            _scrapeDays\r\n        );\r\n    }\r\n\r\n    function referrerInterestBulk(\r\n        bytes16[] memory _referralIDs,\r\n        uint256[] memory _scrapeDays\r\n    ) external snapshotTrigger {\r\n        for(uint256 i = 0; i < _referralIDs.length; i++) {\r\n            _referrerInterest(\r\n                msg.sender,\r\n                _referralIDs[i],\r\n                _scrapeDays[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function _referrerInterest(\r\n        address _referrer,\r\n        bytes16 _referralID,\r\n        uint256 _processDays\r\n    ) internal {\r\n        ReferrerLink memory link =\r\n        referrerLinks[_referrer][_referralID];\r\n\r\n        require(link.isActive == true);\r\n\r\n        address staker = link.staker;\r\n        bytes16 stakeID = link.stakeID;\r\n\r\n        Stake memory stake = stakes[staker][stakeID];\r\n\r\n        uint256 startDay = _determineStartDay(stake, link);\r\n        uint256 finalDay = _determineFinalDay(stake);\r\n\r\n        if (_stakeEnded(stake)) {\r\n            if (\r\n                _processDays > 0 &&\r\n                _processDays < _daysDiff(startDay, finalDay)\r\n                )\r\n            {\r\n                link.processedDays =\r\n                link.processedDays.add(_processDays);\r\n\r\n                finalDay =\r\n                startDay.add(_processDays);\r\n            } else {\r\n                link.isActive = false;\r\n            }\r\n        } else {\r\n            _processDays = _daysDiff(startDay, _currentSwappDay());\r\n\r\n            link.processedDays =\r\n            link.processedDays.add(_processDays);\r\n\r\n            finalDay =\r\n            startDay.add(_processDays);\r\n        }\r\n\r\n        uint256 referralInterest = _checkReferralInterest(\r\n            stake,\r\n            startDay,\r\n            finalDay\r\n        );\r\n\r\n        link.rewardAmount = link.rewardAmount.add(referralInterest);\r\n\r\n        referrerLinks[_referrer][_referralID] = link;\r\n\r\n        _mint(_referrer, referralInterest);\r\n\r\n        emit ReferralCollected(\r\n            staker,\r\n            stakeID,\r\n            _referrer,\r\n            _referralID,\r\n            referralInterest\r\n        );\r\n    }\r\n\r\n    function checkReferralsByID(\r\n        address _referrer,\r\n        bytes16 _referralID\r\n    ) external view returns (\r\n        address staker,\r\n        bytes16 stakeID,\r\n        uint256 referrerShares,\r\n        uint256 referralInterest,\r\n        bool isActiveReferral,\r\n        bool isActiveStake,\r\n        bool isMatureStake,\r\n        bool isEndedStake\r\n    ) {\r\n        ReferrerLink memory link = referrerLinks[_referrer][_referralID];\r\n\r\n        staker = link.staker;\r\n        stakeID = link.stakeID;\r\n        isActiveReferral = link.isActive;\r\n\r\n        Stake memory stake = stakes[staker][stakeID];\r\n        referrerShares = stake.referrerShares;\r\n\r\n        referralInterest = _checkReferralInterest(\r\n            stake,\r\n            _determineStartDay(stake, link),\r\n            _determineFinalDay(stake)\r\n        );\r\n\r\n        isActiveStake = stake.isActive;\r\n        isEndedStake = _stakeEnded(stake);\r\n        isMatureStake = _isMatureStake(stake);\r\n    }\r\n\r\n    function _checkReferralInterest(\r\n        Stake memory _stake,\r\n        uint256 _startDay,\r\n        uint256 _finalDay\r\n    ) internal view returns (uint256 _referralInterest) {\r\n        return _notCriticalMassReferrer(_stake.referrer) ? 0 : _getReferralInterest(_stake, _startDay, _finalDay);\r\n    }\r\n\r\n    function _getReferralInterest(\r\n        Stake memory _stake,\r\n        uint256 _startDay,\r\n        uint256 _finalDay\r\n    ) private view returns (uint256 _referralInterest) {\r\n        for (uint256 _day = _startDay; _day < _finalDay; _day++) {\r\n            _referralInterest += _stake.stakesShares * PRECISION_RATE / rsnapshots[_day].inflationAmount;\r\n        }\r\n    }\r\n\r\n    function _determineStartDay(\r\n        Stake memory _stake,\r\n        ReferrerLink memory _link\r\n    ) internal view returns (uint256) {\r\n        return (\r\n            criticalMass[_stake.referrer].activationDay > _stake.startDay ?\r\n            criticalMass[_stake.referrer].activationDay : _stake.startDay\r\n        ).add(_link.processedDays);\r\n    }\r\n\r\n    function _determineFinalDay(\r\n        Stake memory _stake\r\n    ) internal view returns (uint256) {\r\n        return\r\n            _stake.closeDay > 0 ?\r\n            _stake.closeDay : _calculationDay(_stake);\r\n    }\r\n}\r\n\r\nabstract contract StakingToken is ReferralToken {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @notice A method for a staker to create multiple stakes\r\n     * @param _stakedAmount amount of SWAPP staked.\r\n     * @param _lockDays amount of days it is locked for.\r\n     * @param _referrer address of the referrer\r\n     */\r\n    function createStakeBulk(\r\n        uint256[] memory _stakedAmount,\r\n        uint64[] memory _lockDays,\r\n        address[] memory _referrer\r\n    ) external {\r\n        for(uint256 i = 0; i < _stakedAmount.length; i++) {\r\n            createStake(_stakedAmount[i], _lockDays[i], _referrer[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice A method for a staker to create a stake\r\n     * @param _stakedAmount amount of SWAPP staked.\r\n     * @param _lockDays amount of days it is locked for.\r\n     * @param _referrer address of the referrer\r\n     */\r\n    function createStake(\r\n        uint256 _stakedAmount,\r\n        uint64 _lockDays,\r\n        address _referrer\r\n    )  public returns (bytes16, uint256, bytes16 referralID) {\r\n        require(msg.sender != _referrer && notContract(_referrer));\r\n        require(_lockDays >= MIN_LOCK_DAYS && _lockDays <= MAX_LOCK_DAYS);\r\n        require(_stakedAmount >= MIN_STAKE_AMOUNT);\r\n\r\n        (\r\n            Stake memory newStake,\r\n            bytes16 stakeID,\r\n            uint256 _startDay\r\n        ) = _createStake(msg.sender, _stakedAmount, _lockDays, _referrer);\r\n\r\n        if (newStake.referrerShares > 0) {\r\n\r\n            ReferrerLink memory referrerLink;\r\n\r\n            referrerLink.staker = msg.sender;\r\n            referrerLink.stakeID = stakeID;\r\n            referrerLink.isActive = true;\r\n\r\n            referralID = generateReferralID(_referrer);\r\n            referrerLinks[_referrer][referralID] = referrerLink;\r\n\r\n            _increaseReferralCount(_referrer);\r\n            _addReferrerSharesToEnd(newStake.finalDay, newStake.referrerShares);\r\n        }\r\n\r\n        stakes[msg.sender][stakeID] = newStake;\r\n\r\n        _increaseStakeCount(msg.sender);\r\n\r\n        _increaseGlobals(\r\n            newStake.stakedAmount,\r\n            newStake.stakesShares,\r\n            newStake.referrerShares\r\n        );\r\n\r\n        _addScheduledShares(newStake.finalDay, newStake.stakesShares);\r\n\r\n        emit StakeStart(\r\n            stakeID,\r\n            msg.sender,\r\n            _referrer,\r\n            newStake.stakedAmount,\r\n            newStake.stakesShares,\r\n            newStake.referrerShares,\r\n            newStake.startDay,\r\n            newStake.lockDays,\r\n            newStake.daiEquivalent\r\n        );\r\n\r\n        return (stakeID, _startDay, referralID);\r\n    }\r\n\r\n    function getStakingShare(\r\n        uint256 _stakedAmount,\r\n        uint64 _lockDays,\r\n        address _referrer\r\n    ) external view returns (uint256 stakingShare) {\r\n        return _stakesShares(\r\n            _stakedAmount,\r\n            _lockDays,\r\n            _referrer,\r\n            globals.sharePrice\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice A method for a staker to start a stake\r\n    * @param _staker ...\r\n    * @param _stakedAmount ...\r\n    * @param _lockDays ...\r\n    */\r\n    function _createStake(\r\n        address _staker,\r\n        uint256 _stakedAmount,\r\n        uint64 _lockDays,\r\n        address _referrer\r\n    ) private returns (Stake memory _newStake, bytes16 _stakeID, uint64 _startDay) {\r\n        _burn(_staker, _stakedAmount);\r\n\r\n        userStakedAmount[_staker] = userStakedAmount[_staker].add(_stakedAmount);\r\n\r\n        _startDay = nextSwappDay();\r\n        _stakeID = generateStakeID(_staker);\r\n\r\n        _newStake.lockDays = _lockDays;\r\n        _newStake.startDay = _startDay;\r\n        _newStake.finalDay = _startDay + _lockDays;\r\n        _newStake.isActive = true;\r\n\r\n        _newStake.stakedAmount = _stakedAmount;\r\n        _newStake.stakesShares = _stakesShares(\r\n            _stakedAmount,\r\n            _lockDays,\r\n            _referrer,\r\n            globals.sharePrice\r\n        );\r\n\r\n        _updateDaiEquivalent();\r\n\r\n        _newStake.daiEquivalent = latestDaiEquivalent\r\n            .mul(_newStake.stakedAmount)\r\n            .div(TESLAS_PER_SWAPP);\r\n\r\n        if (_nonZeroAddress(_referrer)) {\r\n            _newStake.referrer = _referrer;\r\n            _addCriticalMass(_newStake.referrer, _newStake.daiEquivalent);\r\n            _newStake.referrerShares = _referrerShares(\r\n                _stakedAmount,\r\n                _lockDays,\r\n                _referrer\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice A method for a staker to remove a stake\r\n    * belonging to his address by providing ID of a stake.\r\n    * @param _stakeID unique bytes sequence reference to the stake\r\n    */\r\n    function endStake(bytes16 _stakeID) snapshotTrigger external returns (uint256) {\r\n        (\r\n            Stake memory endedStake,\r\n            uint256 penaltyAmount\r\n        ) = _endStake(msg.sender, _stakeID);\r\n\r\n        _decreaseGlobals(\r\n            endedStake.stakedAmount,\r\n            endedStake.stakesShares,\r\n            endedStake.referrerShares\r\n        );\r\n\r\n        _removeScheduledShares(endedStake.finalDay, endedStake.stakesShares);\r\n        _removeReferrerSharesToEnd(endedStake.finalDay, endedStake.referrerShares);\r\n\r\n        _removeCriticalMass(\r\n            endedStake.referrer,\r\n            endedStake.daiEquivalent,\r\n            endedStake.startDay\r\n        );\r\n\r\n        _storePenalty(endedStake.closeDay, penaltyAmount);\r\n\r\n        _sharePriceUpdate(\r\n            endedStake.stakedAmount > penaltyAmount ?\r\n            endedStake.stakedAmount - penaltyAmount : 0,\r\n            endedStake.rewardAmount + scrapes[msg.sender][_stakeID],\r\n            endedStake.referrer,\r\n            endedStake.lockDays,\r\n            endedStake.stakesShares\r\n        );\r\n\r\n        emit StakeEnd(\r\n            _stakeID,\r\n            msg.sender,\r\n            endedStake.referrer,\r\n            endedStake.stakedAmount,\r\n            endedStake.stakesShares,\r\n            endedStake.referrerShares,\r\n            endedStake.rewardAmount,\r\n            endedStake.closeDay,\r\n            penaltyAmount\r\n        );\r\n\r\n        return endedStake.rewardAmount;\r\n    }\r\n\r\n    function _endStake(\r\n        address _staker,\r\n        bytes16 _stakeID\r\n    ) private returns (Stake storage _stake, uint256 _penalty) {\r\n        require(stakes[_staker][_stakeID].isActive);\r\n\r\n        _stake = stakes[_staker][_stakeID];\r\n        _stake.closeDay = _currentSwappDay();\r\n        _stake.rewardAmount = _calculateRewardAmount(_stake);\r\n        _penalty = _calculatePenaltyAmount(_stake);\r\n\r\n        _stake.isActive = false;\r\n\r\n        userStakedAmount[_staker] = userStakedAmount[_staker].sub(_stake.stakedAmount);\r\n\r\n        _mint(\r\n            _staker,\r\n            _stake.stakedAmount > _penalty ?\r\n            _stake.stakedAmount - _penalty : 0\r\n        );\r\n\r\n        _mint(_staker, _stake.rewardAmount);\r\n    }\r\n\r\n    /**\r\n    * @notice alloes to scrape interest from active stake\r\n    * @param _stakeID unique bytes sequence reference to the stake\r\n    * @param _scrapeDays amount of days to proccess, 0 = all\r\n    */\r\n    function scrapeInterest(\r\n        bytes16 _stakeID,\r\n        uint64 _scrapeDays\r\n    ) external snapshotTrigger returns (\r\n        uint256 scrapeDay,\r\n        uint256 scrapeAmount,\r\n        uint256 remainingDays,\r\n        uint256 stakersPenalty,\r\n        uint256 referrerPenalty\r\n    ) {\r\n        require(stakes[msg.sender][_stakeID].isActive);\r\n\r\n        Stake memory stake = stakes[msg.sender][_stakeID];\r\n\r\n        scrapeDay = _scrapeDays > 0\r\n            ? _startingDay(stake).add(_scrapeDays)\r\n            : _calculationDay(stake);\r\n\r\n        scrapeDay = scrapeDay > stake.finalDay\r\n            ? _calculationDay(stake)\r\n            : scrapeDay;\r\n\r\n        scrapeAmount = _loopRewardAmount(\r\n            stake.stakesShares,\r\n            _startingDay(stake),\r\n            scrapeDay\r\n        );\r\n\r\n        if (_isMatureStake(stake) == false) {\r\n\r\n            remainingDays = _daysLeft(stake);\r\n\r\n            stakersPenalty = _stakesShares(\r\n                scrapeAmount,\r\n                remainingDays,\r\n                msg.sender,\r\n                globals.sharePrice\r\n            );\r\n\r\n            stake.stakesShares = stake.stakesShares.sub(stakersPenalty);\r\n\r\n            _removeScheduledShares(stake.finalDay, stakersPenalty);\r\n\r\n            if (stake.referrerShares > 0) {\r\n                referrerPenalty = _stakesShares(\r\n                    scrapeAmount,\r\n                    remainingDays,\r\n                    address(0x0),\r\n                    globals.sharePrice\r\n                );\r\n\r\n                stake.referrerShares = stake.referrerShares.sub(referrerPenalty);\r\n                _removeReferrerSharesToEnd(stake.finalDay, referrerPenalty);\r\n            }\r\n\r\n            _decreaseGlobals(0, stakersPenalty, referrerPenalty);\r\n\r\n            _sharePriceUpdate(\r\n                stake.stakedAmount,\r\n                scrapeAmount,\r\n                stake.referrer,\r\n                stake.lockDays,\r\n                stake.stakesShares\r\n            );\r\n        }\r\n        else {\r\n            scrapes[msg.sender][_stakeID] = scrapes[msg.sender][_stakeID].add(scrapeAmount);\r\n            _sharePriceUpdate(\r\n                stake.stakedAmount,\r\n                scrapes[msg.sender][_stakeID],\r\n                stake.referrer,\r\n                stake.lockDays,\r\n                stake.stakesShares\r\n            );\r\n        }\r\n\r\n        stake.scrapeDay = scrapeDay;\r\n        stakes[msg.sender][_stakeID] = stake;\r\n\r\n        _mint(msg.sender, scrapeAmount);\r\n\r\n        emit InterestScraped(\r\n            _stakeID,\r\n            msg.sender,\r\n            scrapeAmount,\r\n            scrapeDay,\r\n            stakersPenalty,\r\n            referrerPenalty,\r\n            _currentSwappDay()\r\n        );\r\n    }\r\n\r\n    function _addScheduledShares(uint256 _finalDay, uint256 _shares) internal {\r\n        scheduledToEnd[_finalDay] = scheduledToEnd[_finalDay].add(_shares);\r\n    }\r\n\r\n    function _removeScheduledShares(uint256 _finalDay, uint256 _shares) internal {\r\n        if (_notPast(_finalDay)) {\r\n            scheduledToEnd[_finalDay] =\r\n            scheduledToEnd[_finalDay] > _shares ?\r\n            scheduledToEnd[_finalDay] - _shares : 0;\r\n        } else {\r\n            uint256 _day = previousSwappDay();\r\n            snapshots[_day].scheduledToEnd =\r\n            snapshots[_day].scheduledToEnd > _shares ?\r\n            snapshots[_day].scheduledToEnd - _shares : 0;\r\n        }\r\n    }\r\n\r\n    function _sharePriceUpdate(\r\n        uint256 _stakedAmount,\r\n        uint256 _rewardAmount,\r\n        address _referrer,\r\n        uint256 _lockDays,\r\n        uint256 _stakeShares\r\n    ) private {\r\n        if (_stakeShares > 0 && _currentSwappDay() > FORMULA_DAY) {\r\n            uint256 newSharePrice = _getNewSharePrice(\r\n                _stakedAmount,\r\n                _rewardAmount,\r\n                _stakeShares,\r\n                _lockDays,\r\n                _referrer\r\n            );\r\n\r\n            if (newSharePrice > globals.sharePrice) {\r\n                newSharePrice = newSharePrice < globals.sharePrice.mul(110).div(100) ?\r\n                    newSharePrice : globals.sharePrice.mul(110).div(100);\r\n\r\n                emit NewSharePrice(\r\n                    newSharePrice,\r\n                    globals.sharePrice,\r\n                    _currentSwappDay()\r\n                );\r\n\r\n                globals.sharePrice = newSharePrice;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (_currentSwappDay() == FORMULA_DAY) {\r\n            globals.sharePrice = 110E15;\r\n        }\r\n    }\r\n\r\n    function _getNewSharePrice(\r\n        uint256 _stakedAmount,\r\n        uint256 _rewardAmount,\r\n        uint256 _stakeShares,\r\n        uint256 _lockDays,\r\n        address _referrer\r\n    ) private pure returns (uint256) {\r\n        uint256 _bonusAmount = _getBonus(\r\n            _lockDays, _nonZeroAddress(_referrer) ? 11E9 : 10E9\r\n        );\r\n\r\n        return \r\n            _stakedAmount\r\n                .add(_rewardAmount)\r\n                .mul(_bonusAmount)\r\n                .mul(1E8)\r\n                .div(_stakeShares);\r\n    }\r\n\r\n    function checkMatureStake(\r\n        address _staker,\r\n        bytes16 _stakeID\r\n    ) external view returns (bool isMature) {\r\n        Stake memory stake = stakes[_staker][_stakeID];\r\n        isMature = _isMatureStake(stake);\r\n    }\r\n\r\n    function checkStakeByID(address _staker, bytes16 _stakeID) external view\r\n        returns (\r\n            uint256 startDay,\r\n            uint256 lockDays,\r\n            uint256 finalDay,\r\n            uint256 closeDay,\r\n            uint256 scrapeDay,\r\n            uint256 stakedAmount,\r\n            uint256 stakesShares,\r\n            uint256 rewardAmount,\r\n            uint256 penaltyAmount,\r\n            bool isActive,\r\n            bool isMature\r\n        )\r\n    {\r\n        Stake memory stake = stakes[_staker][_stakeID];\r\n        startDay = stake.startDay;\r\n        lockDays = stake.lockDays;\r\n        finalDay = stake.finalDay;\r\n        closeDay = stake.closeDay;\r\n        scrapeDay = stake.scrapeDay;\r\n        stakedAmount = stake.stakedAmount;\r\n        stakesShares = stake.stakesShares;\r\n        rewardAmount = _checkRewardAmount(stake);\r\n        penaltyAmount = _calculatePenaltyAmount(stake);\r\n        isActive = stake.isActive;\r\n        isMature = _isMatureStake(stake);\r\n    }\r\n\r\n    function _stakesShares(\r\n        uint256 _stakedAmount,\r\n        uint256 _lockDays,\r\n        address _referrer,\r\n        uint256 _sharePrice\r\n    ) private pure returns (uint256) {\r\n        return _nonZeroAddress(_referrer)\r\n            ? _sharesAmount(_stakedAmount, _lockDays, _sharePrice, 11E9)\r\n            : _sharesAmount(_stakedAmount, _lockDays, _sharePrice, 10E9);\r\n    }\r\n\r\n    function _sharesAmount(\r\n        uint256 _stakedAmount,\r\n        uint256 _lockDays,\r\n        uint256 _sharePrice,\r\n        uint256 _extraBonus\r\n    ) private pure returns (uint256) {\r\n        return _baseAmount(_stakedAmount, _sharePrice)\r\n            .mul(_getBonus(_lockDays, _extraBonus))\r\n            .div(10E9);\r\n    }\r\n\r\n    function _getBonus(\r\n        uint256 _lockDays,\r\n        uint256 _extraBonus\r\n    ) private pure returns (uint256) {\r\n        return\r\n            _regularBonus(_lockDays, DAILY_BONUS_A, MAX_BONUS_DAYS_A) +\r\n            _regularBonus(\r\n                _lockDays > MAX_BONUS_DAYS_A ?\r\n                _lockDays - MAX_BONUS_DAYS_A : 0, DAILY_BONUS_B, MAX_BONUS_DAYS_B\r\n            ) + _extraBonus;\r\n    }\r\n\r\n    function _regularBonus(\r\n        uint256 _lockDays,\r\n        uint256 _daily,\r\n        uint256 _maxDays\r\n    ) private pure returns (uint256) {\r\n        return (\r\n            _lockDays > _maxDays\r\n                ? _maxDays.mul(_daily)\r\n                : _lockDays.mul(_daily)\r\n            ).div(10E9);\r\n    }\r\n\r\n    function _baseAmount(\r\n        uint256 _stakedAmount,\r\n        uint256 _sharePrice\r\n    ) private pure returns (uint256) {\r\n        return _stakedAmount.mul(PRECISION_RATE).div(_sharePrice);\r\n    }\r\n\r\n    function _referrerShares(\r\n        uint256 _stakedAmount,\r\n        uint256 _lockDays,\r\n        address _referrer\r\n    ) private view returns (uint256) {\r\n        return\r\n            _notCriticalMassReferrer(_referrer) ||\r\n            _lockDays < MIN_REFERRAL_DAYS\r\n                ? 0\r\n                : _sharesAmount(\r\n                    _stakedAmount,\r\n                    _lockDays,\r\n                    globals.sharePrice,\r\n                    10E9\r\n                );\r\n    }\r\n\r\n    function _checkRewardAmount(Stake memory _stake) private view returns (uint256) {\r\n        return _stake.isActive ? _detectReward(_stake) : _stake.rewardAmount;\r\n    }\r\n\r\n    function _detectReward(Stake memory _stake) private view returns (uint256) {\r\n        return _stakeNotStarted(_stake) ? 0 : _calculateRewardAmount(_stake);\r\n    }\r\n\r\n    function _storePenalty(uint64 _storeDay, uint256 _penalty) private {\r\n        if (_penalty > 0) {\r\n            totalPenalties[_storeDay] =\r\n            totalPenalties[_storeDay].add(_penalty);\r\n        }\r\n    }\r\n\r\n    function _calculatePenaltyAmount(Stake memory _stake) private view returns (uint256) {\r\n        return _stakeNotStarted(_stake) || _isMatureStake(_stake) ? 0 : _getPenalties(_stake);\r\n    }\r\n\r\n    function _getPenalties(Stake memory _stake) private view returns (uint256) {\r\n        return _stake.stakedAmount * (100 + (800 * (_daysLeft(_stake) - 1) / (_getLockDays(_stake)))) / 1000;\r\n    }\r\n\r\n    function _calculateRewardAmount(Stake memory _stake) private view returns (uint256) {\r\n        return _loopRewardAmount(\r\n            _stake.stakesShares,\r\n            _startingDay(_stake),\r\n            _calculationDay(_stake)\r\n        );\r\n    }\r\n\r\n    function _loopRewardAmount(\r\n        uint256 _stakeShares,\r\n        uint256 _startDay,\r\n        uint256 _finalDay\r\n    ) private view returns (uint256 _rewardAmount) {\r\n        for (uint256 _day = _startDay; _day < _finalDay; _day++) {\r\n            _rewardAmount += _stakeShares * PRECISION_RATE / snapshots[_day].inflationAmount;\r\n        }\r\n    }\r\n}\r\n\r\ncontract SwappToken is StakingToken {\r\n    address public LIQUIDITY_TRANSFORMER;\r\n    address public YIELD_FARM_STABLE;\r\n    address public YIELD_FARM_LP;\r\n    address public tokenMinterDefiner;\r\n\r\n    modifier onlyMinter() {\r\n        require(\r\n            msg.sender == LIQUIDITY_TRANSFORMER ||\r\n            msg.sender == YIELD_FARM_STABLE ||\r\n            msg.sender == YIELD_FARM_LP,\r\n            'SWAPP: Invalid token minter'\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor() ERC20(\"Swapp Token\", \"SWAPP\") {\r\n        tokenMinterDefiner = msg.sender;\r\n\r\n        _mint(0x0d970a04d46c73B6d20d9a0B2B07C35F2495ca9c, 162500000E18); // SWAPP FOUNDATION - Contract Owner Wallet\r\n        _mint(0x915D99375Ba8EDbbee46bE1AD045718a05A6655b, 3307862E18);   // MM-PRESALE Investors Wallet\r\n        _mint(0x7Db4456a73a9C94a381d244E9dfC76E83C05913E, 58364082E18);  // Employee Pool Including Founders MM Wallet\r\n        _mint(0x62F16a5bA06693B1E96a656d46e66A8CdaE17C69, 13328056E18);  // Swapp Previous Investors MM Wallet\r\n        _mint(0x94dc2f1823AbfdC2fb9BB8Ae10162b65D2Cf1c65, 250000000E18); // Rewards Wallet\r\n        _mint(0x2a8eA8a4842DA268FA4180b1a99B7876f820ECC1, 35000000E18);  // Future Development Wallet\r\n        _mint(0x000baFB91ED6436ad2888C2418197aFDB85785C5, 5000000E18);   // Reserved Funding Wallet\r\n        _mint(0xd4041e1c24A54134Fb9657e8DA85e75001D7Ea44, 5000000E18);   // Bounty, Advisors, Partnership Wallet\r\n    }\r\n\r\n    receive() external payable {\r\n        revert();\r\n    }\r\n\r\n    function setMinters(\r\n        address _transformer,\r\n        address _yieldFarmStable,\r\n        address _yieldFarmLP\r\n    ) external {\r\n        require(tokenMinterDefiner == msg.sender);\r\n        LIQUIDITY_TRANSFORMER = _transformer;\r\n        YIELD_FARM_STABLE = _yieldFarmStable;\r\n        YIELD_FARM_LP = _yieldFarmLP;\r\n    }\r\n\r\n    function burnMinterDefiner() external {\r\n        require(tokenMinterDefiner == msg.sender);\r\n        tokenMinterDefiner = address(0x0);\r\n    }\r\n\r\n    /**\r\n     * @notice allows liquidityTransformer to mint supply\r\n     * @dev executed from liquidityTransformer upon UNISWAP transfer\r\n     * and during reservation payout to contributors and referrers\r\n     * @param _investorAddress address for minting SWAPP tokens\r\n     * @param _amount of tokens to mint for _investorAddress\r\n     */\r\n    function mintSupply(address _investorAddress, uint256 _amount) external onlyMinter {\r\n        _mint(_investorAddress, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice allows to grant permission to CM referrer status\r\n     * @dev called from liquidityTransformer if user referred 50 ETH\r\n     * @param _referrer - address that becomes a CM reffer\r\n     */\r\n    function giveStatus(address _referrer) external onlyMinter {\r\n        criticalMass[_referrer].totalAmount = THRESHOLD_LIMIT;\r\n        criticalMass[_referrer].activationDay = nextSwappDay();\r\n    }\r\n\r\n    /**\r\n     * @notice allows to create stake directly with ETH\r\n     * if you don't have SWAPP tokens method will convert\r\n     * and use amount returned from UNISWAP to open a stake\r\n     * @param _lockDays amount of days it is locked for.\r\n     * @param _referrer referrer address for +10% bonus\r\n     */\r\n    function createStakeWithETH(\r\n        uint64 _lockDays,\r\n        address _referrer\r\n    ) external payable returns (bytes16, uint256, bytes16 referralID) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = WETH;\r\n        path[1] = address(this);\r\n\r\n        uint256[] memory amounts = UNISWAP_ROUTER.swapExactETHForTokens{value: msg.value}(\r\n            1,\r\n            path,\r\n            msg.sender,\r\n            block.timestamp\r\n        );\r\n\r\n        return createStake(amounts[1], _lockDays, _referrer);\r\n    }\r\n\r\n    /**\r\n     * @notice allows to create stake with another token\r\n     * if you don't have SWAPP tokens method will convert\r\n     * and use amount returned from UNISWAP to open a stake\r\n     * @dev the token must have WETH pair on UNISWAP\r\n     * @param _tokenAddress any ERC20 token address\r\n     * @param _tokenAmount amount to be converted to SWAPP\r\n     * @param _lockDays amount of days it is locked for.\r\n     * @param _referrer referrer address for +10% bonus\r\n     */\r\n    function createStakeWithToken(\r\n        address _tokenAddress,\r\n        uint256 _tokenAmount,\r\n        uint64 _lockDays,\r\n        address _referrer\r\n    ) external returns (bytes16, uint256, bytes16 referralID) {\r\n        TokenInterface token = TokenInterface(_tokenAddress);\r\n\r\n        token.transferFrom(msg.sender, address(this), _tokenAmount);\r\n        token.approve(address(UNISWAP_ROUTER), _tokenAmount);\r\n\r\n        address[] memory path = _preparePath(_tokenAddress, address(this));\r\n\r\n        uint256[] memory amounts = UNISWAP_ROUTER.swapExactTokensForTokens(\r\n            _tokenAmount,\r\n            1,\r\n            path,\r\n            msg.sender,\r\n            block.timestamp\r\n        );\r\n\r\n        return createStake(amounts[2], _lockDays, _referrer);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scrapeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scrapeDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakersPenalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referrerPenalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentSwappDay\",\"type\":\"uint256\"}],\"name\":\"InterestScraped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"LiquidityGuardStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shareRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referrerShares\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"currentSwappDay\",\"type\":\"uint256\"}],\"name\":\"NewGlobals\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSharePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldSharePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"currentSwappDay\",\"type\":\"uint64\"}],\"name\":\"NewSharePrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"referrerID\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"ReferralCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referralAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"closeDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penaltyAmount\",\"type\":\"uint256\"}],\"name\":\"StakeEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referralAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockDays\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiEquivalent\",\"type\":\"uint256\"}],\"name\":\"StakeStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INFLATION_RATE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAUNCH_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY_GUARD\",\"outputs\":[{\"internalType\":\"contract ILiquidityGuard\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY_TRANSFORMER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_FACTORY\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_PAIR\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_ROUTER\",\"outputs\":[{\"internalType\":\"contract IUniswapRouterV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"YIELD_FARM_LP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"YIELD_FARM_STABLE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnMinterDefiner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"checkMatureStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isMature\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_referralID\",\"type\":\"bytes16\"}],\"name\":\"checkReferralsByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"referrerShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralInterest\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActiveReferral\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isActiveStake\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isMatureStake\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isEndedStake\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"checkStakeByID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scrapeDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penaltyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isMature\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_lockDays\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"createStake\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"referralID\",\"type\":\"bytes16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_stakedAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint64[]\",\"name\":\"_lockDays\",\"type\":\"uint64[]\"},{\"internalType\":\"address[]\",\"name\":\"_referrer\",\"type\":\"address[]\"}],\"name\":\"createStakeBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_lockDays\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"createStakeWithETH\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"referralID\",\"type\":\"bytes16\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_lockDays\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"createStakeWithToken\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"referralID\",\"type\":\"bytes16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"criticalMass\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activationDay\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSwappDay\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"endStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"x\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"bytes1\",\"name\":\"z\",\"type\":\"bytes1\"}],\"name\":\"generateID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"b\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_lockDays\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"getStakingShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"giveStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentSwappDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityShares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLiquidityGuardActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestDaiEquivalent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"latestReferralID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"latestStakeID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityGuardTrigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualDailySnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_updateDay\",\"type\":\"uint64\"}],\"name\":\"manualDailySnapshotPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_investorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextSwappDay\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousSwappDay\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referralSharesToEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"referralsPagination\",\"outputs\":[{\"internalType\":\"bytes16[]\",\"name\":\"_referrals\",\"type\":\"bytes16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_referralID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"_scrapeDays\",\"type\":\"uint256\"}],\"name\":\"referrerInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16[]\",\"name\":\"_referralIDs\",\"type\":\"bytes16[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_scrapeDays\",\"type\":\"uint256[]\"}],\"name\":\"referrerInterestBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"referrerLinks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"processedDays\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rsnapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inflationAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scheduledToEnd\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"scheduledToEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"},{\"internalType\":\"uint64\",\"name\":\"_scrapeDays\",\"type\":\"uint64\"}],\"name\":\"scrapeInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"scrapeDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scrapeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakersPenalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerPenalty\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"scrapes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transformer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yieldFarmStable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yieldFarmLP\",\"type\":\"address\"}],\"name\":\"setMinters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"snapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inflationAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scheduledToEnd\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"startDay\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lockDays\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"finalDay\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"closeDay\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"scrapeDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daiEquivalent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerShares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"stakesPagination\",\"outputs\":[{\"internalType\":\"bytes16[]\",\"name\":\"_stakes\",\"type\":\"bytes16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"swappDayFromStamp\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenMinterDefiner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalPenalties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userStakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SwappToken","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5fc0fbf6b4e80d846430a2c2107e39abab2c58c4d585e46baae4b057c29057f7"}]}