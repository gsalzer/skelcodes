{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface CTokenInterface {\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint); // For ERC20\r\n    function liquidateBorrow(address borrower, uint repayAmount, address cTokenCollateral) external returns (uint);\r\n\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n}\r\n\r\ninterface CETHInterface {\r\n    function mint() external payable;\r\n    function repayBorrow() external payable;\r\n    function repayBorrowBehalf(address borrower) external payable;\r\n    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\r\n}\r\n\r\ninterface TokenInterface {\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface ComptrollerInterface {\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cTokenAddress) external returns (uint);\r\n    function getAssetsIn(address account) external view returns (address[] memory);\r\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\r\n    function claimComp(address) external;\r\n}\r\n\r\ninterface InstaMappingV2 {\r\n    function getMapping(string calldata tokenId) external view returns (address, address);\r\n}\r\n\r\ninterface MemoryInterface {\r\n    function getUint(uint _id) external returns (uint _num);\r\n    function setUint(uint _id, uint _val) external;\r\n}\r\n\r\ncontract DSMath {\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Helpers is DSMath {\r\n    /**\r\n     * @dev Return ethereum address\r\n     */\r\n    function getAddressETH() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return Memory Variable Address\r\n     */\r\n    function getMemoryAddr() internal pure returns (address) {\r\n        return 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F; // InstaMemory Address\r\n    }\r\n\r\n    // /**\r\n    //  * @dev Return InstaEvent Address.\r\n    //  */\r\n    // function getEventAddr() internal pure returns (address) {\r\n    //     return 0x2af7ea6Cb911035f3eb1ED895Cb6692C39ecbA97; // InstaEvent Address\r\n    // }\r\n\r\n    /**\r\n     * @dev Get Uint value from InstaMemory Contract.\r\n    */\r\n    function getUint(uint getId, uint val) internal returns (uint returnVal) {\r\n        returnVal = getId == 0 ? val : MemoryInterface(getMemoryAddr()).getUint(getId);\r\n    }\r\n\r\n    /**\r\n     * @dev Set Uint value in InstaMemory Contract.\r\n    */\r\n    function setUint(uint setId, uint val) internal {\r\n        if (setId != 0) MemoryInterface(getMemoryAddr()).setUint(setId, val);\r\n    }\r\n\r\n    /**\r\n     * @dev Connector Details\r\n    */\r\n    function connectorID() public pure returns(uint _type, uint _id) {\r\n        (_type, _id) = (1, 57);\r\n    }\r\n}\r\n\r\n\r\ncontract CompoundHelpers is Helpers {\r\n    /**\r\n     * @dev Return Compound Comptroller Address\r\n     */\r\n    function getComptrollerAddress() internal pure returns (address) {\r\n        return 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    }\r\n\r\n    /**\r\n     * @dev Return COMP Token Address.\r\n     */\r\n    function getCompTokenAddress() internal pure returns (address) {\r\n        return 0xc00e94Cb662C3520282E6f5717214004A7f26888;\r\n    }\r\n\r\n    /**\r\n     * @dev Return InstaDApp Mapping Addresses\r\n     */\r\n    function getMappingAddr() internal pure returns (address) {\r\n        return 0xA8F9D4aA7319C54C04404765117ddBf9448E2082; // InstaMapping Address\r\n    }\r\n\r\n    /**\r\n     * @dev enter compound market\r\n     */\r\n    function enterMarket(address cToken) internal {\r\n        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\r\n        address[] memory markets = troller.getAssetsIn(address(this));\r\n        bool isEntered = false;\r\n        for (uint i = 0; i < markets.length; i++) {\r\n            if (markets[i] == cToken) {\r\n                isEntered = true;\r\n            }\r\n        }\r\n        if (!isEntered) {\r\n            address[] memory toEnter = new address[](1);\r\n            toEnter[0] = cToken;\r\n            troller.enterMarkets(toEnter);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract BasicResolver is CompoundHelpers {\r\n    event LogDeposit(address indexed token, string tokenId, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n    event LogWithdraw(address indexed token, string tokenId, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n    event LogBorrow(address indexed token, string tokenId, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n    event LogPayback(address indexed token, string tokenId, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n\r\n    /**\r\n     * @dev Deposit ETH/ERC20_Token.\r\n     * @param tokenId token id of the token to deposit.(For eg: ETH-A)\r\n     * @param amt token amount to deposit.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function deposit(string calldata tokenId, uint amt, uint getId, uint setId) external payable{\r\n        uint _amt = getUint(getId, amt);\r\n        (address token, address cToken) = InstaMappingV2(getMappingAddr()).getMapping(tokenId);\r\n        require(token != address(0) && cToken != address(0), \"ctoken mapping not found\");\r\n        enterMarket(cToken);\r\n        if (token == getAddressETH()) {\r\n            _amt = _amt == uint(-1) ? address(this).balance : _amt;\r\n            CETHInterface(cToken).mint.value(_amt)();\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            _amt = _amt == uint(-1) ? tokenContract.balanceOf(address(this)) : _amt;\r\n            tokenContract.approve(cToken, _amt);\r\n            require(CTokenInterface(cToken).mint(_amt) == 0, \"deposit-failed\");\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogDeposit(token, tokenId, cToken, _amt, getId, setId);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw ETH/ERC20_Token.\r\n     * @param tokenId token id of the token to withdraw.(For eg: ETH-A)\r\n     * @param amt token amount to withdraw.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function withdraw(string calldata tokenId, uint amt, uint getId, uint setId) external payable{\r\n        uint _amt = getUint(getId, amt);\r\n        (address token, address cToken) = InstaMappingV2(getMappingAddr()).getMapping(tokenId);\r\n        require(token != address(0) && cToken != address(0), \"ctoken mapping not found\");\r\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\r\n        if (_amt == uint(-1)) {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            uint initialBal = token == getAddressETH() ? address(this).balance : tokenContract.balanceOf(address(this));\r\n            require(cTokenContract.redeem(cTokenContract.balanceOf(address(this))) == 0, \"full-withdraw-failed\");\r\n            uint finalBal = token == getAddressETH() ? address(this).balance : tokenContract.balanceOf(address(this));\r\n            _amt = finalBal - initialBal;\r\n        } else {\r\n            require(cTokenContract.redeemUnderlying(_amt) == 0, \"withdraw-failed\");\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogWithdraw(token, tokenId, cToken, _amt, getId, setId);\r\n    }\r\n\r\n    /**\r\n     * @dev Borrow ETH/ERC20_Token.\r\n     * @param tokenId token id of the token to borrow.(For eg: DAI-A)\r\n     * @param amt token amount to borrow.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function borrow(string calldata tokenId, uint amt, uint getId, uint setId) external payable {\r\n        uint _amt = getUint(getId, amt);\r\n        (address token, address cToken) = InstaMappingV2(getMappingAddr()).getMapping(tokenId);\r\n        require(token != address(0) && cToken != address(0), \"ctoken mapping not found\");\r\n        enterMarket(cToken);\r\n        require(CTokenInterface(cToken).borrow(_amt) == 0, \"borrow-failed\");\r\n        setUint(setId, _amt);\r\n\r\n        emit LogBorrow(token, tokenId, cToken, _amt, getId, setId);\r\n    }\r\n\r\n    /**\r\n     * @dev Payback borrowed ETH/ERC20_Token.\r\n     * @param tokenId token id of the token to payback.(For eg: COMP-A)\r\n     * @param amt token amount to payback.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function payback(string calldata tokenId, uint amt, uint getId, uint setId) external payable {\r\n        uint _amt = getUint(getId, amt);\r\n        (address token, address cToken) = InstaMappingV2(getMappingAddr()).getMapping(tokenId);\r\n        require(token != address(0) && cToken != address(0), \"ctoken mapping not found\");\r\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\r\n        _amt = _amt == uint(-1) ? cTokenContract.borrowBalanceCurrent(address(this)) : _amt;\r\n\r\n        if (token == getAddressETH()) {\r\n            require(address(this).balance >= _amt, \"not-enough-eth\");\r\n            CETHInterface(cToken).repayBorrow.value(_amt)();\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            require(tokenContract.balanceOf(address(this)) >= _amt, \"not-enough-token\");\r\n            tokenContract.approve(cToken, _amt);\r\n            require(cTokenContract.repayBorrow(_amt) == 0, \"repay-failed.\");\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogPayback(token, tokenId, cToken, _amt, getId, setId);\r\n    }\r\n}\r\n\r\ncontract ExtraResolver is BasicResolver {\r\n    event LogClaimedComp(uint256 compAmt, uint256 setId);\r\n    event LogDepositCToken(\r\n        address indexed token,\r\n        string tokenId,\r\n        address cToken,\r\n        uint256 tokenAmt,\r\n        uint256 cTokenAmt,\r\n        uint256 getId,\r\n        uint256 setId\r\n    );\r\n    event LogWithdrawCToken(\r\n        address indexed token,\r\n        string tokenId,\r\n        address cToken,\r\n        uint256 tokenAmt,\r\n        uint256 cTokenAmt,\r\n        uint256 getId,\r\n        uint256 setId\r\n    );\r\n    event LogLiquidate(\r\n        address indexed borrower,\r\n        address indexed tokenToPay,\r\n        address indexed tokenInReturn,\r\n        uint256 tokenAmt,\r\n        uint256 getId,\r\n        uint256 setId\r\n    );\r\n\r\n    struct LiquidateData {\r\n        address tokenToPay;\r\n        address tokenInReturn;\r\n        address cTokenPay;\r\n        address cTokenColl;\r\n}\r\n\r\n    /**\r\n     * @dev Deposit ETH/ERC20_Token.\r\n     * @param tokenId token id of the token to depositCToken.(For eg: DAI-A)\r\n     * @param amt token amount to depositCToken.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set ctoken amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function depositCToken(string calldata tokenId, uint amt, uint getId, uint setId) external payable{\r\n        uint _amt = getUint(getId, amt);\r\n        (address token, address cToken) = InstaMappingV2(getMappingAddr()).getMapping(tokenId);\r\n        require(token != address(0) && cToken != address(0), \"ctoken mapping not found\");\r\n        enterMarket(cToken);\r\n\r\n        CTokenInterface ctokenContract = CTokenInterface(cToken);\r\n        uint initialBal = ctokenContract.balanceOf(address(this));\r\n\r\n        if (token == getAddressETH()) {\r\n            _amt = _amt == uint(-1) ? address(this).balance : _amt;\r\n            CETHInterface(cToken).mint.value(_amt)();\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            _amt = _amt == uint(-1) ? tokenContract.balanceOf(address(this)) : _amt;\r\n            tokenContract.approve(cToken, _amt);\r\n            require(ctokenContract.mint(_amt) == 0, \"deposit-ctoken-failed.\");\r\n        }\r\n\r\n        uint finalBal = ctokenContract.balanceOf(address(this));\r\n        uint _cAmt = finalBal - initialBal;\r\n        setUint(setId, _cAmt);\r\n\r\n        emit LogDepositCToken(token, tokenId, cToken, _amt, _cAmt, getId, setId);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw CETH/CERC20_Token using cToken Amt.\r\n     * @param tokenId token id of the token to withdraw CToken.(For eg: ETH-A)\r\n     * @param cTokenAmt ctoken amount to withdrawCToken.\r\n     * @param getId Get ctoken amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function withdrawCToken(string calldata tokenId, uint cTokenAmt, uint getId, uint setId) external payable {\r\n        uint _cAmt = getUint(getId, cTokenAmt);\r\n        (address token, address cToken) = InstaMappingV2(getMappingAddr()).getMapping(tokenId);\r\n        require(token != address(0) && cToken != address(0), \"ctoken mapping not found\");\r\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\r\n        TokenInterface tokenContract = TokenInterface(token);\r\n        _cAmt = _cAmt == uint(-1) ? cTokenContract.balanceOf(address(this)) : _cAmt;\r\n\r\n        uint withdrawAmt;\r\n\r\n        {\r\n            uint initialBal = token != getAddressETH() ? tokenContract.balanceOf(address(this)) : address(this).balance;\r\n            require(cTokenContract.redeem(_cAmt) == 0, \"redeem-failed\");\r\n            uint finalBal = token != getAddressETH() ? tokenContract.balanceOf(address(this)) : address(this).balance;\r\n\r\n            withdrawAmt = sub(finalBal, initialBal);\r\n        }\r\n\r\n        setUint(setId, withdrawAmt);\r\n\r\n        emit LogWithdrawCToken(token, tokenId, cToken, withdrawAmt, _cAmt, getId, setId);\r\n    }\r\n\r\n    /**\r\n     * @dev Liquidate a position.\r\n     * @param borrower Borrower's Address.\r\n     * @param tokenIdToPay token id of the token to pay for liquidation.(For eg: ETH-A)\r\n     * @param tokenIdInReturn token id of the token to return for liquidation.(For eg: USDC-A)\r\n     * @param amt token amount to pay for liquidation.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function liquidate(\r\n        address borrower,\r\n        string calldata tokenIdToPay,\r\n        string calldata tokenIdInReturn,\r\n        uint amt,\r\n        uint getId,\r\n        uint setId\r\n    ) external payable\r\n    {\r\n        uint _amt = getUint(getId, amt);\r\n\r\n        LiquidateData memory data;\r\n\r\n        (data.tokenToPay, data.cTokenPay) = InstaMappingV2(getMappingAddr()).getMapping(tokenIdToPay);\r\n        require(data.tokenToPay != address(0) && data.cTokenPay != address(0), \"ctoken mapping not found\");\r\n        (data.tokenInReturn, data.cTokenColl) = InstaMappingV2(getMappingAddr()).getMapping(tokenIdInReturn);\r\n        require(data.tokenInReturn != address(0) && data.cTokenColl != address(0), \"ctoken mapping not found\");\r\n        CTokenInterface cTokenContract = CTokenInterface(data.cTokenPay);\r\n\r\n        {\r\n            (,, uint shortfal) = ComptrollerInterface(getComptrollerAddress()).getAccountLiquidity(borrower);\r\n            require(shortfal != 0, \"account-cannot-be-liquidated\");\r\n        }\r\n\r\n        _amt = _amt == uint(-1) ? cTokenContract.borrowBalanceCurrent(borrower) : _amt;\r\n        if (data.tokenToPay == getAddressETH()) {\r\n            require(address(this).balance >= _amt, \"not-enought-eth\");\r\n            CETHInterface(data.cTokenPay).liquidateBorrow.value(_amt)(borrower, data.cTokenColl);\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(data.tokenToPay);\r\n            require(tokenContract.balanceOf(address(this)) >= _amt, \"not-enough-token\");\r\n            tokenContract.approve(data.cTokenPay, _amt);\r\n            require(cTokenContract.liquidateBorrow(borrower, _amt, data.cTokenColl) == 0, \"liquidate-failed\");\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogLiquidate(\r\n            address(this),\r\n            data.tokenToPay,\r\n            data.tokenInReturn,\r\n            _amt,\r\n            getId,\r\n            setId\r\n        );\r\n    }\r\n}\r\n\r\n\r\ncontract ConnectCompound is ExtraResolver {\r\n    string public name = \"Compound-v1.4\";\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"compAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogClaimedComp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cTokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogDepositCToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenToPay\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenInReturn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogLiquidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogPayback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cTokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawCToken\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"connectorID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"depositCToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenIdToPay\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenIdInReturn\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"liquidate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"payback\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"cTokenAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"withdrawCToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"ConnectCompound","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6e13a281679fc5eb592c7067d40add3777765ae4ae09c25542f2e7b8715e0f93"}]}