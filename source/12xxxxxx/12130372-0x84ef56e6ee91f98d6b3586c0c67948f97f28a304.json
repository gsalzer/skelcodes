{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-03-23\r\n*/\r\n\r\npragma solidity ^0.5.0;\r\n\r\n//Mutability and Visibility of some functions has been altered.\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x6466353c\r\ninterface ERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n\r\n    // Changed mutability to implicit non-payable\r\n    // Changed visibility to public\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\"\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n\r\n    // Changed mutability to implicit non-payable\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n\r\n    // Changed mutability to implicit non-payable\r\n    // Changed visibility to public\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Set or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n\r\n    // Changed mutability to implicit non-payable\r\n    function approve(address _approved, uint256 _tokenId) external;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all your assets.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner.\r\n    /// @dev Emits the ApprovalForAll event\r\n    /// @param _operator Address to add to the set of authorized operators.\r\n    /// @param _approved True if the operators is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/Math.sol\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface INFTGovernance {\r\n    function getListingActiveDelay() external view returns (uint256);\r\n    function getBuyBonusResidual() external view returns (uint256);\r\n    function getMarketFee() external view returns (uint256);\r\n    function getAbsoluteMinPrice() external view returns (uint256);\r\n    function getMinPrice() external view returns (uint256);\r\n    function getMaxPrice() external view returns (uint256);\r\n    function getTokensForPrice(uint256 price) external view returns (uint256);\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function getNftAddress(uint256 _tokenId) external view returns (address);\r\n}\r\n\r\ncontract NFTGovernance is INFTGovernance {\r\n    using SafeMath for uint256;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Owner required\");\r\n        _;\r\n    }\r\n    \r\n    modifier unlocked(uint256 index) {\r\n        require(!isTimelockActivated || block.number > unlockTimes[index], \"Locked\");\r\n        _;\r\n    }\r\n    \r\n    modifier timelockUnlocked() {\r\n        require(!isTimelockActivated || block.number > timelockLengthUnlockTime, \"Timelock variable Locked\");\r\n        _;\r\n    }\r\n    \r\n    bool public isTimelockActivated = false;\r\n\r\n    address public nftAddress;\r\n    address public owner;\r\n\r\n    uint256 constant DEFAULT_TIMELOCK_LENGTH = 44800; // length in blocks ~7 days;\r\n\r\n    uint256 constant MARKET_FEE_INDEX = 0;\r\n    uint256 constant MIN_PRICE_INDEX = 1;\r\n    uint256 constant MAX_PRICE_INDEX = 2;\r\n    uint256 constant TARGET_PRICE_INDEX = 3;\r\n    uint256 constant BUY_BONUS_RESIDUAL_INDEX = 4;\r\n    uint256 constant LISTING_DELAY_INDEX = 5;\r\n    uint256 constant ABSOLUTE_MIN_PRICE_INDEX = 6;\r\n    \r\n    uint256 public timelockLengthUnlockTime = 0;\r\n    uint256 public timelockLength = DEFAULT_TIMELOCK_LENGTH;\r\n    uint256 public nextTimelockLength = DEFAULT_TIMELOCK_LENGTH;\r\n        \r\n    uint256 public PRICE_SCALE_FACTOR = 10;\r\n\r\n\r\n    mapping(uint256 => uint256) public pendingValues;\r\n    mapping(uint256 => uint256) public values;\r\n    mapping(uint256 => uint256) public unlockTimes;\r\n\r\n    constructor (\r\n        uint256 marketFeeFactor, \r\n        uint256 minPrice, \r\n        uint256 maxPrice, \r\n        uint256 targetPrice, \r\n        uint256 buyBonusResidual, \r\n        uint256 listingActiveDelay, \r\n        uint256 absoluteMinPrice, \r\n        address _nftAddress\r\n    ) public {\r\n        values[MARKET_FEE_INDEX] = marketFeeFactor;\r\n        values[MIN_PRICE_INDEX] = minPrice;\r\n        values[MAX_PRICE_INDEX] = maxPrice;\r\n        values[TARGET_PRICE_INDEX] = targetPrice;\r\n        values[BUY_BONUS_RESIDUAL_INDEX] = buyBonusResidual;\r\n        values[LISTING_DELAY_INDEX] = listingActiveDelay;\r\n        values[ABSOLUTE_MIN_PRICE_INDEX] = absoluteMinPrice;\r\n        \r\n        nftAddress = _nftAddress;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function activateTimelock() external onlyOwner {\r\n        isTimelockActivated = true;\r\n    }\r\n\r\n    function setPendingValue(uint256 index, uint256 value) external onlyOwner {\r\n        pendingValues[index] = value;\r\n        unlockTimes[index] = timelockLength.add(block.number);\r\n    }\r\n\r\n    function certifyPendingValue(uint256 index) external onlyOwner unlocked(index) {\r\n        values[index] = pendingValues[index];\r\n        unlockTimes[index] = 0;\r\n    }\r\n\r\n    function proposeNextTimelockLength(uint256 value) public onlyOwner {\r\n        nextTimelockLength = value;\r\n        timelockLengthUnlockTime = block.number.add(timelockLength);\r\n    }\r\n\r\n    function certifyNextTimelockLength() public onlyOwner timelockUnlocked() {\r\n        timelockLength = nextTimelockLength;\r\n        timelockLengthUnlockTime = 0;\r\n    }\r\n    \r\n    function getMarketFee() public view returns (uint256) {\r\n        return values[MARKET_FEE_INDEX];\r\n    }\r\n\r\n    function getMinPrice() public view returns (uint256) {\r\n        return values[MIN_PRICE_INDEX];    \r\n    }\r\n\r\n    function getMaxPrice() public view returns (uint256) {\r\n        return values[MAX_PRICE_INDEX];    \r\n    }\r\n\r\n    function getTargetPrice() public view returns (uint256) {\r\n        return values[TARGET_PRICE_INDEX];    \r\n    }\r\n    \r\n    function getBuyBonusResidual() public view returns (uint256) {\r\n        return values[BUY_BONUS_RESIDUAL_INDEX];    \r\n    }\r\n    \r\n    function getListingActiveDelay() public view returns (uint256) {\r\n        return values[LISTING_DELAY_INDEX];    \r\n    }    \r\n\r\n    function getAbsoluteMinPrice() public view returns (uint256) {\r\n        return values[ABSOLUTE_MIN_PRICE_INDEX];    \r\n    }\r\n    \r\n    function getTokensForPrice(uint256 price) external view returns (uint256) {\r\n        uint256 max = getMaxPrice();\r\n        uint256 min = getMinPrice();\r\n        uint256 target = getTargetPrice();\r\n\r\n        uint256 startRange = target.mul(1e18).div(min);\r\n        uint256 endRange = target.mul(1e18).div(max);\r\n        \r\n        uint256 effectivePrice = price;\r\n        if (price < min) {\r\n            effectivePrice = min;\r\n        } else if (price > max) {\r\n            effectivePrice = max;\r\n        }\r\n\r\n        uint256 tokens = 0;\r\n        if (effectivePrice < target) {\r\n            tokens = (target.sub(effectivePrice)).mul(startRange).div(1e18).mul(PRICE_SCALE_FACTOR).add(1e18);\r\n        } else {\r\n            tokens = (max.sub(effectivePrice)).mul(endRange).div(1e18);\r\n        }\r\n        \r\n        return tokens;\r\n    }\r\n    \r\n    function getApproved(uint256 _tokenId) external view returns (address) {\r\n        ERC721 token = ERC721(nftAddress);\r\n        return token.getApproved(_tokenId);\r\n    }\r\n    \r\n    function ownerOf(uint256 _tokenId) external view returns (address) {\r\n        ERC721 token = ERC721(nftAddress);\r\n        return token.ownerOf(_tokenId);\r\n    }\r\n    \r\n    function getNftAddress(uint256 _tokenId) external view returns (address) {\r\n        return nftAddress;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketFeeFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyBonusResidual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingActiveDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"absoluteMinPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE_SCALE_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activateTimelock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"certifyNextTimelockLength\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"certifyPendingValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAbsoluteMinPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBuyBonusResidual\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getListingActiveDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMarketFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaxPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMinPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getNftAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTargetPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"getTokensForPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTimelockActivated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextTimelockLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nftAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingValues\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"proposeNextTimelockLength\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setPendingValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timelockLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timelockLengthUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unlockTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"values\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"NFTGovernance","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000905438e600100000000000000000000000000000000000000000000000000008ac7230489e8000000000000000000000000000000000000000000000000000014d1120d7b160000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000009184e72a000000000000000000000000000c2c747e0f7004f9e8817db2ca4997657a7746928","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://366745c100f70210e6981cf11be22abdb08669fc873dda6129d189ee3af642bc"}]}