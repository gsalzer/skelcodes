{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n *\r\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\r\n * metering changes introduced in the Istanbul hardfork.\r\n */\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor () internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interfaces/IXHalfLife.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface IXHalfLife {\r\n    function createStream(\r\n        address token,\r\n        address recipient,\r\n        uint256 depositAmount,\r\n        uint256 startBlock,\r\n        uint256 kBlock,\r\n        uint256 unlockRatio,\r\n        bool cancelable\r\n    ) external returns (uint256);\r\n\r\n    function createEtherStream(\r\n        address recipient,\r\n        uint256 startBlock,\r\n        uint256 kBlock,\r\n        uint256 unlockRatio,\r\n        bool cancelable\r\n    ) external payable returns (uint256);\r\n\r\n    function hasStream(uint256 streamId) external view returns (bool);\r\n\r\n    function getStream(uint256 streamId)\r\n        external\r\n        view\r\n        returns (\r\n            address sender,\r\n            address recipient,\r\n            address token,\r\n            uint256 depositAmount,\r\n            uint256 startBlock,\r\n            uint256 kBlock,\r\n            uint256 remaining,\r\n            uint256 withdrawable,\r\n            uint256 unlockRatio,\r\n            uint256 lastRewardBlock,\r\n            bool cancelable\r\n        );\r\n\r\n    function balanceOf(uint256 streamId)\r\n        external\r\n        view\r\n        returns (uint256 withdrawable, uint256 remaining);\r\n\r\n    function withdrawFromStream(uint256 streamId, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function cancelStream(uint256 streamId) external returns (bool);\r\n\r\n    function singleFundStream(uint256 streamId, uint256 amount)\r\n        external\r\n        payable\r\n        returns (bool);\r\n\r\n    function lazyFundStream(\r\n        uint256 streamId,\r\n        uint256 amount,\r\n        uint256 blockHeightDiff\r\n    ) external payable returns (bool);\r\n\r\n    function getVersion() external pure returns (bytes32);\r\n}\r\n\r\n// File: contracts/XdexStream.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\ncontract XdexStream is ReentrancyGuard {\r\n    uint256 constant ONE = 10**18;\r\n\r\n    //The XDEX Token!\r\n    address public xdex;\r\n    address public xdexFarmMaster;\r\n\r\n    /**\r\n     * @notice An interface of XHalfLife, the contract responsible for creating, funding and withdrawing from streams.\r\n     * No one could cancle the xdex resward stream except the recipient, because the stream sender is this contract.\r\n     */\r\n    IXHalfLife public halflife;\r\n\r\n    struct LockStream {\r\n        address depositor;\r\n        bool isEntity;\r\n        uint256 streamId;\r\n    }\r\n\r\n    //unlock ratio is 0.1% for both Voting and Normal Pool\r\n    uint256 private constant unlockRatio = 1;\r\n\r\n    //unlock k block for Voting Pool\r\n    uint256 private constant unlockKBlocksV = 540;\r\n    // key: recipient, value: Locked Stream\r\n    mapping(address => LockStream) private votingStreams;\r\n\r\n    //funds for Normal Pool\r\n    uint256 private constant unlockKBlocksN = 60;\r\n    // key: recipient, value: Locked Stream\r\n    mapping(address => LockStream) private normalStreams;\r\n\r\n    // non cancelable farm streams\r\n    bool private constant cancelable = false;\r\n\r\n    /**\r\n     * @notice User can have at most one votingStream and one normalStream.\r\n     * @param streamType The type of stream: 0 is votingStream, 1 is normalStream;\r\n     */\r\n    modifier lockStreamExists(address who, uint256 streamType) {\r\n        bool found = false;\r\n        if (streamType == 0) {\r\n            //voting stream\r\n            found = votingStreams[who].isEntity;\r\n        } else if (streamType == 1) {\r\n            //normal stream\r\n            found = normalStreams[who].isEntity;\r\n        }\r\n\r\n        require(found, \"the lock stream does not exist\");\r\n        _;\r\n    }\r\n\r\n    modifier validStreamType(uint256 streamType) {\r\n        require(\r\n            streamType == 0 || streamType == 1,\r\n            \"invalid stream type: 0 or 1\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _xdex,\r\n        address _halfLife,\r\n        address _farmMaster\r\n    ) public {\r\n        xdex = _xdex;\r\n        halflife = IXHalfLife(_halfLife);\r\n        xdexFarmMaster = _farmMaster;\r\n    }\r\n\r\n    /**\r\n     * If the user has VotingStream or has NormalStream.\r\n     */\r\n    function hasStream(address who)\r\n        public\r\n        view\r\n        returns (bool hasVotingStream, bool hasNormalStream)\r\n    {\r\n        hasVotingStream = votingStreams[who].isEntity;\r\n        hasNormalStream = normalStreams[who].isEntity;\r\n    }\r\n\r\n    /**\r\n     * @notice Get a user's voting or normal stream id.\r\n     * @dev stream id must > 0.\r\n     * @param streamType The type of stream: 0 is votingStream, 1 is normalStream;\r\n     */\r\n    function getStreamId(address who, uint256 streamType)\r\n        public\r\n        view\r\n        lockStreamExists(who, streamType)\r\n        returns (uint256 streamId)\r\n    {\r\n        if (streamType == 0) {\r\n            return votingStreams[who].streamId;\r\n        } else if (streamType == 1) {\r\n            return normalStreams[who].streamId;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a new stream funded by `msg.sender` and paid towards to `recipient`.\r\n     * @param streamType The type of stream: 0 is votingStream, 1 is normalStream;\r\n     */\r\n    function createStream(\r\n        address recipient,\r\n        uint256 depositAmount,\r\n        uint256 streamType,\r\n        uint256 startBlock\r\n    )\r\n        external\r\n        nonReentrant\r\n        validStreamType(streamType)\r\n        returns (uint256 streamId)\r\n    {\r\n        require(msg.sender == xdexFarmMaster, \"only farmMaster could create\");\r\n        require(recipient != address(0), \"stream to the zero address\");\r\n        require(recipient != address(this), \"stream to the contract itself\");\r\n        require(recipient != msg.sender, \"stream to the caller\");\r\n        require(depositAmount > 0, \"depositAmount is zero\");\r\n        require(startBlock >= block.number, \"start block before block.number\");\r\n\r\n        if (streamType == 0) {\r\n            require(\r\n                !(votingStreams[recipient].isEntity),\r\n                \"voting stream exists\"\r\n            );\r\n        }\r\n        if (streamType == 1) {\r\n            require(\r\n                !(normalStreams[recipient].isEntity),\r\n                \"normal stream exists\"\r\n            );\r\n        }\r\n\r\n        uint256 unlockKBlocks = unlockKBlocksN;\r\n        if (streamType == 0) {\r\n            unlockKBlocks = unlockKBlocksV;\r\n        }\r\n\r\n        /* Approve the XHalflife contract to spend. */\r\n        IERC20(xdex).approve(address(halflife), depositAmount);\r\n\r\n        /* Transfer the tokens to this contract. */\r\n        IERC20(xdex).transferFrom(msg.sender, address(this), depositAmount);\r\n\r\n        streamId = halflife.createStream(\r\n            xdex,\r\n            recipient,\r\n            depositAmount,\r\n            startBlock,\r\n            unlockKBlocks,\r\n            unlockRatio,\r\n            cancelable\r\n        );\r\n\r\n        if (streamType == 0) {\r\n            votingStreams[recipient] = LockStream({\r\n                depositor: msg.sender,\r\n                isEntity: true,\r\n                streamId: streamId\r\n            });\r\n        } else if (streamType == 1) {\r\n            normalStreams[recipient] = LockStream({\r\n                depositor: msg.sender,\r\n                isEntity: true,\r\n                streamId: streamId\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Send funds to the stream\r\n     * @param streamId The given stream id;\r\n     * @param amount New amount fund to add;\r\n     * @param blockHeightDiff diff of block.number and farmPool's lastRewardBlock;\r\n     */\r\n    function fundsToStream(\r\n        uint256 streamId,\r\n        uint256 amount,\r\n        uint256 blockHeightDiff\r\n    ) public returns (bool result) {\r\n        require(amount > 0, \"amount is zero\");\r\n\r\n        /* Approve the XHalflife contract to spend. */\r\n        IERC20(xdex).approve(address(halflife), amount);\r\n\r\n        /* Transfer the tokens to this contract. */\r\n        IERC20(xdex).transferFrom(msg.sender, address(this), amount);\r\n\r\n        result = halflife.lazyFundStream(streamId, amount, blockHeightDiff);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_xdex\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_halfLife\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_farmMaster\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"streamType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"}],\"name\":\"createStream\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockHeightDiff\",\"type\":\"uint256\"}],\"name\":\"fundsToStream\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"streamType\",\"type\":\"uint256\"}],\"name\":\"getStreamId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halflife\",\"outputs\":[{\"internalType\":\"contract IXHalfLife\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"hasStream\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasVotingStream\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasNormalStream\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xdex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xdexFarmMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"XdexStream","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000d0151e748d25b766e77efe2a6c8300000000000000000000000092afb2d65466feec2d608484287f8a05984a63440000000000000000000000007f478b6c313cae4d36c1a6c0fb7c366b441bde58","EVMVersion":"istanbul","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f9c9d6b3faf37e96ed3136b7fab0a5fb6adaa398c5cd7a239ad76849e688453f"}]}