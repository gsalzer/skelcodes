{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/StableConverter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"./libraries/SafeERC20.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./interfaces/IWeth.sol\\\";\\n\\ncontract StableConverter {\\n    using SafeERC20 for IERC20;\\n\\n    /**\\n     * @notice admin\\n     */\\n    address public admin;\\n\\n    /**\\n     * @notice WETH token\\n     */\\n    address public immutable weth;\\n\\n    /*** Events ***/\\n\\n    /**\\n     * @notice Emitted when a conversion occured\\n     */\\n    event Convert(address indexed server, address indexed fromToken, address indexed toToken, uint fromAmount, uint toAmount);\\n\\n    /**\\n     * @notice Emitted when a new admin is set\\n     */\\n    event AdminSet(address indexed admin);\\n\\n    /**\\n     * @notice Emitted when admin seize tokens\\n     */\\n    event Seize(address indexed token, uint indexed amount);\\n\\n    constructor(\\n        address _admin,\\n        address _weth\\n    ) {\\n        admin = _admin;\\n        weth = _weth;\\n    }\\n\\n    modifier isAdmin() {\\n        require(msg.sender == admin, \\\"only admin could perform the action\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Execute a series of tokens conversion according to the specified contract address.\\n     * @param token The token address list\\n     * @param token The contract address list\\n     * @param amount The conversion amount list\\n     */\\n    function convertMultiple(address[] calldata token, address[] calldata pair, uint[] calldata amount) external isAdmin() {\\n        require(token.length == amount.length, \\\"invalid data\\\");\\n        require(token.length == pair.length, \\\"invalid data\\\");\\n\\n        for (uint i = 0; i < token.length; i++) {\\n             // if contract address not specified, no conversion\\n            if (pair[i] == address(0)) continue;\\n            // if contract is WETH and token is ETH, then convert to WETH\\n            if (pair[i] == weth && token[i] == address(0)) {\\n                convertEthToWeth(amount[i]);\\n            }\\n            convertWithPair(token[i], pair[i], amount[i]);\\n        }\\n    }\\n\\n    /*** Internal functions ***/\\n\\n    /**\\n     * @notice Convert token with the specified Swap V2 (Uni/Sushi) contract\\n     * @param token The input token address\\n     * @param pair The conversion contract address\\n     * @param amount The amount needs to be converted\\n     */\\n    function convertWithPair(address token, address pair, uint amount) internal {\\n        uint convertAmount = amount;\\n        // if maximum amount is specified, swap the balance only\\n        if (amount == type(uint).max) {\\n            convertAmount = IERC20(token).balanceOf(address(this));\\n        }\\n        swap(token, pair, convertAmount, address(this));\\n    }\\n\\n    /**\\n     * @notice Calculate swap output amount based on input amount and reserves\\n     * @param amountIn The token amount to swap\\n     * @param reserveIn Reserve of input token in the pair\\n     * @param reserveOut Reserve of output token in the pair\\n     * @return amountOut Calculated swap output token amount\\n     */\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\n        uint amountInWithFee = amountIn * 997;\\n        uint numerator = amountInWithFee * reserveOut;\\n        uint denominator = reserveIn * 1000 + amountInWithFee;\\n        amountOut = numerator / denominator;\\n    }\\n\\n    /**\\n     * @notice Convert ETH to WETH\\n     * @param amount The amount of ETH to be converted\\n     */\\n    function convertEthToWeth(uint amount) internal {\\n        IWeth(weth).deposit{value: amount}();\\n        emit Convert(msg.sender, address(0), weth, amount, amount);\\n    }\\n\\n    /**\\n     * @notice Swap fromToken using the given pairAddress\\n     * @param fromToken The from token\\n     * @param pairAddress The swap contract address to swap with\\n     * @param amountIn The amount of fromToken needs to be swapped\\n     * @param to The receiver after the swap\\n     * @return amountOut The amount of toToken that will be sent to the receiver\\n     */\\n    function swap(address fromToken, address pairAddress, uint amountIn, address to) internal returns (uint amountOut) {\\n        address toToken;\\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\\n        require(address(pair) != address(0), \\\"invalid pair\\\");\\n\\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\\n\\n        if (fromToken == pair.token0()) {\\n            toToken = pair.token1();\\n            amountOut = getAmountOut(amountIn, reserve0, reserve1);\\n            IERC20(fromToken).safeTransfer(address(pair), amountIn);\\n            pair.swap(0, amountOut, address(this), new bytes(0));\\n        } else {\\n            toToken = pair.token0();\\n            amountOut = getAmountOut(amountIn, reserve1, reserve0);\\n            IERC20(fromToken).safeTransfer(address(pair), amountIn);\\n            pair.swap(amountOut, 0, address(this), new bytes(0));\\n        }\\n        emit Convert(msg.sender, fromToken, toToken, amountIn, amountOut);\\n    }\\n\\n    /*** Admin functions ***/\\n\\n    /**\\n     * @notice Set the new admin.\\n     * @param newAdmin The new admin\\n     */\\n    function setAdmin(address newAdmin) external isAdmin() {\\n        admin = newAdmin;\\n        emit AdminSet(admin);\\n    }\\n\\n    /**\\n     * @notice Seize token to admin.\\n     * @param token The token address. Empty address for Ether.\\n     * @param amount The amount to seize\\n     */\\n    function seize(address token, uint amount) external isAdmin() {\\n        if (token == address(0)) {\\n            payable(admin).transfer(amount);\\n        } else {\\n            IERC20(token).safeTransfer(admin, amount);\\n        }\\n        emit Seize(token, amount);\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\nlibrary SafeERC20 {\\n    function safeSymbol(IERC20 token) internal view returns(string memory) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\n    }\\n\\n    function safeName(IERC20 token) internal view returns(string memory) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\n    }\\n\\n    function safeDecimals(IERC20 token) public view returns (uint8) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\n    }\\n\\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"SafeERC20: Transfer failed\\\");\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, uint256 amount) internal {\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"SafeERC20: TransferFrom failed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWeth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU\\n\\npragma solidity >=0.5.0;\\n\\ninterface IWeth {\\n    function deposit() external payable;\\n    function withdraw(uint wad) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    // EIP 2612\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AdminSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"server\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toAmount\",\"type\":\"uint256\"}],\"name\":\"Convert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Seize\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"token\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"pair\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"convertMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"seize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"StableConverter","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000197939c1ca20c2b506d6811d8b6cdb3394471074000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}