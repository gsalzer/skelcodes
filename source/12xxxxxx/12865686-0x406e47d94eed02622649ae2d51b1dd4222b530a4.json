{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/v1/markets/eth/opensea/OpenSeaMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface IOpenSea {\\n    /**\\n     * @dev Call atomicMatch - Solidity ABI encoding limitation workaround, hopefully temporary.\\n     */\\n    function atomicMatch_(\\n        address[14] memory addrs,\\n        uint[18] memory uints,\\n        uint8[8] memory feeMethodsSidesKindsHowToCalls,\\n        bytes memory calldataBuy,\\n        bytes memory calldataSell,\\n        bytes memory replacementPatternBuy,\\n        bytes memory replacementPatternSell,\\n        bytes memory staticExtradataBuy,\\n        bytes memory staticExtradataSell,\\n        uint8[2] memory vs,\\n        bytes32[5] memory rssMetadata\\n    ) external payable;\\n}\\n\\nlibrary OpenSeaMarket {\\n\\n    address public constant OPENSEA = 0x7Be8076f4EA4A4AD08075C2508e481d6C946D12b;\\n\\n    struct OpenSeaBuy {\\n        address[14] addrs;\\n        uint[18] uints;\\n        uint8[8] feeMethodsSidesKindsHowToCalls;\\n        bytes calldataBuy;\\n        bytes calldataSell;\\n        bytes replacementPatternBuy;\\n        bytes replacementPatternSell;\\n        bytes staticExtradataBuy;\\n        bytes staticExtradataSell;\\n        uint8[2] vs;\\n        bytes32[5] rssMetadata;\\n    }\\n\\n    function buyAssetsForEth(OpenSeaBuy[] memory openSeaBuys) public {\\n        for (uint256 i = 0; i < openSeaBuys.length; i++) {\\n            _buyAssetForEth(openSeaBuys[i]);\\n        }\\n    }\\n\\n    function _buyAssetForEth(OpenSeaBuy memory _openSeaBuy) internal {\\n        bytes memory _data = abi.encodeWithSelector(IOpenSea.atomicMatch_.selector, _openSeaBuy.addrs, _openSeaBuy.uints, _openSeaBuy.feeMethodsSidesKindsHowToCalls, _openSeaBuy.calldataBuy, _openSeaBuy.calldataSell, _openSeaBuy.replacementPatternBuy, _openSeaBuy.replacementPatternSell, _openSeaBuy.staticExtradataBuy, _openSeaBuy.staticExtradataSell, _openSeaBuy.vs, _openSeaBuy.rssMetadata);\\n        (bool success, ) = OPENSEA.call{value:_openSeaBuy.uints[4]}(_data);\\n        if (!success) {\\n            // Copy revert reason from call\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"OPENSEA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"OpenSeaMarket","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}