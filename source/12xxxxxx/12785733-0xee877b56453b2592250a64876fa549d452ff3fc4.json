{"status":"1","message":"OK","result":[{"SourceCode":"// Dependency file: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// pragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: contracts/libraries/FixedPointMath.sol\r\n\r\n// pragma solidity >=0.6.5 <0.8.0;\r\n\r\n\r\nlibrary FixedPointMath {\r\n  uint256 public constant DECIMALS = 18;\r\n  uint256 public constant SCALAR = 10**DECIMALS;\r\n\r\n  struct uq192x64 {\r\n    uint256 x;\r\n  }\r\n\r\n  function fromU256(uint256 value) internal pure returns (uq192x64 memory) {\r\n    uint256 x;\r\n    require(value == 0 || (x = value * SCALAR) / SCALAR == value);\r\n    return uq192x64(x);\r\n  }\r\n\r\n  function maximumValue() internal pure returns (uq192x64 memory) {\r\n    return uq192x64(uint256(-1));\r\n  }\r\n\r\n  function add(uq192x64 memory self, uq192x64 memory value) internal pure returns (uq192x64 memory) {\r\n    uint256 x;\r\n    require((x = self.x + value.x) >= self.x);\r\n    return uq192x64(x);\r\n  }\r\n\r\n  function add(uq192x64 memory self, uint256 value) internal pure returns (uq192x64 memory) {\r\n    return add(self, fromU256(value));\r\n  }\r\n\r\n  function sub(uq192x64 memory self, uq192x64 memory value) internal pure returns (uq192x64 memory) {\r\n    uint256 x;\r\n    require((x = self.x - value.x) <= self.x);\r\n    return uq192x64(x);\r\n  }\r\n\r\n  function sub(uq192x64 memory self, uint256 value) internal pure returns (uq192x64 memory) {\r\n    return sub(self, fromU256(value));\r\n  }\r\n\r\n  function mul(uq192x64 memory self, uint256 value) internal pure returns (uq192x64 memory) {\r\n    uint256 x;\r\n    require(value == 0 || (x = self.x * value) / value == self.x);\r\n    return uq192x64(x);\r\n  }\r\n\r\n  function div(uq192x64 memory self, uint256 value) internal pure returns (uq192x64 memory) {\r\n    require(value != 0);\r\n    return uq192x64(self.x / value);\r\n  }\r\n\r\n  function cmp(uq192x64 memory self, uq192x64 memory value) internal pure returns (int256) {\r\n    if (self.x < value.x) {\r\n      return -1;\r\n    }\r\n\r\n    if (self.x > value.x) {\r\n      return 1;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  function decode(uq192x64 memory self) internal pure returns (uint256) {\r\n    return self.x / SCALAR;\r\n  }\r\n}\r\n\r\n// Dependency file: contracts/libraries/TransferHelper.sol\r\n\r\n// pragma solidity >=0.6.5 <0.8.0;\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: contracts/interfaces/IDetailedERC20.sol\r\n\r\n// pragma solidity >=0.6.5 <0.8.0;\r\n\r\ninterface IDetailedERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\n// Dependency file: contracts/interfaces/IVaultAdapter.sol\r\n\r\n// pragma solidity >=0.6.5 <0.8.0;\r\n\r\n/// Interface for all Vault Adapter implementations.\r\ninterface IVaultAdapter {\r\n\r\n  /// @dev Gets the token that the adapter accepts.\r\n  function token() external view returns (address);\r\n\r\n  /// @dev The total value of the assets deposited into the vault.\r\n  function totalValue() external view returns (uint256);\r\n\r\n  /// @dev Deposits funds into the vault.\r\n  ///\r\n  /// @param _amount  the amount of funds to deposit.\r\n  function deposit(uint256 _amount) external;\r\n\r\n  /// @dev Attempts to withdraw funds from the wrapped vault.\r\n  ///\r\n  /// The amount withdrawn to the recipient may be less than the amount requested.\r\n  ///\r\n  /// @param _recipient the recipient of the funds.\r\n  /// @param _amount    the amount of funds to withdraw.\r\n  function withdraw(address _recipient, uint256 _amount) external;\r\n}\r\n\r\n// Dependency file: contracts/interfaces/IyVaultV2.sol\r\n\r\n// pragma solidity >=0.6.5 <0.8.0;\r\n\r\ninterface IyVaultV2 {\r\n    function token() external view returns (address);\r\n    function deposit(uint) external returns (uint);\r\n    function withdraw(uint, address) external returns (uint);\r\n    function pricePerShare() external view returns (uint);\r\n    function decimals() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n}\r\n\r\n// Root file: contracts/adapters/YearnVaultAdapter.sol\r\n\r\npragma solidity >=0.6.5 <0.8.0;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n// import \"/mnt/c/code_project/chfry-finance/contract/node_modules/@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\n// import \"contracts/libraries/FixedPointMath.sol\";\r\n// import \"contracts/libraries/TransferHelper.sol\";\r\n// import \"contracts/interfaces/IDetailedERC20.sol\";\r\n// import \"contracts/interfaces/IVaultAdapter.sol\";\r\n// import \"contracts/interfaces/IyVaultV2.sol\";\r\n\r\n/// @title YearnVaultAdapter\r\n///\r\n/// @dev A vault adapter implementation which wraps a yEarn vault.\r\ncontract YearnVaultAdapter is IVaultAdapter {\r\n    using FixedPointMath for FixedPointMath.uq192x64;\r\n    using TransferHelper for address;\r\n    using SafeMath for uint256;\r\n\r\n    /// @dev The vault that the adapter is wrapping.\r\n    IyVaultV2 public vault;\r\n\r\n    /// @dev The address which has admin control over this contract.\r\n    address public admin;\r\n\r\n    /// @dev The decimals of the token.\r\n    uint256 public decimals;\r\n\r\n    constructor(IyVaultV2 _vault, address _admin) public {\r\n        vault = _vault;\r\n        admin = _admin;\r\n        updateApproval();\r\n        decimals = _vault.decimals();\r\n    }\r\n\r\n    /// @dev A modifier which reverts if the caller is not the admin.\r\n    modifier onlyAdmin() {\r\n        require(admin == msg.sender, \"YearnVaultAdapter: only admin\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Gets the token that the vault accepts.\r\n    ///\r\n    /// @return the accepted token.\r\n    function token() external view override returns (address) {\r\n        return vault.token();\r\n    }\r\n\r\n    /// @dev Gets the total value of the assets that the adapter holds in the vault.\r\n    ///\r\n    /// @return the total assets.\r\n    function totalValue() external view override returns (uint256) {\r\n        return _sharesToTokens(vault.balanceOf(address(this)));\r\n    }\r\n\r\n    /// @dev Deposits tokens into the vault.\r\n    ///\r\n    /// @param _amount the amount of tokens to deposit into the vault.\r\n    function deposit(uint256 _amount) external override {\r\n        vault.deposit(_amount);\r\n    }\r\n\r\n    /// @dev Withdraws tokens from the vault to the recipient.\r\n    ///\r\n    /// This function reverts if the caller is not the admin.\r\n    ///\r\n    /// @param _recipient the account to withdraw the tokes to.\r\n    /// @param _amount    the amount of tokens to withdraw.\r\n    function withdraw(address _recipient, uint256 _amount)\r\n        external\r\n        override\r\n        onlyAdmin\r\n    {\r\n        vault.withdraw(_tokensToShares(_amount), _recipient);\r\n    }\r\n\r\n    /// @dev Updates the vaults approval of the token to be the maximum value.\r\n    function updateApproval() public {\r\n        address _token = vault.token();\r\n        _token.safeApprove(address(vault), uint256(-1));\r\n    }\r\n\r\n    /// @dev Computes the number of tokens an amount of shares is worth.\r\n    ///\r\n    /// @param _sharesAmount the amount of shares.\r\n    ///\r\n    /// @return the number of tokens the shares are worth.\r\n\r\n    function _sharesToTokens(uint256 _sharesAmount)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _sharesAmount.mul(vault.pricePerShare()).div(10**decimals);\r\n    }\r\n\r\n    /// @dev Computes the number of shares an amount of tokens is worth.\r\n    ///\r\n    /// @param _tokensAmount the amount of shares.\r\n    ///\r\n    /// @return the number of shares the tokens are worth.\r\n    function _tokensToShares(uint256 _tokensAmount)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _tokensAmount.mul(10**decimals).div(vault.pricePerShare());\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IyVaultV2\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IyVaultV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"YearnVaultAdapter","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000019d3364a399d251e894ac732651be8b0e4e8500100000000000000000000000018a6b56eef252abf858b0f1b4209846d5bb1ff0f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://742ecce2a661eda3987de49817a902b511dcbf6929a8129f90e0d1d6751862cd"}]}