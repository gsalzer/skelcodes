{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.8;\r\n\r\n\r\ncontract ElBote {\r\n    \r\n    //propietario\r\n    address private owner;\r\n    \r\n    //####\r\n    constructor(){\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function changeOwner(address newOwner) public payable {\r\n        require(msg.value >= min_ether);\r\n        payable(owner).transfer(msg.value);\r\n        require(msg.sender == owner);\r\n        owner = newOwner;\r\n    }\r\n    \r\n    //-----------------------------\r\n    \r\n    \r\n    //afiliados\r\n    struct Afiliado{\r\n        uint conversiones;\r\n        uint ingresos;\r\n        bool joined;\r\n    }\r\n    \r\n    mapping(address => Afiliado) private afiliados;\r\n    \r\n    uint constant N = 20;\r\n    address[N] private topIngresos;\r\n    address[N] private topConversiones;\r\n    \r\n    //####\r\n    function getAfiliadoInfo () public view returns (uint, uint, bool) {\r\n        return (afiliados[msg.sender].conversiones, afiliados[msg.sender].ingresos, afiliados[msg.sender].joined);\r\n    }\r\n    \r\n    function pushAfiliado () public payable {\r\n        require(msg.sender != owner);\r\n        require(msg.value >= min_ether);\r\n        require(afiliados[msg.sender].joined==false);\r\n        afiliados[msg.sender]=Afiliado(0,0, true);\r\n        payable(owner).transfer(msg.value);\r\n    }\r\n    //------------------------------\r\n    \r\n    \r\n    //EL BOTE - ¡¡¡HAGAN SUS APUESTAS!!!\r\n    uint public balanceTotal;\r\n    address private winner;\r\n    uint private winnerValue;\r\n    uint private winnerBlock;\r\n    uint private winnerDificulty;\r\n    uint private winnerTimespam;\r\n    uint private rand;\r\n    uint constant MAX_INT = 2**256 - 1; //115792089237316195423570985008687907853269984665640564039457584007913129639935\r\n    uint constant min_ether = 0.01 ether;\r\n    uint constant lotes = 0.001 ether; // calcularemos la probabilidad en n uinidades de 0.001 ethers\r\n    uint constant n_MAX_INT=MAX_INT/lotes;\r\n    uint constant TIME = 1 days;\r\n    uint private bonus;\r\n    uint public level;\r\n    uint public start;\r\n    uint public end;\r\n    uint public bote;\r\n    uint private apuesta;\r\n    \r\n    struct winners_info{\r\n        address winner;\r\n        uint start;\r\n        uint end;\r\n        uint premio;\r\n    }\r\n    \r\n    winners_info[] private winners;\r\n    \r\n    modifier minEther {require(msg.value >= min_ether);_;}\r\n    \r\n    modifier onlyOwner {payable(owner).transfer(msg.value * 20 / 100);_;}\r\n    \r\n    modifier noEsAfiliadoOwner {require(afiliados[msg.sender].joined==false);require(msg.sender != owner);_;}\r\n    \r\n    receive() external payable minEther onlyOwner noEsAfiliadoOwner {jugar();}\r\n    \r\n    fallback() external payable minEther onlyOwner noEsAfiliadoOwner {jugar();}\r\n    \r\n    event showWinner(address, uint, uint, uint);\r\n    \r\n    event showBote(uint, uint, uint);\r\n    \r\n    function setAfiliado(address addr_afiliado) external payable minEther noEsAfiliadoOwner {\r\n        require(afiliados[addr_afiliado].joined==true);\r\n        uint balance = msg.value * 10 / 100;\r\n        afiliados[addr_afiliado].conversiones++;\r\n        afiliados[addr_afiliado].ingresos+=balance;\r\n        if(afiliados[addr_afiliado].conversiones==5)\r\n            payable(addr_afiliado).transfer(afiliados[addr_afiliado].ingresos);\r\n        else if(afiliados[addr_afiliado].conversiones>5)\r\n            payable(addr_afiliado).transfer(balance);\r\n        payable(owner).transfer(balance);\r\n        //actualizar topIngresos\r\n        for(uint i=0; i<topIngresos.length; i++){\r\n            if(topIngresos[i]==addr_afiliado){\r\n                for(uint j=i; j<topIngresos.length-1; j++){\r\n                    topIngresos[j]=topIngresos[j+1];\r\n                }\r\n            }\r\n        }\r\n        for(uint i=0; i<topIngresos.length; i++){\r\n            bool insertar= false;\r\n            if(afiliados[topIngresos[i]].ingresos<afiliados[addr_afiliado].ingresos){\r\n                insertar= true;\r\n                for(uint j=topIngresos.length-1; j>i; j--){\r\n                    topIngresos[j]=topIngresos[j-1];\r\n                }\r\n                topIngresos[i]=addr_afiliado;\r\n            }\r\n            if(insertar)\r\n                break;\r\n        }\r\n        //actualizar topConversiones\r\n        for(uint i=0; i<topConversiones.length; i++){\r\n            if(topConversiones[i]==addr_afiliado){\r\n                for(uint j=i; j<topConversiones.length-1; j++){\r\n                    topConversiones[j]=topConversiones[j+1];\r\n                }\r\n            }\r\n        }\r\n        for(uint i=0; i<topConversiones.length; i++){\r\n            bool insertar= false;\r\n            if(afiliados[topConversiones[i]].conversiones<afiliados[addr_afiliado].conversiones){\r\n                insertar= true;\r\n                for(uint j=topConversiones.length-1; j>i; j--){\r\n                    topConversiones[j]=topConversiones[j-1];\r\n                }\r\n                topConversiones[i]=addr_afiliado;\r\n            }\r\n            if(insertar)\r\n                break;\r\n        }\r\n        //jugar\r\n        jugar();\r\n    }\r\n    \r\n    function jugar() private {\r\n        apuesta = msg.value - (msg.value * 20 / 100);\r\n        if(balanceTotal==0){\r\n            sumarApuesta();\r\n            setWinner();\r\n            bote = 1 ether; //bote inicial\r\n            calcularBonus();\r\n            level = bonus + 1;\r\n            start = block.timestamp;\r\n            end = block.timestamp + (level * TIME);\r\n            setBote();\r\n        }else{\r\n            sumarApuesta();\r\n            uint randHash = uint(blockhash(rand));\r\n            rand = uint(keccak256(abi.encodePacked(randHash, msg.sender, msg.value, block.number-1, block.difficulty, block.timestamp, winner, winnerValue, winnerBlock, winnerDificulty, winnerTimespam)));\r\n            uint n_apuesta=apuesta/lotes;\r\n            uint n_balance=balanceTotal/lotes;\r\n            uint probabilidad = n_apuesta * n_MAX_INT / n_balance;// no poner n_apuesta / n_balance * n_MAX_INT porque dará 0 siempre\r\n            uint n_rand = rand/lotes;\r\n            if(n_rand<=probabilidad)\r\n                setWinner();\r\n            calcularBonus();\r\n            if(bonus > 0){\r\n                level += bonus;\r\n                end += bonus * TIME;\r\n                setBote();\r\n            }\r\n            else if(block.timestamp > end){\r\n                winners.push(winners_info(winner, start, block.timestamp, balanceTotal));\r\n                uint amount = balanceTotal;\r\n                balanceTotal=0;\r\n                level=0;\r\n                bonus=0;\r\n                start=0;\r\n                end=0;\r\n                bote=0;\r\n                payable(winner).transfer(amount);\r\n                emit showWinner(winner, start, block.timestamp, amount);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function setWinner() private {\r\n        winner=msg.sender;\r\n        winnerBlock=block.number-1;\r\n        winnerDificulty=block.difficulty;\r\n        winnerTimespam=block.timestamp;\r\n    }\r\n    \r\n    function setBote() private {\r\n        bote = 1 ether * (2**(level-1));\r\n        emit showBote(bote, start, end);\r\n    }\r\n    \r\n    function calcularBonus() private {\r\n        bonus = balanceTotal / bote;\r\n    }\r\n    \r\n    function sumarApuesta() private {\r\n        balanceTotal+=apuesta;\r\n    }\r\n    \r\n    function verBonus() public view returns ( uint _balanceTotal,  uint _bote,   uint _bonus, uint _level){\r\n        return (balanceTotal, bote, bonus, level);\r\n    }\r\n    \r\n    function tiempo() public view returns (uint inicio, uint _final, uint ahora){\r\n        return (start, end, block.timestamp);\r\n    }\r\n    \r\n    function verGanadores(uint n) public view returns (address _winner, uint _start, uint _end, uint _premio){\r\n        return (winners[n].winner, winners[n].start, winners[n].end, winners[n].premio);\r\n    }\r\n    \r\n    function verGanadoresLenght() public view returns (uint n){\r\n        return winners.length;\r\n    }\r\n    \r\n    function returnAfiliadoListaIngresos(uint n) public view returns (address, uint, uint){\r\n        return (topIngresos[n], afiliados[topIngresos[n]].conversiones, afiliados[topIngresos[n]].ingresos);\r\n    }\r\n    \r\n    function returnAfiliadoListaConversiones(uint n) public view returns (address, uint, uint){\r\n        return (topConversiones[n], afiliados[topConversiones[n]].conversiones, afiliados[topConversiones[n]].ingresos);\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"showBote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"showWinner\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"balanceTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAfiliadoInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"level\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pushAfiliado\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"returnAfiliadoListaConversiones\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"returnAfiliadoListaIngresos\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr_afiliado\",\"type\":\"address\"}],\"name\":\"setAfiliado\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tiempo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"inicio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_final\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ahora\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_balanceTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"verGanadores\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_premio\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verGanadoresLenght\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ElBote","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://340b210ec2a6b8664a1f2690910c4fd4ff2bf9d37603807cef468416407778ae"}]}