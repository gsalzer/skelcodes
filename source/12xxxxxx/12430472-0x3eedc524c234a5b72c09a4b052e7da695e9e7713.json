{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"sources\": {\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"IIntegralERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\nimport 'IERC20.sol';\\n\\ninterface IIntegralERC20 is IERC20 {\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"IReserves.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\ninterface IReserves {\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n    event Fees(uint256 fee0, uint256 fee1);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 lastTimestamp\\n        );\\n\\n    function getReferences()\\n        external\\n        view\\n        returns (\\n            uint112 reference0,\\n            uint112 reference1,\\n            uint32 epoch\\n        );\\n\\n    function getFees() external view returns (uint256 fee0, uint256 fee1);\\n}\\n\"\r\n    },\r\n    \"IIntegralPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\nimport 'IIntegralERC20.sol';\\nimport 'IReserves.sol';\\n\\ninterface IIntegralPair is IIntegralERC20, IReserves {\\n    event Mint(address indexed sender, address indexed to);\\n    event Burn(address indexed sender, address indexed to);\\n    event Swap(address indexed sender, address indexed to);\\n    event SetMintFee(uint256 fee);\\n    event SetBurnFee(uint256 fee);\\n    event SetSwapFee(uint256 fee);\\n    event SetOracle(address account);\\n    event SetTrader(address trader);\\n    event SetToken0AbsoluteLimit(uint256 limit);\\n    event SetToken1AbsoluteLimit(uint256 limit);\\n    event SetToken0RelativeLimit(uint256 limit);\\n    event SetToken1RelativeLimit(uint256 limit);\\n    event SetPriceDeviationLimit(uint256 limit);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function oracle() external view returns (address);\\n\\n    function trader() external view returns (address);\\n\\n    function mintFee() external view returns (uint256);\\n\\n    function setMintFee(uint256 fee) external;\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burnFee() external view returns (uint256);\\n\\n    function setBurnFee(uint256 fee) external;\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swapFee() external view returns (uint256);\\n\\n    function setSwapFee(uint256 fee) external;\\n\\n    function setOracle(address account) external;\\n\\n    function setTrader(address account) external;\\n\\n    function token0AbsoluteLimit() external view returns (uint256);\\n\\n    function setToken0AbsoluteLimit(uint256 limit) external;\\n\\n    function token1AbsoluteLimit() external view returns (uint256);\\n\\n    function setToken1AbsoluteLimit(uint256 limit) external;\\n\\n    function token0RelativeLimit() external view returns (uint256);\\n\\n    function setToken0RelativeLimit(uint256 limit) external;\\n\\n    function token1RelativeLimit() external view returns (uint256);\\n\\n    function setToken1RelativeLimit(uint256 limit) external;\\n\\n    function priceDeviationLimit() external view returns (uint256);\\n\\n    function setPriceDeviationLimit(uint256 limit) external;\\n\\n    function collect(address to) external;\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to\\n    ) external;\\n\\n    function sync() external;\\n\\n    function initialize(\\n        address _token0,\\n        address _token1,\\n        address _oracle,\\n        address _trader\\n    ) external;\\n\\n    function syncWithOracle() external;\\n\\n    function fullSync() external;\\n\\n    function getSpotPrice() external view returns (uint256 spotPrice);\\n\\n    function getSwapAmount0In(uint256 amount1Out) external view returns (uint256 swapAmount0In);\\n\\n    function getSwapAmount1In(uint256 amount0Out) external view returns (uint256 swapAmount1In);\\n\\n    function getSwapAmount0Out(uint256 amount1In) external view returns (uint256 swapAmount0Out);\\n\\n    function getSwapAmount1Out(uint256 amount0In) external view returns (uint256 swapAmount1Out);\\n\\n    function getDepositAmount0In(uint256 amount0) external view returns (uint256 depositAmount0In);\\n\\n    function getDepositAmount1In(uint256 amount1) external view returns (uint256 depositAmount1In);\\n}\\n\"\r\n    },\r\n    \"SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, 'SM_ADD_OVERFLOW');\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = sub(x, y, 'SM_SUB_UNDERFLOW');\\n    }\\n\\n    function sub(\\n        uint256 x,\\n        uint256 y,\\n        string memory message\\n    ) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, message);\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, 'SM_MUL_OVERFLOW');\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, 'SM_DIV_BY_ZERO');\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    function ceil_div(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = div(a, b);\\n        if (c == mul(a, b)) {\\n            return c;\\n        } else {\\n            return add(c, 1);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x > y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"IIntegralFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\ninterface IIntegralFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n    event OwnerSet(address owner);\\n\\n    function owner() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB,\\n        address oracle,\\n        address trader\\n    ) external returns (address pair);\\n\\n    function setOwner(address) external;\\n\\n    function setMintFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setBurnFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setSwapFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setOracle(\\n        address tokenA,\\n        address tokenB,\\n        address oracle\\n    ) external;\\n\\n    function setTrader(\\n        address tokenA,\\n        address tokenB,\\n        address trader\\n    ) external;\\n\\n    function collect(\\n        address tokenA,\\n        address tokenB,\\n        address to\\n    ) external;\\n\\n    function withdraw(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amount,\\n        address to\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity =0.7.5;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{ value: value }(new bytes(0));\\n        require(success, 'TH_ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"TokenShares.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\nimport 'IERC20.sol';\\nimport 'IWETH.sol';\\nimport 'SafeMath.sol';\\nimport 'TransferHelper.sol';\\n\\nlibrary TokenShares {\\n    using SafeMath for uint256;\\n    using TransferHelper for address;\\n\\n    event UnwrapFailed(address to, uint256 amount);\\n\\n    struct Data {\\n        mapping(address => uint256) totalShares;\\n        address weth;\\n    }\\n\\n    function setWeth(Data storage data, address _weth) internal {\\n        data.weth = _weth;\\n    }\\n\\n    function sharesToAmount(\\n        Data storage data,\\n        address token,\\n        uint256 share\\n    ) external returns (uint256) {\\n        if (share == 0) {\\n            return 0;\\n        }\\n        if (token == data.weth) {\\n            return share;\\n        }\\n        require(data.totalShares[token] >= share, 'TS_INSUFFICIENT_BALANCE');\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        uint256 value = balance.mul(share).div(data.totalShares[token]);\\n        data.totalShares[token] = data.totalShares[token].sub(share);\\n        return value;\\n    }\\n\\n    function amountToShares(\\n        Data storage data,\\n        address token,\\n        uint256 amount,\\n        bool wrap\\n    ) external returns (uint256) {\\n        if (amount == 0) {\\n            return 0;\\n        }\\n        if (token == data.weth) {\\n            if (wrap) {\\n                require(msg.value >= amount, 'TS_INSUFFICIENT_AMOUNT');\\n                IWETH(token).deposit{ value: amount }();\\n            } else {\\n                token.safeTransferFrom(msg.sender, address(this), amount);\\n            }\\n            return amount;\\n        } else {\\n            uint256 balanceBefore = IERC20(token).balanceOf(address(this));\\n            require(balanceBefore > 0 || data.totalShares[token] == 0, 'TS_INVALID_SHARES');\\n            if (data.totalShares[token] == 0) {\\n                data.totalShares[token] = balanceBefore;\\n            }\\n            token.safeTransferFrom(msg.sender, address(this), amount);\\n            uint256 balanceAfter = IERC20(token).balanceOf(address(this));\\n            require(balanceAfter > balanceBefore, 'TS_INVALID_TRANSFER');\\n            if (balanceBefore > 0) {\\n                uint256 lastShares = data.totalShares[token];\\n                data.totalShares[token] = lastShares.mul(balanceAfter).div(balanceBefore);\\n                return data.totalShares[token] - lastShares;\\n            } else {\\n                data.totalShares[token] = balanceAfter;\\n                data.totalShares[token] = balanceAfter;\\n                return balanceAfter;\\n            }\\n        }\\n    }\\n\\n    function onUnwrapFailed(\\n        Data storage data,\\n        address to,\\n        uint256 amount\\n    ) external {\\n        emit UnwrapFailed(to, amount);\\n        IWETH(data.weth).deposit{ value: amount }();\\n        TransferHelper.safeTransfer(data.weth, to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"Orders.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport 'SafeMath.sol';\\nimport 'Math.sol';\\nimport 'IIntegralFactory.sol';\\nimport 'IIntegralPair.sol';\\nimport 'TokenShares.sol';\\n\\nlibrary Orders {\\n    using SafeMath for uint256;\\n    using TokenShares for TokenShares.Data;\\n    using TransferHelper for address;\\n\\n    enum OrderType { Empty, Deposit, Withdraw, Sell, Buy }\\n    enum OrderStatus { NonExistent, EnqueuedWaiting, EnqueuedReady, ExecutedSucceeded, ExecutedFailed, Canceled }\\n\\n    event MaxGasLimitSet(uint256 maxGasLimit);\\n    event GasPriceInertiaSet(uint256 gasPriceInertia);\\n    event MaxGasPriceImpactSet(uint256 maxGasPriceImpact);\\n    event TransferGasCostSet(address token, uint256 gasCost);\\n\\n    event DepositEnqueued(uint256 indexed orderId, uint128 validAfterTimestamp, uint256 gasPrice);\\n    event WithdrawEnqueued(uint256 indexed orderId, uint128 validAfterTimestamp, uint256 gasPrice);\\n    event SellEnqueued(uint256 indexed orderId, uint128 validAfterTimestamp, uint256 gasPrice);\\n    event BuyEnqueued(uint256 indexed orderId, uint128 validAfterTimestamp, uint256 gasPrice);\\n\\n    uint8 private constant DEPOSIT_TYPE = 1;\\n    uint8 private constant WITHDRAW_TYPE = 2;\\n    uint8 private constant BUY_TYPE = 3;\\n    uint8 private constant BUY_INVERTED_TYPE = 4;\\n    uint8 private constant SELL_TYPE = 5;\\n    uint8 private constant SELL_INVERTED_TYPE = 6;\\n\\n    uint8 private constant UNWRAP_NOT_FAILED = 0;\\n    uint8 private constant KEEP_NOT_FAILED = 1;\\n    uint8 private constant UNWRAP_FAILED = 2;\\n    uint8 private constant KEEP_FAILED = 3;\\n\\n    uint256 private constant ETHER_TRANSFER_COST = 2300;\\n    uint256 private constant BUFFER_COST = 10000;\\n    uint256 private constant EXECUTE_PREPARATION_COST = 55000; // dequeue + getPair in execute\\n\\n    uint256 public constant ETHER_TRANSFER_CALL_COST = 10000;\\n    uint256 public constant PAIR_TRANSFER_COST = 55000;\\n    uint256 public constant REFUND_END_COST = 2 * ETHER_TRANSFER_COST + BUFFER_COST;\\n    uint256 public constant ORDER_BASE_COST = EXECUTE_PREPARATION_COST + REFUND_END_COST;\\n\\n    uint256 private constant TIMESTAMP_OFFSET = 1609455600; // 2021 Jan 1\\n\\n    struct PairInfo {\\n        address pair;\\n        address token0;\\n        address token1;\\n    }\\n\\n    struct Data {\\n        uint256 delay;\\n        uint256 newestOrderId;\\n        uint256 lastProcessedOrderId;\\n        mapping(uint256 => StoredOrder) orderQueue;\\n        address factory;\\n        uint256 maxGasLimit;\\n        uint256 gasPrice;\\n        uint256 gasPriceInertia;\\n        uint256 maxGasPriceImpact;\\n        mapping(uint32 => PairInfo) pairs;\\n        mapping(address => uint256) transferGasCosts;\\n        mapping(uint256 => bool) canceled;\\n        mapping(address => bool) depositDisabled;\\n        mapping(address => bool) withdrawDisabled;\\n        mapping(address => bool) buyDisabled;\\n        mapping(address => bool) sellDisabled;\\n    }\\n\\n    struct StoredOrder {\\n        // slot 1\\n        uint8 orderType;\\n        uint32 validAfterTimestamp;\\n        uint8 unwrapAndFailure;\\n        uint32 deadline;\\n        uint32 gasLimit;\\n        uint32 gasPrice;\\n        uint112 liquidityOrRatio;\\n        // slot 1\\n        uint112 value0;\\n        uint112 value1;\\n        uint32 pairId;\\n        // slot2\\n        address to;\\n        uint32 minRatioChangeToSwap;\\n        uint32 minSwapPrice;\\n        uint32 maxSwapPrice;\\n    }\\n\\n    struct DepositOrder {\\n        uint32 pairId;\\n        uint256 share0;\\n        uint256 share1;\\n        uint256 initialRatio;\\n        uint256 minRatioChangeToSwap;\\n        uint256 minSwapPrice;\\n        uint256 maxSwapPrice;\\n        bool unwrap;\\n        address to;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        uint256 deadline;\\n    }\\n\\n    struct WithdrawOrder {\\n        uint32 pairId;\\n        uint256 liquidity;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        bool unwrap;\\n        address to;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        uint256 deadline;\\n    }\\n\\n    struct SellOrder {\\n        uint32 pairId;\\n        bool inverse;\\n        uint256 shareIn;\\n        uint256 amountOutMin;\\n        bool unwrap;\\n        address to;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        uint256 deadline;\\n    }\\n\\n    struct BuyOrder {\\n        uint32 pairId;\\n        bool inverse;\\n        uint256 shareInMax;\\n        uint256 amountOut;\\n        bool unwrap;\\n        address to;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        uint256 deadline;\\n    }\\n\\n    function decodeType(uint256 internalType) internal pure returns (OrderType orderType) {\\n        if (internalType == DEPOSIT_TYPE) {\\n            orderType = OrderType.Deposit;\\n        } else if (internalType == WITHDRAW_TYPE) {\\n            orderType = OrderType.Withdraw;\\n        } else if (internalType == BUY_TYPE) {\\n            orderType = OrderType.Buy;\\n        } else if (internalType == BUY_INVERTED_TYPE) {\\n            orderType = OrderType.Buy;\\n        } else if (internalType == SELL_TYPE) {\\n            orderType = OrderType.Sell;\\n        } else if (internalType == SELL_INVERTED_TYPE) {\\n            orderType = OrderType.Sell;\\n        } else {\\n            orderType = OrderType.Empty;\\n        }\\n    }\\n\\n    function getOrder(Data storage data, uint256 orderId)\\n        public\\n        view\\n        returns (OrderType orderType, uint256 validAfterTimestamp)\\n    {\\n        StoredOrder storage order = data.orderQueue[orderId];\\n        uint8 internalType = order.orderType;\\n        validAfterTimestamp = uint32ToTimestamp(order.validAfterTimestamp);\\n        orderType = decodeType(internalType);\\n    }\\n\\n    function getOrderStatus(Data storage data, uint256 orderId) external view returns (OrderStatus orderStatus) {\\n        if (orderId > data.newestOrderId) {\\n            return OrderStatus.NonExistent;\\n        }\\n        if (data.canceled[orderId]) {\\n            return OrderStatus.Canceled;\\n        }\\n        if (isRefundFailed(data, orderId)) {\\n            return OrderStatus.ExecutedFailed;\\n        }\\n        (OrderType orderType, uint256 validAfterTimestamp) = getOrder(data, orderId);\\n        if (orderType == OrderType.Empty) {\\n            return OrderStatus.ExecutedSucceeded;\\n        }\\n        if (validAfterTimestamp >= block.timestamp) {\\n            return OrderStatus.EnqueuedWaiting;\\n        }\\n        return OrderStatus.EnqueuedReady;\\n    }\\n\\n    function getPair(\\n        Data storage data,\\n        address tokenA,\\n        address tokenB\\n    )\\n        internal\\n        returns (\\n            address pair,\\n            uint32 pairId,\\n            bool inverted\\n        )\\n    {\\n        inverted = tokenA > tokenB;\\n        (address token0, address token1) = inverted ? (tokenB, tokenA) : (tokenA, tokenB);\\n        pair = IIntegralFactory(data.factory).getPair(token0, token1);\\n        pairId = uint32(bytes4(keccak256(abi.encodePacked((pair)))));\\n        require(pair != address(0), 'OS_PAIR_NONEXISTENT');\\n        if (data.pairs[pairId].pair == address(0)) {\\n            data.pairs[pairId] = PairInfo(pair, token0, token1);\\n        }\\n    }\\n\\n    function getPairInfo(Data storage data, uint32 pairId)\\n        external\\n        view\\n        returns (\\n            address pair,\\n            address token0,\\n            address token1\\n        )\\n    {\\n        PairInfo storage info = data.pairs[pairId];\\n        pair = info.pair;\\n        token0 = info.token0;\\n        token1 = info.token1;\\n    }\\n\\n    function getDepositOrder(Data storage data, uint256 index) public view returns (DepositOrder memory order) {\\n        StoredOrder memory stored = data.orderQueue[index];\\n        require(stored.orderType == DEPOSIT_TYPE, 'OS_INVALID_ORDER_TYPE');\\n        order.pairId = stored.pairId;\\n        order.share0 = stored.value0;\\n        order.share1 = stored.value1;\\n        order.initialRatio = stored.liquidityOrRatio;\\n        order.minRatioChangeToSwap = stored.minRatioChangeToSwap;\\n        order.minSwapPrice = float32ToUint(stored.minSwapPrice);\\n        order.maxSwapPrice = float32ToUint(stored.maxSwapPrice);\\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\\n        order.to = stored.to;\\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\\n        order.gasLimit = stored.gasLimit;\\n        order.deadline = uint32ToTimestamp(stored.deadline);\\n    }\\n\\n    function getWithdrawOrder(Data storage data, uint256 index) public view returns (WithdrawOrder memory order) {\\n        StoredOrder memory stored = data.orderQueue[index];\\n        require(stored.orderType == WITHDRAW_TYPE, 'OS_INVALID_ORDER_TYPE');\\n        order.pairId = stored.pairId;\\n        order.liquidity = stored.liquidityOrRatio;\\n        order.amount0Min = stored.value0;\\n        order.amount1Min = stored.value1;\\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\\n        order.to = stored.to;\\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\\n        order.gasLimit = stored.gasLimit;\\n        order.deadline = uint32ToTimestamp(stored.deadline);\\n    }\\n\\n    function getSellOrder(Data storage data, uint256 index) public view returns (SellOrder memory order) {\\n        StoredOrder memory stored = data.orderQueue[index];\\n        require(stored.orderType == SELL_TYPE || stored.orderType == SELL_INVERTED_TYPE, 'OS_INVALID_ORDER_TYPE');\\n        order.pairId = stored.pairId;\\n        order.inverse = stored.orderType == SELL_INVERTED_TYPE;\\n        order.shareIn = stored.value0;\\n        order.amountOutMin = stored.value1;\\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\\n        order.to = stored.to;\\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\\n        order.gasLimit = stored.gasLimit;\\n        order.deadline = uint32ToTimestamp(stored.deadline);\\n    }\\n\\n    function getBuyOrder(Data storage data, uint256 index) public view returns (BuyOrder memory order) {\\n        StoredOrder memory stored = data.orderQueue[index];\\n        require(stored.orderType == BUY_TYPE || stored.orderType == BUY_INVERTED_TYPE, 'OS_INVALID_ORDER_TYPE');\\n        order.pairId = stored.pairId;\\n        order.inverse = stored.orderType == BUY_INVERTED_TYPE;\\n        order.shareInMax = stored.value0;\\n        order.amountOut = stored.value1;\\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\\n        order.to = stored.to;\\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\\n        order.gasLimit = stored.gasLimit;\\n        order.deadline = uint32ToTimestamp(stored.deadline);\\n    }\\n\\n    function getFailedOrderType(Data storage data, uint256 orderId)\\n        external\\n        view\\n        returns (OrderType orderType, uint256 validAfterTimestamp)\\n    {\\n        require(isRefundFailed(data, orderId), 'OS_NO_POSSIBLE_REFUND');\\n        (orderType, validAfterTimestamp) = getOrder(data, orderId);\\n    }\\n\\n    function getUnwrap(uint8 unwrapAndFailure) private pure returns (bool) {\\n        return unwrapAndFailure == UNWRAP_FAILED || unwrapAndFailure == UNWRAP_NOT_FAILED;\\n    }\\n\\n    function getUnwrapAndFailure(bool unwrap) private pure returns (uint8) {\\n        return unwrap ? UNWRAP_NOT_FAILED : KEEP_NOT_FAILED;\\n    }\\n\\n    function timestampToUint32(uint256 timestamp) private pure returns (uint32 timestamp32) {\\n        if (timestamp == uint256(-1)) {\\n            return uint32(-1);\\n        }\\n        timestamp32 = uintToUint32(timestamp.sub(TIMESTAMP_OFFSET));\\n    }\\n\\n    function uint32ToTimestamp(uint32 timestamp32) private pure returns (uint256 timestamp) {\\n        if (timestamp32 == uint32(-1)) {\\n            return uint256(-1);\\n        }\\n        if (timestamp32 == 0) {\\n            return 0;\\n        }\\n        timestamp = uint256(timestamp32) + TIMESTAMP_OFFSET;\\n    }\\n\\n    function gasPriceToUint32(uint256 gasPrice) private pure returns (uint32 gasPrice32) {\\n        require((gasPrice / 1e6) * 1e6 == gasPrice, 'OS_GAS_PRICE_PRECISION');\\n        gasPrice32 = uintToUint32(gasPrice / 1e6);\\n    }\\n\\n    function uint32ToGasPrice(uint32 gasPrice32) public pure returns (uint256 gasPrice) {\\n        gasPrice = uint256(gasPrice32) * 1e6;\\n    }\\n\\n    function uintToUint32(uint256 number) private pure returns (uint32 number32) {\\n        number32 = uint32(number);\\n        require(uint256(number32) == number, 'OS_OVERFLOW_32');\\n    }\\n\\n    function uintToUint112(uint256 number) private pure returns (uint112 number112) {\\n        number112 = uint112(number);\\n        require(uint256(number112) == number, 'OS_OVERFLOW_112');\\n    }\\n\\n    function uintToFloat32(uint256 number) internal pure returns (uint32 float32) {\\n        // Number is encoded on 4 bytes. 3 bytes for mantissa and 1 for exponent.\\n        // If the number fits in the mantissa we set the exponent to zero and return.\\n        if (number < 2 << 24) {\\n            return uint32(number << 8);\\n        }\\n        // We find the exponent by counting the number of trailing zeroes.\\n        // Simultaneously we remove those zeroes from the number.\\n        uint32 exponent;\\n        for (exponent = 0; exponent < 256 - 24; exponent++) {\\n            // Last bit is one.\\n            if (number & 1 == 1) {\\n                break;\\n            }\\n            number = number >> 1;\\n        }\\n        // The number must fit in the mantissa.\\n        require(number < 2 << 24, 'OS_OVERFLOW_FLOAT_ENCODE');\\n        // Set the first three bytes to the number and the fourth to the exponent.\\n        float32 = uint32(number << 8) | exponent;\\n    }\\n\\n    function float32ToUint(uint32 float32) internal pure returns (uint256 number) {\\n        // Number is encoded on 4 bytes. 3 bytes for mantissa and 1 for exponent.\\n        // We get the exponent by extracting the last byte.\\n        uint256 exponent = float32 & 0xFF;\\n        // Sanity check. Only triggered for values not encoded with uintToFloat32.\\n        require(exponent <= 256 - 24, 'OS_OVERFLOW_FLOAT_DECODE');\\n        // We get the mantissa by extracting the first three bytes and removing the fourth.\\n        uint256 mantissa = (float32 & 0xFFFFFF00) >> 8;\\n        // We add exponent number zeroes after the mantissa.\\n        number = mantissa << exponent;\\n    }\\n\\n    function enqueueDepositOrder(Data storage data, DepositOrder memory depositOrder) internal {\\n        data.newestOrderId++;\\n        uint128 validAfterTimestamp = uint128(block.timestamp + data.delay);\\n        emit DepositEnqueued(data.newestOrderId, validAfterTimestamp, depositOrder.gasPrice);\\n        data.orderQueue[data.newestOrderId] = StoredOrder(\\n            DEPOSIT_TYPE,\\n            timestampToUint32(validAfterTimestamp),\\n            getUnwrapAndFailure(depositOrder.unwrap),\\n            timestampToUint32(depositOrder.deadline),\\n            uintToUint32(depositOrder.gasLimit),\\n            gasPriceToUint32(depositOrder.gasPrice),\\n            uintToUint112(depositOrder.initialRatio),\\n            uintToUint112(depositOrder.share0),\\n            uintToUint112(depositOrder.share1),\\n            depositOrder.pairId,\\n            depositOrder.to,\\n            uint32(depositOrder.minRatioChangeToSwap),\\n            uintToFloat32(depositOrder.minSwapPrice),\\n            uintToFloat32(depositOrder.maxSwapPrice)\\n        );\\n    }\\n\\n    function enqueueWithdrawOrder(Data storage data, WithdrawOrder memory withdrawOrder) internal {\\n        data.newestOrderId++;\\n        uint128 validAfterTimestamp = uint128(block.timestamp + data.delay);\\n        emit WithdrawEnqueued(data.newestOrderId, validAfterTimestamp, withdrawOrder.gasPrice);\\n        data.orderQueue[data.newestOrderId] = StoredOrder(\\n            WITHDRAW_TYPE,\\n            timestampToUint32(validAfterTimestamp),\\n            getUnwrapAndFailure(withdrawOrder.unwrap),\\n            timestampToUint32(withdrawOrder.deadline),\\n            uintToUint32(withdrawOrder.gasLimit),\\n            gasPriceToUint32(withdrawOrder.gasPrice),\\n            uintToUint112(withdrawOrder.liquidity),\\n            uintToUint112(withdrawOrder.amount0Min),\\n            uintToUint112(withdrawOrder.amount1Min),\\n            withdrawOrder.pairId,\\n            withdrawOrder.to,\\n            0, // maxRatioChange\\n            0, // minSwapPrice\\n            0 // maxSwapPrice\\n        );\\n    }\\n\\n    function enqueueSellOrder(Data storage data, SellOrder memory sellOrder) internal {\\n        data.newestOrderId++;\\n        uint128 validAfterTimestamp = uint128(block.timestamp + data.delay);\\n        emit SellEnqueued(data.newestOrderId, validAfterTimestamp, sellOrder.gasPrice);\\n        data.orderQueue[data.newestOrderId] = StoredOrder(\\n            sellOrder.inverse ? SELL_INVERTED_TYPE : SELL_TYPE,\\n            timestampToUint32(validAfterTimestamp),\\n            getUnwrapAndFailure(sellOrder.unwrap),\\n            timestampToUint32(sellOrder.deadline),\\n            uintToUint32(sellOrder.gasLimit),\\n            gasPriceToUint32(sellOrder.gasPrice),\\n            0, // liquidityOrRatio\\n            uintToUint112(sellOrder.shareIn),\\n            uintToUint112(sellOrder.amountOutMin),\\n            sellOrder.pairId,\\n            sellOrder.to,\\n            0, // maxRatioChange\\n            0, // minSwapPrice\\n            0 // maxSwapPrice\\n        );\\n    }\\n\\n    function enqueueBuyOrder(Data storage data, BuyOrder memory buyOrder) internal {\\n        data.newestOrderId++;\\n        uint128 validAfterTimestamp = uint128(block.timestamp + data.delay);\\n        emit BuyEnqueued(data.newestOrderId, validAfterTimestamp, buyOrder.gasPrice);\\n        data.orderQueue[data.newestOrderId] = StoredOrder(\\n            buyOrder.inverse ? BUY_INVERTED_TYPE : BUY_TYPE,\\n            timestampToUint32(validAfterTimestamp),\\n            getUnwrapAndFailure(buyOrder.unwrap),\\n            timestampToUint32(buyOrder.deadline),\\n            uintToUint32(buyOrder.gasLimit),\\n            gasPriceToUint32(buyOrder.gasPrice),\\n            0, // liquidityOrRatio\\n            uintToUint112(buyOrder.shareInMax),\\n            uintToUint112(buyOrder.amountOut),\\n            buyOrder.pairId,\\n            buyOrder.to,\\n            0, // maxRatioChange\\n            0, // minSwapPrice\\n            0 // maxSwapPrice\\n        );\\n    }\\n\\n    function isRefundFailed(Data storage data, uint256 index) internal view returns (bool) {\\n        uint8 unwrapAndFailure = data.orderQueue[index].unwrapAndFailure;\\n        return unwrapAndFailure == UNWRAP_FAILED || unwrapAndFailure == KEEP_FAILED;\\n    }\\n\\n    function markRefundFailed(Data storage data) internal {\\n        StoredOrder storage stored = data.orderQueue[data.lastProcessedOrderId];\\n        stored.unwrapAndFailure = stored.unwrapAndFailure == UNWRAP_NOT_FAILED ? UNWRAP_FAILED : KEEP_FAILED;\\n    }\\n\\n    function getNextOrder(Data storage data) internal view returns (OrderType orderType, uint256 validAfterTimestamp) {\\n        return getOrder(data, data.lastProcessedOrderId + 1);\\n    }\\n\\n    function dequeueCanceledOrder(Data storage data) external {\\n        data.lastProcessedOrderId++;\\n    }\\n\\n    function dequeueDepositOrder(Data storage data) external returns (DepositOrder memory order) {\\n        data.lastProcessedOrderId++;\\n        order = getDepositOrder(data, data.lastProcessedOrderId);\\n    }\\n\\n    function dequeueWithdrawOrder(Data storage data) external returns (WithdrawOrder memory order) {\\n        data.lastProcessedOrderId++;\\n        order = getWithdrawOrder(data, data.lastProcessedOrderId);\\n    }\\n\\n    function dequeueSellOrder(Data storage data) external returns (SellOrder memory order) {\\n        data.lastProcessedOrderId++;\\n        order = getSellOrder(data, data.lastProcessedOrderId);\\n    }\\n\\n    function dequeueBuyOrder(Data storage data) external returns (BuyOrder memory order) {\\n        data.lastProcessedOrderId++;\\n        order = getBuyOrder(data, data.lastProcessedOrderId);\\n    }\\n\\n    function forgetOrder(Data storage data, uint256 orderId) internal {\\n        delete data.orderQueue[orderId];\\n    }\\n\\n    function forgetLastProcessedOrder(Data storage data) internal {\\n        delete data.orderQueue[data.lastProcessedOrderId];\\n    }\\n\\n    struct DepositParams {\\n        address token0;\\n        address token1;\\n        uint256 amount0;\\n        uint256 amount1;\\n        uint256 initialRatio;\\n        uint256 minRatioChangeToSwap;\\n        uint256 minSwapPrice;\\n        uint256 maxSwapPrice;\\n        bool wrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint256 submitDeadline;\\n        uint256 executionDeadline;\\n    }\\n\\n    function deposit(\\n        Data storage data,\\n        DepositParams calldata depositParams,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        require(\\n            data.transferGasCosts[depositParams.token0] != 0 && data.transferGasCosts[depositParams.token1] != 0,\\n            'OS_TOKEN_TRANSFER_GAS_COST_UNSET'\\n        );\\n        checkOrderParams(\\n            data,\\n            depositParams.to,\\n            depositParams.gasLimit,\\n            depositParams.submitDeadline,\\n            depositParams.executionDeadline,\\n            ORDER_BASE_COST.add(data.transferGasCosts[depositParams.token0]).add(\\n                data.transferGasCosts[depositParams.token1]\\n            )\\n        );\\n        require(depositParams.amount0 != 0 || depositParams.amount1 != 0, 'OS_NO_AMOUNT');\\n        (address pair, uint32 pairId, bool inverted) = getPair(data, depositParams.token0, depositParams.token1);\\n        require(!data.depositDisabled[pair], 'OS_DEPOSIT_DISABLED');\\n\\n        uint256 value = msg.value;\\n\\n        // allocate gas refund\\n        if (depositParams.token0 == tokenShares.weth && depositParams.wrap) {\\n            value = value.sub(depositParams.amount0, 'OS_NOT_ENOUGH_FUNDS');\\n        } else if (depositParams.token1 == tokenShares.weth && depositParams.wrap) {\\n            value = value.sub(depositParams.amount1, 'OS_NOT_ENOUGH_FUNDS');\\n        }\\n        allocateGasRefund(data, value, depositParams.gasLimit);\\n\\n        uint256 shares0 = tokenShares.amountToShares(depositParams.token0, depositParams.amount0, depositParams.wrap);\\n        uint256 shares1 = tokenShares.amountToShares(depositParams.token1, depositParams.amount1, depositParams.wrap);\\n\\n        IIntegralPair(pair).syncWithOracle();\\n        enqueueDepositOrder(\\n            data,\\n            DepositOrder(\\n                pairId,\\n                inverted ? shares1 : shares0,\\n                inverted ? shares0 : shares1,\\n                depositParams.initialRatio,\\n                depositParams.minRatioChangeToSwap,\\n                depositParams.minSwapPrice,\\n                depositParams.maxSwapPrice,\\n                depositParams.wrap,\\n                depositParams.to,\\n                data.gasPrice,\\n                depositParams.gasLimit,\\n                depositParams.executionDeadline\\n            )\\n        );\\n    }\\n\\n    struct WithdrawParams {\\n        address token0;\\n        address token1;\\n        uint256 liquidity;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        bool unwrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint256 submitDeadline;\\n        uint256 executionDeadline;\\n    }\\n\\n    function withdraw(Data storage data, WithdrawParams calldata withdrawParams) external {\\n        (address pair, uint32 pairId, bool inverted) = getPair(data, withdrawParams.token0, withdrawParams.token1);\\n        require(!data.withdrawDisabled[pair], 'OS_WITHDRAW_DISABLED');\\n        checkOrderParams(\\n            data,\\n            withdrawParams.to,\\n            withdrawParams.gasLimit,\\n            withdrawParams.submitDeadline,\\n            withdrawParams.executionDeadline,\\n            ORDER_BASE_COST.add(PAIR_TRANSFER_COST)\\n        );\\n        require(withdrawParams.liquidity != 0, 'OS_NO_LIQUIDITY');\\n\\n        allocateGasRefund(data, msg.value, withdrawParams.gasLimit);\\n        pair.safeTransferFrom(msg.sender, address(this), withdrawParams.liquidity);\\n\\n        IIntegralPair(pair).syncWithOracle();\\n        enqueueWithdrawOrder(\\n            data,\\n            WithdrawOrder(\\n                pairId,\\n                withdrawParams.liquidity,\\n                inverted ? withdrawParams.amount1Min : withdrawParams.amount0Min,\\n                inverted ? withdrawParams.amount0Min : withdrawParams.amount1Min,\\n                withdrawParams.unwrap,\\n                withdrawParams.to,\\n                data.gasPrice,\\n                withdrawParams.gasLimit,\\n                withdrawParams.executionDeadline\\n            )\\n        );\\n    }\\n\\n    struct SellParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountIn;\\n        uint256 amountOutMin;\\n        bool wrapUnwrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint256 submitDeadline;\\n        uint256 executionDeadline;\\n    }\\n\\n    function sell(\\n        Data storage data,\\n        SellParams calldata sellParams,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        require(data.transferGasCosts[sellParams.tokenIn] != 0, 'OS_TOKEN_TRANSFER_GAS_COST_UNSET');\\n        checkOrderParams(\\n            data,\\n            sellParams.to,\\n            sellParams.gasLimit,\\n            sellParams.submitDeadline,\\n            sellParams.executionDeadline,\\n            ORDER_BASE_COST.add(data.transferGasCosts[sellParams.tokenIn])\\n        );\\n        require(sellParams.amountIn != 0, 'OS_NO_AMOUNT_IN');\\n        (address pair, uint32 pairId, bool inverted) = getPair(data, sellParams.tokenIn, sellParams.tokenOut);\\n        require(!data.sellDisabled[pair], 'OS_SELL_DISABLED');\\n        uint256 value = msg.value;\\n\\n        // allocate gas refund\\n        if (sellParams.tokenIn == tokenShares.weth && sellParams.wrapUnwrap) {\\n            value = value.sub(sellParams.amountIn, 'OS_NOT_ENOUGH_FUNDS');\\n        }\\n        allocateGasRefund(data, value, sellParams.gasLimit);\\n\\n        uint256 shares = tokenShares.amountToShares(sellParams.tokenIn, sellParams.amountIn, sellParams.wrapUnwrap);\\n\\n        IIntegralPair(pair).syncWithOracle();\\n        enqueueSellOrder(\\n            data,\\n            SellOrder(\\n                pairId,\\n                inverted,\\n                shares,\\n                sellParams.amountOutMin,\\n                sellParams.wrapUnwrap,\\n                sellParams.to,\\n                data.gasPrice,\\n                sellParams.gasLimit,\\n                sellParams.executionDeadline\\n            )\\n        );\\n    }\\n\\n    struct BuyParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountInMax;\\n        uint256 amountOut;\\n        bool wrapUnwrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint256 submitDeadline;\\n        uint256 executionDeadline;\\n    }\\n\\n    function buy(\\n        Data storage data,\\n        BuyParams calldata buyParams,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        require(data.transferGasCosts[buyParams.tokenIn] != 0, 'OS_TOKEN_TRANSFER_GAS_COST_UNSET');\\n        checkOrderParams(\\n            data,\\n            buyParams.to,\\n            buyParams.gasLimit,\\n            buyParams.submitDeadline,\\n            buyParams.executionDeadline,\\n            ORDER_BASE_COST.add(data.transferGasCosts[buyParams.tokenIn])\\n        );\\n        require(buyParams.amountOut != 0, 'OS_NO_AMOUNT_OUT');\\n        (address pair, uint32 pairId, bool inverted) = getPair(data, buyParams.tokenIn, buyParams.tokenOut);\\n        require(!data.buyDisabled[pair], 'OS_BUY_DISABLED');\\n\\n        uint256 value = msg.value;\\n\\n        // allocate gas refund\\n        if (buyParams.tokenIn == tokenShares.weth && buyParams.wrapUnwrap) {\\n            value = value.sub(buyParams.amountInMax, 'OS_NOT_ENOUGH_FUNDS');\\n        }\\n        allocateGasRefund(data, value, buyParams.gasLimit);\\n\\n        uint256 shares = tokenShares.amountToShares(buyParams.tokenIn, buyParams.amountInMax, buyParams.wrapUnwrap);\\n\\n        IIntegralPair(pair).syncWithOracle();\\n        enqueueBuyOrder(\\n            data,\\n            BuyOrder(\\n                pairId,\\n                inverted,\\n                shares,\\n                buyParams.amountOut,\\n                buyParams.wrapUnwrap,\\n                buyParams.to,\\n                data.gasPrice,\\n                buyParams.gasLimit,\\n                buyParams.executionDeadline\\n            )\\n        );\\n    }\\n\\n    function checkOrderParams(\\n        Data storage data,\\n        address to,\\n        uint256 gasLimit,\\n        uint256 submitDeadline,\\n        uint256 executionDeadline,\\n        uint256 minGasLimit\\n    ) private view {\\n        require(submitDeadline >= block.timestamp, 'OS_EXPIRED');\\n        require(executionDeadline > block.timestamp.add(data.delay), 'OS_INVALID_DEADLINE');\\n        require(gasLimit <= data.maxGasLimit, 'OS_GAS_LIMIT_TOO_HIGH');\\n        require(gasLimit >= minGasLimit, 'OS_GAS_LIMIT_TOO_LOW');\\n        require(to != address(0), 'OS_NO_ADDRESS');\\n    }\\n\\n    function allocateGasRefund(\\n        Data storage data,\\n        uint256 value,\\n        uint256 gasLimit\\n    ) private returns (uint256 futureFee) {\\n        futureFee = data.gasPrice.mul(gasLimit);\\n        require(value >= futureFee, 'OS_NOT_ENOUGH_FUNDS');\\n        if (value > futureFee) {\\n            msg.sender.transfer(value.sub(futureFee));\\n        }\\n    }\\n\\n    function updateGasPrice(Data storage data, uint256 gasUsed) external {\\n        uint256 scale = Math.min(gasUsed, data.maxGasPriceImpact);\\n        uint256 updated = data.gasPrice.mul(data.gasPriceInertia.sub(scale)).add(tx.gasprice.mul(scale)).div(\\n            data.gasPriceInertia\\n        );\\n        // we lower the precision for gas savings in order queue\\n        data.gasPrice = updated - (updated % 1e6);\\n    }\\n\\n    function setMaxGasLimit(Data storage data, uint256 _maxGasLimit) external {\\n        require(_maxGasLimit <= 10000000, 'OS_MAX_GAS_LIMIT_TOO_HIGH');\\n        data.maxGasLimit = _maxGasLimit;\\n        emit MaxGasLimitSet(_maxGasLimit);\\n    }\\n\\n    function setGasPriceInertia(Data storage data, uint256 _gasPriceInertia) external {\\n        require(_gasPriceInertia >= 1, 'OS_INVALID_INERTIA');\\n        data.gasPriceInertia = _gasPriceInertia;\\n        emit GasPriceInertiaSet(_gasPriceInertia);\\n    }\\n\\n    function setMaxGasPriceImpact(Data storage data, uint256 _maxGasPriceImpact) external {\\n        require(_maxGasPriceImpact <= data.gasPriceInertia, 'OS_INVALID_MAX_GAS_PRICE_IMPACT');\\n        data.maxGasPriceImpact = _maxGasPriceImpact;\\n        emit MaxGasPriceImpactSet(_maxGasPriceImpact);\\n    }\\n\\n    function setTransferGasCost(\\n        Data storage data,\\n        address token,\\n        uint256 gasCost\\n    ) external {\\n        data.transferGasCosts[token] = gasCost;\\n        emit TransferGasCostSet(token, gasCost);\\n    }\\n}\\n\"\r\n    },\r\n    \"IIntegralDelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport 'Orders.sol';\\n\\ninterface IIntegralDelay {\\n    event OrderExecuted(uint256 indexed id, bool indexed success, bytes data, uint256 gasSpent, uint256 ethRefunded);\\n    event RefundFailed(address indexed to, address indexed token, uint256 amount, bytes data);\\n    event EthRefund(address indexed to, bool indexed success, uint256 value);\\n    event OwnerSet(address owner);\\n    event BotSet(address bot, bool isBot);\\n    event DelaySet(uint256 delay);\\n    event MaxGasLimitSet(uint256 maxGasLimit);\\n    event GasPriceInertiaSet(uint256 gasPriceInertia);\\n    event MaxGasPriceImpactSet(uint256 maxGasPriceImpact);\\n    event TransferGasCostSet(address token, uint256 gasCost);\\n    event OrderDisabled(address pair, Orders.OrderType orderType, bool disabled);\\n    event UnwrapFailed(address to, uint256 amount);\\n    event Execute(address sender, uint256 n);\\n\\n    function factory() external returns (address);\\n\\n    function owner() external returns (address);\\n\\n    function isBot(address bot) external returns (bool);\\n\\n    function botExecuteTime() external returns (uint256);\\n\\n    function gasPriceInertia() external returns (uint256);\\n\\n    function gasPrice() external returns (uint256);\\n\\n    function maxGasPriceImpact() external returns (uint256);\\n\\n    function maxGasLimit() external returns (uint256);\\n\\n    function delay() external returns (uint256);\\n\\n    function totalShares(address token) external returns (uint256);\\n\\n    function weth() external returns (address);\\n\\n    function getTransferGasCost(address token) external returns (uint256);\\n\\n    function getDepositOrder(uint256 orderId) external returns (Orders.DepositOrder memory order);\\n\\n    function getWithdrawOrder(uint256 orderId) external returns (Orders.WithdrawOrder memory order);\\n\\n    function getSellOrder(uint256 orderId) external returns (Orders.SellOrder memory order);\\n\\n    function getBuyOrder(uint256 orderId) external returns (Orders.BuyOrder memory order);\\n\\n    function getDepositDisabled(address pair) external returns (bool);\\n\\n    function getWithdrawDisabled(address pair) external returns (bool);\\n\\n    function getBuyDisabled(address pair) external returns (bool);\\n\\n    function getSellDisabled(address pair) external returns (bool);\\n\\n    function getOrderStatus(uint256 orderId) external returns (Orders.OrderStatus);\\n\\n    function setOrderDisabled(\\n        address pair,\\n        Orders.OrderType orderType,\\n        bool disabled\\n    ) external;\\n\\n    function setOwner(address _owner) external;\\n\\n    function setBot(address _bot, bool _isBot) external;\\n\\n    function setMaxGasLimit(uint256 _maxGasLimit) external;\\n\\n    function setDelay(uint256 _delay) external;\\n\\n    function setGasPriceInertia(uint256 _gasPriceInertia) external;\\n\\n    function setMaxGasPriceImpact(uint256 _maxGasPriceImpact) external;\\n\\n    function setTransferGasCost(address token, uint256 gasCost) external;\\n\\n    function deposit(Orders.DepositParams memory depositParams) external payable returns (uint256 orderId);\\n\\n    function withdraw(Orders.WithdrawParams memory withdrawParams) external payable returns (uint256 orderId);\\n\\n    function sell(Orders.SellParams memory sellParams) external payable returns (uint256 orderId);\\n\\n    function buy(Orders.BuyParams memory buyParams) external payable returns (uint256 orderId);\\n\\n    function execute(uint256 n) external;\\n}\\n\"\r\n    },\r\n    \"IIntegralOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\ninterface IIntegralOracle {\\n    event OwnerSet(address owner);\\n    event UniswapPairSet(address uniswapPair);\\n    event PriceUpdateIntervalSet(uint32 interval);\\n    event ParametersSet(uint32 epoch, int256[] bidExponents, int256[] bidQs, int256[] askExponents, int256[] askQs);\\n\\n    function owner() external view returns (address);\\n\\n    function setOwner(address) external;\\n\\n    function epoch() external view returns (uint32);\\n\\n    function xDecimals() external view returns (uint8);\\n\\n    function yDecimals() external view returns (uint8);\\n\\n    function getParameters()\\n        external\\n        view\\n        returns (\\n            int256[] memory bidExponents,\\n            int256[] memory bidQs,\\n            int256[] memory askExponents,\\n            int256[] memory askQs\\n        );\\n\\n    function setParameters(\\n        int256[] calldata bidExponents,\\n        int256[] calldata bidQs,\\n        int256[] calldata askExponents,\\n        int256[] calldata askQs\\n    ) external;\\n\\n    function price() external view returns (int256);\\n\\n    function priceUpdateInterval() external view returns (uint32);\\n\\n    function updatePrice() external returns (uint32 _epoch);\\n\\n    function setPriceUpdateInterval(uint32 interval) external;\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function blockTimestampLast() external view returns (uint32);\\n\\n    function tradeX(\\n        uint256 xAfter,\\n        uint256 xBefore,\\n        uint256 yBefore\\n    ) external view returns (uint256 yAfter);\\n\\n    function tradeY(\\n        uint256 yAfter,\\n        uint256 xBefore,\\n        uint256 yBefore\\n    ) external view returns (uint256 xAfter);\\n\\n    function getSpotPrice(uint256 xCurrent, uint256 xBefore) external view returns (uint256 spotPrice);\\n}\\n\"\r\n    },\r\n    \"Normalizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\nimport 'SafeMath.sol';\\n\\nlibrary Normalizer {\\n    using SafeMath for uint256;\\n\\n    function normalize(uint256 amount, uint8 decimals) internal pure returns (uint256) {\\n        if (decimals == 18) {\\n            return amount;\\n        } else if (decimals > 18) {\\n            return amount.div(10**(decimals - 18));\\n        } else {\\n            return amount.mul(10**(18 - decimals));\\n        }\\n    }\\n\\n    function denormalize(uint256 amount, uint8 decimals) internal pure returns (uint256) {\\n        if (decimals == 18) {\\n            return amount;\\n        } else if (decimals > 18) {\\n            return amount.mul(10**(decimals - 18));\\n        } else {\\n            return amount.div(10**(18 - decimals));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"AddLiquidity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\nimport 'TransferHelper.sol';\\nimport 'SafeMath.sol';\\nimport 'Math.sol';\\nimport 'Normalizer.sol';\\nimport 'IIntegralPair.sol';\\nimport 'IIntegralOracle.sol';\\n\\nlibrary AddLiquidity {\\n    using SafeMath for uint256;\\n\\n    function _quote(\\n        uint256 amount0,\\n        uint256 reserve0,\\n        uint256 reserve1\\n    ) private pure returns (uint256 amountB) {\\n        require(amount0 > 0, 'AL_INSUFFICIENT_AMOUNT');\\n        require(reserve0 > 0 && reserve1 > 0, 'AL_INSUFFICIENT_LIQUIDITY');\\n        amountB = amount0.mul(reserve1) / reserve0;\\n    }\\n\\n    function addLiquidity(\\n        address pair,\\n        uint256 amount0Desired,\\n        uint256 amount1Desired\\n    ) external view returns (uint256 amount0, uint256 amount1) {\\n        if (amount0Desired == 0 || amount1Desired == 0) {\\n            return (0, 0);\\n        }\\n        (uint256 reserve0, uint256 reserve1, ) = IIntegralPair(pair).getReserves();\\n        if (reserve0 == 0 && reserve1 == 0) {\\n            (amount0, amount1) = (amount0Desired, amount1Desired);\\n        } else {\\n            uint256 amount1Optimal = _quote(amount0Desired, reserve0, reserve1);\\n            if (amount1Optimal <= amount1Desired) {\\n                (amount0, amount1) = (amount0Desired, amount1Optimal);\\n            } else {\\n                uint256 amount0Optimal = _quote(amount1Desired, reserve1, reserve0);\\n                assert(amount0Optimal <= amount0Desired);\\n                (amount0, amount1) = (amount0Optimal, amount1Desired);\\n            }\\n        }\\n    }\\n\\n    function swapDeposit0(\\n        address pair,\\n        address token0,\\n        uint256 amount0,\\n        uint256 minSwapPrice\\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\\n        uint256 amount0In = IIntegralPair(pair).getDepositAmount0In(amount0);\\n        amount1Left = IIntegralPair(pair).getSwapAmount1Out(amount0In);\\n        if (amount1Left == 0) {\\n            return (amount0, amount1Left);\\n        }\\n        uint256 price = getPrice(amount0In, amount1Left, pair);\\n        require(minSwapPrice == 0 || price >= minSwapPrice, 'AL_PRICE_TOO_LOW');\\n        TransferHelper.safeTransfer(token0, pair, amount0In);\\n        IIntegralPair(pair).swap(0, amount1Left, address(this));\\n        amount0Left = amount0.sub(amount0In);\\n    }\\n\\n    function swapDeposit1(\\n        address pair,\\n        address token1,\\n        uint256 amount1,\\n        uint256 maxSwapPrice\\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\\n        uint256 amount1In = IIntegralPair(pair).getDepositAmount1In(amount1);\\n        amount0Left = IIntegralPair(pair).getSwapAmount0Out(amount1In);\\n        if (amount0Left == 0) {\\n            return (amount0Left, amount1);\\n        }\\n        uint256 price = getPrice(amount0Left, amount1In, pair);\\n        require(maxSwapPrice == 0 || price <= maxSwapPrice, 'AL_PRICE_TOO_HIGH');\\n        TransferHelper.safeTransfer(token1, pair, amount1In);\\n        IIntegralPair(pair).swap(amount0Left, 0, address(this));\\n        amount1Left = amount1.sub(amount1In);\\n    }\\n\\n    function getPrice(\\n        uint256 amount0,\\n        uint256 amount1,\\n        address pair\\n    ) internal view returns (uint256) {\\n        IIntegralOracle oracle = IIntegralOracle(IIntegralPair(pair).oracle());\\n        uint8 xDecimals = oracle.xDecimals();\\n        uint8 yDecimals = oracle.yDecimals();\\n        return Normalizer.normalize(amount1, yDecimals).mul(1e18).div(Normalizer.normalize(amount0, xDecimals));\\n    }\\n\\n    function canSwap(\\n        uint256 initialRatio, // setting it to 0 disables swap\\n        uint256 minRatioChangeToSwap,\\n        address pairAddress\\n    ) external view returns (bool) {\\n        (uint256 reserve0, uint256 reserve1, ) = IIntegralPair(pairAddress).getReserves();\\n        if (reserve0 == 0 || reserve1 == 0 || initialRatio == 0) {\\n            return false;\\n        }\\n        uint256 ratio = reserve0.mul(1e18).div(reserve1);\\n        // ratioChange(before, after) = MAX(before, after) / MIN(before, after) - 1\\n        uint256 change = Math.max(initialRatio, ratio).mul(1e3).div(Math.min(initialRatio, ratio)).sub(1e3);\\n        return change >= minRatioChangeToSwap;\\n    }\\n}\\n\"\r\n    },\r\n    \"BuyHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n// pragma abicoder v2;\\n\\nimport 'IIntegralOracle.sol';\\nimport 'IIntegralPair.sol';\\nimport 'SafeMath.sol';\\n\\nlibrary BuyHelper {\\n    using SafeMath for uint256;\\n    uint256 public constant PRECISION = 10**18;\\n\\n    function getSwapAmount0In(address pair, uint256 amount1Out) external view returns (uint256 swapAmount0In) {\\n        (uint112 reserve0, uint112 reserve1, ) = IIntegralPair(pair).getReserves();\\n        (uint112 reference0, uint112 reference1, ) = IIntegralPair(pair).getReferences();\\n        uint256 balance1After = uint256(reserve1).sub(amount1Out);\\n        uint256 balance0After = IIntegralOracle(IIntegralPair(pair).oracle()).tradeY(\\n            balance1After,\\n            reference0,\\n            reference1\\n        );\\n        uint256 swapFee = IIntegralPair(pair).swapFee();\\n        return balance0After.sub(uint256(reserve0)).mul(PRECISION).ceil_div(PRECISION.sub(swapFee));\\n    }\\n\\n    function getSwapAmount1In(address pair, uint256 amount0Out) external view returns (uint256 swapAmount1In) {\\n        (uint112 reserve0, uint112 reserve1, ) = IIntegralPair(pair).getReserves();\\n        (uint112 reference0, uint112 reference1, ) = IIntegralPair(pair).getReferences();\\n        uint256 balance0After = uint256(reserve0).sub(amount0Out);\\n        uint256 balance1After = IIntegralOracle(IIntegralPair(pair).oracle()).tradeX(\\n            balance0After,\\n            reference0,\\n            reference1\\n        );\\n        uint256 swapFee = IIntegralPair(pair).swapFee();\\n        return balance1After.add(1).sub(uint256(reserve1)).mul(PRECISION).ceil_div(PRECISION.sub(swapFee));\\n    }\\n}\\n\"\r\n    },\r\n    \"WithdrawHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport 'IIntegralPair.sol';\\nimport 'IWETH.sol';\\nimport 'Orders.sol';\\n\\nlibrary WithdrawHelper {\\n    using SafeMath for uint256;\\n\\n    function _transferToken(\\n        uint256 balanceBefore,\\n        address token,\\n        address to\\n    ) internal {\\n        uint256 tokenAmount = IERC20(token).balanceOf(address(this)).sub(balanceBefore);\\n        TransferHelper.safeTransfer(token, to, tokenAmount);\\n    }\\n\\n    function _unwrapWeth(\\n        uint256 ethAmount,\\n        address weth,\\n        address to\\n    ) internal returns (bool) {\\n        IWETH(weth).withdraw(ethAmount);\\n        (bool success, ) = to.call{ value: ethAmount, gas: Orders.ETHER_TRANSFER_CALL_COST }('');\\n        return success;\\n    }\\n\\n    function withdrawAndUnwrap(\\n        address token0,\\n        address token1,\\n        address pair,\\n        address weth,\\n        address to\\n    )\\n        external\\n        returns (\\n            bool,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        bool isToken0Weth = token0 == weth;\\n        address otherToken = isToken0Weth ? token1 : token0;\\n\\n        uint256 balanceBefore = IERC20(otherToken).balanceOf(address(this));\\n        (uint256 amount0, uint256 amount1) = IIntegralPair(pair).burn(address(this));\\n        _transferToken(balanceBefore, otherToken, to);\\n\\n        bool success = _unwrapWeth(isToken0Weth ? amount0 : amount1, weth, to);\\n\\n        return (success, isToken0Weth ? amount0 : amount1, amount0, amount1);\\n    }\\n}\\n\"\r\n    },\r\n    \"IntegralDelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport 'IIntegralPair.sol';\\nimport 'IIntegralDelay.sol';\\nimport 'IIntegralOracle.sol';\\nimport 'IWETH.sol';\\nimport 'SafeMath.sol';\\nimport 'Normalizer.sol';\\nimport 'Orders.sol';\\nimport 'TokenShares.sol';\\nimport 'AddLiquidity.sol';\\nimport 'BuyHelper.sol';\\nimport 'WithdrawHelper.sol';\\n\\ncontract IntegralDelay is IIntegralDelay {\\n    using SafeMath for uint256;\\n    using Normalizer for uint256;\\n    using Orders for Orders.Data;\\n    using TokenShares for TokenShares.Data;\\n    Orders.Data internal orders;\\n    TokenShares.Data internal tokenShares;\\n\\n    uint256 public constant ORDER_CANCEL_TIME = 24 hours;\\n    uint256 private constant ORDER_EXECUTED_COST = 3700;\\n\\n    address public override owner;\\n    mapping(address => bool) public override isBot;\\n    uint256 public override botExecuteTime;\\n\\n    constructor(\\n        address _factory,\\n        address _weth,\\n        address _bot\\n    ) {\\n        orders.factory = _factory;\\n        owner = msg.sender;\\n        isBot[_bot] = true;\\n        orders.gasPrice = tx.gasprice - (tx.gasprice % 1e6);\\n        tokenShares.setWeth(_weth);\\n        orders.delay = 5 minutes;\\n        botExecuteTime = 4 * orders.delay;\\n        orders.maxGasLimit = 5000000;\\n        orders.gasPriceInertia = 20000000;\\n        orders.maxGasPriceImpact = 1000000;\\n    }\\n\\n    function getTransferGasCost(address token) public view override returns (uint256 gasCost) {\\n        return orders.transferGasCosts[token];\\n    }\\n\\n    function getDepositOrder(uint256 orderId) public view override returns (Orders.DepositOrder memory order) {\\n        return orders.getDepositOrder(orderId);\\n    }\\n\\n    function getWithdrawOrder(uint256 orderId) public view override returns (Orders.WithdrawOrder memory order) {\\n        return orders.getWithdrawOrder(orderId);\\n    }\\n\\n    function getSellOrder(uint256 orderId) public view override returns (Orders.SellOrder memory order) {\\n        return orders.getSellOrder(orderId);\\n    }\\n\\n    function getBuyOrder(uint256 orderId) public view override returns (Orders.BuyOrder memory order) {\\n        return orders.getBuyOrder(orderId);\\n    }\\n\\n    function getDepositDisabled(address pair) public view override returns (bool) {\\n        return orders.depositDisabled[pair];\\n    }\\n\\n    function getWithdrawDisabled(address pair) public view override returns (bool) {\\n        return orders.withdrawDisabled[pair];\\n    }\\n\\n    function getBuyDisabled(address pair) public view override returns (bool) {\\n        return orders.buyDisabled[pair];\\n    }\\n\\n    function getSellDisabled(address pair) public view override returns (bool) {\\n        return orders.sellDisabled[pair];\\n    }\\n\\n    function getOrderStatus(uint256 orderId) public view override returns (Orders.OrderStatus) {\\n        return orders.getOrderStatus(orderId);\\n    }\\n\\n    uint256 private unlocked = 1;\\n    modifier lock() {\\n        require(unlocked == 1, 'ID_LOCKED');\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    function factory() public view override returns (address) {\\n        return orders.factory;\\n    }\\n\\n    function totalShares(address token) public view override returns (uint256) {\\n        return tokenShares.totalShares[token];\\n    }\\n\\n    function weth() public view override returns (address) {\\n        return tokenShares.weth;\\n    }\\n\\n    function delay() public view override returns (uint256) {\\n        return orders.delay;\\n    }\\n\\n    function lastProcessedOrderId() public view returns (uint256) {\\n        return orders.lastProcessedOrderId;\\n    }\\n\\n    function newestOrderId() public view returns (uint256) {\\n        return orders.newestOrderId;\\n    }\\n\\n    function getOrder(uint256 orderId) public view returns (Orders.OrderType orderType, uint256 validAfterTimestamp) {\\n        return orders.getOrder(orderId);\\n    }\\n\\n    function isOrderCanceled(uint256 orderId) public view returns (bool) {\\n        return orders.canceled[orderId];\\n    }\\n\\n    function maxGasLimit() public view override returns (uint256) {\\n        return orders.maxGasLimit;\\n    }\\n\\n    function maxGasPriceImpact() public view override returns (uint256) {\\n        return orders.maxGasPriceImpact;\\n    }\\n\\n    function gasPriceInertia() public view override returns (uint256) {\\n        return orders.gasPriceInertia;\\n    }\\n\\n    function gasPrice() public view override returns (uint256) {\\n        return orders.gasPrice;\\n    }\\n\\n    function setOrderDisabled(\\n        address pair,\\n        Orders.OrderType orderType,\\n        bool disabled\\n    ) public override {\\n        require(msg.sender == owner, 'ID_FORBIDDEN');\\n        require(orderType != Orders.OrderType.Empty, 'ID_INVALID_ORDER_TYPE');\\n        if (orderType == Orders.OrderType.Deposit) {\\n            orders.depositDisabled[pair] = disabled;\\n        } else if (orderType == Orders.OrderType.Withdraw) {\\n            orders.withdrawDisabled[pair] = disabled;\\n        } else if (orderType == Orders.OrderType.Sell) {\\n            orders.sellDisabled[pair] = disabled;\\n        } else if (orderType == Orders.OrderType.Buy) {\\n            orders.buyDisabled[pair] = disabled;\\n        }\\n        emit OrderDisabled(pair, orderType, disabled);\\n    }\\n\\n    function setOwner(address _owner) public override {\\n        require(msg.sender == owner, 'ID_FORBIDDEN');\\n        owner = _owner;\\n        emit OwnerSet(owner);\\n    }\\n\\n    function setBot(address _bot, bool _isBot) public override {\\n        require(msg.sender == owner, 'ID_FORBIDDEN');\\n        isBot[_bot] = _isBot;\\n        emit BotSet(_bot, _isBot);\\n    }\\n\\n    function setMaxGasLimit(uint256 _maxGasLimit) public override {\\n        require(msg.sender == owner, 'ID_FORBIDDEN');\\n        orders.setMaxGasLimit(_maxGasLimit);\\n    }\\n\\n    function setDelay(uint256 _delay) public override {\\n        require(msg.sender == owner, 'ID_FORBIDDEN');\\n        orders.delay = _delay;\\n        botExecuteTime = 4 * _delay;\\n        emit DelaySet(_delay);\\n    }\\n\\n    function setGasPriceInertia(uint256 _gasPriceInertia) public override {\\n        require(msg.sender == owner, 'ID_FORBIDDEN');\\n        orders.setGasPriceInertia(_gasPriceInertia);\\n    }\\n\\n    function setMaxGasPriceImpact(uint256 _maxGasPriceImpact) public override {\\n        require(msg.sender == owner, 'ID_FORBIDDEN');\\n        orders.setMaxGasPriceImpact(_maxGasPriceImpact);\\n    }\\n\\n    function setTransferGasCost(address token, uint256 gasCost) public override {\\n        require(msg.sender == owner, 'ID_FORBIDDEN');\\n        orders.setTransferGasCost(token, gasCost);\\n    }\\n\\n    function deposit(Orders.DepositParams calldata depositParams)\\n        external\\n        payable\\n        override\\n        lock\\n        returns (uint256 orderId)\\n    {\\n        orders.deposit(depositParams, tokenShares);\\n        return orders.newestOrderId;\\n    }\\n\\n    function withdraw(Orders.WithdrawParams calldata withdrawParams)\\n        external\\n        payable\\n        override\\n        lock\\n        returns (uint256 orderId)\\n    {\\n        orders.withdraw(withdrawParams);\\n        return orders.newestOrderId;\\n    }\\n\\n    function sell(Orders.SellParams calldata sellParams) external payable override lock returns (uint256 orderId) {\\n        orders.sell(sellParams, tokenShares);\\n        return orders.newestOrderId;\\n    }\\n\\n    function buy(Orders.BuyParams calldata buyParams) external payable override lock returns (uint256 orderId) {\\n        orders.buy(buyParams, tokenShares);\\n        return orders.newestOrderId;\\n    }\\n\\n    function execute(uint256 n) public override lock {\\n        emit Execute(msg.sender, n);\\n        uint256 gasBefore = gasleft();\\n        bool orderExecuted = false;\\n        for (uint256 i = 0; i < n; i++) {\\n            if (isOrderCanceled(orders.lastProcessedOrderId + 1)) {\\n                orders.dequeueCanceledOrder();\\n                continue;\\n            }\\n            (Orders.OrderType orderType, uint256 validAfterTimestamp) = orders.getNextOrder();\\n            if (orderType == Orders.OrderType.Empty || validAfterTimestamp >= block.timestamp) {\\n                break;\\n            }\\n            require(\\n                block.timestamp >= validAfterTimestamp + botExecuteTime || isBot[msg.sender] || isBot[address(0)],\\n                'ID_FORBIDDEN'\\n            );\\n            orderExecuted = true;\\n            if (orderType == Orders.OrderType.Deposit) {\\n                executeDeposit();\\n            } else if (orderType == Orders.OrderType.Withdraw) {\\n                executeWithdraw();\\n            } else if (orderType == Orders.OrderType.Sell) {\\n                executeSell();\\n            } else if (orderType == Orders.OrderType.Buy) {\\n                executeBuy();\\n            }\\n        }\\n        if (orderExecuted) {\\n            orders.updateGasPrice(gasBefore.sub(gasleft()));\\n        }\\n    }\\n\\n    function executeDeposit() internal {\\n        uint256 gasStart = gasleft();\\n        Orders.DepositOrder memory depositOrder = orders.dequeueDepositOrder();\\n        (, address token0, address token1) = orders.getPairInfo(depositOrder.pairId);\\n        (bool executionSuccess, bytes memory data) = address(this).call{\\n            gas: depositOrder.gasLimit.sub(\\n                Orders.ORDER_BASE_COST.add(orders.transferGasCosts[token0]).add(orders.transferGasCosts[token1])\\n            )\\n        }(abi.encodeWithSelector(this._executeDeposit.selector, depositOrder));\\n        bool refundSuccess = true;\\n        if (!executionSuccess) {\\n            refundSuccess = refundTokens(\\n                depositOrder.to,\\n                token0,\\n                depositOrder.share0,\\n                token1,\\n                depositOrder.share1,\\n                depositOrder.unwrap\\n            );\\n        }\\n        if (!refundSuccess) {\\n            orders.markRefundFailed();\\n        } else {\\n            orders.forgetLastProcessedOrder();\\n        }\\n        (uint256 gasUsed, uint256 ethRefund) = refund(\\n            depositOrder.gasLimit,\\n            depositOrder.gasPrice,\\n            gasStart,\\n            depositOrder.to\\n        );\\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\\n    }\\n\\n    function executeWithdraw() internal {\\n        uint256 gasStart = gasleft();\\n        Orders.WithdrawOrder memory withdrawOrder = orders.dequeueWithdrawOrder();\\n        (address pair, , ) = orders.getPairInfo(withdrawOrder.pairId);\\n        (bool executionSuccess, bytes memory data) = address(this).call{\\n            gas: withdrawOrder.gasLimit.sub(Orders.ORDER_BASE_COST.add(Orders.PAIR_TRANSFER_COST))\\n        }(abi.encodeWithSelector(this._executeWithdraw.selector, withdrawOrder));\\n        bool refundSuccess = true;\\n        if (!executionSuccess) {\\n            refundSuccess = refundLiquidity(pair, withdrawOrder.to, withdrawOrder.liquidity);\\n        }\\n        if (!refundSuccess) {\\n            orders.markRefundFailed();\\n        } else {\\n            orders.forgetLastProcessedOrder();\\n        }\\n        (uint256 gasUsed, uint256 ethRefund) = refund(\\n            withdrawOrder.gasLimit,\\n            withdrawOrder.gasPrice,\\n            gasStart,\\n            withdrawOrder.to\\n        );\\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\\n    }\\n\\n    function executeSell() internal {\\n        uint256 gasStart = gasleft();\\n        Orders.SellOrder memory sellOrder = orders.dequeueSellOrder();\\n        (, address token0, address token1) = orders.getPairInfo(sellOrder.pairId);\\n        (bool executionSuccess, bytes memory data) = address(this).call{\\n            gas: sellOrder.gasLimit.sub(\\n                Orders.ORDER_BASE_COST.add(orders.transferGasCosts[sellOrder.inverse ? token1 : token0])\\n            )\\n        }(abi.encodeWithSelector(this._executeSell.selector, sellOrder));\\n        bool refundSuccess = true;\\n        if (!executionSuccess) {\\n            refundSuccess = refundToken(\\n                sellOrder.inverse ? token1 : token0,\\n                sellOrder.to,\\n                sellOrder.shareIn,\\n                sellOrder.unwrap\\n            );\\n        }\\n        if (!refundSuccess) {\\n            orders.markRefundFailed();\\n        } else {\\n            orders.forgetLastProcessedOrder();\\n        }\\n        (uint256 gasUsed, uint256 ethRefund) = refund(sellOrder.gasLimit, sellOrder.gasPrice, gasStart, sellOrder.to);\\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\\n    }\\n\\n    function executeBuy() internal {\\n        uint256 gasStart = gasleft();\\n        Orders.BuyOrder memory buyOrder = orders.dequeueBuyOrder();\\n        (, address token0, address token1) = orders.getPairInfo(buyOrder.pairId);\\n        (bool executionSuccess, bytes memory data) = address(this).call{\\n            gas: buyOrder.gasLimit.sub(\\n                Orders.ORDER_BASE_COST.add(orders.transferGasCosts[buyOrder.inverse ? token1 : token0])\\n            )\\n        }(abi.encodeWithSelector(this._executeBuy.selector, buyOrder));\\n        bool refundSuccess = true;\\n        if (!executionSuccess) {\\n            refundSuccess = refundToken(\\n                buyOrder.inverse ? token1 : token0,\\n                buyOrder.to,\\n                buyOrder.shareInMax,\\n                buyOrder.unwrap\\n            );\\n        }\\n        if (!refundSuccess) {\\n            orders.markRefundFailed();\\n        } else {\\n            orders.forgetLastProcessedOrder();\\n        }\\n        (uint256 gasUsed, uint256 ethRefund) = refund(buyOrder.gasLimit, buyOrder.gasPrice, gasStart, buyOrder.to);\\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\\n    }\\n\\n    function refund(\\n        uint256 gasLimit,\\n        uint256 gasPriceInOrder,\\n        uint256 gasStart,\\n        address to\\n    ) private returns (uint256 gasUsed, uint256 leftOver) {\\n        uint256 feeCollected = gasLimit.mul(gasPriceInOrder);\\n        gasUsed = gasStart.sub(gasleft()).add(Orders.REFUND_END_COST).add(ORDER_EXECUTED_COST);\\n        uint256 actualRefund = Math.min(feeCollected, gasUsed.mul(orders.gasPrice));\\n        leftOver = feeCollected.sub(actualRefund);\\n        require(refundEth(msg.sender, actualRefund), 'ID_ETH_REFUND_FAILED');\\n        refundEth(payable(to), leftOver);\\n    }\\n\\n    function refundEth(address payable to, uint256 value) internal returns (bool success) {\\n        if (value == 0) {\\n            return true;\\n        }\\n        success = to.send(value);\\n        emit EthRefund(to, success, value);\\n    }\\n\\n    function refundToken(\\n        address token,\\n        address to,\\n        uint256 share,\\n        bool unwrap\\n    ) private returns (bool) {\\n        if (share == 0) {\\n            return true;\\n        }\\n        (bool success, bytes memory data) = address(this).call{ gas: orders.transferGasCosts[token] }(\\n            abi.encodeWithSelector(this._refundToken.selector, token, to, share, unwrap)\\n        );\\n        if (!success) {\\n            emit RefundFailed(to, token, share, data);\\n        }\\n        return success;\\n    }\\n\\n    function refundTokens(\\n        address to,\\n        address token0,\\n        uint256 share0,\\n        address token1,\\n        uint256 share1,\\n        bool unwrap\\n    ) private returns (bool) {\\n        (bool success, bytes memory data) = address(this).call{\\n            gas: orders.transferGasCosts[token0].add(orders.transferGasCosts[token1])\\n        }(abi.encodeWithSelector(this._refundTokens.selector, to, token0, share0, token1, share1, unwrap));\\n        if (!success) {\\n            emit RefundFailed(to, token0, share0, data);\\n            emit RefundFailed(to, token1, share1, data);\\n        }\\n        return success;\\n    }\\n\\n    function _refundTokens(\\n        address to,\\n        address token0,\\n        uint256 share0,\\n        address token1,\\n        uint256 share1,\\n        bool unwrap\\n    ) external {\\n        // no need to check sender, because it is checked in _refundToken\\n        _refundToken(token0, to, share0, unwrap);\\n        _refundToken(token1, to, share1, unwrap);\\n    }\\n\\n    function _refundToken(\\n        address token,\\n        address to,\\n        uint256 share,\\n        bool unwrap\\n    ) public {\\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\\n        if (token == tokenShares.weth && unwrap) {\\n            uint256 amount = tokenShares.sharesToAmount(token, share);\\n            IWETH(tokenShares.weth).withdraw(amount);\\n            payable(to).transfer(amount);\\n        } else {\\n            return TransferHelper.safeTransfer(token, to, tokenShares.sharesToAmount(token, share));\\n        }\\n    }\\n\\n    function refundLiquidity(\\n        address pair,\\n        address to,\\n        uint256 liquidity\\n    ) private returns (bool) {\\n        if (liquidity == 0) {\\n            return true;\\n        }\\n        (bool success, bytes memory data) = address(this).call{ gas: Orders.PAIR_TRANSFER_COST }(\\n            abi.encodeWithSelector(this._refundLiquidity.selector, pair, to, liquidity, false)\\n        );\\n        if (!success) {\\n            emit RefundFailed(to, pair, liquidity, data);\\n        }\\n        return success;\\n    }\\n\\n    function _refundLiquidity(\\n        address pair,\\n        address to,\\n        uint256 liquidity\\n    ) public {\\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\\n        return TransferHelper.safeTransfer(pair, to, liquidity);\\n    }\\n\\n    function _executeDeposit(Orders.DepositOrder memory depositOrder) public {\\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\\n        require(depositOrder.deadline >= block.timestamp, 'ID_EXPIRED');\\n\\n        (address pair, address token0, address token1, uint256 amount0Left, uint256 amount1Left) = _initialDeposit(\\n            depositOrder\\n        );\\n        if (\\n            (amount0Left != 0 || amount1Left != 0) &&\\n            AddLiquidity.canSwap(\\n                depositOrder.initialRatio,\\n                depositOrder.minRatioChangeToSwap,\\n                orders.pairs[depositOrder.pairId].pair\\n            )\\n        ) {\\n            if (amount0Left != 0) {\\n                (amount0Left, amount1Left) = AddLiquidity.swapDeposit0(\\n                    pair,\\n                    token0,\\n                    amount0Left,\\n                    depositOrder.minSwapPrice\\n                );\\n            } else if (amount1Left != 0) {\\n                (amount0Left, amount1Left) = AddLiquidity.swapDeposit1(\\n                    pair,\\n                    token1,\\n                    amount1Left,\\n                    depositOrder.maxSwapPrice\\n                );\\n            }\\n        }\\n        if (amount0Left != 0 && amount1Left != 0) {\\n            (amount0Left, amount1Left) = _addLiquidityAndMint(\\n                pair,\\n                depositOrder.to,\\n                token0,\\n                token1,\\n                amount0Left,\\n                amount1Left\\n            );\\n        }\\n\\n        _refundDeposit(depositOrder.to, token0, token1, amount0Left, amount1Left);\\n    }\\n\\n    function _initialDeposit(Orders.DepositOrder memory depositOrder)\\n        private\\n        returns (\\n            address pair,\\n            address token0,\\n            address token1,\\n            uint256 amount0Left,\\n            uint256 amount1Left\\n        )\\n    {\\n        (pair, token0, token1) = orders.getPairInfo(depositOrder.pairId);\\n        uint256 amount0Desired = tokenShares.sharesToAmount(token0, depositOrder.share0);\\n        uint256 amount1Desired = tokenShares.sharesToAmount(token1, depositOrder.share1);\\n        IIntegralPair(pair).fullSync();\\n        (amount0Left, amount1Left) = _addLiquidityAndMint(\\n            pair,\\n            depositOrder.to,\\n            token0,\\n            token1,\\n            amount0Desired,\\n            amount1Desired\\n        );\\n    }\\n\\n    function _addLiquidityAndMint(\\n        address pair,\\n        address to,\\n        address token0,\\n        address token1,\\n        uint256 amount0Desired,\\n        uint256 amount1Desired\\n    ) private returns (uint256 amount0Left, uint256 amount1Left) {\\n        (uint256 amount0, uint256 amount1) = AddLiquidity.addLiquidity(pair, amount0Desired, amount1Desired);\\n        if (amount0 == 0 || amount1 == 0) {\\n            return (amount0Desired, amount1Desired);\\n        }\\n        TransferHelper.safeTransfer(token0, pair, amount0);\\n        TransferHelper.safeTransfer(token1, pair, amount1);\\n        IIntegralPair(pair).mint(to);\\n\\n        amount0Left = amount0Desired.sub(amount0);\\n        amount1Left = amount1Desired.sub(amount1);\\n    }\\n\\n    function _refundDeposit(\\n        address to,\\n        address token0,\\n        address token1,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) private {\\n        if (amount0 > 0) {\\n            TransferHelper.safeTransfer(token0, to, amount0);\\n        }\\n        if (amount1 > 0) {\\n            TransferHelper.safeTransfer(token1, to, amount1);\\n        }\\n    }\\n\\n    function _executeWithdraw(Orders.WithdrawOrder memory withdrawOrder) public {\\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\\n        require(withdrawOrder.deadline >= block.timestamp, 'ID_EXPIRED');\\n\\n        (address pair, address token0, address token1) = orders.getPairInfo(withdrawOrder.pairId);\\n        IIntegralPair(pair).fullSync();\\n        TransferHelper.safeTransfer(pair, pair, withdrawOrder.liquidity);\\n\\n        (uint256 wethAmount, uint256 amount0, uint256 amount1) = (0, 0, 0);\\n        if (withdrawOrder.unwrap && (token0 == tokenShares.weth || token1 == tokenShares.weth)) {\\n            bool success;\\n            (success, wethAmount, amount0, amount1) = WithdrawHelper.withdrawAndUnwrap(\\n                token0,\\n                token1,\\n                pair,\\n                tokenShares.weth,\\n                withdrawOrder.to\\n            );\\n            if (!success) {\\n                tokenShares.onUnwrapFailed(withdrawOrder.to, wethAmount);\\n            }\\n        } else {\\n            (amount0, amount1) = IIntegralPair(pair).burn(withdrawOrder.to);\\n        }\\n        require(amount0 >= withdrawOrder.amount0Min && amount1 >= withdrawOrder.amount1Min, 'ID_INSUFFICIENT_AMOUNT');\\n    }\\n\\n    function _executeBuy(Orders.BuyOrder memory buyOrder) public {\\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\\n        require(buyOrder.deadline >= block.timestamp, 'ID_EXPIRED');\\n\\n        (address pairAddress, address token0, address token1) = orders.getPairInfo(buyOrder.pairId);\\n        (address tokenIn, address tokenOut) = buyOrder.inverse ? (token1, token0) : (token0, token1);\\n        uint256 amountInMax = tokenShares.sharesToAmount(tokenIn, buyOrder.shareInMax);\\n        IIntegralPair pair = IIntegralPair(pairAddress);\\n        pair.fullSync();\\n        uint256 amountIn = buyOrder.inverse\\n            ? BuyHelper.getSwapAmount1In(pairAddress, buyOrder.amountOut)\\n            : BuyHelper.getSwapAmount0In(pairAddress, buyOrder.amountOut);\\n        require(amountInMax >= amountIn, 'ID_INSUFFICIENT_INPUT_AMOUNT');\\n        (uint256 amount0Out, uint256 amount1Out) = buyOrder.inverse\\n            ? (buyOrder.amountOut, uint256(0))\\n            : (uint256(0), buyOrder.amountOut);\\n        TransferHelper.safeTransfer(tokenIn, pairAddress, amountIn);\\n        if (tokenOut == tokenShares.weth && buyOrder.unwrap) {\\n            pair.swap(amount0Out, amount1Out, address(this));\\n            IWETH(tokenShares.weth).withdraw(buyOrder.amountOut);\\n            (bool success, ) = buyOrder.to.call{ value: buyOrder.amountOut, gas: Orders.ETHER_TRANSFER_CALL_COST }('');\\n            if (!success) {\\n                tokenShares.onUnwrapFailed(buyOrder.to, buyOrder.amountOut);\\n            }\\n        } else {\\n            pair.swap(amount0Out, amount1Out, buyOrder.to);\\n        }\\n    }\\n\\n    function _executeSell(Orders.SellOrder memory sellOrder) public {\\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\\n        require(sellOrder.deadline >= block.timestamp, 'ID_EXPIRED');\\n\\n        (address pairAddress, address token0, address token1) = orders.getPairInfo(sellOrder.pairId);\\n        (address tokenIn, address tokenOut) = sellOrder.inverse ? (token1, token0) : (token0, token1);\\n        uint256 amountIn = tokenShares.sharesToAmount(tokenIn, sellOrder.shareIn);\\n        IIntegralPair pair = IIntegralPair(pairAddress);\\n        pair.fullSync();\\n        TransferHelper.safeTransfer(tokenIn, pairAddress, amountIn);\\n        uint256 amountOut = sellOrder.inverse ? pair.getSwapAmount0Out(amountIn) : pair.getSwapAmount1Out(amountIn);\\n        require(amountOut >= sellOrder.amountOutMin, 'ID_INSUFFICIENT_OUTPUT_AMOUNT');\\n        (uint256 amount0Out, uint256 amount1Out) = sellOrder.inverse\\n            ? (amountOut, uint256(0))\\n            : (uint256(0), amountOut);\\n        if (tokenOut == tokenShares.weth && sellOrder.unwrap) {\\n            pair.swap(amount0Out, amount1Out, address(this));\\n            IWETH(tokenShares.weth).withdraw(amountOut);\\n            (bool success, ) = sellOrder.to.call{ value: amountOut, gas: Orders.ETHER_TRANSFER_CALL_COST }('');\\n            if (!success) {\\n                tokenShares.onUnwrapFailed(sellOrder.to, amountOut);\\n            }\\n        } else {\\n            pair.swap(amount0Out, amount1Out, sellOrder.to);\\n        }\\n    }\\n\\n    function performRefund(\\n        Orders.OrderType orderType,\\n        uint256 validAfterTimestamp,\\n        uint256 orderId,\\n        bool shouldRefundEth\\n    ) internal {\\n        bool canOwnerRefund = validAfterTimestamp.add(365 days) < block.timestamp;\\n        if (orderType == Orders.OrderType.Deposit) {\\n            Orders.DepositOrder memory depositOrder = orders.getDepositOrder(orderId);\\n            (, address token0, address token1) = orders.getPairInfo(depositOrder.pairId);\\n            address to = canOwnerRefund ? owner : depositOrder.to;\\n            require(\\n                refundTokens(to, token0, depositOrder.share0, token1, depositOrder.share1, depositOrder.unwrap),\\n                'ID_REFUND_FAILED'\\n            );\\n            if (shouldRefundEth) {\\n                uint256 value = depositOrder.gasPrice.mul(depositOrder.gasLimit);\\n                require(refundEth(payable(to), value), 'ID_ETH_REFUND_FAILED');\\n            }\\n        } else if (orderType == Orders.OrderType.Withdraw) {\\n            Orders.WithdrawOrder memory withdrawOrder = orders.getWithdrawOrder(orderId);\\n            (address pair, , ) = orders.getPairInfo(withdrawOrder.pairId);\\n            address to = canOwnerRefund ? owner : withdrawOrder.to;\\n            require(refundLiquidity(pair, to, withdrawOrder.liquidity), 'ID_REFUND_FAILED');\\n            if (shouldRefundEth) {\\n                uint256 value = withdrawOrder.gasPrice.mul(withdrawOrder.gasLimit);\\n                require(refundEth(payable(to), value), 'ID_ETH_REFUND_FAILED');\\n            }\\n        } else if (orderType == Orders.OrderType.Sell) {\\n            Orders.SellOrder memory sellOrder = orders.getSellOrder(orderId);\\n            (, address token0, address token1) = orders.getPairInfo(sellOrder.pairId);\\n            address to = canOwnerRefund ? owner : sellOrder.to;\\n            require(\\n                refundToken(sellOrder.inverse ? token1 : token0, to, sellOrder.shareIn, sellOrder.unwrap),\\n                'ID_REFUND_FAILED'\\n            );\\n            if (shouldRefundEth) {\\n                uint256 value = sellOrder.gasPrice.mul(sellOrder.gasLimit);\\n                require(refundEth(payable(to), value), 'ID_ETH_REFUND_FAILED');\\n            }\\n        } else if (orderType == Orders.OrderType.Buy) {\\n            Orders.BuyOrder memory buyOrder = orders.getBuyOrder(orderId);\\n            (, address token0, address token1) = orders.getPairInfo(buyOrder.pairId);\\n            address to = canOwnerRefund ? owner : buyOrder.to;\\n            require(\\n                refundToken(buyOrder.inverse ? token1 : token0, to, buyOrder.shareInMax, buyOrder.unwrap),\\n                'ID_REFUND_FAILED'\\n            );\\n            if (shouldRefundEth) {\\n                uint256 value = buyOrder.gasPrice.mul(buyOrder.gasLimit);\\n                require(refundEth(payable(to), value), 'ID_ETH_REFUND_FAILED');\\n            }\\n        }\\n        orders.forgetOrder(orderId);\\n    }\\n\\n    function retryRefund(uint256 orderId) public lock {\\n        (Orders.OrderType orderType, uint256 validAfterTimestamp) = orders.getFailedOrderType(orderId);\\n        performRefund(orderType, validAfterTimestamp, orderId, false);\\n    }\\n\\n    function cancelOrder(uint256 orderId) public lock {\\n        (Orders.OrderType orderType, uint256 validAfterTimestamp) = orders.getOrder(orderId);\\n        require(validAfterTimestamp.sub(delay()).add(ORDER_CANCEL_TIME) < block.timestamp, 'ID_ORDER_NOT_EXCEEDED');\\n        performRefund(orderType, validAfterTimestamp, orderId, true);\\n        orders.canceled[orderId] = true;\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"libraries\": {\r\n      \"IERC20.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"IIntegralERC20.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"IReserves.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"IIntegralPair.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"SafeMath.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"Math.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"IIntegralFactory.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"IWETH.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"TransferHelper.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"TokenShares.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"Orders.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"IIntegralDelay.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"IIntegralOracle.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"Normalizer.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"AddLiquidity.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"BuyHelper.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"WithdrawHelper.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      },\r\n      \"IntegralDelay.sol\": {\r\n        \"TokenShares\": \"0xc82938b53e0e190459ba4e3502bf26f194760183\",\r\n        \"Orders\": \"0x7218D567b671E36c4e6B3257b8919196CF68ff5E\",\r\n        \"AddLiquidity\": \"0x538cffecf85F5232511F7E9204F1dEe84FCca9Bd\",\r\n        \"BuyHelper\": \"0x1412524711D58c4927dE00446682AaBb3F33c6E5\",\r\n        \"WithdrawHelper\": \"0xb0abc66f199Fb295DC3F6e968e8bA0db03821102\"\r\n      }\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"language\": \"Solidity\"\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bot\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bot\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBot\",\"type\":\"bool\"}],\"name\":\"BotSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"DelaySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"EthRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"Execute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasPriceInertia\",\"type\":\"uint256\"}],\"name\":\"GasPriceInertiaSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxGasLimit\",\"type\":\"uint256\"}],\"name\":\"MaxGasLimitSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxGasPriceImpact\",\"type\":\"uint256\"}],\"name\":\"MaxGasPriceImpactSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum Orders.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"OrderDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasSpent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethRefunded\",\"type\":\"uint256\"}],\"name\":\"OrderExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"RefundFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasCost\",\"type\":\"uint256\"}],\"name\":\"TransferGasCostSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnwrapFailed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ORDER_CANCEL_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"pairId\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"inverse\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"shareInMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.BuyOrder\",\"name\":\"buyOrder\",\"type\":\"tuple\"}],\"name\":\"_executeBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"pairId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"share0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"share1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRatioChangeToSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.DepositOrder\",\"name\":\"depositOrder\",\"type\":\"tuple\"}],\"name\":\"_executeDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"pairId\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"inverse\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"shareIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.SellOrder\",\"name\":\"sellOrder\",\"type\":\"tuple\"}],\"name\":\"_executeSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"pairId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.WithdrawOrder\",\"name\":\"withdrawOrder\",\"type\":\"tuple\"}],\"name\":\"_executeWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"_refundLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"}],\"name\":\"_refundToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"share0\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"share1\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"}],\"name\":\"_refundTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"botExecuteTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"wrapUnwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"submitDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executionDeadline\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.BuyParams\",\"name\":\"buyParams\",\"type\":\"tuple\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRatioChangeToSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"wrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"submitDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executionDeadline\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.DepositParams\",\"name\":\"depositParams\",\"type\":\"tuple\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasPriceInertia\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getBuyDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getBuyOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"pairId\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"inverse\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"shareInMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.BuyOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getDepositDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getDepositOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"pairId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"share0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"share1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRatioChangeToSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.DepositOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getOrder\",\"outputs\":[{\"internalType\":\"enum Orders.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"validAfterTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getOrderStatus\",\"outputs\":[{\"internalType\":\"enum Orders.OrderStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getSellDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getSellOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"pairId\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"inverse\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"shareIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.SellOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTransferGasCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasCost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getWithdrawDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getWithdrawOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"pairId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.WithdrawOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"isOrderCanceled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastProcessedOrderId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxGasPriceImpact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newestOrderId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"retryRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"wrapUnwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"submitDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executionDeadline\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.SellParams\",\"name\":\"sellParams\",\"type\":\"tuple\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bot\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isBot\",\"type\":\"bool\"}],\"name\":\"setBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_delay\",\"type\":\"uint256\"}],\"name\":\"setDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasPriceInertia\",\"type\":\"uint256\"}],\"name\":\"setGasPriceInertia\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxGasLimit\",\"type\":\"uint256\"}],\"name\":\"setMaxGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxGasPriceImpact\",\"type\":\"uint256\"}],\"name\":\"setMaxGasPriceImpact\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"enum Orders.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"setOrderDisabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasCost\",\"type\":\"uint256\"}],\"name\":\"setTransferGasCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"submitDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executionDeadline\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.WithdrawParams\",\"name\":\"withdrawParams\",\"type\":\"tuple\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"IntegralDelay","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000673662e97b05e001816c380ba5a628d2e29f55d1000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000008971dc0105a22e54d81593af02167fc82af935e3","EVMVersion":"Default","Library":"TokenShares:c82938b53e0e190459ba4e3502bf26f194760183;Orders:7218d567b671e36c4e6b3257b8919196cf68ff5e;AddLiquidity:538cffecf85f5232511f7e9204f1dee84fcca9bd;BuyHelper:1412524711d58c4927de00446682aabb3f33c6e5;WithdrawHelper:b0abc66f199fb295dc3f6e968e8ba0db03821102","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}