{"status":"1","message":"OK","result":[{"SourceCode":"{\"ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.8;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 \\u003c s \\u003c secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(\\n            uint256(s) \\u003c=\\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n            \\\"ECDSA: invalid signature \\u0027s\\u0027 value\\\"\\n        );\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature \\u0027v\\u0027 value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)\\n            );\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash)\\n            );\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\n/**\\n * @title ERC20 interface\\n */\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IWithdraw.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\ncontract IWithdraw {\\n    event WithdrawEvent(address indexed user, uint256 indexed amount, uint256 indexed nonce);\\n    event DrawEvent(address indexed user, uint256 indexed amount);\\n\\n    function verifySign(uint256 amount, uint256 nonce, address userAddr, bytes memory signature) public view returns (bool);\\n    function withdraw(uint256 amount, uint256 nonce, bytes memory signature) public returns (bool);\\n\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract ReentrancyGuard {\\n    bool private _notEntered;\\n    constructor () internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction\\u0027s gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        _notEntered = true;\\n    }\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n        _;\\n        // By storing the original value once again, a refund is triggered (see\\n        _notEntered = true;\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.8;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Unsigned math operations with safety checks that revert on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n    /**\\r\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath#mul: OVERFLOW\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, \\\"SafeMath#div: DIVISION_BY_ZERO\\\");\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\\"SafeMath#sub: UNDERFLOW\\\");\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds two unsigned integers, reverts on overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath#add: OVERFLOW\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\r\\n     * reverts when dividing by zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\"SafeMath#mod: DIVISION_BY_ZERO\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n\\r\\n}\"},\"TransferHelper.sol\":{\"content\":\"pragma solidity ^0.5.8;\\r\\n\\r\\n// helper methods for interacting with ERC20 tokens  that do not consistently return true/false\\r\\nlibrary TransferHelper {\\r\\n\\r\\n    function safeTransfer(address token, address to, uint value) internal returns (bool){\\r\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        return (success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address token, address from, address to, uint value) internal returns (bool){\\r\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        return (success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))));\\r\\n    }\\r\\n}\"},\"Withdraw.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./TransferHelper.sol\\\";\\nimport \\\"./IWithdraw.sol\\\";\\nimport \\\"./ECDSA.sol\\\";\\n\\ncontract Owned {\\n    address public owner;\\n    address public newOwner;\\n\\n    event OwnershipTransferred(address indexed _from, address indexed _to);\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function transferOwnership(address _newOwner) public onlyOwner {\\n        newOwner = _newOwner;\\n    }\\n\\n    function acceptOwnership() public {\\n        require(msg.sender == newOwner);\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n        newOwner = address(0);\\n    }\\n}\\n\\ncontract Withdraw is IWithdraw, ReentrancyGuard, Owned {\\n    IERC20 private tokenAddr;\\n    using TransferHelper for address;\\n    using SafeMath for uint256;\\n    using ECDSA for bytes32;\\n    string public name;\\n    bool public stop_status = false;\\n\\n    mapping(uint256 =\\u003e bool) usedNonce;\\n\\n    modifier withdraw_status {\\n        require(stop_status == false, \\\"WITHDRAW:STOP\\\");\\n        _;\\n    }\\n\\n    constructor(address _tokenAddr, address _owner) public {\\n        tokenAddr = IERC20(_tokenAddr);\\n        name = \\\"ADAO-WITHDRAW\\\";\\n        owner = _owner;\\n    }\\n\\n    function verifySign(\\n        uint256 amount,\\n        uint256 nonce,\\n        address userAddr,\\n        bytes memory signature\\n    ) public view returns (bool) {\\n        address recoverAddr =\\n            keccak256(abi.encode(userAddr, amount, nonce, this))\\n                .toEthSignedMessageHash()\\n                .recover(signature);\\n        require(recoverAddr == owner, \\\"WITHDRAW:SIGN_FAILURE\\\");\\n        require(!usedNonce[nonce], \\\"WITHDRAW:NONCE_USED\\\");\\n        return true;\\n    }\\n\\n    function withdraw(\\n        uint256 amount,\\n        uint256 nonce,\\n        bytes memory signature\\n    ) public nonReentrant withdraw_status returns (bool) {\\n        verifySign(amount, nonce, msg.sender, signature);\\n        usedNonce[nonce] = true;\\n        require(\\n            address(tokenAddr).safeTransfer(msg.sender, amount),\\n            \\\"WITHDRAW:INSUFFICIENT_CONTRACT_BALANCE\\\"\\n        );\\n        emit WithdrawEvent(msg.sender, amount, nonce);\\n        return true;\\n    }\\n\\n    function stop() public nonReentrant onlyOwner {\\n        stop_status = true;\\n    }\\n\\n    function draw(uint256 amount, address toAddr)\\n        public\\n        nonReentrant\\n        onlyOwner\\n    {\\n        require(\\n            address(tokenAddr).safeTransfer(toAddr, amount),\\n            \\\"WITHDRAW:INSUFFICIENT_CONTRACT_BALANCE\\\"\\n        );\\n        emit DrawEvent(toAddr, amount);\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DrawEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"WithdrawEvent\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"toAddr\",\"type\":\"address\"}],\"name\":\"draw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stop_status\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"verifySign\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Withdraw","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000071fbc1d795fcfbca43a3ebf6de0101952f31a4100000000000000000000000002f53c0e5b28b6066eb1989740f0470cd6af4655b","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6b1af78817e2fd76460c20573c332e6d34eaec64b8cda1a3411ce05e58056122"}]}