{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DsecDistribution.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./interfaces/IDsecDistribution.sol\\\";\\n\\ncontract DsecDistribution is IDsecDistribution {\\n    using SafeMath for uint256;\\n\\n    uint256 public constant DSEC_WITHDRAW_PENALTY_RATE = 20;\\n\\n    address public governanceAccount;\\n    address public treasuryPoolAddress;\\n\\n    mapping(uint256 => uint256) public totalDsec;\\n\\n    struct GovernanceFormingParams {\\n        uint256 totalNumberOfEpochs;\\n        uint256 startTimestamp;\\n        uint256 epochDuration;\\n        uint256 intervalBetweenEpochs;\\n        uint256 endTimestamp;\\n    }\\n\\n    GovernanceFormingParams public governanceForming;\\n\\n    mapping(address => mapping(uint256 => uint256)) private _dsecs;\\n    mapping(address => mapping(uint256 => bool)) private _redeemedDsec;\\n    mapping(uint256 => bool) private _redeemedTeamReward;\\n\\n    constructor(\\n        uint256 totalNumberOfEpochs_,\\n        uint256 epoch0StartTimestamp,\\n        uint256 epochDuration,\\n        uint256 intervalBetweenEpochs\\n    ) {\\n        governanceAccount = msg.sender;\\n        treasuryPoolAddress = msg.sender;\\n        governanceForming = GovernanceFormingParams({\\n            totalNumberOfEpochs: totalNumberOfEpochs_,\\n            startTimestamp: epoch0StartTimestamp,\\n            epochDuration: epochDuration,\\n            intervalBetweenEpochs: intervalBetweenEpochs,\\n            endTimestamp: epoch0StartTimestamp\\n                .add(totalNumberOfEpochs_.mul(epochDuration))\\n                .add(totalNumberOfEpochs_.sub(1).mul(intervalBetweenEpochs))\\n        });\\n    }\\n\\n    modifier onlyBy(address account) {\\n        require(msg.sender == account, \\\"sender not authorized\\\");\\n        _;\\n    }\\n\\n    function setGovernanceAccount(address newGovernanceAccount)\\n        external\\n        onlyBy(governanceAccount)\\n    {\\n        require(\\n            newGovernanceAccount != address(0),\\n            \\\"new governance account is the zero address\\\"\\n        );\\n\\n        governanceAccount = newGovernanceAccount;\\n    }\\n\\n    function setTreasuryPoolAddress(address newTreasuryPoolAddress)\\n        external\\n        onlyBy(governanceAccount)\\n    {\\n        require(\\n            newTreasuryPoolAddress != address(0),\\n            \\\"new treasury pool address is the zero address\\\"\\n        );\\n\\n        treasuryPoolAddress = newTreasuryPoolAddress;\\n    }\\n\\n    function addDsec(address account, uint256 amount)\\n        external\\n        override\\n        onlyBy(treasuryPoolAddress)\\n    {\\n        require(account != address(0), \\\"add to zero address\\\");\\n        require(amount != 0, \\\"add zero amount\\\");\\n\\n        (uint256 currentEpoch, uint256 currentDsec) =\\n            getDsecForTransferNow(amount);\\n        if (currentEpoch >= totalNumberOfEpochs()) {\\n            return;\\n        }\\n\\n        _dsecs[account][currentEpoch] = _dsecs[account][currentEpoch].add(\\n            currentDsec\\n        );\\n        totalDsec[currentEpoch] = totalDsec[currentEpoch].add(currentDsec);\\n\\n        uint256 nextEpoch = currentEpoch.add(1);\\n        if (nextEpoch < totalNumberOfEpochs()) {\\n            for (uint256 i = nextEpoch; i < totalNumberOfEpochs(); i++) {\\n                uint256 futureDsec =\\n                    amount.mul(governanceForming.epochDuration);\\n                _dsecs[account][i] = _dsecs[account][i].add(futureDsec);\\n                totalDsec[i] = totalDsec[i].add(futureDsec);\\n            }\\n        }\\n\\n        emit DsecAdd(\\n            account,\\n            currentEpoch,\\n            amount,\\n            block.timestamp,\\n            currentDsec\\n        );\\n    }\\n\\n    function removeDsec(address account, uint256 amount)\\n        external\\n        override\\n        onlyBy(treasuryPoolAddress)\\n    {\\n        require(account != address(0), \\\"remove from zero address\\\");\\n        require(amount != 0, \\\"remove zero amount\\\");\\n\\n        (uint256 currentEpoch, uint256 currentDsec) =\\n            getDsecForTransferNow(amount);\\n        if (currentEpoch >= totalNumberOfEpochs()) {\\n            return;\\n        }\\n\\n        if (_dsecs[account][currentEpoch] == 0) {\\n            return;\\n        }\\n\\n        uint256 dsecRemove =\\n            (block.timestamp < getStartTimestampForEpoch(currentEpoch))\\n                ? currentDsec\\n                : currentDsec.mul(DSEC_WITHDRAW_PENALTY_RATE.add(100)).div(100);\\n\\n        uint256 accountDsecRemove =\\n            (dsecRemove < _dsecs[account][currentEpoch])\\n                ? dsecRemove\\n                : _dsecs[account][currentEpoch];\\n        _dsecs[account][currentEpoch] = _dsecs[account][currentEpoch].sub(\\n            accountDsecRemove,\\n            \\\"insufficient account dsec\\\"\\n        );\\n        totalDsec[currentEpoch] = totalDsec[currentEpoch].sub(\\n            accountDsecRemove,\\n            \\\"insufficient total dsec\\\"\\n        );\\n\\n        uint256 nextEpoch = currentEpoch.add(1);\\n        if (nextEpoch < totalNumberOfEpochs()) {\\n            for (uint256 i = nextEpoch; i < totalNumberOfEpochs(); i++) {\\n                uint256 futureDsecRemove =\\n                    amount.mul(governanceForming.epochDuration);\\n                uint256 futureAccountDsecRemove =\\n                    (futureDsecRemove < _dsecs[account][i])\\n                        ? futureDsecRemove\\n                        : _dsecs[account][i];\\n                _dsecs[account][i] = _dsecs[account][i].sub(\\n                    futureAccountDsecRemove,\\n                    \\\"insufficient account future dsec\\\"\\n                );\\n                totalDsec[i] = totalDsec[i].sub(\\n                    futureAccountDsecRemove,\\n                    \\\"insufficient total future dsec\\\"\\n                );\\n            }\\n        }\\n\\n        emit DsecRemove(\\n            account,\\n            currentEpoch,\\n            amount,\\n            block.timestamp,\\n            accountDsecRemove\\n        );\\n    }\\n\\n    function redeemDsec(\\n        address account,\\n        uint256 epoch,\\n        uint256 distributionAmount\\n    ) external override onlyBy(treasuryPoolAddress) returns (uint256) {\\n        require(account != address(0), \\\"redeem for zero address\\\");\\n\\n        uint256 rewardAmount =\\n            calculateRewardFor(account, epoch, distributionAmount);\\n        // https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-strict-equalities\\n        // slither-disable-next-line incorrect-equality\\n        if (rewardAmount == 0) {\\n            return 0;\\n        }\\n\\n        if (hasRedeemedDsec(account, epoch)) {\\n            return 0;\\n        }\\n\\n        _redeemedDsec[account][epoch] = true;\\n        emit DsecRedeem(account, epoch, distributionAmount, rewardAmount);\\n        return rewardAmount;\\n    }\\n\\n    function redeemTeamReward(uint256 epoch)\\n        external\\n        override\\n        onlyBy(treasuryPoolAddress)\\n    {\\n        require(epoch < totalNumberOfEpochs(), \\\"governance forming ended\\\");\\n\\n        uint256 currentEpoch = getCurrentEpoch();\\n        require(epoch < currentEpoch, \\\"only for completed epochs\\\");\\n\\n        require(!hasRedeemedTeamReward(epoch), \\\"already redeemed\\\");\\n\\n        _redeemedTeamReward[epoch] = true;\\n        emit TeamRewardRedeem(msg.sender, epoch);\\n    }\\n\\n    function totalNumberOfEpochs()\\n        public\\n        view\\n        returns (uint256 totalNumberOfEpochs_)\\n    {\\n        totalNumberOfEpochs_ = governanceForming.totalNumberOfEpochs;\\n    }\\n\\n    function calculateRewardFor(\\n        address account,\\n        uint256 epoch,\\n        uint256 distributionAmount\\n    ) public view returns (uint256) {\\n        require(distributionAmount != 0, \\\"zero distribution amount\\\");\\n\\n        if (epoch >= totalNumberOfEpochs()) {\\n            return 0;\\n        }\\n\\n        uint256 currentEpoch = getCurrentEpoch();\\n        if (epoch >= currentEpoch) {\\n            return 0;\\n        }\\n\\n        return getRewardFor(account, epoch, distributionAmount);\\n    }\\n\\n    function estimateRewardForCurrentEpoch(\\n        address account,\\n        uint256 distributionAmount\\n    ) external view returns (uint256) {\\n        require(distributionAmount != 0, \\\"zero distribution amount\\\");\\n\\n        uint256 currentEpoch = getCurrentEpoch();\\n        return getRewardFor(account, currentEpoch, distributionAmount);\\n    }\\n\\n    function hasRedeemedDsec(address account, uint256 epoch)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        require(epoch < totalNumberOfEpochs(), \\\"governance forming ended\\\");\\n\\n        return _redeemedDsec[account][epoch];\\n    }\\n\\n    function hasRedeemedTeamReward(uint256 epoch)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        require(epoch < totalNumberOfEpochs(), \\\"governance forming ended\\\");\\n\\n        return _redeemedTeamReward[epoch];\\n    }\\n\\n    function getCurrentEpoch() public view returns (uint256) {\\n        return getEpoch(block.timestamp);\\n    }\\n\\n    function getCurrentEpochStartTimestamp()\\n        external\\n        view\\n        returns (uint256, uint256)\\n    {\\n        return getEpochStartTimestamp(block.timestamp);\\n    }\\n\\n    function getCurrentEpochEndTimestamp()\\n        external\\n        view\\n        returns (uint256, uint256)\\n    {\\n        return getEpochEndTimestamp(block.timestamp);\\n    }\\n\\n    function getEpoch(uint256 timestamp) public view returns (uint256) {\\n        if (timestamp < governanceForming.startTimestamp) {\\n            return 0;\\n        }\\n\\n        if (timestamp >= governanceForming.endTimestamp) {\\n            return totalNumberOfEpochs();\\n        }\\n\\n        return\\n            timestamp\\n                .sub(governanceForming.startTimestamp, \\\"before epoch 0\\\")\\n                .add(governanceForming.intervalBetweenEpochs)\\n                .div(\\n                governanceForming.epochDuration.add(\\n                    governanceForming.intervalBetweenEpochs\\n                )\\n            );\\n    }\\n\\n    function getEpochStartTimestamp(uint256 timestamp)\\n        public\\n        view\\n        returns (uint256, uint256)\\n    {\\n        uint256 epoch = getEpoch(timestamp);\\n        return (epoch, getStartTimestampForEpoch(epoch));\\n    }\\n\\n    function getStartTimestampForEpoch(uint256 epoch)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (epoch >= totalNumberOfEpochs()) {\\n            return 0;\\n        }\\n\\n        // https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-strict-equalities\\n        // slither-disable-next-line incorrect-equality\\n        if (epoch == 0) {\\n            return governanceForming.startTimestamp;\\n        }\\n\\n        return\\n            governanceForming.startTimestamp.add(\\n                epoch.mul(\\n                    governanceForming.epochDuration.add(\\n                        governanceForming.intervalBetweenEpochs\\n                    )\\n                )\\n            );\\n    }\\n\\n    function getEpochEndTimestamp(uint256 timestamp)\\n        public\\n        view\\n        returns (uint256, uint256)\\n    {\\n        uint256 epoch = getEpoch(timestamp);\\n        return (epoch, getEndTimestampForEpoch(epoch));\\n    }\\n\\n    function getEndTimestampForEpoch(uint256 epoch)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (epoch >= totalNumberOfEpochs()) {\\n            return 0;\\n        }\\n\\n        return\\n            governanceForming\\n                .startTimestamp\\n                .add(epoch.add(1).mul(governanceForming.epochDuration))\\n                .add(epoch.mul(governanceForming.intervalBetweenEpochs));\\n    }\\n\\n    function getStartEndTimestampsForEpoch(uint256 epoch)\\n        external\\n        view\\n        returns (uint256, uint256)\\n    {\\n        return (\\n            getStartTimestampForEpoch(epoch),\\n            getEndTimestampForEpoch(epoch)\\n        );\\n    }\\n\\n    function getSecondsUntilCurrentEpochEnd()\\n        public\\n        view\\n        returns (uint256, uint256)\\n    {\\n        return getSecondsUntilEpochEnd(block.timestamp);\\n    }\\n\\n    function getSecondsUntilEpochEnd(uint256 timestamp)\\n        public\\n        view\\n        returns (uint256, uint256)\\n    {\\n        (uint256 endEpoch, uint256 epochEndTimestamp) =\\n            getEpochEndTimestamp(timestamp);\\n        if (timestamp >= epochEndTimestamp) {\\n            return (endEpoch, 0);\\n        }\\n\\n        (uint256 startEpoch, uint256 epochStartTimestamp) =\\n            getEpochStartTimestamp(timestamp);\\n        require(epochStartTimestamp > 0, \\\"unexpected 0 epoch start\\\");\\n        // https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-strict-equalities\\n        // slither-disable-next-line incorrect-equality\\n        require(endEpoch == startEpoch, \\\"start/end different epochs\\\");\\n\\n        uint256 startTimestamp =\\n            (timestamp < epochStartTimestamp) ? epochStartTimestamp : timestamp;\\n        return (\\n            endEpoch,\\n            epochEndTimestamp.sub(startTimestamp, \\\"after end of epoch\\\")\\n        );\\n    }\\n\\n    function getDsecForTransferNow(uint256 amount)\\n        public\\n        view\\n        returns (uint256, uint256)\\n    {\\n        (uint256 currentEpoch, uint256 secondsUntilCurrentEpochEnd) =\\n            getSecondsUntilCurrentEpochEnd();\\n        return (currentEpoch, amount.mul(secondsUntilCurrentEpochEnd));\\n    }\\n\\n    function dsecBalanceFor(address account, uint256 epoch)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        if (epoch >= totalNumberOfEpochs()) {\\n            return 0;\\n        }\\n\\n        uint256 currentEpoch = getCurrentEpoch();\\n        if (epoch > currentEpoch) {\\n            return 0;\\n        }\\n\\n        return _dsecs[account][epoch];\\n    }\\n\\n    function getRewardFor(\\n        address account,\\n        uint256 epoch,\\n        uint256 distributionAmount\\n    ) internal view returns (uint256) {\\n        require(distributionAmount != 0, \\\"zero distribution amount\\\");\\n\\n        if (epoch >= totalNumberOfEpochs()) {\\n            return 0;\\n        }\\n\\n        // https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-strict-equalities\\n        // slither-disable-next-line incorrect-equality\\n        if (totalDsec[epoch] == 0) {\\n            return 0;\\n        }\\n\\n        if (_dsecs[account][epoch] == 0) {\\n            return 0;\\n        }\\n\\n        uint256 rewardAmount =\\n            _dsecs[account][epoch].mul(distributionAmount).div(\\n                totalDsec[epoch]\\n            );\\n        return rewardAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDsecDistribution.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.7.6;\\n\\ninterface IDsecDistribution {\\n    function addDsec(address account, uint256 amount) external;\\n\\n    function hasRedeemedDsec(address account, uint256 epoch)\\n        external\\n        view\\n        returns (bool);\\n\\n    function hasRedeemedTeamReward(uint256 epoch) external view returns (bool);\\n\\n    function removeDsec(address account, uint256 amount) external;\\n\\n    function redeemDsec(\\n        address account,\\n        uint256 epoch,\\n        uint256 distributionAmount\\n    ) external returns (uint256);\\n\\n    function redeemTeamReward(uint256 epoch) external;\\n\\n    event DsecAdd(\\n        address indexed account,\\n        uint256 indexed epoch,\\n        uint256 amount,\\n        uint256 timestamp,\\n        uint256 dsec\\n    );\\n\\n    event DsecRemove(\\n        address indexed account,\\n        uint256 indexed epoch,\\n        uint256 amount,\\n        uint256 timestamp,\\n        uint256 dsec\\n    );\\n\\n    event DsecRedeem(\\n        address indexed account,\\n        uint256 indexed epoch,\\n        uint256 distributionAmount,\\n        uint256 rewardAmount\\n    );\\n\\n    event TeamRewardRedeem(address indexed sender, uint256 indexed epoch);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalNumberOfEpochs_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch0StartTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"intervalBetweenEpochs\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dsec\",\"type\":\"uint256\"}],\"name\":\"DsecAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"distributionAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"DsecRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dsec\",\"type\":\"uint256\"}],\"name\":\"DsecRemove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"TeamRewardRedeem\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DSEC_WITHDRAW_PENALTY_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addDsec\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"distributionAmount\",\"type\":\"uint256\"}],\"name\":\"calculateRewardFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"dsecBalanceFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"distributionAmount\",\"type\":\"uint256\"}],\"name\":\"estimateRewardForCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpochEndTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpochStartTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getDsecForTransferNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getEndTimestampForEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getEpochEndTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getEpochStartTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSecondsUntilCurrentEpochEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getSecondsUntilEpochEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getStartEndTimestampsForEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getStartTimestampForEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceForming\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalNumberOfEpochs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"intervalBetweenEpochs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"hasRedeemedDsec\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"hasRedeemedTeamReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"distributionAmount\",\"type\":\"uint256\"}],\"name\":\"redeemDsec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"redeemTeamReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"removeDsec\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernanceAccount\",\"type\":\"address\"}],\"name\":\"setGovernanceAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTreasuryPoolAddress\",\"type\":\"address\"}],\"name\":\"setTreasuryPoolAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalDsec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalNumberOfEpochs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalNumberOfEpochs_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DsecDistribution","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000060cc6ea00000000000000000000000000000000000000000000000000000000000000e1000000000000000000000000000000000000000000000000000000000000004b0","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}