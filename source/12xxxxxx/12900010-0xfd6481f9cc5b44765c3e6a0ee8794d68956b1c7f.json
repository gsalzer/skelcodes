{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PendlePoolsReadWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n\\ninterface IERC20 {\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string memory);\\n}\\n\\ninterface PendleLiquidityRewardsProxy {\\n    function redeemLiquidityRewards(\\n        address liqMiningContract,\\n        uint256[] calldata expiries,\\n        address user\\n    )\\n        external\\n        returns (\\n            uint256 rewards,\\n            uint256[] memory pendingRewards,\\n            uint256 currentEpoch\\n        );\\n}\\n\\ninterface PendleMarket {\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function expiry() external view returns (uint256);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint256 xytBalance,\\n            uint256 xytWeight,\\n            uint256 tokenBalance,\\n            uint256 tokenWeight,\\n            uint256 currentBlock\\n        );\\n\\n    function symbol() external view returns (string memory);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function token() external view returns (address);\\n\\n    function xyt() external view returns (address);\\n}\\n\\ninterface PendleLiquidityMining {\\n    function allocationSettings(uint256 epochId, uint256 expiry) external view returns (uint256);\\n\\n    function epochDuration() external view returns (uint256);\\n\\n    function getBalances(uint256 expiry, address user) external view returns (uint256);\\n\\n    function readExpiryData(uint256 expiry)\\n        external\\n        view\\n        returns (\\n            uint256 totalStakeLP,\\n            uint256 lastNYield,\\n            uint256 paramL,\\n            address lpHolder\\n        );\\n\\n    function startTime() external view returns (uint256);\\n\\n    function latestSetting() external view returns (uint256 id, uint256 firstEpochToApply);\\n\\n    function totalRewardsForEpoch(uint256 epochId) external view returns (uint256 rewards);\\n}\\n\\ninterface PendleSingleStaking {\\n    function balances(address account) external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface PendleSingleStakingManager {\\n    function rewardPerBlock() external view returns (uint256);\\n}\\n\\ncontract PendlePoolsReadWrapper {\\n    using SafeMath for uint256;\\n\\n    struct Reserves {\\n        uint256 xytBalance;\\n        uint256 xytWeight;\\n        uint256 tokenBalance;\\n        uint256 tokenWeight;\\n    }\\n\\n    function marketApprove(PendleMarket _market, address _staking, uint256 _allowance) public {\\n        _market.approve(_staking, _allowance);\\n    }\\n\\n    function tokenApprove(IERC20 _token, address _staking, uint256 _allowance) public {\\n        _token.approve(_staking, _allowance);\\n    }\\n\\n    function claim(\\n        PendleLiquidityRewardsProxy _rewardsProxy,\\n        address _liqMiningContract,\\n        uint256[] calldata _expiries,\\n        address _user\\n    )\\n        public\\n        returns (\\n            uint256 rewards,\\n            uint256[] memory pendingRewards,\\n            uint256 currentEpoch\\n        )\\n    {\\n        (rewards, pendingRewards, currentEpoch) = _rewardsProxy.redeemLiquidityRewards(\\n            _liqMiningContract,\\n            _expiries,\\n            _user\\n        );\\n    }\\n\\n    function getLiquidityMiningInfo(PendleMarket _market, PendleLiquidityMining _staking)\\n        public\\n        view\\n        returns (\\n            uint256 expiry,\\n            string memory marketSymbol,\\n            string memory tokenSymbol,\\n            uint256 lpTotalSupply,\\n            uint256 totalStakeLP,\\n            uint256 latestSettingId,\\n            uint256 allocationSettings,\\n            uint8 tokenDecimals,\\n            uint8 xytDecimals,\\n            Reserves memory reserves\\n        )\\n    {\\n        {\\n            IERC20 token = IERC20(_market.token());\\n            IERC20 xyt = IERC20(_market.xyt());\\n\\n            tokenSymbol = token.symbol();\\n            tokenDecimals = token.decimals();\\n            xytDecimals = xyt.decimals();\\n        }\\n\\n        {\\n            (\\n                uint256 xytBalance,\\n                uint256 xytWeight,\\n                uint256 tokenBalance,\\n                uint256 tokenWeight,\\n\\n            ) = _market.getReserves();\\n            reserves.xytBalance = xytBalance;\\n            reserves.xytWeight = xytWeight;\\n            reserves.tokenBalance = tokenBalance;\\n            reserves.tokenWeight = tokenWeight;\\n        }\\n\\n        expiry = _market.expiry();\\n        marketSymbol = _market.symbol();\\n        lpTotalSupply = _market.totalSupply();\\n        (totalStakeLP, , , ) = _staking.readExpiryData(expiry);\\n        (latestSettingId, ) = _staking.latestSetting();\\n        allocationSettings = _staking.allocationSettings(latestSettingId, expiry);\\n    }\\n\\n    function getRewardsPerEpoch(\\n        PendleMarket _market,\\n        PendleLiquidityMining _staking,\\n        address _user\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 epochDuration,\\n            uint256 expiry,\\n            uint256 rewardsPerEpoch,\\n            uint256 userStaked,\\n            uint256 userAvailableToStake,\\n            uint256 userAllowance\\n        )\\n    {\\n        epochDuration = _staking.epochDuration();\\n        expiry = _market.expiry();\\n\\n        uint256 startTime = _staking.startTime();\\n        uint256 currentEpoch = (block.timestamp < startTime)\\n            ? 0\\n            : (block.timestamp.sub(startTime)).div(epochDuration).add(1);\\n\\n        rewardsPerEpoch = _staking.totalRewardsForEpoch(currentEpoch);\\n\\n        userStaked = _staking.getBalances(expiry, _user);\\n        userAvailableToStake = _market.balanceOf(_user);\\n        userAllowance = _market.allowance(_user, address(_staking));\\n    }\\n\\n    function getSingleStakingInfo(\\n        PendleSingleStaking _staking,\\n        PendleSingleStakingManager _manager,\\n        IERC20 _pendle,\\n        address _user\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 totalSupply,\\n            uint256 rewardPerBlock,\\n            uint256 userAvailableToStake,\\n            uint256 userAllowance,\\n            uint256 userShare\\n        )\\n    {\\n        totalSupply = _staking.totalSupply();\\n        rewardPerBlock = _manager.rewardPerBlock();\\n        userAvailableToStake = _pendle.balanceOf(_user);\\n        userAllowance = _pendle.allowance(_user, address(_staking));\\n        userShare = _staking.balances(_user);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 15000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract PendleLiquidityRewardsProxy\",\"name\":\"_rewardsProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liqMiningContract\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_expiries\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"pendingRewards\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"currentEpoch\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract PendleMarket\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"contract PendleLiquidityMining\",\"name\":\"_staking\",\"type\":\"address\"}],\"name\":\"getLiquidityMiningInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"marketSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lpTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStakeLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestSettingId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocationSettings\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tokenDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"xytDecimals\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"xytBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xytWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeight\",\"type\":\"uint256\"}],\"internalType\":\"struct PendlePoolsReadWrapper.Reserves\",\"name\":\"reserves\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract PendleMarket\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"contract PendleLiquidityMining\",\"name\":\"_staking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getRewardsPerEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"epochDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsPerEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userAvailableToStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userAllowance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract PendleSingleStaking\",\"name\":\"_staking\",\"type\":\"address\"},{\"internalType\":\"contract PendleSingleStakingManager\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_pendle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getSingleStakingInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userAvailableToStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract PendleMarket\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_staking\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_allowance\",\"type\":\"uint256\"}],\"name\":\"marketApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_staking\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_allowance\",\"type\":\"uint256\"}],\"name\":\"tokenApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PendlePoolsReadWrapper","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"15000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}