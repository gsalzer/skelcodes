{"status":"1","message":"OK","result":[{"SourceCode":"///SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n         _____                                           \r\n       \\/,---<                                           \r\n       ( )a a(      YOU STOLE FIZZY LIFTING DRINKS!!!    \r\n        C   >/                                           \r\n         \\ ~/      BUT THE D.A. MISHANDLED THE EVIDENCE, \r\n       ,- >o<-.    SO HERE'S THE KEYS TO MY FUDGE FACTORY\r\n      /   \\/   \\                                         \r\n     / /|  | |\\ \\     _                                  \r\n     \\ \\|  | | \\ `---/_)                                 \r\n      \\_\\_ | |  `----\\_O-                                \r\n      /_/____|                                           \r\n        |  | |                                           \r\n        |  | |                                           \r\n        |  | |               ____                        \r\n        |__|_|_           &&& x_ \\_,-------.___     |    \r\nStef00  (____)_)         &&&& x__*_\\\\._/__--_-_\\-._/_    \r\n\r\nImage found here: http://www.asciiartfarts.com/20121102.html\r\n\r\nMy name is Millie Monka\r\nI love Meme Coins\r\nAnd also you do\r\nSo I decided to open the doors of my Meme Coin Factory to you\r\nEvery 35 hours you can create a meme coin sending at least 1 ETH\r\nyou can choose name, symbol, and total supply\r\nMeme Coin will be created and 99.98% of the total supply will be stored in a pool on UniswapV2 using eth you provided\r\nremaining 0.02% of the Meme Coin total supply will be sent to Meme Coin creator so they can be swapped in future to have back creation fees\r\nResulting liquidity pool token will be held by the Meme Coin itself\r\nthe first burning 65% of the Meme Coin total supply will extract 60% of the pool\r\nAll Meme Coins removed from the pool will be burned\r\n40% of removed eth will be sent to who burned tokens\r\n47% of removed eth will be sent back to pool\r\nremaining removed eth will be sent as Factory's fees\r\nThe remaining balance of liquidity pool token will be locked inside the Meme Coin forever\r\n\r\nIn Factory:\r\n\r\nyou have create(string memory name, string memory symbol, uint256 totalSupplyPlain) method to create a new Meme Coin. The amount is expressed in the decimal format so you DON'T HAVE TO multiply it for 1e18, Meme Coin will directly do it for you.\r\n\r\nyou have memeCoins() method to retrieve all Meme Coins in order of creation, including latest one\r\nyou have lastMemeCoin() method to retrieve the last Meme Coin only\r\nyou have nextCreationBlock() method to know when the next Meme Coin can be created\r\nyou have canBeCreated() method returning if nextCreationBlock reached and new Meme Coin can be created\r\n\r\nIn every Meme Coin:\r\n\r\nyou have the burn() method which will do all burn stuff descrived above for you\r\n\r\nyou have burnt() method to check if the 65% of total supply was already burnt or not\r\n\r\nYou can build a Telegram bot or fork the Uniswap frontend to easily use the Meme Coins\r\n\r\nHope you will enjoy my Meme Coin Factory,\r\nI will do.\r\n\r\nYours,\r\nMillie\r\n\r\n*/\r\n\r\ninterface IUniswapV2Router {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidityETH(\r\n      address token,\r\n      uint amountTokenDesired,\r\n      uint amountTokenMin,\r\n      uint amountETHMin,\r\n      address to,\r\n      uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidityETH(\r\n      address token,\r\n      uint liquidity,\r\n      uint amountTokenMin,\r\n      uint amountETHMin,\r\n      address to,\r\n      uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n}\r\n\r\ninterface IUniswapLiquidityPool {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function sync() external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface WETHToken {\r\n    function deposit() external payable;\r\n    function transfer(address dst, uint wad) external returns (bool);\r\n}\r\n\r\ncontract MemeCoin {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply;\r\n    \r\n    IUniswapV2Router private UNISWAP;\r\n\r\n    address private _millie;\r\n\r\n    bool public burnt;\r\n\r\n    constructor(IUniswapV2Router uniswap, string memory _name, string memory _symbol, uint256 _totalSupply, address millie) {\r\n        UNISWAP = uniswap;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        _millie = millie;\r\n        _mint(msg.sender, _totalSupply);\r\n    }\r\n\r\n    receive() external payable {\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, msg.sender, currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function burn() public {\r\n        require(!burnt);\r\n        _burn(msg.sender, (totalSupply * 65) / 100);\r\n        burnt = true;\r\n        WETHToken weth = WETHToken(UNISWAP.WETH());\r\n        IUniswapLiquidityPool liquidityPool = IUniswapLiquidityPool(IUniswapV2Factory(UNISWAP.factory()).getPair(address(weth), address(this)));\r\n        uint256 poolBalance = (liquidityPool.balanceOf(address(this)) * 60) / 100;\r\n        liquidityPool.approve(address(UNISWAP), poolBalance);\r\n        (uint256 tokens, uint256 eths) = UNISWAP.removeLiquidityETH(address(this), poolBalance, 1, 1, address(this), block.timestamp + 1000000);\r\n        _burn(address(this), tokens);\r\n        poolBalance = eths;\r\n        payable(msg.sender).transfer(tokens = (eths * 40) / 100);\r\n        poolBalance -= tokens;\r\n        weth.deposit{value : tokens = (eths * 47) / 100}();\r\n        weth.transfer(address(liquidityPool), tokens);\r\n        liquidityPool.sync();\r\n        poolBalance -= tokens;\r\n        payable(_millie).transfer(poolBalance);\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = accountBalance - amount;\r\n        totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n}\r\n\r\ncontract MemeCoinFactory {\r\n\r\n    uint256 private constant BLOCK_INTERVAL = 9333;\r\n    \r\n    IUniswapV2Router private constant UNISWAP = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n\r\n    address private _millie = msg.sender;\r\n\r\n    address[] private _memeCoins;\r\n\r\n    uint256 private _lastMemeCoinCreation;\r\n\r\n    function memeCoins() public view returns (address[] memory){\r\n        return _memeCoins;\r\n    }\r\n\r\n    function lastMemeCoin() public view returns (address) {\r\n        return _memeCoins[_memeCoins.length - 1];\r\n    }\r\n\r\n    function nextCreationBlock() public view returns (uint256) {\r\n        return _lastMemeCoinCreation == 0 ? block.number : _lastMemeCoinCreation + BLOCK_INTERVAL;\r\n    }\r\n\r\n    function canBeCreated() public view returns (bool) {\r\n        return _lastMemeCoinCreation == 0 ? true : block.number >= nextCreationBlock();\r\n    }\r\n\r\n    function create(string calldata name, string calldata symbol, uint256 totalSupplyPlain) public payable {\r\n        require(canBeCreated());\r\n        require(msg.value >= 1e18);\r\n        _lastMemeCoinCreation = block.number;\r\n        uint256 totalSupply = totalSupplyPlain * 1e18;\r\n        MemeCoin newMemeCoin = new MemeCoin(UNISWAP, name, symbol, totalSupply, _millie);\r\n        _memeCoins.push(address(newMemeCoin));\r\n        uint256 senderBalance = (totalSupply * 2) / 10000;\r\n        newMemeCoin.transfer(msg.sender, senderBalance);\r\n        totalSupply -= senderBalance;\r\n        newMemeCoin.approve(address(UNISWAP), totalSupply);\r\n        UNISWAP.addLiquidityETH{value : msg.value}(address(newMemeCoin), totalSupply, 1, 1, address(newMemeCoin), block.timestamp + 100000000);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"canBeCreated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupplyPlain\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastMemeCoin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"memeCoins\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextCreationBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MemeCoinFactory","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://dfd669f9cb7602aaa40f74075b901b78de7121ead5d8a5c9d37d679b9cc99f64"}]}