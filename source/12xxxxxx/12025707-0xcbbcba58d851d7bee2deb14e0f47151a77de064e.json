{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/abialy/Documents/Projects/Crypto/defi/oracle/DecentralizedOracle/on-chain-oracle/contracts/Oracle.sol\": {\r\n      \"content\": \"// pragma solidity >=0.4.21 <0.6.0;\\r\\npragma solidity >=0.6.6;\\r\\n\\r\\nimport \\\"./interfaces/OracleInterface.sol\\\";\\r\\nimport \\\"./interfaces/IDEOR.sol\\\";\\r\\nimport \\\"./interfaces/IOracles.sol\\\";\\r\\nimport \\\"./interfaces/IPriceFeed.sol\\\";\\r\\nimport \\\"./interfaces/IDataQuery.sol\\\";\\r\\nimport \\\"./library/Selection.sol\\\";\\r\\nimport \\\"./library/SafeMathDEOR.sol\\\";\\r\\nimport \\\"./library/Ownable.sol\\\";\\r\\n\\r\\ncontract Oracle is Ownable, OracleInterface, Selection {\\r\\n  using SafeMathDEOR for uint256;\\r\\n\\r\\n  IDEOR private token;\\r\\n  IOracles private oracles;\\r\\n\\r\\n  Request[] private requests; //  list of requests made to the contract\\r\\n  uint256 public currentId = 1; // increasing request id\\r\\n  uint private totalOracleCount = 2000; // Hardcoded oracle count\\r\\n  uint256 constant private EXPIRY_TIME = 3 minutes;\\r\\n  uint256 public requestFee = 100 * (10**10);   // request fee\\r\\n  uint private maxSelectOracleCount = 17;\\r\\n\\r\\n  constructor (address tokenAddress, address oracleAddress) public {\\r\\n    token = IDEOR(tokenAddress);\\r\\n    oracles = IOracles(oracleAddress);\\r\\n    requests.push(Request(0, \\\"\\\", 0, address(0x0), \\\"\\\", 0, 0, 0, 0, 0));\\r\\n  }\\r\\n\\r\\n  function setRequestFee (uint256 fee) public onlyOwner {\\r\\n    requestFee = fee;\\r\\n  }\\r\\n\\r\\n  function newOracle (string memory name) public override(OracleInterface)\\r\\n  {\\r\\n    oracles.newOracle(name, msg.sender, requestFee);\\r\\n    emit NewOracle(msg.sender);\\r\\n  }\\r\\n\\r\\n  function createRequest (\\r\\n    string memory queries,\\r\\n    uint8 qtype,\\r\\n    address contractAddr\\r\\n  )\\r\\n  public override(OracleInterface)\\r\\n  {\\r\\n    require(token.balanceOf(msg.sender) >= requestFee, \\\"Invalid fee.\\\");\\r\\n    require(token.transferFrom(msg.sender, owner, requestFee), \\\"DEOR transfer Failed.\\\");\\r\\n\\r\\n    uint i = 0;\\r\\n    uint len = oracles.getOracleCount();\\r\\n    uint selectedOracleCount = (len * 2 + 2) / 3;\\r\\n    if (selectedOracleCount > maxSelectOracleCount) {\\r\\n      selectedOracleCount = maxSelectOracleCount;\\r\\n    }\\r\\n\\r\\n    requests.push(Request(currentId, queries, qtype, contractAddr, \\\"\\\", 0, block.timestamp, 0, requestFee, selectedOracleCount));\\r\\n    uint256 length = requests.length;\\r\\n    Request storage r = requests[length-1];\\r\\n\\r\\n    uint256[] memory orderingOracles = getSelectedOracles(len);\\r\\n    uint256 penaltyForRequest = requestFee.div(selectedOracleCount);\\r\\n    uint count = 0;\\r\\n\\r\\n    for (i = 0; i < len && count < selectedOracleCount ; i ++) {\\r\\n      address selOracle = oracles.getOracleByIndex(orderingOracles[i]);\\r\\n      //Validate oracle's acitivity\\r\\n      if (token.transferFrom(selOracle, owner, penaltyForRequest) && now < oracles.getOracleLastActiveTime(selOracle) + 1 days) {\\r\\n        r.quorum[selOracle] = 1;\\r\\n        count ++;\\r\\n        oracles.increaseOracleAssigned(selOracle, penaltyForRequest);\\r\\n      }\\r\\n    }\\r\\n    r.minQuorum = (count * 2 + 2) / 3;          //minimum number of responses to receive before declaring final result(2/3 of total)\\r\\n\\r\\n    // launch an event to be detected by oracle outside of blockchain\\r\\n    emit NewRequest (\\r\\n      currentId,\\r\\n      queries,\\r\\n      qtype\\r\\n    );\\r\\n\\r\\n    // increase request id\\r\\n    currentId ++;\\r\\n  }\\r\\n\\r\\n  function checkRetrievedValue (Request storage currRequest, address oracleAddress, string memory _valueRetrieved, int256 _priceRetrieved) \\r\\n    internal view returns (bool)\\r\\n  {\\r\\n    if (currRequest.qtype == 0) {\\r\\n      bytes memory a = bytes(currRequest.answers[oracleAddress]);\\r\\n      bytes memory b = bytes(_valueRetrieved);\\r\\n\\r\\n      if(keccak256(a) == keccak256(b)) {\\r\\n        return true;\\r\\n      }\\r\\n    }\\r\\n    else {\\r\\n      int256 diff = 0;\\r\\n      if (currRequest.priceAnswers[oracleAddress] > _priceRetrieved) {\\r\\n        diff = currRequest.priceAnswers[oracleAddress] - _priceRetrieved;\\r\\n      }\\r\\n      else {\\r\\n        diff = _priceRetrieved - currRequest.priceAnswers[oracleAddress];\\r\\n      }\\r\\n      if (diff < _priceRetrieved / 200) {\\r\\n        return true;\\r\\n      }\\r\\n    }\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  //called by the oracle to record its answer\\r\\n  function updateRequest (\\r\\n    uint256 _id,\\r\\n    string memory _valueRetrieved,\\r\\n    int256 _priceRetrieved\\r\\n  ) public override(OracleInterface) {\\r\\n\\r\\n    Request storage currRequest = requests[_id];\\r\\n\\r\\n    uint256 responseTime = block.timestamp.sub(currRequest.timestamp);\\r\\n    require(responseTime < EXPIRY_TIME, \\\"Your answer is expired.\\\");\\r\\n\\r\\n    //update last active time\\r\\n    oracles.updateOracleLastActiveTime(msg.sender);\\r\\n\\r\\n    //check if oracle is in the list of trusted oracles\\r\\n    //and if the oracle hasn't voted yet\\r\\n    if(currRequest.quorum[msg.sender] == 1){\\r\\n\\r\\n      oracles.increaseOracleCompleted(msg.sender, responseTime);\\r\\n\\r\\n      //marking that this address has voted\\r\\n      currRequest.quorum[msg.sender] = 2;\\r\\n\\r\\n      //save the retrieved value\\r\\n      if (currRequest.qtype == 0) {\\r\\n        currRequest.answers[msg.sender] = _valueRetrieved;\\r\\n      }\\r\\n      else {\\r\\n        currRequest.priceAnswers[msg.sender] = _priceRetrieved;\\r\\n      }\\r\\n\\r\\n      uint i = 0;\\r\\n      uint256 currentQuorum = 0;\\r\\n      uint len = oracles.getOracleCount();\\r\\n      uint8[] memory flag = new uint8[](len);\\r\\n\\r\\n      //iterate through oracle list and check if enough oracles(minimum quorum)\\r\\n      //have voted the same answer has the current one\\r\\n      for (i = 0 ; i < len ; i ++) {\\r\\n        if (checkRetrievedValue(currRequest, oracles.getOracleByIndex(i), _valueRetrieved, _priceRetrieved)) {\\r\\n          currentQuorum ++;\\r\\n          flag[i] = 1;\\r\\n        }\\r\\n      }\\r\\n\\r\\n      //request Resolved\\r\\n      if(currentQuorum >= currRequest.minQuorum) {\\r\\n\\r\\n        uint256 penaltyForRequest = currRequest.fee.div(currRequest.selectedOracleCount);\\r\\n\\r\\n        for (i = 0 ; i < len ; i ++) {\\r\\n\\r\\n          if (flag[i] == 1) {\\r\\n            uint256 awardForRequest = currRequest.fee.div(currentQuorum);\\r\\n            address addr = oracles.getOracleByIndex(i);\\r\\n            oracles.increaseOracleAccepted(addr, awardForRequest);\\r\\n            token.transferFrom(owner, addr, awardForRequest + penaltyForRequest);\\r\\n          }\\r\\n        }\\r\\n\\r\\n        currRequest.agreedValue = _valueRetrieved;\\r\\n\\r\\n        if (currRequest.qtype == 0) {     // data aggregator\\r\\n          IDataQuery _feed = IDataQuery(currRequest.contractAddr);\\r\\n          _feed.addRequestAnswer(_valueRetrieved);\\r\\n        }\\r\\n        else if (currRequest.qtype == 1) {     // price aggregator\\r\\n          if (currRequest.contractAddr != address(0x0)) {\\r\\n            IPriceFeed _feed = IPriceFeed(currRequest.contractAddr);\\r\\n            _feed.addRequestAnswer(_priceRetrieved);\\r\\n          }\\r\\n        }\\r\\n\\r\\n        emit UpdatedRequest (\\r\\n          currRequest.id,\\r\\n          currRequest.queries,\\r\\n          currRequest.qtype,\\r\\n          _valueRetrieved,\\r\\n          _priceRetrieved\\r\\n        );\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/Users/abialy/Documents/Projects/Crypto/defi/oracle/DecentralizedOracle/on-chain-oracle/contracts/interfaces/IDEOR.sol\": {\r\n      \"content\": \"// pragma solidity >=0.4.21 <0.6.0;\\r\\npragma solidity >=0.6.6;\\r\\n\\r\\ninterface IDEOR {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address _owner) external view returns (uint256);\\r\\n    function transfer(address _to, uint256 _value) external returns (bool);\\r\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\r\\n    function approve(address _spender, uint256 _value) external returns (bool);\\r\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\r\\n\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\r\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n    event Mint(address indexed to, uint256 amount);\\r\\n    event MintFinished();\\r\\n}\"\r\n    },\r\n    \"/Users/abialy/Documents/Projects/Crypto/defi/oracle/DecentralizedOracle/on-chain-oracle/contracts/interfaces/IDataQuery.sol\": {\r\n      \"content\": \"// pragma solidity >=0.4.21 <0.6.0;\\npragma solidity >=0.6.6;\\n\\ninterface IDataQuery {\\n\\n  struct requestAnswer {\\n      uint256 id;\\n      uint256 timestamp;\\n      string answer;\\n  }\\n\\n  function getLatestAnswer() external returns (string memory);\\n  function getLatestTimestamp() external returns (uint256);\\n  function getTimestamp(uint256 _id) external returns (uint256);\\n  function getAnswer(uint256 _id) external returns (string memory);\\n  function addRequestAnswer(string calldata _answer) external;\\n}\\n\"\r\n    },\r\n    \"/Users/abialy/Documents/Projects/Crypto/defi/oracle/DecentralizedOracle/on-chain-oracle/contracts/interfaces/IOracles.sol\": {\r\n      \"content\": \"// pragma solidity >=0.4.21 <0.6.0;\\r\\npragma solidity >=0.6.6;\\r\\n\\r\\ninterface IOracles {\\r\\n\\r\\n  struct reputation {\\r\\n    string name;\\r\\n    address addr;\\r\\n    uint256 totalAssignedRequest;        //total number of past requests that an oracle has agreed to, both fulfilled and unfulfileed\\r\\n    uint256 totalCompletedRequest;       //total number of past requests that an oracle has fulfileed\\r\\n    uint256 totalAcceptedRequest;        //total number of requests that have been accepted\\r\\n    uint256 totalResponseTime;           //total seconds of response time\\r\\n    uint256 lastActiveTime;              //last active time of the oracle as second\\r\\n    uint256 penalty;                     //amount of penalty payment\\r\\n    uint256 totalEarned;                 //total earned\\r\\n  }\\r\\n\\r\\n  function newOracle (string calldata name, address addr, uint256 requestFee) external ;\\r\\n  function getOracleCount () external returns (uint256);\\r\\n  function isOracleAvailable (address addr) external returns (bool);\\r\\n  function getOracleByIndex (uint256 idx) external returns (address);\\r\\n  function increaseOracleAssigned (address addr, uint256 penalty) external;\\r\\n  function increaseOracleCompleted (address addr, uint256 responseTime) external;\\r\\n  function increaseOracleAccepted (address addr, uint256 earned) external;\\r\\n  function getOracleLastActiveTime (address addr) external returns (uint256);\\r\\n  function updateOracleLastActiveTime (address addr) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/Users/abialy/Documents/Projects/Crypto/defi/oracle/DecentralizedOracle/on-chain-oracle/contracts/interfaces/IPriceFeed.sol\": {\r\n      \"content\": \"// pragma solidity >=0.4.21 <0.6.0;\\npragma solidity >=0.6.6;\\n\\ninterface IPriceFeed {\\n\\n  struct requestAnswer {\\n      uint256 id;\\n      uint256 timestamp;\\n      int256 priceAnswer;\\n  }\\n\\n  function getLatestAnswer() external returns (int256);\\n  function getLatestTimestamp() external returns (uint256);\\n  function getTimestamp(uint256 _id) external returns (uint256);\\n  function getAnswer(uint256 _id) external returns (int256);\\n  function addRequestAnswer(int256 _priceAnswer) external;\\n}\\n\"\r\n    },\r\n    \"/Users/abialy/Documents/Projects/Crypto/defi/oracle/DecentralizedOracle/on-chain-oracle/contracts/interfaces/OracleInterface.sol\": {\r\n      \"content\": \"// pragma solidity >=0.4.21 <0.6.0;\\r\\npragma solidity >=0.6.6;\\r\\n\\r\\ninterface OracleInterface {\\r\\n    struct Request {\\r\\n        uint256 id;                            //request id\\r\\n        string queries;\\r\\n        uint8 qtype;                        //0: data query, 1: price\\r\\n        address contractAddr;               // contract to save result\\r\\n        string agreedValue;                 //value from key\\r\\n        int256 agreedPrice;\\r\\n        uint256 timestamp;                     //Request Timestamp\\r\\n        uint minQuorum;                     //minimum number of responses to receive before declaring final result\\r\\n        uint256 fee;                            //transaction fee\\r\\n        uint selectedOracleCount;                //selected oracle count\\r\\n        mapping(address => string) answers;     //answers provided by the oracles\\r\\n        mapping(address => int256) priceAnswers;     //answers provided by the oracles\\r\\n        mapping(address => uint256) quorum;    //oracles which will query the answer (1=oracle hasn't voted, 2=oracle has voted)\\r\\n    }\\r\\n\\r\\n    struct reputation {\\r\\n        string name;\\r\\n        address addr;\\r\\n        uint256 totalAssignedRequest;        //total number of past requests that an oracle has agreed to, both fulfilled and unfulfileed\\r\\n        uint256 totalCompletedRequest;       //total number of past requests that an oracle has fulfileed\\r\\n        uint256 totalAcceptedRequest;        //total number of requests that have been accepted\\r\\n        uint256 totalResponseTime;           //total seconds of response time\\r\\n        uint256 lastActiveTime;              //last active time of the oracle as second\\r\\n        uint256 penalty;                     //amount of penalty payment\\r\\n        uint256 totalEarned;                 //total earned\\r\\n    }\\r\\n\\r\\n    event NewOracle(address addr);\\r\\n    event NewRequest(uint256 id, string queries, uint8 qtype);\\r\\n    event UpdatedRequest(uint256 id, string queries, uint8 qtype, string agreedValue, int256 agreedPrice);\\r\\n    event DeletedRequest(uint256 id);\\r\\n\\r\\n    function newOracle(string calldata name) external;\\r\\n    function createRequest(string calldata queries, uint8 qtype, address contractAddr) external;\\r\\n    function updateRequest(uint256 _id, string calldata _valueRetrieved, int256 _priceRetrieved) external;\\r\\n}\"\r\n    },\r\n    \"/Users/abialy/Documents/Projects/Crypto/defi/oracle/DecentralizedOracle/on-chain-oracle/contracts/library/Ownable.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\r\\n\\r\\ncontract Ownable {\\r\\n    address public owner;\\r\\n\\r\\n    /**\\r\\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\r\\n    * account.\\r\\n    */\\r\\n    constructor() public {\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n    * @dev Throws if called by any account other than the owner.\\r\\n    */\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n    * @param newOwner The address to transfer ownership to.\\r\\n    */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        if (newOwner != address(0)) {\\r\\n            owner = newOwner;\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"/Users/abialy/Documents/Projects/Crypto/defi/oracle/DecentralizedOracle/on-chain-oracle/contracts/library/Randomizer.sol\": {\r\n      \"content\": \"// pragma solidity >=0.4.21 <0.6.0;\\r\\npragma solidity >=0.6.6;\\r\\n\\r\\n\\r\\n/**\\r\\n * Randomizer to generating psuedo random numbers\\r\\n */\\r\\ncontract Randomizer {\\r\\n    function getRandom(uint gamerange) internal view returns (uint)\\r\\n    {\\r\\n        return\\r\\n            uint(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(\\r\\n                        block.timestamp +\\r\\n                            block.difficulty +\\r\\n                            uint(keccak256(abi.encodePacked(block.coinbase)))\\r\\n                    )\\r\\n                )\\r\\n            ) % gamerange;\\r\\n    }\\r\\n\\r\\n    function getRandom(uint gamerange, uint seed) internal view returns (uint)\\r\\n    {\\r\\n        return\\r\\n            uint(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(\\r\\n                        now +\\r\\n                            block.difficulty +\\r\\n                            uint(\\r\\n                                keccak256(abi.encodePacked(block.coinbase))\\r\\n                            ) +\\r\\n                            seed\\r\\n                    )\\r\\n                )\\r\\n            ) % gamerange;\\r\\n    }\\r\\n\\r\\n    function getRandom() internal view returns (uint) {\\r\\n        return\\r\\n            uint(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(\\r\\n                        block.timestamp +\\r\\n                            block.difficulty +\\r\\n                            uint(keccak256(abi.encodePacked(block.coinbase)))\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/Users/abialy/Documents/Projects/Crypto/defi/oracle/DecentralizedOracle/on-chain-oracle/contracts/library/SafeMathDEOR.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// pragma solidity ^0.7.0;\\r\\npragma solidity >=0.6.6;\\r\\n// pragma solidity >=0.4.21 <0.6.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMathDEOR {\\r\\n  /**\\r\\n    * @dev Returns the addition of two unsigned integers, reverting on\\r\\n    * overflow.\\r\\n    *\\r\\n    * Counterpart to Solidity's `+` operator.\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - Addition cannot overflow.\\r\\n    */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n    * overflow (when the result is negative).\\r\\n    *\\r\\n    * Counterpart to Solidity's `-` operator.\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - Subtraction cannot overflow.\\r\\n    */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n    uint256 c = a - b;\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n    * overflow.\\r\\n    *\\r\\n    * Counterpart to Solidity's `*` operator.\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - Multiplication cannot overflow.\\r\\n    */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n    // benefit is lost if 'b' is also tested.\\r\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n    * division by zero. The result is rounded towards zero.\\r\\n    *\\r\\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n    * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - The divisor cannot be zero.\\r\\n    */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Solidity only automatically asserts when dividing by 0\\r\\n    require(b > 0, \\\"SafeMath: division by zero\\\");\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n    * Reverts when dividing by zero.\\r\\n    *\\r\\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n    * invalid opcode to revert (consuming all remaining gas).\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - The divisor cannot be zero.\\r\\n    */\\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b != 0, \\\"SafeMath: modulo by zero\\\");\\r\\n    return a % b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @dev Returns the ceiling of log_2,\\r\\n    *\\r\\n    */\\r\\n  function log_2(uint256 x) internal pure returns (uint256) {\\r\\n    uint256 idx = 1;\\r\\n    uint256 res = 0;\\r\\n    while (x > idx) {\\r\\n      idx = idx << 1;\\r\\n      res = add(res, 1);\\r\\n    }\\r\\n    return res;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/Users/abialy/Documents/Projects/Crypto/defi/oracle/DecentralizedOracle/on-chain-oracle/contracts/library/Selection.sol\": {\r\n      \"content\": \"// pragma solidity >=0.4.21 <0.6.0;\\r\\npragma solidity >=0.6.6;\\r\\n\\r\\nimport \\\"./Randomizer.sol\\\";\\r\\n\\r\\ncontract Selection is Randomizer {\\r\\n\\r\\n    struct Pair {\\r\\n        uint id;\\r\\n        uint value;\\r\\n    }\\r\\n\\r\\n    function quickSort(Pair[] memory arr, int left, int right) internal pure {\\r\\n        int i = left;\\r\\n        int j = right;\\r\\n        if (i == j) return;\\r\\n        uint pivot = arr[uint(left + (right - left) / 2)].value;\\r\\n        while (i <= j) {\\r\\n            while (arr[uint(i)].value < pivot) i++;\\r\\n            while (pivot < arr[uint(j)].value) j--;\\r\\n            if (i <= j) {\\r\\n                (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);\\r\\n                i++;\\r\\n                j--;\\r\\n            }\\r\\n        }\\r\\n        if (left < j)\\r\\n            quickSort(arr, left, j);\\r\\n        if (i < right)\\r\\n            quickSort(arr, i, right);\\r\\n    }\\r\\n\\r\\n    function getSelectedOracles(uint n) internal view returns (uint[] memory) {\\r\\n        Pair[] memory data = new Pair[](n);\\r\\n        uint[] memory res = new uint[](n);\\r\\n        uint i = 0;\\r\\n        \\r\\n        for (i = 0 ; i < n ; i ++) {\\r\\n            data[i] = Pair(i, getRandom(n));\\r\\n        }\\r\\n\\r\\n        quickSort(data, int(0), int(data.length - 1));\\r\\n        \\r\\n        for (i = 0 ; i < n ; i ++) {\\r\\n            res[i] = data[i].id;\\r\\n        }\\r\\n\\r\\n        return res;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracleAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"DeletedRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"NewOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"queries\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"qtype\",\"type\":\"uint8\"}],\"name\":\"NewRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"queries\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"qtype\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"agreedValue\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"agreedPrice\",\"type\":\"int256\"}],\"name\":\"UpdatedRequest\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"queries\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"qtype\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"}],\"name\":\"createRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"newOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setRequestFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_valueRetrieved\",\"type\":\"string\"},{\"internalType\":\"int256\",\"name\":\"_priceRetrieved\",\"type\":\"int256\"}],\"name\":\"updateRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Oracle","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000063726dae7c57d25e90ec829ce9a5c745ffd984d3000000000000000000000000665985d25f5bee80f3051d93ec5933e16a57cf0e","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}