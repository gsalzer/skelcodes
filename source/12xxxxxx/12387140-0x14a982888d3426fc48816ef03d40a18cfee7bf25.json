{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Links.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.1;\\n\\nimport \\\"./ERC223Burnable.sol\\\";\\nimport \\\"./ERC223Detailed.sol\\\";\\n\\n/**\\n * @title Reference implementation of the ERC223 standard token.\\n */\\ncontract Links is ERC223Detailed, ERC223Burnable {\\n\\n\\tconstructor () public ERC223Detailed(\\\"Smart Links\\\", \\\"LINX\\\", 18) {\\n\\t\\tuint256 initialAmount = 20000000000 * (10**uint256(18));\\n\\t\\tbalances[msg.sender] = balances[msg.sender].add(initialAmount);\\n\\t\\t_totalSupply = _totalSupply.add(initialAmount);\\n\\t\\tbytes memory empty = hex\\\"00000000\\\";\\n\\t\\temit Transfer(address(0), msg.sender, initialAmount, empty);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/ERC223Burnable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.1;\\n\\nimport \\\"./ERC223.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC223} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\ncontract ERC223Burnable is ERC223Token {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 _amount) public {\\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\\n        _totalSupply = _totalSupply.sub(_amount);\\n        \\n        bytes memory empty = hex\\\"00000000\\\";\\n        emit Transfer(msg.sender, address(0), _amount, empty);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC223Detailed.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.1;\\n\\nimport \\\"./ERC223.sol\\\";\\n\\n\\nimport \\\"./IERC223.sol\\\";\\n\\n/**\\n * @title ERC20Detailed token\\n * @dev The decimals are only for visualization purposes.\\n * All the operations are done using the smallest and indivisible token unit,\\n * just as on Ethereum all the operations are done in wei.\\n */\\ncontract ERC223Detailed is IERC223 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @return the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @return the symbol of the token.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @return the number of decimals of the token.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC223.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.1;\\n\\nimport \\\"./IERC223.sol\\\";\\nimport \\\"./IERC223Recipient.sol\\\";\\nimport \\\"../contracts/math/SafeMath.sol\\\";\\nimport \\\"../contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title Reference implementation of the ERC223 standard token.\\n */\\ncontract ERC223Token is IERC223 {\\n    using SafeMath for uint;\\n\\n    /**\\n     * @dev See `IERC223.totalSupply`.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    mapping(address => uint) balances; // List of user balances.\\n\\n    /**\\n     * @dev Transfer the specified amount of tokens to the specified address.\\n     *      Invokes the `tokenFallback` function if the recipient is a contract.\\n     *      The token transfer fails if the recipient is a contract\\n     *      but does not implement the `tokenFallback` function\\n     *      or the fallback function to receive funds.\\n     *\\n     * @param _to    Receiver address.\\n     * @param _value Amount of tokens that will be transferred.\\n     * @param _data  Transaction metadata.\\n     */\\n    function transfer(address _to, uint _value, bytes memory _data) public returns (bool success){\\n        // Standard function transfer similar to ERC20 transfer with no _data .\\n        // Added due to backwards compatibility reasons .\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        if(Address.isContract(_to)) {\\n            IERC223Recipient receiver = IERC223Recipient(_to);\\n            receiver.tokenFallback(msg.sender, _value, _data);\\n        }\\n        emit Transfer(msg.sender, _to, _value, _data);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer the specified amount of tokens to the specified address.\\n     *      This function works the same with the previous one\\n     *      but doesn't contain `_data` param.\\n     *      Added due to backwards compatibility reasons.\\n     *\\n     * @param _to    Receiver address.\\n     * @param _value Amount of tokens that will be transferred.\\n     */\\n    function transfer(address _to, uint _value) public returns (bool success){\\n        bytes memory empty = hex\\\"00000000\\\";\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        if(Address.isContract(_to)) {\\n            IERC223Recipient receiver = IERC223Recipient(_to);\\n            receiver.tokenFallback(msg.sender, _value, empty);\\n        }\\n        emit Transfer(msg.sender, _to, _value, empty);\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Returns balance of the `_owner`.\\n     *\\n     * @param _owner   The address whose balance will be returned.\\n     * @return balance Balance of the `_owner`.\\n     */\\n    function balanceOf(address _owner) public view returns (uint balance) {\\n        return balances[_owner];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IERC223.sol\": {\r\n      \"content\": \"    \\npragma solidity ^0.5.1;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * [ERC1820 registry standard](https://eips.ethereum.org/EIPS/eip-1820) to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See `IERC1820Registry` and\\n * `ERC1820Implementer`.\\n */\\n\\ncontract IERC223 {\\n    /**\\n     * @dev Returns the total supply of the token.\\n     */\\n    uint public _totalSupply;\\n    \\n    /**\\n     * @dev Returns the balance of the `who` address.\\n     */\\n    function balanceOf(address who) public view returns (uint);\\n        \\n    /**\\n     * @dev Transfers `value` tokens from `msg.sender` to `to` address\\n     * and returns `true` on success.\\n     */\\n    function transfer(address to, uint value) public returns (bool success);\\n        \\n    /**\\n     * @dev Transfers `value` tokens from `msg.sender` to `to` address with `data` parameter\\n     * and returns `true` on success.\\n     */\\n    function transfer(address to, uint value, bytes memory data) public returns (bool success);\\n     \\n     /**\\n     * @dev Event that is fired on successful transfer.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint value, bytes data);\\n}\\n\"\r\n    },\r\n    \"contracts/IERC223Recipient.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.1;\\n\\n /**\\n * @title Contract that will work with ERC223 tokens.\\n */\\n \\ncontract IERC223Recipient { \\n/**\\n * @dev Standard ERC223 function that will handle incoming token transfers.\\n *\\n * @param _from  Token sender address.\\n * @param _value Amount of tokens.\\n * @param _data  Transaction metadata.\\n */\\n    function tokenFallback(address _from, uint _value, bytes memory _data) public;\\n}\\n\"\r\n    },\r\n    \"contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract's constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * > It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"Links","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}