// SPDX-License-Identifier: MIT
pragma solidity 0.7.0;

import "./external/UniswapV2Library.sol";
import "./external/UniswapV3Library.sol";
import "./IPLPS.sol";

abstract contract UsingLiquidityProtectionService {
	bool private unProtected = false;
	IPLPS private plps;
	uint64 internal constant HUNDRED_PERCENT = 1e18;
	bytes32 internal constant UNISWAP =
		0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f;
	bytes32 internal constant PANCAKESWAP =
		0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5;
	bytes32 internal constant QUICKSWAP =
		0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f;

	enum UniswapVersion {
		V2,
		V3
	}

	enum UniswapV3Fees {
		_005, // 0.05%
		_03, // 0.3%
		_1 // 1%
	}

	modifier onlyProtectionAdmin() {
		protectionAdminCheck();
		_;
	}

	constructor(address _plps) {
		plps = IPLPS(_plps);
	}

	function LiquidityProtection_setLiquidityProtectionService(IPLPS _plps)
		external
		onlyProtectionAdmin()
	{
		plps = _plps;
	}

	function token_transfer(
		address from,
		address to,
		uint256 amount
	) internal virtual;

	function token_balanceOf(address holder)
		internal
		view
		virtual
		returns (uint256);

	function protectionAdminCheck() internal view virtual;

	function uniswapVariety() internal pure virtual returns (bytes32);

	function uniswapVersion() internal pure virtual returns (UniswapVersion);

	function uniswapFactory() internal pure virtual returns (address);

	function counterToken() internal pure virtual returns (address) {
		return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // WETH
	}

	function uniswapV3Fee() internal pure virtual returns (UniswapV3Fees) {
		return UniswapV3Fees._03;
	}

	function protectionChecker() internal view virtual returns (bool) {
		return ProtectionSwitch_manual();
	}

	function lps() private view returns (IPLPS) {
		return plps;
	}

	function LiquidityProtection_beforeTokenTransfer(
		address _from,
		address _to,
		uint256 _amount
	) internal virtual {
		if (protectionChecker()) {
			if (unProtected) {
				return;
			}
			lps().LiquidityProtection_beforeTokenTransfer(
				getLiquidityPool(),
				_from,
				_to,
				_amount
			);
		}
	}

	function revokeBlocked(address[] calldata _holders, address _revokeTo)
		external
		onlyProtectionAdmin()
	{
		require(
			protectionChecker(),
			"UsingLiquidityProtectionService: protection removed"
		);
		unProtected = true;
		address pool = getLiquidityPool();
		for (uint256 i = 0; i < _holders.length; i++) {
			address holder = _holders[i];
			if (lps().isBlocked(pool, holder)) {
				token_transfer(holder, _revokeTo, token_balanceOf(holder));
			}
		}
		unProtected = false;
	}

	function LiquidityProtection_unblock(address[] calldata _holders)
		external
		onlyProtectionAdmin()
	{
		require(
			protectionChecker(),
			"UsingLiquidityProtectionService: protection removed"
		);
		address pool = getLiquidityPool();
		for (uint256 i = 0; i < _holders.length; i++) {
			lps().unblock(pool, _holders[i]);
		}
	}

	function disableProtection() external onlyProtectionAdmin() {
		unProtected = true;
	}

	function isProtected() public view returns (bool) {
		return not(unProtected);
	}

	function ProtectionSwitch_manual() internal view returns (bool) {
		return isProtected();
	}

	function ProtectionSwitch_timestamp(uint256 _timestamp)
		internal
		view
		returns (bool)
	{
		return not(passed(_timestamp));
	}

	function ProtectionSwitch_block(uint256 _block)
		internal
		view
		returns (bool)
	{
		return not(blockPassed(_block));
	}

	function blockPassed(uint256 _block) internal view returns (bool) {
		return _block < block.number;
	}

	function passed(uint256 _timestamp) internal view returns (bool) {
		return _timestamp < block.timestamp;
	}

	function not(bool _condition) internal pure returns (bool) {
		return !_condition;
	}

	function feeToUint24(UniswapV3Fees _fee) internal pure returns (uint24) {
		if (_fee == UniswapV3Fees._03) return 3000;
		if (_fee == UniswapV3Fees._005) return 500;
		return 10000;
	}

	function getLiquidityPool() public view returns (address) {
		if (uniswapVersion() == UniswapVersion.V2) {
			return
				UniswapV2Library.pairFor(
					uniswapVariety(),
					uniswapFactory(),
					address(this),
					counterToken()
				);
		}
		require(
			uniswapVariety() == UNISWAP,
			"LiquidityProtection: uniswapVariety() can only be UNISWAP for V3."
		);
		return
			UniswapV3Library.computeAddress(
				uniswapFactory(),
				UniswapV3Library.getPoolKey(
					address(this),
					counterToken(),
					feeToUint24(uniswapV3Fee())
				)
			);
	}
}

