{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-05-21\r\n*/\r\n\r\npragma solidity ^0.6.12;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n }\r\n\r\ncontract Ownable {\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender==owner,\"only owner allowed\");\r\n        _;\r\n    }\r\n    \r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    \r\n    \r\n    address payable owner;\r\n    address payable newOwner;\r\n\r\n    function changeOwner(address payable _newOwner) public onlyOwner {\r\n        require(_newOwner!=address(0));\r\n        newOwner = _newOwner;\r\n    }\r\n    \r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner, \"only new owner allowed\");\r\n         emit OwnershipTransferred(\r\n            owner,\r\n            newOwner\r\n        );\r\n        owner = newOwner;\r\n        \r\n    }\r\n}\r\n\r\nabstract contract ERC20 {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) view public virtual returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public virtual returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public virtual returns (bool success);\r\n    function approve(address _spender, uint256 _value) public virtual returns (bool success);\r\n    function allowance(address _owner, address _spender) view public virtual returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Token is Ownable,  ERC20 {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    \r\n    string public symbol;\r\n    string public name;\r\n    uint8 public decimals;\r\n    \r\n    mapping (address=>uint256) balances;\r\n    mapping (address=>mapping (address=>uint256)) allowed;\r\n    \r\n \r\n    uint256 public circulationSupply;\r\n    uint256 public stakeFarmSupply;\r\n    uint256 public teamAdvisorSupply;\r\n    uint256 public devFundSupply;\r\n    uint256 public marketingSupply;\r\n    uint256 public resverdSupply;\r\n    \r\n    uint256 public teamCounter; \r\n    uint256 public devFundCounter;\r\n    \r\n    mapping(uint256 => uint256) public  stakeFarmSupplyUnlockTime;\r\n    mapping(uint256 => uint256) public  stakeFarmUnlockSupply;\r\n    \r\n    mapping(uint256 => uint256) public  teamAdvisorSupplyUnlockTime;\r\n    mapping(uint256 => uint256) public  teamAdvisorSupplyUnlockSupply;\r\n    \r\n    mapping(uint256 => uint256) public  devFundSupplyUnlockTime;\r\n    mapping(uint256 => uint256) public  devFundSupplyUnlockSupply;\r\n    \r\n    mapping(uint256 => uint256) public  marketingSupplyUnlockTime;\r\n    mapping(uint256 => uint256) public  marketingUnlockSupply;\r\n    \r\n    mapping(uint256 => uint256) public  resverdSupplyUnlockTime;\r\n    mapping(uint256 => uint256) public  resverdUnlockSupply;\r\n    \r\n\t\r\n\tuint256 constant public maxSupply = 5000000 ether;\r\n\tuint256 constant public supplyPerYear =  1000000 ether;\r\n\tuint256 constant public oneYear = 31536000;\r\n\tuint256 constant public teamAdvisorPeriod = 5256000;\r\n\tuint256 constant public devFundPeriod = 2628000;\r\n\t\r\n\r\n    EnumerableSet.AddressSet private farmAddress;\r\n    address public stakeAddress;\r\n\r\n   \r\n    function balanceOf(address _owner) view public virtual override returns (uint256 balance) {return balances[_owner];}\r\n    \r\n    \r\n    function transfer(address _to, uint256 _amount) public virtual override returns (bool success) {\r\n      require (balances[msg.sender]>=_amount&&_amount>0&&balances[_to]+_amount>balances[_to]);\r\n      balances[msg.sender]-=_amount;\r\n      balances[_to]+=_amount;\r\n      emit Transfer(msg.sender,_to,_amount);\r\n      return true;\r\n    }\r\n  \r\n    function transferFrom(address _from,address _to,uint256 _amount) public virtual override returns (bool success) {\r\n      require (balances[_from]>=_amount&&allowed[_from][msg.sender]>=_amount&&_amount>0&&balances[_to]+_amount>balances[_to]);\r\n      balances[_from]-=_amount;\r\n      allowed[_from][msg.sender]-=_amount;\r\n      balances[_to]+=_amount;\r\n      emit Transfer(_from, _to, _amount);\r\n      return true;\r\n    }\r\n  \r\n    function approve(address _spender, uint256 _amount) public virtual override returns (bool success) {\r\n      allowed[msg.sender][_spender]=_amount;\r\n      emit Approval(msg.sender, _spender, _amount);\r\n      return true;\r\n    }\r\n    \r\n    function allowance(address _owner, address _spender) view public virtual override returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    function burn(uint256 _amount) public onlyOwner returns (bool success) {\r\n      require(_amount <= totalSupply, \"The burning value cannot be greater than the Total Supply!\");\r\n      address addressToBurn = 0x2323232323232323232323232323232323232323;\r\n      uint256 feeToOwner = _amount * 3 / 100; // 3%\r\n      transfer(addressToBurn, _amount - feeToOwner); // burn\r\n      transfer(owner, feeToOwner); // transfer to owner address\r\n      return true;\r\n    }\r\n\r\n    function mint(address _to, uint256 _amount) private returns (bool) {\r\n      require((_amount + totalSupply) <= maxSupply, \"The total supply cannot exceed 5.000.000\");\r\n      totalSupply = totalSupply + _amount;\r\n      balances[_to] = balances[_to] + _amount;\r\n      emit Transfer(address(0), _to, _amount);\r\n      return true;\r\n    }\r\n    \r\n    \r\n    function mintCirculationSupply(address to,uint256 _amount) external onlyOwner returns(bool){\r\n        require(circulationSupply >= _amount);    \r\n        mint(to,_amount);\r\n        circulationSupply -= _amount;\r\n        return true;\r\n    }\r\n    \r\n    function mintMarketingSupply(address to,uint256 _amount) external onlyOwner returns(bool){\r\n        for(uint i = 1;i <= 4 ; i++){\r\n            if(marketingSupplyUnlockTime[i] < now && marketingUnlockSupply[i] != 0){\r\n                marketingSupply += marketingUnlockSupply[i];\r\n                marketingUnlockSupply[i] = 0;\r\n            }\r\n            if(marketingSupplyUnlockTime[i] >  now)\r\n              break;\r\n        }\r\n        require(marketingSupply >= _amount);    \r\n        mint(to,_amount);\r\n        marketingSupply -= _amount;\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function setFarmAddress(address[] memory _farm) external onlyOwner returns(bool){\r\n        for(uint256 i= 0 ;i< _farm.length;i++)\r\n        {\r\n            farmAddress.add(_farm[i]);\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function setStakeAddress(address _stake) external onlyOwner returns(bool){\r\n        stakeAddress = _stake;\r\n        return true;\r\n    }\r\n    \r\n    function mintStakeFarmSupply(address to,uint256 _amount) external returns(uint256){\r\n        require(farmAddress.contains(msg.sender) || msg.sender == stakeAddress,\"err farm or stake address only\");\r\n        for(uint i = 1;i <= 4 ; i++){\r\n            if(stakeFarmSupplyUnlockTime[i] < now && stakeFarmUnlockSupply[i] != 0){\r\n                stakeFarmSupply += stakeFarmUnlockSupply[i];\r\n                stakeFarmUnlockSupply[i] = 0;\r\n            }\r\n            if(stakeFarmSupplyUnlockTime[i] >  now)\r\n              break;\r\n        }\r\n        if(_amount > stakeFarmSupply){\r\n            _amount = stakeFarmSupply;\r\n        }    \r\n        mint(to,_amount);\r\n        stakeFarmSupply -= _amount;\r\n        return _amount;\r\n    }\r\n    \r\n    \r\n    function mintReservedSupply(address to,uint256 _amount) external onlyOwner returns(bool){\r\n        for(uint i = 1;i <= 4 ; i++){\r\n            if(resverdSupplyUnlockTime[i] < now && resverdUnlockSupply[i] != 0){\r\n                resverdSupply += resverdUnlockSupply[i];\r\n                resverdUnlockSupply[i] = 0;\r\n            }\r\n            if(resverdSupplyUnlockTime[i] >  now)\r\n              break;\r\n        }\r\n        require(resverdSupply >= _amount);    \r\n        mint(to,_amount);\r\n        resverdSupply -= _amount;\r\n        return true;\r\n    }\r\n    \r\n    // for loop dont take too much cost as it only loop to 25\r\n    function mintDevFundSupply(address to,uint256 _amount) external onlyOwner returns(bool){\r\n        for(uint i = 1;i <= devFundCounter ; i++){\r\n            if(devFundSupplyUnlockTime[i] < now && devFundSupplyUnlockSupply[i] != 0){\r\n                devFundSupply += devFundSupplyUnlockSupply[i];\r\n                devFundSupplyUnlockSupply[i] = 0;\r\n            }\r\n            if(devFundSupplyUnlockTime[i] >  now)\r\n              break;\r\n        }\r\n        require(devFundSupply >= _amount);    \r\n        mint(to,_amount);\r\n        devFundSupply -= _amount;\r\n        return true;\r\n    }\r\n    \r\n    function mintTeamAdvisorFundSupply(address to,uint256 _amount) external onlyOwner returns(bool){\r\n        for(uint i = 1;i <= teamCounter ; i++){\r\n            if(teamAdvisorSupplyUnlockTime[i] < now && teamAdvisorSupplyUnlockSupply[i] != 0){\r\n                teamAdvisorSupply += teamAdvisorSupplyUnlockSupply[i];\r\n                teamAdvisorSupplyUnlockSupply[i] = 0;\r\n            }\r\n            if(teamAdvisorSupplyUnlockTime[i] >  now)\r\n              break;\r\n        }\r\n        require(teamAdvisorSupply >= _amount);    \r\n        mint(to,_amount);\r\n        teamAdvisorSupply -= _amount;\r\n        return true;\r\n    }\r\n\r\n    \r\n    \r\n    function _initSupply() internal returns (bool){\r\n        \r\n        circulationSupply = 370000 ether;\r\n        stakeFarmSupply =  350000 ether;\r\n        marketingSupply = 50000 ether;\r\n        resverdSupply = 10000 ether;\r\n        \r\n        uint256 currentTime = now;\r\n        uint256 tempAdvisor = 100000 ether;\r\n        uint256 tempDev = 120000 ether;\r\n    \r\n        for(uint j = 1;j <= 6 ; j++){\r\n            teamCounter+=1;\r\n            teamAdvisorSupplyUnlockTime[teamCounter] = currentTime+(teamAdvisorPeriod*j);\r\n            teamAdvisorSupplyUnlockSupply[teamCounter] = tempAdvisor/6;\r\n            \r\n        }\r\n        \r\n        for(uint k = 1;k <= 5 ; k++){\r\n            devFundCounter+= 1;\r\n            devFundSupplyUnlockTime[devFundCounter] = currentTime+(devFundPeriod*k);\r\n            devFundSupplyUnlockSupply[devFundCounter] = tempDev/5;\r\n            \r\n        }\r\n        \r\n        \r\n        for(uint i = 1;i <= 4 ; i++){\r\n            currentTime += oneYear;\r\n            \r\n            stakeFarmSupplyUnlockTime[i] = currentTime;\r\n            stakeFarmUnlockSupply[i] = 720000 ether;\r\n         \r\n            marketingSupplyUnlockTime[i] = currentTime;\r\n            marketingUnlockSupply[i] = 50000 ether;\r\n            \r\n            resverdSupplyUnlockTime[i] = currentTime;\r\n            resverdUnlockSupply[i] = 10000 ether;\r\n            \r\n            \r\n           for(uint j = 1;j <= 6 ; j++){\r\n                teamCounter+=1;\r\n                teamAdvisorSupplyUnlockTime[teamCounter] = currentTime+(teamAdvisorPeriod*j);\r\n                teamAdvisorSupplyUnlockSupply[teamCounter] = tempAdvisor/6;\r\n            \r\n           }\r\n        \r\n            for(uint k = 1;k <= 5 ; k++){\r\n                devFundCounter+= 1;\r\n                devFundSupplyUnlockTime[devFundCounter] = currentTime+(devFundPeriod*k);\r\n                devFundSupplyUnlockSupply[devFundCounter] = tempDev/5;\r\n                \r\n            }\r\n             \r\n        }\r\n            \r\n \r\n    }\r\n   \r\n}\r\n\r\ncontract Remit is Token{\r\n    \r\n    \r\n    \r\n    constructor() public{\r\n      symbol = \"REMIT\";\r\n      name = \"Remit\";\r\n      decimals = 18;\r\n      totalSupply = 0;  \r\n      owner = msg.sender;\r\n      balances[owner] = totalSupply;\r\n      _initSupply();\r\n      \r\n    }\r\n    \r\n    \r\n\r\n    receive () payable external {\r\n      require(msg.value>0);\r\n      owner.transfer(msg.value);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circulationSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFundCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFundPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFundSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"devFundSupplyUnlockSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"devFundSupplyUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"marketingSupplyUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"marketingUnlockSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintCirculationSupply\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintDevFundSupply\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintMarketingSupply\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintReservedSupply\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintStakeFarmSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintTeamAdvisorFundSupply\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resverdSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"resverdSupplyUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"resverdUnlockSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_farm\",\"type\":\"address[]\"}],\"name\":\"setFarmAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stake\",\"type\":\"address\"}],\"name\":\"setStakeAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeFarmSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeFarmSupplyUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeFarmUnlockSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyPerYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamAdvisorPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamAdvisorSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamAdvisorSupplyUnlockSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamAdvisorSupplyUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Remit","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5d78ad243727850b26dbe716e194ecb45fec459f198fbacf2547f8d7b039d0f1"}]}