{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CouncilNFT.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * > Note: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\n\\n/**\\n * @title Custom NFT contract based off ERC721 but restricted by access control.\\n * @dev made for https://sips.synthetix.io/sips/sip-93\\n */\\ncontract ThalesCouncil is Ownable {\\n    // Event that is emitted when a new SpartanCouncil token is minted\\n    event Mint(uint256 indexed tokenId, address to);\\n    // Event that is emitted when an existing SpartanCouncil token is burned\\n    event Burn(uint256 indexed tokenId);\\n    // Event that is emitted when an existing SpartanCouncil token is transfer\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    // Event that is emitted when an metadata is added\\n    event MetadataChanged(uint256 tokenId, string tokenURI);\\n\\n    // Array of token ids\\n    uint256[] public tokens;\\n    // Map between a owner and their token\\n    mapping(address => uint256) public tokenOwned;\\n    // Maps a token to the owner address\\n    mapping(uint256 => address) public tokenOwner;\\n    // Optional mapping for token URIs\\n    mapping(uint256 => string) public tokenURIs;\\n    // Token name\\n    string public name;\\n    // Token symbol\\n    string public symbol;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     * @param _name the name of the token\\n     * @param _symbol the symbol of the token\\n     */\\n    constructor(string memory _name, string memory _symbol) public {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /**\\n     * @dev Modifier to check that an address is not the \\\"0\\\" address\\n     * @param to address the address to check\\n     */\\n    modifier isValidAddress(address to) {\\n        require(to != address(0), \\\"Method called with the zero address\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Function to retrieve whether an address owns a token\\n     * @param owner address the address to check the balance of\\n     */\\n    function balanceOf(address owner) public view isValidAddress(owner) returns (uint256) {\\n        if (tokenOwned[owner] > 0) {\\n            return 1;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Function to check the owner of a token\\n     * @param tokenId uint256 ID of the token to retrieve the owner for\\n     */\\n    function ownerOf(uint256 tokenId) public view returns (address) {\\n        return tokenOwner[tokenId];\\n    }\\n\\n    /**\\n     * @dev Transfer function to assign a token to another address\\n     * Reverts if the address already owns a token\\n     * @param from address the address that currently owns the token\\n     * @param to address the address to assign the token to\\n     * @param tokenId uint256 ID of the token to transfer\\n     */\\n    function transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public isValidAddress(to) onlyOwner {\\n        require(tokenOwned[to] == 0, \\\"Destination address already owns a token\\\");\\n\\n        tokenOwned[from] = 0;\\n        tokenOwned[to] = tokenId;\\n\\n        tokenOwner[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Mint function to mint a new token given a tokenId and assign it to an address\\n     * Reverts if the tokenId is 0 or the token already exist\\n     * @param to address the address to assign the token to\\n     * @param tokenId uint256 ID of the token to mint\\n     */\\n    function mint(address to, uint256 tokenId) public onlyOwner isValidAddress(to) {\\n        require(tokenId != 0, \\\"Token ID must be greater than 0\\\");\\n        require(tokenOwner[tokenId] == address(0), \\\"ERC721: token already minted\\\");\\n\\n        tokens.push(tokenId);\\n        tokenOwned[to] = tokenId;\\n        tokenOwner[tokenId] = to;\\n\\n        emit Mint(tokenId, to);\\n    }\\n\\n    /**\\n     * @dev Burn function to remove a given tokenId\\n     * Reverts if the token ID does not exist.\\n     * @param tokenId uint256 ID of the token to burn\\n     */\\n    function burn(uint256 tokenId) public onlyOwner {\\n        require(tokenOwner[tokenId] != address(0), \\\"ERC721: token does not exist\\\");\\n\\n        address previousOwner = tokenOwner[tokenId];\\n\\n        tokenOwned[previousOwner] = 0;\\n        tokenOwner[tokenId] = address(0);\\n\\n        uint256 lastElement = tokens[tokens.length - 1];\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            if (tokens[i] == tokenId) {\\n                tokens[i] = lastElement;\\n            }\\n        }\\n\\n        tokens.pop;\\n\\n        // Clear metadata (if any)\\n        if (bytes(tokenURIs[tokenId]).length != 0) {\\n            delete tokenURIs[tokenId];\\n        }\\n\\n        emit Burn(tokenId);\\n    }\\n\\n    /**\\n     * @dev Function to get the total supply of tokens currently available\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return tokens.length;\\n    }\\n\\n    /**\\n     * @dev Function to get the token URI for a given token.\\n     * Reverts if the token ID does not exist.\\n     * @param tokenId uint256 ID of the token to retrieve the uri for\\n     */\\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\\n        require(tokenOwner[tokenId] != address(0), \\\"ERC721: token does not exist\\\");\\n        string memory _tokenURI = tokenURIs[tokenId];\\n        return _tokenURI;\\n    }\\n\\n    /**\\n     * @dev Function to set the token URI for a given token.\\n     * Reverts if the token ID does not exist.\\n     * @param tokenId uint256 ID of the token to set its URI\\n     * @param uri string URI to assign\\n     */\\n    function setTokenURI(uint256 tokenId, string memory uri) public onlyOwner {\\n        require(tokenOwner[tokenId] != address(0), \\\"ERC721: token does not exist\\\");\\n        tokenURIs[tokenId] = uri;\\n        emit MetadataChanged(tokenId, uri);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenURI\",\"type\":\"string\"}],\"name\":\"MetadataChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenOwned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenURIs\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ThalesCouncil","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000e5468616c657320436f756e63696c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000654432d4e46540000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}