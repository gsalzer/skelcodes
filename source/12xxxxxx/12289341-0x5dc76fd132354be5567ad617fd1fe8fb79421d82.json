{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/WrapMultisig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.8.0;\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"./base/WrapManager.sol\\\";\\nimport \\\"./interfaces/ERC721TokenReceiver.sol\\\";\\n\\n/// @title Wrap protocol locking contract, based on Gnosis Safe contract work\\ncontract WrapMultisig is MultisigManager, ERC721TokenReceiver {\\n    using SafeMath for uint256;\\n    using ECDSA for bytes32;\\n\\n    string public constant NAME = \\\"Wrap multisig\\\";\\n    string public constant VERSION = \\\"1.0.0\\\";\\n\\n    bytes4 private constant ERC20_TRANSFER_SELECTOR =\\n        bytes4(keccak256(bytes(\\\"transferFrom(address,address,uint256)\\\")));\\n\\n    bytes4 private constant ERC721_SAFE_TRANSFER_SELECTOR =\\n        bytes4(keccak256(bytes(\\\"safeTransferFrom(address,address,uint256)\\\")));\\n\\n    //keccak256(\\n    //    \\\"EIP712Domain(address verifyingContract)\\\"\\n    //);\\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\\n        0x035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749;\\n\\n    //keccak256(\\n    //    \\\"WrapTx(address to,uint256 value,bytes data,string tezosOperation)\\\"\\n    //);\\n    bytes32 private constant UNWRAP_TX_TYPEHASH =\\n        0x987804e036e2c4c5e32f45ccae87d65fb92de3f7d16998a7fa3910a01da2ab53;\\n\\n    mapping(string => bool) internal tezosOperations;\\n\\n    event ExecutionFailure(bytes32 txHash);\\n    event ExecutionSuccess(bytes32 txHash);\\n    event ERC20WrapAsked(\\n        address user,\\n        address token,\\n        uint256 amount,\\n        string tezosDestinationAddress\\n    );\\n    event ERC721WrapAsked(\\n        address user,\\n        address token,\\n        uint256 tokenId,\\n        string tezosDestinationAddress\\n    );\\n\\n    bytes32 public domainSeparator;\\n\\n    /// @notice The administrator will be allowed to modify multisig members and quorum\\n    /// @param _administrator Administrator of the multisig\\n    constructor(address _administrator) {\\n        require(\\n            _administrator != address(0),\\n            \\\"WRAP: INVALID_ADMINISTRATOR_PROVIDED\\\"\\n        );\\n        administrator = _administrator;\\n    }\\n\\n    /// @notice Initialize multisig members and threshold\\n    /// @dev This function can only be called once and set the domain separator\\n    /// @param owners Initial members of the multisig\\n    /// @param threshold Threshold of the multisig\\n    function setup(address[] calldata owners, uint256 threshold)\\n        external\\n        authorized\\n    {\\n        require(domainSeparator == 0, \\\"WRAP: DOMAIN_SEPARATOR_ALREADY_SET\\\");\\n        domainSeparator = keccak256(\\n            abi.encode(DOMAIN_SEPARATOR_TYPEHASH, this)\\n        );\\n        _setup(owners, threshold);\\n    }\\n\\n    /// @notice Transfer ERC20 tokens to the custody on behalf of the user\\n    /// @param token Token contract address\\n    /// @param amount Amount to put in custody\\n    /// @param tezosAddress Destination address of the wrap on Tezos blockchain\\n    function wrapERC20(\\n        address token,\\n        uint256 amount,\\n        string calldata tezosAddress\\n    ) external returns (bool success) {\\n        require(amount > 0, \\\"WRAP: INVALID_AMOUNT\\\");\\n        _erc20SafeTransferFrom(token, msg.sender, address(this), amount);\\n        emit ERC20WrapAsked(msg.sender, token, amount, tezosAddress);\\n        return true;\\n    }\\n\\n    function _erc20SafeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) private {\\n        (bool success, bytes memory data) =\\n            token.call(\\n                abi.encodeWithSelector(ERC20_TRANSFER_SELECTOR, from, to, value)\\n            );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"WRAP: ERC20_TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    /// @notice Transfer ERC721 tokens to the custody on behalf of the user\\n    /// @param token Token contract address\\n    /// @param tokenId Id of the NFT to transfer\\n    /// @param tezosAddress Destination address of the wrap on Tezos blockchain\\n    function wrapERC721(\\n        address token,\\n        uint256 tokenId,\\n        string calldata tezosAddress\\n    ) external returns (bool success) {\\n        _erc721SafeTransferFrom(token, msg.sender, address(this), tokenId);\\n        emit ERC721WrapAsked(msg.sender, token, tokenId, tezosAddress);\\n        return true;\\n    }\\n\\n    function _erc721SafeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) private {\\n        (bool success, bytes memory data) =\\n            token.call(\\n                abi.encodeWithSelector(\\n                    ERC721_SAFE_TRANSFER_SELECTOR,\\n                    from,\\n                    to,\\n                    tokenId\\n                )\\n            );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"WRAP: ERC721_TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    /// @notice Allow to execute an unwrap transaction signed by multisig members\\n    /// @dev tezosOperation is used as a nonce to protect against replay attacks\\n    /// @param to Destination address of the transaction\\n    /// @param value Ether value\\n    /// @param data Data paylaod\\n    /// @param tezosOperation Identifier of the tezos operation used to burn corresponding wrapped assets\\n    /// @param signatures Packed signature data\\n    function execTransaction(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        string calldata tezosOperation,\\n        bytes calldata signatures\\n    ) external returns (bool success) {\\n        require(\\n            tezosOperations[tezosOperation] == false,\\n            \\\"WRAP: TRANSACTION_ALREADY_PROCESSED\\\"\\n        );\\n        tezosOperations[tezosOperation] = true;\\n        bytes memory txHashData =\\n            encodeTransactionData(to, value, data, tezosOperation);\\n        bytes32 txHash = keccak256(txHashData);\\n        _checkSignatures(txHash, signatures);\\n        success = _execute(to, value, data, gasleft());\\n        if (success) emit ExecutionSuccess(txHash);\\n        else emit ExecutionFailure(txHash);\\n    }\\n\\n    function _execute(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        uint256 txGas\\n    ) internal returns (bool success) {\\n        assembly {\\n            success := call(\\n                txGas,\\n                to,\\n                value,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0\\n            )\\n        }\\n    }\\n\\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`\\n    /// @notice Make sure to perform a bounds check for @param pos, to avoid out of bounds access on @param signatures\\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\\n    /// @param signatures concatenated rsv signatures\\n    /// @return v v\\n    /// @return r r\\n    /// @return s s\\n    function _signatureSplit(bytes memory signatures, uint256 pos)\\n        internal\\n        pure\\n        returns (\\n            uint8 v,\\n            bytes32 r,\\n            bytes32 s\\n        )\\n    {\\n        // The signature format is a compact form of:\\n        //   {bytes32 r}{bytes32 s}{uint8 v}\\n        // Compact means, uint8 is not padded to 32 bytes.\\n        assembly {\\n            let signaturePos := mul(0x41, pos)\\n            r := mload(add(signatures, add(signaturePos, 0x20)))\\n            s := mload(add(signatures, add(signaturePos, 0x40)))\\n            // Here we are loading the last 32 bytes, including 31 bytes\\n            // of 's'. There is no 'mload8' to do this.\\n            //\\n            // 'byte' is not working due to the Solidity parser, so lets\\n            // use the second best option, 'and'\\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\\n        }\\n    }\\n\\n    /// @dev Checks whether the signature provided is valid for the provided hash. Will revert otherwise.\\n    /// @param dataHash Hash of the data\\n    /// @param signatures Signature data that should be verified.\\n    function _checkSignatures(bytes32 dataHash, bytes memory signatures)\\n        internal\\n        view\\n    {\\n        uint256 _threshold = threshold;\\n        require(_threshold > 0, \\\"WRAP: THRESHOLD_NOT_DEFINED\\\");\\n        require(\\n            signatures.length >= _threshold.mul(65),\\n            \\\"WRAP: SIGNATURES_DATA_TOO_SHORT\\\"\\n        );\\n        address lastOwner = address(0);\\n        address currentOwner;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        uint256 i;\\n        for (i = 0; i < _threshold; i++) {\\n            (v, r, s) = _signatureSplit(signatures, i);\\n            currentOwner = dataHash.toEthSignedMessageHash().recover(v, r, s);\\n            require(\\n                currentOwner > lastOwner &&\\n                    owners[currentOwner] != address(0) &&\\n                    currentOwner != SENTINEL_OWNERS,\\n                \\\"WRAP: INVALID_OWNER_PROVIDED\\\"\\n            );\\n            lastOwner = currentOwner;\\n        }\\n    }\\n\\n    /// @notice Returns the bytes that are hashed to be signed by owners\\n    /// @param to Destination address\\n    /// @param value Ether value\\n    /// @param data Data payload\\n    /// @param tezosOperation Identifier of the tezos operation used to burn corresponding wrapped assets\\n    /// @return Transaction hash bytes\\n    function encodeTransactionData(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        string memory tezosOperation\\n    ) public view returns (bytes memory) {\\n        bytes32 wrapTxHash =\\n            keccak256(\\n                abi.encode(\\n                    UNWRAP_TX_TYPEHASH,\\n                    to,\\n                    value,\\n                    keccak256(data),\\n                    tezosOperation\\n                )\\n            );\\n        return\\n            abi.encodePacked(\\n                bytes1(0x19),\\n                bytes1(0x01),\\n                domainSeparator,\\n                wrapTxHash\\n            );\\n    }\\n\\n    /// @notice Returns hash to be signed by owners\\n    /// @param to Destination address\\n    /// @param value Ether value\\n    /// @param data Data payload\\n    /// @param tezosOperation Identifier of the tezos operation used to burn corresponding wrapped assets\\n    /// @return Transaction hash\\n    function getTransactionHash(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        string memory tezosOperation\\n    ) public view returns (bytes32) {\\n        return\\n            keccak256(encodeTransactionData(to, value, data, tezosOperation));\\n    }\\n\\n    /// @notice Check if an unwrap were already processed\\n    /// @param tezosOperation Identifier to check\\n    /// @return true if already processed, false otherwise\\n    function isTezosOperationProcessed(string memory tezosOperation)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return tezosOperations[tezosOperation];\\n    }\\n\\n    /// @notice Allow ERC721 safe transfers\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        return 0x150b7a02;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/WrapManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/// @title MultisigManager - Manages a set of owners and a threshold to perform actions\\n/// @notice Owners and threshold is managed by the administrator\\ncontract MultisigManager {\\n    event AddedOwner(address owner);\\n    event RemovedOwner(address owner);\\n    event ChangedThreshold(uint256 threshold);\\n\\n    address internal constant SENTINEL_OWNERS = address(0x1);\\n\\n    address administrator;\\n    mapping(address => address) internal owners;\\n    uint256 ownerCount;\\n    uint256 internal threshold;\\n\\n    modifier authorized() {\\n        require(\\n            msg.sender == administrator,\\n            \\\"WRAP: METHOD_CAN_ONLY_BE_CALLED_BY_ADMINISTRATOR\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @dev Setup function sets initial storage of contract\\n    /// @param _owners List of owners\\n    /// @param _threshold Number of required confirmations for a Wrap transaction\\n    function _setup(address[] memory _owners, uint256 _threshold) internal {\\n        require(threshold == 0, \\\"WRAP: CONTRACT_ALREADY_SETUP\\\");\\n        require(\\n            _threshold <= _owners.length,\\n            \\\"WRAP: THRESHOLD_CANNOT_EXCEED_OWNER_COUNT\\\"\\n        );\\n        require(_threshold >= 1, \\\"WRAP: THRESHOLD_NEEED_TO_BE_GREETER_THAN_0\\\");\\n        address currentOwner = SENTINEL_OWNERS;\\n        for (uint256 i = 0; i < _owners.length; i++) {\\n            address owner = _owners[i];\\n            require(\\n                owner != address(0) && owner != SENTINEL_OWNERS,\\n                \\\"WRAP: INVALID_OWNER_PROVIDED\\\"\\n            );\\n            require(\\n                owners[owner] == address(0),\\n                \\\"WRAP: DUPLICATE_OWNER_ADDRESS_PROVIDED\\\"\\n            );\\n            owners[currentOwner] = owner;\\n            currentOwner = owner;\\n        }\\n        owners[currentOwner] = SENTINEL_OWNERS;\\n        ownerCount = _owners.length;\\n        threshold = _threshold;\\n    }\\n\\n    /// @dev Allows to add a new owner and update the threshold at the same time\\n    /// @notice Adds the owner `owner` and updates the threshold to `_threshold`\\n    /// @param owner New owner address\\n    /// @param _threshold New threshold\\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\\n        public\\n        authorized\\n    {\\n        require(\\n            owner != address(0) && owner != SENTINEL_OWNERS,\\n            \\\"WRAP: INVALID_OWNER_ADDRESS_PROVIDED\\\"\\n        );\\n        require(\\n            owners[owner] == address(0),\\n            \\\"WRAP: ADDRESS_IS_ALREADY_AN_OWNER\\\"\\n        );\\n        owners[owner] = owners[SENTINEL_OWNERS];\\n        owners[SENTINEL_OWNERS] = owner;\\n        ownerCount++;\\n        emit AddedOwner(owner);\\n        if (threshold != _threshold) changeThreshold(_threshold);\\n    }\\n\\n    /// @dev Allows to remove an owner and update the threshold at the same time\\n    /// @notice Removes the owner `owner` and updates the threshold to `_threshold`\\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\\n    /// @param owner Owner address to be removed\\n    /// @param _threshold New threshold\\n    function removeOwner(\\n        address prevOwner,\\n        address owner,\\n        uint256 _threshold\\n    ) public authorized {\\n        require(\\n            ownerCount - 1 >= _threshold,\\n            \\\"WRAP: NEW_OWNER_COUNT_NEEDS_TO_BE_LONGER_THAN_THRESHOLD\\\"\\n        );\\n        require(\\n            owner != address(0) && owner != SENTINEL_OWNERS,\\n            \\\"WRAP: INVALID_OWNER_ADDRESS_PROVIDED\\\"\\n        );\\n        require(\\n            owners[prevOwner] == owner,\\n            \\\"WRAP: INVALID_PREV_OWNER_OWNER_PAIR_PROVIDED\\\"\\n        );\\n        owners[prevOwner] = owners[owner];\\n        owners[owner] = address(0);\\n        ownerCount--;\\n        emit RemovedOwner(owner);\\n        if (threshold != _threshold) changeThreshold(_threshold);\\n    }\\n\\n    /// @dev Allows to swap/replace an owner with another address\\n    /// @notice Replaces the owner `oldOwner` with `newOwner`\\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\\n    /// @param oldOwner Owner address to be replaced\\n    /// @param newOwner New owner address\\n    function swapOwner(\\n        address prevOwner,\\n        address oldOwner,\\n        address newOwner\\n    ) public authorized {\\n        require(\\n            newOwner != address(0) && newOwner != SENTINEL_OWNERS,\\n            \\\"WRAP: INVALID_OWNER_ADDRESS_PROVIDED\\\"\\n        );\\n        require(\\n            owners[newOwner] == address(0),\\n            \\\"WRAP: ADDRESS_IS_ALREADY_AN_OWNER\\\"\\n        );\\n        require(\\n            oldOwner != address(0) && oldOwner != SENTINEL_OWNERS,\\n            \\\"WRAP: INVALID_OWNER_ADDRESS_PROVIDED\\\"\\n        );\\n        require(\\n            owners[prevOwner] == oldOwner,\\n            \\\"WRAP: INVALID_PREV_OWNER_OWNER_PAIR_PROVIDED\\\"\\n        );\\n        owners[newOwner] = owners[oldOwner];\\n        owners[prevOwner] = newOwner;\\n        owners[oldOwner] = address(0);\\n        emit RemovedOwner(oldOwner);\\n        emit AddedOwner(newOwner);\\n    }\\n\\n    /// @dev Allows to update the number of required confirmations\\n    /// @notice Changes the threshold to `_threshold`\\n    /// @param _threshold New threshold\\n    function changeThreshold(uint256 _threshold) public authorized {\\n        require(\\n            _threshold <= ownerCount,\\n            \\\"WRAP: THRESHOLD_CANNOT_EXCEED_OWNER_COUNT\\\"\\n        );\\n        require(_threshold >= 1, \\\"WRAP: THRESHOLD_NEEED_TO_BE_GREETER_THAN_0\\\");\\n        threshold = _threshold;\\n        emit ChangedThreshold(threshold);\\n    }\\n\\n    /// @notice Get multisig threshold\\n    /// @return Threshold\\n    function getThreshold() public view returns (uint256) {\\n        return threshold;\\n    }\\n\\n    /// @notice Allow to check if an address is owner of the multisig\\n    /// @return True if owner, false otherwise\\n    function isOwner(address owner) public view returns (bool) {\\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\\n    }\\n\\n    /// @notice Get multisig members\\n    /// @return Owners list\\n    function getOwners() public view returns (address[] memory) {\\n        address[] memory array = new address[](ownerCount);\\n\\n        uint256 index = 0;\\n        address currentOwner = owners[SENTINEL_OWNERS];\\n        while (currentOwner != SENTINEL_OWNERS) {\\n            array[index] = currentOwner;\\n            currentOwner = owners[currentOwner];\\n            index++;\\n        }\\n        return array;\\n    }\\n\\n    /// @notice Get current multisig administrator\\n    /// @return Administrator address\\n    function getAdministrator() public view returns (address) {\\n        return administrator;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC721TokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.8.0;\\n\\ninterface ERC721TokenReceiver {\\n    function onERC721Received(\\n        address _operator,\\n        address _from,\\n        uint256 _tokenId,\\n        bytes calldata _data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_administrator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"AddedOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"ChangedThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tezosDestinationAddress\",\"type\":\"string\"}],\"name\":\"ERC20WrapAsked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tezosDestinationAddress\",\"type\":\"string\"}],\"name\":\"ERC721WrapAsked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"}],\"name\":\"ExecutionFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"}],\"name\":\"ExecutionSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"RemovedOwner\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"addOwnerWithThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"changeThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"tezosOperation\",\"type\":\"string\"}],\"name\":\"encodeTransactionData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"tezosOperation\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"execTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdministrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"tezosOperation\",\"type\":\"string\"}],\"name\":\"getTransactionHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tezosOperation\",\"type\":\"string\"}],\"name\":\"isTezosOperationProcessed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"removeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"swapOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tezosAddress\",\"type\":\"string\"}],\"name\":\"wrapERC20\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tezosAddress\",\"type\":\"string\"}],\"name\":\"wrapERC721\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"WrapMultisig","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"0000000000000000000000005b64d8b8459b37e3d1e8ae59d4a6d4fd6d207698","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}