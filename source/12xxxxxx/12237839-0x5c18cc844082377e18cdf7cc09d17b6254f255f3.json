{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/thirdparty/ECDH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n/*\\n    Modifications Copyright (C) 2018 SKALE Labs\\n    ec.sol by @jbaylina under GPL-3.0 License\\n*/\\n/** @file ECDH.sol\\n * @author Jordi Baylina (@jbaylina)\\n * @date 2016\\n */\\n\\npragma solidity 0.6.10;\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\n\\n/**\\n * @title ECDH\\n * @dev This contract performs Elliptic-curve Diffie-Hellman key exchange to\\n * support the DKG process.\\n */\\ncontract ECDH {\\n    using SafeMath for uint256;\\n\\n    uint256 constant private _GX = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\\n    uint256 constant private _GY = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\\n    uint256 constant private _N  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\\n    uint256 constant private _A  = 0;\\n\\n    function publicKey(uint256 privKey) external pure returns (uint256 qx, uint256 qy) {\\n        uint256 x;\\n        uint256 y;\\n        uint256 z;\\n        (x, y, z) = ecMul(\\n            privKey,\\n            _GX,\\n            _GY,\\n            1\\n        );\\n        z = inverse(z);\\n        qx = mulmod(x, z, _N);\\n        qy = mulmod(y, z, _N);\\n    }\\n\\n    function deriveKey(\\n        uint256 privKey,\\n        uint256 pubX,\\n        uint256 pubY\\n    )\\n        external\\n        pure\\n        returns (uint256 qx, uint256 qy)\\n    {\\n        uint256 x;\\n        uint256 y;\\n        uint256 z;\\n        (x, y, z) = ecMul(\\n            privKey,\\n            pubX,\\n            pubY,\\n            1\\n        );\\n        z = inverse(z);\\n        qx = mulmod(x, z, _N);\\n        qy = mulmod(y, z, _N);\\n    }\\n\\n    function jAdd(\\n        uint256 x1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 z2\\n    )\\n        public\\n        pure\\n        returns (uint256 x3, uint256 z3)\\n    {\\n        (x3, z3) = (addmod(mulmod(z2, x1, _N), mulmod(x2, z1, _N), _N), mulmod(z1, z2, _N));\\n    }\\n\\n    function jSub(\\n        uint256 x1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 z2\\n    )\\n        public\\n        pure\\n        returns (uint256 x3, uint256 z3)\\n    {\\n        (x3, z3) = (addmod(mulmod(z2, x1, _N), mulmod(_N.sub(x2), z1, _N), _N), mulmod(z1, z2, _N));\\n    }\\n\\n    function jMul(\\n        uint256 x1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 z2\\n    )\\n        public\\n        pure\\n        returns (uint256 x3, uint256 z3)\\n    {\\n        (x3, z3) = (mulmod(x1, x2, _N), mulmod(z1, z2, _N));\\n    }\\n\\n    function jDiv(\\n        uint256 x1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 z2\\n    )\\n        public\\n        pure\\n        returns (uint256 x3, uint256 z3)\\n    {\\n        (x3, z3) = (mulmod(x1, z2, _N), mulmod(z1, x2, _N));\\n    }\\n\\n    function inverse(uint256 a) public pure returns (uint256 invA) {\\n        require(a > 0 && a < _N, \\\"Input is incorrect\\\");\\n        uint256 t = 0;\\n        uint256 newT = 1;\\n        uint256 r = _N;\\n        uint256 newR = a;\\n        uint256 q;\\n        while (newR != 0) {\\n            q = r.div(newR);\\n            (t, newT) = (newT, addmod(t, (_N.sub(mulmod(q, newT, _N))), _N));\\n            (r, newR) = (newR, r % newR);\\n        }\\n        return t;\\n    }\\n\\n    function ecAdd(\\n        uint256 x1,\\n        uint256 y1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 y2,\\n        uint256 z2\\n    )\\n        public\\n        pure\\n        returns (uint256 x3, uint256 y3, uint256 z3)\\n    {\\n        uint256 ln;\\n        uint256 lz;\\n        uint256 da;\\n        uint256 db;\\n        // we use (0 0 1) as zero point, z always equal 1\\n        if ((x1 == 0) && (y1 == 0)) {\\n            return (x2, y2, z2);\\n        }\\n\\n        // we use (0 0 1) as zero point, z always equal 1\\n        if ((x2 == 0) && (y2 == 0)) {\\n            return (x1, y1, z1);\\n        }\\n\\n        if ((x1 == x2) && (y1 == y2)) {\\n            (ln, lz) = jMul(x1, z1, x1, z1);\\n            (ln, lz) = jMul(ln,lz,3,1);\\n            (ln, lz) = jAdd(ln,lz,_A,1);\\n            (da, db) = jMul(y1,z1,2,1);\\n        } else {\\n            (ln, lz) = jSub(y2,z2,y1,z1);\\n            (da, db) = jSub(x2,z2,x1,z1);\\n        }\\n        (ln, lz) = jDiv(ln,lz,da,db);\\n\\n        (x3, da) = jMul(ln,lz,ln,lz);\\n        (x3, da) = jSub(x3,da,x1,z1);\\n        (x3, da) = jSub(x3,da,x2,z2);\\n\\n        (y3, db) = jSub(x1,z1,x3,da);\\n        (y3, db) = jMul(y3,db,ln,lz);\\n        (y3, db) = jSub(y3,db,y1,z1);\\n\\n        if (da != db) {\\n            x3 = mulmod(x3, db, _N);\\n            y3 = mulmod(y3, da, _N);\\n            z3 = mulmod(da, db, _N);\\n        } else {\\n            z3 = da;\\n        }\\n    }\\n\\n    function ecDouble(\\n        uint256 x1,\\n        uint256 y1,\\n        uint256 z1\\n    )\\n        public\\n        pure\\n        returns (uint256 x3, uint256 y3, uint256 z3)\\n    {\\n        (x3, y3, z3) = ecAdd(\\n            x1,\\n            y1,\\n            z1,\\n            x1,\\n            y1,\\n            z1\\n        );\\n    }\\n\\n    function ecMul(\\n        uint256 d,\\n        uint256 x1,\\n        uint256 y1,\\n        uint256 z1\\n    )\\n        public\\n        pure\\n        returns (uint256 x3, uint256 y3, uint256 z3)\\n    {\\n        uint256 remaining = d;\\n        uint256 px = x1;\\n        uint256 py = y1;\\n        uint256 pz = z1;\\n        uint256 acx = 0;\\n        uint256 acy = 0;\\n        uint256 acz = 1;\\n\\n        if (d == 0) {\\n            return (0, 0, 1);\\n        }\\n\\n        while (remaining != 0) {\\n            if ((remaining & 1) != 0) {\\n                (acx, acy, acz) = ecAdd(\\n                    acx,\\n                    acy,\\n                    acz,\\n                    px,\\n                    py,\\n                    pz\\n                );\\n            }\\n            remaining = remaining.div(2);\\n            (px, py, pz) = ecDouble(px, py, pz);\\n        }\\n\\n        (x3, y3, z3) = (acx, acy, acz);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"privKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubY\",\"type\":\"uint256\"}],\"name\":\"deriveKey\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"qx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qy\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z2\",\"type\":\"uint256\"}],\"name\":\"ecAdd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"x3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z3\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z1\",\"type\":\"uint256\"}],\"name\":\"ecDouble\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"x3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z3\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z1\",\"type\":\"uint256\"}],\"name\":\"ecMul\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"x3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z3\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"inverse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"invA\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z2\",\"type\":\"uint256\"}],\"name\":\"jAdd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"x3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z3\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z2\",\"type\":\"uint256\"}],\"name\":\"jDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"x3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z3\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z2\",\"type\":\"uint256\"}],\"name\":\"jMul\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"x3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z3\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z2\",\"type\":\"uint256\"}],\"name\":\"jSub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"x3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z3\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"privKey\",\"type\":\"uint256\"}],\"name\":\"publicKey\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"qx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qy\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"ECDH","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}