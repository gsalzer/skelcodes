{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": false,\r\n        \"peephole\": true,\r\n        \"yul\": false\r\n      },\r\n      \"runs\": 256\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"src/rollup/contracts/ExecutionProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\nimport './MetaProxyFactory.sol';\\nimport './IBridge.sol';\\n\\n/// @notice This contract verifies execution permits and is meant to be used for L1 governance.\\n/// A new proxy can be created with `createProxy`, to be used for governance.\\n// Audit-1: ok\\ncontract ExecutionProxy is MetaProxyFactory {\\n  /// @notice keeps track of already executed permits\\n  mapping (bytes32 => bool) public executed;\\n\\n  event ProxyCreated(address indexed bridge, address indexed vault, address proxy);\\n\\n  /// @notice Returns the metadata of this (MetaProxy) contract.\\n  /// Only relevant with contracts created via the MetaProxy.\\n  /// @dev This function is aimed to be invoked with- & without a call.\\n  function getMetadata () public pure returns (\\n    address bridge,\\n    address vault\\n  ) {\\n    assembly {\\n      // calldata layout:\\n      // [ arbitrary data... ] [ metadata... ] [ size of metadata 32 bytes ]\\n      bridge := calldataload(sub(calldatasize(), 96))\\n      vault := calldataload(sub(calldatasize(), 64))\\n    }\\n  }\\n\\n  /// @notice MetaProxy construction via calldata.\\n  /// @param bridge is the address of the habitat rollup\\n  /// @param vault is the L2 vault used for governance.\\n  function createProxy (address bridge, address vault) external returns (address addr) {\\n    addr = MetaProxyFactory._metaProxyFromCalldata();\\n    emit ProxyCreated(bridge, vault, addr);\\n  }\\n\\n  /// @notice Executes a set of contract calls `actions` if there is a valid\\n  /// permit on the rollup bridge for `proposalId` and `actions`.\\n  function execute (bytes32 proposalId, bytes memory actions) external {\\n    (address bridge, address vault) = getMetadata();\\n\\n    require(executed[proposalId] == false, 'already executed');\\n    require(\\n      IBridge(bridge).executionPermit(vault, proposalId) == keccak256(actions),\\n      'wrong permit'\\n    );\\n\\n    // mark it as executed\\n    executed[proposalId] = true;\\n    // execute\\n    assembly {\\n      // Note: we use `callvalue()` instead of `0`\\n      let ptr := add(actions, 32)\\n      let max := add(ptr, mload(actions))\\n\\n      for { } lt(ptr, max) { } {\\n        let addr := mload(ptr)\\n        ptr := add(ptr, 32)\\n        let size := mload(ptr)\\n        ptr := add(ptr, 32)\\n\\n        let success := call(gas(), addr, callvalue(), ptr, size, callvalue(), callvalue())\\n        if iszero(success) {\\n          // failed, copy the error\\n          returndatacopy(callvalue(), callvalue(), returndatasize())\\n          revert(callvalue(), returndatasize())\\n        }\\n        ptr := add(ptr, size)\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/IBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\ninterface IBridge {\\n  function executionPermit (address vault, bytes32 proposalId) external view returns (bytes32);\\n  function deposit (address token, uint256 amountOrId, address receiver) external;\\n}\\n\"\r\n    },\r\n    \"src/rollup/contracts/MetaProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.7.6;\\n\\n/// @notice Based on EIP-3448\\n// Audit-1: ok\\ncontract MetaProxyFactory {\\n  /// @dev Creates a child with metadata from calldata.\\n  /// Copies everything from calldata except the first 4 bytes.\\n  function _metaProxyFromCalldata () internal returns (address addr) {\\n    // the following assembly code (init code + contract code) constructs a metaproxy.\\n    assembly {\\n      // load free memory pointer as per solidity convention\\n      let start := mload(64)\\n      // copy\\n      let ptr := start\\n      // deploy code (11 bytes) + first part of the proxy (21 bytes)\\n      mstore(ptr, 0x600b380380600b3d393df3363d3d373d3d3d3d60368038038091363936013d73)\\n      ptr := add(ptr, 32)\\n\\n      // store the address of the contract to be called\\n      mstore(ptr, shl(96, address()))\\n      // 20 bytes\\n      ptr := add(ptr, 20)\\n\\n      // the remaining proxy code...\\n      mstore(ptr, 0x5af43d3d93803e603457fd5bf300000000000000000000000000000000000000)\\n      // ...13 bytes\\n      ptr := add(ptr, 13)\\n\\n      // now calculdate the size and copy the metadata\\n      // - 4 bytes function signature\\n      let size := sub(calldatasize(), 4)\\n      // copy\\n      calldatacopy(ptr, 4, size)\\n      ptr := add(ptr, size)\\n      // store the size of the metadata at the end of the bytecode\\n      mstore(ptr, size)\\n      ptr := add(ptr, 32)\\n\\n      // The size is deploy code + contract code + calldatasize - 4 + 32.\\n      addr := create(0, start, sub(ptr, start))\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"ProxyCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"createProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"actions\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"executed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMetadata\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"ExecutionProxy","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"256","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"none"}]}