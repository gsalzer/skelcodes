{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MErc20Immutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.6.12;\\n\\nimport \\\"./CErc20.sol\\\";\\nimport \\\"./Moartroller.sol\\\";\\nimport \\\"./AbstractInterestRateModel.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\\\";\\nimport \\\"./Interfaces/Versionable.sol\\\";\\n\\n/**\\n * @title MOAR's MErc20Immutable Contract\\n * @notice MTokens which wrap an EIP-20 underlying and are immutable\\n * @author MOAR\\n */\\ncontract MErc20Immutable is MErc20, Initializable, Versionable {\\n    /**\\n     * @notice Construct a new money market\\n     * @param underlying_ The address of the underlying asset\\n     * @param moartroller_ The address of the Moartroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     * @param admin_ Address of the administrator of this token\\n     */\\n    function initialize(address underlying_,\\n                Moartroller moartroller_,\\n                AbstractInterestRateModel interestRateModel_,\\n                uint initialExchangeRateMantissa_,\\n                string memory name_,\\n                string memory symbol_,\\n                uint8 decimals_,\\n                address payable admin_) public initializer {\\n        // Creator of the contract is admin during initialization\\n        admin = msg.sender;\\n\\n        // Initialize the market\\n        super.init(underlying_, moartroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\\n\\n        // Set the proper admin now that initialization is done\\n        admin = admin_;\\n    }\\n\\n    function getContractVersion() external override pure returns(string memory){\\n        return \\\"V1\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CErc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.6.12;\\n\\nimport \\\"./MToken.sol\\\";\\nimport \\\"./Interfaces/MErc20Interface.sol\\\";\\nimport \\\"./Moartroller.sol\\\";\\nimport \\\"./AbstractInterestRateModel.sol\\\";\\nimport \\\"./Interfaces/EIP20Interface.sol\\\";\\nimport \\\"./Utils/SafeEIP20.sol\\\";\\n\\n/**\\n * @title MOAR's MErc20 Contract\\n * @notice MTokens which wrap an EIP-20 underlying\\n */\\ncontract MErc20 is MToken, MErc20Interface {\\n\\n    using SafeEIP20 for EIP20Interface;\\n\\n    /**\\n     * @notice Initialize the new money market\\n     * @param underlying_ The address of the underlying asset\\n     * @param moartroller_ The address of the Moartroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     */\\n    function init(address underlying_,\\n                        Moartroller moartroller_,\\n                        AbstractInterestRateModel interestRateModel_,\\n                        uint initialExchangeRateMantissa_,\\n                        string memory name_,\\n                        string memory symbol_,\\n                        uint8 decimals_) public {\\n        // MToken initialize does the bulk of the work\\n        super.init(moartroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\\n\\n        // Set underlying and sanity check it\\n        underlying = underlying_;\\n        EIP20Interface(underlying).totalSupply();\\n    }\\n\\n    /*** User Interface ***/\\n\\n    /**\\n     * @notice Sender supplies assets into the market and receives mTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function mint(uint mintAmount) external override returns (uint) {\\n        (uint err,) = mintInternal(mintAmount);\\n        return err;\\n    }\\n\\n    /**\\n     * @notice Sender redeems mTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of mTokens to redeem into underlying\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeem(uint redeemTokens) external override returns (uint) {\\n        return redeemInternal(redeemTokens);\\n    }\\n\\n    /**\\n     * @notice Sender redeems mTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to redeem\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeemUnderlying(uint redeemAmount) external override returns (uint) {\\n        return redeemUnderlyingInternal(redeemAmount);\\n    }\\n\\n    /**\\n      * @notice Sender borrows assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function borrow(uint borrowAmount) external override returns (uint) {\\n        return borrowInternal(borrowAmount);\\n    }\\n\\n    function borrowFor(address payable borrower, uint borrowAmount) external override returns (uint) {\\n        return borrowForInternal(borrower, borrowAmount);\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @param repayAmount The amount to repay\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function repayBorrow(uint repayAmount) external override returns (uint) {\\n        (uint err,) = repayBorrowInternal(repayAmount);\\n        return err;\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower.\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount The amount to repay\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override returns (uint) {\\n        (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);\\n        return err;\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this mToken to be liquidated\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param mTokenCollateral The market in which to seize collateral from the borrower\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function liquidateBorrow(address borrower, uint repayAmount, MToken mTokenCollateral) external override returns (uint) {\\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, mTokenCollateral);\\n        return err;\\n    }\\n\\n    /**\\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\\n     * @param token The address of the ERC-20 token to sweep\\n     */\\n    function sweepToken(EIP20Interface token) override external {\\n    \\trequire(address(token) != underlying, \\\"MErc20::sweepToken: can not sweep underlying token\\\");\\n    \\tuint256 balance = token.balanceOf(address(this));\\n    \\ttoken.safeTransfer(admin, balance);\\n    }\\n\\n    /**\\n     * @notice The sender adds to reserves.\\n     * @param addAmount The amount fo underlying token to add as reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _addReserves(uint addAmount) external override returns (uint) {\\n        return _addReservesInternal(addAmount);\\n    }\\n\\n    /*** Safe Token ***/\\n\\n    /**\\n     * @notice Gets balance of this contract in terms of the underlying\\n     * @dev This excludes the value of the current message, if any\\n     * @return The quantity of underlying tokens owned by this contract\\n     */\\n    function getCashPrior() internal override view returns (uint) {\\n        EIP20Interface token = EIP20Interface(underlying);\\n        return token.balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\\n     *      This will revert due to insufficient balance or insufficient allowance.\\n     *      This function returns the actual amount received,\\n     *      which may be less than `amount` if there is a fee attached to the transfer.\\n     *`\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n     */\\n    function doTransferIn(address from, uint amount) internal override returns (uint) {\\n        EIP20Interface token = EIP20Interface(underlying);\\n        uint balanceBefore = token.balanceOf(address(this));\\n        token.safeTransferFrom(from, address(this), amount);\\n\\n        // Calculate the amount that was *actually* transferred\\n        uint balanceAfter = token.balanceOf(address(this));\\n        require(balanceAfter >= balanceBefore, \\\"TOKEN_TRANSFER_IN_OVERFLOW\\\");\\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\\n    }\\n\\n    /**\\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\\n     *      it is >= amount, this should not revert in normal conditions.\\n     *\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n     */\\n    function doTransferOut(address payable to, uint amount) internal override {\\n        EIP20Interface token = EIP20Interface(underlying);\\n        token.safeTransfer(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Moartroller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\n// Thanks to Compound for their foundational work in DeFi and open-sourcing their code from which we build upon.\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n// import \\\"hardhat/console.sol\\\";\\n\\nimport \\\"./MToken.sol\\\";\\nimport \\\"./Utils/ErrorReporter.sol\\\";\\nimport \\\"./Utils/ExponentialNoError.sol\\\";\\nimport \\\"./Interfaces/PriceOracle.sol\\\";\\nimport \\\"./Interfaces/MoartrollerInterface.sol\\\";\\nimport \\\"./Interfaces/Versionable.sol\\\";\\nimport \\\"./Interfaces/MProxyInterface.sol\\\";\\nimport \\\"./MoartrollerStorage.sol\\\";\\nimport \\\"./Governance/UnionGovernanceToken.sol\\\";\\nimport \\\"./MProtection.sol\\\";\\nimport \\\"./Interfaces/LiquidityMathModelInterface.sol\\\";\\nimport \\\"./LiquidityMathModelV1.sol\\\";\\nimport \\\"./Utils/SafeEIP20.sol\\\";\\nimport \\\"./Interfaces/EIP20Interface.sol\\\";\\nimport \\\"./Interfaces/LiquidationModelInterface.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\\\";\\n\\n/**\\n * @title MOAR's Moartroller Contract\\n * @author MOAR\\n */\\ncontract Moartroller is MoartrollerV6Storage, MoartrollerInterface, MoartrollerErrorReporter, ExponentialNoError, Versionable, Initializable {\\n\\n    using SafeEIP20 for EIP20Interface;\\n\\n    /// @notice Indicator that this is a Moartroller contract (for inspection)\\n    bool public constant isMoartroller = true;\\n\\n    /// @notice Emitted when an admin supports a market\\n    event MarketListed(MToken mToken);\\n\\n    /// @notice Emitted when an account enters a market\\n    event MarketEntered(MToken mToken, address account);\\n\\n    /// @notice Emitted when an account exits a market\\n    event MarketExited(MToken mToken, address account);\\n\\n    /// @notice Emitted when close factor is changed by admin\\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\\n\\n    /// @notice Emitted when a collateral factor is changed by admin\\n    event NewCollateralFactor(MToken mToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\\n\\n    /// @notice Emitted when liquidation incentive is changed by admin\\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\\n\\n    /// @notice Emitted when price oracle is changed\\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\\n\\n    /// @notice Emitted when protection is changed\\n    event NewCProtection(MProtection oldCProtection, MProtection newCProtection);\\n\\n    /// @notice Emitted when pause guardian is changed\\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\\n\\n    /// @notice Emitted when an action is paused globally\\n    event ActionPaused(string action, bool pauseState);\\n\\n    /// @notice Emitted when an action is paused on a market\\n    event ActionPausedMToken(MToken mToken, string action, bool pauseState);\\n\\n    /// @notice Emitted when a new MOAR speed is calculated for a market\\n    event MoarSpeedUpdated(MToken indexed mToken, uint newSpeed);\\n\\n    /// @notice Emitted when a new MOAR speed is set for a contributor\\n    event ContributorMoarSpeedUpdated(address indexed contributor, uint newSpeed);\\n\\n    /// @notice Emitted when MOAR is distributed to a supplier\\n    event DistributedSupplierMoar(MToken indexed mToken, address indexed supplier, uint moarDelta, uint moarSupplyIndex);\\n\\n    /// @notice Emitted when MOAR is distributed to a borrower\\n    event DistributedBorrowerMoar(MToken indexed mToken, address indexed borrower, uint moarDelta, uint moarBorrowIndex);\\n\\n    /// @notice Emitted when borrow cap for a mToken is changed\\n    event NewBorrowCap(MToken indexed mToken, uint newBorrowCap);\\n\\n    /// @notice Emitted when borrow cap guardian is changed\\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\\n\\n    /// @notice Emitted when MOAR is granted by admin\\n    event MoarGranted(address recipient, uint amount);\\n\\n    event NewLiquidityMathModel(address oldLiquidityMathModel, address newLiquidityMathModel);\\n\\n    event NewLiquidationModel(address oldLiquidationModel, address newLiquidationModel);\\n\\n    /// @notice The initial MOAR index for a market\\n    uint224 public constant moarInitialIndex = 1e36;\\n\\n    // closeFactorMantissa must be strictly greater than this value\\n    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\\n\\n    // closeFactorMantissa must not exceed this value\\n    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\\n\\n    // No collateralFactorMantissa may exceed this value\\n    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\\n\\n    // Custom initializer\\n    function initialize(LiquidityMathModelInterface mathModel, LiquidationModelInterface lqdModel) public initializer {\\n        admin = msg.sender;\\n        liquidityMathModel = mathModel;\\n        liquidationModel = lqdModel;\\n        rewardClaimEnabled = false;\\n    }\\n\\n    /*** Assets You Are In ***/\\n\\n    /**\\n     * @notice Returns the assets an account has entered\\n     * @param account The address of the account to pull assets for\\n     * @return A dynamic list with the assets the account has entered\\n     */\\n    function getAssetsIn(address account) external view returns (MToken[] memory) {\\n        MToken[] memory assetsIn = accountAssets[account];\\n\\n        return assetsIn;\\n    }\\n\\n    /**\\n     * @notice Returns whether the given account is entered in the given asset\\n     * @param account The address of the account to check\\n     * @param mToken The mToken to check\\n     * @return True if the account is in the asset, otherwise false.\\n     */\\n    function checkMembership(address account, MToken mToken) external view returns (bool) {\\n        return markets[address(mToken)].accountMembership[account];\\n    }\\n\\n    /**\\n     * @notice Add assets to be included in account liquidity calculation\\n     * @param mTokens The list of addresses of the mToken markets to be enabled\\n     * @return Success indicator for whether each corresponding market was entered\\n     */\\n    function enterMarkets(address[] memory mTokens) public override returns (uint[] memory) {\\n        uint len = mTokens.length;\\n\\n        uint[] memory results = new uint[](len);\\n        for (uint i = 0; i < len; i++) {\\n            MToken mToken = MToken(mTokens[i]);\\n\\n            results[i] = uint(addToMarketInternal(mToken, msg.sender));\\n        }\\n\\n        return results;\\n    }\\n\\n    /**\\n     * @notice Add the market to the borrower's \\\"assets in\\\" for liquidity calculations\\n     * @param mToken The market to enter\\n     * @param borrower The address of the account to modify\\n     * @return Success indicator for whether the market was entered\\n     */\\n    function addToMarketInternal(MToken mToken, address borrower) internal returns (Error) {\\n        Market storage marketToJoin = markets[address(mToken)];\\n\\n        if (!marketToJoin.isListed) {\\n            // market is not listed, cannot join\\n            return Error.MARKET_NOT_LISTED;\\n        }\\n\\n        if (marketToJoin.accountMembership[borrower] == true) {\\n            // already joined\\n            return Error.NO_ERROR;\\n        }\\n\\n        // survived the gauntlet, add to list\\n        // NOTE: we store these somewhat redundantly as a significant optimization\\n        //  this avoids having to iterate through the list for the most common use cases\\n        //  that is, only when we need to perform liquidity checks\\n        //  and not whenever we want to check if an account is in a particular market\\n        marketToJoin.accountMembership[borrower] = true;\\n        accountAssets[borrower].push(mToken);\\n\\n        emit MarketEntered(mToken, borrower);\\n\\n        return Error.NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Removes asset from sender's account liquidity calculation\\n     * @dev Sender must not have an outstanding borrow balance in the asset,\\n     *  or be providing necessary collateral for an outstanding borrow.\\n     * @param mTokenAddress The address of the asset to be removed\\n     * @return Whether or not the account successfully exited the market\\n     */\\n    function exitMarket(address mTokenAddress) external override returns (uint) {\\n        MToken mToken = MToken(mTokenAddress);\\n        /* Get sender tokensHeld and amountOwed underlying from the mToken */\\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = mToken.getAccountSnapshot(msg.sender);\\n        require(oErr == 0, \\\"exitMarket: getAccountSnapshot failed\\\"); // semi-opaque error code\\n\\n        /* Fail if the sender has a borrow balance */\\n        if (amountOwed != 0) {\\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\\n        }\\n\\n        /* Fail if the sender is not permitted to redeem all of their tokens */\\n        uint allowed = redeemAllowedInternal(mTokenAddress, msg.sender, tokensHeld);\\n        if (allowed != 0) {\\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\\n        }\\n\\n        Market storage marketToExit = markets[address(mToken)];\\n\\n        /* Return true if the sender is not already ‘in’ the market */\\n        if (!marketToExit.accountMembership[msg.sender]) {\\n            return uint(Error.NO_ERROR);\\n        }\\n\\n        /* Set mToken account membership to false */\\n        delete marketToExit.accountMembership[msg.sender];\\n\\n        /* Delete mToken from the account’s list of assets */\\n        // load into memory for faster iteration\\n        MToken[] memory userAssetList = accountAssets[msg.sender];\\n        uint len = userAssetList.length;\\n        uint assetIndex = len;\\n        for (uint i = 0; i < len; i++) {\\n            if (userAssetList[i] == mToken) {\\n                assetIndex = i;\\n                break;\\n            }\\n        }\\n\\n        // We *must* have found the asset in the list or our redundant data structure is broken\\n        assert(assetIndex < len);\\n\\n        // copy last item in list to location of item to be removed, reduce length by 1\\n        MToken[] storage storedList = accountAssets[msg.sender];\\n        storedList[assetIndex] = storedList[storedList.length - 1];\\n        storedList.pop();\\n\\n        emit MarketExited(mToken, msg.sender);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /*** Policy Hooks ***/\\n\\n    /**\\n     * @notice Checks if the account should be allowed to mint tokens in the given market\\n     * @param mToken The market to verify the mint against\\n     * @param minter The account which would get the minted tokens\\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function mintAllowed(address mToken, address minter, uint mintAmount) external override returns (uint) {\\n        // Pausing is a very serious situation - we revert to sound the alarms\\n        require(!mintGuardianPaused[mToken], \\\"mint is paused\\\");\\n\\n        // Shh - currently unused\\n        minter;\\n        mintAmount;\\n\\n        if (!markets[mToken].isListed) {\\n            return uint(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        // Keep the flywheel moving\\n        updateMoarSupplyIndex(mToken);\\n        distributeSupplierMoar(mToken, minter);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\\n     * @param mToken The market to verify the redeem against\\n     * @param redeemer The account which would redeem the tokens\\n     * @param redeemTokens The number of mTokens to exchange for the underlying asset in the market\\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function redeemAllowed(address mToken, address redeemer, uint redeemTokens) external override returns (uint) {\\n        uint allowed = redeemAllowedInternal(mToken, redeemer, redeemTokens);\\n        if (allowed != uint(Error.NO_ERROR)) {\\n            return allowed;\\n        }\\n\\n        // Keep the flywheel moving\\n        updateMoarSupplyIndex(mToken);\\n        distributeSupplierMoar(mToken, redeemer);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    function redeemAllowedInternal(address mToken, address redeemer, uint redeemTokens) internal view returns (uint) {\\n        if (!markets[mToken].isListed) {\\n            return uint(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\\n        if (!markets[mToken].accountMembership[redeemer]) {\\n            return uint(Error.NO_ERROR);\\n        }\\n\\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, MToken(mToken), redeemTokens, 0);\\n        if (err != Error.NO_ERROR) {\\n            return uint(err);\\n        }\\n        if (shortfall > 0) {\\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\\n        }\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Validates redeem and reverts on rejection. May emit logs.\\n     * @param mToken Asset being redeemed\\n     * @param redeemer The address redeeming the tokens\\n     * @param redeemAmount The amount of the underlying asset being redeemed\\n     * @param redeemTokens The number of tokens being redeemed\\n     */\\n    function redeemVerify(address mToken, address redeemer, uint redeemAmount, uint redeemTokens) external override {\\n        // Shh - currently unused\\n        mToken;\\n        redeemer;\\n\\n        // Require tokens is zero or amount is also zero\\n        if (redeemTokens == 0 && redeemAmount > 0) {\\n            revert(\\\"redeemTokens zero\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\\n     * @param mToken The market to verify the borrow against\\n     * @param borrower The account which would borrow the asset\\n     * @param borrowAmount The amount of underlying the account would borrow\\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function borrowAllowed(address mToken, address borrower, uint borrowAmount) external override returns (uint) {\\n        // Pausing is a very serious situation - we revert to sound the alarms\\n        require(!borrowGuardianPaused[mToken], \\\"borrow is paused\\\");\\n\\n        if (!markets[mToken].isListed) {\\n            return uint(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        if (!markets[mToken].accountMembership[borrower]) {\\n            // only mTokens may call borrowAllowed if borrower not in market\\n            require(msg.sender == mToken, \\\"sender must be mToken\\\");\\n\\n            // attempt to add borrower to the market\\n            Error err = addToMarketInternal(MToken(msg.sender), borrower);\\n            if (err != Error.NO_ERROR) {\\n                return uint(err);\\n            }\\n\\n            // it should be impossible to break the important invariant\\n            assert(markets[mToken].accountMembership[borrower]);\\n        }\\n\\n        if (oracle.getUnderlyingPrice(MToken(mToken)) == 0) {\\n            return uint(Error.PRICE_ERROR);\\n        }\\n\\n\\n        uint borrowCap = borrowCaps[mToken];\\n        // Borrow cap of 0 corresponds to unlimited borrowing\\n        if (borrowCap != 0) {\\n            uint totalBorrows = MToken(mToken).totalBorrows();\\n            uint nextTotalBorrows = add_(totalBorrows, borrowAmount);\\n            require(nextTotalBorrows < borrowCap, \\\"market borrow cap reached\\\");\\n        }\\n\\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, MToken(mToken), 0, borrowAmount);\\n        if (err != Error.NO_ERROR) {\\n            return uint(err);\\n        }\\n        if (shortfall > 0) {\\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\\n        }\\n\\n        // Keep the flywheel moving\\n        Exp memory borrowIndex = Exp({mantissa: MToken(mToken).borrowIndex()});\\n        updateMoarBorrowIndex(mToken, borrowIndex);\\n        distributeBorrowerMoar(mToken, borrower, borrowIndex);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\\n     * @param mToken The market to verify the repay against\\n     * @param payer The account which would repay the asset\\n     * @param borrower The account which would borrowed the asset\\n     * @param repayAmount The amount of the underlying asset the account would repay\\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function repayBorrowAllowed(\\n        address mToken,\\n        address payer,\\n        address borrower,\\n        uint repayAmount) external override returns (uint) {\\n        // Shh - currently unused\\n        payer;\\n        borrower;\\n        repayAmount;\\n\\n        if (!markets[mToken].isListed) {\\n            return uint(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        // Keep the flywheel moving\\n        Exp memory borrowIndex = Exp({mantissa: MToken(mToken).borrowIndex()});\\n        updateMoarBorrowIndex(mToken, borrowIndex);\\n        distributeBorrowerMoar(mToken, borrower, borrowIndex);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Checks if the liquidation should be allowed to occur\\n     * @param mTokenBorrowed Asset which was borrowed by the borrower\\n     * @param mTokenCollateral Asset which was used as collateral and will be seized\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\n     * @param borrower The address of the borrower\\n     * @param repayAmount The amount of underlying being repaid\\n     */\\n    function liquidateBorrowAllowed(\\n        address mTokenBorrowed,\\n        address mTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint repayAmount) external override returns (uint) {\\n        // Shh - currently unused\\n        liquidator;\\n\\n        if (!markets[mTokenBorrowed].isListed || !markets[mTokenCollateral].isListed) {\\n            return uint(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        /* The borrower must have shortfall in order to be liquidatable */\\n        (Error err, , uint shortfall) = getAccountLiquidityInternal(borrower);\\n        if (err != Error.NO_ERROR) {\\n            return uint(err);\\n        }\\n        if (shortfall == 0) {\\n            return uint(Error.INSUFFICIENT_SHORTFALL);\\n        }\\n\\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\\n        uint borrowBalance = MToken(mTokenBorrowed).borrowBalanceStored(borrower);\\n        uint maxClose = mul_ScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\\n        if (repayAmount > maxClose) {\\n            return uint(Error.TOO_MUCH_REPAY);\\n        }\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Checks if the seizing of assets should be allowed to occur\\n     * @param mTokenCollateral Asset which was used as collateral and will be seized\\n     * @param mTokenBorrowed Asset which was borrowed by the borrower\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\n     * @param borrower The address of the borrower\\n     * @param seizeTokens The number of collateral tokens to seize\\n     */\\n    function seizeAllowed(\\n        address mTokenCollateral,\\n        address mTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint seizeTokens) external override returns (uint) {\\n        // Pausing is a very serious situation - we revert to sound the alarms\\n        require(!seizeGuardianPaused, \\\"seize is paused\\\");\\n\\n        // Shh - currently unused\\n        seizeTokens;\\n\\n        if (!markets[mTokenCollateral].isListed || !markets[mTokenBorrowed].isListed) {\\n            return uint(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        if (MToken(mTokenCollateral).moartroller() != MToken(mTokenBorrowed).moartroller()) {\\n            return uint(Error.MOARTROLLER_MISMATCH);\\n        }\\n\\n        // Keep the flywheel moving\\n        updateMoarSupplyIndex(mTokenCollateral);\\n        distributeSupplierMoar(mTokenCollateral, borrower);\\n        distributeSupplierMoar(mTokenCollateral, liquidator);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\\n     * @param mToken The market to verify the transfer against\\n     * @param src The account which sources the tokens\\n     * @param dst The account which receives the tokens\\n     * @param transferTokens The number of mTokens to transfer\\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function transferAllowed(address mToken, address src, address dst, uint transferTokens) external override returns (uint) {\\n        // Pausing is a very serious situation - we revert to sound the alarms\\n        require(!transferGuardianPaused, \\\"transfer is paused\\\");\\n\\n        // Currently the only consideration is whether or not\\n        //  the src is allowed to redeem this many tokens\\n        uint allowed = redeemAllowedInternal(mToken, src, transferTokens);\\n        if (allowed != uint(Error.NO_ERROR)) {\\n            return allowed;\\n        }\\n\\n        // Keep the flywheel moving\\n        updateMoarSupplyIndex(mToken);\\n        distributeSupplierMoar(mToken, src);\\n        distributeSupplierMoar(mToken, dst);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /*** Liquidity/Liquidation Calculations ***/\\n\\n    /**\\n     * @notice Determine the current account liquidity wrt collateral requirements\\n     * @return (possible error code (semi-opaque),\\n                account liquidity in excess of collateral requirements,\\n     *          account shortfall below collateral requirements)\\n     */\\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, MToken(0), 0, 0);\\n\\n        return (uint(err), liquidity, shortfall);\\n    }\\n\\n    /**\\n     * @notice Determine the current account liquidity wrt collateral requirements\\n     * @return (possible error code,\\n                account liquidity in excess of collateral requirements,\\n     *          account shortfall below collateral requirements)\\n     */\\n    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\\n        return getHypotheticalAccountLiquidityInternal(account, MToken(0), 0, 0);\\n    }\\n\\n    /**\\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\\n     * @param mTokenModify The market to hypothetically redeem/borrow in\\n     * @param account The account to determine liquidity for\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\n     * @return (possible error code (semi-opaque),\\n                hypothetical account liquidity in excess of collateral requirements,\\n     *          hypothetical account shortfall below collateral requirements)\\n     */\\n    function getHypotheticalAccountLiquidity(\\n        address account,\\n        address mTokenModify,\\n        uint redeemTokens,\\n        uint borrowAmount) public view returns (uint, uint, uint) {\\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, MToken(mTokenModify), redeemTokens, borrowAmount);\\n        return (uint(err), liquidity, shortfall);\\n    }\\n\\n    /**\\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\\n     * @param mTokenModify The market to hypothetically redeem/borrow in\\n     * @param account The account to determine liquidity for\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\n     * @dev Note that we calculate the exchangeRateStored for each collateral mToken using stored data,\\n     *  without calculating accumulated interest.\\n     * @return (possible error code,\\n                hypothetical account liquidity in excess of collateral requirements,\\n     *          hypothetical account shortfall below collateral requirements)\\n     */\\n    function getHypotheticalAccountLiquidityInternal(\\n        address account,\\n        MToken mTokenModify,\\n        uint redeemTokens,\\n        uint borrowAmount) internal view returns (Error, uint, uint) {\\n\\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\\n        uint oErr;\\n\\n        // For each asset the account is in\\n        MToken[] memory assets = accountAssets[account];\\n        for (uint i = 0; i < assets.length; i++) {\\n            MToken asset = assets[i];\\n            address _account = account;\\n\\n            // Read the balances and exchange rate from the mToken\\n            (oErr, vars.mTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(_account);\\n            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\\n                return (Error.SNAPSHOT_ERROR, 0, 0);\\n            }\\n            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\\n\\n            // Get the normalized price of the asset\\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\\n            if (vars.oraclePriceMantissa == 0) {\\n                return (Error.PRICE_ERROR, 0, 0);\\n            }\\n            vars.oraclePrice = mul_(Exp({mantissa: vars.oraclePriceMantissa}), 10**uint256(18 - EIP20Interface(asset.getUnderlying()).decimals()));\\n\\n            // Pre-compute a conversion factor from tokens -> dai (normalized price value)\\n            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\\n\\n            // sumCollateral += tokensToDenom * mTokenBalance\\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.mTokenBalance, vars.sumCollateral);\\n\\n            // Protection value calculation sumCollateral += protectionValueLocked\\n            // Mark to market value calculation sumCollateral += markToMarketValue\\n            uint protectionValueLocked;\\n            uint markToMarketValue;\\n            (protectionValueLocked, markToMarketValue) = liquidityMathModel.getTotalProtectionLockedValue(LiquidityMathModelInterface.LiquidityMathArgumentsSet(asset, _account, markets[address(asset)].collateralFactorMantissa, cprotection, oracle));\\n            if (vars.sumCollateral < mul_( protectionValueLocked, vars.collateralFactor)) {\\n                vars.sumCollateral = 0;\\n            } else {\\n                vars.sumCollateral = sub_(vars.sumCollateral, mul_( protectionValueLocked, vars.collateralFactor));\\n            }\\n            vars.sumCollateral = add_(vars.sumCollateral, protectionValueLocked);\\n            vars.sumCollateral = add_(vars.sumCollateral, markToMarketValue);\\n\\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\\n\\n            // Calculate effects of interacting with mTokenModify\\n            if (asset == mTokenModify) {\\n                // redeem effect\\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\\n\\n                // borrow effect\\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\\n\\n                _account = account;\\n            }\\n        }\\n        // These are safe, as the underflow condition is checked first\\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\\n        } else {\\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the value of possible optimization left for asset\\n     * @param asset The MToken address\\n     * @param account The owner of asset\\n     * @return The value of possible optimization\\n     */\\n    function getMaxOptimizableValue(MToken asset, address account) public view returns(uint){\\n        return liquidityMathModel.getMaxOptimizableValue(\\n            LiquidityMathModelInterface.LiquidityMathArgumentsSet(\\n                asset, account, markets[address(asset)].collateralFactorMantissa, cprotection, oracle\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Returns the value of hypothetical optimization (ignoring existing optimization used) for asset\\n     * @param asset The MToken address\\n     * @param account The owner of asset\\n     * @return The amount of hypothetical optimization\\n     */\\n    function getHypotheticalOptimizableValue(MToken asset, address account) public view returns(uint){\\n        return liquidityMathModel.getHypotheticalOptimizableValue(\\n            LiquidityMathModelInterface.LiquidityMathArgumentsSet(\\n                asset, account, markets[address(asset)].collateralFactorMantissa, cprotection, oracle\\n            )\\n        );\\n    }\\n\\n    function liquidateCalculateSeizeUserTokens(address mTokenBorrowed, address mTokenCollateral, uint actualRepayAmount, address account) external override view returns (uint, uint) {\\n        return LiquidationModelInterface(liquidationModel).liquidateCalculateSeizeUserTokens(\\n            LiquidationModelInterface.LiquidateCalculateSeizeUserTokensArgumentsSet(\\n                oracle,\\n                this,\\n                mTokenBorrowed,\\n                mTokenCollateral,\\n                actualRepayAmount,\\n                account,\\n                liquidationIncentiveMantissa\\n            )\\n        );\\n    }\\n\\n\\n    /**\\n     * @notice Returns the amount of a specific asset that is locked under all c-ops\\n     * @param asset The MToken address\\n     * @param account The owner of asset\\n     * @return The amount of asset locked under c-ops\\n     */\\n    function getUserLockedAmount(MToken asset, address account) public override view returns(uint) {\\n        uint protectionLockedAmount;\\n        address currency = asset.underlying();\\n\\n        uint256 numOfProtections = cprotection.getUserUnderlyingProtectionTokenIdByCurrencySize(account, currency);\\n\\n        for (uint i = 0; i < numOfProtections; i++) {\\n            uint cProtectionId = cprotection.getUserUnderlyingProtectionTokenIdByCurrency(account, currency, i);\\n            if(cprotection.isProtectionAlive(cProtectionId)){\\n                protectionLockedAmount = protectionLockedAmount + cprotection.getUnderlyingProtectionLockedAmount(cProtectionId);\\n            }\\n        }\\n\\n        return protectionLockedAmount;\\n    }\\n\\n\\n\\n    /*** Admin Functions ***/\\n\\n    /**\\n      * @notice Sets a new price oracle for the moartroller\\n      * @dev Admin function to set a new price oracle\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\\n        }\\n\\n        // Track the old oracle for the moartroller\\n        PriceOracle oldOracle = oracle;\\n\\n        // Set moartroller's oracle to newOracle\\n        oracle = newOracle;\\n\\n        // Emit NewPriceOracle(oldOracle, newOracle)\\n        emit NewPriceOracle(oldOracle, newOracle);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Sets a new CProtection that is allowed to use as a collateral optimisation\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setProtection(address newCProtection) public returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\\n        }\\n\\n        MProtection oldCProtection = cprotection;\\n        cprotection = MProtection(newCProtection);\\n\\n        // Emit NewPriceOracle(oldOracle, newOracle)\\n        emit NewCProtection(oldCProtection, cprotection);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Sets the closeFactor used when liquidating borrows\\n      * @dev Admin function to set closeFactor\\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\\n      * @return uint 0=success, otherwise a failure\\n      */\\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\\n        // Check caller is admin\\n    \\trequire(msg.sender == admin, \\\"only admin can set close factor\\\");\\n\\n        uint oldCloseFactorMantissa = closeFactorMantissa;\\n        closeFactorMantissa = newCloseFactorMantissa;\\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Sets the collateralFactor for a market\\n      * @dev Admin function to set per-market collateralFactor\\n      * @param mToken The market to set the factor on\\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\\n      */\\n    function _setCollateralFactor(MToken mToken, uint newCollateralFactorMantissa) external returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\\n        }\\n\\n        // Verify market is listed\\n        Market storage market = markets[address(mToken)];\\n        if (!market.isListed) {\\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\\n        }\\n    \\n        // TODO: this check is temporary switched off. we can make exception for UNN later\\n\\n        // Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\\n        //\\n        //\\n        // Check collateral factor <= 0.9\\n        // Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\\n        // if (lessThanExp(highLimit, newCollateralFactorExp)) {\\n        //     return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\\n        // }\\n\\n        // If collateral factor != 0, fail if price == 0\\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(mToken) == 0) {\\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\\n        }\\n\\n        // Set market's collateral factor to new collateral factor, remember old value\\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\\n\\n        // Emit event with asset, old collateral factor, and new collateral factor\\n        emit NewCollateralFactor(mToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Sets liquidationIncentive\\n      * @dev Admin function to set liquidationIncentive\\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\\n      */\\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\\n        }\\n\\n        // Save current value for use in log\\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\\n\\n        // Set liquidation incentive to new incentive\\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\\n\\n        // Emit event with old incentive, new incentive\\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n        function _setRewardClaimEnabled(bool status) external returns (uint) {\\n        // Check caller is admin\\n    \\trequire(msg.sender == admin, \\\"only admin can set close factor\\\");\\n        rewardClaimEnabled = status;\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Add the market to the markets mapping and set it as listed\\n      * @dev Admin function to set isListed and add support for the market\\n      * @param mToken The address of the market (token) to list\\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\\n      */\\n    function _supportMarket(MToken mToken) external returns (uint) {\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\\n        }\\n\\n        if (markets[address(mToken)].isListed) {\\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\\n        }\\n\\n        mToken.isMToken(); // Sanity check to make sure its really a MToken\\n\\n        // Note that isMoared is not in active use anymore\\n        markets[address(mToken)] = Market({isListed: true, isMoared: false, collateralFactorMantissa: 0});\\n        tokenAddressToMToken[address(mToken.underlying())] = mToken;\\n\\n        _addMarketInternal(address(mToken));\\n\\n        emit MarketListed(mToken);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    function _addMarketInternal(address mToken) internal {\\n        for (uint i = 0; i < allMarkets.length; i ++) {\\n            require(allMarkets[i] != MToken(mToken), \\\"market already added\\\");\\n        }\\n        allMarkets.push(MToken(mToken));\\n    }\\n\\n    /**\\n      * @notice Set the given borrow caps for the given mToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\\n      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\\n      * @param mTokens The addresses of the markets (tokens) to change the borrow caps for\\n      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\\n      */\\n    function _setMarketBorrowCaps(MToken[] calldata mTokens, uint[] calldata newBorrowCaps) external {\\n    \\trequire(msg.sender == admin || msg.sender == borrowCapGuardian, \\\"only admin or borrow cap guardian can set borrow caps\\\"); \\n\\n        uint numMarkets = mTokens.length;\\n        uint numBorrowCaps = newBorrowCaps.length;\\n\\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \\\"invalid input\\\");\\n\\n        for(uint i = 0; i < numMarkets; i++) {\\n            borrowCaps[address(mTokens[i])] = newBorrowCaps[i];\\n            emit NewBorrowCap(mTokens[i], newBorrowCaps[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Admin function to change the Borrow Cap Guardian\\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\\n     */\\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\\n        require(msg.sender == admin, \\\"only admin can set borrow cap guardian\\\");\\n\\n        // Save current value for inclusion in log\\n        address oldBorrowCapGuardian = borrowCapGuardian;\\n\\n        // Store borrowCapGuardian with value newBorrowCapGuardian\\n        borrowCapGuardian = newBorrowCapGuardian;\\n\\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\\n    }\\n\\n    /**\\n     * @notice Admin function to change the Pause Guardian\\n     * @param newPauseGuardian The address of the new Pause Guardian\\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\\n     */\\n    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\\n        }\\n\\n        // Save current value for inclusion in log\\n        address oldPauseGuardian = pauseGuardian;\\n\\n        // Store pauseGuardian with value newPauseGuardian\\n        pauseGuardian = newPauseGuardian;\\n\\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    function _setMintPaused(MToken mToken, bool state) public returns (bool) {\\n        require(markets[address(mToken)].isListed, \\\"cannot pause a market that is not listed\\\");\\n        require(msg.sender == pauseGuardian || msg.sender == admin, \\\"only pause guardian and admin can pause\\\");\\n        require(msg.sender == admin || state == true, \\\"only admin can unpause\\\");\\n\\n        mintGuardianPaused[address(mToken)] = state;\\n        emit ActionPausedMToken(mToken, \\\"Mint\\\", state);\\n        return state;\\n    }\\n\\n    function _setBorrowPaused(MToken mToken, bool state) public returns (bool) {\\n        require(markets[address(mToken)].isListed, \\\"cannot pause a market that is not listed\\\");\\n        require(msg.sender == pauseGuardian || msg.sender == admin, \\\"only pause guardian and admin can pause\\\");\\n        require(msg.sender == admin || state == true, \\\"only admin can unpause\\\");\\n\\n        borrowGuardianPaused[address(mToken)] = state;\\n        emit ActionPausedMToken(mToken, \\\"Borrow\\\", state);\\n        return state;\\n    }\\n\\n    function _setTransferPaused(bool state) public returns (bool) {\\n        require(msg.sender == pauseGuardian || msg.sender == admin, \\\"only pause guardian and admin can pause\\\");\\n        require(msg.sender == admin || state == true, \\\"only admin can unpause\\\");\\n\\n        transferGuardianPaused = state;\\n        emit ActionPaused(\\\"Transfer\\\", state);\\n        return state;\\n    }\\n\\n    function _setSeizePaused(bool state) public returns (bool) {\\n        require(msg.sender == pauseGuardian || msg.sender == admin, \\\"only pause guardian and admin can pause\\\");\\n        require(msg.sender == admin || state == true, \\\"only admin can unpause\\\");\\n\\n        seizeGuardianPaused = state;\\n        emit ActionPaused(\\\"Seize\\\", state);\\n        return state;\\n    }\\n\\n    /**\\n     * @notice Checks caller is admin, or this contract is becoming the new implementation\\n     */\\n    function adminOrInitializing() internal view returns (bool) {\\n        return msg.sender == admin || msg.sender == moartrollerImplementation;\\n    }\\n\\n    /*** MOAR Distribution ***/\\n\\n    /**\\n     * @notice Set MOAR speed for a single market\\n     * @param mToken The market whose MOAR speed to update\\n     * @param moarSpeed New MOAR speed for market\\n     */\\n    function setMoarSpeedInternal(MToken mToken, uint moarSpeed) internal {\\n        uint currentMoarSpeed = moarSpeeds[address(mToken)];\\n        if (currentMoarSpeed != 0) {\\n            // note that MOAR speed could be set to 0 to halt liquidity rewards for a market\\n            Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});\\n            updateMoarSupplyIndex(address(mToken));\\n            updateMoarBorrowIndex(address(mToken), borrowIndex);\\n        } else if (moarSpeed != 0) {\\n            // Add the MOAR market\\n            Market storage market = markets[address(mToken)];\\n            require(market.isListed == true, \\\"MOAR market is not listed\\\");\\n\\n            if (moarSupplyState[address(mToken)].index == 0 && moarSupplyState[address(mToken)].block == 0) {\\n                moarSupplyState[address(mToken)] = MoarMarketState({\\n                    index: moarInitialIndex,\\n                    block: safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\")\\n                });\\n            }\\n\\n            if (moarBorrowState[address(mToken)].index == 0 && moarBorrowState[address(mToken)].block == 0) {\\n                moarBorrowState[address(mToken)] = MoarMarketState({\\n                    index: moarInitialIndex,\\n                    block: safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\")\\n                });\\n            }\\n        }\\n\\n        if (currentMoarSpeed != moarSpeed) {\\n            moarSpeeds[address(mToken)] = moarSpeed;\\n            emit MoarSpeedUpdated(mToken, moarSpeed);\\n        }\\n    }\\n\\n    /**\\n     * @notice Accrue MOAR to the market by updating the supply index\\n     * @param mToken The market whose supply index to update\\n     */\\n    function updateMoarSupplyIndex(address mToken) internal {\\n        MoarMarketState storage supplyState = moarSupplyState[mToken];\\n        uint supplySpeed = moarSpeeds[mToken];\\n        uint blockNumber = getBlockNumber();\\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\\n        if (deltaBlocks > 0 && supplySpeed > 0) {\\n            uint supplyTokens = MToken(mToken).totalSupply();\\n            uint moarAccrued = mul_(deltaBlocks, supplySpeed);\\n            Double memory ratio = supplyTokens > 0 ? fraction(moarAccrued, supplyTokens) : Double({mantissa: 0});\\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\\n            moarSupplyState[mToken] = MoarMarketState({\\n                index: safe224(index.mantissa, \\\"new index exceeds 224 bits\\\"),\\n                block: safe32(blockNumber, \\\"block number exceeds 32 bits\\\")\\n            });\\n        } else if (deltaBlocks > 0) {\\n            supplyState.block = safe32(blockNumber, \\\"block number exceeds 32 bits\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Accrue MOAR to the market by updating the borrow index\\n     * @param mToken The market whose borrow index to update\\n     */\\n    function updateMoarBorrowIndex(address mToken, Exp memory marketBorrowIndex) internal {\\n        MoarMarketState storage borrowState = moarBorrowState[mToken];\\n        uint borrowSpeed = moarSpeeds[mToken];\\n        uint blockNumber = getBlockNumber();\\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\\n            uint borrowAmount = div_(MToken(mToken).totalBorrows(), marketBorrowIndex);\\n            uint moarAccrued = mul_(deltaBlocks, borrowSpeed);\\n            Double memory ratio = borrowAmount > 0 ? fraction(moarAccrued, borrowAmount) : Double({mantissa: 0});\\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\\n            moarBorrowState[mToken] = MoarMarketState({\\n                index: safe224(index.mantissa, \\\"new index exceeds 224 bits\\\"),\\n                block: safe32(blockNumber, \\\"block number exceeds 32 bits\\\")\\n            });\\n        } else if (deltaBlocks > 0) {\\n            borrowState.block = safe32(blockNumber, \\\"block number exceeds 32 bits\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate MOAR accrued by a supplier and possibly transfer it to them\\n     * @param mToken The market in which the supplier is interacting\\n     * @param supplier The address of the supplier to distribute MOAR to\\n     */\\n    function distributeSupplierMoar(address mToken, address supplier) internal {\\n        MoarMarketState storage supplyState = moarSupplyState[mToken];\\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\\n        Double memory supplierIndex = Double({mantissa: moarSupplierIndex[mToken][supplier]});\\n        moarSupplierIndex[mToken][supplier] = supplyIndex.mantissa;\\n\\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\\n            supplierIndex.mantissa = moarInitialIndex;\\n        }\\n\\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\\n        uint supplierTokens = MToken(mToken).balanceOf(supplier);\\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\\n        uint supplierAccrued = add_(moarAccrued[supplier], supplierDelta);\\n        moarAccrued[supplier] = supplierAccrued;\\n        emit DistributedSupplierMoar(MToken(mToken), supplier, supplierDelta, supplyIndex.mantissa);\\n    }\\n\\n    /**\\n     * @notice Calculate MOAR accrued by a borrower and possibly transfer it to them\\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\\n     * @param mToken The market in which the borrower is interacting\\n     * @param borrower The address of the borrower to distribute MOAR to\\n     */\\n    function distributeBorrowerMoar(address mToken, address borrower, Exp memory marketBorrowIndex) internal {\\n        MoarMarketState storage borrowState = moarBorrowState[mToken];\\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\\n        Double memory borrowerIndex = Double({mantissa: moarBorrowerIndex[mToken][borrower]});\\n        moarBorrowerIndex[mToken][borrower] = borrowIndex.mantissa;\\n        \\n        if (borrowerIndex.mantissa > 0) {\\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\\n            uint borrowerAmount = div_(MToken(mToken).borrowBalanceStored(borrower), marketBorrowIndex);\\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\\n            uint borrowerAccrued = add_(moarAccrued[borrower], borrowerDelta);\\n            moarAccrued[borrower] = borrowerAccrued;\\n            emit DistributedBorrowerMoar(MToken(mToken), borrower, borrowerDelta, borrowIndex.mantissa);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate additional accrued MOAR for a contributor since last accrual\\n     * @param contributor The address to calculate contributor rewards for\\n     */\\n    function updateContributorRewards(address contributor) public {\\n        uint moarSpeed = moarContributorSpeeds[contributor];\\n        uint blockNumber = getBlockNumber();\\n        uint deltaBlocks = sub_(blockNumber, lastContributorBlock[contributor]);\\n        if (deltaBlocks > 0 && moarSpeed > 0) {\\n            uint newAccrued = mul_(deltaBlocks, moarSpeed);\\n            uint contributorAccrued = add_(moarAccrued[contributor], newAccrued);\\n\\n            moarAccrued[contributor] = contributorAccrued;\\n            lastContributorBlock[contributor] = blockNumber;\\n        }\\n    }\\n\\n    /**\\n     * @notice Claim all the MOAR accrued by holder in all markets\\n     * @param holder The address to claim MOAR for\\n     */\\n    function claimMoarReward(address holder) public {\\n        return claimMoar(holder, allMarkets);\\n    }\\n\\n    /**\\n     * @notice Claim all the MOAR accrued by holder in the specified markets\\n     * @param holder The address to claim MOAR for\\n     * @param mTokens The list of markets to claim MOAR in\\n     */\\n    function claimMoar(address holder, MToken[] memory mTokens) public {\\n        address[] memory holders = new address[](1);\\n        holders[0] = holder;\\n        claimMoar(holders, mTokens, true, true);\\n    }\\n\\n    /**\\n     * @notice Claim all MOAR accrued by the holders\\n     * @param holders The addresses to claim MOAR for\\n     * @param mTokens The list of markets to claim MOAR in\\n     * @param borrowers Whether or not to claim MOAR earned by borrowing\\n     * @param suppliers Whether or not to claim MOAR earned by supplying\\n     */\\n    function claimMoar(address[] memory holders, MToken[] memory mTokens, bool borrowers, bool suppliers) public {\\n        require(rewardClaimEnabled, \\\"reward claim is disabled\\\");\\n        for (uint i = 0; i < mTokens.length; i++) {\\n            MToken mToken = mTokens[i];\\n            require(markets[address(mToken)].isListed, \\\"market must be listed\\\");\\n            if (borrowers == true) {\\n                Exp memory borrowIndex = Exp({mantissa: mToken.borrowIndex()});\\n                updateMoarBorrowIndex(address(mToken), borrowIndex);\\n                for (uint j = 0; j < holders.length; j++) {\\n                    distributeBorrowerMoar(address(mToken), holders[j], borrowIndex);\\n                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);\\n                }\\n            }\\n            if (suppliers == true) {\\n                updateMoarSupplyIndex(address(mToken));\\n                for (uint j = 0; j < holders.length; j++) {\\n                    distributeSupplierMoar(address(mToken), holders[j]);\\n                    moarAccrued[holders[j]] = grantMoarInternal(holders[j], moarAccrued[holders[j]]);\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfer MOAR to the user\\n     * @dev Note: If there is not enough MOAR, we do not perform the transfer all.\\n     * @param user The address of the user to transfer MOAR to\\n     * @param amount The amount of MOAR to (possibly) transfer\\n     * @return The amount of MOAR which was NOT transferred to the user\\n     */\\n    function grantMoarInternal(address user, uint amount) internal returns (uint) {\\n        EIP20Interface moar = EIP20Interface(getMoarAddress());\\n        uint moarRemaining = moar.balanceOf(address(this));\\n        if (amount > 0 && amount <= moarRemaining) {\\n            moar.approve(mProxy, amount);\\n            MProxyInterface(mProxy).proxyClaimReward(getMoarAddress(), user, amount);\\n            return 0;\\n        }\\n        return amount;\\n    }\\n\\n    /*** MOAR Distribution Admin ***/\\n\\n    /**\\n     * @notice Transfer MOAR to the recipient\\n     * @dev Note: If there is not enough MOAR, we do not perform the transfer all.\\n     * @param recipient The address of the recipient to transfer MOAR to\\n     * @param amount The amount of MOAR to (possibly) transfer\\n     */\\n    function _grantMoar(address recipient, uint amount) public {\\n        require(adminOrInitializing(), \\\"only admin can grant MOAR\\\");\\n        uint amountLeft = grantMoarInternal(recipient, amount);\\n        require(amountLeft == 0, \\\"insufficient MOAR for grant\\\");\\n        emit MoarGranted(recipient, amount);\\n    }\\n\\n    /**\\n     * @notice Set MOAR speed for a single market\\n     * @param mToken The market whose MOAR speed to update\\n     * @param moarSpeed New MOAR speed for market\\n     */\\n    function _setMoarSpeed(MToken mToken, uint moarSpeed) public {\\n        require(adminOrInitializing(), \\\"only admin can set MOAR speed\\\");\\n        setMoarSpeedInternal(mToken, moarSpeed);\\n    }\\n\\n    /**\\n     * @notice Set MOAR speed for a single contributor\\n     * @param contributor The contributor whose MOAR speed to update\\n     * @param moarSpeed New MOAR speed for contributor\\n     */\\n    function _setContributorMoarSpeed(address contributor, uint moarSpeed) public {\\n        require(adminOrInitializing(), \\\"only admin can set MOAR speed\\\");\\n\\n        // note that MOAR speed could be set to 0 to halt liquidity rewards for a contributor\\n        updateContributorRewards(contributor);\\n        if (moarSpeed == 0) {\\n            // release storage\\n            delete lastContributorBlock[contributor];\\n        } else {\\n            lastContributorBlock[contributor] = getBlockNumber();\\n        }\\n        moarContributorSpeeds[contributor] = moarSpeed;\\n\\n        emit ContributorMoarSpeedUpdated(contributor, moarSpeed);\\n    }\\n\\n    /**\\n     * @notice Set liquidity math model implementation\\n     * @param mathModel the math model implementation\\n     */\\n    function _setLiquidityMathModel(LiquidityMathModelInterface mathModel) public {\\n        require(msg.sender == admin, \\\"only admin can set liquidity math model implementation\\\");\\n\\n        LiquidityMathModelInterface oldLiquidityMathModel = liquidityMathModel;\\n        liquidityMathModel = mathModel;\\n\\n        emit NewLiquidityMathModel(address(oldLiquidityMathModel), address(liquidityMathModel));\\n    }\\n\\n    /**\\n     * @notice Set liquidation model implementation\\n     * @param newLiquidationModel the liquidation model implementation\\n     */\\n    function _setLiquidationModel(LiquidationModelInterface newLiquidationModel) public {\\n        require(msg.sender == admin, \\\"only admin can set liquidation model implementation\\\");\\n\\n        LiquidationModelInterface oldLiquidationModel = liquidationModel;\\n        liquidationModel = newLiquidationModel;\\n\\n        emit NewLiquidationModel(address(oldLiquidationModel), address(liquidationModel));\\n    }\\n\\n\\n    function _setMoarToken(address moarTokenAddress) public {\\n        require(msg.sender == admin, \\\"only admin can set MOAR token address\\\");\\n        moarToken = moarTokenAddress;\\n    }\\n\\n    function _setMProxy(address mProxyAddress) public {\\n        require(msg.sender == admin, \\\"only admin can set MProxy address\\\");\\n        mProxy = mProxyAddress;\\n    }\\n\\n    /**\\n     * @notice Add new privileged address \\n     * @param privilegedAddress address to add\\n     */\\n    function _addPrivilegedAddress(address privilegedAddress) public {\\n        require(msg.sender == admin, \\\"only admin can set liquidity math model implementation\\\");\\n        privilegedAddresses[privilegedAddress] = 1;\\n    }\\n\\n    /**\\n     * @notice Remove privileged address \\n     * @param privilegedAddress address to remove\\n     */\\n    function _removePrivilegedAddress(address privilegedAddress) public {\\n        require(msg.sender == admin, \\\"only admin can set liquidity math model implementation\\\");\\n        delete privilegedAddresses[privilegedAddress];\\n    }\\n\\n    /**\\n     * @notice Check if address if privileged\\n     * @param privilegedAddress address to check\\n     */\\n    function isPrivilegedAddress(address privilegedAddress) public view returns (bool) {\\n        return privilegedAddresses[privilegedAddress] == 1;\\n    }\\n    \\n    /**\\n     * @notice Return all of the markets\\n     * @dev The automatic getter may be used to access an individual market.\\n     * @return The list of market addresses\\n     */\\n    function getAllMarkets() public view returns (MToken[] memory) {\\n        return allMarkets;\\n    }\\n\\n    function getBlockNumber() public view returns (uint) {\\n        return block.number;\\n    }\\n\\n    /**\\n     * @notice Return the address of the MOAR token\\n     * @return The address of MOAR\\n     */\\n    function getMoarAddress() public view returns (address) {\\n        return moarToken;\\n    }\\n\\n    function getContractVersion() external override pure returns(string memory){\\n        return \\\"V1\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AbstractInterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.6.12;\\n\\nimport \\\"./Interfaces/InterestRateModelInterface.sol\\\";\\n\\nabstract contract AbstractInterestRateModel is InterestRateModelInterface {\\n\\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\\n    bool public constant isInterestRateModel = true;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\nimport \\\"../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/Versionable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.6.12;\\n\\ninterface Versionable {\\n    function getContractVersion() external pure returns (string memory);\\n}\"\r\n    },\r\n    \"contracts/MToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.6.12;\\n\\nimport \\\"./Utils/ErrorReporter.sol\\\";\\nimport \\\"./Utils/Exponential.sol\\\";\\nimport \\\"./Interfaces/EIP20Interface.sol\\\";\\nimport \\\"./MTokenStorage.sol\\\";\\nimport \\\"./Interfaces/MTokenInterface.sol\\\";\\nimport \\\"./Interfaces/MProxyInterface.sol\\\";\\nimport \\\"./Moartroller.sol\\\";\\nimport \\\"./AbstractInterestRateModel.sol\\\";\\n\\n/**\\n * @title MOAR's MToken Contract\\n * @notice Abstract base for MTokens\\n * @author MOAR\\n */\\nabstract contract MToken is MTokenInterface, Exponential, TokenErrorReporter, MTokenStorage {\\n    /**\\n     * @notice Indicator that this is a MToken contract (for inspection)\\n     */\\n    bool public constant isMToken = true;\\n\\n\\n    /*** Market Events ***/\\n\\n    /**\\n     * @notice Event emitted when interest is accrued\\n     */\\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when tokens are minted\\n     */\\n    event Mint(address minter, uint mintAmount, uint mintTokens);\\n\\n    /**\\n     * @notice Event emitted when tokens are redeemed\\n     */\\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\\n\\n    /**\\n     * @notice Event emitted when underlying is borrowed\\n     */\\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when a borrow is repaid\\n     */\\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when a borrow is liquidated\\n     */\\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address MTokenCollateral, uint seizeTokens);\\n\\n\\n    /*** Admin Events ***/\\n\\n    /**\\n     * @notice Event emitted when pendingAdmin is changed\\n     */\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    /**\\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\\n     */\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    /**\\n     * @notice Event emitted when moartroller is changed\\n     */\\n    event NewMoartroller(Moartroller oldMoartroller, Moartroller newMoartroller);\\n\\n    /**\\n     * @notice Event emitted when interestRateModel is changed\\n     */\\n    event NewMarketInterestRateModel(InterestRateModelInterface oldInterestRateModel, InterestRateModelInterface newInterestRateModel);\\n\\n    /**\\n     * @notice Event emitted when the reserve factor is changed\\n     */\\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\\n\\n    /**\\n     * @notice Event emitted when the reserves are added\\n     */\\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\\n\\n    /**\\n     * @notice Event emitted when the reserves are reduced\\n     */\\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\\n\\n    /**\\n     * @notice EIP20 Transfer event\\n     */\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n\\n    /**\\n     * @notice EIP20 Approval event\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\n\\n    /**\\n     * @notice Failure event\\n     */\\n    event Failure(uint error, uint info, uint detail);\\n\\n    /**\\n     * @notice Max protection composition value updated event \\n     */\\n    event MpcUpdated(uint newValue);\\n\\n    /**\\n     * @notice Initialize the money market\\n     * @param moartroller_ The address of the Moartroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ EIP-20 name of this token\\n     * @param symbol_ EIP-20 symbol of this token\\n     * @param decimals_ EIP-20 decimal precision of this token\\n     */\\n    function init(Moartroller moartroller_,\\n                        AbstractInterestRateModel interestRateModel_,\\n                        uint initialExchangeRateMantissa_,\\n                        string memory name_,\\n                        string memory symbol_,\\n                        uint8 decimals_) public {\\n        require(msg.sender == admin, \\\"not_admin\\\");\\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \\\"already_init\\\");\\n\\n        // Set initial exchange rate\\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\\n        require(initialExchangeRateMantissa > 0, \\\"too_low\\\");\\n\\n        // Set the moartroller\\n        uint err = _setMoartroller(moartroller_);\\n        require(err == uint(Error.NO_ERROR), \\\"setting moartroller failed\\\");\\n\\n        // Initialize block number and borrow index (block number mocks depend on moartroller being set)\\n        accrualBlockNumber = getBlockNumber();\\n        borrowIndex = mantissaOne;\\n\\n        // Set the interest rate model (depends on block number / borrow index)\\n        err = _setInterestRateModelFresh(interestRateModel_);\\n        require(err == uint(Error.NO_ERROR), \\\"setting IRM failed\\\");\\n\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = decimals_;\\n\\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\\n        _notEntered = true;\\n\\n        maxProtectionComposition = 5000;\\n        maxProtectionCompositionMantissa = 1e4;\\n        reserveFactorMaxMantissa = 1e18;\\n        borrowRateMaxMantissa = 0.0005e16;\\n    }\\n\\n    /**\\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\\n     * @dev Called by both `transfer` and `transferFrom` internally\\n     * @param spender The address of the account performing the transfer\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param tokens The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\\n        /* Fail if transfer not allowed */\\n        uint allowed = moartroller.transferAllowed(address(this), src, dst, tokens);\\n        if (allowed != 0) {\\n            return failOpaque(Error.MOARTROLLER_REJECTION, FailureInfo.TRANSFER_MOARTROLLER_REJECTION, allowed);\\n        }\\n\\n        /* Do not allow self-transfers */\\n        if (src == dst) {\\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\\n        }\\n\\n        /* Get the allowance, infinite for the account owner */\\n        uint startingAllowance = 0;\\n        if (spender == src) {\\n            startingAllowance = uint(-1);\\n        } else {\\n            startingAllowance = transferAllowances[src][spender];\\n        }\\n\\n        /* Do the calculations, checking for {under,over}flow */\\n        MathError mathErr;\\n        uint allowanceNew;\\n        uint srmTokensNew;\\n        uint dstTokensNew;\\n\\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\\n        }\\n\\n        (mathErr, srmTokensNew) = subUInt(accountTokens[src], tokens);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\\n        }\\n\\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        accountTokens[src] = srmTokensNew;\\n        accountTokens[dst] = dstTokensNew;\\n\\n        /* Eat some of the allowance (if necessary) */\\n        if (startingAllowance != uint(-1)) {\\n            transferAllowances[src][spender] = allowanceNew;\\n        }\\n\\n        /* We emit a Transfer event */\\n        emit Transfer(src, dst, tokens);\\n\\n        // unused function\\n        // moartroller.transferVerify(address(this), src, dst, tokens);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transfer(address dst, uint256 amount) external virtual override nonReentrant returns (bool) {\\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transferFrom(address src, address dst, uint256 amount) external virtual override nonReentrant returns (bool) {\\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved (-1 means infinite)\\n     * @return Whether or not the approval succeeded\\n     */\\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\\n        address src = msg.sender;\\n        transferAllowances[src][spender] = amount;\\n        emit Approval(src, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Get the current allowance from `owner` for `spender`\\n     * @param owner The address of the account which owns the tokens to be spent\\n     * @param spender The address of the account which may transfer tokens\\n     * @return The number of tokens allowed to be spent (-1 means infinite)\\n     */\\n    function allowance(address owner, address spender) external virtual override view returns (uint256) {\\n        return transferAllowances[owner][spender];\\n    }\\n\\n    /**\\n     * @notice Get the token balance of the `owner`\\n     * @param owner The address of the account to query\\n     * @return The number of tokens owned by `owner`\\n     */\\n    function balanceOf(address owner) external virtual override view returns (uint256) {\\n        return accountTokens[owner];\\n    }\\n\\n    /**\\n     * @notice Get the underlying balance of the `owner`\\n     * @dev This also accrues interest in a transaction\\n     * @param owner The address of the account to query\\n     * @return The amount of underlying owned by `owner`\\n     */\\n    function balanceOfUnderlying(address owner) external virtual override returns (uint) {\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\\n        require(mErr == MathError.NO_ERROR, \\\"balance_calculation_failed\\\");\\n        return balance;\\n    }\\n\\n    /**\\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\\n     * @dev This is used by moartroller to more efficiently perform liquidity checks.\\n     * @param account Address of the account to snapshot\\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\\n     */\\n    function getAccountSnapshot(address account) external virtual override view returns (uint, uint, uint, uint) {\\n        uint mTokenBalance = accountTokens[account];\\n        uint borrowBalance;\\n        uint exchangeRateMantissa;\\n\\n        MathError mErr;\\n\\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\\n        if (mErr != MathError.NO_ERROR) {\\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\\n        }\\n\\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\\n        if (mErr != MathError.NO_ERROR) {\\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\\n        }\\n\\n        return (uint(Error.NO_ERROR), mTokenBalance, borrowBalance, exchangeRateMantissa);\\n    }\\n\\n    /**\\n     * @dev Function to simply retrieve block number\\n     *  This exists mainly for inheriting test contracts to stub this result.\\n     */\\n    function getBlockNumber() internal view returns (uint) {\\n        return block.number;\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block borrow interest rate for this mToken\\n     * @return The borrow interest rate per block, scaled by 1e18\\n     */\\n    function borrowRatePerBlock() external virtual override view returns (uint) {\\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block supply interest rate for this mToken\\n     * @return The supply interest rate per block, scaled by 1e18\\n     */\\n    function supplyRatePerBlock() external virtual override view returns (uint) {\\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\\n    }\\n\\n    /**\\n     * @notice Returns the current total borrows plus accrued interest\\n     * @return The total borrows with interest\\n     */\\n    function totalBorrowsCurrent() external virtual override nonReentrant returns (uint) {\\n        require(accrueInterest() == uint(Error.NO_ERROR), \\\"accrue interest failed\\\");\\n        return totalBorrows;\\n    }\\n\\n    /**\\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\\n     * @param account The address whose balance should be calculated after updating borrowIndex\\n     * @return The calculated balance\\n     */\\n    function borrowBalanceCurrent(address account) external virtual override nonReentrant returns (uint) {\\n        require(accrueInterest() == uint(Error.NO_ERROR), \\\"accrue interest failed\\\");\\n        return borrowBalanceStored(account);\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return The calculated balance\\n     */\\n    function borrowBalanceStored(address account) public virtual view returns (uint) {\\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\\n        require(err == MathError.NO_ERROR, \\\"borrowBalanceStored failed\\\");\\n        return result;\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\\n     */\\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\\n        /* Note: we do not assert that the market is up to date */\\n        MathError mathErr;\\n        uint principalTimesIndex;\\n        uint result;\\n\\n        /* Get borrowBalance and borrowIndex */\\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\\n\\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\\n         */\\n        if (borrowSnapshot.principal == 0) {\\n            return (MathError.NO_ERROR, 0);\\n        }\\n\\n        /* Calculate new borrow balance using the interest index:\\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\\n         */\\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return (mathErr, 0);\\n        }\\n\\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return (mathErr, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, result);\\n    }\\n\\n    /**\\n     * @notice Accrue interest then return the up-to-date exchange rate\\n     * @return Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateCurrent() public virtual nonReentrant returns (uint) {\\n        require(accrueInterest() == uint(Error.NO_ERROR), \\\"accrue interest failed\\\");\\n        return exchangeRateStored();\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the MToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateStored() public virtual view returns (uint) {\\n        (MathError err, uint result) = exchangeRateStoredInternal();\\n        require(err == MathError.NO_ERROR, \\\"exchangeRateStored failed\\\");\\n        return result;\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the MToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return (error code, calculated exchange rate scaled by 1e18)\\n     */\\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\\n        uint _totalSupply = totalSupply;\\n        if (_totalSupply == 0) {\\n            /*\\n             * If there are no tokens minted:\\n             *  exchangeRate = initialExchangeRate\\n             */\\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\\n        } else {\\n            /*\\n             * Otherwise:\\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\\n             */\\n            uint totalCash = getCashPrior();\\n            uint cashPlusBorrowsMinusReserves;\\n            Exp memory exchangeRate;\\n            MathError mathErr;\\n\\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\\n            if (mathErr != MathError.NO_ERROR) {\\n                return (mathErr, 0);\\n            }\\n\\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\\n            if (mathErr != MathError.NO_ERROR) {\\n                return (mathErr, 0);\\n            }\\n\\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\\n        }\\n    }\\n\\n    /**\\n     * @notice Get cash balance of this mToken in the underlying asset\\n     * @return The quantity of underlying asset owned by this contract\\n     */\\n    function getCash() external virtual override view returns (uint) {\\n        return getCashPrior();\\n    }\\n\\n    function getRealBorrowIndex() public view returns (uint) {\\n        uint currentBlockNumber = getBlockNumber();\\n        uint accrualBlockNumberPrior = accrualBlockNumber;\\n        uint cashPrior = getCashPrior();\\n        uint borrowsPrior = totalBorrows;\\n        uint reservesPrior = totalReserves;\\n        uint borrowIndexPrior = borrowIndex;\\n\\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \\\"borrow rate too high\\\");\\n\\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\\n        require(mathErr == MathError.NO_ERROR, \\\"could not calc block delta\\\");\\n\\n        Exp memory simpleInterestFactor;\\n        uint borrowIndexNew;\\n\\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\\n        require(mathErr == MathError.NO_ERROR, \\\"could not calc simpleInterestFactor\\\");\\n\\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\\n        require(mathErr == MathError.NO_ERROR, \\\"could not calc borrowIndex\\\");\\n\\n        return borrowIndexNew;\\n    }\\n\\n    /**\\n     * @notice Applies accrued interest to total borrows and reserves\\n     * @dev This calculates interest accrued from the last checkpointed block\\n     *   up to the current block and writes new checkpoint to storage.\\n     */\\n    function accrueInterest() public virtual returns (uint) {\\n        /* Remember the initial block number */\\n        uint currentBlockNumber = getBlockNumber();\\n        uint accrualBlockNumberPrior = accrualBlockNumber;\\n\\n        /* Short-circuit accumulating 0 interest */\\n        if (accrualBlockNumberPrior == currentBlockNumber) {\\n            return uint(Error.NO_ERROR);\\n        }\\n\\n        /* Read the previous values out of storage */\\n        uint cashPrior = getCashPrior();\\n        uint borrowsPrior = totalBorrows;\\n        uint reservesPrior = totalReserves;\\n        uint borrowIndexPrior = borrowIndex;\\n\\n        /* Calculate the current borrow interest rate */\\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \\\"borrow rate too high\\\");\\n\\n        /* Calculate the number of blocks elapsed since the last accrual */\\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\\n        require(mathErr == MathError.NO_ERROR, \\\"could not calc block delta\\\");\\n\\n        /*\\n         * Calculate the interest accumulated into borrows and reserves and the new index:\\n         *  simpleInterestFactor = borrowRate * blockDelta\\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\\n         */\\n\\n        Exp memory simpleInterestFactor;\\n        AccrueInterestTempStorage memory temp;\\n\\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\\n        }\\n\\n        (mathErr, temp.interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\\n        }\\n\\n        (mathErr, temp.totalBorrowsNew) = addUInt(temp.interestAccumulated, borrowsPrior);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\\n        }\\n\\n        (mathErr, temp.reservesAdded) = mulScalarTruncate(Exp({mantissa: reserveFactorMantissa}), temp.interestAccumulated);\\n        if(mathErr != MathError.NO_ERROR){\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\\n        }\\n\\n        (mathErr, temp.splitedReserves_2) = mulScalarTruncate(Exp({mantissa: reserveSplitFactorMantissa}), temp.reservesAdded);\\n        if(mathErr != MathError.NO_ERROR){\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\\n        }\\n\\n        (mathErr, temp.splitedReserves_1) = subUInt(temp.reservesAdded, temp.splitedReserves_2);\\n        if(mathErr != MathError.NO_ERROR){\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\\n        }\\n\\n        (mathErr, temp.totalReservesNew) = addUInt(temp.splitedReserves_1, reservesPrior);\\n        if(mathErr != MathError.NO_ERROR){\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\\n        }\\n\\n        (mathErr, temp.borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We write the previously calculated values into storage */\\n        accrualBlockNumber = currentBlockNumber;\\n        borrowIndex = temp.borrowIndexNew;\\n        totalBorrows = temp.totalBorrowsNew;\\n        totalReserves = temp.totalReservesNew;\\n\\n        if(temp.splitedReserves_2 > 0){\\n            address mProxy = moartroller.mProxy();\\n            EIP20Interface(underlying).approve(mProxy, temp.splitedReserves_2);\\n            MProxyInterface(mProxy).proxySplitReserves(underlying, temp.splitedReserves_2);\\n        }\\n        \\n        /* We emit an AccrueInterest event */\\n        emit AccrueInterest(cashPrior, temp.interestAccumulated, temp.borrowIndexNew, temp.totalBorrowsNew);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n    \\n    /**\\n     * @notice Sender supplies assets into the market and receives mTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\\n     */\\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\\n        }\\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\n        return mintFresh(msg.sender, mintAmount);\\n    }\\n\\n    struct MintLocalVars {\\n        Error err;\\n        MathError mathErr;\\n        uint exchangeRateMantissa;\\n        uint mintTokens;\\n        uint totalSupplyNew;\\n        uint accountTokensNew;\\n        uint actualMintAmount;\\n    }\\n\\n    /**\\n     * @notice User supplies assets into the market and receives mTokens in exchange\\n     * @dev Assumes interest has already been accrued up to the current block\\n     * @param minter The address of the account which is supplying the assets\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\\n     */\\n    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\\n        /* Fail if mint not allowed */\\n        uint allowed = moartroller.mintAllowed(address(this), minter, mintAmount);\\n        if (allowed != 0) {\\n            return (failOpaque(Error.MOARTROLLER_REJECTION, FailureInfo.MINT_MOARTROLLER_REJECTION, allowed), 0);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\\n        }\\n\\n        MintLocalVars memory vars;\\n\\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\\n        if (vars.mathErr != MathError.NO_ERROR) {\\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         *  We call `doTransferIn` for the minter and the mintAmount.\\n         *  Note: The mToken must handle variations between ERC-20 and ETH underlying.\\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\\n         *  side-effects occurred. The function returns the amount actually transferred,\\n         *  in case of a fee. On success, the mToken holds an additional `actualMintAmount`\\n         *  of cash.\\n         */\\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\\n\\n        /*\\n         * We get the current exchange rate and calculate the number of mTokens to be minted:\\n         *  mintTokens = actualMintAmount / exchangeRate\\n         */\\n\\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\\n        require(vars.mathErr == MathError.NO_ERROR, \\\"MINT_E\\\");\\n\\n        /*\\n         * We calculate the new total supply of mTokens and minter token balance, checking for overflow:\\n         *  totalSupplyNew = totalSupply + mintTokens\\n         *  accountTokensNew = accountTokens[minter] + mintTokens\\n         */\\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\\n        require(vars.mathErr == MathError.NO_ERROR, \\\"MINT_E\\\");\\n\\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\\n        require(vars.mathErr == MathError.NO_ERROR, \\\"MINT_E\\\");\\n\\n        /* We write previously calculated values into storage */\\n        totalSupply = vars.totalSupplyNew;\\n        accountTokens[minter] = vars.accountTokensNew;\\n\\n        /* We emit a Mint event, and a Transfer event */\\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\\n        emit Transfer(address(this), minter, vars.mintTokens);\\n\\n        /* We call the defense hook */\\n        // unused function\\n        // moartroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\\n\\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\\n    }\\n\\n    /**\\n     * @notice Sender redeems mTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of mTokens to redeem into underlying\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\\n        }\\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\\n        return redeemFresh(msg.sender, redeemTokens, 0);\\n    }\\n\\n    /**\\n     * @notice Sender redeems mTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to receive from redeeming mTokens\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\\n        }\\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\\n        return redeemFresh(msg.sender, 0, redeemAmount);\\n    }\\n\\n    struct RedeemLocalVars {\\n        Error err;\\n        MathError mathErr;\\n        uint exchangeRateMantissa;\\n        uint redeemTokens;\\n        uint redeemAmount;\\n        uint totalSupplyNew;\\n        uint accountTokensNew;\\n    }\\n\\n    /**\\n     * @notice User redeems mTokens in exchange for the underlying asset\\n     * @dev Assumes interest has already been accrued up to the current block\\n     * @param redeemer The address of the account which is redeeming the tokens\\n     * @param redeemTokensIn The number of mTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming mTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \\\"redeemFresh_missing_zero\\\");\\n\\n        RedeemLocalVars memory vars;\\n\\n        /* exchangeRate = invoke Exchange Rate Stored() */\\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\\n        if (vars.mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\\n        }\\n\\n        /* If redeemTokensIn > 0: */\\n        if (redeemTokensIn > 0) {\\n            /*\\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\\n             *  redeemTokens = redeemTokensIn\\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\\n             */\\n            vars.redeemTokens = redeemTokensIn;\\n\\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\\n            if (vars.mathErr != MathError.NO_ERROR) {\\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\\n            }\\n        } else {\\n            /*\\n             * We get the current exchange rate and calculate the amount to be redeemed:\\n             *  redeemTokens = redeemAmountIn / exchangeRate\\n             *  redeemAmount = redeemAmountIn\\n             */\\n\\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\\n            if (vars.mathErr != MathError.NO_ERROR) {\\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\\n            }\\n\\n            vars.redeemAmount = redeemAmountIn;\\n        }\\n\\n        /* Fail if redeem not allowed */\\n        uint allowed = moartroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\\n        if (allowed != 0) {\\n            return failOpaque(Error.MOARTROLLER_REJECTION, FailureInfo.REDEEM_MOARTROLLER_REJECTION, allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\\n        }\\n\\n        /*\\n         * We calculate the new total supply and redeemer balance, checking for underflow:\\n         *  totalSupplyNew = totalSupply - redeemTokens\\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\\n         */\\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\\n        if (vars.mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\\n        }\\n\\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\\n        if (vars.mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\\n        }\\n\\n        /* Fail gracefully if protocol has insufficient cash */\\n        if (getCashPrior() < vars.redeemAmount) {\\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\\n        }\\n\\n        /* Fail if user tries to redeem more than he has locked with c-op*/\\n        // TODO: update error codes\\n        uint newTokensAmount =  div_(mul_(vars.accountTokensNew, vars.exchangeRateMantissa), 1e18);\\n        if (newTokensAmount < moartroller.getUserLockedAmount(this, redeemer)) {\\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\\n        }\\n\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\\n         *  Note: The mToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the mToken has redeemAmount less of cash.\\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         */\\n        doTransferOut(redeemer, vars.redeemAmount);\\n\\n        /* We write previously calculated values into storage */\\n        totalSupply = vars.totalSupplyNew;\\n        accountTokens[redeemer] = vars.accountTokensNew;\\n\\n        /* We emit a Transfer event, and a Redeem event */\\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\\n\\n        /* We call the defense hook */\\n        moartroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Sender borrows assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\\n        }\\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\\n        return borrowFresh(msg.sender, borrowAmount);\\n    }\\n\\n    function borrowForInternal(address payable borrower, uint borrowAmount) internal nonReentrant returns (uint) {\\n        require(moartroller.isPrivilegedAddress(msg.sender), \\\"permission_missing\\\");\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\\n        }\\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\\n        return borrowFresh(borrower, borrowAmount);\\n    }\\n\\n    struct BorrowLocalVars {\\n        MathError mathErr;\\n        uint accountBorrows;\\n        uint accountBorrowsNew;\\n        uint totalBorrowsNew;\\n    }\\n\\n    /**\\n      * @notice Users borrow assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\\n        /* Fail if borrow not allowed */\\n        uint allowed = moartroller.borrowAllowed(address(this), borrower, borrowAmount);\\n        if (allowed != 0) {\\n            return failOpaque(Error.MOARTROLLER_REJECTION, FailureInfo.BORROW_MOARTROLLER_REJECTION, allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\\n        }\\n\\n        /* Fail gracefully if protocol has insufficient underlying cash */\\n        if (getCashPrior() < borrowAmount) {\\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\\n        }\\n\\n        BorrowLocalVars memory vars;\\n\\n        /*\\n         * We calculate the new borrower and total borrow balances, failing on overflow:\\n         *  accountBorrowsNew = accountBorrows + borrowAmount\\n         *  totalBorrowsNew = totalBorrows + borrowAmount\\n         */\\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\\n        if (vars.mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\\n        }\\n\\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\\n        if (vars.mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\\n        }\\n\\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\\n        if (vars.mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We invoke doTransferOut for the borrower and the borrowAmount.\\n         *  Note: The mToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the mToken borrowAmount less of cash.\\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         */\\n        doTransferOut(borrower, borrowAmount);\\n\\n        /* We write the previously calculated values into storage */\\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = vars.totalBorrowsNew;\\n\\n        /* We emit a Borrow event */\\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\\n\\n        /* We call the defense hook */\\n        //unused function\\n        // moartroller.borrowVerify(address(this), borrower, borrowAmount);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @param repayAmount The amount to repay\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\n     */\\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\\n        }\\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount The amount to repay\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\n     */\\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\\n        }\\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\\n    }\\n\\n    struct RepayBorrowLocalVars {\\n        Error err;\\n        MathError mathErr;\\n        uint repayAmount;\\n        uint borrowerIndex;\\n        uint accountBorrows;\\n        uint accountBorrowsNew;\\n        uint totalBorrowsNew;\\n        uint actualRepayAmount;\\n    }\\n\\n    /**\\n     * @notice Borrows are repaid by another user (possibly the borrower).\\n     * @param payer the account paying off the borrow\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount the amount of undelrying tokens being returned\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\n     */\\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\\n        /* Fail if repayBorrow not allowed */\\n        uint allowed = moartroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\\n        if (allowed != 0) {\\n            return (failOpaque(Error.MOARTROLLER_REJECTION, FailureInfo.REPAY_BORROW_MOARTROLLER_REJECTION, allowed), 0);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\\n        }\\n\\n        RepayBorrowLocalVars memory vars;\\n\\n        /* We remember the original borrowerIndex for verification purposes */\\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\\n\\n        /* We fetch the amount the borrower owes, with accumulated interest */\\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\\n        if (vars.mathErr != MathError.NO_ERROR) {\\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\\n        }\\n\\n        /* If repayAmount == -1, repayAmount = accountBorrows */\\n        /* If the borrow is repaid by another user -1 cannot be used to prevent borrow front-running */\\n        if (repayAmount == uint(-1)) {\\n            require(tx.origin == borrower, \\\"specify a precise amount\\\");\\n            vars.repayAmount = vars.accountBorrows;\\n        } else {\\n            vars.repayAmount = repayAmount;\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We call doTransferIn for the payer and the repayAmount\\n         *  Note: The mToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the mToken holds an additional repayAmount of cash.\\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         *   it returns the amount actually transferred, in case of a fee.\\n         */\\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\\n\\n        /*\\n         * We calculate the new borrower and total borrow balances, failing on underflow:\\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\\n         */\\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\\n        require(vars.mathErr == MathError.NO_ERROR, \\\"BORROW_BALANCE_CALCULATION_FAILED\\\");\\n\\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\\n        require(vars.mathErr == MathError.NO_ERROR, \\\"TOTAL_BALANCE_CALCULATION_FAILED\\\");\\n\\n        /* We write the previously calculated values into storage */\\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = vars.totalBorrowsNew;\\n\\n        /* We emit a RepayBorrow event */\\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\\n\\n        /* We call the defense hook */\\n        // unused function\\n        // moartroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\\n\\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this mToken to be liquidated\\n     * @param mTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\n     */\\n    function liquidateBorrowInternal(address borrower, uint repayAmount, MToken mTokenCollateral) internal nonReentrant returns (uint, uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\\n        }\\n\\n        error = mTokenCollateral.accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\\n        }\\n\\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, mTokenCollateral);\\n    }\\n\\n    /**\\n     * @notice The liquidator liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this mToken to be liquidated\\n     * @param liquidator The address repaying the borrow and seizing collateral\\n     * @param mTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\n     */\\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, MToken mTokenCollateral) internal returns (uint, uint) {\\n        /* Fail if liquidate not allowed */\\n        uint allowed = moartroller.liquidateBorrowAllowed(address(this), address(mTokenCollateral), liquidator, borrower, repayAmount);\\n        if (allowed != 0) {\\n            return (failOpaque(Error.MOARTROLLER_REJECTION, FailureInfo.LIQUIDATE_MOARTROLLER_REJECTION, allowed), 0);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\\n        }\\n\\n        /* Verify mTokenCollateral market's block number equals current block number */\\n        if (mTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\\n        }\\n\\n        /* Fail if borrower = liquidator */\\n        if (borrower == liquidator) {\\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\\n        }\\n\\n        /* Fail if repayAmount = 0 */\\n        if (repayAmount == 0) {\\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\\n        }\\n\\n        /* Fail if repayAmount = -1 */\\n        if (repayAmount == uint(-1)) {\\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\\n        }\\n\\n\\n        /* Fail if repayBorrow fails */\\n        (uint repayBorrowError, uint actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\\n            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We calculate the number of collateral tokens that will be seized */\\n        (uint amountSeizeError, uint seizeTokens) = moartroller.liquidateCalculateSeizeUserTokens(address(this), address(mTokenCollateral), actualRepayAmount, borrower);\\n        require(amountSeizeError == uint(Error.NO_ERROR), \\\"CALCULATE_AMOUNT_SEIZE_FAILED\\\");\\n\\n        /* Revert if borrower collateral token balance < seizeTokens */\\n        require(mTokenCollateral.balanceOf(borrower) >= seizeTokens, \\\"TOO_MUCH\\\");\\n\\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\\n        uint seizeError;\\n        if (address(mTokenCollateral) == address(this)) {\\n            seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\\n        } else {\\n            seizeError = mTokenCollateral.seize(liquidator, borrower, seizeTokens);\\n        }\\n\\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\\n        require(seizeError == uint(Error.NO_ERROR), \\\"token seizure failed\\\");\\n\\n        /* We emit a LiquidateBorrow event */\\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(mTokenCollateral), seizeTokens);\\n\\n        /* We call the defense hook */\\n        // unused function\\n        // moartroller.liquidateBorrowVerify(address(this), address(mTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);\\n\\n        return (uint(Error.NO_ERROR), actualRepayAmount);\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Will fail unless called by another mToken during the process of liquidation.\\n     *  Its absolutely critical to use msg.sender as the borrowed mToken and not a parameter.\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of mTokens to seize\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function seize(address liquidator, address borrower, uint seizeTokens) external virtual override nonReentrant returns (uint) {\\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another MToken.\\n     *  Its absolutely critical to use msg.sender as the seizer mToken and not a parameter.\\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed mToken)\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of mTokens to seize\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\\n        /* Fail if seize not allowed */\\n        uint allowed = moartroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\\n        if (allowed != 0) {\\n            return failOpaque(Error.MOARTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_MOARTROLLER_REJECTION, allowed);\\n        }\\n\\n        /* Fail if borrower = liquidator */\\n        if (borrower == liquidator) {\\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\\n        }\\n\\n        MathError mathErr;\\n        uint borrowerTokensNew;\\n        uint liquidatorTokensNew;\\n\\n        /*\\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\\n         */\\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\\n        }\\n\\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We write the previously calculated values into storage */\\n        accountTokens[borrower] = borrowerTokensNew;\\n        accountTokens[liquidator] = liquidatorTokensNew;\\n\\n        /* Emit a Transfer event */\\n        emit Transfer(borrower, liquidator, seizeTokens);\\n\\n        /* We call the defense hook */\\n        // unused function\\n        // moartroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n\\n    /*** Admin Functions ***/\\n\\n    /**\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @param newPendingAdmin New pending admin.\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setPendingAdmin(address payable newPendingAdmin) external virtual override returns (uint) {\\n        // Check caller = admin\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\\n        }\\n\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n      * @dev Admin function for pending admin to accept role and update admin\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _acceptAdmin() external virtual override returns (uint) {\\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\\n        }\\n\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n\\n        // Clear the pending value\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Sets a new moartroller for the market\\n      * @dev Admin function to set a new moartroller\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setMoartroller(Moartroller newMoartroller) public virtual returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MOARTROLLER_OWNER_CHECK);\\n        }\\n\\n        Moartroller oldMoartroller = moartroller;\\n        // Ensure invoke moartroller.isMoartroller() returns true\\n        require(newMoartroller.isMoartroller(), \\\"not_moartroller\\\");\\n\\n        // Set market's moartroller to newMoartroller\\n        moartroller = newMoartroller;\\n\\n        // Emit NewMoartroller(oldMoartroller, newMoartroller)\\n        emit NewMoartroller(oldMoartroller, newMoartroller);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\\n      * @dev Admin function to accrue interest and set a new reserve factor\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setReserveFactor(uint newReserveFactorMantissa) external virtual override nonReentrant returns (uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\\n        }\\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\\n        return _setReserveFactorFresh(newReserveFactorMantissa);\\n    }\\n\\n    function _setReserveSplitFactor(uint newReserveSplitFactorMantissa) external nonReentrant returns (uint) {\\n         if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\\n        }\\n        reserveSplitFactorMantissa = newReserveSplitFactorMantissa;\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\\n      * @dev Admin function to set a new reserve factor\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\\n        }\\n\\n        // Verify market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\\n        }\\n\\n        // Check newReserveFactor ≤ maxReserveFactor\\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\\n        }\\n\\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\\n        reserveFactorMantissa = newReserveFactorMantissa;\\n\\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Accrues interest and reduces reserves by transferring from msg.sender\\n     * @param addAmount Amount of addition to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\\n        }\\n\\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\\n        (error, ) = _addReservesFresh(addAmount);\\n        return error;\\n    }\\n\\n    /**\\n     * @notice Add reserves by transferring from caller\\n     * @dev Requires fresh interest accrual\\n     * @param addAmount Amount of addition to reserves\\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\\n     */\\n    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\\n        // totalReserves + actualAddAmount\\n        uint totalReservesNew;\\n        uint actualAddAmount;\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We call doTransferIn for the caller and the addAmount\\n         *  Note: The mToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the mToken holds an additional addAmount of cash.\\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         *  it returns the amount actually transferred, in case of a fee.\\n         */\\n\\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\\n\\n        totalReservesNew = totalReserves + actualAddAmount;\\n\\n        /* Revert on overflow */\\n        require(totalReservesNew >= totalReserves, \\\"overflow\\\");\\n\\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\\n        totalReserves = totalReservesNew;\\n\\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\\n\\n        /* Return (NO_ERROR, actualAddAmount) */\\n        return (uint(Error.NO_ERROR), actualAddAmount);\\n    }\\n\\n\\n    /**\\n     * @notice Accrues interest and reduces reserves by transferring to admin\\n     * @param reduceAmount Amount of reduction to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _reduceReserves(uint reduceAmount) external virtual override nonReentrant returns (uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\\n        }\\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\\n        return _reduceReservesFresh(reduceAmount);\\n    }\\n\\n    /**\\n     * @notice Reduces reserves by transferring to admin\\n     * @dev Requires fresh interest accrual\\n     * @param reduceAmount Amount of reduction to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\\n        // totalReserves - reduceAmount\\n        uint totalReservesNew;\\n\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\\n        }\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\\n        }\\n\\n        // Fail gracefully if protocol has insufficient underlying cash\\n        if (getCashPrior() < reduceAmount) {\\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\\n        }\\n\\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\\n        if (reduceAmount > totalReserves) {\\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        totalReservesNew = totalReserves - reduceAmount;\\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\\n        require(totalReservesNew <= totalReserves, \\\"underflow\\\");\\n\\n        // Store reserves[n+1] = reserves[n] - reduceAmount\\n        totalReserves = totalReservesNew;\\n\\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n        doTransferOut(admin, reduceAmount);\\n\\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\\n     * @dev Admin function to accrue interest and update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setInterestRateModel(AbstractInterestRateModel newInterestRateModel) public virtual returns (uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\\n        }\\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\\n        return _setInterestRateModelFresh(newInterestRateModel);\\n    }\\n\\n    /**\\n     * @notice updates the interest rate model (*requires fresh interest accrual)\\n     * @dev Admin function to update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setInterestRateModelFresh(AbstractInterestRateModel newInterestRateModel) internal returns (uint) {\\n\\n        // Used to store old model for use in the event that is emitted on success\\n        InterestRateModelInterface oldInterestRateModel;\\n\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\\n        }\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\\n        }\\n\\n        // Track the market's current interest rate model\\n        oldInterestRateModel = interestRateModel;\\n\\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\\n        require(newInterestRateModel.isInterestRateModel(), \\\"not_interest_model\\\");\\n\\n        // Set the interest rate model to newInterestRateModel\\n        interestRateModel = newInterestRateModel;\\n\\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Sets new value for max protection composition parameter \\n     * @param newMPC New value of MPC\\n     * @return uint 0=success, otherwise a failure \\n     */\\n    function _setMaxProtectionComposition(uint256 newMPC) external returns(uint){\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\\n        }\\n\\n        maxProtectionComposition = newMPC;\\n        emit MpcUpdated(newMPC);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Returns address of underlying token\\n     * @return address of underlying token\\n     */\\n    function getUnderlying() external override view returns(address){\\n        return underlying;\\n    }\\n\\n    /*** Safe Token ***/\\n\\n    /**\\n     * @notice Gets balance of this contract in terms of the underlying\\n     * @dev This excludes the value of the current message, if any\\n     * @return The quantity of underlying owned by this contract\\n     */\\n    function getCashPrior() internal virtual view returns (uint);\\n\\n    /**\\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\\n     *  This may revert due to insufficient balance or insufficient allowance.\\n     */\\n    function doTransferIn(address from, uint amount) internal virtual returns (uint);\\n\\n    /**\\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\\n     */\\n    function doTransferOut(address payable to, uint amount) internal virtual;\\n\\n\\n    /*** Reentrancy Guard ***/\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     */\\n    modifier nonReentrant() {\\n        require(_notEntered, \\\"re-entered\\\");\\n        _notEntered = false;\\n        _;\\n        _notEntered = true; // get a gas-refund post-Istanbul\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/MErc20Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.6.12;\\n\\nimport \\\"../MToken.sol\\\";\\n\\ninterface MErc20Interface {\\n    /*** User contract ***/\\n    function mint(uint mintAmount) external returns (uint);\\n    function redeem(uint redeemTokens) external returns (uint);\\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\\n    function borrow(uint borrowAmount) external returns (uint);\\n    function borrowFor(address payable borrower, uint borrowAmount) external returns (uint);\\n    function repayBorrow(uint repayAmount) external returns (uint);\\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\\n    function liquidateBorrow(address borrower, uint repayAmount, MToken mTokenCollateral) external returns (uint);\\n\\n    /*** Admin Functions ***/\\n    function _addReserves(uint addAmount) external returns (uint);\\n}\"\r\n    },\r\n    \"contracts/Interfaces/EIP20Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.6.12;\\n\\n/**\\n * @title ERC 20 Token Standard Interface\\n *  https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface EIP20Interface {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n      * @notice Get the total number of tokens in circulation\\n      * @return The supply of tokens\\n      */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return balance The balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return success Whether or not the transfer succeeded\\n      */\\n    function transfer(address dst, uint256 amount) external returns (bool);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param src The address of the source account\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return success Whether or not the transfer succeeded\\n      */\\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool);\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved (-1 means infinite)\\n      * @return success Whether or not the approval succeeded\\n      */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return remaining The number of tokens allowed to be spent (-1 means infinite)\\n      */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/Utils/SafeEIP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../Interfaces/EIP20Interface.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title SafeEIP20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * This is a forked version of Openzeppelin's SafeERC20 contract but supporting\\n * EIP20Interface instead of Openzeppelin's IERC20\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeEIP20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(EIP20Interface token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(EIP20Interface token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(EIP20Interface token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(EIP20Interface token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(EIP20Interface token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(EIP20Interface token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Utils/ErrorReporter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.6.12;\\n\\ncontract MoartrollerErrorReporter {\\n    enum Error {\\n        NO_ERROR,\\n        UNAUTHORIZED,\\n        MOARTROLLER_MISMATCH,\\n        INSUFFICIENT_SHORTFALL,\\n        INSUFFICIENT_LIQUIDITY,\\n        INVALID_CLOSE_FACTOR,\\n        INVALID_COLLATERAL_FACTOR,\\n        INVALID_LIQUIDATION_INCENTIVE,\\n        MARKET_NOT_ENTERED, // no longer possible\\n        MARKET_NOT_LISTED,\\n        MARKET_ALREADY_LISTED,\\n        MATH_ERROR,\\n        NONZERO_BORROW_BALANCE,\\n        PRICE_ERROR,\\n        REJECTION,\\n        SNAPSHOT_ERROR,\\n        TOO_MANY_ASSETS,\\n        TOO_MUCH_REPAY\\n    }\\n\\n    enum FailureInfo {\\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\\n        EXIT_MARKET_BALANCE_OWED,\\n        EXIT_MARKET_REJECTION,\\n        SET_CLOSE_FACTOR_OWNER_CHECK,\\n        SET_CLOSE_FACTOR_VALIDATION,\\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\\n        SET_COLLATERAL_FACTOR_VALIDATION,\\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\\n        SET_IMPLEMENTATION_OWNER_CHECK,\\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\\n        SET_MAX_ASSETS_OWNER_CHECK,\\n        SET_PENDING_ADMIN_OWNER_CHECK,\\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\\n        SET_PRICE_ORACLE_OWNER_CHECK,\\n        SUPPORT_MARKET_EXISTS,\\n        SUPPORT_MARKET_OWNER_CHECK,\\n        SUPPORT_PROTECTION_OWNER_CHECK,\\n        SET_PAUSE_GUARDIAN_OWNER_CHECK\\n    }\\n\\n    /**\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\n      **/\\n    event Failure(uint error, uint info, uint detail);\\n\\n    /**\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\n      */\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), 0);\\n\\n        return uint(err);\\n    }\\n\\n    /**\\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\n      */\\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), opaqueError);\\n\\n        return uint(err);\\n    }\\n}\\n\\ncontract TokenErrorReporter {\\n    enum Error {\\n        NO_ERROR,\\n        UNAUTHORIZED,\\n        BAD_INPUT,\\n        MOARTROLLER_REJECTION,\\n        MOARTROLLER_CALCULATION_ERROR,\\n        INTEREST_RATE_MODEL_ERROR,\\n        INVALID_ACCOUNT_PAIR,\\n        INVALID_CLOSE_AMOUNT_REQUESTED,\\n        INVALID_COLLATERAL_FACTOR,\\n        MATH_ERROR,\\n        MARKET_NOT_FRESH,\\n        MARKET_NOT_LISTED,\\n        TOKEN_INSUFFICIENT_ALLOWANCE,\\n        TOKEN_INSUFFICIENT_BALANCE,\\n        TOKEN_INSUFFICIENT_CASH,\\n        TOKEN_TRANSFER_IN_FAILED,\\n        TOKEN_TRANSFER_OUT_FAILED\\n    }\\n\\n    /*\\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\\n     *       This is because FailureInfo grows significantly faster, and\\n     *       the order of Error has some meaning, while the order of FailureInfo\\n     *       is entirely arbitrary.\\n     */\\n    enum FailureInfo {\\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\\n        BORROW_ACCRUE_INTEREST_FAILED,\\n        BORROW_CASH_NOT_AVAILABLE,\\n        BORROW_FRESHNESS_CHECK,\\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\\n        BORROW_MARKET_NOT_LISTED,\\n        BORROW_MOARTROLLER_REJECTION,\\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\\n        LIQUIDATE_MOARTROLLER_REJECTION,\\n        LIQUIDATE_MOARTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\\n        LIQUIDATE_FRESHNESS_CHECK,\\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\\n        LIQUIDATE_SEIZE_MOARTROLLER_REJECTION,\\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\\n        LIQUIDATE_SEIZE_TOO_MUCH,\\n        MINT_ACCRUE_INTEREST_FAILED,\\n        MINT_MOARTROLLER_REJECTION,\\n        MINT_EXCHANGE_CALCULATION_FAILED,\\n        MINT_EXCHANGE_RATE_READ_FAILED,\\n        MINT_FRESHNESS_CHECK,\\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\\n        MINT_TRANSFER_IN_FAILED,\\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\\n        REDEEM_ACCRUE_INTEREST_FAILED,\\n        REDEEM_MOARTROLLER_REJECTION,\\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\\n        REDEEM_FRESHNESS_CHECK,\\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\\n        REDUCE_RESERVES_ADMIN_CHECK,\\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\\n        REDUCE_RESERVES_FRESH_CHECK,\\n        REDUCE_RESERVES_VALIDATION,\\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\\n        REPAY_BORROW_MOARTROLLER_REJECTION,\\n        REPAY_BORROW_FRESHNESS_CHECK,\\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\\n        SET_COLLATERAL_FACTOR_VALIDATION,\\n        SET_MOARTROLLER_OWNER_CHECK,\\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\\n        SET_MAX_ASSETS_OWNER_CHECK,\\n        SET_ORACLE_MARKET_NOT_LISTED,\\n        SET_PENDING_ADMIN_OWNER_CHECK,\\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\\n        SET_RESERVE_FACTOR_FRESH_CHECK,\\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\\n        TRANSFER_MOARTROLLER_REJECTION,\\n        TRANSFER_NOT_ALLOWED,\\n        TRANSFER_NOT_ENOUGH,\\n        TRANSFER_TOO_MUCH,\\n        ADD_RESERVES_ACCRUE_INTEREST_FAILED,\\n        ADD_RESERVES_FRESH_CHECK,\\n        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE\\n    }\\n\\n    /**\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\n      **/\\n    event Failure(uint error, uint info, uint detail);\\n\\n    /**\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\n      */\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), 0);\\n\\n        return uint(err);\\n    }\\n\\n    /**\\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\n      */\\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), opaqueError);\\n\\n        return uint(err);\\n    }\\n}\\n\\ncontract LiquidityMathModelErrorReporter {\\n    enum Error {\\n        NO_ERROR,\\n        UNAUTHORIZED,\\n        PRICE_ERROR,\\n        SNAPSHOT_ERROR\\n    }\\n\\n    enum FailureInfo {\\n        ORACLE_PRICE_CHECK_FAILED\\n    }\\n\\n    /**\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\n      **/\\n    event Failure(uint error, uint info, uint detail);\\n\\n    /**\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\n      */\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), 0);\\n\\n        return uint(err);\\n    }\\n\\n    /**\\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\n      */\\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), opaqueError);\\n\\n        return uint(err);\\n    }\\n}\"\r\n    },\r\n    \"contracts/Utils/Exponential.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\nimport \\\"./CarefulMath.sol\\\";\\nimport \\\"./ExponentialNoError.sol\\\";\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract Exponential is CarefulMath, ExponentialNoError {\\n    /**\\n     * @dev Creates an exponential from numerator and denominator values.\\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\\n     *            or if `denom` is zero.\\n     */\\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\\n        if (err1 != MathError.NO_ERROR) {\\n            return (err1, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\\n    }\\n\\n    /**\\n     * @dev Adds two exponentials, returning a new exponential.\\n     */\\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\\n\\n        return (error, Exp({mantissa: result}));\\n    }\\n\\n    /**\\n     * @dev Subtracts two exponentials, returning a new exponential.\\n     */\\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\\n\\n        return (error, Exp({mantissa: result}));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\\n     */\\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n     */\\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, truncate(product));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n     */\\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return addUInt(truncate(product), addend);\\n    }\\n\\n    /**\\n     * @dev Divide an Exp by a scalar, returning a new Exp.\\n     */\\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\\n    }\\n\\n    /**\\n     * @dev Divide a scalar by an Exp, returning a new Exp.\\n     */\\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\\n        /*\\n          We are doing this as:\\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\\n\\n          How it works:\\n          Exp = a / b;\\n          Scalar = s;\\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\\n        */\\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n        return getExp(numerator, divisor.mantissa);\\n    }\\n\\n    /**\\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\\n     */\\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, truncate(fraction));\\n    }\\n\\n    /**\\n     * @dev Multiplies two exponentials, returning a new exponential.\\n     */\\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n\\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        // We add half the scale before dividing so that we get rounding instead of truncation.\\n        //  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717\\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\\n        if (err1 != MathError.NO_ERROR) {\\n            return (err1, Exp({mantissa: 0}));\\n        }\\n\\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\\n        assert(err2 == MathError.NO_ERROR);\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\\n    }\\n\\n    /**\\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\\n     */\\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\\n    }\\n\\n    /**\\n     * @dev Multiplies three exponentials, returning a new exponential.\\n     */\\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\\n        (MathError err, Exp memory ab) = mulExp(a, b);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, ab);\\n        }\\n        return mulExp(ab, c);\\n    }\\n\\n    /**\\n     * @dev Divides two exponentials, returning a new exponential.\\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\\n     */\\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n        return getExp(a.mantissa, b.mantissa);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MTokenStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.6.12;\\n\\nimport \\\"./Moartroller.sol\\\";\\nimport \\\"./AbstractInterestRateModel.sol\\\";\\n\\nabstract contract MTokenStorage {\\n    /**\\n     * @dev Guard variable for re-entrancy checks\\n     */\\n    bool internal _notEntered;\\n\\n    /**\\n     * @dev EIP-20 token name for this token\\n     */\\n    string public name;\\n\\n    /**\\n     * @dev EIP-20 token symbol for this token\\n     */\\n    string public symbol;\\n\\n    /**\\n     * @dev EIP-20 token decimals for this token\\n     */\\n    uint8 public decimals;\\n\\n    /**\\n     * @notice Underlying asset for this MToken\\n     */\\n    address public underlying;\\n\\n    /**\\n     * @dev Maximum borrow rate that can ever be applied (.0005% / block)\\n     */\\n\\n    uint internal borrowRateMaxMantissa;\\n\\n    /**\\n     * @dev Maximum fraction of interest that can be set aside for reserves\\n     */\\n    uint internal reserveFactorMaxMantissa;\\n\\n    /**\\n     * @dev Administrator for this contract\\n     */\\n    address payable public admin;\\n\\n    /**\\n     * @dev Pending administrator for this contract\\n     */\\n    address payable public pendingAdmin;\\n\\n    /**\\n     * @dev Contract which oversees inter-mToken operations\\n     */\\n    Moartroller public moartroller;\\n\\n    /**\\n     * @dev Model which tells what the current interest rate should be\\n     */\\n    AbstractInterestRateModel public interestRateModel;\\n\\n    /**\\n     * @dev Initial exchange rate used when minting the first MTokens (used when totalSupply = 0)\\n     */\\n    uint internal initialExchangeRateMantissa;\\n\\n    /**\\n     * @dev Fraction of interest currently set aside for reserves\\n     */\\n    uint public reserveFactorMantissa;\\n\\n    /**\\n     * @dev Fraction of reserves currently set aside for other usage\\n     */\\n    uint public reserveSplitFactorMantissa;\\n\\n    /**\\n     * @dev Block number that interest was last accrued at\\n     */\\n    uint public accrualBlockNumber;\\n\\n    /**\\n     * @dev Accumulator of the total earned interest rate since the opening of the market\\n     */\\n    uint public borrowIndex;\\n\\n    /**\\n     * @dev Total amount of outstanding borrows of the underlying in this market\\n     */\\n    uint public totalBorrows;\\n\\n    /**\\n     * @dev Total amount of reserves of the underlying held in this market\\n     */\\n    uint public totalReserves;\\n\\n    /**\\n     * @dev Total number of tokens in circulation\\n     */\\n    uint public totalSupply;\\n\\n    /**\\n     * @dev The Maximum Protection Moarosition (MPC) factor for collateral optimisation, default: 50% = 5000\\n     */\\n    uint public maxProtectionComposition;\\n\\n    /**\\n     * @dev The Maximum Protection Moarosition (MPC) mantissa, default: 1e5\\n     */\\n    uint public maxProtectionCompositionMantissa;\\n\\n    /**\\n     * @dev Official record of token balances for each account\\n     */\\n    mapping (address => uint) internal accountTokens;\\n\\n    /**\\n     * @dev Approved token transfer amounts on behalf of others\\n     */\\n    mapping (address => mapping (address => uint)) internal transferAllowances;\\n\\n    struct ProtectionUsage {\\n        uint256 protectionValueUsed;\\n    }\\n\\n    /**\\n     * @dev Container for borrow balance information\\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\\n     */\\n    struct BorrowSnapshot {\\n        uint principal;\\n        uint interestIndex;\\n        mapping (uint256 => ProtectionUsage) protectionsUsed;\\n    }\\n\\n    struct AccrueInterestTempStorage{\\n        uint interestAccumulated;\\n        uint reservesAdded;\\n        uint splitedReserves_1;\\n        uint splitedReserves_2;\\n        uint totalBorrowsNew;\\n        uint totalReservesNew;\\n        uint borrowIndexNew;\\n    }\\n\\n    /**\\n     * @dev Mapping of account addresses to outstanding borrow balances\\n     */\\n    mapping(address => BorrowSnapshot) public accountBorrows;\\n\\n\\n}\"\r\n    },\r\n    \"contracts/Interfaces/MTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.6.12;\\n\\nimport \\\"./EIP20Interface.sol\\\";\\n\\ninterface MTokenInterface {\\n    /*** User contract ***/\\n    function transfer(address dst, uint256 amount) external returns (bool);\\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool);\\n    function approve(address spender, uint amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function balanceOfUnderlying(address owner) external returns (uint);\\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\\n    function borrowRatePerBlock() external view returns (uint);\\n    function supplyRatePerBlock() external view returns (uint);\\n    function totalBorrowsCurrent() external returns (uint);\\n    function borrowBalanceCurrent(address account) external returns (uint);\\n    function getCash() external view returns (uint);\\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);\\n    function getUnderlying() external view returns(address);\\n    function sweepToken(EIP20Interface token) external;\\n\\n\\n    /*** Admin Functions ***/\\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\\n    function _acceptAdmin() external returns (uint);\\n    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\\n    function _reduceReserves(uint reduceAmount) external returns (uint);\\n}\"\r\n    },\r\n    \"contracts/Interfaces/MProxyInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.6.12;\\n\\ninterface MProxyInterface {\\n  \\n    function proxyClaimReward(address asset, address recipient, uint amount) external;\\n    function proxySplitReserves(address asset, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Utils/CarefulMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/**\\n  * @title Careful Math\\n  * @author MOAR\\n  * @notice Derived from OpenZeppelin's SafeMath library\\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\\n  */\\ncontract CarefulMath {\\n\\n    /**\\n     * @dev Possible error codes that we can return\\n     */\\n    enum MathError {\\n        NO_ERROR,\\n        DIVISION_BY_ZERO,\\n        INTEGER_OVERFLOW,\\n        INTEGER_UNDERFLOW\\n    }\\n\\n    /**\\n    * @dev Multiplies two numbers, returns an error on overflow.\\n    */\\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        if (a == 0) {\\n            return (MathError.NO_ERROR, 0);\\n        }\\n\\n        uint c = a * b;\\n\\n        if (c / a != b) {\\n            return (MathError.INTEGER_OVERFLOW, 0);\\n        } else {\\n            return (MathError.NO_ERROR, c);\\n        }\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        if (b == 0) {\\n            return (MathError.DIVISION_BY_ZERO, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, a / b);\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        if (b <= a) {\\n            return (MathError.NO_ERROR, a - b);\\n        } else {\\n            return (MathError.INTEGER_UNDERFLOW, 0);\\n        }\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, returns an error on overflow.\\n    */\\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        uint c = a + b;\\n\\n        if (c >= a) {\\n            return (MathError.NO_ERROR, c);\\n        } else {\\n            return (MathError.INTEGER_OVERFLOW, 0);\\n        }\\n    }\\n\\n    /**\\n    * @dev add a and b and then subtract c\\n    */\\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\\n        (MathError err0, uint sum) = addUInt(a, b);\\n\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, 0);\\n        }\\n\\n        return subUInt(sum, c);\\n    }\\n}\"\r\n    },\r\n    \"contracts/Utils/ExponentialNoError.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract ExponentialNoError {\\n    uint constant expScale = 1e18;\\n    uint constant doubleScale = 1e36;\\n    uint constant halfExpScale = expScale/2;\\n    uint constant mantissaOne = expScale;\\n\\n    struct Exp {\\n        uint mantissa;\\n    }\\n\\n    struct Double {\\n        uint mantissa;\\n    }\\n\\n    /**\\n     * @dev Truncates the given exp to a whole number value.\\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\n     */\\n    function truncate(Exp memory exp) pure internal returns (uint) {\\n        // Note: We are not using careful math here as we're performing a division that cannot fail\\n        return exp.mantissa / expScale;\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n     */\\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\\n        Exp memory product = mul_(a, scalar);\\n        return truncate(product);\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n     */\\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\\n        Exp memory product = mul_(a, scalar);\\n        return add_(truncate(product), addend);\\n    }\\n\\n    /**\\n     * @dev Checks if first Exp is less than second Exp.\\n     */\\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa < right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp <= right Exp.\\n     */\\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa <= right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp > right Exp.\\n     */\\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa > right.mantissa;\\n    }\\n\\n    /**\\n     * @dev returns true if Exp is exactly zero\\n     */\\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\\n        return value.mantissa == 0;\\n    }\\n\\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\\n        require(n < 2**224, errorMessage);\\n        return uint224(n);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(uint a, uint b) pure internal returns (uint) {\\n        return add_(a, b, \\\"addition overflow\\\");\\n    }\\n\\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, errorMessage);\\n        return c;\\n    }\\n\\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(uint a, uint b) pure internal returns (uint) {\\n        return sub_(a, b, \\\"subtraction underflow\\\");\\n    }\\n\\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\\n    }\\n\\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / expScale;\\n    }\\n\\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\\n    }\\n\\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / doubleScale;\\n    }\\n\\n    function mul_(uint a, uint b) pure internal returns (uint) {\\n        return mul_(a, b, \\\"multiplication overflow\\\");\\n    }\\n\\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n        uint c = a * b;\\n        require(c / a == b, errorMessage);\\n        return c;\\n    }\\n\\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\\n    }\\n\\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\\n        return div_(mul_(a, expScale), b.mantissa);\\n    }\\n\\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\\n    }\\n\\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Double memory b) pure internal returns (uint) {\\n        return div_(mul_(a, doubleScale), b.mantissa);\\n    }\\n\\n    function div_(uint a, uint b) pure internal returns (uint) {\\n        return div_(a, b, \\\"divide by zero\\\");\\n    }\\n\\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/PriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.6.12;\\n\\nimport \\\"../MToken.sol\\\";\\n\\ninterface PriceOracle {\\n    /**\\n      * @notice Get the underlying price of a mToken asset\\n      * @param mToken The mToken to get the underlying price of\\n      * @return The underlying asset price mantissa (scaled by 1e18).\\n      *  Zero means the price is unavailable.\\n      */\\n    function getUnderlyingPrice(MToken mToken) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/MoartrollerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.6.12;\\n\\nimport \\\"../MToken.sol\\\";\\nimport \\\"../Utils/ExponentialNoError.sol\\\";\\n\\ninterface MoartrollerInterface {\\n\\n    /**\\n * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\\n *  Note that `mTokenBalance` is the number of mTokens the account owns in the market,\\n *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\\n */\\n    struct AccountLiquidityLocalVars {\\n        uint sumCollateral;\\n        uint sumBorrowPlusEffects;\\n        uint mTokenBalance;\\n        uint borrowBalance;\\n        uint exchangeRateMantissa;\\n        uint oraclePriceMantissa;\\n        ExponentialNoError.Exp collateralFactor;\\n        ExponentialNoError.Exp exchangeRate;\\n        ExponentialNoError.Exp oraclePrice;\\n        ExponentialNoError.Exp tokensToDenom;\\n    }\\n\\n    /*** Assets You Are In ***/\\n\\n    function enterMarkets(address[] calldata mTokens) external returns (uint[] memory);\\n    function exitMarket(address mToken) external returns (uint);\\n\\n    /*** Policy Hooks ***/\\n\\n    function mintAllowed(address mToken, address minter, uint mintAmount) external returns (uint);\\n\\n    function redeemAllowed(address mToken, address redeemer, uint redeemTokens) external returns (uint);\\n    function redeemVerify(address mToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\\n\\n    function borrowAllowed(address mToken, address borrower, uint borrowAmount) external returns (uint);\\n\\n    function repayBorrowAllowed(\\n        address mToken,\\n        address payer,\\n        address borrower,\\n        uint repayAmount) external returns (uint);\\n\\n    function liquidateBorrowAllowed(\\n        address mTokenBorrowed,\\n        address mTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint repayAmount) external returns (uint);\\n\\n    function seizeAllowed(\\n        address mTokenCollateral,\\n        address mTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint seizeTokens) external returns (uint);\\n\\n    function transferAllowed(address mToken, address src, address dst, uint transferTokens) external returns (uint);\\n\\n    /*** Liquidity/Liquidation Calculations ***/\\n\\n    function liquidateCalculateSeizeUserTokens(\\n        address mTokenBorrowed,\\n        address mTokenCollateral,\\n        uint repayAmount,\\n        address account) external view returns (uint, uint);\\n\\n    function getUserLockedAmount(MToken asset, address account) external view returns(uint);\\n}\\n\"\r\n    },\r\n    \"contracts/MoartrollerStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.6.12;\\n\\nimport \\\"./MToken.sol\\\";\\nimport \\\"./Interfaces/PriceOracle.sol\\\";\\nimport \\\"./Interfaces/LiquidityMathModelInterface.sol\\\";\\nimport \\\"./Interfaces/LiquidationModelInterface.sol\\\";\\nimport \\\"./MProtection.sol\\\";\\n\\nabstract contract UnitrollerAdminStorage {\\n    /**\\n    * @dev Administrator for this contract\\n    */\\n    address public admin;\\n\\n    /**\\n    * @dev Pending administrator for this contract\\n    */\\n    address public pendingAdmin;\\n\\n    /**\\n    * @dev Active brains of Unitroller\\n    */\\n    address public moartrollerImplementation;\\n\\n    /**\\n    * @dev Pending brains of Unitroller\\n    */\\n    address public pendingMoartrollerImplementation;\\n}\\n\\ncontract MoartrollerV1Storage is UnitrollerAdminStorage {\\n\\n    /**\\n     * @dev Oracle which gives the price of any given asset\\n     */\\n    PriceOracle public oracle;\\n\\n    /**\\n     * @dev Multiplier used to calculate the maximum repayAmount when liquidating a borrow\\n     */\\n    uint public closeFactorMantissa;\\n\\n    /**\\n     * @dev Multiplier representing the discount on collateral that a liquidator receives\\n     */\\n    uint public liquidationIncentiveMantissa;\\n\\n    /**\\n     * @dev Max number of assets a single account can participate in (borrow or use as collateral)\\n     */\\n    uint public maxAssets;\\n\\n    /**\\n     * @dev Per-account mapping of \\\"assets you are in\\\", capped by maxAssets\\n     */\\n    mapping(address => MToken[]) public accountAssets;\\n\\n}\\n\\ncontract MoartrollerV2Storage is MoartrollerV1Storage {\\n    struct Market {\\n        // Whether or not this market is listed\\n        bool isListed;\\n\\n        // Multiplier representing the most one can borrow against their collateral in this market.\\n        // For instance, 0.9 to allow borrowing 90% of collateral value.\\n        // Must be between 0 and 1, and stored as a mantissa.\\n        uint collateralFactorMantissa;\\n\\n        // Per-market mapping of \\\"accounts in this asset\\\"\\n        mapping(address => bool) accountMembership;\\n\\n        // Whether or not this market receives MOAR\\n        bool isMoared;\\n    }\\n\\n    /**\\n     * @dev Official mapping of mTokens -> Market metadata\\n     * @dev Used e.g. to determine if a market is supported\\n     */\\n    mapping(address => Market) public markets;\\n\\n\\n    /**\\n     * @dev The Pause Guardian can pause certain actions as a safety mechanism.\\n     *  Actions which allow users to remove their own assets cannot be paused.\\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\\n     */\\n    address public pauseGuardian;\\n    bool public _mintGuardianPaused;\\n    bool public _borrowGuardianPaused;\\n    bool public transferGuardianPaused;\\n    bool public seizeGuardianPaused;\\n    mapping(address => bool) public mintGuardianPaused;\\n    mapping(address => bool) public borrowGuardianPaused;\\n}\\n\\ncontract MoartrollerV3Storage is MoartrollerV2Storage {\\n    struct MoarMarketState {\\n        // The market's last updated moarBorrowIndex or moarSupplyIndex\\n        uint224 index;\\n\\n        // The block number the index was last updated at\\n        uint32 block;\\n    }\\n\\n    /// @dev A list of all markets\\n    MToken[] public allMarkets;\\n\\n    /// @dev The rate at which the flywheel distributes MOAR, per block\\n    uint public moarRate;\\n\\n    /// @dev The portion of moarRate that each market currently receives\\n    mapping(address => uint) public moarSpeeds;\\n\\n    /// @dev The MOAR market supply state for each market\\n    mapping(address => MoarMarketState) public moarSupplyState;\\n\\n    /// @dev The MOAR market borrow state for each market\\n    mapping(address => MoarMarketState) public moarBorrowState;\\n\\n    /// @dev The MOAR borrow index for each market for each supplier as of the last time they accrued MOAR\\n    mapping(address => mapping(address => uint)) public moarSupplierIndex;\\n\\n    /// @dev The MOAR borrow index for each market for each borrower as of the last time they accrued MOAR\\n    mapping(address => mapping(address => uint)) public moarBorrowerIndex;\\n\\n    /// @dev The MOAR accrued but not yet transferred to each user\\n    mapping(address => uint) public moarAccrued;\\n}\\n\\ncontract MoartrollerV4Storage is MoartrollerV3Storage {\\n    // @dev The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\\n    address public borrowCapGuardian;\\n\\n    // @dev Borrow caps enforced by borrowAllowed for each mToken address. Defaults to zero which corresponds to unlimited borrowing.\\n    mapping(address => uint) public borrowCaps;\\n}\\n\\ncontract MoartrollerV5Storage is MoartrollerV4Storage {\\n    /// @dev The portion of MOAR that each contributor receives per block\\n    mapping(address => uint) public moarContributorSpeeds;\\n\\n    /// @dev Last block at which a contributor's MOAR rewards have been allocated\\n    mapping(address => uint) public lastContributorBlock;\\n}\\n\\ncontract MoartrollerV6Storage is MoartrollerV5Storage {\\n    /**\\n     * @dev Moar token address\\n     */\\n    address public moarToken;\\n\\n    /**\\n     * @dev MProxy address\\n     */\\n    address public mProxy;\\n    \\n    /**\\n     * @dev CProtection contract which can be used for collateral optimisation\\n     */\\n    MProtection public cprotection;\\n\\n    /**\\n     * @dev Mapping for basic token address to mToken\\n     */\\n    mapping(address => MToken) public tokenAddressToMToken;\\n\\n    /**\\n     * @dev Math model for liquidity calculation\\n     */\\n    LiquidityMathModelInterface public liquidityMathModel;\\n\\n\\n    /**\\n     * @dev Liquidation model for liquidation related functions\\n     */\\n    LiquidationModelInterface public liquidationModel;\\n\\n\\n\\n    /**\\n     * @dev List of addresses with privileged access\\n     */\\n    mapping(address => uint) public privilegedAddresses;\\n\\n    /**\\n     * @dev Determines if reward claim feature is enabled\\n     */\\n    bool public rewardClaimEnabled;\\n}\\n\"\r\n    },\r\n    \"contracts/Governance/UnionGovernanceToken.sol\": {\r\n      \"content\": \"// Copyright (c) 2020 The UNION Protocol Foundation\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\n\\n/**\\n * @title UNION Protocol Governance Token\\n * @dev Implementation of the basic standard token.\\n */\\ncontract UnionGovernanceToken is AccessControl, IERC20 {\\n\\n  using Address for address;\\n  using SafeMath for uint256;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  /**\\n   * @notice Struct for marking number of votes from a given block\\n   * @member from\\n   * @member votes\\n   */\\n  struct VotingCheckpoint {\\n    uint256 from;\\n    uint256 votes;\\n  }\\n \\n  /**\\n   * @notice Struct for locked tokens\\n   * @member amount\\n   * @member releaseTime\\n   * @member votable\\n   */\\n  struct LockedTokens{\\n    uint amount;\\n    uint releaseTime;\\n    bool votable;\\n  }\\n\\n  /**\\n  * @notice Struct for EIP712 Domain\\n  * @member name\\n  * @member version\\n  * @member chainId\\n  * @member verifyingContract\\n  * @member salt\\n  */\\n  struct EIP712Domain {\\n    string name;\\n    string version;\\n    uint256 chainId;\\n    address verifyingContract;\\n    bytes32 salt;\\n  }\\n\\n  /**\\n  * @notice Struct for EIP712 VotingDelegate call\\n  * @member owner\\n  * @member delegate\\n  * @member nonce\\n  * @member expirationTime\\n  */\\n  struct VotingDelegate {\\n    address owner;\\n    address delegate;\\n    uint256 nonce;\\n    uint256 expirationTime;\\n  }\\n\\n  /**\\n  * @notice Struct for EIP712 Permit call\\n  * @member owner\\n  * @member spender\\n  * @member value\\n  * @member nonce\\n  * @member deadline\\n  */\\n  struct Permit {\\n    address owner;\\n    address spender;\\n    uint256 value;\\n    uint256 nonce;\\n    uint256 deadline;\\n  }\\n\\n  /**\\n   * @notice Vote Delegation Events\\n   */\\n  event VotingDelegateChanged(address indexed _owner, address indexed _fromDelegate, address indexed _toDelegate);\\n  event VotingDelegateRemoved(address indexed _owner);\\n  \\n  /**\\n   * @notice Vote Balance Events\\n   * Emmitted when a delegate account's vote balance changes at the time of a written checkpoint\\n   */\\n  event VoteBalanceChanged(address indexed _account, uint256 _oldBalance, uint256 _newBalance);\\n\\n  /**\\n   * @notice Transfer/Allocator Events\\n   */\\n  event TransferStatusChanged(bool _newTransferStatus);\\n\\n  /**\\n   * @notice Reversion Events\\n   */\\n  event ReversionStatusChanged(bool _newReversionSetting);\\n\\n  /**\\n   * @notice EIP-20 Approval event\\n   */\\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n  \\n  /**\\n   * @notice EIP-20 Transfer event\\n   */\\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n\\n  event Burn(address indexed _from, uint256 _value);\\n  event AddressPermitted(address indexed _account);\\n  event AddressRestricted(address indexed _account);\\n\\n  /**\\n   * @dev AccessControl recognized roles\\n   */\\n  bytes32 public constant ROLE_ADMIN = keccak256(\\\"ROLE_ADMIN\\\");\\n  bytes32 public constant ROLE_ALLOCATE = keccak256(\\\"ROLE_ALLOCATE\\\");\\n  bytes32 public constant ROLE_GOVERN = keccak256(\\\"ROLE_GOVERN\\\");\\n  bytes32 public constant ROLE_MINT = keccak256(\\\"ROLE_MINT\\\");\\n  bytes32 public constant ROLE_LOCK = keccak256(\\\"ROLE_LOCK\\\");\\n  bytes32 public constant ROLE_TRUSTED = keccak256(\\\"ROLE_TRUSTED\\\");\\n  bytes32 public constant ROLE_TEST = keccak256(\\\"ROLE_TEST\\\");\\n   \\n  bytes32 public constant EIP712DOMAIN_TYPEHASH = keccak256(\\n    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\\\"\\n  );\\n  bytes32 public constant DELEGATE_TYPEHASH = keccak256(\\n    \\\"DelegateVote(address owner,address delegate,uint256 nonce,uint256 expirationTime)\\\"\\n  );\\n\\n  //keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n  bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n  address private constant BURN_ADDRESS = address(0);\\n  address public UPGT_CONTRACT_ADDRESS;\\n\\n  /**\\n   * @dev hashes to support EIP-712 signing and validating, EIP712DOMAIN_SEPARATOR is set at time of contract instantiation and token minting.\\n   */\\n  bytes32 public immutable EIP712DOMAIN_SEPARATOR;\\n\\n  /**\\n   * @dev EIP-20 token name\\n   */\\n  string public name = \\\"UNION Protocol Governance Token\\\";\\n\\n  /**\\n   * @dev EIP-20 token symbol\\n   */\\n  string public symbol = \\\"UNN\\\";\\n\\n  /**\\n   * @dev EIP-20 token decimals\\n   */\\n  uint8 public decimals = 18;\\n\\n  /**\\n   * @dev Contract version\\n   */\\n  string public constant version = '0.0.1';\\n\\n  /**\\n   * @dev Initial amount of tokens\\n   */\\n  uint256 private uint256_initialSupply = 100000000000 * 10**18;\\n\\n  /**\\n   * @dev Total amount of tokens\\n   */\\n  uint256 private uint256_totalSupply;\\n\\n  /**\\n   * @dev Chain id\\n   */\\n  uint256 private uint256_chain_id;\\n\\n  /**\\n   * @dev general transfer restricted as function of public sale not complete\\n   */\\n  bool private b_canTransfer = false;\\n\\n  /**\\n   * @dev private variable that determines if failed EIP-20 functions revert() or return false.  Reversion short-circuits the return from these functions.\\n   */\\n  bool private b_revert = false; //false allows false return values\\n\\n  /**\\n   * @dev Locked destinations list\\n   */\\n  mapping(address => bool) private m_lockedDestinations;\\n\\n  /**\\n   * @dev EIP-20 allowance and balance maps\\n   */\\n  mapping(address => mapping(address => uint256)) private m_allowances;\\n  mapping(address => uint256) private m_balances;\\n  mapping(address => LockedTokens[]) private m_lockedBalances;\\n\\n  /**\\n   * @dev nonces used by accounts to this contract for signing and validating signatures under EIP-712\\n   */\\n  mapping(address => uint256) private m_nonces;\\n\\n  /**\\n   * @dev delegated account may for off-line vote delegation\\n   */\\n  mapping(address => address) private m_delegatedAccounts;\\n\\n  /**\\n   * @dev delegated account inverse map is needed to live calculate voting power\\n   */\\n  mapping(address => EnumerableSet.AddressSet) private m_delegatedAccountsInverseMap;\\n\\n\\n  /**\\n   * @dev indexed mapping of vote checkpoints for each account\\n   */\\n  mapping(address => mapping(uint256 => VotingCheckpoint)) private m_votingCheckpoints;\\n\\n  /**\\n   * @dev mapping of account addrresses to voting checkpoints\\n   */\\n  mapping(address => uint256) private m_accountVotingCheckpoints;\\n\\n  /**\\n   * @dev Contructor for the token\\n   * @param _owner address of token contract owner\\n   * @param _initialSupply of tokens generated by this contract\\n   * Sets Transfer the total suppply to the owner.\\n   * Sets default admin role to the owner.\\n   * Sets ROLE_ALLOCATE to the owner.\\n   * Sets ROLE_GOVERN to the owner.\\n   * Sets ROLE_MINT to the owner.\\n   * Sets EIP 712 Domain Separator.\\n   */\\n  constructor(address _owner, uint256 _initialSupply) public {\\n    \\n    //set internal contract references\\n    UPGT_CONTRACT_ADDRESS = address(this);\\n\\n    //setup roles using AccessControl\\n    _setupRole(DEFAULT_ADMIN_ROLE, _owner);\\n    _setupRole(ROLE_ADMIN, _owner);\\n    _setupRole(ROLE_ADMIN, _msgSender());\\n    _setupRole(ROLE_ALLOCATE, _owner);\\n    _setupRole(ROLE_ALLOCATE, _msgSender());\\n    _setupRole(ROLE_TRUSTED, _owner);\\n    _setupRole(ROLE_TRUSTED, _msgSender());\\n    _setupRole(ROLE_GOVERN, _owner);\\n    _setupRole(ROLE_MINT, _owner);\\n    _setupRole(ROLE_LOCK, _owner);\\n    _setupRole(ROLE_TEST, _owner);\\n\\n    m_balances[_owner] = _initialSupply;\\n    uint256_totalSupply = _initialSupply;\\n    b_canTransfer = false;\\n    uint256_chain_id = _getChainId();\\n\\n    EIP712DOMAIN_SEPARATOR = _hash(EIP712Domain({\\n        name : name,\\n        version : version,\\n        chainId : uint256_chain_id,\\n        verifyingContract : address(this),\\n        salt : keccak256(abi.encodePacked(name))\\n      }\\n    ));\\n   \\n    emit Transfer(BURN_ADDRESS, _owner, uint256_totalSupply);\\n  }\\n\\n    /**\\n   * @dev Sets transfer status to lock token transfer\\n   * @param _canTransfer value can be true or false.\\n   * disables transfer when set to false and enables transfer when true\\n   * Only a member of ADMIN role can call to change transfer status\\n   */\\n  function setCanTransfer(bool _canTransfer) public {\\n    if(hasRole(ROLE_ADMIN, _msgSender())){\\n      b_canTransfer = _canTransfer;\\n      emit TransferStatusChanged(_canTransfer);\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets status of token transfer lock\\n   * @return true or false status of whether the token can be transfered\\n   */\\n  function getCanTransfer() public view returns (bool) {\\n    return b_canTransfer;\\n  }\\n\\n  /**\\n   * @dev Sets transfer reversion status to either return false or throw on error\\n   * @param _reversion value can be true or false.\\n   * disables return of false values for transfer failures when set to false and enables transfer-related exceptions when true\\n   * Only a member of ADMIN role can call to change transfer reversion status\\n   */\\n  function setReversion(bool _reversion) public {\\n    if(hasRole(ROLE_ADMIN, _msgSender()) || \\n       hasRole(ROLE_TEST, _msgSender())\\n    ) {\\n      b_revert = _reversion;\\n      emit ReversionStatusChanged(_reversion);\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets status of token transfer reversion\\n   * @return true or false status of whether the token transfer failures return false or are reverted\\n   */\\n  function getReversion() public view returns (bool) {\\n    return b_revert;\\n  }\\n\\n  /**\\n   * @dev retrieve current chain id\\n   * @return chain id\\n   */\\n  function getChainId() public pure returns (uint256) {\\n    return _getChainId();\\n  }\\n\\n  /**\\n   * @dev Retrieve current chain id\\n   * @return chain id\\n   */\\n  function _getChainId() internal pure returns (uint256) {\\n    uint256 id;\\n    assembly {\\n      id := chainid()\\n    }\\n    return id;\\n  }\\n\\n  /**\\n   * @dev Retrieve total supply of tokens\\n   * @return uint256 total supply of tokens\\n   */\\n  function totalSupply() public view override returns (uint256) {\\n    return uint256_totalSupply;\\n  }\\n\\n  /**\\n   * Balance related functions\\n   */\\n\\n  /**\\n   * @dev Retrieve balance of a specified account\\n   * @param _account address of account holding balance\\n   * @return uint256 balance of the specified account address\\n   */\\n  function balanceOf(address _account) public view override returns (uint256) {\\n    return m_balances[_account].add(_calculateReleasedBalance(_account));\\n  }\\n\\n  /**\\n   * @dev Retrieve locked balance of a specified account\\n   * @param _account address of account holding locked balance\\n   * @return uint256 locked balance of the specified account address\\n   */\\n  function lockedBalanceOf(address _account) public view returns (uint256) {\\n    return _calculateLockedBalance(_account);\\n  }\\n\\n  /**\\n   * @dev Retrieve lenght of locked balance array for specific address\\n   * @param _account address of account holding locked balance\\n   * @return uint256 locked balance array lenght\\n   */\\n  function getLockedTokensListSize(address _account) public view returns (uint256){\\n    require(_msgSender() == _account || hasRole(ROLE_ADMIN, _msgSender()) || hasRole(ROLE_TRUSTED, _msgSender()), \\\"UPGT_ERROR: insufficient permissions\\\");\\n    return m_lockedBalances[_account].length;\\n  }\\n\\n  /**\\n   * @dev Retrieve locked tokens struct from locked balance array for specific address\\n   * @param _account address of account holding locked tokens\\n   * @param _index index in array with locked tokens position\\n   * @return amount of locked tokens\\n   * @return releaseTime descibes time when tokens will be unlocked\\n   * @return votable flag is describing votability of tokens\\n   */\\n  function getLockedTokens(address _account, uint256 _index) public view returns (uint256 amount, uint256 releaseTime, bool votable){\\n    require(_msgSender() == _account || hasRole(ROLE_ADMIN, _msgSender()) || hasRole(ROLE_TRUSTED, _msgSender()), \\\"UPGT_ERROR: insufficient permissions\\\");\\n    require(_index < m_lockedBalances[_account].length, \\\"UPGT_ERROR: LockedTokens position doesn't exist on given index\\\");\\n    LockedTokens storage lockedTokens = m_lockedBalances[_account][_index];\\n    return (lockedTokens.amount, lockedTokens.releaseTime, lockedTokens.votable);\\n  }\\n\\n  /**\\n   * @dev Calculates locked balance of a specified account\\n   * @param _account address of account holding locked balance\\n   * @return uint256 locked balance of the specified account address\\n   */\\n  function _calculateLockedBalance(address _account) private view returns (uint256) {\\n    uint256 lockedBalance = 0;\\n    for (uint i=0; i<m_lockedBalances[_account].length; i++) {\\n      if(m_lockedBalances[_account][i].releaseTime > block.timestamp){\\n        lockedBalance = lockedBalance.add(m_lockedBalances[_account][i].amount);\\n      }\\n    }\\n    return lockedBalance;\\n  }\\n\\n  /**\\n   * @dev Calculates released balance of a specified account\\n   * @param _account address of account holding released balance\\n   * @return uint256 released balance of the specified account address\\n   */\\n  function _calculateReleasedBalance(address _account) private view returns (uint256) {\\n    uint256 releasedBalance = 0;\\n    for (uint i=0; i<m_lockedBalances[_account].length; i++) {\\n      if(m_lockedBalances[_account][i].releaseTime <= block.timestamp){\\n          releasedBalance = releasedBalance.add(m_lockedBalances[_account][i].amount);\\n      }\\n    }\\n    return releasedBalance;\\n  }\\n\\n  /**\\n   * @dev Calculates locked votable balance of a specified account\\n   * @param _account address of account holding locked votable balance\\n   * @return uint256 locked votable balance of the specified account address\\n   */\\n  function _calculateLockedVotableBalance(address _account) private view returns (uint256) {\\n    uint256 lockedVotableBalance = 0;\\n    for (uint i=0; i<m_lockedBalances[_account].length; i++) {\\n      if(m_lockedBalances[_account][i].votable == true){\\n        lockedVotableBalance = lockedVotableBalance.add(m_lockedBalances[_account][i].amount);\\n      }\\n    }\\n    return lockedVotableBalance;\\n  }\\n\\n  /**\\n   * @dev Moves released balance to normal balance for a specified account\\n   * @param _account address of account holding released balance\\n   */\\n  function _moveReleasedBalance(address _account) internal virtual{\\n    uint256 releasedToMove = 0;\\n    for (uint i=0; i<m_lockedBalances[_account].length; i++) {\\n      if(m_lockedBalances[_account][i].releaseTime <= block.timestamp){\\n        releasedToMove = releasedToMove.add(m_lockedBalances[_account][i].amount);\\n        m_lockedBalances[_account][i] = m_lockedBalances[_account][m_lockedBalances[_account].length - 1];\\n        m_lockedBalances[_account].pop();\\n      }\\n    }\\n    m_balances[_account] = m_balances[_account].add(releasedToMove);\\n  }\\n\\n  /**\\n   * Allowance related functinons\\n   */\\n\\n  /**\\n   * @dev Retrieve the spending allowance for a token holder by a specified account\\n   * @param _owner Token account holder\\n   * @param _spender Account given allowance\\n   * @return uint256 allowance value\\n   */\\n  function allowance(address _owner, address _spender) public override virtual view returns (uint256) {\\n    return m_allowances[_owner][_spender];\\n  }\\n\\n  /**\\n   * @dev Message sender approval to spend for a specified amount\\n   * @param _spender address of party approved to spend\\n   * @param _value amount of the approval \\n   * @return boolean success status \\n   * public wrapper for _approve, _owner is msg.sender\\n   */\\n  function approve(address _spender, uint256 _value) public override returns (bool) {\\n    bool success = _approveUNN(_msgSender(), _spender, _value);\\n    if(!success && b_revert){\\n      revert(\\\"UPGT_ERROR: APPROVE ERROR\\\");\\n    }\\n    return success;\\n  }\\n  \\n  /**\\n   * @dev Token owner approval of amount for specified spender\\n   * @param _owner address of party that owns the tokens being granted approval for spending\\n   * @param _spender address of party that is granted approval for spending\\n   * @param _value amount approved for spending\\n   * @return boolean approval status\\n   * if _spender allownace for a given _owner is greater than 0, \\n   * increaseAllowance/decreaseAllowance should be used to prevent a race condition whereby the spender is able to spend the total value of both the old and new allowance.  _spender cannot be burn or this governance token contract address.  Addresses github.com/ethereum/EIPs/issues738\\n   */\\n  function _approveUNN(address _owner, address _spender, uint256 _value) internal returns (bool) {\\n    bool retval = false;\\n    if(_spender != BURN_ADDRESS &&\\n      _spender != UPGT_CONTRACT_ADDRESS &&\\n      (m_allowances[_owner][_spender] == 0 || _value == 0)\\n    ){\\n      m_allowances[_owner][_spender] = _value;\\n      emit Approval(_owner, _spender, _value);\\n      retval = true;\\n    }\\n    return retval;\\n  }\\n\\n  /**\\n   * @dev Increase spender allowance by specified incremental value\\n   * @param _spender address of party that is granted approval for spending\\n   * @param _addedValue specified incremental increase\\n   * @return boolean increaseAllowance status\\n   * public wrapper for _increaseAllowance, _owner restricted to msg.sender\\n   */\\n  function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\\n    bool success = _increaseAllowanceUNN(_msgSender(), _spender, _addedValue);\\n    if(!success && b_revert){\\n      revert(\\\"UPGT_ERROR: INCREASE ALLOWANCE ERROR\\\");\\n    }\\n    return success;\\n  }\\n\\n  /**\\n   * @dev Allow owner to increase spender allowance by specified incremental value\\n   * @param _owner address of the token owner\\n   * @param _spender address of the token spender\\n   * @param _addedValue specified incremental increase\\n   * @return boolean return value status\\n   * increase the number of tokens that an _owner provides as allowance to a _spender-- does not requrire the number of tokens allowed to be set first to 0.  _spender cannot be either burn or this goverance token contract address.\\n   */\\n  function _increaseAllowanceUNN(address _owner, address _spender, uint256 _addedValue) internal returns (bool) {\\n    bool retval = false;\\n    if(_spender != BURN_ADDRESS &&\\n      _spender != UPGT_CONTRACT_ADDRESS &&\\n      _addedValue > 0\\n    ){\\n      m_allowances[_owner][_spender] = m_allowances[_owner][_spender].add(_addedValue);\\n      retval = true;\\n      emit Approval(_owner, _spender, m_allowances[_owner][_spender]);\\n    }\\n    return retval;\\n  }\\n\\n  /**\\n   * @dev Decrease spender allowance by specified incremental value\\n   * @param _spender address of party that is granted approval for spending\\n   * @param _subtractedValue specified incremental decrease\\n   * @return boolean success status\\n   * public wrapper for _decreaseAllowance, _owner restricted to msg.sender\\n   */\\n  //public wrapper for _decreaseAllowance, _owner restricted to msg.sender\\n  function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\\n    bool success = _decreaseAllowanceUNN(_msgSender(), _spender, _subtractedValue);\\n    if(!success && b_revert){\\n      revert(\\\"UPGT_ERROR: DECREASE ALLOWANCE ERROR\\\");\\n    }\\n    return success;\\n  } \\n\\n  /**\\n   * @dev Allow owner to decrease spender allowance by specified incremental value\\n   * @param _owner address of the token owner\\n   * @param _spender address of the token spender\\n   * @param _subtractedValue specified incremental decrease\\n   * @return boolean return value status\\n   * decrease the number of tokens than an _owner provdes as allowance to a _spender.  A _spender cannot have a negative allowance.  Does not require existing allowance to be set first to 0.  _spender cannot be burn or this governance token contract address.\\n   */\\n  function _decreaseAllowanceUNN(address _owner, address _spender, uint256 _subtractedValue) internal returns (bool) {\\n    bool retval = false;\\n    if(_spender != BURN_ADDRESS &&\\n       _spender != UPGT_CONTRACT_ADDRESS &&\\n      _subtractedValue > 0 &&\\n      m_allowances[_owner][_spender] >= _subtractedValue\\n    ){\\n      m_allowances[_owner][_spender] = m_allowances[_owner][_spender].sub(_subtractedValue);\\n      retval = true;\\n      emit Approval(_owner, _spender, m_allowances[_owner][_spender]);\\n    }\\n    return retval;\\n  }\\n\\n  /**\\n   * LockedDestination related functions\\n   */\\n\\n  /**\\n   * @dev Adds address as a designated destination for tokens when locked for allocation only\\n   * @param _address Address of approved desitnation for movement during lock\\n   * @return success in setting address as eligible for transfer independent of token lock status\\n   */\\n  function setAsEligibleLockedDestination(address _address) public returns (bool) {\\n    bool retVal = false;\\n    if(hasRole(ROLE_ADMIN, _msgSender())){\\n      m_lockedDestinations[_address] = true;\\n      retVal = true;\\n    }\\n    return retVal;\\n  }\\n\\n  /**\\n   * @dev removes desitnation as eligible for transfer\\n   * @param _address address being removed\\n   */\\n  function removeEligibleLockedDestination(address _address) public {\\n    if(hasRole(ROLE_ADMIN, _msgSender())){\\n      require(_address != BURN_ADDRESS, \\\"UPGT_ERROR: address cannot be burn address\\\");\\n      delete(m_lockedDestinations[_address]);\\n    }\\n  }\\n\\n  /**\\n   * @dev checks whether a destination is eligible as recipient of transfer independent of token lock status\\n   * @param _address address being checked\\n   * @return whether desitnation is locked\\n   */\\n  function checkEligibleLockedDesination(address _address) public view returns (bool) {\\n    return m_lockedDestinations[_address];\\n  }\\n\\n  /**\\n   * @dev Adds address as a designated allocator that can move tokens when they are locked\\n   * @param _address Address receiving the role of ROLE_ALLOCATE\\n   * @return success as true or false\\n   */\\n  function setAsAllocator(address _address) public returns (bool) {\\n    bool retVal = false;\\n    if(hasRole(ROLE_ADMIN, _msgSender())){\\n      grantRole(ROLE_ALLOCATE, _address);\\n      retVal = true;\\n    }\\n    return retVal;\\n  }\\n  \\n  /**\\n   * @dev Removes address as a designated allocator that can move tokens when they are locked\\n   * @param _address Address being removed from the ROLE_ALLOCATE\\n   * @return success as true or false\\n   */\\n  function removeAsAllocator(address _address) public returns (bool) {\\n    bool retVal = false;\\n    if(hasRole(ROLE_ADMIN, _msgSender())){\\n      if(hasRole(ROLE_ALLOCATE, _address)){\\n        revokeRole(ROLE_ALLOCATE, _address);\\n        retVal = true;\\n      }\\n    }\\n    return retVal;\\n  }\\n\\n  /**\\n   * @dev Checks to see if an address has the role of being an allocator\\n   * @param _address Address being checked for ROLE_ALLOCATE\\n   * @return true or false whether the address has ROLE_ALLOCATE assigned\\n   */\\n  function checkAsAllocator(address _address) public view returns (bool) {\\n    return hasRole(ROLE_ALLOCATE, _address);\\n  }\\n\\n  /**\\n   * Transfer related functions\\n   */\\n\\n  /**\\n   * @dev Public wrapper for transfer function to move tokens of specified value to a given address\\n   * @param _to specified recipient\\n   * @param _value amount being transfered to recipient\\n   * @return status of transfer success\\n   */\\n  function transfer(address _to, uint256 _value) external override returns (bool) {\\n    bool success = _transferUNN(_msgSender(), _to, _value);\\n    if(!success && b_revert){\\n      revert(\\\"UPGT_ERROR: ERROR ON TRANSFER\\\");\\n    }\\n    return success;\\n  }\\n\\n  /**\\n   * @dev Transfer token for a specified address, but cannot transfer tokens to either the burn or this governance contract address.  Also moves voting delegates as required.\\n   * @param _owner The address owner where transfer originates\\n   * @param _to The address to transfer to\\n   * @param _value The amount to be transferred\\n   * @return status of transfer success\\n   */\\n  function _transferUNN(address _owner, address _to, uint256 _value) internal returns (bool) {\\n    bool retval = false;\\n    if(b_canTransfer || hasRole(ROLE_ALLOCATE, _msgSender()) || checkEligibleLockedDesination(_to)) {\\n      if(\\n         _to != BURN_ADDRESS &&\\n         _to != UPGT_CONTRACT_ADDRESS &&\\n         (balanceOf(_owner) >= _value) &&\\n         (_value >= 0)\\n      ){\\n        _moveReleasedBalance(_owner);\\n        m_balances[_owner] = m_balances[_owner].sub(_value);\\n        m_balances[_to] = m_balances[_to].add(_value);\\n        retval = true;\\n        //need to move voting delegates with transfer of tokens\\n        retval = retval && _moveVotingDelegates(m_delegatedAccounts[_owner], m_delegatedAccounts[_to], _value);\\n        emit Transfer(_owner, _to, _value);\\n      }\\n    }\\n    return retval;\\n  }\\n\\n  /**\\n   * @dev Public wrapper for transferAndLock function to move tokens of specified value to a given address and lock them for a period of time\\n   * @param _to specified recipient\\n   * @param _value amount being transfered to recipient\\n   * @param _releaseTime time in seconds after amount will be released\\n   * @param _votable flag which describes if locked tokens are votable or not\\n   * @return status of transfer success\\n   * Requires ROLE_LOCK\\n   */\\n  function transferAndLock(address _to, uint256 _value, uint256 _releaseTime, bool _votable) public virtual returns (bool) {\\n    bool retval = false;\\n    if(hasRole(ROLE_LOCK, _msgSender())){\\n      retval = _transferAndLock(msg.sender, _to, _value, _releaseTime, _votable);\\n    }\\n   \\n    if(!retval && b_revert){\\n      revert(\\\"UPGT_ERROR: ERROR ON TRANSFER AND LOCK\\\");\\n    }\\n    return retval;\\n  }\\n\\n  /**\\n   * @dev Transfers tokens of specified value to a given address and lock them for a period of time\\n   * @param _owner The address owner where transfer originates\\n   * @param _to specified recipient\\n   * @param _value amount being transfered to recipient\\n   * @param _releaseTime time in seconds after amount will be released\\n   * @param _votable flag which describes if locked tokens are votable or not\\n   * @return status of transfer success\\n   */\\n  function _transferAndLock(address _owner, address _to, uint256 _value, uint256 _releaseTime, bool _votable) internal virtual returns (bool){\\n    bool retval = false;\\n    if(b_canTransfer || hasRole(ROLE_ALLOCATE, _msgSender()) || checkEligibleLockedDesination(_to)) {\\n      if(\\n         _to != BURN_ADDRESS &&\\n         _to != UPGT_CONTRACT_ADDRESS &&\\n         (balanceOf(_owner) >= _value) &&\\n         (_value >= 0)\\n      ){\\n        _moveReleasedBalance(_owner);\\n        m_balances[_owner] = m_balances[_owner].sub(_value);\\n        m_lockedBalances[_to].push(LockedTokens(_value, _releaseTime, _votable));\\n        retval = true;\\n        //need to move voting delegates with transfer of tokens\\n        // retval = retval && _moveVotingDelegates(m_delegatedAccounts[_owner], m_delegatedAccounts[_to], _value);  \\n        emit Transfer(_owner, _to, _value);\\n      }\\n    }\\n    return retval;\\n  }\\n\\n  /**\\n   * @dev Public wrapper for transferFrom function\\n   * @param _owner The address to transfer from\\n   * @param _spender cannot be the burn address\\n   * @param _value The amount to be transferred\\n   * @return status of transferFrom success\\n   * _spender cannot be either this goverance token contract or burn\\n   */\\n  function transferFrom(address _owner, address _spender, uint256 _value) external override returns (bool) {\\n    bool success = _transferFromUNN(_owner, _spender, _value);\\n    if(!success && b_revert){\\n      revert(\\\"UPGT_ERROR: ERROR ON TRANSFER FROM\\\");\\n    }\\n    return success;\\n  }\\n\\n  /**\\n   * @dev Transfer token for a specified address.  _spender cannot be either this goverance token contract or burn\\n   * @param _owner The address to transfer from\\n   * @param _spender cannot be the burn address\\n   * @param _value The amount to be transferred\\n   * @return status of transferFrom success\\n   * _spender cannot be either this goverance token contract or burn\\n   */\\n  function _transferFromUNN(address _owner, address _spender, uint256 _value) internal returns (bool) {\\n    bool retval = false;\\n    if(b_canTransfer || hasRole(ROLE_ALLOCATE, _msgSender()) || checkEligibleLockedDesination(_spender)) {\\n      if(\\n        _spender != BURN_ADDRESS &&\\n        _spender != UPGT_CONTRACT_ADDRESS &&\\n        (balanceOf(_owner) >= _value) &&\\n        (_value > 0) &&\\n        (m_allowances[_owner][_msgSender()] >= _value)\\n      ){\\n        _moveReleasedBalance(_owner);\\n        m_balances[_owner] = m_balances[_owner].sub(_value);\\n        m_balances[_spender] = m_balances[_spender].add(_value);\\n        m_allowances[_owner][_msgSender()] = m_allowances[_owner][_msgSender()].sub(_value);\\n        retval = true;\\n        //need to move delegates that exist for this owner in line with transfer\\n        retval = retval && _moveVotingDelegates(_owner, _spender, _value); \\n        emit Transfer(_owner, _spender, _value);\\n      }\\n    }\\n    return retval;\\n  }\\n\\n  /**\\n   * @dev Public wrapper for transferFromAndLock function to move tokens of specified value from given address to another address and lock them for a period of time\\n   * @param _owner The address owner where transfer originates\\n   * @param _to specified recipient\\n   * @param _value amount being transfered to recipient\\n   * @param _releaseTime time in seconds after amount will be released\\n   * @param _votable flag which describes if locked tokens are votable or not\\n   * @return status of transfer success\\n   * Requires ROLE_LOCK\\n   */\\n  function transferFromAndLock(address _owner, address _to, uint256 _value, uint256 _releaseTime, bool _votable) public virtual returns (bool) {\\n     bool retval = false;\\n    if(hasRole(ROLE_LOCK, _msgSender())){\\n      retval = _transferFromAndLock(_owner, _to, _value, _releaseTime, _votable);\\n    }\\n   \\n    if(!retval && b_revert){\\n      revert(\\\"UPGT_ERROR: ERROR ON TRANSFER FROM AND LOCK\\\");\\n    }\\n    return retval;\\n  }\\n\\n  /**\\n   * @dev Transfers tokens of specified value from a given address to another address and lock them for a period of time\\n   * @param _owner The address owner where transfer originates\\n   * @param _to specified recipient\\n   * @param _value amount being transfered to recipient\\n   * @param _releaseTime time in seconds after amount will be released\\n   * @param _votable flag which describes if locked tokens are votable or not\\n   * @return status of transfer success\\n   */\\n  function _transferFromAndLock(address _owner, address _to, uint256 _value, uint256 _releaseTime, bool _votable) internal returns (bool) {\\n    bool retval = false;\\n    if(b_canTransfer || hasRole(ROLE_ALLOCATE, _msgSender()) || checkEligibleLockedDesination(_to)) {\\n      if(\\n        _to != BURN_ADDRESS &&\\n        _to != UPGT_CONTRACT_ADDRESS &&\\n        (balanceOf(_owner) >= _value) &&\\n        (_value > 0) &&\\n        (m_allowances[_owner][_msgSender()] >= _value)\\n      ){\\n        _moveReleasedBalance(_owner);\\n        m_balances[_owner] = m_balances[_owner].sub(_value);\\n        m_lockedBalances[_to].push(LockedTokens(_value, _releaseTime, _votable));\\n        m_allowances[_owner][_msgSender()] = m_allowances[_owner][_msgSender()].sub(_value);\\n        retval = true;\\n        //need to move delegates that exist for this owner in line with transfer\\n        // retval = retval && _moveVotingDelegates(_owner, _to, _value); \\n        emit Transfer(_owner, _to, _value);\\n      }\\n    }\\n    return retval;\\n  }\\n\\n  /**\\n   * @dev Public function to burn tokens\\n   * @param _value number of tokens to be burned\\n   * @return whether tokens were burned\\n   * Only ROLE_MINTER may burn tokens\\n   */\\n  function burn(uint256 _value) external returns (bool) {\\n    bool success = _burn(_value);\\n    if(!success && b_revert){\\n      revert(\\\"UPGT_ERROR: FAILED TO BURN\\\");\\n    }\\n    return success;\\n  } \\n\\n  /**\\n   * @dev Private function Burn tokens\\n   * @param _value number of tokens to be burned\\n   * @return bool whether the tokens were burned\\n   * only a minter may burn tokens, meaning that tokens being burned must be previously send to a ROLE_MINTER wallet.\\n   */\\n  function _burn(uint256 _value) internal returns (bool) {\\n    bool retval = false;\\n    if(hasRole(ROLE_MINT, _msgSender()) &&\\n       (m_balances[_msgSender()] >= _value)\\n    ){\\n      m_balances[_msgSender()] -= _value;\\n      uint256_totalSupply = uint256_totalSupply.sub(_value);\\n      retval = true;\\n      emit Burn(_msgSender(), _value);\\n    }\\n    return retval;\\n  }\\n\\n  /** \\n  * Voting related functions\\n  */\\n\\n  /**\\n   * @dev Public wrapper for _calculateVotingPower function which calulates voting power\\n   * @dev voting power = balance + locked votable balance + delegations\\n   * @return uint256 voting power\\n   */\\n  function calculateVotingPower() public view returns (uint256) {\\n    return _calculateVotingPower(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Calulates voting power of specified address\\n   * @param _account address of token holder\\n   * @return uint256 voting power\\n   */\\n  function _calculateVotingPower(address _account) private view returns (uint256) {\\n    uint256 votingPower = m_balances[_account].add(_calculateLockedVotableBalance(_account));\\n    for (uint i=0; i<m_delegatedAccountsInverseMap[_account].length(); i++) {\\n      if(m_delegatedAccountsInverseMap[_account].at(i) != address(0)){\\n        address delegatedAccount = m_delegatedAccountsInverseMap[_account].at(i);\\n        votingPower = votingPower.add(m_balances[delegatedAccount]).add(_calculateLockedVotableBalance(delegatedAccount));\\n      }\\n    }\\n    return votingPower;\\n  }\\n\\n  /**\\n   * @dev Moves a number of votes from a token holder to a designated representative\\n   * @param _source address of token holder\\n   * @param _destination address of voting delegate\\n   * @param _amount of voting delegation transfered to designated representative\\n   * @return bool whether move was successful\\n   * Requires ROLE_TEST\\n   */\\n  function moveVotingDelegates(\\n    address _source,\\n    address _destination,\\n    uint256 _amount) public returns (bool) {\\n    require(hasRole(ROLE_TEST, _msgSender()), \\\"UPGT_ERROR: ROLE_TEST Required\\\");\\n    return _moveVotingDelegates(_source, _destination, _amount);\\n  }\\n\\n  /**\\n   * @dev Moves a number of votes from a token holder to a designated representative\\n   * @param _source address of token holder\\n   * @param _destination address of voting delegate\\n   * @param _amount of voting delegation transfered to designated representative\\n   * @return bool whether move was successful\\n   */\\n  function _moveVotingDelegates(\\n      address _source, \\n      address _destination, \\n      uint256 _amount\\n  ) internal returns (bool) {\\n    if(_source != _destination && _amount > 0) {\\n      if(_source != BURN_ADDRESS) {\\n        uint256 sourceNumberOfVotingCheckpoints = m_accountVotingCheckpoints[_source];\\n        uint256 sourceNumberOfVotingCheckpointsOriginal = (sourceNumberOfVotingCheckpoints > 0)? m_votingCheckpoints[_source][sourceNumberOfVotingCheckpoints.sub(1)].votes : 0;\\n        if(sourceNumberOfVotingCheckpointsOriginal >= _amount) {\\n          uint256 sourceNumberOfVotingCheckpointsNew = sourceNumberOfVotingCheckpointsOriginal.sub(_amount);\\n          _writeVotingCheckpoint(_source, sourceNumberOfVotingCheckpoints, sourceNumberOfVotingCheckpointsOriginal, sourceNumberOfVotingCheckpointsNew);\\n        }\\n      }\\n\\n      if(_destination != BURN_ADDRESS) {\\n        uint256 destinationNumberOfVotingCheckpoints = m_accountVotingCheckpoints[_destination];\\n        uint256 destinationNumberOfVotingCheckpointsOriginal = (destinationNumberOfVotingCheckpoints > 0)? m_votingCheckpoints[_source][destinationNumberOfVotingCheckpoints.sub(1)].votes : 0;\\n        uint256 destinationNumberOfVotingCheckpointsNew = destinationNumberOfVotingCheckpointsOriginal.add(_amount);\\n        _writeVotingCheckpoint(_destination, destinationNumberOfVotingCheckpoints, destinationNumberOfVotingCheckpointsOriginal, destinationNumberOfVotingCheckpointsNew);\\n      }\\n    }\\n    \\n    return true; \\n  }\\n\\n  /**\\n   * @dev Writes voting checkpoint for a given voting delegate\\n   * @param _votingDelegate exercising votes\\n   * @param _numberOfVotingCheckpoints number of voting checkpoints for current vote\\n   * @param _oldVotes previous number of votes\\n   * @param _newVotes new number of votes\\n   * Public function for writing voting checkpoint\\n   * Requires ROLE_TEST\\n   */\\n  function writeVotingCheckpoint(\\n    address _votingDelegate,\\n    uint256 _numberOfVotingCheckpoints,\\n    uint256 _oldVotes,\\n    uint256 _newVotes) public {\\n    require(hasRole(ROLE_TEST, _msgSender()), \\\"UPGT_ERROR: ROLE_TEST Required\\\");\\n    _writeVotingCheckpoint(_votingDelegate, _numberOfVotingCheckpoints, _oldVotes, _newVotes);\\n  }\\n\\n  /**\\n   * @dev Writes voting checkpoint for a given voting delegate\\n   * @param _votingDelegate exercising votes\\n   * @param _numberOfVotingCheckpoints number of voting checkpoints for current vote\\n   * @param _oldVotes previous number of votes\\n   * @param _newVotes new number of votes\\n   * Private function for writing voting checkpoint\\n   */\\n  function _writeVotingCheckpoint(\\n    address _votingDelegate, \\n    uint256 _numberOfVotingCheckpoints, \\n    uint256 _oldVotes, \\n    uint256 _newVotes) internal {\\n    if(_numberOfVotingCheckpoints > 0 && m_votingCheckpoints[_votingDelegate][_numberOfVotingCheckpoints.sub(1)].from == block.number) {\\n      m_votingCheckpoints[_votingDelegate][_numberOfVotingCheckpoints-1].votes = _newVotes;\\n    }\\n    else {\\n      m_votingCheckpoints[_votingDelegate][_numberOfVotingCheckpoints] = VotingCheckpoint(block.number, _newVotes);\\n      _numberOfVotingCheckpoints = _numberOfVotingCheckpoints.add(1);\\n    }\\n    emit VoteBalanceChanged(_votingDelegate, _oldVotes, _newVotes);\\n  }\\n\\n  /**\\n   * @dev Calculate account votes as of a specific block\\n   * @param _account address whose votes are counted\\n   * @param _blockNumber from which votes are being counted\\n   * @return number of votes counted\\n   */\\n  function getVoteCountAtBlock(\\n    address _account, \\n    uint256 _blockNumber) public view returns (uint256) {\\n    uint256 voteCount = 0;\\n    if(_blockNumber < block.number) {\\n      if(m_accountVotingCheckpoints[_account] != 0) {\\n        if(m_votingCheckpoints[_account][m_accountVotingCheckpoints[_account].sub(1)].from <= _blockNumber) {\\n          voteCount = m_votingCheckpoints[_account][m_accountVotingCheckpoints[_account].sub(1)].votes;\\n        }\\n        else if(m_votingCheckpoints[_account][0].from > _blockNumber) {\\n          voteCount = 0;\\n        }\\n        else {\\n          uint256 lower = 0;\\n          uint256 upper = m_accountVotingCheckpoints[_account].sub(1);\\n          \\n          while(upper > lower) {\\n            uint256 center = upper.sub((upper.sub(lower).div(2)));\\n            VotingCheckpoint memory votingCheckpoint = m_votingCheckpoints[_account][center];\\n            if(votingCheckpoint.from == _blockNumber) {\\n              voteCount = votingCheckpoint.votes;\\n              break;\\n            }\\n            else if(votingCheckpoint.from < _blockNumber) {\\n              lower = center;\\n            }\\n            else {\\n              upper = center.sub(1);\\n            }\\n          \\n          }\\n        }\\n      }\\n    }\\n    return voteCount;\\n  }\\n\\n  /**\\n   * @dev Vote Delegation Functions\\n   * @param _to address where message sender is assigning votes\\n   * @return success of message sender delegating vote\\n   * delegate function does not allow assignment to burn\\n   */\\n  function delegateVote(address _to) public returns (bool) {\\n    return _delegateVote(_msgSender(), _to);\\n  }\\n\\n  /**\\n   * @dev Delegate votes from token holder to another address\\n   * @param _from Token holder \\n   * @param _toDelegate Address that will be delegated to for purpose of voting\\n   * @return success as to whether delegation has been a success\\n   */\\n  function _delegateVote(\\n    address _from, \\n    address _toDelegate) internal returns (bool) {\\n    bool retval = false;\\n    if(_toDelegate != BURN_ADDRESS) {\\n      address currentDelegate = m_delegatedAccounts[_from];\\n      uint256 fromAccountBalance = m_balances[_from].add(_calculateLockedVotableBalance(_from));\\n      address oldToDelegate = m_delegatedAccounts[_from];\\n      m_delegatedAccounts[_from] = _toDelegate;\\n\\n      m_delegatedAccountsInverseMap[oldToDelegate].remove(_from);\\n      if(_from != _toDelegate){\\n        m_delegatedAccountsInverseMap[_toDelegate].add(_from);\\n      }\\n\\n      retval = true;\\n      retval = retval && _moveVotingDelegates(currentDelegate, _toDelegate, fromAccountBalance);\\n      if(retval) {\\n        if(_from == _toDelegate){\\n          emit VotingDelegateRemoved(_from);\\n        }\\n        else{\\n          emit VotingDelegateChanged(_from, currentDelegate, _toDelegate);\\n        }\\n      }\\n    }\\n    return retval;\\n  }\\n\\n  /**\\n   * @dev Revert voting delegate control to owner account\\n   * @param _account  The account that has delegated its vote\\n   * @return success of reverting delegation to owner\\n   */\\n  function _revertVotingDelegationToOwner(address _account) internal returns (bool) {\\n    return _delegateVote(_account, _account);\\n  }\\n\\n  /**\\n   * @dev Used by an message sending account to recall its voting delegates\\n   * @return success of reverting delegation to owner\\n   */\\n  function recallVotingDelegate() public returns (bool) {\\n    return _revertVotingDelegationToOwner(_msgSender());\\n  }\\n  \\n  /**\\n   * @dev Retrieve the voting delegate for a specified account\\n   * @param _account  The account that has delegated its vote\\n   */ \\n  function getVotingDelegate(address _account) public view returns (address) {\\n    return m_delegatedAccounts[_account];\\n  }\\n\\n  /** \\n  * EIP-712 related functions\\n  */\\n\\n  /**\\n   * @dev EIP-712 Ethereum Typed Structured Data Hashing and Signing for Allocation Permit\\n   * @param _owner address of token owner\\n   * @param _spender address of designated spender\\n   * @param _value value permitted for spend\\n   * @param _deadline expiration of signature\\n   * @param _ecv ECDSA v parameter\\n   * @param _ecr ECDSA r parameter\\n   * @param _ecs ECDSA s parameter\\n   */\\n  function permit(\\n    address _owner, \\n    address _spender, \\n    uint256 _value, \\n    uint256 _deadline, \\n    uint8 _ecv, \\n    bytes32 _ecr, \\n    bytes32 _ecs\\n  ) external returns (bool) {\\n    require(block.timestamp <= _deadline, \\\"UPGT_ERROR: wrong timestamp\\\");\\n    require(uint256_chain_id == _getChainId(), \\\"UPGT_ERROR: chain_id is incorrect\\\");\\n    bytes32 digest = keccak256(abi.encodePacked(\\n        \\\"\\\\x19\\\\x01\\\",\\n        EIP712DOMAIN_SEPARATOR,\\n        keccak256(abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, m_nonces[_owner]++, _deadline))\\n      )\\n    );\\n    require(_owner == _recoverSigner(digest, _ecv, _ecr, _ecs), \\\"UPGT_ERROR: sign does not match user\\\");\\n    require(_owner != BURN_ADDRESS, \\\"UPGT_ERROR: address cannot be burn address\\\");\\n\\n    return _approveUNN(_owner, _spender, _value);\\n  }\\n\\n  /**\\n   * @dev EIP-712 ETH Typed Structured Data Hashing and Signing for Delegate Vote\\n   * @param _owner address of token owner\\n   * @param _delegate address of voting delegate\\n   * @param _expiretimestamp expiration of delegation signature\\n   * @param _ecv ECDSA v parameter\\n   * @param _ecr ECDSA r parameter\\n   * @param _ecs ECDSA s parameter\\n   * @ @return bool true or false depedening on whether vote was successfully delegated\\n   */\\n  function delegateVoteBySignature(\\n    address _owner, \\n    address _delegate, \\n    uint256 _expiretimestamp, \\n    uint8 _ecv, \\n    bytes32 _ecr, \\n    bytes32 _ecs\\n  ) external returns (bool) {\\n    require(block.timestamp <= _expiretimestamp, \\\"UPGT_ERROR: wrong timestamp\\\");\\n    require(uint256_chain_id == _getChainId(), \\\"UPGT_ERROR: chain_id is incorrect\\\");\\n    bytes32 digest = keccak256(abi.encodePacked(\\n        \\\"\\\\x19\\\\x01\\\",\\n        EIP712DOMAIN_SEPARATOR,\\n        _hash(VotingDelegate(\\n          {\\n            owner : _owner,\\n            delegate : _delegate,\\n            nonce : m_nonces[_owner]++,\\n            expirationTime : _expiretimestamp\\n          })\\n        )\\n      )\\n    );\\n    require(_owner == _recoverSigner(digest, _ecv, _ecr, _ecs), \\\"UPGT_ERROR: sign does not match user\\\");\\n    require(_owner!= BURN_ADDRESS, \\\"UPGT_ERROR: address cannot be burn address\\\");\\n\\n    return _delegateVote(_owner, _delegate);\\n  }\\n\\n  /**\\n   * @dev Public hash EIP712Domain struct for EIP-712\\n   * @param _eip712Domain EIP712Domain struct\\n   * @return bytes32 hash of _eip712Domain\\n   * Requires ROLE_TEST\\n   */\\n  function hashEIP712Domain(EIP712Domain memory _eip712Domain) public view returns (bytes32) {\\n    require(hasRole(ROLE_TEST, _msgSender()), \\\"UPGT_ERROR: ROLE_TEST Required\\\");\\n    return _hash(_eip712Domain);\\n  }\\n\\n  /**\\n   * @dev Hash Delegate struct for EIP-712\\n   * @param _delegate VotingDelegate struct\\n   * @return bytes32 hash of _delegate\\n   * Requires ROLE_TEST\\n   */\\n  function hashDelegate(VotingDelegate memory _delegate) public view returns (bytes32) {\\n    require(hasRole(ROLE_TEST, _msgSender()), \\\"UPGT_ERROR: ROLE_TEST Required\\\");\\n    return _hash(_delegate);\\n  }\\n\\n  /**\\n   * @dev Public hash Permit struct for EIP-712\\n   * @param _permit Permit struct\\n   * @return bytes32 hash of _permit\\n   * Requires ROLE_TEST\\n   */\\n  function hashPermit(Permit memory _permit) public view returns (bytes32) {\\n    require(hasRole(ROLE_TEST, _msgSender()), \\\"UPGT_ERROR: ROLE_TEST Required\\\");\\n    return _hash(_permit);\\n  }\\n\\n  /**\\n   * @param _digest signed, hashed message\\n   * @param _ecv ECDSA v parameter\\n   * @param _ecr ECDSA r parameter\\n   * @param _ecs ECDSA s parameter\\n   * @return address of the validated signer\\n   * based on openzeppelin/contracts/cryptography/ECDSA.sol recover() function\\n   * Requires ROLE_TEST\\n   */\\n  function recoverSigner(bytes32 _digest, uint8 _ecv, bytes32 _ecr, bytes32 _ecs) public view returns (address) {\\n    require(hasRole(ROLE_TEST, _msgSender()), \\\"UPGT_ERROR: ROLE_TEST Required\\\");\\n    return _recoverSigner(_digest, _ecv, _ecr, _ecs);\\n  }\\n\\n  /**\\n  * @dev Private hash EIP712Domain struct for EIP-712\\n  * @param _eip712Domain EIP712Domain struct\\n  * @return bytes32 hash of _eip712Domain\\n  */\\n  function _hash(EIP712Domain memory _eip712Domain) internal pure returns (bytes32) {\\n      return keccak256(\\n          abi.encode(\\n              EIP712DOMAIN_TYPEHASH,\\n              keccak256(bytes(_eip712Domain.name)),\\n              keccak256(bytes(_eip712Domain.version)),\\n              _eip712Domain.chainId,\\n              _eip712Domain.verifyingContract,\\n              _eip712Domain.salt\\n          )\\n      );\\n  }\\n\\n  /**\\n  * @dev Private hash Delegate struct for EIP-712\\n  * @param _delegate VotingDelegate struct\\n  * @return bytes32 hash of _delegate\\n  */\\n  function _hash(VotingDelegate memory _delegate) internal pure returns (bytes32) {\\n      return keccak256(\\n          abi.encode(\\n              DELEGATE_TYPEHASH,\\n              _delegate.owner,\\n              _delegate.delegate,\\n              _delegate.nonce,\\n              _delegate.expirationTime\\n          )\\n      );\\n  }\\n\\n  /** \\n  * @dev Private hash Permit struct for EIP-712\\n  * @param _permit Permit struct\\n  * @return bytes32 hash of _permit\\n  */\\n  function _hash(Permit memory _permit) internal pure returns (bytes32) {\\n      return keccak256(abi.encode(\\n      PERMIT_TYPEHASH,\\n      _permit.owner,\\n      _permit.spender,\\n      _permit.value,\\n      _permit.nonce,\\n      _permit.deadline\\n      ));\\n  }\\n\\n  /**\\n  * @dev Recover signer information from provided digest\\n  * @param _digest signed, hashed message\\n  * @param _ecv ECDSA v parameter\\n  * @param _ecr ECDSA r parameter\\n  * @param _ecs ECDSA s parameter\\n  * @return address of the validated signer\\n  * based on openzeppelin/contracts/cryptography/ECDSA.sol recover() function\\n  */\\n  function _recoverSigner(bytes32 _digest, uint8 _ecv, bytes32 _ecr, bytes32 _ecs) internal pure returns (address) {\\n      // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n      // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n      // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n      // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n      //\\n      // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n      // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n      // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n      // these malleable signatures as well.\\n      if(uint256(_ecs) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n          revert(\\\"ECDSA: invalid signature 's' value\\\");\\n      }\\n\\n      if(_ecv != 27 && _ecv != 28) {\\n          revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n      }\\n\\n      // If the signature is valid (and not malleable), return the signer address\\n      address signer = ecrecover(_digest, _ecv, _ecr, _ecs);\\n      require(signer != BURN_ADDRESS, \\\"ECDSA: invalid signature\\\");\\n\\n      return signer;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/MProtection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\nimport \\\"./Interfaces/CopMappingInterface.sol\\\";\\nimport \\\"./Interfaces/Versionable.sol\\\";\\nimport \\\"./Moartroller.sol\\\";\\nimport \\\"./Utils/ExponentialNoError.sol\\\";\\nimport \\\"./Utils/ErrorReporter.sol\\\";\\nimport \\\"./Utils/AssetHelpers.sol\\\";\\nimport \\\"./MToken.sol\\\";\\nimport \\\"./Interfaces/EIP20Interface.sol\\\";\\nimport \\\"./Utils/SafeEIP20.sol\\\";\\n\\n/**\\n * @title MOAR's MProtection Contract\\n * @notice Collateral optimization ERC-721 wrapper\\n * @author MOAR\\n */\\ncontract MProtection is ERC721Upgradeable, OwnableUpgradeable, ExponentialNoError, AssetHelpers, Versionable {\\n    using Counters for Counters.Counter;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    /**\\n     * @notice Event emitted when new MProtection token is minted\\n     */\\n    event Mint(address minter, uint tokenId, uint underlyingTokenId, address asset, uint amount, uint strikePrice, uint expirationTime);\\n\\n    /**\\n     * @notice Event emitted when MProtection token is redeemed\\n     */\\n    event Redeem(address redeemer, uint tokenId, uint underlyingTokenId);\\n\\n    /**\\n     * @notice Event emitted when MProtection token changes its locked value\\n     */\\n    event LockValue(uint tokenId, uint underlyingTokenId, uint optimizationValue);\\n\\n    /**\\n     * @notice Event emitted when maturity window parameter is changed\\n     */\\n    event MaturityWindowUpdated(uint newMaturityWindow);\\n\\n    Counters.Counter private _tokenIds;\\n    address private _copMappingAddress;\\n    address private _moartrollerAddress;\\n    mapping (uint256 => uint256) private _underlyingProtectionTokensMapping;\\n    mapping (uint256 => uint256) private _underlyingProtectionLockedValue;\\n    mapping (address => mapping (address => EnumerableSet.UintSet)) private _protectionCurrencyMapping;\\n    uint256 public _maturityWindow;\\n\\n    struct ProtectionMappedData{\\n        address pool;\\n        address underlyingAsset;\\n        uint256 amount;\\n        uint256 strike;\\n        uint256 premium;\\n        uint256 lockedValue;\\n        uint256 totalValue;\\n        uint issueTime;\\n        uint expirationTime;\\n        bool isProtectionAlive;\\n    }\\n\\n    /**\\n     * @notice Constructor for MProtection contract\\n     * @param copMappingAddress The address of data mapper for C-OP\\n     * @param moartrollerAddress The address of the Moartroller\\n     */\\n    function initialize(address copMappingAddress, address moartrollerAddress) public initializer {\\n        __Ownable_init();\\n        __ERC721_init(\\\"c-uUNN OC-Protection\\\", \\\"c-uUNN\\\");\\n        _copMappingAddress = copMappingAddress;\\n        _moartrollerAddress = moartrollerAddress;\\n        _setMaturityWindow(10800); // 3 hours default\\n    }\\n\\n    /**\\n     * @notice Returns C-OP mapping contract \\n     */\\n    function copMapping() private view returns (CopMappingInterface){\\n        return CopMappingInterface(_copMappingAddress);\\n    }\\n\\n    /**\\n     * @notice Mint new MProtection token\\n     * @param underlyingTokenId Id of C-OP token that will be deposited\\n     * @return ID of minted MProtection token\\n     */\\n    function mint(uint256 underlyingTokenId) public returns (uint256)\\n    {\\n        return mintFor(underlyingTokenId, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Mint new MProtection token for specified address\\n     * @param underlyingTokenId Id of C-OP token that will be deposited\\n     * @param receiver Address that will receive minted Mprotection token\\n     * @return ID of minted MProtection token\\n     */\\n    function mintFor(uint256 underlyingTokenId, address receiver) public returns (uint256)\\n    {\\n        CopMappingInterface copMappingInstance = copMapping();\\n        ERC721Upgradeable(copMappingInstance.getTokenAddress()).transferFrom(msg.sender, address(this), underlyingTokenId);\\n        _tokenIds.increment();\\n        uint256 newItemId = _tokenIds.current();\\n        _mint(receiver, newItemId);\\n        addUProtectionIndexes(receiver, newItemId, underlyingTokenId);\\n        emit Mint(\\n            receiver,\\n            newItemId,\\n            underlyingTokenId,\\n            copMappingInstance.getUnderlyingAsset(underlyingTokenId),\\n            copMappingInstance.getUnderlyingAmount(underlyingTokenId),\\n            copMappingInstance.getUnderlyingStrikePrice(underlyingTokenId),\\n            copMappingInstance.getUnderlyingDeadline(underlyingTokenId)\\n        );\\n        \\n        return newItemId;\\n    }\\n\\n    /**\\n     * @notice Redeem C-OP token\\n     * @param tokenId Id of MProtection token that will be withdrawn\\n     * @return ID of redeemed C-OP token\\n     */\\n    function redeem(uint256 tokenId) external returns (uint256) {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"cuUNN: caller is not owner nor approved\\\");\\n        uint256 underlyingTokenId = getUnderlyingProtectionTokenId(tokenId);\\n        ERC721Upgradeable(copMapping().getTokenAddress()).transferFrom(address(this), msg.sender, underlyingTokenId);\\n        removeProtectionIndexes(tokenId);\\n        _burn(tokenId);\\n        emit Redeem(msg.sender, tokenId, underlyingTokenId);\\n\\n        return underlyingTokenId;\\n    }\\n\\n    /**\\n     * @notice Returns set of C-OP data\\n     * @param tokenId Id of MProtection token \\n     * @return ProtectionMappedData struct filled with C-OP data\\n     */\\n    function getMappedProtectionData(uint256 tokenId) public view returns (ProtectionMappedData memory){\\n        ProtectionMappedData memory data;\\n        (address pool, uint256 amount, uint256 strike, uint256 premium, uint issueTime , uint expirationTime) = getProtectionData(tokenId);\\n        data = ProtectionMappedData(pool, getUnderlyingAsset(tokenId), amount, strike, premium, getUnderlyingProtectionLockedValue(tokenId), getUnderlyingProtectionTotalValue(tokenId), issueTime, expirationTime, isProtectionAlive(tokenId));\\n        return data;\\n    }\\n\\n    /**\\n     * @notice Returns underlying token ID\\n     * @param tokenId Id of MProtection token \\n     */\\n    function getUnderlyingProtectionTokenId(uint256 tokenId) public view returns (uint256){\\n        return _underlyingProtectionTokensMapping[tokenId];\\n    }\\n\\n    /**\\n     * @notice Returns size of C-OPs filtered by asset address\\n     * @param owner Address of wallet holding C-OPs\\n     * @param currency Address of asset used to filter C-OPs\\n     */\\n    function getUserUnderlyingProtectionTokenIdByCurrencySize(address owner, address currency) public view returns (uint256){\\n        return _protectionCurrencyMapping[owner][currency].length();\\n    }\\n\\n    /**\\n     * @notice Returns list of C-OP IDs filtered by asset address\\n     * @param owner Address of wallet holding C-OPs\\n     * @param currency Address of asset used to filter C-OPs\\n     */\\n    function getUserUnderlyingProtectionTokenIdByCurrency(address owner, address currency, uint256 index) public view returns (uint256){\\n        return _protectionCurrencyMapping[owner][currency].at(index);\\n    }\\n\\n    /**\\n     * @notice Checks if address is owner of MProtection\\n     * @param owner Address of potential owner to check\\n     * @param tokenId ID of MProtection to check\\n     */\\n    function isUserProtection(address owner, uint256 tokenId) public view returns(bool) {\\n        if(Moartroller(_moartrollerAddress).isPrivilegedAddress(msg.sender)){\\n            return true;\\n        }\\n        return owner == ownerOf(tokenId);\\n    }\\n\\n    /**\\n     * @notice Checks if MProtection is stil alive\\n     * @param tokenId ID of MProtection to check\\n     */\\n    function isProtectionAlive(uint256 tokenId) public view returns(bool) {\\n       uint256 deadline = getUnderlyingDeadline(tokenId);\\n       return (deadline - _maturityWindow) > now;\\n    }\\n\\n    /**\\n     * @notice Creates appropriate indexes for C-OP\\n     * @param owner C-OP owner address\\n     * @param tokenId ID of MProtection \\n     * @param underlyingTokenId ID of C-OP \\n     */\\n    function addUProtectionIndexes(address owner, uint256 tokenId, uint256 underlyingTokenId) private{\\n        address currency = copMapping().getUnderlyingAsset(underlyingTokenId);\\n        _underlyingProtectionTokensMapping[tokenId] = underlyingTokenId;\\n        _protectionCurrencyMapping[owner][currency].add(tokenId);\\n    }\\n\\n    /**\\n     * @notice Remove indexes for C-OP\\n     * @param tokenId ID of MProtection \\n     */\\n    function removeProtectionIndexes(uint256 tokenId) private{\\n        address owner = ownerOf(tokenId);\\n        address currency = getUnderlyingAsset(tokenId);\\n        _underlyingProtectionTokensMapping[tokenId] = 0;\\n        _protectionCurrencyMapping[owner][currency].remove(tokenId);\\n    }\\n\\n    /**\\n     * @notice Returns C-OP total value\\n     * @param tokenId ID of MProtection \\n     */\\n    function getUnderlyingProtectionTotalValue(uint256 tokenId) public view returns(uint256){\\n        address underlyingAsset = getUnderlyingAsset(tokenId);\\n        uint256 assetDecimalsMantissa = getAssetDecimalsMantissa(underlyingAsset);\\n\\n        return div_(\\n            mul_(\\n                getUnderlyingStrikePrice(tokenId),\\n                getUnderlyingAmount(tokenId)\\n            ),\\n            assetDecimalsMantissa\\n        );\\n    }\\n\\n    /**\\n     * @notice Returns C-OP locked value\\n     * @param tokenId ID of MProtection \\n     */\\n    function getUnderlyingProtectionLockedValue(uint256 tokenId) public view returns(uint256){\\n        return _underlyingProtectionLockedValue[tokenId];\\n    }\\n\\n    /**\\n     * @notice get the amount of underlying asset that is locked\\n     * @param tokenId CProtection tokenId\\n     * @return amount locked\\n     */\\n    function getUnderlyingProtectionLockedAmount(uint256 tokenId) public view returns(uint256){\\n        address underlyingAsset = getUnderlyingAsset(tokenId);\\n        uint256 assetDecimalsMantissa = getAssetDecimalsMantissa(underlyingAsset);\\n\\n        // calculates total protection value\\n        uint256 protectionValue = div_(\\n            mul_(\\n                getUnderlyingAmount(tokenId),\\n                getUnderlyingStrikePrice(tokenId)\\n            ),\\n            assetDecimalsMantissa\\n        );\\n\\n        // return value is lockedValue / totalValue * amount\\n        return div_(\\n            mul_(\\n                getUnderlyingAmount(tokenId),\\n                div_(\\n                    mul_(\\n                        _underlyingProtectionLockedValue[tokenId],\\n                        1e18\\n                    ),\\n                    protectionValue\\n                )\\n            ),\\n            1e18\\n        );\\n    }\\n\\n    /**\\n     * @notice Locks the given protection value as collateral optimization\\n     * @param tokenId The MProtection token id\\n     * @param value The value in stablecoin of protection to be locked as collateral optimization. 0 = max available optimization\\n     * @return locked protection value\\n     * TODO: convert semantic errors to standarized error codes\\n     */\\n    function lockProtectionValue(uint256 tokenId, uint value) external returns(uint) {\\n        //check if the protection belongs to the caller\\n        require(isUserProtection(msg.sender, tokenId), \\\"ERROR: CALLER IS NOT THE OWNER OF PROTECTION\\\");\\n\\n        address currency = getUnderlyingAsset(tokenId);\\n\\n        Moartroller moartroller = Moartroller(_moartrollerAddress);\\n        MToken mToken = moartroller.tokenAddressToMToken(currency);\\n        require(moartroller.oracle().getUnderlyingPrice(mToken) <= getUnderlyingStrikePrice(tokenId), \\\"ERROR: C-OP STRIKE PRICE IS LOWER THAN ASSET SPOT PRICE\\\");\\n\\n        uint protectionTotalValue = getUnderlyingProtectionTotalValue(tokenId);\\n        uint maxOptimizableValue = moartroller.getMaxOptimizableValue(mToken, ownerOf(tokenId));\\n\\n        // add protection locked value if any\\n        uint protectionLockedValue = getUnderlyingProtectionLockedValue(tokenId);\\n        if ( protectionLockedValue > 0) {\\n            maxOptimizableValue = add_(maxOptimizableValue, protectionLockedValue);\\n        }\\n\\n        uint valueToLock;\\n\\n        if (value != 0) {\\n            // check if lock value is at most max optimizable value\\n            require(value <= maxOptimizableValue, \\\"ERROR: VALUE TO BE LOCKED EXCEEDS ALLOWED OPTIMIZATION VALUE\\\");\\n            // check if lock value is at most protection total value\\n            require( value <= protectionTotalValue, \\\"ERROR: VALUE TO BE LOCKED EXCEEDS PROTECTION TOTAL VALUE\\\");\\n            valueToLock = value;\\n        } else {\\n            // if we want to lock maximum protection value let's lock the value that is at most max optimizable value\\n            if (protectionTotalValue > maxOptimizableValue) {\\n                valueToLock = maxOptimizableValue;\\n            } else {\\n                valueToLock = protectionTotalValue;\\n            }\\n        }\\n\\n        _underlyingProtectionLockedValue[tokenId] = valueToLock;\\n        emit LockValue(tokenId, getUnderlyingProtectionTokenId(tokenId), valueToLock);\\n        return valueToLock;\\n    }\\n\\n    function _setCopMapping(address newMapping) public onlyOwner {\\n        _copMappingAddress = newMapping;\\n    }\\n\\n    function _setMoartroller(address newMoartroller) public onlyOwner {\\n        _moartrollerAddress = newMoartroller;\\n    }\\n\\n    function _setMaturityWindow(uint256 maturityWindow) public onlyOwner {\\n        emit MaturityWindowUpdated(maturityWindow);\\n        _maturityWindow = maturityWindow;\\n    }\\n\\n\\n    // MAPPINGS \\n    function getProtectionData(uint256 tokenId) public view returns (address, uint256, uint256, uint256, uint, uint){\\n        uint256 underlyingTokenId = getUnderlyingProtectionTokenId(tokenId);\\n        return copMapping().getProtectionData(underlyingTokenId);\\n    }\\n\\n    function getUnderlyingAsset(uint256 tokenId) public view returns (address){\\n        uint256 underlyingTokenId = getUnderlyingProtectionTokenId(tokenId);\\n        return copMapping().getUnderlyingAsset(underlyingTokenId);\\n    }\\n\\n    function getUnderlyingAmount(uint256 tokenId) public view returns (uint256){\\n        uint256 underlyingTokenId = getUnderlyingProtectionTokenId(tokenId);\\n        return copMapping().getUnderlyingAmount(underlyingTokenId);\\n    }\\n\\n    function getUnderlyingStrikePrice(uint256 tokenId) public view returns (uint){\\n        uint256 underlyingTokenId = getUnderlyingProtectionTokenId(tokenId);\\n        return copMapping().getUnderlyingStrikePrice(underlyingTokenId);\\n    }\\n\\n    function getUnderlyingDeadline(uint256 tokenId) public view returns (uint){\\n        uint256 underlyingTokenId = getUnderlyingProtectionTokenId(tokenId);\\n        return copMapping().getUnderlyingDeadline(underlyingTokenId);\\n    }\\n\\n    function getContractVersion() external override pure returns(string memory){\\n        return \\\"V1\\\";\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/Interfaces/LiquidityMathModelInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.6.12;\\n\\nimport \\\"../MToken.sol\\\";\\nimport \\\"../MProtection.sol\\\";\\nimport \\\"../Interfaces/PriceOracle.sol\\\";\\n\\ninterface LiquidityMathModelInterface {\\n    struct LiquidityMathArgumentsSet {\\n        MToken asset;\\n        address account;\\n        uint collateralFactorMantissa;\\n        MProtection cprotection;\\n        PriceOracle oracle;\\n    }\\n    \\n    function getMaxOptimizableValue(LiquidityMathArgumentsSet memory _arguments) external view returns (uint);\\n    function getHypotheticalOptimizableValue(LiquidityMathArgumentsSet memory _arguments) external view returns(uint);\\n    function getTotalProtectionLockedValue(LiquidityMathArgumentsSet memory _arguments) external view returns(uint, uint);\\n}\"\r\n    },\r\n    \"contracts/LiquidityMathModelV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.6.12;\\n\\nimport \\\"./Interfaces/LiquidityMathModelInterface.sol\\\";\\nimport \\\"./MToken.sol\\\";\\nimport \\\"./Utils/ErrorReporter.sol\\\";\\nimport \\\"./Utils/ExponentialNoError.sol\\\";\\nimport \\\"./Utils/AssetHelpers.sol\\\";\\nimport \\\"./Moartroller.sol\\\";\\nimport \\\"./SimplePriceOracle.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n\\ncontract LiquidityMathModelV1 is LiquidityMathModelInterface, LiquidityMathModelErrorReporter, ExponentialNoError, Ownable, AssetHelpers {\\n\\n\\n    /**\\n     * @notice get the maximum asset value that can be still optimized.\\n     * @notice if protectionId is supplied, the maxOptimizableValue is increased by the protection lock value'\\n     * which is helpful to recalculate how much of this protection can be optimized again\\n     */\\n    function getMaxOptimizableValue(LiquidityMathModelInterface.LiquidityMathArgumentsSet memory arguments) external override view returns (uint){\\n        uint returnValue;\\n        uint hypotheticalOptimizableValue = getHypotheticalOptimizableValue(arguments);\\n        uint totalProtectionLockedValue;\\n        (totalProtectionLockedValue, ) = getTotalProtectionLockedValue(arguments);\\n        if(hypotheticalOptimizableValue <= totalProtectionLockedValue){\\n            returnValue = 0;\\n        }\\n        else{\\n            returnValue = sub_(hypotheticalOptimizableValue, totalProtectionLockedValue);\\n        }\\n\\n        return returnValue;\\n    }\\n\\n    /**\\n     * @notice get the maximum value of an asset that can be optimized by protection for the given user\\n     * @dev optimizable = asset value * MPC\\n     * @return the hypothetical optimizable value\\n     * TODO: replace hardcoded 1e18 values\\n     */\\n    function getHypotheticalOptimizableValue(LiquidityMathModelInterface.LiquidityMathArgumentsSet memory arguments) public override view returns(uint) {\\n        uint assetValue = div_(\\n            mul_(\\n                div_(\\n                    mul_(\\n                    arguments.asset.balanceOf(arguments.account),\\n                    arguments.asset.exchangeRateStored()\\n                    ),\\n                    1e18\\n                ),\\n                arguments.oracle.getUnderlyingPrice(arguments.asset)\\n            ),\\n            getAssetDecimalsMantissa(arguments.asset.getUnderlying())\\n        );\\n\\n        uint256 hypotheticalOptimizableValue = div_(\\n            mul_(\\n                assetValue,\\n                arguments.asset.maxProtectionComposition()\\n            ),\\n            arguments.asset.maxProtectionCompositionMantissa()\\n        );\\n        return hypotheticalOptimizableValue;\\n    }\\n\\n    /**\\n     * @dev gets all locked protections values with mark to market value. Used by Moartroller.\\n     */\\n    function getTotalProtectionLockedValue(LiquidityMathModelInterface.LiquidityMathArgumentsSet memory arguments) public override view returns(uint, uint) {\\n        uint _lockedValue = 0;\\n        uint _markToMarket = 0;\\n\\n        uint _protectionCount = arguments.cprotection.getUserUnderlyingProtectionTokenIdByCurrencySize(arguments.account, arguments.asset.underlying());\\n        for (uint j = 0; j < _protectionCount; j++) {\\n            uint protectionId = arguments.cprotection.getUserUnderlyingProtectionTokenIdByCurrency(arguments.account, arguments.asset.underlying(), j);\\n            bool protectionIsAlive = arguments.cprotection.isProtectionAlive(protectionId);\\n\\n            if(protectionIsAlive){\\n                _lockedValue = add_(_lockedValue, arguments.cprotection.getUnderlyingProtectionLockedValue(protectionId));\\n\\n                uint assetSpotPrice = arguments.oracle.getUnderlyingPrice(arguments.asset);\\n                uint protectionStrikePrice = arguments.cprotection.getUnderlyingStrikePrice(protectionId);\\n\\n                if( assetSpotPrice > protectionStrikePrice) {\\n                    _markToMarket = _markToMarket + div_(\\n                        mul_(\\n                            div_(\\n                                mul_(\\n                                    assetSpotPrice - protectionStrikePrice,\\n                                    arguments.cprotection.getUnderlyingProtectionLockedAmount(protectionId)\\n                                ),\\n                                getAssetDecimalsMantissa(arguments.asset.underlying())\\n                            ),\\n                            arguments.collateralFactorMantissa\\n                        ),\\n                    1e18\\n                    );\\n                }\\n            }\\n            \\n        }\\n        return (_lockedValue , _markToMarket);\\n    }\\n}\"\r\n    },\r\n    \"contracts/Interfaces/LiquidationModelInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./PriceOracle.sol\\\";\\nimport \\\"./MoartrollerInterface.sol\\\";\\npragma solidity ^0.6.12;\\n\\n\\ninterface LiquidationModelInterface {\\n    function liquidateCalculateSeizeUserTokens(LiquidateCalculateSeizeUserTokensArgumentsSet memory arguments) external view returns (uint, uint);\\n    function liquidateCalculateSeizeTokens(LiquidateCalculateSeizeUserTokensArgumentsSet memory arguments) external view returns (uint, uint);\\n\\n    struct LiquidateCalculateSeizeUserTokensArgumentsSet {\\n        PriceOracle oracle;\\n        MoartrollerInterface moartroller;\\n        address mTokenBorrowed;\\n        address mTokenCollateral;\\n        uint actualRepayAmount;\\n        address accountForLiquidation;\\n        uint liquidationIncentiveMantissa;\\n\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/InterestRateModelInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.6.12;\\n\\n/**\\n  * @title MOAR's InterestRateModel Interface\\n  * @author MOAR\\n  */\\ninterface InterestRateModelInterface {\\n    /**\\n      * @notice Calculates the current borrow interest rate per block\\n      * @param cash The total amount of cash the market has\\n      * @param borrows The total amount of borrows the market has outstanding\\n      * @param reserves The total amount of reserves the market has\\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\\n      */\\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint);\\n\\n    /**\\n      * @notice Calculates the current supply interest rate per block\\n      * @param cash The total amount of cash the market has\\n      * @param borrows The total amount of borrows the market has outstanding\\n      * @param reserves The total amount of reserves the market has\\n      * @param reserveFactorMantissa The current reserve factor the market has\\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\\n      */\\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external view returns (uint);\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"./IERC721Upgradeable.sol\\\";\\nimport \\\"./IERC721MetadataUpgradeable.sol\\\";\\nimport \\\"./IERC721EnumerableUpgradeable.sol\\\";\\nimport \\\"./IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"../../introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../math/SafeMathUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"../../utils/EnumerableMapUpgradeable.sol\\\";\\nimport \\\"../../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../../proxy/Initializable.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable, IERC721EnumerableUpgradeable {\\n    using SafeMathUpgradeable for uint256;\\n    using AddressUpgradeable for address;\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\\n    using EnumerableMapUpgradeable for EnumerableMapUpgradeable.UintToAddressMap;\\n    using StringsUpgradeable for uint256;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from holder address to their (enumerable) set of owned tokens\\n    mapping (address => EnumerableSetUpgradeable.UintSet) private _holderTokens;\\n\\n    // Enumerable mapping from token ids to their owners\\n    EnumerableMapUpgradeable.UintToAddressMap private _tokenOwners;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Optional mapping for token URIs\\n    mapping (uint256 => string) private _tokenURIs;\\n\\n    // Base URI\\n    string private _baseURI;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\\n     *\\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    /*\\n     *     bytes4(keccak256('name()')) == 0x06fdde03\\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\\n     *\\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    /*\\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\\n     *\\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    function __ERC721_init(string memory name_, string memory symbol_) internal initializer {\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __ERC721_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {\\n        _name = name_;\\n        _symbol = symbol_;\\n\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _holderTokens[owner].length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n        string memory base = baseURI();\\n\\n        // If there is no base URI, return the token URI.\\n        if (bytes(base).length == 0) {\\n            return _tokenURI;\\n        }\\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\n        if (bytes(_tokenURI).length > 0) {\\n            return string(abi.encodePacked(base, _tokenURI));\\n        }\\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\\n        return string(abi.encodePacked(base, tokenId.toString()));\\n    }\\n\\n    /**\\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\\n    * to the token ID if no specific URI is set for that token ID.\\n    */\\n    function baseURI() public view virtual returns (string memory) {\\n        return _baseURI;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        return _holderTokens[owner].at(index);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\\n        return _tokenOwners.length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        (uint256 tokenId, ) = _tokenOwners.at(index);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || ERC721Upgradeable.isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _tokenOwners.contains(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || ERC721Upgradeable.isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     d*\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId); // internal owner\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        // Clear metadata (if any)\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n\\n        _holderTokens[owner].remove(tokenId);\\n\\n        _tokenOwners.remove(tokenId);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\"); // internal owner\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _holderTokens[from].remove(tokenId);\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    /**\\n     * @dev Internal function to set the base URI for all token IDs. It is\\n     * automatically added as a prefix to the value returned in {tokenURI},\\n     * or to the token ID if {tokenURI} is empty.\\n     */\\n    function _setBaseURI(string memory baseURI_) internal virtual {\\n        _baseURI = baseURI_;\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\\n            IERC721ReceiverUpgradeable(to).onERC721Received.selector,\\n            _msgSender(),\\n            from,\\n            tokenId,\\n            _data\\n        ), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n        bytes4 retval = abi.decode(returndata, (bytes4));\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId); // internal owner\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n    uint256[41] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../math/SafeMath.sol\\\";\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\\n * directly accessed.\\n */\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/CopMappingInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\ninterface CopMappingInterface {\\n    function getTokenAddress() external view returns (address);\\n    function getProtectionData(uint256 underlyingTokenId) external view returns (address, uint256, uint256, uint256, uint, uint);\\n    function getUnderlyingAsset(uint256 underlyingTokenId) external view returns (address);\\n    function getUnderlyingAmount(uint256 underlyingTokenId) external view returns (uint256);\\n    function getUnderlyingStrikePrice(uint256 underlyingTokenId) external view returns (uint);\\n    function getUnderlyingDeadline(uint256 underlyingTokenId) external view returns (uint);\\n\\n}\"\r\n    },\r\n    \"contracts/Utils/AssetHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\nimport \\\"../Interfaces/EIP20Interface.sol\\\";\\n\\ncontract AssetHelpers {\\n    /**\\n     * @dev return asset decimals mantissa. Returns 1e18 if ETH\\n     */\\n    function getAssetDecimalsMantissa(address assetAddress) public view returns (uint256){\\n        uint assetDecimals = 1e18;\\n        if (assetAddress != address(0)) {\\n            EIP20Interface token = EIP20Interface(assetAddress);\\n            assetDecimals = 10 ** uint256(token.decimals());\\n        }\\n        return assetDecimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\nimport \\\"../proxy/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721EnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../proxy/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    function __ERC165_init() internal initializer {\\n        __ERC165_init_unchained();\\n    }\\n\\n    function __ERC165_init_unchained() internal initializer {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMathUpgradeable {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/EnumerableMapUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\\n * supported.\\n */\\nlibrary EnumerableMapUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct MapEntry {\\n        bytes32 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct Map {\\n        // Storage of map keys and values\\n        MapEntry[] _entries;\\n\\n        // Position of the entry defined by a key in the `entries` array, plus 1\\n        // because index 0 means a key is not in the map.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\\n            map._entries.push(MapEntry({ _key: key, _value: value }));\\n            // The entry is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            map._indexes[key] = map._entries.length;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = keyIndex - 1;\\n            uint256 lastIndex = map._entries.length - 1;\\n\\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            MapEntry storage lastEntry = map._entries[lastIndex];\\n\\n            // Move the last entry to the index where the entry to delete is\\n            map._entries[toDeleteIndex] = lastEntry;\\n            // Update the index for the moved entry\\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved entry was stored\\n            map._entries.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._entries.length;\\n    }\\n\\n   /**\\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of entries inside the\\n    * array, and it may change when more entries are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n        require(map._entries.length > index, \\\"EnumerableMap: index out of bounds\\\");\\n\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, \\\"EnumerableMap: nonexistent key\\\"); // Equivalent to contains(map, key)\\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\\n    }\\n\\n    /**\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\\n     */\\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the element stored at position `index` in the set. O(1).\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/EnumerableSet.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SimplePriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.6.12;\\n\\nimport \\\"./Interfaces/PriceOracle.sol\\\";\\nimport \\\"./CErc20.sol\\\";\\n\\n/**\\n * Temporary simple price feed \\n */\\ncontract SimplePriceOracle is PriceOracle {\\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\\n    bool public constant isPriceOracle = true;\\n\\n    mapping(address => uint) prices;\\n\\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\\n\\n    function getUnderlyingPrice(MToken mToken) public override view returns (uint) {\\n        if (compareStrings(mToken.symbol(), \\\"mDAI\\\")) {\\n            return 1e18;\\n        } else {\\n            return prices[address(MErc20(address(mToken)).underlying())];\\n        }\\n    }\\n\\n    function setUnderlyingPrice(MToken mToken, uint underlyingPriceMantissa) public {\\n        address asset = address(MErc20(address(mToken)).underlying());\\n        emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\\n        prices[asset] = underlyingPriceMantissa;\\n    }\\n\\n    function setDirectPrice(address asset, uint price) public {\\n        emit PricePosted(asset, prices[asset], price, price);\\n        prices[asset] = price;\\n    }\\n\\n    // v1 price oracle interface for use as backing of proxy\\n    function assetPrices(address asset) external view returns (uint) {\\n        return prices[asset];\\n    }\\n\\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cashPrior\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestAccumulated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"AccrueInterest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"info\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"detail\",\"type\":\"uint256\"}],\"name\":\"Failure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"MTokenCollateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"name\":\"LiquidateBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"MpcUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"oldInterestRateModel\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract InterestRateModelInterface\",\"name\":\"newInterestRateModel\",\"type\":\"address\"}],\"name\":\"NewMarketInterestRateModel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract Moartroller\",\"name\":\"oldMoartroller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract Moartroller\",\"name\":\"newMoartroller\",\"type\":\"address\"}],\"name\":\"NewMoartroller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldReserveFactorMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReserveFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"NewReserveFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"RepayBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"benefactor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"addAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalReserves\",\"type\":\"uint256\"}],\"name\":\"ReservesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reduceAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalReserves\",\"type\":\"uint256\"}],\"name\":\"ReservesReduced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_acceptAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"addAmount\",\"type\":\"uint256\"}],\"name\":\"_addReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reduceAmount\",\"type\":\"uint256\"}],\"name\":\"_reduceReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AbstractInterestRateModel\",\"name\":\"newInterestRateModel\",\"type\":\"address\"}],\"name\":\"_setInterestRateModel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMPC\",\"type\":\"uint256\"}],\"name\":\"_setMaxProtectionComposition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Moartroller\",\"name\":\"newMoartroller\",\"type\":\"address\"}],\"name\":\"_setMoartroller\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"_setPendingAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newReserveFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"_setReserveFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newReserveSplitFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"_setReserveSplitFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountBorrows\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrualBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrueInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOfUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"borrowBalanceCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"borrowBalanceStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"borrowFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountSnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRealBorrowIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnderlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Moartroller\",\"name\":\"moartroller_\",\"type\":\"address\"},{\"internalType\":\"contract AbstractInterestRateModel\",\"name\":\"interestRateModel_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialExchangeRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying_\",\"type\":\"address\"},{\"internalType\":\"contract Moartroller\",\"name\":\"moartroller_\",\"type\":\"address\"},{\"internalType\":\"contract AbstractInterestRateModel\",\"name\":\"interestRateModel_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialExchangeRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying_\",\"type\":\"address\"},{\"internalType\":\"contract Moartroller\",\"name\":\"moartroller_\",\"type\":\"address\"},{\"internalType\":\"contract AbstractInterestRateModel\",\"name\":\"interestRateModel_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialExchangeRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"address payable\",\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRateModel\",\"outputs\":[{\"internalType\":\"contract AbstractInterestRateModel\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"contract MToken\",\"name\":\"mTokenCollateral\",\"type\":\"address\"}],\"name\":\"liquidateBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxProtectionComposition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxProtectionCompositionMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moartroller\",\"outputs\":[{\"internalType\":\"contract Moartroller\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"}],\"name\":\"redeemUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"repayBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"repayBorrowBehalf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveFactorMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveSplitFactorMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"name\":\"seize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract EIP20Interface\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBorrows\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBorrowsCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MErc20Immutable","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}