{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.11\r\n\r\n\r\ninterface Vault:\r\n    def token() -> address: view\r\n    def apiVersion() -> String[28]: view\r\n    def governance() -> address: view\r\n    def initialize(\r\n        token: address,\r\n        governance: address,\r\n        rewards: address,\r\n        name: String[64],\r\n        symbol: String[32],\r\n        guardian: address,\r\n    ): nonpayable\r\n\r\n\r\n# len(releases)\r\nnumReleases: public(uint256)\r\nreleases: public(HashMap[uint256, address])\r\n\r\n# Token => len(vaults)\r\nnumVaults: public(HashMap[address, uint256])\r\nvaults: public(HashMap[address, HashMap[uint256, address]])\r\n\r\n# Index of token added => token address\r\ntokens: public(HashMap[uint256, address])\r\n# len(tokens)\r\nnumTokens: public(uint256)\r\n# Inclusion check for token\r\nisRegistered: public(HashMap[address, bool])\r\n\r\n# 2-phase commit\r\ngovernance: public(address)\r\npendingGovernance: public(address)\r\n\r\ntags: public(HashMap[address, String[120]])\r\nbanksy: public(HashMap[address, bool])  # could be anyone\r\n\r\nevent NewRelease:\r\n    release_id: indexed(uint256)\r\n    template: address\r\n    api_version: String[28]\r\n\r\nevent NewVault:\r\n    token: indexed(address)\r\n    vault_id: indexed(uint256)\r\n    vault: address\r\n    api_version: String[28]\r\n\r\nevent NewExperimentalVault:\r\n    token: indexed(address)\r\n    deployer: indexed(address)\r\n    vault: address\r\n    api_version: String[28]\r\n\r\nevent NewGovernance:\r\n    governance: address\r\n\r\nevent VaultTagged:\r\n    vault: address\r\n    tag: String[120]\r\n\r\n@external\r\ndef __init__():\r\n    self.governance = msg.sender\r\n\r\n\r\n@external\r\ndef setGovernance(governance: address):\r\n    \"\"\"\r\n    @notice Starts the 1st phase of the governance transfer.\r\n    @dev Throws if the caller is not current governance.\r\n    @param governance The next governance address\r\n    \"\"\"\r\n    assert msg.sender == self.governance  # dev: unauthorized\r\n    self.pendingGovernance = governance\r\n\r\n\r\n@external\r\ndef acceptGovernance():\r\n    \"\"\"\r\n    @notice Completes the 2nd phase of the governance transfer.\r\n    @dev\r\n        Throws if the caller is not the pending caller.\r\n        Emits a `NewGovernance` event.\r\n    \"\"\"\r\n    assert msg.sender == self.pendingGovernance  # dev: unauthorized\r\n    self.governance = msg.sender\r\n    log NewGovernance(msg.sender)\r\n\r\n\r\n@view\r\n@external\r\ndef latestRelease() -> String[28]:\r\n    \"\"\"\r\n    @notice Returns the api version of the latest release.\r\n    @dev Throws if no releases are registered yet.\r\n    @return The api version of the latest release.\r\n    \"\"\"\r\n    # NOTE: Throws if there has not been a release yet\r\n    return Vault(self.releases[self.numReleases - 1]).apiVersion()  # dev: no release\r\n\r\n\r\n@view\r\n@external\r\ndef latestVault(token: address) -> address:\r\n    \"\"\"\r\n    @notice Returns the latest deployed vault for the given token.\r\n    @dev Throws if no vaults are endorsed yet for the given token.\r\n    @param token The token address to find the latest vault for.\r\n    @return The address of the latest vault for the given token.\r\n    \"\"\"\r\n    # NOTE: Throws if there has not been a deployed vault yet for this token\r\n    return self.vaults[token][self.numVaults[token] - 1]  # dev: no vault for token\r\n\r\n\r\n@external\r\ndef newRelease(vault: address):\r\n    \"\"\"\r\n    @notice\r\n        Add a previously deployed Vault as the template contract for the latest release,\r\n        to be used by further \"forwarder-style\" delegatecall proxy contracts that can be\r\n        deployed from the registry throw other methods (to save gas).\r\n    @dev\r\n        Throws if caller isn't `self.governance`.\r\n        Throws if `vault`'s governance isn't `self.governance`.\r\n        Throws if the api version is the same as the previous release.\r\n        Emits a `NewVault` event.\r\n    @param vault The vault that will be used as the template contract for the next release.\r\n    \"\"\"\r\n    assert msg.sender == self.governance  # dev: unauthorized\r\n\r\n    # Check if the release is different from the current one\r\n    # NOTE: This doesn't check for strict semver-style linearly increasing release versions\r\n    release_id: uint256 = self.numReleases  # Next id in series\r\n    if release_id > 0:\r\n        assert (\r\n            Vault(self.releases[release_id - 1]).apiVersion()\r\n            != Vault(vault).apiVersion()\r\n        )  # dev: same api version\r\n    # else: we are adding the first release to the Registry!\r\n\r\n    # Update latest release\r\n    self.releases[release_id] = vault\r\n    self.numReleases = release_id + 1\r\n\r\n    # Log the release for external listeners (e.g. Graph)\r\n    log NewRelease(release_id, vault, Vault(vault).apiVersion())\r\n\r\n\r\n@internal\r\ndef _newProxyVault(\r\n    token: address,\r\n    governance: address,\r\n    rewards: address,\r\n    guardian: address,\r\n    name: String[64],\r\n    symbol: String[32],\r\n    releaseTarget: uint256,\r\n) -> address:\r\n    release: address = self.releases[releaseTarget]\r\n    assert release != ZERO_ADDRESS  # dev: unknown release\r\n    vault: address = create_forwarder_to(release)\r\n\r\n    # NOTE: Must initialize the Vault atomically with deploying it\r\n    Vault(vault).initialize(token, governance, rewards, name, symbol, guardian)\r\n\r\n    return vault\r\n\r\n\r\n@internal\r\ndef _registerVault(token: address, vault: address):\r\n    # Check if there is an existing deployment for this token at the particular api version\r\n    # NOTE: This doesn't check for strict semver-style linearly increasing release versions\r\n    vault_id: uint256 = self.numVaults[token]  # Next id in series\r\n    if vault_id > 0:\r\n        assert (\r\n            Vault(self.vaults[token][vault_id - 1]).apiVersion()\r\n            != Vault(vault).apiVersion()\r\n        )  # dev: same api version\r\n    # else: we are adding a new token to the Registry\r\n\r\n    # Update the latest deployment\r\n    self.vaults[token][vault_id] = vault\r\n    self.numVaults[token] = vault_id + 1\r\n\r\n    # Register tokens for endorsed vaults\r\n    if not self.isRegistered[token]:\r\n        self.isRegistered[token] = True\r\n        self.tokens[self.numTokens] = token\r\n        self.numTokens += 1\r\n\r\n    # Log the deployment for external listeners (e.g. Graph)\r\n    log NewVault(token, vault_id, vault, Vault(vault).apiVersion())\r\n\r\n\r\n@external\r\ndef newVault(\r\n    token: address,\r\n    guardian: address,\r\n    rewards: address,\r\n    name: String[64],\r\n    symbol: String[32],\r\n    releaseDelta: uint256 = 0,  # NOTE: Uses latest by default\r\n) -> address:\r\n    \"\"\"\r\n    @notice\r\n        Create a new vault for the given token using the latest release in the registry,\r\n        as a simple \"forwarder-style\" delegatecall proxy to the latest release. Also adds\r\n        the new vault to the list of \"endorsed\" vaults for that token.\r\n    @dev\r\n        `governance` is set in the new vault as `self.governance`, with no ability to override.\r\n        Throws if caller isn't `self.governance`.\r\n        Throws if no releases are registered yet.\r\n        Throws if there already is a registered vault for the given token with the latest api version.\r\n        Emits a `NewVault` event.\r\n    @param token The token that may be deposited into the new Vault.\r\n    @param guardian The address authorized for guardian interactions in the new Vault.\r\n    @param rewards The address to use for collecting rewards in the new Vault\r\n    @param name Specify a custom Vault name. Set to empty string for default choice.\r\n    @param symbol Specify a custom Vault symbol name. Set to empty string for default choice.\r\n    @param releaseDelta Specify the number of releases prior to the latest to use as a target. Default is latest.\r\n    @return The address of the newly-deployed vault\r\n    \"\"\"\r\n    assert msg.sender == self.governance  # dev: unauthorized\r\n\r\n    # NOTE: Underflow if no releases created yet, or targeting prior to release history\r\n    releaseTarget: uint256 = self.numReleases - 1 - releaseDelta  # dev: no releases\r\n    vault: address = self._newProxyVault(token, msg.sender, rewards, guardian, name, symbol, releaseTarget)\r\n\r\n    self._registerVault(token, vault)\r\n\r\n    return vault\r\n\r\n\r\n@external\r\ndef newExperimentalVault(\r\n    token: address,\r\n    governance: address,\r\n    guardian: address,\r\n    rewards: address,\r\n    name: String[64],\r\n    symbol: String[32],\r\n    releaseDelta: uint256 = 0,  # NOTE: Uses latest by default\r\n) -> address:\r\n    \"\"\"\r\n    @notice\r\n        Create a new vault for the given token using the latest release in the registry,\r\n        as a simple \"forwarder-style\" delegatecall proxy to the latest release. Does not add\r\n        the new vault to the list of \"endorsed\" vaults for that token.\r\n    @dev\r\n        Throws if no releases are registered yet.\r\n        Emits a `NewExperimentalVault` event.\r\n    @param token The token that may be deposited into the new Vault.\r\n    @param governance The address authorized for governance interactions in the new Vault.\r\n    @param guardian The address authorized for guardian interactions in the new Vault.\r\n    @param rewards The address to use for collecting rewards in the new Vault\r\n    @param name Specify a custom Vault name. Set to empty string for default choice.\r\n    @param symbol Specify a custom Vault symbol name. Set to empty string for default choice.\r\n    @param releaseDelta Specify the number of releases prior to the latest to use as a target. Default is latest.\r\n    @return The address of the newly-deployed vault\r\n    \"\"\"\r\n    # NOTE: Underflow if no releases created yet, or targeting prior to release history\r\n    releaseTarget: uint256 = self.numReleases - 1 - releaseDelta  # dev: no releases\r\n    # NOTE: Anyone can call this method, as a convenience to Strategist' experiments\r\n    vault: address = self._newProxyVault(token, governance, rewards, guardian, name, symbol, releaseTarget)\r\n\r\n    # NOTE: Not registered, so emit an \"experiment\" event here instead\r\n    log NewExperimentalVault(token, msg.sender, vault, Vault(vault).apiVersion())\r\n\r\n    return vault\r\n\r\n\r\n@external\r\ndef endorseVault(vault: address, releaseDelta: uint256 = 0):\r\n    \"\"\"\r\n    @notice\r\n        Adds an existing vault to the list of \"endorsed\" vaults for that token.\r\n    @dev\r\n        `governance` is set in the new vault as `self.governance`, with no ability to override.\r\n        Throws if caller isn't `self.governance`.\r\n        Throws if `vault`'s governance isn't `self.governance`.\r\n        Throws if no releases are registered yet.\r\n        Throws if `vault`'s api version does not match latest release.\r\n        Throws if there already is a deployment for the vault's token with the latest api version.\r\n        Emits a `NewVault` event.\r\n    @param vault The vault that will be endorsed by the Registry.\r\n    @param releaseDelta Specify the number of releases prior to the latest to use as a target. Default is latest.\r\n    \"\"\"\r\n    assert msg.sender == self.governance  # dev: unauthorized\r\n    assert Vault(vault).governance() == msg.sender  # dev: not governed\r\n\r\n    # NOTE: Underflow if no releases created yet, or targeting prior to release history\r\n    releaseTarget: uint256 = self.numReleases - 1 - releaseDelta  # dev: no releases\r\n    api_version: String[28] = Vault(self.releases[releaseTarget]).apiVersion()\r\n    assert Vault(vault).apiVersion() == api_version  # dev: not target release\r\n\r\n    # Add to the end of the list of vaults for token\r\n    self._registerVault(Vault(vault).token(), vault)\r\n\r\n\r\n@external\r\ndef setBanksy(tagger: address, allowed: bool = True):\r\n    \"\"\"\r\n    @notice Set the ability of a particular tagger to tag current vaults.\r\n    @dev Throws if caller is not `self.governance`.\r\n    @param tagger The address to approve or deny access to tagging.\r\n    @param allowed Whether to approve or deny `tagger`. Defaults to approve.\r\n    \"\"\"\r\n    assert msg.sender == self.governance  # dev: unauthorized\r\n    self.banksy[tagger] = allowed\r\n\r\n\r\n@external\r\ndef tagVault(vault: address, tag: String[120]):\r\n    \"\"\"\r\n    @notice Tag a Vault with a message.\r\n    @dev\r\n        Throws if caller is not `self.governance` or an approved tagger.\r\n        Emits a `VaultTagged` event.\r\n    @param vault The address to tag with the given `tag` message.\r\n    @param tag The message to tag `vault` with.\r\n    \"\"\"\r\n    if msg.sender != self.governance:\r\n        assert self.banksy[msg.sender]  # dev: not banksy\r\n    # else: we are governance, we can do anything banksy can do\r\n\r\n    self.tags[vault] = tag\r\n    log VaultTagged(vault, tag)","ABI":"[{\"name\":\"NewRelease\",\"inputs\":[{\"name\":\"release_id\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"template\",\"type\":\"address\",\"indexed\":false},{\"name\":\"api_version\",\"type\":\"string\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewVault\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\",\"indexed\":true},{\"name\":\"vault_id\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"vault\",\"type\":\"address\",\"indexed\":false},{\"name\":\"api_version\",\"type\":\"string\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewExperimentalVault\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\",\"indexed\":true},{\"name\":\"deployer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"vault\",\"type\":\"address\",\"indexed\":false},{\"name\":\"api_version\",\"type\":\"string\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewGovernance\",\"inputs\":[{\"name\":\"governance\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"VaultTagged\",\"inputs\":[{\"name\":\"vault\",\"type\":\"address\",\"indexed\":false},{\"name\":\"tag\",\"type\":\"string\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setGovernance\",\"inputs\":[{\"name\":\"governance\",\"type\":\"address\"}],\"outputs\":[],\"gas\":36245},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"acceptGovernance\",\"inputs\":[],\"outputs\":[],\"gas\":37517},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"latestRelease\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":6831},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"latestVault\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2587},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"newRelease\",\"inputs\":[{\"name\":\"vault\",\"type\":\"address\"}],\"outputs\":[],\"gas\":82588},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"newVault\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"guardian\",\"type\":\"address\"},{\"name\":\"rewards\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"newVault\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"guardian\",\"type\":\"address\"},{\"name\":\"rewards\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"releaseDelta\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"newExperimentalVault\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"governance\",\"type\":\"address\"},{\"name\":\"guardian\",\"type\":\"address\"},{\"name\":\"rewards\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"newExperimentalVault\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"governance\",\"type\":\"address\"},{\"name\":\"guardian\",\"type\":\"address\"},{\"name\":\"rewards\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"releaseDelta\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"endorseVault\",\"inputs\":[{\"name\":\"vault\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"endorseVault\",\"inputs\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"releaseDelta\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setBanksy\",\"inputs\":[{\"name\":\"tagger\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setBanksy\",\"inputs\":[{\"name\":\"tagger\",\"type\":\"address\"},{\"name\":\"allowed\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"tagVault\",\"inputs\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"tag\",\"type\":\"string\"}],\"outputs\":[],\"gas\":186064},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"numReleases\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":1388},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"releases\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1533},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"numVaults\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":1663},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vaults\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1808},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tokens\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1623},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"numTokens\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":1538},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"isRegistered\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":1783},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"governance\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1598},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pendingGovernance\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1628},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tags\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":10229},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"banksy\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":1903}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.11","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":""}]}