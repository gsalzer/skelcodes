{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FundManager.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\nimport \\\"./Base.sol\\\";\\nimport \\\"./interfaces/IConfig.sol\\\";\\nimport \\\"./interfaces/IFund.sol\\\";\\nimport \\\"./interfaces/IFundManager.sol\\\";\\nimport \\\"./Fund.sol\\\";\\n\\nimport \\\"./libs/TransferHelper.sol\\\";\\n\\ninterface INameRegistry {\\n    function isRegistered(address _owner) external returns (bool);\\n}\\n\\ncontract FundManager is Base {\\n    event FundCreated(address indexed from, address fund, address manager, uint256 _managerInvestAmount);\\n\\n    event FundChanged(address indexed fund);\\n\\n    event ConfigChanged(address indexed from, address config, address newConfig);\\n\\n    event LibChanged(address indexed lib);\\n\\n    address public uniswapV2Router;\\n\\n    address[] public funds; // fund list\\n\\n    address lib;\\n\\n    modifier ready() {\\n        require(lib != address(0), \\\"lib is unset\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _config,\\n        address _router,\\n        address _lib\\n    ) Base(_config) {\\n        require(_router != address(0), \\\"router address = 0\\\");\\n        uniswapV2Router = _router;\\n        require(_lib != address(0), \\\"lib address = 0\\\");\\n        lib = _lib;\\n    }\\n\\n    function allFunds() external view returns (address[] memory) {\\n        return funds;\\n    }\\n\\n    function fundCount() external view returns (uint256) {\\n        return funds.length;\\n    }\\n\\n    function updateLib(address _lib) external onlyCEO() {\\n        require(_lib != address(0), \\\"lib address = 0\\\");\\n        lib = _lib;\\n        emit LibChanged(lib);\\n    }\\n\\n    function invest(address _fund, uint256 _amount) external {\\n        IFund fund = IFund(_fund);\\n        address baseToken = fund.getToken(0);\\n        TransferHelper.safeTransferFrom(baseToken, msg.sender, _fund, _amount);\\n        fund.invest(msg.sender, _amount);\\n    }\\n\\n    function feeTo() external view returns (address) {\\n        return config.feeTo();\\n    }\\n\\n    function createFund(\\n        string memory _title,\\n        uint128 _minSize,\\n        uint256[2] memory _dates, // start date, end date\\n        uint16[4] memory _rates, // hurdle rate, roe, maxDrawdown\\n        uint256 _amountOfManager,\\n        address[] memory _tokens\\n    ) external returns (address) {\\n        string memory symbol = string(abi.encodePacked(\\\"DF_\\\", toString(funds.length)));\\n        require(INameRegistry(config.nameRegistry()).isRegistered(msg.sender), \\\"address not registered\\\");\\n        uint8 decimals = IERC20(_tokens[0]).decimals();\\n        for (uint256 i; i < _tokens.length; i++) {\\n            uint256 minAmount = config.tokenMinFundSize(_tokens[i]);\\n            require(minAmount > 0, \\\"not in whitelist\\\");\\n            if (i == 0) {\\n                require(_minSize >= minAmount, \\\"size < minimal size\\\");\\n            }\\n        }\\n        address fundAddr = clone(lib);\\n        address manager = msg.sender;\\n        TransferHelper.safeTransferFrom(_tokens[0], manager, fundAddr, _amountOfManager);\\n        funds.push(fundAddr);\\n        IFund(fundAddr).initialize(\\n            _title,\\n            symbol,\\n            decimals,\\n            _minSize,\\n            _dates,\\n            _rates,\\n            manager,\\n            _amountOfManager,\\n            _tokens\\n        );\\n        emit FundCreated(msg.sender, fundAddr, msg.sender, _amountOfManager);\\n        config.notify(IConfig.EventType.FUND_CREATED, fundAddr);\\n        return fundAddr;\\n    }\\n\\n    function broadcast() external {\\n        emit FundChanged(msg.sender);\\n    }\\n\\n    function toString(uint256 i) internal pure returns (string memory) {\\n        if (i == 0) return \\\"0\\\";\\n        uint256 j = i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len - 1;\\n        while (i != 0) {\\n            bstr[k] = bytes1(uint8(48 + (i % 10)));\\n            if (k > 0) {\\n                i /= 10;\\n                k--;\\n            } else {\\n                break;\\n            }\\n        }\\n        return string(bstr);\\n    }\\n\\n    function clone(address master) internal returns (address instance) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, master))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Base.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\nimport \\\"./interfaces/IConfig.sol\\\";\\n\\ncontract Base {\\n    event ConfigUpdated(address indexed owner, address indexed config);\\n\\n    IConfig internal config;\\n\\n    modifier onlyCEO() {\\n        require(msg.sender == config.ceo(), \\\"only CEO\\\");\\n        _;\\n    }\\n\\n    constructor(address _configAddr) {\\n        require(_configAddr != address(0), \\\"config address = 0\\\");\\n        config = IConfig(_configAddr);\\n    }\\n\\n    function updateConfig(address _config) external onlyCEO() {\\n        require(_config != address(0), \\\"config address = 0\\\");\\n        require(address(config) != _config, \\\"address identical\\\");\\n        config = IConfig(_config);\\n        emit ConfigUpdated(msg.sender, _config);\\n    }\\n\\n    function configAddress() external view returns (address) {\\n        return address(config);\\n    }\\n\\n    function getConfig() external view returns (IConfig) {\\n        return config;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IConfig.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\ninterface IConfig {\\n    enum EventType {FUND_CREATED, FUND_UPDATED, STAKE_CREATED, STAKE_UPDATED, REG_CREATED, REG_UPDATED, PFUND_CREATED, PFUND_UPDATED}\\n\\n    function ceo() external view returns (address);\\n\\n    function protocolPool() external view returns (address);\\n\\n    function protocolToken() external view returns (address);\\n\\n    function feeTo() external view returns (address);\\n\\n    function nameRegistry() external view returns (address);\\n\\n    //  function investTokenWhitelist() external view returns (address[] memory);\\n\\n    function tokenMinFundSize(address token) external view returns (uint256);\\n\\n    function investFeeRate() external view returns (uint256);\\n\\n    function redeemFeeRate() external view returns (uint256);\\n\\n    function claimFeeRate() external view returns (uint256);\\n\\n    function poolCreationRate() external view returns (uint256);\\n\\n    function slot0() external view returns (uint256);\\n\\n    function slot1() external view returns (uint256);\\n\\n    function slot2() external view returns (uint256);\\n\\n    function slot3() external view returns (uint256);\\n\\n    function slot4() external view returns (uint256);\\n\\n    function notify(EventType _type, address _src) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFund.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\ninterface IFund {\\n    enum Status {Raise, Run, Liquidation, RaiseFailure}\\n\\n    function invest(address owner, uint256 amount) external;\\n\\n    function initialize(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals,\\n        uint128 _minSize,\\n        uint256[2] memory _dates,\\n        uint16[4] memory _rates,\\n        address _manager,\\n        uint256 _amountOfManager,\\n        address[] memory _tokens\\n    ) external;\\n\\n    function tokens() external view returns (address[] memory);\\n\\n    function getToken(uint256) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFundManager.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\nimport \\\"./IConfig.sol\\\";\\n\\ninterface IFundManager {\\n    function feeTo() external view returns (address);\\n\\n    function broadcast() external;\\n\\n    function uniswapV2Router() external view returns (address);\\n\\n    function getConfig() external view returns (IConfig);\\n}\\n\"\r\n    },\r\n    \"contracts/Fund.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\nimport \\\"./libs/TransferHelper.sol\\\";\\n\\nimport \\\"./interfaces/IFundManager.sol\\\";\\nimport \\\"./interfaces/IFund.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Router02.sol\\\";\\n\\n// import \\\"./console.sol\\\";\\n\\ninterface IUniswapV2Factory {\\n    function getPair(address token0, address token1) external view returns (address);\\n\\n    function feeTo() external view returns (address);\\n}\\n\\ninterface IUniswapV2Pair {\\n    function getReserves() external view returns (uint256, uint256);\\n}\\n\\ncontract Fund is IFund, ERC20 {\\n    event StatuChanged(uint256 status);\\n    event Invested(address indexed investor, uint256 amount);\\n    event Liquidated(address indexed liquidator, uint256 netValue);\\n    event Redeemed(address indexed redeemer, uint256 dfAmount);\\n\\n    uint256 public constant UintMax = 2**256 - 1;\\n\\n    uint128 public minSize; // raise size\\n\\n    uint128 public finalNetValue;\\n\\n    uint32 public startDate;\\n\\n    uint32 public endDate;\\n\\n    /**  base 100, percentage */\\n    uint16 public hurdleRate;\\n\\n    uint16 public estimatedROE;\\n\\n    uint16 public performanceFee;\\n\\n    uint16 public maxDrawdown;\\n    // percentage end\\n\\n    Status private fundStatus;\\n\\n    bool locker;\\n\\n    bool initialized;\\n\\n    address public manager;\\n\\n    address public controller; // FundManager address\\n\\n    address[] public override getToken; // tradeable getToken\\n\\n    uint256 public reservePoolDF; // amount of raise token of manager to create Pool\\n\\n    modifier lock() {\\n        require(!locker, \\\"reentrant call\\\");\\n        locker = true;\\n        _;\\n        locker = false;\\n    }\\n\\n    modifier onlyManager() {\\n        require(msg.sender == manager, \\\"only manager\\\");\\n        _;\\n    }\\n\\n    modifier onlyController() {\\n        require(msg.sender == controller, \\\"only controller\\\");\\n        _;\\n    }\\n\\n    modifier nonContract() {\\n        uint256 size;\\n        address account = msg.sender;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        require(size == 0, \\\"CONTRACT_INVOKE\\\");\\n        _;\\n    }\\n\\n    modifier ready() {\\n        require(initialized, \\\"not initialized\\\");\\n        _;\\n    }\\n\\n    modifier inRaise() {\\n        require(fundStatus == Status.Raise && startDate >= block.timestamp, \\\"status != raise\\\");\\n        _;\\n    }\\n\\n    modifier inRun() {\\n        require(fundStatus == Status.Run, \\\"status != run\\\");\\n        _;\\n    }\\n\\n    constructor() {}\\n\\n    function initialize(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals,\\n        uint128 _minSize,\\n        uint256[2] memory _dates,\\n        uint16[4] memory _rates,\\n        address _manager,\\n        uint256 _amountOfManager,\\n        address[] memory _tokens\\n    ) external override lock() {\\n        require(!initialized, \\\"alreday initialized\\\");\\n        super.initialize(_name, _symbol, _decimals);\\n        initialized = true;\\n        controller = msg.sender;\\n        require(_tokens.length > 1, \\\"token length = 1\\\");\\n        IERC20 base = IERC20(_tokens[0]);\\n        require(base.balanceOf(address(this)) == _amountOfManager, \\\"contract's balance != amount\\\");\\n        getToken = _tokens;\\n\\n        require(\\n            _dates[1] > _dates[0] && _dates[1] <= (_dates[0] + 1000 days),\\n            \\\"endDate < startDate or endDate - startDate > 1000 days\\\"\\n        );\\n        require(_dates[0] > block.timestamp, \\\"start date < current time\\\");\\n        startDate = uint32(_dates[0]);\\n        endDate = uint32(_dates[1]);\\n\\n        minSize = _minSize;\\n\\n        require(_amountOfManager >= minSize / 50, \\\"amountOfManager < minSize * 2%\\\");\\n\\n        hurdleRate = _rates[0];\\n        require(hurdleRate >= 110, \\\"hurdleRate < 110\\\");\\n        performanceFee = _rates[1];\\n        require(performanceFee <= 80, \\\"performanceFee > 80\\\");\\n        maxDrawdown = _rates[2];\\n        require(maxDrawdown < 100 && maxDrawdown > 5, \\\"maxDrawdown => 100 or maxDrawdown <= 5\\\");\\n        estimatedROE = _rates[3];\\n\\n        manager = _manager;\\n        IConfig config = IFundManager(controller).getConfig();\\n        require(config.poolCreationRate() > 0, \\\"poolCreationRate==0\\\");\\n        reservePoolDF = (_amountOfManager * config.poolCreationRate()) / 10000;\\n        _mint(manager, _amountOfManager - reservePoolDF);\\n        _mint(address(this), reservePoolDF);\\n    }\\n\\n    function invest(address _owner, uint256 _amount) external override ready() lock() inRaise() onlyController() {\\n        _mint(_owner, _amount);\\n\\n        if (_totalSupply >= minSize) {\\n            minSize = uint128(_totalSupply);\\n            fundStatus = Status.Run;\\n            _createPool();\\n        }\\n        _notify();\\n    }\\n\\n    function redeem() external ready() lock() {\\n        address redeemer = msg.sender;\\n        if (fundStatus == Status.Raise || fundStatus == Status.Run) {\\n            _liquidate(redeemer);\\n        }\\n\\n        uint256 dfBalance = balanceOf(redeemer);\\n        for (uint256 i = 0; i < getToken.length; i++) {\\n            address token = getToken[i];\\n            uint256 total = IERC20(token).balanceOf(address(this));\\n            if (total > 0) {\\n                _redeemToken(token, redeemer, (total * dfBalance) / _totalSupply);\\n            }\\n        }\\n        _burn(redeemer, dfBalance);\\n        _notify();\\n    }\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        uint256 deadline\\n    ) external inRun() ready() nonContract() onlyManager() {\\n        require(deadline >= block.timestamp, \\\"expired\\\");\\n        require(path.length > 1, \\\"path length <= 1\\\");\\n        address last = path[path.length - 1];\\n        require(_inGetToken(last), \\\"not in getToken\\\");\\n        address first = path[0];\\n        address uniswapV2Router = IFundManager(controller).uniswapV2Router();\\n        _checkAndSetMaxAllowanceToUniswap(first, uniswapV2Router);\\n        IUniswapV2Router02(uniswapV2Router).swapExactTokensForTokens(\\n            amountIn,\\n            amountOutMin,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n        _notify();\\n    }\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        uint256 deadline\\n    ) external inRun() ready() nonContract() onlyManager() {\\n        require(deadline >= block.timestamp, \\\"expired\\\");\\n        require(path.length > 1, \\\"path length <= 1\\\");\\n        address last = path[path.length - 1];\\n        require(_inGetToken(last), \\\"not in getToken\\\");\\n        address first = path[0];\\n        address uniswapV2Router = IFundManager(controller).uniswapV2Router();\\n        _checkAndSetMaxAllowanceToUniswap(first, uniswapV2Router);\\n        IUniswapV2Router02(uniswapV2Router).swapTokensForExactTokens(\\n            amountOut,\\n            amountInMax,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n        _notify();\\n    }\\n\\n    function status() external view returns (Status) {\\n        if (fundStatus == Status.Raise && _isRaiseFailure()) return Status.RaiseFailure;\\n        if (fundStatus == Status.Run && block.timestamp >= endDate) return Status.Liquidation;\\n        return fundStatus;\\n    }\\n\\n    function tokens() external view override returns (address[] memory) {\\n        return getToken;\\n    }\\n\\n    function netValue() external view returns (uint256) {\\n        return _netValue();\\n    }\\n\\n    function _inGetToken(address _token) internal view returns (bool) {\\n        for (uint256 i; i < getToken.length; i++) {\\n            if (_token == getToken[i]) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function _isRaiseFailure() private view returns (bool) {\\n        return\\n            fundStatus == Status.RaiseFailure ||\\n            (fundStatus == Status.Raise && block.timestamp > startDate && _totalSupply < minSize);\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override {\\n        require(fundStatus != Status.Raise || from == address(0), \\\"not allow transfering in raise\\\");\\n        require(from != manager || to == address(0), \\\"not allow manager transfering\\\");\\n    }\\n\\n    function _createPool() private {\\n        uint256 liquidity = balanceOf(address(this));\\n        address uniswapV2Router = IFundManager(controller).uniswapV2Router();\\n        address base = getToken[0];\\n        TransferHelper.safeApprove(base, uniswapV2Router, UintMax);\\n        TransferHelper.safeApprove(address(this), uniswapV2Router, UintMax);\\n        IUniswapV2Router02 router = IUniswapV2Router02(uniswapV2Router);\\n\\n        router.addLiquidity(address(this), base, liquidity, liquidity, 0, 0, manager, block.timestamp);\\n    }\\n\\n    function _notify() private {\\n        IFundManager(controller).getConfig().notify(IConfig.EventType.FUND_UPDATED, address(this));\\n    }\\n\\n    function _netValue() private view returns (uint256) {\\n        // console.log(\\\"!status\\\", uint256(fundStatus));\\n        if (fundStatus == Status.Raise || fundStatus == Status.RaiseFailure) {\\n            return _totalSupply;\\n        }\\n\\n        if (fundStatus == Status.Liquidation) {\\n            return finalNetValue;\\n        }\\n        address baseAsset = getToken[0];\\n        uint256 amount = IERC20(baseAsset).balanceOf(address(this));\\n        IUniswapV2Router02 router = IUniswapV2Router02(IFundManager(controller).uniswapV2Router());\\n        for (uint256 i = 1; i < getToken.length; i++) {\\n            uint256 balance = IERC20(getToken[i]).balanceOf(address(this));\\n            if (balance > 0) {\\n                address token = getToken[i];\\n                address pair = IUniswapV2Factory(router.factory()).getPair(baseAsset, token);\\n                if (pair == address(0)) {\\n                    continue;\\n                }\\n                (uint256 baseAssetReserve, uint256 tokenReserve) = _getReserves(pair, baseAsset, token);\\n                amount += _quote(balance, tokenReserve, baseAssetReserve);\\n                // uint256[] memory amounts = router.getAmountsOut(balance, paths);\\n                // console.log(\\\"swap out 0\\\", amounts[0]);\\n                // console.log(\\\"swap out 1\\\", amounts[1]);\\n                // console.log(\\\"amounts length\\\", amounts.length);\\n                // if (amounts.length == 2) {\\n                //     amount += amounts[1];\\n                // }\\n            }\\n        }\\n\\n        return amount;\\n    }\\n\\n    function _getReserves(\\n        address _pair,\\n        address _tokenA,\\n        address _tokenB\\n    ) private view returns (uint256 reserveA, uint256 reserveB) {\\n        address token0 = _tokenA < _tokenB ? _tokenA : _tokenB;\\n        (uint256 reserve0, uint256 reserve1) = IUniswapV2Pair(_pair).getReserves();\\n        return token0 == _tokenA ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    function _quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) internal pure returns (uint256 amountB) {\\n        require(amountA > 0, \\\"UniswapV2Library: INSUFFICIENT_AMOUNT\\\");\\n        require(reserveA > 0 && reserveB > 0, \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\");\\n        amountB = (amountA * reserveB) / reserveA;\\n    }\\n\\n    function _liquidate(address _liquidator) private {\\n        require(balanceOf(_liquidator) > 0, \\\"balance == 0, not investor\\\");\\n        uint256 value = _netValue();\\n        finalNetValue = uint128(value);\\n        uint256 maxDrawdownValue = (_totalSupply * maxDrawdown) / 100;\\n        // console.log(\\\"liquidator\\\", _liquidator);\\n        // console.log(\\\"    status\\\", uint256(fundStatus));\\n        // console.log(\\\"   manager\\\", manager);\\n        // console.log(\\\"  netValue\\\", value);\\n        // console.log(\\\" drawValue\\\", maxDrawdownValue);\\n        require(\\n            block.timestamp > endDate ||\\n                _isRaiseFailure() ||\\n                (fundStatus == Status.Run && (_liquidator == manager || value <= maxDrawdownValue)),\\n            \\\"now <= end date or status != failure or liquidator != manager or netValue >= maxDrawdownValue\\\"\\n        );\\n\\n        uint256 total = balanceOf(address(this));\\n        if (total > 0) {\\n            // return fund of creating pool to manager\\n            fundStatus = Status.RaiseFailure;\\n            _transfer(address(this), manager, total);\\n            return;\\n        }\\n        fundStatus = Status.Liquidation;\\n        _distributeHurdleReward();\\n    }\\n\\n    function _distributeHurdleReward() private {\\n        address base = getToken[0];\\n        uint256 value = IERC20(base).balanceOf(address(this));\\n        uint256 hurdleLine = (minSize * hurdleRate) / 100;\\n        if (value > hurdleLine) {\\n            uint256 reward = ((value - hurdleLine) * performanceFee) / 100;\\n            _redeemToken(base, manager, reward);\\n        }\\n    }\\n\\n    function _redeemToken(\\n        address _token,\\n        address _redeemer,\\n        uint256 _amountOfRedeemer\\n    ) private {\\n        IConfig config = IFundManager(controller).getConfig();\\n        uint256 out =\\n            fundStatus == Status.Liquidation\\n                ? (_amountOfRedeemer * (10000 - config.redeemFeeRate())) / 10000\\n                : _amountOfRedeemer;\\n\\n        uint256 fee = _amountOfRedeemer - out;\\n        // console.log(\\\"amount\\\", _amountOfRedeemer);\\n        // console.log(\\\"   out\\\", out);\\n        // console.log(\\\"   fee\\\", fee);\\n        if (out > 0) {\\n            TransferHelper.safeTransfer(_token, _redeemer, out);\\n        }\\n        if (fee > 0) {\\n            TransferHelper.safeTransfer(_token, config.feeTo(), fee);\\n        }\\n    }\\n\\n    function _checkAndSetMaxAllowanceToUniswap(address _token, address _router) private {\\n        IERC20 token = IERC20(_token);\\n        uint256 uniAllowance = token.allowance(address(this), _router);\\n        if (uniAllowance <= UintMax) {\\n            token.approve(_router, UintMax);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/TransferHelper.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper: APPROVE_FAILED'\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper: TRANSFER_FAILED'\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper: TRANSFER_FROM_FAILED'\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./libs/SafeMath.sol\\\";\\n\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 internal _totalSupply;\\n\\n    string public override name;\\n    string public override symbol;\\n    uint8 public override decimals;\\n\\n    function initialize(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimal\\n    ) internal {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimal;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()].sub(\\n                amount,\\n                \\\"ERC20: transfer amount exceeds allowance\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].add(addedValue)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].sub(\\n                subtractedValue,\\n                \\\"ERC20: decreased allowance below zero\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\n        );\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(\\n            amount,\\n            \\\"ERC20: burn amount exceeds balance\\\"\\n        );\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    function _msgSender() private view returns (address) {\\n        return msg.sender;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router02 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.0 <=0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, 'SafeMath: addition overflow');\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, 'SafeMath: subtraction overflow');\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, 'SafeMath: division by zero');\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, 'SafeMath: modulo by zero');\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_config\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lib\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"config\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newConfig\",\"type\":\"address\"}],\"name\":\"ConfigChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"config\",\"type\":\"address\"}],\"name\":\"ConfigUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fund\",\"type\":\"address\"}],\"name\":\"FundChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fund\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_managerInvestAmount\",\"type\":\"uint256\"}],\"name\":\"FundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lib\",\"type\":\"address\"}],\"name\":\"LibChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allFunds\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"broadcast\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_title\",\"type\":\"string\"},{\"internalType\":\"uint128\",\"name\":\"_minSize\",\"type\":\"uint128\"},{\"internalType\":\"uint256[2]\",\"name\":\"_dates\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint16[4]\",\"name\":\"_rates\",\"type\":\"uint16[4]\"},{\"internalType\":\"uint256\",\"name\":\"_amountOfManager\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"createFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"funds\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"contract IConfig\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fund\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_config\",\"type\":\"address\"}],\"name\":\"updateConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lib\",\"type\":\"address\"}],\"name\":\"updateLib\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"FundManager","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"000000000000000000000000a2d0b2148c84c71e873bcdc45dfed041822cfbb90000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000008db8f83809c1a32616a4c7a5507253cf13324927","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}