{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.1;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract TokenVesting {\r\n\r\n  event TrancheCreated(uint8 indexed tranche_id, uint256 cliff_start, uint256 duration);\r\n  event TrancheBalanceAdded(address indexed user, uint8 indexed tranche_id, uint256 amount);\r\n  event TrancheBalanceRemoved(address indexed user, uint8 indexed tranche_id, uint256 amount);\r\n  event StakeDeposited(address indexed user, uint256 amount, bytes32 vega_public_key);\r\n  event StakeRemoved(address indexed user, uint256 amount);\r\n  event IssuerPermitted(address indexed issuer, uint256 amount);\r\n  event IssuerRevoked(address indexed issuer);\r\n  event ControllerSet(address indexed new_controller);\r\n\r\n  /// @notice controller is similar to \"owner\" in other contracts\r\n  address public controller;\r\n  /// @notice tranche_count starts at 1 to cause tranche 0 (perma-lock) to exist as the default tranche\r\n  uint8 public tranche_count = 1;\r\n  /// @notice user => has been migrated\r\n  mapping(address => bool) public v1_migrated;\r\n  /// @notice user => user_stat struct\r\n  mapping(address=> user_stat) public user_stats;\r\n  /// @notice total_locked is the total amount of tokens \"on\" this contract that are locked into a tranche\r\n  uint256 public total_locked;\r\n  /// @notice v1_address is the address for Vega's v1 ERC20 token that has already been deployed\r\n  address public v1_address; // mainnet = 0xD249B16f61cB9489Fe0Bb046119A48025545b58a;\r\n  /// @notice v2_address is the address for Vega's v2 ERC20 token that replaces v1\r\n  address public v2_address;\r\n  /// @notice accuracy_scale is the multiplier to assist in integer division\r\n  uint256 constant public accuracy_scale = 100000000000;\r\n  /// @notice default_tranche_id is the tranche_id for the default tranche\r\n  uint8 constant public default_tranche_id = 0;\r\n\r\n  /****ADDRESS MIGRATION**/\r\n  /// @notice new address => old address\r\n  mapping(address => address) public address_migration;\r\n  /*****/\r\n\r\n  /// @param token_v1_address Vega's already deployed v1 ERC20 token address\r\n  /// @param token_v2_address Vega's v2 ERC20 token and the token being vested here\r\n  /// @dev emits Controller_Set event\r\n  constructor(address token_v1_address, address token_v2_address, address[] memory old_addresses, address[] memory new_addresses) {\r\n    require(old_addresses.length == new_addresses.length, \"array length mismatch\");\r\n\r\n    for(uint8 map_idx = 0; map_idx < old_addresses.length; map_idx++) {\r\n      v1_migrated[old_addresses[map_idx]] = true;\r\n      address_migration[new_addresses[map_idx]] = old_addresses[map_idx];\r\n    }\r\n\r\n    v1_address = token_v1_address;\r\n    /// @notice this initializes the total_locked with the amount of already issued v1 VEGA ERC20 tokens\r\n    total_locked = IERC20(token_v1_address).totalSupply() - IERC20(token_v1_address).balanceOf(token_v1_address);\r\n    v2_address = token_v2_address;\r\n    controller = msg.sender;\r\n    emit ControllerSet(controller);\r\n  }\r\n\r\n  /// @notice tranche_balance has the params necessary to track what a user is owed in a single tranche\r\n  /// @param total_deposited is the total number of tokens deposited into this single tranche for a single user\r\n  /// @param total_claimed is the total number of tokens in this tranche that have been withdrawn\r\n  struct tranche_balance {\r\n      uint256 total_deposited;\r\n      uint256 total_claimed;\r\n  }\r\n\r\n  /// @notice user_stat is a struct that holds all the details needed to handle a single user's vesting\r\n  /// @param total_in_all_tranches is the total number of tokens currently in all tranches that have been migrated to v2\r\n  /// @param lien total amount of locked tokens that have been marked for staking\r\n  /// @param tranche_balances is a mapping of tranche_id => tranche_balance\r\n  struct user_stat {\r\n    uint256 total_in_all_tranches;\r\n    uint256 lien;\r\n    mapping (uint8 => tranche_balance) tranche_balances;\r\n  }\r\n\r\n  /// @notice tranche is a struct that hold the details needed for calculating individual tranche vesting\r\n  /// @param cliff_start is a timestamp after which vesting starts\r\n  /// @param duration is the number of seconds after cliff_start until the tranche is 100% vested\r\n  struct tranche {\r\n    uint256 cliff_start;\r\n    uint256 duration;\r\n  }\r\n\r\n  /// @notice tranche_id => tranche struct\r\n  mapping(uint8 => tranche) public tranches;\r\n  /// @notice issuer address => permitted issuance allowance\r\n  mapping(address => uint256) public permitted_issuance;\r\n\r\n  /// @notice this function allows the contract controller to create a tranche\r\n  /// @notice tranche zero is perma-locked and already exists prior to running this function, making the first vesting tranche \"tranche:1\"\r\n  /// @param cliff_start is a timestamp in seconds of when vesting begins for this tranche\r\n  /// @param duration is the number of seconds after cliff_start that the tranche will be fully vested\r\n  function create_tranche(uint256 cliff_start, uint256 duration) public only_controller {\r\n    tranches[tranche_count] = tranche(cliff_start, duration);\r\n    emit TrancheCreated(tranche_count, cliff_start, duration);\r\n    /// @notice sol ^0.8 comes with auto-overflow protection\r\n    tranche_count++;\r\n  }\r\n\r\n  /// @notice this function allows the conroller or permitted issuer to issue tokens from this contract itself (no tranches) into the specified tranche\r\n  /// @notice tranche MUST be created\r\n  /// @notice once assigned to a tranche, tokens can never be clawed back, but they can be reassigned IFF they are in tranche_id:0\r\n  /// @param user The user being issued the tokens\r\n  /// @param tranche_id the id of the target tranche\r\n  /// @param amount number of tokens to be issued into tranche\r\n  /// @dev emits Tranche_Balance_Added event\r\n  function issue_into_tranche(address user, uint8 tranche_id, uint256 amount) public controller_or_issuer {\r\n    require(tranche_id < tranche_count, \"tranche_id out of bounds\");\r\n    if(permitted_issuance[msg.sender] > 0){\r\n      /// @dev if code gets here, they are an issuer if not they must be the controller\r\n      require(permitted_issuance[msg.sender] >= amount, \"not enough permitted balance\");\r\n      require(user != msg.sender, \"cannot issue to self\");\r\n      permitted_issuance[msg.sender] -= amount;\r\n    }\r\n    require( IERC20(v2_address).balanceOf(address(this)) - (total_locked + amount) >= 0, \"contract token balance low\" );\r\n\r\n    /// @dev only runs once\r\n    if(!v1_migrated[user]){\r\n      uint256 bal = v1_bal(user);\r\n      user_stats[user].tranche_balances[0].total_deposited += bal;\r\n      user_stats[user].total_in_all_tranches += bal;\r\n      v1_migrated[user] = true;\r\n    }\r\n    user_stats[user].tranche_balances[tranche_id].total_deposited += amount;\r\n    user_stats[user].total_in_all_tranches += amount;\r\n    total_locked += amount;\r\n    emit TrancheBalanceAdded(user, tranche_id, amount);\r\n  }\r\n\r\n\r\n  /// @notice this function allows the controller to move tokens issued into tranche zero to the target tranche\r\n  /// @notice can only be moved from tranche 0\r\n  /// @param user The user being issued the tokens\r\n  /// @param tranche_id the id of the target tranche\r\n  /// @param amount number of tokens to be moved from tranche 0\r\n  /// @dev emits Tranche_Balance_Removed event\r\n  /// @dev emits Tranche_Balance_Added event\r\n  function move_into_tranche(address user, uint8 tranche_id, uint256 amount) public only_controller {\r\n    require(tranche_id > 0 && tranche_id < tranche_count);\r\n\r\n    /// @dev only runs once\r\n    if(!v1_migrated[user]){\r\n      uint256 bal = v1_bal(user);\r\n      user_stats[user].tranche_balances[default_tranche_id].total_deposited += bal;\r\n      user_stats[user].total_in_all_tranches += bal;\r\n      v1_migrated[user] = true;\r\n    }\r\n    require(user_stats[user].tranche_balances[default_tranche_id].total_deposited >= amount);\r\n    user_stats[user].tranche_balances[default_tranche_id].total_deposited -= amount;\r\n    user_stats[user].tranche_balances[tranche_id].total_deposited += amount;\r\n    emit TrancheBalanceRemoved(user, default_tranche_id, amount);\r\n    emit TrancheBalanceAdded(user, tranche_id, amount);\r\n  }\r\n\r\n  /// @notice this view returns the balance of the given tranche for the given user\r\n  /// @notice tranche 0 balance of a non-v1_migrated user will return user's v1 token balance as they are pre-issued to the current hodlers\r\n  /// @param user Target user address\r\n  /// @param tranche_id target tranche\r\n  /// @return balance of target tranche of user\r\n  function get_tranche_balance(address user, uint8 tranche_id) public view returns(uint256) {\r\n    if(tranche_id == default_tranche_id && !v1_migrated[user]){\r\n      return v1_bal(user);\r\n    } else {\r\n      return user_stats[user].tranche_balances[tranche_id].total_deposited - user_stats[user].tranche_balances[tranche_id].total_claimed;\r\n    }\r\n  }\r\n\r\n  /// @notice This view returns the amount that is currently vested in a given tranche\r\n  /// @notice This does NOT take into account any current lien\r\n  /// @param user Target user address\r\n  /// @param tranche_id Target tranche\r\n  /// @return number of tokens vested in the target tranche for the target user\r\n  function get_vested_for_tranche(address user, uint8 tranche_id) public view returns(uint256) {\r\n    if(block.timestamp < tranches[tranche_id].cliff_start){\r\n      return 0;\r\n    }\r\n    else if(block.timestamp > tranches[tranche_id].cliff_start + tranches[tranche_id].duration || tranches[tranche_id].duration == 0){\r\n      return user_stats[user].tranche_balances[tranche_id].total_deposited -  user_stats[user].tranche_balances[tranche_id].total_claimed;\r\n    } else {\r\n      return (((( accuracy_scale * (block.timestamp - tranches[tranche_id].cliff_start) )  / tranches[tranche_id].duration\r\n          ) * user_stats[user].tranche_balances[tranche_id].total_deposited\r\n        ) / accuracy_scale ) - user_stats[user].tranche_balances[tranche_id].total_claimed;\r\n    }\r\n  }\r\n\r\n  /// @notice This view returns the balance remaining in Vega V1 for a given user\r\n  /// @notice Once migrated, the balance will always return zero, hence \"remaining\"\r\n  /// @param user Target user\r\n  /// @return remaining v1 balance\r\n  function v1_bal(address user) internal view returns(uint256) {\r\n    if(!v1_migrated[user]){\r\n      if(address_migration[user] != address(0)){\r\n        return IERC20(v1_address).balanceOf(user) + IERC20(v1_address).balanceOf(address_migration[user]);\r\n      } else {\r\n        return IERC20(v1_address).balanceOf(user);\r\n      }\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /// @notice This view returns the current amount of tokens locked in all tranches\r\n  /// @notice This includes remaining v1 balance\r\n  /// @param user Target user\r\n  /// @return the current amount of tokens for target user in all tranches\r\n  function user_total_all_tranches(address user) public view returns(uint256){\r\n    return user_stats[user].total_in_all_tranches + v1_bal(user);\r\n  }\r\n\r\n  /// @notice This function withdraws all the currently available vested tokens from the target tranche\r\n  /// @notice This will not allow a user's total tranch balance to go below the user's lien amount\r\n  /// @dev Emits Tranche_Balance_Removed event if successful\r\n  /// @param tranche_id Id of target tranche\r\n  function withdraw_from_tranche(uint8 tranche_id) public {\r\n    require(tranche_id != default_tranche_id);\r\n    uint256 to_withdraw = get_vested_for_tranche(msg.sender, tranche_id);\r\n    require(user_stats[msg.sender].total_in_all_tranches - to_withdraw >=  user_stats[msg.sender].lien);\r\n    user_stats[msg.sender].tranche_balances[tranche_id].total_claimed += to_withdraw;\r\n    user_stats[msg.sender].total_in_all_tranches -= to_withdraw;\r\n    total_locked -= to_withdraw;\r\n    require(IERC20(v2_address).transfer(msg.sender, to_withdraw));\r\n    emit TrancheBalanceRemoved(msg.sender, tranche_id, to_withdraw);\r\n  }\r\n\r\n  /// @notice This function will put a lien on the user who runs this function\r\n  /// @dev Emits Stake_Deposited event if successful\r\n  /// @param amount Amount of tokens to stake\r\n  /// @param vega_public_key Target Vega public key to be credited with the stake lock\r\n  function stake_tokens(uint256 amount, bytes32 vega_public_key) public {\r\n    require(user_stats[msg.sender].lien + amount > user_stats[msg.sender].lien);\r\n    require(user_total_all_tranches(msg.sender) >= user_stats[msg.sender].lien + amount);\r\n    //user applies this to themselves which only multisig control can remove\r\n    user_stats[msg.sender].lien += amount;\r\n    emit StakeDeposited(msg.sender, amount, vega_public_key);\r\n  }\r\n\r\n  /// @notice This function will remove the lien from the user who runs this function\r\n  /// @notice clears \"amount\" of lien\r\n  /// @dev emits Stake_Removed event if successful\r\n  /// @param amount Amount of tokens to remove from Staking\r\n  function remove_stake(uint256 amount) public {\r\n    /// @dev TODO add multisigControl IFF needed\r\n\r\n    /// @dev Solidity ^0.8 has overflow protection, if this next line overflows, the transaction will revert\r\n    user_stats[msg.sender].lien -= amount;\r\n    emit StakeRemoved(msg.sender, amount);\r\n  }\r\n\r\n  /// @notice This function allows the controller to permit the given address to issue the given Amount\r\n  /// @notice Target users MUST have a zero (0) permitted issuance balance (try revoke_issuer)\r\n  /// @dev emits Issuer_Permitted event\r\n  /// @param issuer Target address to be allowed to issue given amount\r\n  /// @param amount Number of tokens issuer is permitted to issue\r\n  function permit_issuer(address issuer, uint256 amount) public only_controller {\r\n    /// @notice revoke is required first to stop a simple double allowance attack\r\n    require(amount > 0, \"amount must be > 0\");\r\n    require(permitted_issuance[issuer] == 0, \"issuer already permitted, revoke first\");\r\n    require(controller != issuer, \"controller cannot be permitted issuer\");\r\n    permitted_issuance[issuer] = amount;\r\n    emit IssuerPermitted(issuer, amount);\r\n  }\r\n\r\n  /// @notice This function allows the controller to revoke issuance permission from given target\r\n  /// @notice permitted_issuance must be greater than zero (0)\r\n  /// @dev emits Issuer_Revoked event\r\n  /// @param issuer Target address of issuer to be revoked\r\n  function revoke_issuer(address issuer) public only_controller {\r\n    require(permitted_issuance[issuer] != 0, \"issuer already revoked\");\r\n    permitted_issuance[issuer] = 0;\r\n    emit IssuerRevoked(issuer);\r\n  }\r\n\r\n  /// @notice This function allows the controller to assign a new controller\r\n  /// @dev Emits Controller_Set event\r\n  /// @param new_controller Address of the new controller\r\n  function set_controller(address new_controller) public only_controller {\r\n    controller = new_controller;\r\n    if(permitted_issuance[new_controller] > 0){\r\n      permitted_issuance[new_controller] = 0;\r\n      emit IssuerRevoked(new_controller);\r\n    }\r\n    emit ControllerSet(new_controller);\r\n  }\r\n\r\n  /// @notice this modifier requires that msg.sender is the controller of this contract\r\n  modifier only_controller {\r\n         require( msg.sender == controller, \"not controller\" );\r\n         _;\r\n  }\r\n\r\n  /// @notice this modifier requires that msg.sender is the controller of this contract or has a permitted issuance remaining of more than zero (0)\r\n  modifier controller_or_issuer {\r\n         require( msg.sender == controller || permitted_issuance[msg.sender] > 0,\"not controller or issuer\" );\r\n         _;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_v1_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_v2_address\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"old_addresses\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"new_addresses\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"new_controller\",\"type\":\"address\"}],\"name\":\"ControllerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"IssuerPermitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"}],\"name\":\"IssuerRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"vega_public_key\",\"type\":\"bytes32\"}],\"name\":\"StakeDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TrancheBalanceAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TrancheBalanceRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cliff_start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"TrancheCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accuracy_scale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"address_migration\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cliff_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"create_tranche\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"default_tranche_id\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"}],\"name\":\"get_tranche_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"}],\"name\":\"get_vested_for_tranche\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"issue_into_tranche\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"move_into_tranche\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"permit_issuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"permitted_issuance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"remove_stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"}],\"name\":\"revoke_issuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_controller\",\"type\":\"address\"}],\"name\":\"set_controller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"vega_public_key\",\"type\":\"bytes32\"}],\"name\":\"stake_tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_locked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tranche_count\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"tranches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cliff_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user_stats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total_in_all_tranches\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lien\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"user_total_all_tranches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"v1_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"v1_migrated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"v2_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"}],\"name\":\"withdraw_from_tranche\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenVesting","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d249b16f61cb9489fe0bb046119a48025545b58a000000000000000000000000814a6bd368f5f2416330a3450b174373a73339b8000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000f5688c0b8e7f1c101917f1f1d13513e00473b3a20000000000000000000000000000000000000000000000000000000000000001000000000000000000000000dbe53786812bdcbf3ce340e244f11a49b6aa57af","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fb6a82ecafc621b1332097832ba330f5d91e0dc368b16cea56516ff9b76208d4"}]}