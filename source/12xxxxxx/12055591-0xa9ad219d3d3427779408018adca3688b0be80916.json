{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n      *\r\n      * Requirements:\r\n      *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n      * - `tokenId` token must exist and be owned by `from`.\r\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n      *\r\n      * Emits a {Transfer} event.\r\n      */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\ninterface IGoaldToken is IERC20 {\r\n    /** Gets the base url for Goald metadata. */\r\n    function getBaseTokenURI() external view returns (string memory);\r\n\r\n    /** Gets the total number of deployed Goalds. */\r\n    function getGoaldCount() external view returns (uint256);\r\n\r\n    /** Returns the current stage of the DAO's governance. */\r\n    function getGovernanceStage() external view returns (uint256);\r\n\r\n    /** Gets the current DAO address. */\r\n    function getLatestDAO() external view returns (address);\r\n\r\n    /** Called by the latest DAO when a new Goald has been deployed. */\r\n    function goaldDeployed(address recipient, address goaldAddress) external returns (uint256);\r\n}\r\n\r\n/** Tracks all DAO functionality for the Goald token. Each version of the DAO manages its own balances and rewards. */\r\ncontract GoaldDAO {\r\n    /** @dev The number of decimals is small to allow for rewards of tokens with substantially different exchange rates. */\r\n    uint8 private constant DECIMALS = 2;\r\n\r\n    /** \r\n     * @dev The minimum amount of tokens necessary to be eligible for a reward. This is \"one token\", considering decimal places. We\r\n     * are choosing two decimal places because we are initially targeting WBTC, which has 8. This way we can do a minimum reward ratio\r\n     * of 1 / 1,000,000 of a WBTC, relative to our token. So at $25,000 (2020 value), the minimum reward would be $250 (assuming we\r\n     * have issued all 10,000 tokens).\r\n     */\r\n    uint256 private constant REWARD_THRESHOLD = 10**uint256(DECIMALS);\r\n\r\n    /** @dev The current owner of the proxy. This will become the Goald token (as delgated DAO manager) when the DAO is initiated. */\r\n    address public  _owner;\r\n\r\n    /** @dev Which Uniswap router we're currently using for trades. */\r\n    address private _uniswapRouterAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n\r\n    /** @dev The address of the Goald token. Set in constructer and should never have to be changed. */\r\n    address public  _goaldToken = 0x5Cd9207c3A81FB7A73c9D71CDd413B85b4a7D045;\r\n\r\n\r\n    /** @dev Which deployers are allowed to create new Goalds. We use a mapping for O(1) lookups and an array for complete list. */\r\n    mapping (address => bool) private _allowedDeployersMap;\r\n    address[] private _allowedDeployersList;\r\n\r\n    /** @dev The addresses of all deployed goalds. */\r\n    address[] private _deployedGoalds;\r\n\r\n    /** @dev The owner of each deployed goald. */\r\n    address[] private _goaldOwners;\r\n\r\n    /** @dev The id offset to account for Goalds deployed in previous versions of the DAO. */\r\n    uint256   private _idOffset;\r\n\r\n\r\n    /** @dev Which ERC20 contract will be used for rewards (e.g., WBTC). */\r\n    address   private _rewardToken = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599; // WBTC\r\n\r\n    /** @dev How many holders are eligible for rewards. This is used to determine how much should be reserved. */\r\n    uint256   private _rewardHolders;\r\n\r\n    /** @dev How much of the current balance is reserved for rewards. */\r\n    uint256   private _reservedRewardBalance;\r\n\r\n    /** @dev How many holders have yet to withdraw a given reward. */\r\n    uint256[] private _rewardHolderCounts;\r\n\r\n    /** @dev The multipliers for each reward. */\r\n    uint256[] private _rewardMultipliers;\r\n\r\n    /** @dev The remaining reserves for a given reward. */\r\n    uint256[] private _rewardReserves;\r\n\r\n    /** @dev The minimum reward index to check eligibility against for a given address. */\r\n    mapping (address => uint256) private _minimumRewardIndex;\r\n    \r\n    /** @dev The available reward balance for a given address. */\r\n    mapping (address => uint256) private _rewardBalance;\r\n\r\n    /**\r\n     * @dev The stage of the governance token. Tokens can be issued based on deployments regardless of what stage we are in. Identical\r\n     * to `GoaldToken.governanceStage`. Cannot be set directly.\r\n     *\r\n     * Statuses:\r\n     *      0: Created, with no governance protocol initiated. The initial governance issuance can be claimed.\r\n     *      1: Initial governance issuance has been claimed.\r\n     *      2: The governance protocal has been initiated.\r\n     *      3: All governance tokens have been issued.\r\n     */\r\n    uint256 private constant STAGE_INITIAL               = 0;\r\n    uint256 private constant STAGE_ISSUANCE_CLAIMED      = 1;\r\n    uint256 private constant STAGE_DAO_INITIATED         = 2;\r\n    uint256 private constant STAGE_ALL_GOVERNANCE_ISSUED = 3;\r\n    uint256 private _governanceStage;\r\n\r\n    // Reentrancy reversions are the only calls to revert (in this contract) that do not have reasons. We add a third state, 'frozen'\r\n    // to allow for locking non-admin functions. The contract may be permanently frozen if it has been upgraded.\r\n    uint256 private constant RE_NOT_ENTERED = 1;\r\n    uint256 private constant RE_ENTERED     = 2;\r\n    uint256 private constant RE_FROZEN      = 3;\r\n    uint256 private _status;\r\n\r\n    // Set when the DAO is ready to deploy things.\r\n    uint256 private constant NOT_READY = 0;\r\n    uint256 private constant READY = 1;\r\n    uint256 private _ready;\r\n\r\n    constructor() public {\r\n        _owner = msg.sender;\r\n\r\n        _status = RE_NOT_ENTERED;\r\n    }\r\n\r\n    /// Events ///\r\n\r\n    event RewardCreated(uint256 multiplier, string reason);\r\n\r\n    /// Admin Functions ///\r\n\r\n    /** Adds more allowed deployers. */\r\n    function addAllowedDeployers(address[] calldata newDeployers) external {\r\n        // Reentrancy guard.\r\n        require(_status == RE_NOT_ENTERED || _status == RE_FROZEN);\r\n        require(msg.sender == _owner, \"Not owner\");\r\n\r\n        uint256 count = newDeployers.length;\r\n        uint256 index;\r\n        address newDeployer;\r\n        for (; index < count; index++) {\r\n            newDeployer = newDeployers[index];\r\n\r\n            // Don't revert if it already exists.\r\n            if (!_allowedDeployersMap[newDeployer]) {\r\n                // Add the deployer.\r\n                _allowedDeployersMap[newDeployer] = true;\r\n                _allowedDeployersList.push(newDeployer);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Freezes the proxy contract. Only admin functions can be called. */\r\n    function freeze() external {\r\n        // Reentrancy guard.\r\n        require(\r\n               _status == RE_NOT_ENTERED\r\n            && msg.sender == _owner\r\n        );\r\n\r\n        _status = RE_FROZEN;\r\n    }\r\n\r\n    /** Called if the DAO manager is no longer a holder after burning the initialization tokens. */\r\n    function initializeDecreasesHolders() external {\r\n        // Reentrancy guard. Caller must be goald token. Must be non-initialized.\r\n        require(\r\n               _status == RE_NOT_ENTERED\r\n            && msg.sender == _goaldToken\r\n            && _governanceStage == STAGE_ISSUANCE_CLAIMED\r\n        );\r\n\r\n        _rewardHolders --;\r\n    }\r\n\r\n    /** Called if the DAO manager is now a holder after claiming the initialization tokens. */\r\n    function issuanceIncreasesHolders() external {\r\n        // Reentrancy guard. Caller must be goald token. Issuance can't be claimed.\r\n        require(\r\n               _status == RE_NOT_ENTERED\r\n            && msg.sender == _goaldToken\r\n            && _governanceStage == STAGE_INITIAL\r\n        );\r\n\r\n        _rewardHolders ++;\r\n    }\r\n\r\n    /** Makes this DAO ready for deployments (regardless of whether or not there are authorized ones). */\r\n    function makeReady(uint256 governanceStage, uint256 idOffset) external {\r\n        require(\r\n               (_status == RE_NOT_ENTERED || _status == RE_FROZEN) // Reentrancy guard.\r\n            && msg.sender == _goaldToken                           // Not Goald token.\r\n            && _ready == NOT_READY                                 // Already ready.\r\n        );\r\n\r\n        _governanceStage = governanceStage;\r\n        _idOffset = idOffset;\r\n        _ready = READY;\r\n        \r\n        // The owner of this contract depends on whether or not the DAO has been initialized.\r\n        if (governanceStage >= STAGE_DAO_INITIATED) {\r\n            _owner = _goaldToken;\r\n        }\r\n    }\r\n\r\n    /** Removes an allowed deployer by index. We require the index for no-traversal removal against a known address. */\r\n    function removeAllowedDeployer(address deployerAddress, uint256 index) external {\r\n        address indexAddress = _allowedDeployersList[index];\r\n        require(\r\n               (_status == RE_NOT_ENTERED || _status == RE_FROZEN) // Reentrancy guard.\r\n            && msg.sender == _owner                                // Not owner.\r\n            && indexAddress == deployerAddress                     // Address mismatch.\r\n            && _allowedDeployersMap[deployerAddress]               // Already restricted.\r\n        );\r\n\r\n        // Remove the deployer.\r\n        _allowedDeployersMap[deployerAddress] = false;\r\n        _allowedDeployersList[index] = _allowedDeployersList[_allowedDeployersList.length - 1];\r\n        _allowedDeployersList.pop();\r\n    }\r\n\r\n    /** Updates the goald token. Should never have to be called. */\r\n    function setGoaldToken(address newAddress) external {\r\n        require(\r\n               _status == RE_FROZEN        // Reentrancy guard.\r\n            && msg.sender == _owner        // Caller must be owner.\r\n            && newAddress != address(0)    // Invalid address.\r\n            && newAddress != address(this) // Invalid address.\r\n        );\r\n\r\n        // The DAO has been initialized, so carry over the new address.\r\n        if (_owner == _goaldToken) {\r\n            _owner = newAddress;\r\n        }\r\n\r\n        _goaldToken = newAddress;\r\n    }\r\n\r\n    /** Update the owner, so long as the DAO hasn't been initialized. */\r\n    function setOwner(address newOwner) external {\r\n        require(\r\n               (_status == RE_NOT_ENTERED || _status == RE_FROZEN) // Reentrancy guard.\r\n            && msg.sender == _owner                                // Caller can't be owner.\r\n            && _owner != _goaldToken                               // Can't be initialized.\r\n            && newOwner != address(0)                              // Validate new owner.\r\n        );\r\n\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * The uniswap router for converting tokens within this DAO. Setting to the zero address disables swapping for newly created\r\n     * Goalds, but their owners can still manually change it for each Goald.\r\n     */\r\n    function setUniswapRouterAddress(address newAddress) external {\r\n        require(\r\n               (_status == RE_NOT_ENTERED || _status == RE_FROZEN) // Reentrancy guard.\r\n            && msg.sender == _owner                                // Caller must be owner.\r\n        );\r\n\r\n        _uniswapRouterAddress = newAddress;\r\n    }\r\n\r\n    /** Unfreezes the proxy contract. Non-admin functions can again be called. */\r\n    function unfreeze() external {\r\n        require(\r\n               _status == RE_FROZEN // Reentrancy guard.\r\n            && msg.sender == _owner // Caller must be owner.\r\n        );\r\n\r\n        _status = RE_NOT_ENTERED;\r\n    }\r\n\r\n    /// Goald Deployers ///\r\n\r\n    /** Returns the address of the deployer at the specified index. */\r\n    function getDeployerAt(uint256 index) external view returns (address) {\r\n        return _allowedDeployersList[index];\r\n    }\r\n\r\n    /** Returns the number of allowed deployers. */\r\n    function getDeployerCount() external view returns (uint256) {\r\n        return _allowedDeployersList.length;\r\n    }\r\n\r\n    /** Returns the address and owner of the Goald at the specified index. */\r\n    function getGoaldAt(uint256 index) external view returns (address[2] memory) {\r\n        return [_deployedGoalds[index], _goaldOwners[index]];\r\n    }\r\n\r\n    /** Returns the number of goalds deployed from this DAO. */\r\n    function getGoaldCount() external view returns (uint256) {\r\n        return _deployedGoalds.length;\r\n    }\r\n\r\n    /** Returns the ID offset of the Goalds tracked by this DAO. */\r\n    function getIDOffset() external view returns (uint256) {\r\n        return _idOffset;\r\n    }\r\n\r\n    /** Returns the next Goald id so that we have a unique ID for each NFT, regardless of which deployer was used. */\r\n    function getNextGoaldId() external view returns (uint256) {\r\n        return IGoaldToken(_goaldToken).getGoaldCount() + 1;\r\n    }\r\n\r\n    /** Returns the current address that fees will be sent to. */\r\n    function getProxyAddress() external view returns (address) {\r\n        return IGoaldToken(_goaldToken).getLatestDAO();\r\n    }\r\n\r\n    /** Return the metadata for a specific Goald. */\r\n    function getTokenURI(uint256 tokenId) external view returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        uint256 temp = tokenId;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = tokenId;\r\n        while (temp != 0) {\r\n            buffer[index--] = byte(uint8(48 + temp % 10));\r\n            temp /= 10;\r\n        }\r\n\r\n        return string(abi.encodePacked(IGoaldToken(_goaldToken).getBaseTokenURI(), string(buffer)));\r\n    }\r\n\r\n    /** Returns the address of the uniswap router. */\r\n    function getUniswapRouterAddress() external view returns (address) {\r\n        return _uniswapRouterAddress;\r\n    }\r\n\r\n    /** Returns if the address is an allowed deployer. */\r\n    function isAllowedDeployer(address deployer) external view returns (bool) {\r\n        return _allowedDeployersMap[deployer];\r\n    }\r\n\r\n    /**\r\n     * Called when a deployer deploys a new Goald. Currently we use this to distribute the governance token according to the following\r\n     * schedule. An additional 120,000 tokens will be claimable by the deployer of this proxy. This will create a total supply of\r\n     * 210,000 tokens. Once the governance protocal is set up, 110,000 tokens will be burned to initiate that mechanism. That will leave\r\n     * 10% ownership for the deployer of the contract, with the remaining 90% disbused on Goald creations. No rewards can be paid out\r\n     * before the governance protocal has been initiated.\r\n     *\r\n     *      # Goalds    # Tokens\r\n     *       0 -  9       1000\r\n     *      10 - 19        900\r\n     *      20 - 29        800\r\n     *      30 - 39        700\r\n     *      40 - 49        600\r\n     *      50 - 59        500\r\n     *      60 - 69        400\r\n     *      70 - 79        300\r\n     *      80 - 89        200\r\n     *      90 - 99        100\r\n     *       < 3600         10\r\n     */\r\n    function notifyGoaldCreated(address creator, address goaldAddress) external {\r\n        // Reentrancy guard.\r\n        require(_status == RE_NOT_ENTERED);\r\n        _status = RE_ENTERED;\r\n\r\n        require(_allowedDeployersMap[msg.sender], \"Not allowed deployer\");\r\n\r\n        IGoaldToken goaldToken = IGoaldToken(_goaldToken);\r\n        require(goaldToken.getLatestDAO() == address(this), \"Not latest DAO\");\r\n\r\n        // Must be ready for deployment.\r\n        require(_ready == READY, \"Not ready\");\r\n\r\n        // All governance tokens have been issued.\r\n        if (_governanceStage == STAGE_ALL_GOVERNANCE_ISSUED) {\r\n            goaldToken.goaldDeployed(creator, goaldAddress);\r\n\r\n            // Track the goald and its owner.\r\n            _deployedGoalds.push(goaldAddress);\r\n            _goaldOwners.push(creator);\r\n\r\n            return;\r\n        }\r\n\r\n        // We might be creating a new holder.\r\n        bool increaseHolders;\r\n        if (goaldToken.balanceOf(creator) < REWARD_THRESHOLD) {\r\n            increaseHolders = true;\r\n        }\r\n\r\n        // Get the amount of tokens minted.\r\n        uint256 amount = goaldToken.goaldDeployed(creator, goaldAddress);\r\n\r\n        // It's possible we have issued all governance tokens without the DAO initiated.\r\n        if (amount > 0) {\r\n            // Update their reward balance.\r\n            _checkRewardBalance(creator);\r\n\r\n            if (increaseHolders) {\r\n                _rewardHolders ++;\r\n            }\r\n        }\r\n\r\n        // We have issued all tokens, so move to the last stage of governance. This will short circuit this function on future calls.\r\n        // This will result in unnecessary gas if the DAO is never initiated and all 3600 token-earning goalds are created. But the\r\n        // DAO should be initiated long before that.\r\n        else if (_governanceStage == STAGE_DAO_INITIATED) {\r\n            _governanceStage = STAGE_ALL_GOVERNANCE_ISSUED;\r\n        }\r\n\r\n        // Track the goald and its owner.\r\n        _deployedGoalds.push(goaldAddress);\r\n        _goaldOwners.push(creator);\r\n\r\n        // By storing the original amount once again, a refund is triggered (see https://eips.ethereum.org/EIPS/eip-2200).\r\n        _status = RE_NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * Updates the owner of a deployed Goald.\r\n     * Due to a bug in GoaldFlexibleDeployer, id here is off by one (it is the index)\r\n     */\r\n    function setGoaldOwner(uint256 id) external {\r\n        // Reentrancy guard.\r\n        require(_status == RE_NOT_ENTERED);\r\n        _status = RE_ENTERED;\r\n\r\n        // Get the index of the Goald.\r\n        uint256 index = id - _idOffset;\r\n        require(index < _deployedGoalds.length, \"Invalid id\");\r\n\r\n        // We don't have the address as a parameter to make sure we have the correct value stored here.\r\n        address owner = IERC721(_deployedGoalds[index]).ownerOf(id + 1);\r\n        _goaldOwners[index] = owner;\r\n\r\n        // By storing the original amount once again, a refund is triggered (see https://eips.ethereum.org/EIPS/eip-2200).\r\n        _status = RE_NOT_ENTERED;\r\n    }\r\n\r\n    /// Governance ///\r\n\r\n    /** Uses Uniswap to convert all held amount of a specific token into the reward token, using the provided path. */\r\n    function convertToken(address[] calldata path, uint256 deadline) external {\r\n        require(\r\n               _status == RE_NOT_ENTERED             // Reentrancy guard.\r\n            && msg.sender == _owner                  // Caller must be owner.\r\n            && path[path.length - 1] == _rewardToken // Last must be reward token. Array is calldata; this avoids gas for pushing.\r\n        );\r\n        _status = RE_ENTERED;\r\n\r\n        // Swap the tokens.\r\n        IERC20 tokenContract = IERC20(path[0]);\r\n        uint256 amount = tokenContract.balanceOf(address(this));\r\n        tokenContract.approve(_uniswapRouterAddress, amount);\r\n        IUniswapV2Router02(_uniswapRouterAddress).swapExactTokensForTokens(amount, 1, path, address(this), deadline);\r\n\r\n        // By storing the original amount once again, a refund is triggered (see https://eips.ethereum.org/EIPS/eip-2200).\r\n        _status = RE_NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * Uses Uniswap to convert all held amount of specific tokens into the reward token. The tokens must have a direct path,\r\n     * otherwise the intermediary is used for increased liquidity.\r\n     */\r\n    function convertTokens(address[] calldata tokenAddresses, address intermediaryTokenOrZeroAddress, uint256 deadline) external {\r\n        require(\r\n               _status == RE_NOT_ENTERED             // Reentrancy guard.\r\n            && msg.sender == _owner                  // Caller must be owner.\r\n        );\r\n        _status = RE_ENTERED;\r\n\r\n        // The path between a given token and the reward token within Uniswap.\r\n        address[] memory path;\r\n        if (intermediaryTokenOrZeroAddress != address(0)) {\r\n            path = new address[](3);\r\n            path[1] = intermediaryTokenOrZeroAddress;\r\n            path[2] = _rewardToken;\r\n        } else {\r\n            path = new address[](2);\r\n            path[1] = _rewardToken;\r\n        }\r\n        IUniswapV2Router02 uniswap = IUniswapV2Router02(_uniswapRouterAddress);\r\n\r\n        address tokenAddress;\r\n        IERC20 tokenContract;\r\n        \r\n        uint256 amount;\r\n        uint256 count = tokenAddresses.length;\r\n        for (uint256 i; i < count; i ++) {\r\n            // Validate the token.\r\n            tokenAddress = tokenAddresses[i];\r\n            require(\r\n                   tokenAddress != address(0)\r\n                && tokenAddress != address(this)\r\n                && tokenAddress != _rewardToken\r\n            , \"Invalid address\");\r\n\r\n            // Make sure this contract actually has a balance.\r\n            tokenContract = IERC20(tokenAddress);\r\n            amount = tokenContract.balanceOf(address(this));\r\n            if (amount == 0) {\r\n                continue;\r\n            }\r\n\r\n            // Swap the tokens.\r\n            tokenContract.approve(_uniswapRouterAddress, amount);\r\n            path[0] = tokenAddress;\r\n            uniswap.swapExactTokensForTokens(amount, 1, path, address(this), deadline);\r\n        }\r\n\r\n        // By storing the original amount once again, a refund is triggered (see https://eips.ethereum.org/EIPS/eip-2200).\r\n        _status = RE_NOT_ENTERED;\r\n    }\r\n\r\n    /** This should always be the same as `GoaldToken.getGovernanceStage()`. */\r\n    function getGovernanceStage() external view returns (uint256) {\r\n        return _governanceStage;\r\n    }\r\n\r\n    /** Called when the DAO has been initialized. */\r\n    function updateGovernanceStage() external {\r\n        uint256 governanceStage = IGoaldToken(_goaldToken).getGovernanceStage();\r\n\r\n        // Make sure the owner is updated to the goald token if the DAO has been initiated.\r\n        if (governanceStage >= STAGE_DAO_INITIATED && _owner != _goaldToken) {\r\n            _owner = _goaldToken;\r\n        }\r\n\r\n        _governanceStage = governanceStage;\r\n    }\r\n\r\n    /**\r\n     * Changes which token will be the reward token. This can only happen if there is no balance in reserve held for rewards. If a\r\n     * change is desired despite there being excess rewards, call `withdrawReward()` on behalf of each holder to drain the reserve.\r\n     */\r\n    function setRewardToken(address newToken) external {\r\n        require(\r\n               (_status == RE_NOT_ENTERED || _status == RE_FROZEN) // Reentrancy guard.\r\n            && msg.sender == _owner        // Not owner.\r\n            && newToken != address(0)      // Can't be zero address.\r\n            && newToken != address(this)   // Can't be this address.\r\n            && _reservedRewardBalance == 0 // Have reserved balance.\r\n        );\r\n\r\n        _rewardToken = newToken;\r\n    }\r\n\r\n    /// Rewards ///\r\n\r\n    /**\r\n     * Check which rewards a given address is eligible for, and update their current reward balance to reflect that total. Since\r\n     * balances are static until transferred (or minted in the case of a new Goald being created), this function is called before\r\n     * any change to a given addresses' balance. Ths will bring them up to date with any past, unclaimed rewards. Any future rewards\r\n     * will be dependant on their balance after the change.\r\n     */\r\n    function _checkRewardBalance(address holder) internal {\r\n        // There is no need for reentrancy since this only updates the `_rewardBalance` for a given holder according to the amounts\r\n        // they are already owed according to the current state. If this is an unexpected reentrant call, then that holder gets the\r\n        // benefit of this math without having to pay the gas.\r\n\r\n        // The total number of rewards issued.\r\n        uint256 count = _rewardMultipliers.length;\r\n\r\n        // The holder has already claimed all rewards.\r\n        uint256 currentMinimumIndex = _minimumRewardIndex[holder];\r\n        if (currentMinimumIndex == count) {\r\n            return;\r\n        }\r\n\r\n        // The holder is not eligible for a reward according to their current balance.\r\n        uint256 balance = IGoaldToken(_goaldToken).balanceOf(holder);\r\n        if (balance < REWARD_THRESHOLD) {\r\n            // Mark that they have been checked for all rewards.\r\n            if (currentMinimumIndex < count) {\r\n                _minimumRewardIndex[holder] = count;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Calculate the balance increase according to which rewards the holder has yet to claim. We don't change how much is held in\r\n        // reserve, even if the balance would close out a given reward. Those tokens must still be held until such time as the holder\r\n        // chooses to claim (or someone claims on their behalf).\r\n        uint256 multiplier;\r\n        uint256 totalMultiplier;\r\n        for (; currentMinimumIndex < count; currentMinimumIndex ++) {\r\n            // This can never overflow since a reward can't be created unless there is enough reserve balance to cover its\r\n            // multiplier, which already checks for overflows, likewise `multiplier * balance` can never overflow.\r\n            multiplier = _rewardMultipliers[currentMinimumIndex];\r\n            totalMultiplier += multiplier;\r\n\r\n            // Close out this reward.\r\n            if (_rewardHolderCounts[currentMinimumIndex] == 1) {\r\n                _rewardHolderCounts[currentMinimumIndex] = 0;\r\n                _rewardReserves[currentMinimumIndex] = 0;\r\n                // We don't wipe `_rewardMultipliers` here despite this being the last holder, so we have a historical record.\r\n            } else {\r\n                _rewardHolderCounts[currentMinimumIndex]--;\r\n                _rewardReserves[currentMinimumIndex] -= multiplier * balance;\r\n            }\r\n        }\r\n        _minimumRewardIndex[holder] = count;\r\n\r\n        // Update their claimable balance.\r\n        uint256 currentBalance = _rewardBalance[holder];\r\n        require(currentBalance + (totalMultiplier * balance) > currentBalance, \"Balance overflow\");\r\n        _rewardBalance[holder] = currentBalance + (totalMultiplier * balance);\r\n    }\r\n\r\n    /**\r\n     * Creates a new reward. Rewards are only paid out to holders who have at least \"one token\" at time of creation. The reward\r\n     * is a multiplier, representing how many reward tokens (e.g., WBTC) should be paid out for one governance token. reward\r\n     * eligibility is only updated in state in two cases:\r\n     *      1) When a reward is being withdrawn (in which it is set to zero).\r\n     *      2) When the governance token is transferred (balances are checked before the transfer, on both sender and recipient).\r\n     */\r\n    function createReward(uint256 multiplier, string calldata reason) external {\r\n        uint256 holders = _rewardHolders;\r\n        require(\r\n               _status == RE_NOT_ENTERED               // Reentrancy guard.\r\n            && msg.sender == _owner                    // Not owner.\r\n            && _governanceStage >= STAGE_DAO_INITIATED // DAO not initiated.\r\n            && multiplier > 0                          // Multiplier must be > 0.\r\n            && holders > 0                             // Must have a holder\r\n        );\r\n        _status = RE_ENTERED;\r\n\r\n        // Make sure we can actually create a reward with that amount. This balance of the reward token at this proxy address should\r\n        // never decrease except when rewards are claimed by holders.\r\n        uint256 reservedRewardBalance = _reservedRewardBalance;\r\n        uint256 currentBalance = IERC20(_rewardToken).balanceOf(address(this));\r\n        require(currentBalance >= reservedRewardBalance, \"Current reserve insufficient\");\r\n        uint256 reserveIncrease = IGoaldToken(_goaldToken).totalSupply() * multiplier;\r\n        require(reserveIncrease <= (currentBalance - reservedRewardBalance), \"Multiplier too large\");\r\n\r\n        // Increase the reserve.\r\n        require((reservedRewardBalance + reserveIncrease) > reservedRewardBalance, \"Reserved overflow error\");\r\n        _reservedRewardBalance += reserveIncrease;\r\n\r\n        // Keep track of the holders, reserve, and multiplier for this reward. These values will not increase after being set here.\r\n        _rewardHolderCounts.push(holders);\r\n        _rewardMultipliers.push(multiplier);\r\n        _rewardReserves.push(reserveIncrease);\r\n\r\n        // Hello world!\r\n        emit RewardCreated(multiplier, reason);\r\n\r\n        // By storing the original amount once again, a refund is triggered (see https://eips.ethereum.org/EIPS/eip-2200).\r\n        _status = RE_NOT_ENTERED;\r\n    }\r\n\r\n    /** Returns the reward balance for a holder according to the true state, not the hard state. See: `_checkRewardBalance()`. */\r\n    function getHolderRewardBalance(address holder) external view returns (uint256) {\r\n        uint256 count = _rewardMultipliers.length;\r\n        uint256 balance = IGoaldToken(_goaldToken).balanceOf(holder);\r\n        uint256 rewardBalance = _rewardBalance[holder];\r\n        uint256 currentMinimumIndex = _minimumRewardIndex[holder];\r\n        for (; currentMinimumIndex < count; currentMinimumIndex ++) {\r\n            rewardBalance += _rewardMultipliers[currentMinimumIndex] * balance;\r\n        }\r\n\r\n        return rewardBalance;\r\n    }\r\n\r\n    /** Return the general reward details. */\r\n    function getRewardDetails() external view returns (uint256[4] memory) {\r\n        return [\r\n            uint256(_rewardToken),\r\n            _rewardReserves.length,\r\n            _rewardHolders,\r\n            _reservedRewardBalance\r\n        ];\r\n    }\r\n\r\n    /** Get the details of the reward at the specified index.*/\r\n    function getRewardDetailsAt(uint256 index) external view returns (uint256[3] memory) {\r\n        return [\r\n            _rewardMultipliers[index],\r\n            _rewardHolderCounts[index],\r\n            _rewardReserves[index]\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Withdraws the current reward balance. The sender doesn't need to have any current balance of the governance token to\r\n     * withdraw, so long as they have a preexisting outstanding balance. This has a provided recipient so that we can drain the\r\n     * reward pool as necessary (e.g., for changing the reward token).\r\n     */\r\n    function withdrawReward(address holder) external {\r\n        // Reentrancy guard. Allow owner to drain the pool even if frozen.\r\n        require(_status == RE_NOT_ENTERED || (_status == RE_FROZEN && msg.sender == _owner));\r\n        _status = RE_ENTERED;\r\n\r\n        // Update their balance.\r\n        _checkRewardBalance(holder);\r\n\r\n        // Revert so gas estimators will show a failure.\r\n        uint256 balance = _rewardBalance[holder];\r\n        require(balance > 0, \"No reward balance\");\r\n\r\n        // Wipe the balance.\r\n        _rewardBalance[holder] = 0;\r\n        require(_reservedRewardBalance - balance > 0, \"Reserved balance underflow\");\r\n        _reservedRewardBalance -= balance;\r\n\r\n        // Give them their balance.\r\n        IERC20(_rewardToken).transfer(holder, balance);\r\n\r\n        // By storing the original amount once again, a refund is triggered (see https://eips.ethereum.org/EIPS/eip-2200).\r\n        _status = RE_NOT_ENTERED;\r\n    }\r\n\r\n    /// ERC20 Overrides ///\r\n\r\n    /** Update the reward balances prior to the transfer completing. */\r\n    function preTransfer(address sender, address recipient) external {\r\n        // Reentrancy guard. Caller must be the Goald token.\r\n        require(_status == RE_NOT_ENTERED && msg.sender == _goaldToken);\r\n        _status = RE_ENTERED;\r\n\r\n        // Update the reward balances prior to the transfer for both sender and receiver.\r\n        _checkRewardBalance(sender);\r\n        _checkRewardBalance(recipient);\r\n\r\n        // By storing the original amount once again, a refund is triggered (see https://eips.ethereum.org/EIPS/eip-2200).\r\n        _status = RE_NOT_ENTERED;\r\n    }\r\n\r\n    /** Updates holder counts after doing a transfer. */\r\n    function postTransfer(address sender, uint256 senderBefore, uint256 senderAfter, uint256 recipientBefore, uint256 recipientAfter) external {\r\n        // Reentrancy guard. Caller must be the Goald token.\r\n        require(\r\n               (_status == RE_NOT_ENTERED || _status == RE_FROZEN)\r\n            && msg.sender == _goaldToken\r\n        );\r\n\r\n        // See if we need to change `_rewardHolders`.\r\n        if        (senderBefore  < REWARD_THRESHOLD && senderAfter >= REWARD_THRESHOLD) {\r\n            _rewardHolders ++;\r\n        } else if (senderBefore >= REWARD_THRESHOLD && senderAfter  < REWARD_THRESHOLD) {\r\n            _rewardHolders --;\r\n        }\r\n        if        (recipientBefore  < REWARD_THRESHOLD && recipientAfter >= REWARD_THRESHOLD) {\r\n            _rewardHolders ++;\r\n        } else if (recipientBefore >= REWARD_THRESHOLD && recipientAfter  < REWARD_THRESHOLD) {\r\n            _rewardHolders --;\r\n        }\r\n\r\n        // The sender has no balance, so clear their minimum index. This should save on total storage space for this contract. We do\r\n        // not clear the reward balance even if their token balance is zero, since they still have a claim to that balance.\r\n        if (senderAfter == 0) {\r\n            _minimumRewardIndex[sender] = 0;\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"RewardCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_goaldToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"newDeployers\",\"type\":\"address[]\"}],\"name\":\"addAllowedDeployers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"convertToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"intermediaryTokenOrZeroAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"convertTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"createReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getDeployerAt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDeployerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getGoaldAt\",\"outputs\":[{\"internalType\":\"address[2]\",\"name\":\"\",\"type\":\"address[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGoaldCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGovernanceStage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getHolderRewardBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIDOffset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextGoaldId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProxyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardDetails\",\"outputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"\",\"type\":\"uint256[4]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRewardDetailsAt\",\"outputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"\",\"type\":\"uint256[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUniswapRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializeDecreasesHolders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"name\":\"isAllowedDeployer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"issuanceIncreasesHolders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"governanceStage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"idOffset\",\"type\":\"uint256\"}],\"name\":\"makeReady\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"goaldAddress\",\"type\":\"address\"}],\"name\":\"notifyGoaldCreated\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"senderBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"senderAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recipientBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recipientAfter\",\"type\":\"uint256\"}],\"name\":\"postTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"preTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"removeAllowedDeployer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"setGoaldOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setGoaldToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"setRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setUniswapRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateGovernanceStage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"withdrawReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GoaldDAO","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6bddb6271a2a05c96be30b902f6ee1d59909df10e76823b9c813e6a80220013f"}]}