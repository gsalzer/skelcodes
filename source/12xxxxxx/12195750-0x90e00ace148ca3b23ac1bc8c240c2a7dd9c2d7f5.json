{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.11\r\n\"\"\"\r\n@title Curve Registry\r\n@license MIT\r\n@author Curve.Fi\r\n\"\"\"\r\n\r\nMAX_COINS: constant(int128) = 8\r\nCALC_INPUT_SIZE: constant(int128) = 100\r\n\r\n\r\nstruct CoinInfo:\r\n    index: uint256\r\n    register_count: uint256\r\n    swap_count: uint256\r\n    swap_for: address[MAX_INT128]\r\n\r\nstruct PoolArray:\r\n    location: uint256\r\n    decimals: uint256\r\n    underlying_decimals: uint256\r\n    rate_info: bytes32\r\n    base_pool: address\r\n    coins: address[MAX_COINS]\r\n    ul_coins: address[MAX_COINS]\r\n    n_coins: uint256  # [coins, underlying coins] tightly packed as uint128[2]\r\n    has_initial_A: bool\r\n    is_v1: bool\r\n    name: String[64]\r\n    asset_type: uint256\r\n\r\nstruct PoolParams:\r\n    A: uint256\r\n    future_A: uint256\r\n    fee: uint256\r\n    admin_fee: uint256\r\n    future_fee: uint256\r\n    future_admin_fee: uint256\r\n    future_owner: address\r\n    initial_A: uint256\r\n    initial_A_time: uint256\r\n    future_A_time: uint256\r\n\r\n\r\ninterface AddressProvider:\r\n    def admin() -> address: view\r\n    def get_address(_id: uint256) -> address: view\r\n\r\ninterface ERC20:\r\n    def balanceOf(_addr: address) -> uint256: view\r\n    def decimals() -> uint256: view\r\n    def totalSupply() -> uint256: view\r\n\r\ninterface CurvePool:\r\n    def A() -> uint256: view\r\n    def future_A() -> uint256: view\r\n    def fee() -> uint256: view\r\n    def admin_fee() -> uint256: view\r\n    def future_fee() -> uint256: view\r\n    def future_admin_fee() -> uint256: view\r\n    def future_owner() -> address: view\r\n    def initial_A() -> uint256: view\r\n    def initial_A_time() -> uint256: view\r\n    def future_A_time() -> uint256: view\r\n    def coins(i: uint256) -> address: view\r\n    def underlying_coins(i: uint256) -> address: view\r\n    def balances(i: uint256) -> uint256: view\r\n    def get_virtual_price() -> uint256: view\r\n\r\ninterface CurvePoolV1:\r\n    def coins(i: int128) -> address: view\r\n    def underlying_coins(i: int128) -> address: view\r\n    def balances(i: int128) -> uint256: view\r\n\r\ninterface CurveMetapool:\r\n    def base_pool() -> address: view\r\n\r\ninterface GasEstimator:\r\n    def estimate_gas_used(_pool: address, _from: address, _to: address) -> uint256: view\r\n\r\ninterface LiquidityGauge:\r\n    def lp_token() -> address: view\r\n\r\ninterface GaugeController:\r\n    def gauge_types(gauge: address) -> int128: view\r\n\r\ninterface RateCalc:\r\n    def get_rate(_coin: address) -> uint256: view\r\n\r\n\r\nevent PoolAdded:\r\n    pool: indexed(address)\r\n    rate_method_id: Bytes[4]\r\n\r\nevent PoolRemoved:\r\n    pool: indexed(address)\r\n\r\n\r\naddress_provider: public(AddressProvider)\r\ngauge_controller: public(address)\r\npool_list: public(address[65536])   # master list of pools\r\npool_count: public(uint256)         # actual length of pool_list\r\n\r\npool_data: HashMap[address, PoolArray]\r\n\r\ncoin_count: public(uint256)  # total unique coins registered\r\ncoins: HashMap[address, CoinInfo]\r\nget_coin: public(address[65536])  # unique list of registered coins\r\n# bitwise_xor(coina, coinb) -> (coina_pos, coinb_pos) sorted\r\n# stored as uint128[2]\r\ncoin_swap_indexes: HashMap[uint256, uint256]\r\n\r\n# lp token -> pool\r\nget_pool_from_lp_token: public(HashMap[address, address])\r\n\r\n# pool -> lp token\r\nget_lp_token: public(HashMap[address, address])\r\n\r\n# mapping of estimated gas costs for pools and coins\r\n# for a pool the values are [wrapped exchange, underlying exchange]\r\n# for a coin the values are [transfer cost, 0]\r\ngas_estimate_values: HashMap[address, uint256[2]]\r\n\r\n# pool -> gas estimation contract\r\n# used when gas costs for a pool are too complex to be handled by summing\r\n# values in `gas_estimate_values`\r\ngas_estimate_contracts: HashMap[address, address]\r\n\r\n# mapping of coins -> pools for trading\r\n# a mapping key is generated for each pair of addresses via\r\n# `bitwise_xor(convert(a, uint256), convert(b, uint256))`\r\nmarkets: HashMap[uint256, address[65536]]\r\nmarket_counts: HashMap[uint256, uint256]\r\n\r\nliquidity_gauges: HashMap[address, address[10]]\r\n\r\nlast_updated: public(uint256)\r\n\r\n\r\n@external\r\ndef __init__(_address_provider: address, _gauge_controller: address):\r\n    \"\"\"\r\n    @notice Constructor function\r\n    \"\"\"\r\n    self.address_provider = AddressProvider(_address_provider)\r\n    self.gauge_controller = _gauge_controller\r\n\r\n\r\n# internal functionality for getters\r\n\r\n@view\r\n@internal\r\ndef _unpack_decimals(_packed: uint256, _n_coins: uint256) -> uint256[MAX_COINS]:\r\n    # decimals are tightly packed as a series of uint8 within a little-endian bytes32\r\n    # the packed value is stored as uint256 to simplify unpacking via shift and modulo\r\n    decimals: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    n_coins: int128 = convert(_n_coins, int128)\r\n    for i in range(MAX_COINS):\r\n        if i == n_coins:\r\n            break\r\n        decimals[i] = shift(_packed, -8 * i) % 256\r\n\r\n    return decimals\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_rates(_pool: address) -> uint256[MAX_COINS]:\r\n    rates: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    base_pool: address = self.pool_data[_pool].base_pool\r\n    if base_pool == ZERO_ADDRESS:\r\n        rate_info: bytes32 = self.pool_data[_pool].rate_info\r\n        rate_calc_addr: uint256 = convert(slice(rate_info, 8, 20), uint256)\r\n        rate_method_id: Bytes[4] = slice(rate_info, 28, 4)\r\n\r\n        for i in range(MAX_COINS):\r\n            coin: address = self.pool_data[_pool].coins[i]\r\n            if coin == ZERO_ADDRESS:\r\n                break\r\n            if rate_info == EMPTY_BYTES32 or coin == self.pool_data[_pool].ul_coins[i]:\r\n                rates[i] = 10 ** 18\r\n            elif rate_calc_addr != 0:\r\n                rates[i] = RateCalc(convert(rate_calc_addr, address)).get_rate(coin)\r\n            else:\r\n                rates[i] = convert(\r\n                    raw_call(coin, rate_method_id, max_outsize=32, is_static_call=True),  # dev: bad response\r\n                    uint256\r\n                )\r\n    else:\r\n        base_coin_idx: uint256 = shift(self.pool_data[_pool].n_coins, -128) - 1\r\n        rates[base_coin_idx] = CurvePool(base_pool).get_virtual_price()\r\n        for i in range(MAX_COINS):\r\n            if i == base_coin_idx:\r\n                break\r\n            rates[i] = 10 ** 18\r\n\r\n    return rates\r\n\r\n@view\r\n@internal\r\ndef _get_balances(_pool: address) -> uint256[MAX_COINS]:\r\n    is_v1: bool = self.pool_data[_pool].is_v1\r\n\r\n    balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    for i in range(MAX_COINS):\r\n        if self.pool_data[_pool].coins[i] == ZERO_ADDRESS:\r\n            assert i != 0\r\n            break\r\n\r\n        if is_v1:\r\n            balances[i] = CurvePoolV1(_pool).balances(i)\r\n        else:\r\n            balances[i] = CurvePool(_pool).balances(convert(i, uint256))\r\n\r\n    return balances\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_underlying_balances(_pool: address) -> uint256[MAX_COINS]:\r\n    balances: uint256[MAX_COINS] = self._get_balances(_pool)\r\n    rates: uint256[MAX_COINS] = self._get_rates(_pool)\r\n    decimals: uint256 = self.pool_data[_pool].underlying_decimals\r\n    underlying_balances: uint256[MAX_COINS] = balances\r\n    for i in range(MAX_COINS):\r\n        coin: address = self.pool_data[_pool].coins[i]\r\n        if coin == ZERO_ADDRESS:\r\n            break\r\n        ucoin: address = self.pool_data[_pool].ul_coins[i]\r\n        if ucoin == ZERO_ADDRESS:\r\n            continue\r\n        if ucoin != coin:\r\n            underlying_balances[i] = balances[i] * rates[i] / 10**(shift(decimals, -8 * i) % 256)\r\n\r\n    return underlying_balances\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_meta_underlying_balances(_pool: address, _base_pool: address) -> uint256[MAX_COINS]:\r\n    base_coin_idx: uint256 = shift(self.pool_data[_pool].n_coins, -128) - 1\r\n    is_v1: bool = self.pool_data[_base_pool].is_v1\r\n    base_total_supply: uint256 = ERC20(self.get_lp_token[_base_pool]).totalSupply()\r\n\r\n    underlying_balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    ul_balance: uint256 = 0\r\n    underlying_pct: uint256 = 0\r\n    if base_total_supply > 0:\r\n        underlying_pct = CurvePool(_pool).balances(base_coin_idx) * 10**36 / base_total_supply\r\n\r\n    for i in range(MAX_COINS):\r\n        if self.pool_data[_pool].ul_coins[i] == ZERO_ADDRESS:\r\n            break\r\n        if i < base_coin_idx:\r\n            ul_balance = CurvePool(_pool).balances(i)\r\n        else:\r\n            if is_v1:\r\n                ul_balance = CurvePoolV1(_base_pool).balances(convert(i - base_coin_idx, int128))\r\n            else:\r\n                ul_balance = CurvePool(_base_pool).balances(i-base_coin_idx)\r\n            ul_balance = ul_balance * underlying_pct / 10**36\r\n        underlying_balances[i] = ul_balance\r\n\r\n    return underlying_balances\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_coin_indices(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address\r\n) -> uint256[3]:\r\n    \"\"\"\r\n    Convert coin addresses to indices for use with pool methods.\r\n    \"\"\"\r\n    # the return value is stored as `uint256[3]` to reduce gas costs\r\n    # from index, to index, is the market underlying?\r\n    result: uint256[3] = empty(uint256[3])\r\n\r\n    found_market: bool = False\r\n\r\n    # check coin markets\r\n    for x in range(MAX_COINS):\r\n        coin: address = self.pool_data[_pool].coins[x]\r\n        if coin == ZERO_ADDRESS:\r\n            # if we reach the end of the coins, reset `found_market` and try again\r\n            # with the underlying coins\r\n            found_market = False\r\n            break\r\n        if coin == _from:\r\n            result[0] = x\r\n        elif coin == _to:\r\n            result[1] = x\r\n        else:\r\n            continue\r\n\r\n        if found_market:\r\n            # the second time we find a match, break out of the loop\r\n            break\r\n        # the first time we find a match, set `found_market` to True\r\n        found_market = True\r\n\r\n    if not found_market:\r\n        # check underlying coin markets\r\n        for x in range(MAX_COINS):\r\n            coin: address = self.pool_data[_pool].ul_coins[x]\r\n            if coin == ZERO_ADDRESS:\r\n                raise \"No available market\"\r\n            if coin == _from:\r\n                result[0] = x\r\n            elif coin == _to:\r\n                result[1] = x\r\n            else:\r\n                continue\r\n\r\n            if found_market:\r\n                result[2] = 1\r\n                break\r\n            found_market = True\r\n\r\n    return result\r\n\r\n\r\n# targetted external getters, optimized for on-chain calls\r\n\r\n@view\r\n@external\r\ndef find_pool_for_coins(_from: address, _to: address, i: uint256 = 0) -> address:\r\n    \"\"\"\r\n    @notice Find an available pool for exchanging two coins\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param i Index value. When multiple pools are available\r\n            this value is used to return the n'th address.\r\n    @return Pool address\r\n    \"\"\"\r\n    key: uint256 = bitwise_xor(convert(_from, uint256), convert(_to, uint256))\r\n    return self.markets[key][i]\r\n\r\n\r\n@view\r\n@external\r\ndef get_n_coins(_pool: address) -> uint256[2]:\r\n    \"\"\"\r\n    @notice Get the number of coins in a pool\r\n    @dev For non-metapools, both returned values are identical\r\n         even when the pool does not use wrapping/lending\r\n    @param _pool Pool address\r\n    @return Number of wrapped coins, number of underlying coins\r\n    \"\"\"\r\n    n_coins: uint256 = self.pool_data[_pool].n_coins\r\n    return [shift(n_coins, -128), n_coins % 2**128]\r\n\r\n\r\n@view\r\n@external\r\ndef get_coins(_pool: address) -> address[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get the coins within a pool\r\n    @dev For pools using lending, these are the wrapped coin addresses\r\n    @param _pool Pool address\r\n    @return List of coin addresses\r\n    \"\"\"\r\n    coins: address[MAX_COINS] = empty(address[MAX_COINS])\r\n    n_coins: uint256 = shift(self.pool_data[_pool].n_coins, -128)\r\n    for i in range(MAX_COINS):\r\n        if i == n_coins:\r\n            break\r\n        coins[i] = self.pool_data[_pool].coins[i]\r\n\r\n    return coins\r\n\r\n\r\n@view\r\n@external\r\ndef get_underlying_coins(_pool: address) -> address[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get the underlying coins within a pool\r\n    @dev For pools that do not lend, returns the same value as `get_coins`\r\n    @param _pool Pool address\r\n    @return List of coin addresses\r\n    \"\"\"\r\n    coins: address[MAX_COINS] = empty(address[MAX_COINS])\r\n    n_coins: uint256 = self.pool_data[_pool].n_coins % 2**128\r\n    for i in range(MAX_COINS):\r\n        if i == n_coins:\r\n            break\r\n        coins[i] = self.pool_data[_pool].ul_coins[i]\r\n\r\n    return coins\r\n\r\n\r\n@view\r\n@external\r\ndef get_decimals(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get decimal places for each coin within a pool\r\n    @dev For pools using lending, these are the wrapped coin decimal places\r\n    @param _pool Pool address\r\n    @return uint256 list of decimals\r\n    \"\"\"\r\n    n_coins: uint256 = shift(self.pool_data[_pool].n_coins, -128)\r\n    return self._unpack_decimals(self.pool_data[_pool].decimals, n_coins)\r\n\r\n\r\n@view\r\n@external\r\ndef get_underlying_decimals(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get decimal places for each underlying coin within a pool\r\n    @dev For pools that do not lend, returns the same value as `get_decimals`\r\n    @param _pool Pool address\r\n    @return uint256 list of decimals\r\n    \"\"\"\r\n    n_coins: uint256 = self.pool_data[_pool].n_coins % 2**128\r\n    return self._unpack_decimals(self.pool_data[_pool].underlying_decimals, n_coins)\r\n\r\n\r\n@view\r\n@external\r\ndef get_rates(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get rates between coins and underlying coins\r\n    @dev For coins where there is no underlying coin, or where\r\n         the underlying coin cannot be swapped, the rate is\r\n         given as 1e18\r\n    @param _pool Pool address\r\n    @return Rates between coins and underlying coins\r\n    \"\"\"\r\n    return self._get_rates(_pool)\r\n\r\n\r\n@view\r\n@external\r\ndef get_gauges(_pool: address) -> (address[10], int128[10]):\r\n    \"\"\"\r\n    @notice Get a list of LiquidityGauge contracts associated with a pool\r\n    @param _pool Pool address\r\n    @return address[10] of gauge addresses, int128[10] of gauge types\r\n    \"\"\"\r\n    liquidity_gauges: address[10] = empty(address[10])\r\n    gauge_types: int128[10] = empty(int128[10])\r\n    gauge_controller: address = self.gauge_controller\r\n    for i in range(10):\r\n        gauge: address = self.liquidity_gauges[_pool][i]\r\n        if gauge == ZERO_ADDRESS:\r\n            break\r\n        liquidity_gauges[i] = gauge\r\n        gauge_types[i] = GaugeController(gauge_controller).gauge_types(gauge)\r\n\r\n    return liquidity_gauges, gauge_types\r\n\r\n\r\n@view\r\n@external\r\ndef get_balances(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get balances for each coin within a pool\r\n    @dev For pools using lending, these are the wrapped coin balances\r\n    @param _pool Pool address\r\n    @return uint256 list of balances\r\n    \"\"\"\r\n    return self._get_balances(_pool)\r\n\r\n\r\n@view\r\n@external\r\ndef get_underlying_balances(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get balances for each underlying coin within a pool\r\n    @dev  For pools that do not lend, returns the same value as `get_balances`\r\n    @param _pool Pool address\r\n    @return uint256 list of underlyingbalances\r\n    \"\"\"\r\n    base_pool: address = self.pool_data[_pool].base_pool\r\n    if base_pool == ZERO_ADDRESS:\r\n        return self._get_underlying_balances(_pool)\r\n    return self._get_meta_underlying_balances(_pool, base_pool)\r\n\r\n\r\n@view\r\n@external\r\ndef get_virtual_price_from_lp_token(_token: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the virtual price of a pool LP token\r\n    @param _token LP token address\r\n    @return uint256 Virtual price\r\n    \"\"\"\r\n    return CurvePool(self.get_pool_from_lp_token[_token]).get_virtual_price()\r\n\r\n\r\n@view\r\n@external\r\ndef get_A(_pool: address) -> uint256:\r\n    return CurvePool(_pool).A()\r\n\r\n\r\n@view\r\n@external\r\ndef get_parameters(_pool: address) -> PoolParams:\r\n    \"\"\"\r\n    @notice Get parameters for a pool\r\n    @dev For older pools where `initial_A` is not public, this value is set to 0\r\n    @param _pool Pool address\r\n    @return Pool amp, future amp, fee, admin fee, future fee, future admin fee,\r\n            future owner, initial amp, initial amp time, future amp time\r\n    \"\"\"\r\n    pool_params: PoolParams = empty(PoolParams)\r\n    pool_params.A = CurvePool(_pool).A()\r\n    pool_params.future_A = CurvePool(_pool).future_A()\r\n    pool_params.fee = CurvePool(_pool).fee()\r\n    pool_params.future_fee = CurvePool(_pool).future_fee()\r\n    pool_params.admin_fee = CurvePool(_pool).admin_fee()\r\n    pool_params.future_admin_fee = CurvePool(_pool).future_admin_fee()\r\n    pool_params.future_owner = CurvePool(_pool).future_owner()\r\n\r\n    if self.pool_data[_pool].has_initial_A:\r\n        pool_params.initial_A = CurvePool(_pool).initial_A()\r\n        pool_params.initial_A_time = CurvePool(_pool).initial_A_time()\r\n        pool_params.future_A_time = CurvePool(_pool).future_A_time()\r\n\r\n    return pool_params\r\n\r\n\r\n@view\r\n@external\r\ndef get_fees(_pool: address) -> uint256[2]:\r\n    \"\"\"\r\n    @notice Get the fees for a pool\r\n    @dev Fees are expressed as integers\r\n    @return Pool fee as uint256 with 1e10 precision\r\n            Admin fee as 1e10 percentage of pool fee\r\n    \"\"\"\r\n    return [CurvePool(_pool).fee(), CurvePool(_pool).admin_fee()]\r\n\r\n\r\n@view\r\n@external\r\ndef get_admin_balances(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get the current admin balances (uncollected fees) for a pool\r\n    @param _pool Pool address\r\n    @return List of uint256 admin balances\r\n    \"\"\"\r\n    balances: uint256[MAX_COINS] = self._get_balances(_pool)\r\n    n_coins: uint256 = shift(self.pool_data[_pool].n_coins, -128)\r\n    for i in range(MAX_COINS):\r\n        coin: address = self.pool_data[_pool].coins[i]\r\n        if i == n_coins:\r\n            break\r\n        if coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            balances[i] = _pool.balance - balances[i]\r\n        else:\r\n            balances[i] = ERC20(coin).balanceOf(_pool) - balances[i]\r\n\r\n    return balances\r\n\r\n\r\n@view\r\n@external\r\ndef get_coin_indices(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address\r\n) -> (int128, int128, bool):\r\n    \"\"\"\r\n    @notice Convert coin addresses to indices for use with pool methods\r\n    @param _from Coin address to be used as `i` within a pool\r\n    @param _to Coin address to be used as `j` within a pool\r\n    @return int128 `i`, int128 `j`, boolean indicating if `i` and `j` are underlying coins\r\n    \"\"\"\r\n    result: uint256[3] = self._get_coin_indices(_pool, _from, _to)\r\n    return convert(result[0], int128), convert(result[1], int128), result[2] > 0\r\n\r\n\r\n@view\r\n@external\r\ndef estimate_gas_used(_pool: address, _from: address, _to: address) -> uint256:\r\n    \"\"\"\r\n    @notice Estimate the gas used in an exchange.\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @return Upper-bound gas estimate, in wei\r\n    \"\"\"\r\n    estimator: address = self.gas_estimate_contracts[_pool]\r\n    if estimator != ZERO_ADDRESS:\r\n        return GasEstimator(estimator).estimate_gas_used(_pool, _from, _to)\r\n\r\n    # here we call `_get_coin_indices` to find out if the exchange involves wrapped\r\n    # or underlying coins, and use the result as an index in `gas_estimate_values`\r\n    # 0 == wrapped   1 == underlying\r\n    idx_underlying: uint256 = self._get_coin_indices(_pool, _from, _to)[2]\r\n\r\n    total: uint256 = self.gas_estimate_values[_pool][idx_underlying]\r\n    assert total != 0  # dev: pool value not set\r\n\r\n    for addr in [_from, _to]:\r\n        _gas: uint256 = self.gas_estimate_values[addr][0]\r\n        assert _gas != 0  # dev: coin value not set\r\n        total += _gas\r\n\r\n    return total\r\n\r\n@view\r\n@external\r\ndef is_meta(_pool: address) -> bool:\r\n    \"\"\"\r\n    @notice Verify `_pool` is a metapool\r\n    @param _pool Pool address\r\n    @return True if `_pool` is a metapool\r\n    \"\"\"\r\n    return self.pool_data[_pool].base_pool != ZERO_ADDRESS\r\n\r\n\r\n@view\r\n@external\r\ndef get_pool_name(_pool: address) -> String[64]:\r\n    \"\"\"\r\n    @notice Get the given name for a pool\r\n    @param _pool Pool address\r\n    @return The name of a pool\r\n    \"\"\"\r\n    return self.pool_data[_pool].name\r\n\r\n\r\n@view\r\n@external\r\ndef get_coin_swap_count(_coin: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of unique coins available to swap `_coin` against\r\n    @param _coin Coin address\r\n    @return The number of unique coins available to swap for\r\n    \"\"\"\r\n    return self.coins[_coin].swap_count\r\n\r\n\r\n@view\r\n@external\r\ndef get_coin_swap_complement(_coin: address, _index: uint256) -> address:\r\n    \"\"\"\r\n    @notice Get the coin available to swap against `_coin` at `_index`\r\n    @param _coin Coin address\r\n    @param _index An index in the `_coin`'s set of available counter\r\n        coin's\r\n    @return Address of a coin available to swap against `_coin`\r\n    \"\"\"\r\n    return self.coins[_coin].swap_for[_index]\r\n\r\n\r\n@view\r\n@external\r\ndef get_pool_asset_type(_pool: address) -> uint256:\r\n    \"\"\"\r\n    @notice Query the asset type of `_pool`\r\n    @param _pool Pool Address\r\n    @return The asset type as an unstripped string\r\n    \"\"\"\r\n    return self.pool_data[_pool].asset_type\r\n\r\n\r\n# internal functionality used in admin setters\r\n\r\n@internal\r\ndef _add_pool(\r\n    _sender: address,\r\n    _pool: address,\r\n    _n_coins: uint256,\r\n    _lp_token: address,\r\n    _rate_info: bytes32,\r\n    _has_initial_A: bool,\r\n    _is_v1: bool,\r\n    _name: String[64],\r\n):\r\n    assert _sender == self.address_provider.admin()  # dev: admin-only function\r\n    assert _lp_token != ZERO_ADDRESS\r\n    assert self.pool_data[_pool].coins[0] == ZERO_ADDRESS  # dev: pool exists\r\n    assert self.get_pool_from_lp_token[_lp_token] == ZERO_ADDRESS\r\n\r\n    # add pool to pool_list\r\n    length: uint256 = self.pool_count\r\n    self.pool_list[length] = _pool\r\n    self.pool_count = length + 1\r\n    self.pool_data[_pool].location = length\r\n    self.pool_data[_pool].rate_info = _rate_info\r\n    self.pool_data[_pool].has_initial_A = _has_initial_A\r\n    self.pool_data[_pool].is_v1 = _is_v1\r\n    self.pool_data[_pool].n_coins = _n_coins\r\n    self.pool_data[_pool].name = _name\r\n\r\n    # update public mappings\r\n    self.get_pool_from_lp_token[_lp_token] = _pool\r\n    self.get_lp_token[_pool] = _lp_token\r\n    self.last_updated = block.timestamp\r\n\r\n    log PoolAdded(_pool, slice(_rate_info, 28, 4))\r\n\r\n\r\n@internal\r\ndef _register_coin(_coin: address):\r\n    if self.coins[_coin].register_count == 0:\r\n        coin_count: uint256 = self.coin_count\r\n        self.coins[_coin].index = coin_count\r\n        self.get_coin[coin_count] = _coin\r\n        self.coin_count += 1\r\n    self.coins[_coin].register_count += 1\r\n\r\n\r\n@internal\r\ndef _register_coin_pair(_coina: address, _coinb: address, _key: uint256):\r\n    # register _coinb in _coina's array of coins\r\n    coin_b_pos: uint256 = self.coins[_coina].swap_count\r\n    self.coins[_coina].swap_for[coin_b_pos] = _coinb\r\n    self.coins[_coina].swap_count += 1\r\n    # register _coina in _coinb's array of coins\r\n    coin_a_pos: uint256 = self.coins[_coinb].swap_count\r\n    self.coins[_coinb].swap_for[coin_a_pos] = _coina\r\n    self.coins[_coinb].swap_count += 1\r\n    # register indexes (coina pos in coinb array, coinb pos in coina array)\r\n    if convert(_coina, uint256) < convert(_coinb, uint256): \r\n        self.coin_swap_indexes[_key] = shift(coin_a_pos, 128) + coin_b_pos\r\n    else:\r\n        self.coin_swap_indexes[_key] = shift(coin_b_pos, 128) + coin_a_pos\r\n\r\n\r\n@internal\r\ndef _unregister_coin(_coin: address):\r\n    self.coins[_coin].register_count -= 1\r\n\r\n    if self.coins[_coin].register_count == 0:\r\n        self.coin_count -= 1\r\n        coin_count: uint256 = self.coin_count\r\n        location: uint256 = self.coins[_coin].index\r\n\r\n        if location < coin_count:\r\n            coin_b: address = self.get_coin[coin_count]\r\n            self.get_coin[location] = coin_b\r\n            self.coins[coin_b].index = location\r\n\r\n        self.coins[_coin].index = 0\r\n        self.get_coin[coin_count] = ZERO_ADDRESS\r\n\r\n\r\n@internal\r\ndef _unregister_coin_pair(_coina: address, _coinb: address, _coinb_idx: uint256):\r\n    \"\"\"\r\n    @param _coinb_idx the index of _coinb in _coina's array of unique coin's \r\n    \"\"\"\r\n    # decrement swap counts for both coins\r\n    self.coins[_coina].swap_count -= 1\r\n\r\n    # retrieve the last currently occupied index in coina's array\r\n    coina_arr_last_idx: uint256 = self.coins[_coina].swap_count\r\n\r\n    # if coinb's index in coina's array is less than the last\r\n    # overwrite it's position with the last coin\r\n    if _coinb_idx < coina_arr_last_idx:\r\n        # here's our last coin in coina's array\r\n        coin_c: address = self.coins[_coina].swap_for[coina_arr_last_idx]\r\n        # get the bitwise_xor of the pair to retrieve their indexes\r\n        key: uint256 = bitwise_xor(convert(_coina, uint256), convert(coin_c, uint256))\r\n        indexes: uint256 = self.coin_swap_indexes[key]\r\n\r\n        # update the pairing's indexes\r\n        if convert(_coina, uint256) < convert(coin_c, uint256):\r\n            # least complicated most readable way of shifting twice to remove the lower order bits\r\n            self.coin_swap_indexes[key] = shift(shift(indexes, -128), 128) + _coinb_idx\r\n        else:\r\n            self.coin_swap_indexes[key] = shift(_coinb_idx, 128) + indexes % 2 ** 128\r\n        # set _coinb_idx in coina's array to coin_c\r\n        self.coins[_coina].swap_for[_coinb_idx] = coin_c\r\n\r\n    self.coins[_coina].swap_for[coina_arr_last_idx] = ZERO_ADDRESS\r\n\r\n\r\n@internal\r\ndef _get_new_pool_coins(\r\n    _pool: address,\r\n    _n_coins: uint256,\r\n    _is_underlying: bool,\r\n    _is_v1: bool\r\n) -> address[MAX_COINS]:\r\n    coin_list: address[MAX_COINS] = empty(address[MAX_COINS])\r\n    coin: address = ZERO_ADDRESS\r\n    for i in range(MAX_COINS):\r\n        if i == _n_coins:\r\n            break\r\n        if _is_underlying:\r\n            if _is_v1:\r\n                coin = CurvePoolV1(_pool).underlying_coins(convert(i, int128))\r\n            else:\r\n                coin = CurvePool(_pool).underlying_coins(i)\r\n            self.pool_data[_pool].ul_coins[i] = coin\r\n        else:\r\n            if _is_v1:\r\n                coin = CurvePoolV1(_pool).coins(convert(i, int128))\r\n            else:\r\n                coin = CurvePool(_pool).coins(i)\r\n            self.pool_data[_pool].coins[i] = coin\r\n        coin_list[i] = coin\r\n\r\n    for i in range(MAX_COINS):\r\n        if i == _n_coins:\r\n            break\r\n\r\n        self._register_coin(coin_list[i])\r\n        # add pool to markets\r\n        i2: uint256 = i + 1\r\n        for x in range(i2, i2 + MAX_COINS):\r\n            if x == _n_coins:\r\n                break\r\n\r\n            key: uint256 = bitwise_xor(convert(coin_list[i], uint256), convert(coin_list[x], uint256))\r\n            length: uint256 = self.market_counts[key]\r\n            self.markets[key][length] = _pool\r\n            self.market_counts[key] = length + 1\r\n\r\n            # register the coin pair\r\n            if length == 0:\r\n                self._register_coin_pair(coin_list[x], coin_list[i], key)\r\n\r\n    return coin_list\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_new_pool_decimals(_coins: address[MAX_COINS], _n_coins: uint256) -> uint256:\r\n    packed: uint256 = 0\r\n    value: uint256 = 0\r\n\r\n    n_coins: int128 = convert(_n_coins, int128)\r\n    for i in range(MAX_COINS):\r\n        if i == n_coins:\r\n            break\r\n        coin: address = _coins[i]\r\n        if coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            value = 18\r\n        else:\r\n            value = ERC20(coin).decimals()\r\n            assert value < 256  # dev: decimal overflow\r\n\r\n        packed += shift(value, i * 8)\r\n\r\n    return packed\r\n\r\n\r\n@internal\r\ndef _remove_market(_pool: address, _coina: address, _coinb: address):\r\n    key: uint256 = bitwise_xor(convert(_coina, uint256), convert(_coinb, uint256))\r\n    length: uint256 = self.market_counts[key] - 1\r\n    if length == 0:\r\n        indexes: uint256 = self.coin_swap_indexes[key]\r\n        if convert(_coina, uint256) < convert(_coinb, uint256):\r\n            self._unregister_coin_pair(_coina, _coinb, indexes % 2 ** 128)\r\n            self._unregister_coin_pair(_coinb, _coina, shift(indexes, -128))\r\n        else:\r\n            self._unregister_coin_pair(_coina, _coinb, shift(indexes, -128))\r\n            self._unregister_coin_pair(_coinb, _coina, indexes % 2 ** 128)\r\n        self.coin_swap_indexes[key] = 0\r\n    for i in range(65536):\r\n        if i > length:\r\n            break\r\n        if self.markets[key][i] == _pool:\r\n            if i < length:\r\n                self.markets[key][i] = self.markets[key][length]\r\n            self.markets[key][length] = ZERO_ADDRESS\r\n            self.market_counts[key] = length\r\n            break\r\n\r\n\r\n# admin functions\r\n\r\n@external\r\ndef add_pool(\r\n    _pool: address,\r\n    _n_coins: uint256,\r\n    _lp_token: address,\r\n    _rate_info: bytes32,\r\n    _decimals: uint256,\r\n    _underlying_decimals: uint256,\r\n    _has_initial_A: bool,\r\n    _is_v1: bool,\r\n    _name: String[64],\r\n):\r\n    \"\"\"\r\n    @notice Add a pool to the registry\r\n    @dev Only callable by admin\r\n    @param _pool Pool address to add\r\n    @param _n_coins Number of coins in the pool\r\n    @param _lp_token Pool deposit token address\r\n    @param _rate_info Encoded twenty-byte rate calculator address and/or four-byte\r\n        function signature to query coin rates\r\n    @param _decimals Coin decimal values, tightly packed as uint8 in a little-endian bytes32\r\n    @param _underlying_decimals Underlying coin decimal values, tightly packed\r\n                                as uint8 in a little-endian bytes32\r\n    @param _name The name of the pool\r\n    \"\"\"\r\n    self._add_pool(\r\n        msg.sender,\r\n        _pool,\r\n        _n_coins + shift(_n_coins, 128),\r\n        _lp_token,\r\n        _rate_info,\r\n        _has_initial_A,\r\n        _is_v1,\r\n        _name,\r\n    )\r\n\r\n    coins: address[MAX_COINS] = self._get_new_pool_coins(_pool, _n_coins, False, _is_v1)\r\n    decimals: uint256 = _decimals\r\n    if decimals == 0:\r\n        decimals = self._get_new_pool_decimals(coins, _n_coins)\r\n    self.pool_data[_pool].decimals = decimals\r\n\r\n    coins = self._get_new_pool_coins(_pool, _n_coins, True, _is_v1)\r\n    decimals = _underlying_decimals\r\n    if decimals == 0:\r\n        decimals = self._get_new_pool_decimals(coins, _n_coins)\r\n    self.pool_data[_pool].underlying_decimals = decimals\r\n\r\n\r\n@external\r\ndef add_pool_without_underlying(\r\n    _pool: address,\r\n    _n_coins: uint256,\r\n    _lp_token: address,\r\n    _rate_info: bytes32,\r\n    _decimals: uint256,\r\n    _use_rates: uint256,\r\n    _has_initial_A: bool,\r\n    _is_v1: bool,\r\n    _name: String[64],\r\n):\r\n    \"\"\"\r\n    @notice Add a pool to the registry\r\n    @dev Only callable by admin\r\n    @param _pool Pool address to add\r\n    @param _n_coins Number of coins in the pool\r\n    @param _lp_token Pool deposit token address\r\n    @param _rate_info Encoded twenty-byte rate calculator address and/or four-byte\r\n        function signature to query coin rates\r\n    @param _decimals Coin decimal values, tightly packed as uint8 in a little-endian bytes32\r\n    @param _use_rates Boolean array indicating which coins use lending rates,\r\n                      tightly packed in a little-endian bytes32\r\n    @param _name The name of the pool\r\n    \"\"\"\r\n    self._add_pool(\r\n        msg.sender,\r\n        _pool,\r\n        _n_coins + shift(_n_coins, 128),\r\n        _lp_token,\r\n        _rate_info,\r\n        _has_initial_A,\r\n        _is_v1,\r\n        _name,\r\n    )\r\n\r\n    coins: address[MAX_COINS] = self._get_new_pool_coins(_pool, _n_coins, False, _is_v1)\r\n\r\n    decimals: uint256 = _decimals\r\n    if decimals == 0:\r\n        decimals = self._get_new_pool_decimals(coins, _n_coins)\r\n    self.pool_data[_pool].decimals = decimals\r\n\r\n    udecimals: uint256 = 0\r\n    for i in range(MAX_COINS):\r\n        if i == _n_coins:\r\n            break\r\n        offset: int128 = -8 * convert(i, int128)\r\n        if shift(_use_rates, offset) % 256 == 0:\r\n            self.pool_data[_pool].ul_coins[i] = coins[i]\r\n            udecimals += shift(shift(decimals, offset) % 256, -offset)\r\n\r\n    self.pool_data[_pool].underlying_decimals = udecimals\r\n\r\n\r\n@external\r\ndef add_metapool(\r\n    _pool: address,\r\n    _n_coins: uint256,\r\n    _lp_token: address,\r\n    _decimals: uint256,\r\n    _name: String[64],\r\n    _base_pool: address = ZERO_ADDRESS\r\n):\r\n    \"\"\"\r\n    @notice Add a pool to the registry\r\n    @dev Only callable by admin\r\n    @param _pool Pool address to add\r\n    @param _n_coins Number of coins in the pool\r\n    @param _lp_token Pool deposit token address\r\n    @param _decimals Coin decimal values, tightly packed as uint8 in a little-endian bytes32\r\n    @param _name The name of the pool\r\n    @param _base_pool Address of the base_pool useful for adding factory pools\r\n    \"\"\"\r\n    base_coin_offset: uint256 = _n_coins - 1\r\n\r\n    base_pool: address = _base_pool\r\n    if base_pool == ZERO_ADDRESS:\r\n        base_pool = CurveMetapool(_pool).base_pool()\r\n    base_n_coins: uint256 = shift(self.pool_data[base_pool].n_coins, -128)\r\n    assert base_n_coins > 0  # dev: base pool unknown\r\n\r\n    self._add_pool(\r\n        msg.sender,\r\n        _pool,\r\n        base_n_coins + base_coin_offset + shift(_n_coins, 128),\r\n        _lp_token,\r\n        EMPTY_BYTES32,\r\n        True,\r\n        False,\r\n        _name,\r\n    )\r\n\r\n    coins: address[MAX_COINS] = self._get_new_pool_coins(_pool, _n_coins, False, False)\r\n\r\n    decimals: uint256 = _decimals\r\n    if decimals == 0:\r\n        decimals = self._get_new_pool_decimals(coins, _n_coins)\r\n\r\n    self.pool_data[_pool].decimals = decimals\r\n    self.pool_data[_pool].base_pool = base_pool\r\n\r\n    base_coins: address[MAX_COINS] = empty(address[MAX_COINS])\r\n    coin: address = ZERO_ADDRESS\r\n    for i in range(MAX_COINS):\r\n        if i == base_n_coins + base_coin_offset:\r\n            break\r\n        if i < base_coin_offset:\r\n            coin = coins[i]\r\n        else:\r\n            x: uint256 = i - base_coin_offset\r\n            coin = self.pool_data[base_pool].coins[x]\r\n            base_coins[x] = coin\r\n            self._register_coin(base_coins[x])\r\n        self.pool_data[_pool].ul_coins[i] = coin\r\n\r\n    underlying_decimals: uint256 = shift(\r\n        self.pool_data[base_pool].decimals, 8 * convert(base_coin_offset, int128)\r\n    )\r\n    underlying_decimals += decimals % 256 ** base_coin_offset\r\n\r\n    self.pool_data[_pool].underlying_decimals = underlying_decimals\r\n\r\n    for i in range(MAX_COINS):\r\n        if i == base_coin_offset:\r\n            break\r\n        for x in range(MAX_COINS):\r\n            if x == base_n_coins:\r\n                break\r\n            key: uint256 = bitwise_xor(convert(coins[i], uint256), convert(base_coins[x], uint256))\r\n            length: uint256 = self.market_counts[key]\r\n            self.markets[key][length] = _pool\r\n            self.market_counts[key] = length + 1\r\n\r\n            # register the coin pair\r\n            if length == 0:\r\n                self._register_coin_pair(coins[i], base_coins[x], key)\r\n\r\n\r\n@external\r\ndef remove_pool(_pool: address):\r\n    \"\"\"\r\n    @notice Remove a pool to the registry\r\n    @dev Only callable by admin\r\n    @param _pool Pool address to remove\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n    assert self.pool_data[_pool].coins[0] != ZERO_ADDRESS  # dev: pool does not exist\r\n\r\n\r\n    self.get_pool_from_lp_token[self.get_lp_token[_pool]] = ZERO_ADDRESS\r\n    self.get_lp_token[_pool] = ZERO_ADDRESS\r\n\r\n    # remove _pool from pool_list\r\n    location: uint256 = self.pool_data[_pool].location\r\n    length: uint256 = self.pool_count - 1\r\n\r\n    if location < length:\r\n        # replace _pool with final value in pool_list\r\n        addr: address = self.pool_list[length]\r\n        self.pool_list[location] = addr\r\n        self.pool_data[addr].location = location\r\n\r\n    # delete final pool_list value\r\n    self.pool_list[length] = ZERO_ADDRESS\r\n    self.pool_count = length\r\n\r\n    self.pool_data[_pool].underlying_decimals = 0\r\n    self.pool_data[_pool].decimals = 0\r\n    self.pool_data[_pool].n_coins = 0\r\n    self.pool_data[_pool].name = \"\"\r\n    self.pool_data[_pool].asset_type = 0\r\n\r\n    coins: address[MAX_COINS] = empty(address[MAX_COINS])\r\n    ucoins: address[MAX_COINS] = empty(address[MAX_COINS])\r\n\r\n    for i in range(MAX_COINS):\r\n        coins[i] = self.pool_data[_pool].coins[i]\r\n        ucoins[i] = self.pool_data[_pool].ul_coins[i]\r\n        if ucoins[i] == ZERO_ADDRESS and coins[i] == ZERO_ADDRESS:\r\n            break\r\n        if coins[i] != ZERO_ADDRESS:\r\n            # delete coin address from pool_data\r\n            self.pool_data[_pool].coins[i] = ZERO_ADDRESS\r\n            self._unregister_coin(coins[i])\r\n        if ucoins[i] != ZERO_ADDRESS:\r\n            # delete underlying_coin from pool_data\r\n            self.pool_data[_pool].ul_coins[i] = ZERO_ADDRESS\r\n            if self.coins[ucoins[i]].register_count != 0:\r\n                self._unregister_coin(ucoins[i])\r\n\r\n    is_meta: bool = self.pool_data[_pool].base_pool != ZERO_ADDRESS\r\n    for i in range(MAX_COINS):\r\n        coin: address = coins[i]\r\n        ucoin: address = ucoins[i]\r\n        if coin == ZERO_ADDRESS:\r\n            break\r\n\r\n        # remove pool from markets\r\n        i2: uint256 = i + 1\r\n        for x in range(i2, i2 + MAX_COINS):\r\n            ucoinx: address = ucoins[x]\r\n            if ucoinx == ZERO_ADDRESS:\r\n                break\r\n\r\n            coinx: address = coins[x]\r\n            if coinx != ZERO_ADDRESS:\r\n                self._remove_market(_pool, coin, coinx)\r\n\r\n            if coin != ucoin or coinx != ucoinx:\r\n                self._remove_market(_pool, ucoin, ucoinx)\r\n\r\n            if is_meta and not ucoin in coins:\r\n                key: uint256 = bitwise_xor(convert(ucoin, uint256), convert(ucoinx, uint256))\r\n                self._register_coin_pair(ucoin, ucoinx, key)\r\n\r\n    self.pool_data[_pool].base_pool = ZERO_ADDRESS\r\n    self.last_updated = block.timestamp\r\n    log PoolRemoved(_pool)\r\n\r\n\r\n@external\r\ndef set_pool_gas_estimates(_addr: address[5], _amount: uint256[2][5]):\r\n    \"\"\"\r\n    @notice Set gas estimate amounts\r\n    @param _addr Array of pool addresses\r\n    @param _amount Array of gas estimate amounts as `[(wrapped, underlying), ..]`\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    for i in range(5):\r\n        _pool: address = _addr[i]\r\n        if _pool == ZERO_ADDRESS:\r\n            break\r\n        self.gas_estimate_values[_pool] = _amount[i]\r\n    self.last_updated = block.timestamp\r\n\r\n\r\n@external\r\ndef set_coin_gas_estimates(_addr: address[10], _amount: uint256[10]):\r\n    \"\"\"\r\n    @notice Set gas estimate amounts\r\n    @param _addr Array of coin addresses\r\n    @param _amount Array of gas estimate amounts\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    for i in range(10):\r\n        _coin: address = _addr[i]\r\n        if _coin == ZERO_ADDRESS:\r\n            break\r\n        self.gas_estimate_values[_coin][0] = _amount[i]\r\n    self.last_updated = block.timestamp\r\n\r\n\r\n@external\r\ndef set_gas_estimate_contract(_pool: address, _estimator: address):\r\n    \"\"\"\r\n    @notice Set gas estimate contract\r\n    @param _pool Pool address\r\n    @param _estimator GasEstimator address\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    self.gas_estimate_contracts[_pool] = _estimator\r\n    self.last_updated = block.timestamp\r\n\r\n\r\n@external\r\ndef set_liquidity_gauges(_pool: address, _liquidity_gauges: address[10]):\r\n    \"\"\"\r\n    @notice Set liquidity gauge contracts``\r\n    @param _pool Pool address\r\n    @param _liquidity_gauges Liquidity gauge address\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    _lp_token: address = self.get_lp_token[_pool]\r\n    _gauge_controller: address = self.gauge_controller\r\n    for i in range(10):\r\n        _gauge: address = _liquidity_gauges[i]\r\n        if _gauge != ZERO_ADDRESS:\r\n            assert LiquidityGauge(_gauge).lp_token() == _lp_token  # dev: wrong token\r\n            GaugeController(_gauge_controller).gauge_types(_gauge)\r\n            self.liquidity_gauges[_pool][i] = _gauge\r\n        elif self.liquidity_gauges[_pool][i] != ZERO_ADDRESS:\r\n            self.liquidity_gauges[_pool][i] = ZERO_ADDRESS\r\n        else:\r\n            break\r\n    self.last_updated = block.timestamp\r\n\r\n\r\n@external\r\ndef set_pool_asset_type(_pool: address, _asset_type: uint256):\r\n    \"\"\"\r\n    @notice Set the asset type name for a curve pool\r\n    @dev This is a simple way to setting the cache of categories instead of\r\n        performing some computation for no reason. Pool's don't necessarily\r\n        change once they are deployed.\r\n    @param _pool Pool address\r\n    @param _asset_type String of asset type\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    self.pool_data[_pool].asset_type = _asset_type\r\n    self.last_updated = block.timestamp\r\n\r\n\r\n@external\r\ndef batch_set_pool_asset_type(_pools: address[32], _asset_types: uint256[32]):\r\n    \"\"\"\r\n    @notice Batch set the asset type name for curve pools\r\n    @dev This is a simple way of setting the cache of categories instead of\r\n        performing some computation for no reason. Pool's don't necessarily\r\n        change once they are deployed.\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    for i in range(32):\r\n        if _pools[i] == ZERO_ADDRESS:\r\n            break\r\n        self.pool_data[_pools[i]].asset_type = _asset_types[i]\r\n    self.last_updated = block.timestamp","ABI":"[{\"name\":\"PoolAdded\",\"inputs\":[{\"name\":\"pool\",\"type\":\"address\",\"indexed\":true},{\"name\":\"rate_method_id\",\"type\":\"bytes\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PoolRemoved\",\"inputs\":[{\"name\":\"pool\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_address_provider\",\"type\":\"address\"},{\"name\":\"_gauge_controller\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"find_pool_for_coins\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"find_pool_for_coins\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_n_coins\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}],\"gas\":1521},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_coins\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address[8]\"}],\"gas\":12102},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_underlying_coins\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address[8]\"}],\"gas\":12194},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_decimals\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[8]\"}],\"gas\":7874},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_underlying_decimals\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[8]\"}],\"gas\":7966},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_rates\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[8]\"}],\"gas\":36992},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_gauges\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address[10]\"},{\"name\":\"\",\"type\":\"int128[10]\"}],\"gas\":20157},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_balances\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[8]\"}],\"gas\":16583},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_underlying_balances\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[8]\"}],\"gas\":162842},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_virtual_price_from_lp_token\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":1927},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_A\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":1045},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_parameters\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"A\",\"type\":\"uint256\"},{\"name\":\"future_A\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"admin_fee\",\"type\":\"uint256\"},{\"name\":\"future_fee\",\"type\":\"uint256\"},{\"name\":\"future_admin_fee\",\"type\":\"uint256\"},{\"name\":\"future_owner\",\"type\":\"address\"},{\"name\":\"initial_A\",\"type\":\"uint256\"},{\"name\":\"initial_A_time\",\"type\":\"uint256\"},{\"name\":\"future_A_time\",\"type\":\"uint256\"}],\"gas\":6305},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_fees\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}],\"gas\":1450},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_admin_balances\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[8]\"}],\"gas\":36454},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_coin_indices\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"},{\"name\":\"\",\"type\":\"int128\"},{\"name\":\"\",\"type\":\"bool\"}],\"gas\":27131},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"estimate_gas_used\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":32004},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_meta\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":1900},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_pool_name\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":8323},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_coin_swap_count\",\"inputs\":[{\"name\":\"_coin\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":1951},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_coin_swap_complement\",\"inputs\":[{\"name\":\"_coin\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2090},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_pool_asset_type\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2011},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_pool\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_n_coins\",\"type\":\"uint256\"},{\"name\":\"_lp_token\",\"type\":\"address\"},{\"name\":\"_rate_info\",\"type\":\"bytes32\"},{\"name\":\"_decimals\",\"type\":\"uint256\"},{\"name\":\"_underlying_decimals\",\"type\":\"uint256\"},{\"name\":\"_has_initial_A\",\"type\":\"bool\"},{\"name\":\"_is_v1\",\"type\":\"bool\"},{\"name\":\"_name\",\"type\":\"string\"}],\"outputs\":[],\"gas\":61485845},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_pool_without_underlying\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_n_coins\",\"type\":\"uint256\"},{\"name\":\"_lp_token\",\"type\":\"address\"},{\"name\":\"_rate_info\",\"type\":\"bytes32\"},{\"name\":\"_decimals\",\"type\":\"uint256\"},{\"name\":\"_use_rates\",\"type\":\"uint256\"},{\"name\":\"_has_initial_A\",\"type\":\"bool\"},{\"name\":\"_is_v1\",\"type\":\"bool\"},{\"name\":\"_name\",\"type\":\"string\"}],\"outputs\":[],\"gas\":31306062},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_metapool\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_n_coins\",\"type\":\"uint256\"},{\"name\":\"_lp_token\",\"type\":\"address\"},{\"name\":\"_decimals\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_metapool\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_n_coins\",\"type\":\"uint256\"},{\"name\":\"_lp_token\",\"type\":\"address\"},{\"name\":\"_decimals\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_base_pool\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_pool\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[],\"gas\":779731418758},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_pool_gas_estimates\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address[5]\"},{\"name\":\"_amount\",\"type\":\"uint256[2][5]\"}],\"outputs\":[],\"gas\":390460},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_coin_gas_estimates\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address[10]\"},{\"name\":\"_amount\",\"type\":\"uint256[10]\"}],\"outputs\":[],\"gas\":392047},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_gas_estimate_contract\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_estimator\",\"type\":\"address\"}],\"outputs\":[],\"gas\":72629},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_liquidity_gauges\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_liquidity_gauges\",\"type\":\"address[10]\"}],\"outputs\":[],\"gas\":400675},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_pool_asset_type\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_asset_type\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":72667},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"batch_set_pool_asset_type\",\"inputs\":[{\"name\":\"_pools\",\"type\":\"address[32]\"},{\"name\":\"_asset_types\",\"type\":\"uint256[32]\"}],\"outputs\":[],\"gas\":1173447},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"address_provider\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2048},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge_controller\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2078},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pool_list\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2217},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pool_count\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2138},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"coin_count\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2168},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_coin\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2307},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_pool_from_lp_token\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2443},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_lp_token\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2473},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_updated\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2288}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.11","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000000000000022d53366457f9d5e68ec105046fc43830000000000000000000000002f50d538606fa9edd2b11e2446beb18c9d5846bb","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}