{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\r\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\r\n// representation. When it does not, it is annonated in the function's NatSpec documentation.\r\nlibrary PRBMathCommon {\r\n\t/// @dev How many trailing decimals can be represented.\r\n\tuint256 internal constant SCALE = 1e18;\r\n\r\n\t/// @dev Largest power of two divisor of SCALE.\r\n\tuint256 internal constant SCALE_LPOTD = 262144;\r\n\r\n\t/// @dev SCALE inverted mod 2^256.\r\n\tuint256 internal constant SCALE_INVERSE = 78156646155174841979727994598816262306175212592076161876661508869554232690281;\r\n\r\n\t/// @notice Calculates the binary exponent of x using the binary fraction method.\r\n\t/// @dev Uses 128.128-bit fixed-point numbers - it is the most efficient way.\r\n\t/// @param x The exponent as an unsigned 128.128-bit fixed-point number.\r\n\t/// @return result The result as an unsigned 60x18 decimal fixed-point number.\r\n\tfunction exp2(uint256 x) internal pure returns (uint256 result) {\r\n\t\tunchecked {\r\n\t\t\t// Start from 0.5 in the 128.128-bit fixed-point format. We need to use uint256 because the intermediary\r\n\t\t\t// may get very close to 2^256, which doesn't fit in int256.\r\n\t\t\tresult = 0x80000000000000000000000000000000;\r\n\r\n\t\t\t// Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\r\n\t\t\t// because the initial result is 2^127 and all magic factors are less than 2^129.\r\n\t\t\tif (x & 0x80000000000000000000000000000000 > 0) result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\r\n\t\t\tif (x & 0x40000000000000000000000000000000 > 0) result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDED) >> 128;\r\n\t\t\tif (x & 0x20000000000000000000000000000000 > 0) result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A7920) >> 128;\r\n\t\t\tif (x & 0x10000000000000000000000000000000 > 0) result = (result * 0x10B5586CF9890F6298B92B71842A98364) >> 128;\r\n\t\t\tif (x & 0x8000000000000000000000000000000 > 0) result = (result * 0x1059B0D31585743AE7C548EB68CA417FE) >> 128;\r\n\t\t\tif (x & 0x4000000000000000000000000000000 > 0) result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE9) >> 128;\r\n\t\t\tif (x & 0x2000000000000000000000000000000 > 0) result = (result * 0x10163DA9FB33356D84A66AE336DCDFA40) >> 128;\r\n\t\t\tif (x & 0x1000000000000000000000000000000 > 0) result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9544) >> 128;\r\n\t\t\tif (x & 0x800000000000000000000000000000 > 0) result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679C) >> 128;\r\n\t\t\tif (x & 0x400000000000000000000000000000 > 0) result = (result * 0x1002C605E2E8CEC506D21BFC89A23A011) >> 128;\r\n\t\t\tif (x & 0x200000000000000000000000000000 > 0) result = (result * 0x100162F3904051FA128BCA9C55C31E5E0) >> 128;\r\n\t\t\tif (x & 0x100000000000000000000000000000 > 0) result = (result * 0x1000B175EFFDC76BA38E31671CA939726) >> 128;\r\n\t\t\tif (x & 0x80000000000000000000000000000 > 0) result = (result * 0x100058BA01FB9F96D6CACD4B180917C3E) >> 128;\r\n\t\t\tif (x & 0x40000000000000000000000000000 > 0) result = (result * 0x10002C5CC37DA9491D0985C348C68E7B4) >> 128;\r\n\t\t\tif (x & 0x20000000000000000000000000000 > 0) result = (result * 0x1000162E525EE054754457D5995292027) >> 128;\r\n\t\t\tif (x & 0x10000000000000000000000000000 > 0) result = (result * 0x10000B17255775C040618BF4A4ADE83FD) >> 128;\r\n\t\t\tif (x & 0x8000000000000000000000000000 > 0) result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAC) >> 128;\r\n\t\t\tif (x & 0x4000000000000000000000000000 > 0) result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7CA) >> 128;\r\n\t\t\tif (x & 0x2000000000000000000000000000 > 0) result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\r\n\t\t\tif (x & 0x1000000000000000000000000000 > 0) result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\r\n\t\t\tif (x & 0x800000000000000000000000000 > 0) result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1629) >> 128;\r\n\t\t\tif (x & 0x400000000000000000000000000 > 0) result = (result * 0x1000002C5C863B73F016468F6BAC5CA2C) >> 128;\r\n\t\t\tif (x & 0x200000000000000000000000000 > 0) result = (result * 0x100000162E430E5A18F6119E3C02282A6) >> 128;\r\n\t\t\tif (x & 0x100000000000000000000000000 > 0) result = (result * 0x1000000B1721835514B86E6D96EFD1BFF) >> 128;\r\n\t\t\tif (x & 0x80000000000000000000000000 > 0) result = (result * 0x100000058B90C0B48C6BE5DF846C5B2F0) >> 128;\r\n\t\t\tif (x & 0x40000000000000000000000000 > 0) result = (result * 0x10000002C5C8601CC6B9E94213C72737B) >> 128;\r\n\t\t\tif (x & 0x20000000000000000000000000 > 0) result = (result * 0x1000000162E42FFF037DF38AA2B219F07) >> 128;\r\n\t\t\tif (x & 0x10000000000000000000000000 > 0) result = (result * 0x10000000B17217FBA9C739AA5819F44FA) >> 128;\r\n\t\t\tif (x & 0x8000000000000000000000000 > 0) result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC824) >> 128;\r\n\t\t\tif (x & 0x4000000000000000000000000 > 0) result = (result * 0x100000002C5C85FE31F35A6A30DA1BE51) >> 128;\r\n\t\t\tif (x & 0x2000000000000000000000000 > 0) result = (result * 0x10000000162E42FF0999CE3541B9FFFD0) >> 128;\r\n\t\t\tif (x & 0x1000000000000000000000000 > 0) result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\r\n\t\t\tif (x & 0x800000000000000000000000 > 0) result = (result * 0x10000000058B90BFBF8479BD5A81B51AE) >> 128;\r\n\t\t\tif (x & 0x400000000000000000000000 > 0) result = (result * 0x1000000002C5C85FDF84BD62AE30A74CD) >> 128;\r\n\t\t\tif (x & 0x200000000000000000000000 > 0) result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\r\n\t\t\tif (x & 0x100000000000000000000000 > 0) result = (result * 0x1000000000B17217F7D5A7716BBA4A9AF) >> 128;\r\n\t\t\tif (x & 0x80000000000000000000000 > 0) result = (result * 0x100000000058B90BFBE9DDBAC5E109CCF) >> 128;\r\n\t\t\tif (x & 0x40000000000000000000000 > 0) result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0E) >> 128;\r\n\t\t\tif (x & 0x20000000000000000000000 > 0) result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\r\n\t\t\tif (x & 0x10000000000000000000000 > 0) result = (result * 0x10000000000B17217F7D20CF927C8E94D) >> 128;\r\n\t\t\tif (x & 0x8000000000000000000000 > 0) result = (result * 0x1000000000058B90BFBE8F71CB4E4B33E) >> 128;\r\n\t\t\tif (x & 0x4000000000000000000000 > 0) result = (result * 0x100000000002C5C85FDF477B662B26946) >> 128;\r\n\t\t\tif (x & 0x2000000000000000000000 > 0) result = (result * 0x10000000000162E42FEFA3AE53369388D) >> 128;\r\n\t\t\tif (x & 0x1000000000000000000000 > 0) result = (result * 0x100000000000B17217F7D1D351A389D41) >> 128;\r\n\t\t\tif (x & 0x800000000000000000000 > 0) result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDF) >> 128;\r\n\t\t\tif (x & 0x400000000000000000000 > 0) result = (result * 0x1000000000002C5C85FDF4741BEA6E77F) >> 128;\r\n\t\t\tif (x & 0x200000000000000000000 > 0) result = (result * 0x100000000000162E42FEFA39FE95583C3) >> 128;\r\n\t\t\tif (x & 0x100000000000000000000 > 0) result = (result * 0x1000000000000B17217F7D1CFB72B45E3) >> 128;\r\n\t\t\tif (x & 0x80000000000000000000 > 0) result = (result * 0x100000000000058B90BFBE8E7CC35C3F2) >> 128;\r\n\t\t\tif (x & 0x40000000000000000000 > 0) result = (result * 0x10000000000002C5C85FDF473E242EA39) >> 128;\r\n\t\t\tif (x & 0x20000000000000000000 > 0) result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;\r\n\t\t\tif (x & 0x10000000000000000000 > 0) result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\r\n\t\t\tif (x & 0x8000000000000000000 > 0) result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\r\n\t\t\tif (x & 0x4000000000000000000 > 0) result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;\r\n\t\t\tif (x & 0x2000000000000000000 > 0) result = (result * 0x10000000000000162E42FEFA39EF44D92) >> 128;\r\n\t\t\tif (x & 0x1000000000000000000 > 0) result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;\r\n\t\t\tif (x & 0x800000000000000000 > 0) result = (result * 0x10000000000000058B90BFBE8E7BCE545) >> 128;\r\n\t\t\tif (x & 0x400000000000000000 > 0) result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\r\n\t\t\tif (x & 0x200000000000000000 > 0) result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;\r\n\t\t\tif (x & 0x100000000000000000 > 0) result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\r\n\t\t\tif (x & 0x80000000000000000 > 0) result = (result * 0x100000000000000058B90BFBE8E7BCD6E) >> 128;\r\n\t\t\tif (x & 0x40000000000000000 > 0) result = (result * 0x10000000000000002C5C85FDF473DE6B3) >> 128;\r\n\t\t\tif (x & 0x20000000000000000 > 0) result = (result * 0x1000000000000000162E42FEFA39EF359) >> 128;\r\n\t\t\tif (x & 0x10000000000000000 > 0) result = (result * 0x10000000000000000B17217F7D1CF79AC) >> 128;\r\n\r\n\t\t\t// Multiply the result by the integer part 2^n + 1. We have to shift by one bit extra because we have already divided\r\n\t\t\t// by two when we set the result equal to 0.5 above.\r\n\t\t\tresult = result << ((x >> 128) + 1);\r\n\r\n\t\t\t// Convert the result to the signed 60.18-decimal fixed-point format.\r\n\t\t\tresult = PRBMathCommon.mulDiv(result, 1e18, 2**128);\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Finds the zero-based index of the first one in the binary representation of x.\r\n\t/// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\r\n\t/// @param x The uint256 number for which to find the index of the most significant bit.\r\n\t/// @return msb The index of the most significant bit as an uint256.\r\n\tfunction mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\r\n\t\tif (x >= 2**128) {\r\n\t\t\tx >>= 128;\r\n\t\t\tmsb += 128;\r\n\t\t}\r\n\t\tif (x >= 2**64) {\r\n\t\t\tx >>= 64;\r\n\t\t\tmsb += 64;\r\n\t\t}\r\n\t\tif (x >= 2**32) {\r\n\t\t\tx >>= 32;\r\n\t\t\tmsb += 32;\r\n\t\t}\r\n\t\tif (x >= 2**16) {\r\n\t\t\tx >>= 16;\r\n\t\t\tmsb += 16;\r\n\t\t}\r\n\t\tif (x >= 2**8) {\r\n\t\t\tx >>= 8;\r\n\t\t\tmsb += 8;\r\n\t\t}\r\n\t\tif (x >= 2**4) {\r\n\t\t\tx >>= 4;\r\n\t\t\tmsb += 4;\r\n\t\t}\r\n\t\tif (x >= 2**2) {\r\n\t\t\tx >>= 2;\r\n\t\t\tmsb += 2;\r\n\t\t}\r\n\t\tif (x >= 2**1) {\r\n\t\t\t// No need to shift x any more.\r\n\t\t\tmsb += 1;\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Calculates floor(x*y÷denominator) with full precision.\r\n\t///\r\n\t/// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\r\n\t///\r\n\t/// Requirements:\r\n\t/// - The denominator cannot be zero.\r\n\t/// - The result must fit within uint256.\r\n\t///\r\n\t/// Caveats:\r\n\t/// - This function does not work with fixed-point numbers.\r\n\t///\r\n\t/// @param x The multiplicand as an uint256.\r\n\t/// @param y The multiplier as an uint256.\r\n\t/// @param denominator The divisor as an uint256.\r\n\t/// @return result The result as an uint256.\r\n\tfunction mulDiv(\r\n\t\tuint256 x,\r\n\t\tuint256 y,\r\n\t\tuint256 denominator\r\n\t) internal pure returns (uint256 result) {\r\n\t\t// 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2**256 and mod 2**256 - 1, then use\r\n\t\t// use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n\t\t// variables such that product = prod1 * 2**256 + prod0.\r\n\t\tuint256 prod0; // Least significant 256 bits of the product\r\n\t\tuint256 prod1; // Most significant 256 bits of the product\r\n\t\tassembly {\r\n\t\t\tlet mm := mulmod(x, y, not(0))\r\n\t\t\tprod0 := mul(x, y)\r\n\t\t\tprod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n\t\t}\r\n\r\n\t\t// Handle non-overflow cases, 256 by 256 division\r\n\t\tif (prod1 == 0) {\r\n\t\t\trequire(denominator > 0);\r\n\t\t\tassembly {\r\n\t\t\t\tresult := div(prod0, denominator)\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\t// Make sure the result is less than 2**256. Also prevents denominator == 0.\r\n\t\trequire(denominator > prod1);\r\n\r\n\t\t///////////////////////////////////////////////\r\n\t\t// 512 by 256 division.\r\n\t\t///////////////////////////////////////////////\r\n\r\n\t\t// Make division exact by subtracting the remainder from [prod1 prod0].\r\n\t\tuint256 remainder;\r\n\t\tassembly {\r\n\t\t\t// Compute remainder using mulmod.\r\n\t\t\tremainder := mulmod(x, y, denominator)\r\n\r\n\t\t\t// Subtract 256 bit number from 512 bit number\r\n\t\t\tprod1 := sub(prod1, gt(remainder, prod0))\r\n\t\t\tprod0 := sub(prod0, remainder)\r\n\t\t}\r\n\r\n\t\t// Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n\t\t// See https://cs.stackexchange.com/q/138556/92363.\r\n\t\tunchecked {\r\n\t\t\t// Does not overflow because the denominator cannot be zero at this stage in the function.\r\n\t\t\tuint256 lpotdod = denominator & (~denominator + 1);\r\n\t\t\tassembly {\r\n\t\t\t\t// Divide denominator by lpotdod.\r\n\t\t\t\tdenominator := div(denominator, lpotdod)\r\n\r\n\t\t\t\t// Divide [prod1 prod0] by lpotdod.\r\n\t\t\t\tprod0 := div(prod0, lpotdod)\r\n\r\n\t\t\t\t// Flip lpotdod such that it is 2**256 / lpotdod. If lpotdod is zero, then it becomes one.\r\n\t\t\t\tlpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\r\n\t\t\t}\r\n\r\n\t\t\t// Shift in bits from prod1 into prod0.\r\n\t\t\tprod0 |= prod1 * lpotdod;\r\n\r\n\t\t\t// Invert denominator mod 2**256. Now that denominator is an odd number, it has an inverse modulo 2**256 such\r\n\t\t\t// that denominator * inv = 1 mod 2**256. Compute the inverse by starting with a seed that is correct for\r\n\t\t\t// four bits. That is, denominator * inv = 1 mod 2**4\r\n\t\t\tuint256 inverse = (3 * denominator) ^ 2;\r\n\r\n\t\t\t// Now use Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n\t\t\t// in modular arithmetic, doubling the correct bits in each step.\r\n\t\t\tinverse *= 2 - denominator * inverse; // inverse mod 2**8\r\n\t\t\tinverse *= 2 - denominator * inverse; // inverse mod 2**16\r\n\t\t\tinverse *= 2 - denominator * inverse; // inverse mod 2**32\r\n\t\t\tinverse *= 2 - denominator * inverse; // inverse mod 2**64\r\n\t\t\tinverse *= 2 - denominator * inverse; // inverse mod 2**128\r\n\t\t\tinverse *= 2 - denominator * inverse; // inverse mod 2**256\r\n\r\n\t\t\t// Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n\t\t\t// This will give us the correct result modulo 2**256. Since the precoditions guarantee that the outcome is\r\n\t\t\t// less than 2**256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n\t\t\t// is no longer required.\r\n\t\t\tresult = prod0 * inverse;\r\n\t\t\treturn result;\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Calculates floor(x*y÷1e18) with full precision.\r\n\t///\r\n\t/// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\r\n\t/// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\r\n\t/// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\r\n\t///\r\n\t/// Requirements:\r\n\t/// - The result must fit within uint256.\r\n\t///\r\n\t/// Caveats:\r\n\t/// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMathCommon.mulDiv\" to understand how this works.\r\n\t/// - It is assumed that the result can never be type(uint256).max when x and y solve the following two queations:\r\n\t///     1) x * y = type(uint256).max * SCALE\r\n\t///     2) (x * y) % SCALE >= SCALE / 2\r\n\t///\r\n\t/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\r\n\t/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\r\n\t/// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n\tfunction mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n\t\tuint256 prod0;\r\n\t\tuint256 prod1;\r\n\t\tassembly {\r\n\t\t\tlet mm := mulmod(x, y, not(0))\r\n\t\t\tprod0 := mul(x, y)\r\n\t\t\tprod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n\t\t}\r\n\r\n\t\tuint256 remainder;\r\n\t\tuint256 roundUpUnit;\r\n\t\tassembly {\r\n\t\t\tremainder := mulmod(x, y, SCALE)\r\n\t\t\troundUpUnit := gt(remainder, 499999999999999999)\r\n\t\t}\r\n\r\n\t\tif (prod1 == 0) {\r\n\t\t\tunchecked {\r\n\t\t\t\tresult = (prod0 / SCALE) + roundUpUnit;\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trequire(SCALE > prod1);\r\n\r\n\t\tassembly {\r\n\t\t\tresult := add(\r\n\t\t\t\tmul(\r\n\t\t\t\t\tor(\r\n\t\t\t\t\t\tdiv(sub(prod0, remainder), SCALE_LPOTD),\r\n\t\t\t\t\t\tmul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\r\n\t\t\t\t\t),\r\n\t\t\t\t\tSCALE_INVERSE\r\n\t\t\t\t),\r\n\t\t\t\troundUpUnit\r\n\t\t\t)\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Calculates the square root of x, rounding down.\r\n\t/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\r\n\t///\r\n\t/// Caveats:\r\n\t/// - This function does not work with fixed-point numbers.\r\n\t///\r\n\t/// @param x The uint256 number for which to calculate the square root.\r\n\t/// @return result The result as an uint256.\r\n\tfunction sqrt(uint256 x) internal pure returns (uint256 result) {\r\n\t\tif (x == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// Calculate the square root of the perfect square of a power of two that is the closest to x.\r\n\t\tuint256 xAux = uint256(x);\r\n\t\tresult = 1;\r\n\t\tif (xAux >= 0x100000000000000000000000000000000) {\r\n\t\t\txAux >>= 128;\r\n\t\t\tresult <<= 64;\r\n\t\t}\r\n\t\tif (xAux >= 0x10000000000000000) {\r\n\t\t\txAux >>= 64;\r\n\t\t\tresult <<= 32;\r\n\t\t}\r\n\t\tif (xAux >= 0x100000000) {\r\n\t\t\txAux >>= 32;\r\n\t\t\tresult <<= 16;\r\n\t\t}\r\n\t\tif (xAux >= 0x10000) {\r\n\t\t\txAux >>= 16;\r\n\t\t\tresult <<= 8;\r\n\t\t}\r\n\t\tif (xAux >= 0x100) {\r\n\t\t\txAux >>= 8;\r\n\t\t\tresult <<= 4;\r\n\t\t}\r\n\t\tif (xAux >= 0x10) {\r\n\t\t\txAux >>= 4;\r\n\t\t\tresult <<= 2;\r\n\t\t}\r\n\t\tif (xAux >= 0x8) {\r\n\t\t\tresult <<= 1;\r\n\t\t}\r\n\r\n\t\t// The operations can never overflow because the result is max 2^127 when it enters this block.\r\n\t\tunchecked {\r\n\t\t\tresult = (result + x / result) >> 1;\r\n\t\t\tresult = (result + x / result) >> 1;\r\n\t\t\tresult = (result + x / result) >> 1;\r\n\t\t\tresult = (result + x / result) >> 1;\r\n\t\t\tresult = (result + x / result) >> 1;\r\n\t\t\tresult = (result + x / result) >> 1;\r\n\t\t\tresult = (result + x / result) >> 1; // Seven iterations should be enough\r\n\t\t\tuint256 roundedDownResult = x / result;\r\n\t\t\treturn result >= roundedDownResult ? roundedDownResult : result;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/// @title PRBMathUD60x18\r\n/// @author Paul Razvan Berg\r\n/// @notice Smart contract library for advanced fixed-point math. It works with uint256 numbers considered to have 18\r\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\r\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\r\n/// maximum values permitted by the Solidity type uint256.\r\nlibrary PRBMathUD60x18 {\r\n\t/// @dev Half the SCALE number.\r\n\tuint256 internal constant HALF_SCALE = 5e17;\r\n\r\n\t/// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\r\n\tuint256 internal constant LOG2_E = 1442695040888963407;\r\n\r\n\t/// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\r\n\tuint256 internal constant MAX_UD60x18 = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\r\n\r\n\t/// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\r\n\tuint256 internal constant MAX_WHOLE_UD60x18 = 115792089237316195423570985008687907853269984665640564039457000000000000000000;\r\n\r\n\t/// @dev How many trailing decimals can be represented.\r\n\tuint256 internal constant SCALE = 1e18;\r\n\r\n\t/// @notice Calculates arithmetic average of x and y, rounding down.\r\n\t/// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\r\n\t/// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\r\n\t/// @return result The arithmetic average as an usigned 60.18-decimal fixed-point number.\r\n\tfunction avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n\t\t// The operations can never overflow.\r\n\t\tunchecked {\r\n\t\t\t// The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\r\n\t\t\t// to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\r\n\t\t\tresult = (x >> 1) + (y >> 1) + (x & y & 1);\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\r\n\t///\r\n\t/// @dev Optimised for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\r\n\t/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\r\n\t///\r\n\t/// Requirements:\r\n\t/// - x must be less than or equal to MAX_WHOLE_UD60x18.\r\n\t///\r\n\t/// @param x The unsigned 60.18-decimal fixed-point number to ceil.\r\n\t/// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\r\n\tfunction ceil(uint256 x) internal pure returns (uint256 result) {\r\n\t\trequire(x <= MAX_WHOLE_UD60x18);\r\n\t\tassembly {\r\n\t\t\t// Equivalent to \"x % SCALE\" but faster.\r\n\t\t\tlet remainder := mod(x, SCALE)\r\n\r\n\t\t\t// Equivalent to \"SCALE - remainder\" but faster.\r\n\t\t\tlet delta := sub(SCALE, remainder)\r\n\r\n\t\t\t// Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\r\n\t\t\tresult := add(x, mul(delta, gt(remainder, 0)))\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\r\n\t///\r\n\t/// @dev Uses mulDiv to enable overflow-safe multiplication and division.\r\n\t///\r\n\t/// Requirements:\r\n\t/// - y cannot be zero.\r\n\t///\r\n\t/// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\r\n\t/// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\r\n\t/// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\r\n\tfunction div(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n\t\tresult = PRBMathCommon.mulDiv(x, SCALE, y);\r\n\t}\r\n\r\n\t/// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\r\n\t/// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\r\n\tfunction e() internal pure returns (uint256 result) {\r\n\t\tresult = 2718281828459045235;\r\n\t}\r\n\r\n\t/// @notice Calculates the natural exponent of x.\r\n\t///\r\n\t/// @dev Based on the insight that e^x = 2^(x * log2(e)).\r\n\t///\r\n\t/// Requirements:\r\n\t/// - All from \"log2\".\r\n\t/// - x must be less than 88722839111672999628.\r\n\t///\r\n\t/// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\r\n\t/// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n\tfunction exp(uint256 x) internal pure returns (uint256 result) {\r\n\t\t// Without this check, the value passed to \"exp2\" would be greater than 128e18.\r\n\t\trequire(x < 88722839111672999628);\r\n\r\n\t\t// Do the fixed-point multiplication inline to save gas.\r\n\t\tunchecked {\r\n\t\t\tuint256 doubleScaleProduct = x * LOG2_E;\r\n\t\t\tresult = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Calculates the binary exponent of x using the binary fraction method.\r\n\t///\r\n\t/// @dev See https://ethereum.stackexchange.com/q/79903/24693.\r\n\t///\r\n\t/// Requirements:\r\n\t/// - x must be 128e18 or less.\r\n\t/// - The result must fit within MAX_UD60x18.\r\n\t///\r\n\t/// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\r\n\t/// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n\tfunction exp2(uint256 x) internal pure returns (uint256 result) {\r\n\t\t// 2**128 doesn't fit within the 128.128-bit format used internally in this function.\r\n\t\trequire(x < 128e18);\r\n\r\n\t\tunchecked {\r\n\t\t\t// Convert x to the 128.128-bit fixed-point format.\r\n\t\t\tuint256 x128x128 = (x << 128) / SCALE;\r\n\r\n\t\t\t// Pass x to the PRBMathCommon.exp2 function, which uses the 128.128-bit fixed-point number representation.\r\n\t\t\tresult = PRBMathCommon.exp2(x128x128);\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\r\n\t/// @dev Optimised for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\r\n\t/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\r\n\t/// @param x The unsigned 60.18-decimal fixed-point number to floor.\r\n\t/// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\r\n\tfunction floor(uint256 x) internal pure returns (uint256 result) {\r\n\t\tassembly {\r\n\t\t\t// Equivalent to \"x % SCALE\" but faster.\r\n\t\t\tlet remainder := mod(x, SCALE)\r\n\r\n\t\t\t// Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\r\n\t\t\tresult := sub(x, mul(remainder, gt(remainder, 0)))\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Yields the excess beyond the floor of x.\r\n\t/// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\r\n\t/// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\r\n\t/// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\r\n\tfunction frac(uint256 x) internal pure returns (uint256 result) {\r\n\t\tassembly {\r\n\t\t\tresult := mod(x, SCALE)\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\r\n\t///\r\n\t/// @dev Requirements:\r\n\t/// - x * y must fit within MAX_UD60x18, lest it overflows.\r\n\t///\r\n\t/// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\r\n\t/// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\r\n\t/// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n\tfunction gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n\t\tif (x == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tunchecked {\r\n\t\t\t// Checking for overflow this way is faster than letting Solidity do it.\r\n\t\t\tuint256 xy = x * y;\r\n\t\t\trequire(xy / x == y);\r\n\r\n\t\t\t// We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\r\n\t\t\t// during multiplication. See the comments within the \"sqrt\" function.\r\n\t\t\tresult = PRBMathCommon.sqrt(xy);\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Calculates 1 / x, rounding towards zero.\r\n\t///\r\n\t/// @dev Requirements:\r\n\t/// - x cannot be zero.\r\n\t///\r\n\t/// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\r\n\t/// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\r\n\tfunction inv(uint256 x) internal pure returns (uint256 result) {\r\n\t\tunchecked {\r\n\t\t\t// 1e36 is SCALE * SCALE.\r\n\t\t\tresult = 1e36 / x;\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Calculates the natural logarithm of x.\r\n\t///\r\n\t/// @dev Based on the insight that ln(x) = log2(x) / log2(e).\r\n\t///\r\n\t/// Requirements:\r\n\t/// - All from \"log2\".\r\n\t///\r\n\t/// Caveats:\r\n\t/// - All from \"log2\".\r\n\t/// - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision.\r\n\t///\r\n\t/// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\r\n\t/// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\r\n\tfunction ln(uint256 x) internal pure returns (uint256 result) {\r\n\t\t// Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\r\n\t\t// can return is 196205294292027477728.\r\n\t\tunchecked { result = (log2(x) * SCALE) / LOG2_E; }\r\n\t}\r\n\r\n\t/// @notice Calculates the common logarithm of x.\r\n\t///\r\n\t/// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\r\n\t/// logarithm based on the insight that log10(x) = log2(x) / log2(10).\r\n\t///\r\n\t/// Requirements:\r\n\t/// - All from \"log2\".\r\n\t///\r\n\t/// Caveats:\r\n\t/// - All from \"log2\".\r\n\t///\r\n\t/// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\r\n\t/// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\r\n\tfunction log10(uint256 x) internal pure returns (uint256 result) {\r\n\t\trequire(x >= SCALE);\r\n\r\n\t\t// Note that the \"mul\" in this block is the assembly mul operation, not the \"mul\" function defined in this contract.\r\n\t\t// prettier-ignore\r\n\t\tassembly {\r\n\t\t\tswitch x\r\n\t\t\tcase 1 { result := mul(SCALE, sub(0, 18)) }\r\n\t\t\tcase 10 { result := mul(SCALE, sub(1, 18)) }\r\n\t\t\tcase 100 { result := mul(SCALE, sub(2, 18)) }\r\n\t\t\tcase 1000 { result := mul(SCALE, sub(3, 18)) }\r\n\t\t\tcase 10000 { result := mul(SCALE, sub(4, 18)) }\r\n\t\t\tcase 100000 { result := mul(SCALE, sub(5, 18)) }\r\n\t\t\tcase 1000000 { result := mul(SCALE, sub(6, 18)) }\r\n\t\t\tcase 10000000 { result := mul(SCALE, sub(7, 18)) }\r\n\t\t\tcase 100000000 { result := mul(SCALE, sub(8, 18)) }\r\n\t\t\tcase 1000000000 { result := mul(SCALE, sub(9, 18)) }\r\n\t\t\tcase 10000000000 { result := mul(SCALE, sub(10, 18)) }\r\n\t\t\tcase 100000000000 { result := mul(SCALE, sub(11, 18)) }\r\n\t\t\tcase 1000000000000 { result := mul(SCALE, sub(12, 18)) }\r\n\t\t\tcase 10000000000000 { result := mul(SCALE, sub(13, 18)) }\r\n\t\t\tcase 100000000000000 { result := mul(SCALE, sub(14, 18)) }\r\n\t\t\tcase 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\r\n\t\t\tcase 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\r\n\t\t\tcase 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\r\n\t\t\tcase 1000000000000000000 { result := 0 }\r\n\t\t\tcase 10000000000000000000 { result := SCALE }\r\n\t\t\tcase 100000000000000000000 { result := mul(SCALE, 2) }\r\n\t\t\tcase 1000000000000000000000 { result := mul(SCALE, 3) }\r\n\t\t\tcase 10000000000000000000000 { result := mul(SCALE, 4) }\r\n\t\t\tcase 100000000000000000000000 { result := mul(SCALE, 5) }\r\n\t\t\tcase 1000000000000000000000000 { result := mul(SCALE, 6) }\r\n\t\t\tcase 10000000000000000000000000 { result := mul(SCALE, 7) }\r\n\t\t\tcase 100000000000000000000000000 { result := mul(SCALE, 8) }\r\n\t\t\tcase 1000000000000000000000000000 { result := mul(SCALE, 9) }\r\n\t\t\tcase 10000000000000000000000000000 { result := mul(SCALE, 10) }\r\n\t\t\tcase 100000000000000000000000000000 { result := mul(SCALE, 11) }\r\n\t\t\tcase 1000000000000000000000000000000 { result := mul(SCALE, 12) }\r\n\t\t\tcase 10000000000000000000000000000000 { result := mul(SCALE, 13) }\r\n\t\t\tcase 100000000000000000000000000000000 { result := mul(SCALE, 14) }\r\n\t\t\tcase 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\r\n\t\t\tcase 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\r\n\t\t\tcase 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\r\n\t\t\tcase 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\r\n\t\t\tcase 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\r\n\t\t\tcase 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\r\n\t\t\tcase 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\r\n\t\t\tcase 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\r\n\t\t\tcase 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\r\n\t\t\tcase 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\r\n\t\t\tcase 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\r\n\t\t\tcase 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\r\n\t\t\tcase 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\r\n\t\t\tcase 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\r\n\t\t\tcase 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\r\n\t\t\tcase 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\r\n\t\t\tcase 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\r\n\t\t\tcase 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\r\n\t\t\tcase 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\r\n\t\t\tcase 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\r\n\t\t\tcase 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\r\n\t\t\tcase 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\r\n\t\t\tcase 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\r\n\t\t\tcase 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\r\n\t\t\tcase 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\r\n\t\t\tcase 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\r\n\t\t\tcase 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\r\n\t\t\tcase 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\r\n\t\t\tcase 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\r\n\t\t\tcase 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\r\n\t\t\tcase 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\r\n\t\t\tcase 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\r\n\t\t\tcase 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\r\n\t\t\tcase 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\r\n\t\t\tcase 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\r\n\t\t\tcase 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\r\n\t\t\tcase 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\r\n\t\t\tcase 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\r\n\t\t\tcase 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\r\n\t\t\tcase 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\r\n\t\t\tcase 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\r\n\t\t\tcase 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\r\n\t\t\tcase 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\r\n\t\t\tcase 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\r\n\t\t\tcase 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\r\n\t\t\tdefault {\r\n\t\t\t\tresult := MAX_UD60x18\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (result == MAX_UD60x18) {\r\n\t\t\t// Do the fixed-point division inline to save gas. The denominator is log2(10).\r\n\t\t\tunchecked { result = (log2(x) * SCALE) / 332192809488736234; }\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Calculates the binary logarithm of x.\r\n\t///\r\n\t/// @dev Based on the iterative approximation algorithm.\r\n\t/// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\r\n\t///\r\n\t/// Requirements:\r\n\t/// - x must be greater than or equal to SCALE, otherwise the result would be negative.\r\n\t///\r\n\t/// Caveats:\r\n\t/// - The results are nor perfectly accurate to the last digit, due to the lossy precision of the iterative approximation.\r\n\t///\r\n\t/// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\r\n\t/// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\r\n\tfunction log2(uint256 x) internal pure returns (uint256 result) {\r\n\t\trequire(x >= SCALE);\r\n\t\tunchecked {\r\n\t\t\t// Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\r\n\t\t\tuint256 n = PRBMathCommon.mostSignificantBit(x / SCALE);\r\n\r\n\t\t\t// The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\r\n\t\t\t// because n is maximum 255 and SCALE is 1e18.\r\n\t\t\tresult = n * SCALE;\r\n\r\n\t\t\t// This is y = x * 2^(-n).\r\n\t\t\tuint256 y = x >> n;\r\n\r\n\t\t\t// If y = 1, the fractional part is zero.\r\n\t\t\tif (y == SCALE) {\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\r\n\t\t\t// Calculate the fractional part via the iterative approximation.\r\n\t\t\t// The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\r\n\t\t\tfor (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\r\n\t\t\t\ty = (y * y) / SCALE;\r\n\r\n\t\t\t\t// Is y^2 > 2 and so in the range [2,4)?\r\n\t\t\t\tif (y >= 2 * SCALE) {\r\n\t\t\t\t\t// Add the 2^(-m) factor to the logarithm.\r\n\t\t\t\t\tresult += delta;\r\n\r\n\t\t\t\t\t// Corresponds to z/2 on Wikipedia.\r\n\t\t\t\t\ty >>= 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\r\n\t/// fixed-point number.\r\n\t/// @dev See the documentation for the \"PRBMathCommon.mulDivFixedPoint\" function.\r\n\t/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\r\n\t/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\r\n\t/// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n\tfunction mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n\t\tresult = PRBMathCommon.mulDivFixedPoint(x, y);\r\n\t}\r\n\r\n\t/// @notice Retrieves PI as an unsigned 60.18-decimal fixed-point number.\r\n\tfunction pi() internal pure returns (uint256 result) {\r\n\t\tresult = 3141592653589793238;\r\n\t}\r\n\r\n\t/// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\r\n\t/// famous algorithm \"exponentiation by squaring\".\r\n\t///\r\n\t/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\r\n\t///\r\n\t/// Requirements:\r\n\t/// - The result must fit within MAX_UD60x18.\r\n\t///\r\n\t/// Caveats:\r\n\t/// - All from \"mul\".\r\n\t/// - Assumes 0^0 is 1.\r\n\t///\r\n\t/// @param x The base as an unsigned 60.18-decimal fixed-point number.\r\n\t/// @param y The exponent as an uint256.\r\n\t/// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n\tfunction pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n\t\t// Calculate the first iteration of the loop in advance.\r\n\t\tresult = y & 1 > 0 ? x : SCALE;\r\n\r\n\t\t// Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\r\n\t\tfor (y >>= 1; y > 0; y >>= 1) {\r\n\t\t\tx = mul(x, x);\r\n\r\n\t\t\t// Equivalent to \"y % 2 == 1\" but faster.\r\n\t\t\tif (y & 1 > 0) {\r\n\t\t\t\tresult = mul(result, x);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\r\n\tfunction scale() internal pure returns (uint256 result) {\r\n\t\tresult = SCALE;\r\n\t}\r\n\r\n\t/// @notice Calculates the square root of x, rounding down.\r\n\t/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\r\n\t///\r\n\t/// Requirements:\r\n\t/// - x must be less than MAX_UD60x18 / SCALE.\r\n\t///\r\n\t/// Caveats:\r\n\t/// - The maximum fixed-point number permitted is 115792089237316195423570985008687907853269.984665640564039458.\r\n\t///\r\n\t/// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\r\n\t/// @return result The result as an unsigned 60.18-decimal fixed-point .\r\n\tfunction sqrt(uint256 x) internal pure returns (uint256 result) {\r\n\t\trequire(x < 115792089237316195423570985008687907853269984665640564039458);\r\n\t\tunchecked {\r\n\t\t\t// Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\r\n\t\t\t// 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\r\n\t\t\tresult = PRBMathCommon.sqrt(x * SCALE);\r\n\t\t}\r\n\t}\r\n}\r\n\r\ninterface Callable {\r\n\tfunction tokenCallback(address _from, uint256 _tokens, bytes calldata _data) external returns (bool);\r\n}\r\n\r\n\r\ncontract LMAO {\r\n\r\n\tuint256 constant private UINT_MAX = type(uint256).max;\r\n\tuint256 constant private TOTAL_SUPPLY = 1e25; // 10M LMAO\r\n\tuint256 constant private STAKING_REWARDS = 35e23; // 3.5M LMAO\r\n\r\n\tstring constant public name = \"LMAO Token\";\r\n\tstring constant public symbol = \"LMAO\";\r\n\tuint8 constant public decimals = 18;\r\n\r\n\tstruct User {\r\n\t\tuint256 balance;\r\n\t\tmapping(address => uint256) allowance;\r\n\t}\r\n\r\n\tstruct Info {\r\n\t\tmapping(address => User) users;\r\n\t\taddress staking;\r\n\t}\r\n\tInfo private info;\r\n\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 tokens);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 tokens);\r\n\r\n\r\n\tconstructor(address _owner) {\r\n\t\tuint256 _ownerTokens = TOTAL_SUPPLY - STAKING_REWARDS;\r\n\t\tinfo.users[_owner].balance = _ownerTokens;\r\n\t\temit Transfer(address(0x0), _owner, _ownerTokens);\r\n\t\tinfo.staking = msg.sender;\r\n\t\tinfo.users[info.staking].balance = STAKING_REWARDS;\r\n\t\temit Transfer(address(0x0), info.staking, STAKING_REWARDS);\r\n\t}\r\n\r\n\tfunction transfer(address _to, uint256 _tokens) external returns (bool) {\r\n\t\treturn _transfer(msg.sender, _to, _tokens);\r\n\t}\r\n\r\n\tfunction approve(address _spender, uint256 _tokens) external returns (bool) {\r\n\t\tinfo.users[msg.sender].allowance[_spender] = _tokens;\r\n\t\temit Approval(msg.sender, _spender, _tokens);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _tokens) external returns (bool) {\r\n\t\tuint256 _allowance = allowance(_from, msg.sender);\r\n\t\trequire(_allowance >= _tokens);\r\n\t\tif (_allowance != UINT_MAX) {\r\n\t\t\tinfo.users[_from].allowance[msg.sender] -= _tokens;\r\n\t\t}\r\n\t\treturn _transfer(_from, _to, _tokens);\r\n\t}\r\n\r\n\tfunction transferAndCall(address _to, uint256 _tokens, bytes calldata _data) external returns (bool) {\r\n\t\t_transfer(msg.sender, _to, _tokens);\r\n\t\tuint32 _size;\r\n\t\tassembly {\r\n\t\t\t_size := extcodesize(_to)\r\n\t\t}\r\n\t\tif (_size > 0) {\r\n\t\t\trequire(Callable(_to).tokenCallback(msg.sender, _tokens, _data));\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\tfunction stakingAddress() external view returns (address) {\r\n\t\treturn info.staking;\r\n\t}\r\n\t\r\n\tfunction totalSupply() public pure returns (uint256) {\r\n\t\treturn TOTAL_SUPPLY;\r\n\t}\r\n\r\n\tfunction balanceOf(address _user) public view returns (uint256) {\r\n\t\treturn info.users[_user].balance;\r\n\t}\r\n\r\n\tfunction allowance(address _user, address _spender) public view returns (uint256) {\r\n\t\treturn info.users[_user].allowance[_spender];\r\n\t}\r\n\r\n\tfunction allInfoFor(address _user) external view returns (uint256 totalTokens, uint256 userTOKENS, uint256 userBalance) {\r\n\t\ttotalTokens = totalSupply();\r\n\t\tuserTOKENS = _user.balance;\r\n\t\tuserBalance = balanceOf(_user);\r\n\t}\r\n\r\n\r\n\tfunction _transfer(address _from, address _to, uint256 _tokens) internal returns (bool) {\r\n\t\trequire(balanceOf(_from) >= _tokens);\r\n\t\tinfo.users[_from].balance -= _tokens;\r\n\t\tinfo.users[_to].balance += _tokens;\r\n\t\temit Transfer(_from, _to, _tokens);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\ncontract StakingRewards {\r\n\r\n\tusing PRBMathUD60x18 for uint256;\r\n\r\n\tuint256 constant private FLOAT_SCALAR = 2**64;\r\n\tuint256 constant private PERCENT_FEE = 5;\r\n\tuint256 constant private X_TICK = 45 days;\r\n\r\n\tstruct User {\r\n\t\tuint256 deposited;\r\n\t\tint256 scaledPayout;\r\n\t}\r\n\r\n\tstruct Info {\r\n\t\tuint256 totalRewards;\r\n\t\tuint256 startTime;\r\n\t\tuint256 lastUpdated;\r\n\t\tuint256 pendingFee;\r\n\t\tuint256 scaledRewardsPerToken;\r\n\t\tuint256 totalDeposited;\r\n\t\tmapping(address => User) users;\r\n\t\tLMAO lmao;\r\n\t}\r\n\tInfo private info;\r\n\r\n\r\n\tevent Deposit(address indexed user, uint256 amount, uint256 fee);\r\n\tevent Withdraw(address indexed user, uint256 amount, uint256 fee);\r\n\tevent Claim(address indexed user, uint256 amount);\r\n\tevent Reinvest(address indexed user, uint256 amount);\r\n\tevent Reward(uint256 amount);\r\n\r\n\r\n\tconstructor(uint256 _stakingRewardsStart) {\r\n\t\tinfo.startTime = block.timestamp < _stakingRewardsStart ? _stakingRewardsStart : block.timestamp;\r\n\t\tinfo.lastUpdated = info.startTime;\r\n\t\tinfo.lmao = new LMAO(msg.sender);\r\n\t\tinfo.totalRewards = info.lmao.balanceOf(address(this));\r\n\t}\r\n\r\n\tfunction update() public {\r\n\t\tuint256 _now = block.timestamp;\r\n\t\tif (_now > info.lastUpdated && info.totalDeposited > 0) {\r\n\t\t\tuint256 _reward = info.totalRewards.mul(_delta(_getX(info.lastUpdated), _getX(_now)));\r\n\t\t\t_disburse(_reward);\r\n\t\t\tinfo.lastUpdated = _now;\r\n\t\t\tif (info.pendingFee > 0) {\r\n\t\t\t\t_processFee(info.pendingFee);\r\n\t\t\t\tinfo.pendingFee = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction deposit(uint256 _amount) external {\r\n\t\tdepositFor(msg.sender, _amount);\r\n\t}\r\n\r\n\tfunction depositFor(address _user, uint256 _amount) public {\r\n\t\trequire(_amount > 0);\r\n\t\tupdate();\r\n\t\tinfo.lmao.transferFrom(msg.sender, address(this), _amount);\r\n\t\t_deposit(_user, _amount);\r\n\t}\r\n\r\n\tfunction tokenCallback(address _from, uint256 _tokens, bytes calldata) external returns (bool) {\r\n\t\trequire(msg.sender == address(info.lmao));\r\n\t\trequire(_tokens > 0);\r\n\t\t_deposit(_from, _tokens);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction disburse(uint256 _amount) public {\r\n\t\trequire(_amount > 0);\r\n\t\tupdate();\r\n\t\tinfo.lmao.transferFrom(msg.sender, address(this), _amount);\r\n\t\t_disburse(_amount);\r\n\t}\r\n\r\n\tfunction withdrawAll() public {\r\n\t\tuint256 _deposited = depositedOf(msg.sender);\r\n\t\tif (_deposited > 0) {\r\n\t\t\twithdraw(_deposited);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction withdraw(uint256 _amount) public {\r\n\t\trequire(_amount > 0 && _amount <= depositedOf(msg.sender));\r\n\t\tupdate();\r\n\t\tinfo.totalDeposited -= _amount;\r\n\t\tinfo.users[msg.sender].deposited -= _amount;\r\n\t\tinfo.users[msg.sender].scaledPayout -= int256(_amount * info.scaledRewardsPerToken);\r\n\t\tuint256 _fee = _calculateFee(_amount);\r\n\t\tinfo.lmao.transfer(msg.sender, _amount - _fee);\r\n\t\t_processFee(_fee);\r\n\t\temit Withdraw(msg.sender, _amount, _fee);\r\n\t}\r\n\r\n\tfunction claim() public {\r\n\t\tupdate();\r\n\t\tuint256 _rewards = rewardsOf(msg.sender);\r\n\t\tif (_rewards > 0) {\r\n\t\t\tinfo.users[msg.sender].scaledPayout += int256(_rewards * FLOAT_SCALAR);\r\n\t\t\tinfo.lmao.transfer(msg.sender, _rewards);\r\n\t\t\temit Claim(msg.sender, _rewards);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction reinvest() public {\r\n\t\tupdate();\r\n\t\tuint256 _rewards = rewardsOf(msg.sender);\r\n\t\tif (_rewards > 0) {\r\n\t\t\tinfo.users[msg.sender].scaledPayout += int256(_rewards * FLOAT_SCALAR);\r\n\t\t\t_deposit(msg.sender, _rewards);\r\n\t\t\temit Reinvest(msg.sender, _rewards);\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\tfunction depositedOf(address _user) public view returns (uint256) {\r\n\t\treturn info.users[_user].deposited;\r\n\t}\r\n\t\r\n\tfunction rewardsOf(address _user) public view returns (uint256) {\r\n\t\treturn uint256(int256(info.scaledRewardsPerToken * depositedOf(_user)) - info.users[_user].scaledPayout) / FLOAT_SCALAR;\r\n\t}\r\n\t\r\n\tfunction currentRatePerDay() public view returns (uint256) {\r\n\t\tif (block.timestamp < info.startTime) {\r\n\t\t\treturn 0;\r\n\t\t} else {\r\n\t\t\treturn info.totalRewards.mul(_delta(_getX(block.timestamp), _getX(block.timestamp + 24 hours)));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction totalDistributed() public view returns (uint256) {\r\n\t\treturn info.totalRewards.mul(_sum(_getX(block.timestamp)));\r\n\t}\r\n\r\n\tfunction allInfoFor(address _user) external view returns (uint256 startTime, uint256 totalRewardsDistributed, uint256 rewardsRatePerDay, uint256 currentFeePercent, uint256 totalDeposited, uint256 virtualRewards, uint256 userTOKENS, uint256 userBalance, uint256 userAllowance, uint256 userDeposited, uint256 userRewards) {\r\n\t\tstartTime = info.startTime;\r\n\t\ttotalRewardsDistributed = totalDistributed();\r\n\t\trewardsRatePerDay = currentRatePerDay();\r\n\t\tcurrentFeePercent = _calculateFee(1e20);\r\n\t\ttotalDeposited = info.totalDeposited;\r\n\t\tvirtualRewards = block.timestamp > info.lastUpdated ? info.totalRewards.mul(_delta(_getX(info.lastUpdated), _getX(block.timestamp))) : 0;\r\n\t\tuserTOKENS = _user.balance;\r\n\t\tuserBalance = info.lmao.balanceOf(_user);\r\n\t\tuserAllowance = info.lmao.allowance(_user, address(this));\r\n\t\tuserDeposited = depositedOf(_user);\r\n\t\tuserRewards = rewardsOf(_user);\r\n\t}\r\n\r\n\r\n\tfunction _deposit(address _user, uint256 _amount) internal {\r\n\t\tuint256 _fee = _calculateFee(_amount);\r\n\t\tuint256 _deposited = _amount - _fee;\r\n\t\tinfo.totalDeposited += _deposited;\r\n\t\tinfo.users[_user].deposited += _deposited;\r\n\t\tinfo.users[_user].scaledPayout += int256(_deposited * info.scaledRewardsPerToken);\r\n\t\t_processFee(_fee);\r\n\t\temit Deposit(_user, _amount, _fee);\r\n\t}\r\n\t\r\n\tfunction _processFee(uint256 _fee) internal {\r\n\t\tif (_fee > 0) {\r\n\t\t\tif (block.timestamp < info.startTime) {\r\n\t\t\t\tinfo.pendingFee += _fee;\r\n\t\t\t} else {\r\n\t\t\t\t_disburse(_fee);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _disburse(uint256 _amount) internal {\r\n\t\tinfo.scaledRewardsPerToken += _amount * FLOAT_SCALAR / info.totalDeposited;\r\n\t\temit Reward(_amount);\r\n\t}\r\n\r\n\tfunction _calculateFee(uint256 _amount) internal view returns (uint256) {\r\n\t\treturn (_amount * PERCENT_FEE / 100).mul(1e18 - _sum(_getX(block.timestamp)));\r\n\t}\r\n\t\r\n\tfunction _getX(uint256 t) internal view returns (uint256) {\r\n\t\tuint256 _start = info.startTime;\r\n\t\tif (t < _start) {\r\n\t\t\treturn 0;\r\n\t\t} else {\r\n\t\t\treturn ((t - _start) * 1e18).div(X_TICK * 1e18);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _sum(uint256 x) internal pure returns (uint256) {\r\n\t\tuint256 _e2x = x.exp2();\r\n\t\treturn (_e2x - 1e18).div(_e2x);\r\n\t}\r\n\r\n\tfunction _delta(uint256 x1, uint256 x2) internal pure returns (uint256) {\r\n\t\trequire(x2 >= x1);\r\n\t\treturn _sum(x2) - _sum(x1);\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"allInfoFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userTOKENS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LMAO","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000083238fceb0343a37e6676b2941d27c1d08a13559","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4a85d097256a20570c85d25ca9334cf284dd8cc4117b4a5befcf86eabe67d960"}]}