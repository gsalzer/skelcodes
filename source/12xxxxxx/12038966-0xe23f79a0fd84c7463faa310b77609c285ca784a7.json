{"status":"1","message":"OK","result":[{"SourceCode":"{\"FarmUniswap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\n\\nlibrary Address {\\n  function isContract(address account) internal view returns (bool) {\\n    uint256 size;\\n    assembly { size := extcodesize(account) }\\n    return size \\u003e 0;\\n  }\\n\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n    (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n    return _functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n    require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n    return _functionCallWithValue(target, data, value, errorMessage);\\n  }\\n\\n  function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\n    (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n    if (success) {\\n      return returndata;\\n    } else {\\n      if (returndata.length \\u003e 0) {\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\\nlibrary SafeMath {\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n  }\\n\\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    require(b \\u003c= a, errorMessage);\\n    uint256 c = a - b;\\n    return c;\\n  }\\n\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint256 c = a * b;\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n    return c;\\n  }\\n\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, \\\"SafeMath: division by zero\\\");\\n  }\\n\\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    require(b \\u003e 0, errorMessage);\\n    uint256 c = a / b;\\n    return c;\\n  }\\n\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n  }\\n\\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\\nlibrary SafeERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n    require((value == 0) || (token.allowance(address(this), spender) == 0), \\\"SafeERC20: approve from non-zero to non-zero allowance\\\");\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n\\n  function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n    if (returndata.length \\u003e 0) {\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n  }\\n}\\n\\nlibrary TransferHelper {\\n  function safeApprove(address token, address to, uint value) internal {\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n    require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: APPROVE_FAILED\\u0027);\\n  }\\n\\n  function safeTransfer(address token, address to, uint value) internal {\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n    require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FAILED\\u0027);\\n  }\\n\\n  function safeTransferFrom(address token, address from, address to, uint value) internal {\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n    require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FROM_FAILED\\u0027);\\n  }\\n}\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n  function balanceOf(address account) external view returns (uint256);\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  function approve(address spender, uint256 amount) external returns (bool);\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IFarmFactory {\\n  function userEnteredFarm(address _user) external;\\n  function userLeftFarm(address _user) external;\\n  function registerFarm(address _farmAddress) external;\\n}\\n\\n\\ncontract FarmUniswap {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  /// @notice information stuct on each user than stakes LP tokens.\\n  struct UserInfo {\\n    uint256 amount;     // How many LP tokens the user has provided.\\n    uint256 rewardDebt; // Reward debt.\\n  }\\n\\n  /// @notice all the settings for this farm in one struct\\n  struct FarmInfo {\\n    IERC20 lpToken;\\n    IERC20 rewardToken;\\n    uint256 startBlock;\\n    uint256 blockReward;\\n    uint256 bonusEndBlock;\\n    uint256 bonus;\\n    uint256 endBlock;\\n    uint256 lastRewardBlock;   // Last block number that reward distribution occurs.\\n    uint256 accRewardPerShare; // Accumulated Rewards per share, times 1e12\\n    uint256 farmableSupply;    // set in init, total amount of tokens farmable\\n    uint256 numFarmers;\\n  }\\n\\n  /// @notice farm type id. Useful for back-end systems to know how to read the contract (ABI) as we plan to launch multiple farm types\\n  uint256 public farmType = 1;\\n\\n  IFarmFactory public factory;\\n  address public farmGenerator;\\n\\n  FarmInfo public farmInfo;\\n\\n  /// @notice information on each user than stakes LP tokens\\n  mapping (address =\\u003e UserInfo) public userInfo;\\n\\n  event Deposit(address indexed user, uint256 amount);\\n  event Withdraw(address indexed user, uint256 amount);\\n  event EmergencyWithdraw(address indexed user, uint256 amount);\\n\\n  constructor(address _factory, address _farmGenerator) public {\\n    factory = IFarmFactory(_factory);\\n    farmGenerator = _farmGenerator;\\n  }\\n\\n  /**\\n   * @notice initialize the farming contract. This is called only once upon farm creation and the FarmGenerator ensures the farm has the correct paramaters\\n   */\\n  function init(IERC20 _rewardToken, uint256 _amount, IERC20 _lpToken, uint256 _blockReward, uint256 _startBlock, uint256 _endBlock, uint256 _bonusEndBlock, uint256 _bonus) public {\\n    address msgSender = _msgSender();\\n    require(msgSender == address(farmGenerator), \\u0027FORBIDDEN\\u0027);\\n\\n    TransferHelper.safeTransferFrom(address(_rewardToken), msgSender, address(this), _amount);\\n    farmInfo.rewardToken = _rewardToken;\\n\\n    farmInfo.startBlock = _startBlock;\\n    farmInfo.blockReward = _blockReward;\\n    farmInfo.bonusEndBlock = _bonusEndBlock;\\n    farmInfo.bonus = _bonus;\\n\\n    uint256 lastRewardBlock = block.number \\u003e _startBlock ? block.number : _startBlock;\\n    farmInfo.lpToken = _lpToken;\\n    farmInfo.lastRewardBlock = lastRewardBlock;\\n    farmInfo.accRewardPerShare = 0;\\n\\n    farmInfo.endBlock = _endBlock;\\n    farmInfo.farmableSupply = _amount;\\n  }\\n\\n  /**\\n   * @notice Gets the reward multiplier over the given _from_block until _to block\\n   * @param _from_block the start of the period to measure rewards for\\n   * @param _to the end of the period to measure rewards for\\n   * @return The weighted multiplier for the given period\\n   */\\n  function getMultiplier(uint256 _from_block, uint256 _to) public view returns (uint256) {\\n    uint256 _from = _from_block \\u003e= farmInfo.startBlock ? _from_block : farmInfo.startBlock;\\n    uint256 to = farmInfo.endBlock \\u003e _to ? _to : farmInfo.endBlock;\\n    if (to \\u003c= farmInfo.bonusEndBlock) {\\n      return to.sub(_from).mul(farmInfo.bonus);\\n    } else if (_from \\u003e= farmInfo.bonusEndBlock) {\\n      return to.sub(_from);\\n    } else {\\n      return farmInfo.bonusEndBlock.sub(_from).mul(farmInfo.bonus).add(\\n        to.sub(farmInfo.bonusEndBlock)\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @notice function to see accumulated balance of reward token for specified user\\n   * @param _user the user for whom unclaimed tokens will be shown\\n   * @return total amount of withdrawable reward tokens\\n   */\\n  function pendingReward(address _user) external view returns (uint256) {\\n    UserInfo storage user = userInfo[_user];\\n    uint256 accRewardPerShare = farmInfo.accRewardPerShare;\\n    uint256 lpSupply = farmInfo.lpToken.balanceOf(address(this));\\n    if (block.number \\u003e farmInfo.lastRewardBlock \\u0026\\u0026 lpSupply != 0) {\\n      uint256 multiplier = getMultiplier(farmInfo.lastRewardBlock, block.number);\\n      uint256 tokenReward = multiplier.mul(farmInfo.blockReward);\\n      accRewardPerShare = accRewardPerShare.add(tokenReward.mul(1e12).div(lpSupply));\\n    }\\n    return user.amount.mul(accRewardPerShare).div(1e12).sub(user.rewardDebt);\\n  }\\n\\n  /**\\n   * @notice updates pool information to be up to date to the current block\\n   */\\n  function updatePool() public {\\n    if (block.number \\u003c= farmInfo.lastRewardBlock) {\\n      return;\\n    }\\n    uint256 lpSupply = farmInfo.lpToken.balanceOf(address(this));\\n    if (lpSupply == 0) {\\n      farmInfo.lastRewardBlock = block.number \\u003c farmInfo.endBlock ? block.number : farmInfo.endBlock;\\n      return;\\n    }\\n    uint256 multiplier = getMultiplier(farmInfo.lastRewardBlock, block.number);\\n    uint256 tokenReward = multiplier.mul(farmInfo.blockReward);\\n    farmInfo.accRewardPerShare = farmInfo.accRewardPerShare.add(tokenReward.mul(1e12).div(lpSupply));\\n    farmInfo.lastRewardBlock = block.number \\u003c farmInfo.endBlock ? block.number : farmInfo.endBlock;\\n  }\\n\\n  /**\\n   * @notice deposit LP token function for msgSender\\n   * @param _amount the total deposit amount\\n   */\\n  function deposit(uint256 _amount) public {\\n    address msgSender = _msgSender();\\n    UserInfo storage user = userInfo[msgSender];\\n    updatePool();\\n    if (user.amount \\u003e 0) {\\n      uint256 pending = user.amount.mul(farmInfo.accRewardPerShare).div(1e12).sub(user.rewardDebt);\\n      safeRewardTransfer(msgSender, pending);\\n    }\\n    if (user.amount == 0 \\u0026\\u0026 _amount \\u003e 0) {\\n      factory.userEnteredFarm(msgSender);\\n      farmInfo.numFarmers = farmInfo.numFarmers.add(1);\\n    }\\n    farmInfo.lpToken.safeTransferFrom(address(msgSender), address(this), _amount);\\n    user.amount = user.amount.add(_amount);\\n    user.rewardDebt = user.amount.mul(farmInfo.accRewardPerShare).div(1e12);\\n    emit Deposit(msgSender, _amount);\\n  }\\n\\n  /**\\n   * @notice withdraw LP token function for msgSender\\n   * @param _amount the total withdrawable amount\\n   */\\n  function withdraw(uint256 _amount) public {\\n    address msgSender = _msgSender();\\n    UserInfo storage user = userInfo[msgSender];\\n    require(user.amount \\u003e= _amount, \\\"INSUFFICIENT\\\");\\n    updatePool();\\n    if (user.amount == _amount \\u0026\\u0026 _amount \\u003e 0) {\\n      factory.userLeftFarm(msgSender);\\n      farmInfo.numFarmers = farmInfo.numFarmers.sub(1);\\n    }\\n    uint256 pending = user.amount.mul(farmInfo.accRewardPerShare).div(1e12).sub(user.rewardDebt);\\n    safeRewardTransfer(msgSender, pending);\\n    user.amount = user.amount.sub(_amount);\\n    user.rewardDebt = user.amount.mul(farmInfo.accRewardPerShare).div(1e12);\\n    farmInfo.lpToken.safeTransfer(address(msgSender), _amount);\\n    emit Withdraw(msgSender, _amount);\\n  }\\n\\n  /**\\n   * @notice emergency functoin to withdraw LP tokens and forego harvest rewards. Important to protect users LP tokens\\n   */\\n  function emergencyWithdraw() public {\\n    address msgSender = _msgSender();\\n    UserInfo storage user = userInfo[msgSender];\\n    farmInfo.lpToken.safeTransfer(address(msgSender), user.amount);\\n    emit EmergencyWithdraw(msgSender, user.amount);\\n    if (user.amount \\u003e 0) {\\n      factory.userLeftFarm(msgSender);\\n      farmInfo.numFarmers = farmInfo.numFarmers.sub(1);\\n    }\\n    user.amount = 0;\\n    user.rewardDebt = 0;\\n  }\\n\\n  /**\\n   * @notice Safe reward transfer function, just in case a rounding error causes pool to not have enough reward tokens\\n   * @param _to the user address to transfer tokens to\\n   * @param _amount the total amount of tokens to transfer\\n   */\\n  function safeRewardTransfer(address _to, uint256 _amount) internal {\\n    uint256 rewardBal = farmInfo.rewardToken.balanceOf(address(this));\\n    if (_amount \\u003e rewardBal) {\\n      farmInfo.rewardToken.transfer(_to, rewardBal);\\n    } else {\\n      farmInfo.rewardToken.transfer(_to, _amount);\\n    }\\n  }\\n\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n}\\n\"},\"FarmUniswapGenerator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\nimport \\\"./FarmUniswap.sol\\\";\\n\\ninterface IUniFactory {\\n  function getPair(address tokenA, address tokenB) external view returns (address);\\n}\\n\\ninterface IUniswapV2Pair {\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  function name() external pure returns (string memory);\\n  function symbol() external pure returns (string memory);\\n  function decimals() external pure returns (uint8);\\n  function totalSupply() external view returns (uint);\\n  function balanceOf(address owner) external view returns (uint);\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  function approve(address spender, uint value) external returns (bool);\\n  function transfer(address to, uint value) external returns (bool);\\n  function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\\n  function nonces(address owner) external view returns (uint);\\n\\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n  event Mint(address indexed sender, uint amount0, uint amount1);\\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n  event Swap(\\n    address indexed sender,\\n    uint amount0In,\\n    uint amount1In,\\n    uint amount0Out,\\n    uint amount1Out,\\n    address indexed to\\n  );\\n  event Sync(uint112 reserve0, uint112 reserve1);\\n\\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\\n  function factory() external view returns (address);\\n  function token0() external view returns (address);\\n  function token1() external view returns (address);\\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n  function price0CumulativeLast() external view returns (uint);\\n  function price1CumulativeLast() external view returns (uint);\\n  function kLast() external view returns (uint);\\n\\n  function mint(address to) external returns (uint liquidity);\\n  function burn(address to) external returns (uint amount0, uint amount1);\\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n  function skim(address to) external;\\n  function sync() external;\\n\\n  function initialize(address, address) external;\\n}\\n\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n}\\n\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  constructor () internal {\\n    address msgSender = _msgSender();\\n    _owner = msgSender;\\n    emit OwnershipTransferred(address(0), msgSender);\\n  }\\n\\n  function owner() public view returns (address) {\\n    return _owner;\\n  }\\n\\n  modifier onlyOwner() {\\n    require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    _;\\n  }\\n\\n  function renounceOwnership() public virtual onlyOwner {\\n    emit OwnershipTransferred(_owner, address(0));\\n    _owner = address(0);\\n  }\\n\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n  }\\n}\\n\\n\\ncontract FarmUniswapGenerator is Context, Ownable {\\n  using SafeMath for uint256;\\n  IFarmFactory public factory;\\n\\n  struct FarmParameters {\\n    uint256 bonusBlocks;\\n    uint256 totalBonusReward;\\n    uint256 numBlocks;\\n    uint256 endBlock;\\n    uint256 requiredAmount;\\n  }\\n\\n  constructor(IFarmFactory _factory) public {\\n    factory = _factory;\\n  }\\n\\n  /**\\n   * @notice Determine the endBlock based on inputs. Used on the front end to show the exact settings the Farm contract will be deployed with\\n   */\\n  function determineEndBlock(uint256 _amount, uint256 _blockReward, uint256 _startBlock, uint256 _bonusEndBlock, uint256 _bonus) public pure returns (uint256, uint256) {\\n    FarmParameters memory params;\\n    params.bonusBlocks = _bonusEndBlock.sub(_startBlock);\\n    params.totalBonusReward = params.bonusBlocks.mul(_bonus).mul(_blockReward);\\n    params.numBlocks = _amount.sub(params.totalBonusReward).div(_blockReward);\\n    params.endBlock = params.numBlocks.add(params.bonusBlocks).add(_startBlock);\\n\\n    uint256 nonBonusBlocks = params.endBlock.sub(_bonusEndBlock);\\n    uint256 effectiveBlocks = params.bonusBlocks.mul(_bonus).add(nonBonusBlocks);\\n    uint256 requiredAmount = _blockReward.mul(effectiveBlocks);\\n    return (params.endBlock, requiredAmount);\\n  }\\n\\n  /**\\n   * @notice Determine the blockReward based on inputs specifying an end date. Used on the front end to show the exact settings the Farm contract will be deployed with\\n   */\\n  function determineBlockReward(uint256 _amount, uint256 _startBlock, uint256 _bonusEndBlock, uint256 _bonus, uint256 _endBlock) public pure returns (uint256, uint256) {\\n    uint256 bonusBlocks = _bonusEndBlock.sub(_startBlock);\\n    uint256 nonBonusBlocks = _endBlock.sub(_bonusEndBlock);\\n    uint256 effectiveBlocks = bonusBlocks.mul(_bonus).add(nonBonusBlocks);\\n    uint256 blockReward = _amount.div(effectiveBlocks);\\n    uint256 requiredAmount = blockReward.mul(effectiveBlocks);\\n    return (blockReward, requiredAmount);\\n  }\\n\\n  /**\\n   * @notice Creates a new FarmUniswap contract and registers it in the \\n   * .sol. All farming rewards are locked in the FarmUniswap Contract\\n   */\\n  function createFarmUniswap(IERC20 _rewardToken, uint256 _amount, IERC20 _lpToken, IUniFactory _swapFactory, uint256 _blockReward, uint256 _startBlock, uint256 _bonusEndBlock, uint256 _bonus) public onlyOwner returns (address){\\n    require(_startBlock \\u003e block.number, \\u0027START\\u0027); // ideally at least 24 hours more to give farmers time\\n    require(_bonus \\u003e 0, \\u0027BONUS\\u0027);\\n    require(address(_rewardToken) != address(0), \\u0027REWARD TOKEN\\u0027);\\n    require(_blockReward \\u003e 1000, \\u0027BLOCK REWARD\\u0027); // minimum 1000 divisibility per block reward\\n    IUniFactory swapFactory = _swapFactory;\\n    // ensure this pair is on swapFactory by querying the factory\\n    IUniswapV2Pair lpair = IUniswapV2Pair(address(_lpToken));\\n    address factoryPairAddress = swapFactory.getPair(lpair.token0(), lpair.token1());\\n    require(factoryPairAddress == address(_lpToken), \\u0027This pair is not on _swapFactory exchange\\u0027);\\n\\n    FarmParameters memory params;\\n    (params.endBlock, params.requiredAmount) = determineEndBlock(_amount, _blockReward, _startBlock, _bonusEndBlock, _bonus);\\n\\n    TransferHelper.safeTransferFrom(address(_rewardToken), address(_msgSender()), address(this), params.requiredAmount);\\n    FarmUniswap newFarm = new FarmUniswap(address(factory), address(this));\\n    TransferHelper.safeApprove(address(_rewardToken), address(newFarm), params.requiredAmount);\\n    newFarm.init(_rewardToken, params.requiredAmount, _lpToken, _blockReward, _startBlock, params.endBlock, _bonusEndBlock, _bonus);\\n\\n    factory.registerFarm(address(newFarm));\\n    return (address(newFarm));\\n  }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IFarmFactory\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"contract IUniFactory\",\"name\":\"_swapFactory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonusEndBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"createFarmUniswap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonusEndBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endBlock\",\"type\":\"uint256\"}],\"name\":\"determineBlockReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonusEndBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"determineEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IFarmFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"FarmUniswapGenerator","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"0000000000000000000000001f1245df65e7a21923ca6885cb65dc670ba7bda5","EVMVersion":"istanbul","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://862cc422088edcc8b8850bbd40ccda01e0959b4f58d43dd4a492b8c66fe08c09"}]}