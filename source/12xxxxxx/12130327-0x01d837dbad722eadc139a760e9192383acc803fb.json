{"status":"1","message":"OK","result":[{"SourceCode":"\"\"\"\r\n@title Greenwood AaveV2Calculator\r\n@notice AaveV2 calculations for the Greenwood Protocol\r\n@author Greenwood Labs\r\n\"\"\"\r\n\r\n# define the interfaces used by the contract\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface AAVE_V2_PRICE_FEED:\r\n    def getAssetPrice(_asset: address) -> uint256: view\r\n\r\ninterface REGISTRY:\r\n    def getAddress(_contract: String[20], _version: String[11]) -> address: nonpayable\r\n    def governance() -> address: nonpayable\r\n\r\n# define the constants used by the contract\r\nTEN_EXP_18: constant(uint256) = 1000000000000000000\r\n\r\n# define the events emitted by the contract\r\nevent SetFee:\r\n    previousFee: uint256\r\n    newFee: uint256\r\n    governance: address\r\n    blockNumber: uint256\r\n\r\nevent SetRegistry:\r\n    previousRegistry: address\r\n    newRegistry: address\r\n    governance: address\r\n    blockNumber: uint256\r\n\r\n# define the structs used by the contract\r\nstruct AaveV2BorrowCalculation:\r\n    requiredCollateral: uint256\r\n    borrowIndex: uint256\r\n    borrowAmount: uint256\r\n    originationFee: uint256\r\n\r\nstruct AaveV2RepayCalculation:\r\n    repayAmount: uint256\r\n    redemptionAmount: int128\r\n    requiredCollateral: uint256\r\n    outstanding: int128\r\n    borrowIndex: uint256\r\n\r\nstruct AaveV2WithdrawCalculation:\r\n    requiredCollateral: uint256\r\n    outstanding: uint256\r\n\r\nstruct AssetContext:\r\n    aToken: address\r\n    aaveV2PriceFeed: address\r\n    aaveV2LendingPool: address\r\n    cToken: address\r\n    compoundPriceFeed: address\r\n    comptroller: address\r\n    decimals: uint256\r\n    underlying: address\r\n\r\nstruct Loan:\r\n    collateralAsset: address\r\n    borrowAsset: address\r\n    outstanding: uint256\r\n    collateralizationRatio: uint256\r\n    collateralLocked: uint256\r\n    borrower: address\r\n    lastBorrowIndex: uint256\r\n    repaymentTime: uint256\r\n\r\n# define the storage variables used by the contract\r\nprotocolFee: public(uint256)\r\nregistry: public(address)\r\n\r\n@external\r\ndef __init__(_protocol_fee: uint256, _registry: address):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _protocol_fee The origination fee for the Greenwood Protocol scaled by 1e18\r\n    @param _registry The address of the Greenwood Registry\r\n    \"\"\"\r\n\r\n    # set the protocol fee\r\n    self.protocolFee = _protocol_fee\r\n\r\n    # set the address of the Greenwood Registry\r\n    self.registry = _registry\r\n\r\n@internal\r\ndef isAuthorized(_caller: address, _role: String[20], _version: String[11]) -> bool:\r\n    \"\"\"\r\n    @notice Method for role-based security\r\n    @param _caller The address that called the permissioned method\r\n    @param _role The requested authorization level\r\n    @param _version The version of Greenwood to use\r\n    @return True if the caller is authorized, False otherwise\r\n    \"\"\"\r\n\r\n    # check if the requested role is \"escrow\"\r\n    if keccak256(_role) == keccak256(\"escrow\"):\r\n\r\n        # get the address of the Escrow from the Registry\r\n        controller: address = REGISTRY(self.registry).getAddress(\"aaveV2Escrow\", _version)\r\n\r\n        # return the equality comparison\r\n        return controller == _caller\r\n    \r\n    # check if the requested role is \"governance\"\r\n    elif keccak256(_role) == keccak256(\"governance\"):\r\n\r\n        # get the address of the Governance from the Registry\r\n        governance: address = REGISTRY(self.registry).governance()\r\n\r\n        # return the equality comparison\r\n        return governance == _caller\r\n\r\n    # catch extraneous role arguments\r\n    else:\r\n\r\n        # revert\r\n        raise \"Unhandled role argument\"\r\n\r\n@external\r\ndef calculateBorrow(_borrow_context: AssetContext, _collateral_context: AssetContext, _amount: uint256, _collateralization_ratio: uint256, _version: String[11]) -> AaveV2BorrowCalculation:\r\n    \"\"\"\r\n    @notice Calculate and return values needed to open a loan on Aave V2\r\n    @param _borrow_context The AssetContext struct of the asset being borrowed\r\n    @param _collateral_context The AssetContext struct of the asset being used as collateral\r\n    @param _amount The amount of asset being borrowed scaled by the asset's decimals\r\n    @param _collateralization_ratio The collateralization ratio for the loan\r\n    @param _version The version of the Greenwood Protocol to use\r\n    @return AaveV2BorrowCalculation struct\r\n    @dev Only the AaveV2Escrow or the Governance can call this method\r\n    \"\"\"\r\n\r\n    # require that the method caller is the Escrow or the Governance\r\n    assert self.isAuthorized(msg.sender, \"escrow\", _version) == True or self.isAuthorized(msg.sender, \"governance\", _version) == True, \"Only Escrow or Governance can call this method\"\r\n\r\n    # get the LTV ratio of the collateral asset\r\n    collateralReserveData: Bytes[768] = raw_call(\r\n        _collateral_context.aaveV2LendingPool,\r\n        concat(\r\n            method_id(\"getReserveData(address)\"),\r\n            convert(_collateral_context.underlying, bytes32)\r\n        ),\r\n        max_outsize=768\r\n    )\r\n\r\n    # parse the LTV from collateralReserveData and convert it to a percentage\r\n    collateralAssetLTV: decimal = convert(convert(slice(collateralReserveData, 30, 2), uint256), decimal) / 10000.0\r\n\r\n    # get the current borrowIndex of the borrow asset\r\n    borrowReserveData: Bytes[768] = raw_call(\r\n        _borrow_context.aaveV2LendingPool,\r\n        concat(\r\n            method_id(\"getReserveData(address)\"),\r\n            convert(_borrow_context.underlying, bytes32)\r\n        ),\r\n        max_outsize=768\r\n    )\r\n\r\n    # parse the variableBorrowIndex from borrowReserveData\r\n    borrowIndex: uint256 = convert(slice(borrowReserveData, 64, 32), uint256)\r\n\r\n    # get the price of the borrow asset and the collateral asset denominated in ETH\r\n    borrowAssetPriceScaled: uint256 = AAVE_V2_PRICE_FEED(_borrow_context.aaveV2PriceFeed).getAssetPrice(_borrow_context.underlying)\r\n    collateralAssetPriceScaled: uint256 = AAVE_V2_PRICE_FEED(_collateral_context.aaveV2PriceFeed).getAssetPrice(_collateral_context.underlying)\r\n\r\n    # scale down the asset prices and convert them to decimals\r\n    borrowAssetPrice: decimal = convert(borrowAssetPriceScaled, decimal) / convert(TEN_EXP_18, decimal)\r\n    collateralAssetPrice: decimal = convert(collateralAssetPriceScaled, decimal) / convert(TEN_EXP_18, decimal)\r\n\r\n    # convert the borrow amount to a decimal and scale it down\r\n    borrowAmount: decimal = convert(_amount, decimal) / convert(10 ** _borrow_context.decimals, decimal)\r\n\r\n    # calculate the protocol fee\r\n    originationFee: decimal = (borrowAmount * (convert(self.protocolFee, decimal) / convert(TEN_EXP_18, decimal))) / (collateralAssetPrice / borrowAssetPrice)\r\n\r\n    # calculate the value of the borrow request denominated in ETH\r\n    borrowAmountInETH: decimal = borrowAmount * borrowAssetPrice\r\n\r\n    # calculate the required collateral denominated in ETH\r\n    requiredCollateralInETH: decimal = borrowAmountInETH / collateralAssetLTV\r\n    \r\n    # calculate the required collateral denominated in the collateral asset \r\n    requiredCollateral: decimal = requiredCollateralInETH / collateralAssetPrice\r\n\r\n    # calculate the required collateral for Greenwood plus fees denominated in the collateral asset \r\n    requiredCollateralGreenwood: decimal = requiredCollateral * (convert(_collateralization_ratio, decimal) / 100.0)\r\n\r\n    # scale the required collateral for Greenwood by the decimals of the collateral asset\r\n    requiredCollateralScaled: uint256 = convert(requiredCollateralGreenwood * convert(10 ** _collateral_context.decimals, decimal), uint256)\r\n\r\n    # return the calculations\r\n    return AaveV2BorrowCalculation({\r\n        requiredCollateral: requiredCollateralScaled,\r\n        borrowIndex: borrowIndex,\r\n        borrowAmount: convert(borrowAmount * convert(10 ** _borrow_context.decimals, decimal), uint256),    # scale the borrow amount back up and convert it to a uint256\r\n        originationFee: convert(originationFee * convert(10 ** _collateral_context.decimals, decimal), uint256) # scale the protocol fee back up and convert it to a uint256\r\n    })\r\n\r\n@external\r\ndef calculateWithdraw(_borrow_context: AssetContext, _collateral_context: AssetContext, _escrow: address, _loan: Loan, _version: String[11]) -> AaveV2WithdrawCalculation:\r\n    \"\"\"\r\n    @notice Calculate and return values needed to withdraw collateral from Aave V2\r\n    @param _borrow_context The AssetContext struct of the asset being borrowed\r\n    @param _collateral_context The AssetContext struct of the asset being used as collateral\r\n    @param _escrow The address of the Greenwood Escrow use\r\n    @param _loan A Loan struct containing loan data\r\n    @param _version The version of the Greenwood Protocol to use\r\n    @return AaveV2WithdrawCalculation struct\r\n    @dev Only the AaveV2Escrow or the Governance can call this method\r\n    \"\"\"\r\n\r\n    # require that the method caller is the Escrow or the Governance\r\n    assert self.isAuthorized(msg.sender, \"escrow\", _version) == True or self.isAuthorized(msg.sender, \"governance\", _version) == True, \"Only Escrow or Governance can call this method\"\r\n\r\n    # get the LTV ratio of the collateral asset\r\n    collateralReserveData: Bytes[768] = raw_call(\r\n        _collateral_context.aaveV2LendingPool,\r\n        concat(\r\n            method_id(\"getReserveData(address)\"),\r\n            convert(_collateral_context.underlying, bytes32)\r\n        ),\r\n        max_outsize=768\r\n    )\r\n\r\n    # parse the LTV from collateralReserveData and convert it to a percentage\r\n    collateralAssetLTV: decimal = convert(convert(slice(collateralReserveData, 30, 2), uint256), decimal) / 10000.0\r\n\r\n    # get the current borrowIndex of the borrow asset\r\n    borrowReserveData: Bytes[768] = raw_call(\r\n        _borrow_context.aaveV2LendingPool,\r\n        concat(\r\n            method_id(\"getReserveData(address)\"),\r\n            convert(_borrow_context.underlying, bytes32)\r\n        ),\r\n        max_outsize=768\r\n    )\r\n\r\n    # parse the variableBorrowIndex from borrowReserveData\r\n    borrowIndex: uint256 = convert(slice(borrowReserveData, 64, 32), uint256)\r\n\r\n    # parse the variableDebtTokenAddress from borrowReserveData\r\n    variableDebtTokenAddress: address = convert(convert(slice(borrowReserveData, 288, 32), bytes32), address)\r\n\r\n    # get variableDebtToken balance of the Escrow\r\n    escrowBorrowBalance: uint256 = ERC20(variableDebtTokenAddress).balanceOf(_escrow)\r\n\r\n    # get the variableDebtToken scaledBalanceOf of the Escrow\r\n    scaledBalanceOfResponse: Bytes[32] = raw_call(\r\n        variableDebtTokenAddress,\r\n        concat(\r\n            method_id(\"scaledBalanceOf(address)\"),\r\n            convert(_escrow, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n\r\n    # convert the scaledBalanceOfResponse to a uint256\r\n    scaledBalanceOf: uint256 = convert(scaledBalanceOfResponse, uint256)\r\n\r\n    # calculate the borrow balance increase of the Escrow\r\n    balanceIncrease: decimal = ((convert(escrowBorrowBalance, decimal) - convert(scaledBalanceOf, decimal)) * (convert(_loan.lastBorrowIndex, decimal) / convert(10 ** 27, decimal))) / convert(10 ** 18, decimal)\r\n\r\n    # declare a memory variable to store the amount of interest accrued\r\n    interestAccrued: decimal = 0.0\r\n\r\n    # check that the escrow borrow balance is not equal to the balance increase to prevent division by 0\r\n    if convert(escrowBorrowBalance, decimal) != balanceIncrease:\r\n\r\n        # calculate the interest accrued since the last action on the loan\r\n        interestAccrued = balanceIncrease / (convert(escrowBorrowBalance, decimal) - balanceIncrease)\r\n\r\n    # apply interest accrued to the outstanding balance of the loan\r\n    borrowBalanceScaled: uint256 = convert(convert(_loan.outstanding, decimal) * (1.0 + interestAccrued), uint256)\r\n\r\n    # get the price of the borrow asset and the collateral asset denominated in ETH\r\n    borrowAssetPriceExp: uint256 = AAVE_V2_PRICE_FEED(_borrow_context.aaveV2PriceFeed).getAssetPrice(_borrow_context.underlying)\r\n    collateralAssetPriceExp: uint256 = AAVE_V2_PRICE_FEED(_collateral_context.aaveV2PriceFeed).getAssetPrice(_collateral_context.underlying)\r\n\r\n    # scale down the prices and convert them to decimals\r\n    borrowAssetPrice: decimal = convert(borrowAssetPriceExp, decimal) / convert(TEN_EXP_18, decimal)\r\n    collateralAssetPrice: decimal = convert(collateralAssetPriceExp, decimal) / convert(TEN_EXP_18, decimal)\r\n\r\n    # convert the borrow balance to a decimal and scale it down\r\n    borrowBalance: decimal = convert(borrowBalanceScaled, decimal) / convert(10 ** _borrow_context.decimals, decimal)\r\n\r\n    # calculate the value of the borrow balance denominated in ETH\r\n    borrowAmountInETH: decimal = borrowBalance * borrowAssetPrice\r\n\r\n    # calculate the required collateral denominated in ETH\r\n    requiredCollateralInETH: decimal = borrowAmountInETH / collateralAssetLTV\r\n\r\n    # calculate the required collateral denominated in the collateral asset \r\n    requiredCollateral: decimal = requiredCollateralInETH / collateralAssetPrice\r\n\r\n    # calculate the required collateral for Greenwood denominated in the collateral asset \r\n    requiredCollateralGreenwood: decimal = requiredCollateral * (convert(_loan.collateralizationRatio, decimal) / 100.0)\r\n\r\n    # scale the required collateral for Greenwood by the decimals of the collateral asset\r\n    requiredCollateralScaled: uint256 = convert(requiredCollateralGreenwood * convert(10 ** _collateral_context.decimals, decimal), uint256)\r\n\r\n    # return the calculation\r\n    return AaveV2WithdrawCalculation({\r\n        requiredCollateral: requiredCollateralScaled,\r\n        outstanding: borrowBalanceScaled\r\n    })\r\n\r\n@external\r\ndef calculateRepay(_borrow_context: AssetContext, _collateral_context: AssetContext, _amount: uint256, _escrow: address, _loan: Loan, _version: String[11]) -> AaveV2RepayCalculation:\r\n    \"\"\"\r\n    @notice Calculate and return values needed to repay a loan on Aave V2\r\n    @param _borrow_context The AssetContext struct of the asset being borrowed\r\n    @param _collateral_context The AssetContext struct of the asset being used as collateral\r\n    @param _amount The amount of asset being repaid scaled by the asset's decimals\r\n    @param _escrow The address of the Greenwood Escrow use\r\n    @param _loan A Loan struct containing loan data\r\n    @param _version The version of the Greenwood Protocol to use\r\n    @return AaveV2RepayCalculation struct\r\n    @dev Passing 2 ** 256 - 1 as _amount triggers a full repayment\r\n    @dev Only the AaveV2Escrow or the Governance can call this method\r\n    \"\"\"\r\n\r\n    # require that the method caller is the Escrow or the Governance\r\n    assert self.isAuthorized(msg.sender, \"escrow\", _version) == True or self.isAuthorized(msg.sender, \"governance\", _version) == True, \"Only Escrow or Governance can call this method\"\r\n    \r\n    # get the current borrowIndex of the borrow asset\r\n    borrowReserveData: Bytes[768] = raw_call(\r\n        _borrow_context.aaveV2LendingPool,\r\n        concat(\r\n            method_id(\"getReserveData(address)\"),\r\n            convert(_borrow_context.underlying, bytes32)\r\n        ),\r\n        max_outsize=768\r\n    )\r\n\r\n    # parse the variableBorrowIndex from borrowReserveData\r\n    borrowIndex: uint256 = convert(slice(borrowReserveData, 64, 32), uint256)\r\n\r\n    # parse the variableDebtTokenAddress from borrowReserveData\r\n    variableDebtTokenAddress: address = convert(convert(slice(borrowReserveData, 288, 32), bytes32), address)\r\n\r\n    # get variableDebtToken balance of the Escrow\r\n    escrowBorrowBalance: uint256 = ERC20(variableDebtTokenAddress).balanceOf(_escrow)\r\n\r\n    # get the variableDebtToken scaledBalanceOf of the Escrow\r\n    scaledBalanceOfResponse: Bytes[32] = raw_call(\r\n        variableDebtTokenAddress,\r\n        concat(\r\n            method_id(\"scaledBalanceOf(address)\"),\r\n            convert(_escrow, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n\r\n    # convert the scaledBalanceOfResponse to a uint256\r\n    scaledBalanceOf: uint256 = convert(scaledBalanceOfResponse, uint256)\r\n\r\n    # calculate the borrow balance increase of the Escrow\r\n    balanceIncrease: decimal = ((convert(escrowBorrowBalance, decimal) - convert(scaledBalanceOf, decimal)) * (convert(_loan.lastBorrowIndex, decimal) / convert(10 ** 27, decimal))) / convert(10 ** 18, decimal)\r\n\r\n    # declare a memory variable to store the amount of interest accrued\r\n    interestAccrued: decimal = 0.0\r\n\r\n    # check that the escrow borrow balance is not equal to the balance increase to prevent division by 0\r\n    if convert(escrowBorrowBalance, decimal) != balanceIncrease:\r\n\r\n        # calculate the interest accrued since the last action on the loan\r\n        interestAccrued = balanceIncrease / (convert(escrowBorrowBalance, decimal) - balanceIncrease)\r\n\r\n    # apply interest accrued to the outstanding balance of the loan\r\n    borrowBalance: uint256 = convert(convert(_loan.outstanding, decimal) * (1.0 + interestAccrued), uint256)\r\n\r\n    # declare a memory variable to store the repayment amount \r\n    repayAmount: uint256 = 0\r\n\r\n    # check if this is a full repayment or an over-repayment\r\n    if _amount == MAX_UINT256 or _amount > borrowBalance:\r\n\r\n        # set repaymentAmount to be the borrowBalance\r\n        repayAmount = borrowBalance\r\n\r\n    # handle partial repayment\r\n    else:\r\n\r\n        # set repaymentAmount to be the requested amount\r\n        repayAmount = _amount\r\n\r\n    # subtract the repayment amount from the borrow balance to get the outstanding balance\r\n    outstandingBalanceScaled: int128 = convert(borrowBalance, int128) - convert(repayAmount, int128)\r\n\r\n    # get the LTV ratio of the collateral asset\r\n    collateralReserveData: Bytes[768] = raw_call(\r\n        _collateral_context.aaveV2LendingPool,\r\n        concat(\r\n            method_id(\"getReserveData(address)\"),\r\n            convert(_collateral_context.underlying, bytes32)\r\n        ),\r\n        max_outsize=768\r\n    )\r\n\r\n    # parse the LTV from collateralReserveData and convert it to a percentage\r\n    collateralAssetLTV: decimal = convert(convert(slice(collateralReserveData, 30, 2), uint256), decimal) / 10000.0\r\n\r\n    # get the price of the borrow asset and the collateral asset denominated in ETH\r\n    borrowAssetPriceExp: uint256 = AAVE_V2_PRICE_FEED(_borrow_context.aaveV2PriceFeed).getAssetPrice(_borrow_context.underlying)\r\n    collateralAssetPriceExp: uint256 = AAVE_V2_PRICE_FEED(_collateral_context.aaveV2PriceFeed).getAssetPrice(_collateral_context.underlying)\r\n\r\n    # scale down the prices and convert them to decimals\r\n    borrowAssetPrice: decimal = convert(borrowAssetPriceExp, decimal) / convert(TEN_EXP_18, decimal)\r\n    collateralAssetPrice: decimal = convert(collateralAssetPriceExp, decimal) / convert(TEN_EXP_18, decimal)\r\n\r\n    # convert the outstanding balance to a decimal and scale it down\r\n    outstandingBalance: decimal = convert(outstandingBalanceScaled, decimal) / convert(10 ** _borrow_context.decimals, decimal)\r\n\r\n    # calculate the value of the outstanding borrow amount denominated in ETH\r\n    borrowAmountInETH: decimal = outstandingBalance * borrowAssetPrice\r\n\r\n    # calculate the required collateral denominated in ETH\r\n    requiredCollateralInETH: decimal = borrowAmountInETH / collateralAssetLTV\r\n\r\n    # calculate the amount of collateral asset to lock\r\n    requiredCollateral: decimal = requiredCollateralInETH / collateralAssetPrice\r\n\r\n    # calculate the required collateral denominated in the collateral asset\r\n    requiredCollateralGreenwood: decimal = requiredCollateral * (convert(_loan.collateralizationRatio, decimal) / 100.0)\r\n\r\n    # calculate the required collateral for Greenwood denominated in the collateral asset \r\n    requiredCollateralScaled: uint256 = convert(requiredCollateralGreenwood * convert(10 ** _collateral_context.decimals, decimal), uint256)\r\n\r\n    # calculate the redemption amount\r\n    redemptionAmount: int128 = convert(_loan.collateralLocked, int128) - convert(requiredCollateralScaled, int128)\r\n\r\n    # return the calculations\r\n    return AaveV2RepayCalculation({\r\n        repayAmount: repayAmount,\r\n        redemptionAmount: redemptionAmount,\r\n        requiredCollateral: requiredCollateralScaled,\r\n        outstanding: convert(outstandingBalance * convert(10 ** _borrow_context.decimals, decimal), int128), # scale the outstanding balance back up and convert it to an int128\r\n        borrowIndex: borrowIndex\r\n    })\r\n\r\n@external\r\ndef setProtocolFee(_new_fee: uint256):\r\n    \"\"\"\r\n    @notice Updates the protocol fee\r\n    @param _new_fee The new protocol fee\r\n    @dev Only the Governance can call this method\r\n    \"\"\"\r\n\r\n    # require that the method caller is the Governance\r\n    assert self.isAuthorized(msg.sender, \"governance\", \"\") == True, \"Only Governance can call this method\"\r\n\r\n    # get the previous protocol fee\r\n    previousFee: uint256 = self.protocolFee\r\n\r\n    # update the protocol fee\r\n    self.protocolFee = _new_fee\r\n\r\n    # emit a SetFee event\r\n    log SetFee(previousFee, _new_fee, msg.sender, block.number)\r\n\r\n@external\r\ndef setRegistry(_new_registry: address):\r\n    \"\"\"\r\n    @notice Updates the address of the Registry\r\n    @param _new_registry The address of the new Greenwood Registry\r\n    @dev Only the Governance can call this method\r\n    @dev Only call this method with a valid Greenwood Registry or subsequent calls will fail!\r\n    \"\"\"\r\n\r\n    # require that the method caller is the Governance\r\n    assert self.isAuthorized(msg.sender, \"governance\", \"\") == True, \"Only Governance can call this method\"\r\n\r\n    # get the previous Registry\r\n    previousRegistry: address = self.registry\r\n\r\n    # update the address of the Registry\r\n    self.registry = _new_registry\r\n\r\n    # emit a SetRegistry event\r\n    log SetRegistry(previousRegistry, _new_registry, msg.sender, block.number)","ABI":"[{\"name\":\"SetFee\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"previousFee\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"newFee\",\"indexed\":false},{\"type\":\"address\",\"name\":\"governance\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetRegistry\",\"inputs\":[{\"type\":\"address\",\"name\":\"previousRegistry\",\"indexed\":false},{\"type\":\"address\",\"name\":\"newRegistry\",\"indexed\":false},{\"type\":\"address\",\"name\":\"governance\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_protocol_fee\"},{\"type\":\"address\",\"name\":\"_registry\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"calculateBorrow\",\"outputs\":[{\"type\":\"tuple\",\"name\":\"\",\"components\":[{\"type\":\"uint256\",\"name\":\"requiredCollateral\"},{\"type\":\"uint256\",\"name\":\"borrowIndex\"},{\"type\":\"uint256\",\"name\":\"borrowAmount\"},{\"type\":\"uint256\",\"name\":\"originationFee\"}]}],\"inputs\":[{\"type\":\"tuple\",\"name\":\"_borrow_context\",\"components\":[{\"type\":\"address\",\"name\":\"aToken\"},{\"type\":\"address\",\"name\":\"aaveV2PriceFeed\"},{\"type\":\"address\",\"name\":\"aaveV2LendingPool\"},{\"type\":\"address\",\"name\":\"cToken\"},{\"type\":\"address\",\"name\":\"compoundPriceFeed\"},{\"type\":\"address\",\"name\":\"comptroller\"},{\"type\":\"uint256\",\"name\":\"decimals\"},{\"type\":\"address\",\"name\":\"underlying\"}]},{\"type\":\"tuple\",\"name\":\"_collateral_context\",\"components\":[{\"type\":\"address\",\"name\":\"aToken\"},{\"type\":\"address\",\"name\":\"aaveV2PriceFeed\"},{\"type\":\"address\",\"name\":\"aaveV2LendingPool\"},{\"type\":\"address\",\"name\":\"cToken\"},{\"type\":\"address\",\"name\":\"compoundPriceFeed\"},{\"type\":\"address\",\"name\":\"comptroller\"},{\"type\":\"uint256\",\"name\":\"decimals\"},{\"type\":\"address\",\"name\":\"underlying\"}]},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"uint256\",\"name\":\"_collateralization_ratio\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":31404},{\"name\":\"calculateWithdraw\",\"outputs\":[{\"type\":\"tuple\",\"name\":\"\",\"components\":[{\"type\":\"uint256\",\"name\":\"requiredCollateral\"},{\"type\":\"uint256\",\"name\":\"outstanding\"}]}],\"inputs\":[{\"type\":\"tuple\",\"name\":\"_borrow_context\",\"components\":[{\"type\":\"address\",\"name\":\"aToken\"},{\"type\":\"address\",\"name\":\"aaveV2PriceFeed\"},{\"type\":\"address\",\"name\":\"aaveV2LendingPool\"},{\"type\":\"address\",\"name\":\"cToken\"},{\"type\":\"address\",\"name\":\"compoundPriceFeed\"},{\"type\":\"address\",\"name\":\"comptroller\"},{\"type\":\"uint256\",\"name\":\"decimals\"},{\"type\":\"address\",\"name\":\"underlying\"}]},{\"type\":\"tuple\",\"name\":\"_collateral_context\",\"components\":[{\"type\":\"address\",\"name\":\"aToken\"},{\"type\":\"address\",\"name\":\"aaveV2PriceFeed\"},{\"type\":\"address\",\"name\":\"aaveV2LendingPool\"},{\"type\":\"address\",\"name\":\"cToken\"},{\"type\":\"address\",\"name\":\"compoundPriceFeed\"},{\"type\":\"address\",\"name\":\"comptroller\"},{\"type\":\"uint256\",\"name\":\"decimals\"},{\"type\":\"address\",\"name\":\"underlying\"}]},{\"type\":\"address\",\"name\":\"_escrow\"},{\"type\":\"tuple\",\"name\":\"_loan\",\"components\":[{\"type\":\"address\",\"name\":\"collateralAsset\"},{\"type\":\"address\",\"name\":\"borrowAsset\"},{\"type\":\"uint256\",\"name\":\"outstanding\"},{\"type\":\"uint256\",\"name\":\"collateralizationRatio\"},{\"type\":\"uint256\",\"name\":\"collateralLocked\"},{\"type\":\"address\",\"name\":\"borrower\"},{\"type\":\"uint256\",\"name\":\"lastBorrowIndex\"},{\"type\":\"uint256\",\"name\":\"repaymentTime\"}]},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36499},{\"name\":\"calculateRepay\",\"outputs\":[{\"type\":\"tuple\",\"name\":\"\",\"components\":[{\"type\":\"uint256\",\"name\":\"repayAmount\"},{\"type\":\"int128\",\"name\":\"redemptionAmount\"},{\"type\":\"uint256\",\"name\":\"requiredCollateral\"},{\"type\":\"int128\",\"name\":\"outstanding\"},{\"type\":\"uint256\",\"name\":\"borrowIndex\"}]}],\"inputs\":[{\"type\":\"tuple\",\"name\":\"_borrow_context\",\"components\":[{\"type\":\"address\",\"name\":\"aToken\"},{\"type\":\"address\",\"name\":\"aaveV2PriceFeed\"},{\"type\":\"address\",\"name\":\"aaveV2LendingPool\"},{\"type\":\"address\",\"name\":\"cToken\"},{\"type\":\"address\",\"name\":\"compoundPriceFeed\"},{\"type\":\"address\",\"name\":\"comptroller\"},{\"type\":\"uint256\",\"name\":\"decimals\"},{\"type\":\"address\",\"name\":\"underlying\"}]},{\"type\":\"tuple\",\"name\":\"_collateral_context\",\"components\":[{\"type\":\"address\",\"name\":\"aToken\"},{\"type\":\"address\",\"name\":\"aaveV2PriceFeed\"},{\"type\":\"address\",\"name\":\"aaveV2LendingPool\"},{\"type\":\"address\",\"name\":\"cToken\"},{\"type\":\"address\",\"name\":\"compoundPriceFeed\"},{\"type\":\"address\",\"name\":\"comptroller\"},{\"type\":\"uint256\",\"name\":\"decimals\"},{\"type\":\"address\",\"name\":\"underlying\"}]},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"address\",\"name\":\"_escrow\"},{\"type\":\"tuple\",\"name\":\"_loan\",\"components\":[{\"type\":\"address\",\"name\":\"collateralAsset\"},{\"type\":\"address\",\"name\":\"borrowAsset\"},{\"type\":\"uint256\",\"name\":\"outstanding\"},{\"type\":\"uint256\",\"name\":\"collateralizationRatio\"},{\"type\":\"uint256\",\"name\":\"collateralLocked\"},{\"type\":\"address\",\"name\":\"borrower\"},{\"type\":\"uint256\",\"name\":\"lastBorrowIndex\"},{\"type\":\"uint256\",\"name\":\"repaymentTime\"}]},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38016},{\"name\":\"setProtocolFee\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_new_fee\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":46859},{\"name\":\"setRegistry\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_new_registry\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":46928},{\"name\":\"protocolFee\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1331},{\"name\":\"registry\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1361}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.3","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ddbb7a21905c6a8dbd76b20b7c6b3a55d1af24f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}