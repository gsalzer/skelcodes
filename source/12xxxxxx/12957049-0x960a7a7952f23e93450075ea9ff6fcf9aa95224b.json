{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/stakingpools/StakingPools.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./interfaces/IStakingPoolMigrator.sol\\\";\\nimport \\\"./interfaces/IStakingPoolRewarder.sol\\\";\\n\\n/**\\n * @title StakingPools\\n *\\n * @dev A contract for staking Uniswap LP tokens in exchange for locked CONV rewards.\\n * No actual CONV tokens will be held or distributed by this contract. Only the amounts\\n * are accumulated.\\n *\\n * @dev The `migrator` in this contract has access to users' staked tokens. Any changes\\n * to the migrator address will only take effect after a delay period specified at contract\\n * creation.\\n *\\n * @dev This contract interacts with token contracts via `safeApprove`, `safeTransfer`,\\n * and `safeTransferFrom` instead of the standard Solidity interface so that some non-ERC20-\\n * compatible tokens (e.g. Tether) can also be staked.\\n */\\ncontract StakingPools is Ownable {\\n    using SafeMath for uint256;\\n\\n    event PoolCreated(\\n        uint256 indexed poolId,\\n        address indexed token,\\n        uint256 startBlock,\\n        uint256 endBlock,\\n        uint256 migrationBlock,\\n        uint256 rewardPerBlock\\n    );\\n    event PoolEndBlockExtended(uint256 indexed poolId, uint256 oldEndBlock, uint256 newEndBlock);\\n    event PoolMigrationBlockExtended(uint256 indexed poolId, uint256 oldMigrationBlock, uint256 newMigrationBlock);\\n    event PoolRewardRateChanged(uint256 indexed poolId, uint256 oldRewardPerBlock, uint256 newRewardPerBlock);\\n    event MigratorChangeProposed(address newMigrator);\\n    event MigratorChanged(address oldMigrator, address newMigrator);\\n    event RewarderChanged(address oldRewarder, address newRewarder);\\n    event PoolMigrated(uint256 indexed poolId, address oldToken, address newToken);\\n    event Staked(uint256 indexed poolId, address indexed staker, address token, uint256 amount);\\n    event Unstaked(uint256 indexed poolId, address indexed staker, address token, uint256 amount);\\n    event RewardRedeemed(uint256 indexed poolId, address indexed staker, address rewarder, uint256 amount);\\n\\n    /**\\n     * @param startBlock the block from which reward accumulation starts\\n     * @param endBlock the block from which reward accumulation stops\\n     * @param migrationBlock the block since which LP token migration can be triggered\\n     * @param rewardPerBlock total amount of token to be rewarded in a block\\n     * @param poolToken token to be staked\\n     */\\n    struct PoolInfo {\\n        uint256 startBlock;\\n        uint256 endBlock;\\n        uint256 migrationBlock;\\n        uint256 rewardPerBlock;\\n        address poolToken;\\n    }\\n    /**\\n     * @param totalStakeAmount total amount of staked tokens\\n     * @param accuRewardPerShare accumulated rewards for a single unit of token staked, multiplied by `ACCU_REWARD_MULTIPLIER`\\n     * @param accuRewardLastUpdateBlock the block number at which the `accuRewardPerShare` field was last updated\\n     */\\n    struct PoolData {\\n        uint256 totalStakeAmount;\\n        uint256 accuRewardPerShare;\\n        uint256 accuRewardLastUpdateBlock;\\n    }\\n    /**\\n     * @param stakeAmount amount of token the user stakes\\n     * @param pendingReward amount of reward to be redeemed by the user up to the user's last action\\n     * @param entryAccuRewardPerShare the `accuRewardPerShare` value at the user's last stake/unstake action\\n     */\\n    struct UserData {\\n        uint256 stakeAmount;\\n        uint256 pendingReward;\\n        uint256 entryAccuRewardPerShare;\\n    }\\n    /**\\n     * @param proposeTime timestamp when the change is proposed\\n     * @param newMigrator new migrator address\\n     */\\n    struct PendingMigratorChange {\\n        uint64 proposeTime;\\n        address newMigrator;\\n    }\\n\\n    uint256 public lastPoolId; // The first pool has ID of 1\\n\\n    IStakingPoolMigrator public migrator;\\n    uint256 public migratorSetterDelay;\\n    PendingMigratorChange public pendingMigrator;\\n\\n    IStakingPoolRewarder public rewarder;\\n\\n    mapping(uint256 => PoolInfo) public poolInfos;\\n    mapping(uint256 => PoolData) public poolData;\\n    mapping(uint256 => mapping(address => UserData)) public userData;\\n\\n    uint256 private constant ACCU_REWARD_MULTIPLIER = 10**20; // Precision loss prevention\\n\\n    bytes4 private constant TRANSFER_SELECTOR = bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n    bytes4 private constant APPROVE_SELECTOR = bytes4(keccak256(bytes(\\\"approve(address,uint256)\\\")));\\n    bytes4 private constant TRANSFERFROM_SELECTOR = bytes4(keccak256(bytes(\\\"transferFrom(address,address,uint256)\\\")));\\n\\n    modifier onlyPoolExists(uint256 poolId) {\\n        require(poolInfos[poolId].endBlock > 0, \\\"StakingPools: pool not found\\\");\\n        _;\\n    }\\n\\n    modifier onlyPoolActive(uint256 poolId) {\\n        require(\\n            block.number >= poolInfos[poolId].startBlock && block.number < poolInfos[poolId].endBlock,\\n            \\\"StakingPools: pool not active\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyPoolNotEnded(uint256 poolId) {\\n        require(block.number < poolInfos[poolId].endBlock, \\\"StakingPools: pool ended\\\");\\n        _;\\n    }\\n\\n    function getReward(uint256 poolId, address staker) external view returns (uint256) {\\n        UserData memory currentUserData = userData[poolId][staker];\\n        PoolInfo memory currentPoolInfo = poolInfos[poolId];\\n        PoolData memory currentPoolData = poolData[poolId];\\n\\n        uint256 latestAccuRewardPerShare =\\n            currentPoolData.totalStakeAmount > 0\\n                ? currentPoolData.accuRewardPerShare.add(\\n                    Math\\n                        .min(block.number, currentPoolInfo.endBlock)\\n                        .sub(currentPoolData.accuRewardLastUpdateBlock)\\n                        .mul(currentPoolInfo.rewardPerBlock)\\n                        .mul(ACCU_REWARD_MULTIPLIER)\\n                        .div(currentPoolData.totalStakeAmount)\\n                )\\n                : currentPoolData.accuRewardPerShare;\\n\\n        return\\n            currentUserData.pendingReward.add(\\n                currentUserData.stakeAmount.mul(latestAccuRewardPerShare.sub(currentUserData.entryAccuRewardPerShare)).div(\\n                    ACCU_REWARD_MULTIPLIER\\n                )\\n            );\\n    }\\n\\n    constructor(uint256 _migratorSetterDelay) {\\n        require(_migratorSetterDelay > 0, \\\"StakingPools: zero setter delay\\\");\\n\\n        migratorSetterDelay = _migratorSetterDelay;\\n    }\\n\\n    function createPool(\\n        address token,\\n        uint256 startBlock,\\n        uint256 endBlock,\\n        uint256 migrationBlock,\\n        uint256 rewardPerBlock\\n    ) external onlyOwner {\\n        require(token != address(0), \\\"StakingPools: zero address\\\");\\n        require(\\n            startBlock > block.number && endBlock > startBlock && migrationBlock > startBlock,\\n            \\\"StakingPools: invalid block range\\\"\\n        );\\n        require(rewardPerBlock > 0, \\\"StakingPools: reward must be positive\\\");\\n\\n        uint256 newPoolId = ++lastPoolId;\\n\\n        poolInfos[newPoolId] = PoolInfo({\\n            startBlock: startBlock,\\n            endBlock: endBlock,\\n            migrationBlock: migrationBlock,\\n            rewardPerBlock: rewardPerBlock,\\n            poolToken: token\\n        });\\n        poolData[newPoolId] = PoolData({totalStakeAmount: 0, accuRewardPerShare: 0, accuRewardLastUpdateBlock: startBlock});\\n\\n        emit PoolCreated(newPoolId, token, startBlock, endBlock, migrationBlock, rewardPerBlock);\\n    }\\n\\n    function extendEndBlock(uint256 poolId, uint256 newEndBlock)\\n        external\\n        onlyOwner\\n        onlyPoolExists(poolId)\\n        onlyPoolNotEnded(poolId)\\n    {\\n        uint256 currentEndBlock = poolInfos[poolId].endBlock;\\n        require(newEndBlock > currentEndBlock, \\\"StakingPools: end block not extended\\\");\\n\\n        poolInfos[poolId].endBlock = newEndBlock;\\n\\n        emit PoolEndBlockExtended(poolId, currentEndBlock, newEndBlock);\\n    }\\n\\n    function extendMigrationBlock(uint256 poolId, uint256 newMigrationBlock)\\n        external\\n        onlyOwner\\n        onlyPoolExists(poolId)\\n        onlyPoolNotEnded(poolId)\\n    {\\n        uint256 currentMigrationBlock = poolInfos[poolId].migrationBlock;\\n        require(newMigrationBlock > currentMigrationBlock, \\\"StakingPools: migration block not extended\\\");\\n\\n        poolInfos[poolId].migrationBlock = newMigrationBlock;\\n\\n        emit PoolMigrationBlockExtended(poolId, currentMigrationBlock, newMigrationBlock);\\n    }\\n\\n    function setPoolReward(uint256 poolId, uint256 newRewardPerBlock)\\n        external\\n        onlyOwner\\n        onlyPoolExists(poolId)\\n        onlyPoolNotEnded(poolId)\\n    {\\n        if ( block.number >= poolInfos[poolId].startBlock) {\\n            // \\\"Settle\\\" rewards up to this block \\n             _updatePoolAccuReward(poolId);\\n        }\\n\\n\\n        // We're deliberately allowing setting the reward rate to 0 here. If it turns\\n        // out this, or even changing rates at all, is undesirable after deployment, the\\n        // ownership of this contract can be transferred to a contract incapable of making\\n        // calls to this function.\\n        uint256 currentRewardPerBlock = poolInfos[poolId].rewardPerBlock;\\n        poolInfos[poolId].rewardPerBlock = newRewardPerBlock;\\n\\n        emit PoolRewardRateChanged(poolId, currentRewardPerBlock, newRewardPerBlock);\\n    }\\n\\n    function proposeMigratorChange(address newMigrator) external onlyOwner {\\n        pendingMigrator = PendingMigratorChange({proposeTime: uint64(block.timestamp), newMigrator: newMigrator});\\n\\n        emit MigratorChangeProposed(newMigrator);\\n    }\\n\\n    function executeMigratorChange() external {\\n        require(pendingMigrator.proposeTime > 0, \\\"StakingPools: migrator change proposal not found\\\");\\n        require(\\n            block.timestamp >= uint256(pendingMigrator.proposeTime).add(migratorSetterDelay),\\n            \\\"StakingPools: migrator setter delay not passed\\\"\\n        );\\n\\n        address oldMigrator = address(migrator);\\n        migrator = IStakingPoolMigrator(pendingMigrator.newMigrator);\\n\\n        // Clear storage\\n        pendingMigrator = PendingMigratorChange({proposeTime: 0, newMigrator: address(0)});\\n\\n        emit MigratorChanged(oldMigrator, address(migrator));\\n    }\\n\\n    function setRewarder(address newRewarder) external onlyOwner {\\n        address oldRewarder = address(rewarder);\\n        rewarder = IStakingPoolRewarder(newRewarder);\\n\\n        emit RewarderChanged(oldRewarder, newRewarder);\\n    }\\n\\n    function migratePool(uint256 poolId) external onlyPoolExists(poolId) {\\n        require(address(migrator) != address(0), \\\"StakingPools: migrator not set\\\");\\n\\n        PoolInfo memory currentPoolInfo = poolInfos[poolId];\\n        PoolData memory currentPoolData = poolData[poolId];\\n        require(block.number >= currentPoolInfo.migrationBlock, \\\"StakingPools: migration block not reached\\\");\\n\\n        safeApprove(currentPoolInfo.poolToken, address(migrator), currentPoolData.totalStakeAmount);\\n\\n        // New token balance is not validated here since the migrator can do whatever\\n        // it wants anyways (including providing a fake token address with fake balance).\\n        // It's the migrator contract's responsibility to ensure tokens are properly migrated.\\n        address newToken =\\n            migrator.migrate(poolId, address(currentPoolInfo.poolToken), uint256(currentPoolData.totalStakeAmount));\\n        require(newToken != address(0), \\\"StakingPools: zero new token address\\\");\\n\\n        poolInfos[poolId].poolToken = newToken;\\n\\n        emit PoolMigrated(poolId, currentPoolInfo.poolToken, newToken);\\n    }\\n\\n    function stake(uint256 poolId, uint256 amount) external onlyPoolExists(poolId) onlyPoolActive(poolId) {\\n        _updatePoolAccuReward(poolId);\\n        _updateStakerReward(poolId, msg.sender);\\n\\n        _stake(poolId, msg.sender, amount);\\n    }\\n\\n    function unstake(uint256 poolId, uint256 amount) external onlyPoolExists(poolId) {\\n        _updatePoolAccuReward(poolId);\\n        _updateStakerReward(poolId, msg.sender);\\n\\n        _unstake(poolId, msg.sender, amount);\\n    }\\n\\n    function emergencyUnstake(uint256 poolId) external onlyPoolExists(poolId) {\\n        _unstake(poolId, msg.sender, userData[poolId][msg.sender].stakeAmount);\\n\\n        // Forfeit user rewards to avoid abuse\\n        userData[poolId][msg.sender].pendingReward = 0;\\n    }\\n\\n    function redeemRewards(uint256 poolId) external onlyPoolExists(poolId) {\\n\\n        redeemRewardsByAddress(poolId, msg.sender);\\n    }\\n\\n    function redeemRewardsByAddress(uint256 poolId, address user) public onlyPoolExists(poolId) {\\n\\n        require(user != address(0), \\\"StakingPools: zero address\\\");\\n\\n        _updatePoolAccuReward(poolId);\\n        _updateStakerReward(poolId, user);\\n\\n        require(address(rewarder) != address(0), \\\"StakingPools: rewarder not set\\\");\\n\\n        uint256 rewardToRedeem = userData[poolId][user].pendingReward;\\n        require(rewardToRedeem > 0, \\\"StakingPools: no reward to redeem\\\");\\n\\n        userData[poolId][user].pendingReward = 0;\\n\\n        rewarder.onReward(poolId, user, rewardToRedeem);\\n\\n        emit RewardRedeemed(poolId, user, address(rewarder), rewardToRedeem);\\n    }\\n\\n    function _stake(\\n        uint256 poolId,\\n        address user,\\n        uint256 amount\\n    ) private {\\n        require(amount > 0, \\\"StakingPools: cannot stake zero amount\\\");\\n\\n        userData[poolId][user].stakeAmount = userData[poolId][user].stakeAmount.add(amount);\\n        poolData[poolId].totalStakeAmount = poolData[poolId].totalStakeAmount.add(amount);\\n\\n        safeTransferFrom(poolInfos[poolId].poolToken, user, address(this), amount);\\n\\n        emit Staked(poolId, user, poolInfos[poolId].poolToken, amount);\\n    }\\n\\n    function _unstake(\\n        uint256 poolId,\\n        address user,\\n        uint256 amount\\n    ) private {\\n        require(amount > 0, \\\"StakingPools: cannot unstake zero amount\\\");\\n\\n        // No sufficiency check required as sub() will throw anyways\\n        userData[poolId][user].stakeAmount = userData[poolId][user].stakeAmount.sub(amount);\\n        poolData[poolId].totalStakeAmount = poolData[poolId].totalStakeAmount.sub(amount);\\n\\n        safeTransfer(poolInfos[poolId].poolToken, user, amount);\\n\\n        emit Unstaked(poolId, user, poolInfos[poolId].poolToken, amount);\\n    }\\n\\n    function _updatePoolAccuReward(uint256 poolId) private {\\n        PoolInfo storage currentPoolInfo = poolInfos[poolId];\\n        PoolData storage currentPoolData = poolData[poolId];\\n\\n        uint256 appliedUpdateBlock = Math.min(block.number, currentPoolInfo.endBlock);\\n        uint256 durationInBlocks = appliedUpdateBlock.sub(currentPoolData.accuRewardLastUpdateBlock);\\n\\n        // This saves tx cost when being called multiple times in the same block\\n        if (durationInBlocks > 0) {\\n            // No need to update the rate if no one staked at all\\n            if (currentPoolData.totalStakeAmount > 0) {\\n                currentPoolData.accuRewardPerShare = currentPoolData.accuRewardPerShare.add(\\n                    durationInBlocks.mul(currentPoolInfo.rewardPerBlock).mul(ACCU_REWARD_MULTIPLIER).div(\\n                        currentPoolData.totalStakeAmount\\n                    )\\n                );\\n            }\\n            currentPoolData.accuRewardLastUpdateBlock = appliedUpdateBlock;\\n        }\\n    }\\n\\n    function _updateStakerReward(uint256 poolId, address staker) private {\\n        UserData storage currentUserData = userData[poolId][staker];\\n        PoolData storage currentPoolData = poolData[poolId];\\n\\n        uint256 stakeAmount = currentUserData.stakeAmount;\\n        uint256 stakerEntryRate = currentUserData.entryAccuRewardPerShare;\\n        uint256 accuDifference = currentPoolData.accuRewardPerShare.sub(stakerEntryRate);\\n\\n        if (accuDifference > 0) {\\n            currentUserData.pendingReward = currentUserData.pendingReward.add(\\n                stakeAmount.mul(accuDifference).div(ACCU_REWARD_MULTIPLIER)\\n            );\\n            currentUserData.entryAccuRewardPerShare = currentPoolData.accuRewardPerShare;\\n        }\\n    }\\n\\n    function safeApprove(\\n        address token,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(APPROVE_SELECTOR, spender, amount));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"StakingPools: approve failed\\\");\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address recipient,\\n        uint256 amount\\n    ) private {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(TRANSFER_SELECTOR, recipient, amount));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"StakingPools: transfer failed\\\");\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) private {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(TRANSFERFROM_SELECTOR, sender, recipient, amount));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"StakingPools: transferFrom failed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/stakingpools/interfaces/IStakingPoolMigrator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\ninterface IStakingPoolMigrator {\\n    function migrate(\\n        uint256 poolId,\\n        address oldToken,\\n        uint256 amount\\n    ) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/stakingpools/interfaces/IStakingPoolRewarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\ninterface IStakingPoolRewarder {\\n    function onReward(\\n        uint256 poolId,\\n        address user,\\n        uint256 amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_migratorSetterDelay\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMigrator\",\"type\":\"address\"}],\"name\":\"MigratorChangeProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldMigrator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMigrator\",\"type\":\"address\"}],\"name\":\"MigratorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"migrationBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldEndBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newEndBlock\",\"type\":\"uint256\"}],\"name\":\"PoolEndBlockExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"PoolMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMigrationBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMigrationBlock\",\"type\":\"uint256\"}],\"name\":\"PoolMigrationBlockExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRewardPerBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"PoolRewardRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewarder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldRewarder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRewarder\",\"type\":\"address\"}],\"name\":\"RewarderChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"migrationBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"emergencyUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executeMigratorChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newEndBlock\",\"type\":\"uint256\"}],\"name\":\"extendEndBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMigrationBlock\",\"type\":\"uint256\"}],\"name\":\"extendMigrationBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPoolId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"migratePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrator\",\"outputs\":[{\"internalType\":\"contract IStakingPoolMigrator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migratorSetterDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingMigrator\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"proposeTime\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"newMigrator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accuRewardPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accuRewardLastUpdateBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"migrationBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"poolToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMigrator\",\"type\":\"address\"}],\"name\":\"proposeMigratorChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"redeemRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"redeemRewardsByAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewarder\",\"outputs\":[{\"internalType\":\"contract IStakingPoolRewarder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newRewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"setPoolReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRewarder\",\"type\":\"address\"}],\"name\":\"setRewarder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"entryAccuRewardPerShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"StakingPools","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000093a80","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}