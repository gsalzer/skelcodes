{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/MerkleAirdrop.sol\r\n\r\n// Modified from https://github.com/Phala-Network/prelaunch-token/blob/master/contracts/MerkleAirdrop.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\ncontract MerkleAirdrop {\r\n    struct Airdrop {\r\n        bytes32 root;\r\n        string dataURI;\r\n        bool paused;\r\n        mapping(address => bool) awarded;\r\n    }\r\n\r\n    // Events\r\n    event Start(uint256 id);\r\n    event PauseChange(uint256 id, bool paused);\r\n    event Award(uint256 id, address recipient, uint256 amount);\r\n\r\n    // States\r\n    mapping(uint256 => Airdrop) public airdrops;\r\n    IERC20 public token;\r\n    uint256 public airdropsCount;\r\n\r\n    address public core;\r\n\r\n    // Errors\r\n    string private constant ERROR_AWARDED = \"AWARDED\";\r\n    string private constant ERROR_INVALID = \"INVALID\";\r\n    string private constant ERROR_PAUSED = \"PAUSED\";\r\n    string private constant ERROR_INVALID_BAL = \"INVALID_BAL\";\r\n\r\n    modifier onlyCore() {\r\n        require(msg.sender == core, \"Not Authorized\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        core = msg.sender;\r\n    }\r\n\r\n    function setToken(address _token) public onlyCore {\r\n        token = IERC20(_token);\r\n    }\r\n\r\n    /**\r\n     * @notice Start a new airdrop `_root` / `_dataURI`\r\n     * @param _root New airdrop merkle root\r\n     * @param _dataURI Data URI for airdrop data\r\n     */\r\n    function start(bytes32 _root, string memory _dataURI) public onlyCore {\r\n        require(token.balanceOf(address(this)) > 0, ERROR_INVALID_BAL);\r\n\r\n        uint256 id = ++airdropsCount; // start at 1\r\n        airdrops[id] = Airdrop(_root, _dataURI, false);\r\n        emit Start(id);\r\n    }\r\n\r\n    /**\r\n     * @notice Pause or resume an airdrop `_id` / `_paused`\r\n     * @param _id The airdrop to change status\r\n     * @param _paused Pause to resume\r\n     */\r\n    function setPause(uint256 _id, bool _paused) public onlyCore {\r\n        require(_id <= airdropsCount, ERROR_INVALID);\r\n        airdrops[_id].paused = _paused;\r\n        emit PauseChange(_id, _paused);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove tokens after airdrop has finished.\r\n     */\r\n    function removeToken() public onlyCore {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        if (balance > 0) {\r\n            token.transfer(core, balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Fetch Award from airdrop\r\n     * @param _id Airdrop id\r\n     * @param _recipient Airdrop recipient\r\n     * @param _amount The token amount\r\n     * @param _proof Merkle proof to correspond to data supplied\r\n     */\r\n    function award(\r\n        uint256 _id,\r\n        address _recipient,\r\n        uint256 _amount,\r\n        bytes32[] memory _proof\r\n    ) public {\r\n        require(_id <= airdropsCount, ERROR_INVALID);\r\n\r\n        Airdrop storage airdrop = airdrops[_id];\r\n        require(!airdrop.paused, ERROR_PAUSED);\r\n\r\n        bytes32 hash = keccak256(abi.encodePacked(_recipient, _amount));\r\n        require(validate(airdrop.root, _proof, hash), ERROR_INVALID);\r\n\r\n        require(!airdrops[_id].awarded[_recipient], ERROR_AWARDED);\r\n\r\n        airdrops[_id].awarded[_recipient] = true;\r\n\r\n        uint256 bal = token.balanceOf(address(this));\r\n        if (bal >= _amount) {\r\n            token.transfer(_recipient, _amount);\r\n        } else {\r\n            revert(\"INVALID_CONTRACT_BALANCE\");\r\n        }\r\n\r\n        emit Award(_id, _recipient, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Fetch Award from many airdrops\r\n     * @param _ids Airdrop ids\r\n     * @param _recipient Recepient of award\r\n     * @param _amounts The amounts\r\n     * @param _proofs Merkle proofs\r\n     * @param _proofLengths Merkle proof lengths\r\n     */\r\n    function awardFromMany(\r\n        uint256[] memory _ids,\r\n        address _recipient,\r\n        uint256[] memory _amounts,\r\n        bytes memory _proofs,\r\n        uint256[] memory _proofLengths\r\n    ) public {\r\n        uint256 totalAmount;\r\n\r\n        uint256 marker = 32;\r\n\r\n        for (uint256 i = 0; i < _ids.length; i++) {\r\n            uint256 id = _ids[i];\r\n            require(id <= airdropsCount, ERROR_INVALID);\r\n            require(!airdrops[id].paused, ERROR_PAUSED);\r\n\r\n            bytes32[] memory proof =\r\n                extractProof(_proofs, marker, _proofLengths[i]);\r\n            marker += _proofLengths[i] * 32;\r\n\r\n            bytes32 hash = keccak256(abi.encodePacked(_recipient, _amounts[i]));\r\n            require(validate(airdrops[id].root, proof, hash), ERROR_INVALID);\r\n\r\n            require(!airdrops[id].awarded[_recipient], ERROR_AWARDED);\r\n\r\n            airdrops[id].awarded[_recipient] = true;\r\n\r\n            totalAmount += _amounts[i];\r\n\r\n            emit Award(id, _recipient, _amounts[i]);\r\n        }\r\n\r\n        uint256 bal = token.balanceOf(address(this));\r\n        if (bal >= totalAmount) {\r\n            token.transfer(_recipient, totalAmount);\r\n        } else {\r\n            revert(\"INVALID_CONTRACT_BALANCE\");\r\n        }\r\n    }\r\n\r\n    function extractProof(\r\n        bytes memory _proofs,\r\n        uint256 _marker,\r\n        uint256 proofLength\r\n    ) public pure returns (bytes32[] memory proof) {\r\n        proof = new bytes32[](proofLength);\r\n\r\n        bytes32 el;\r\n\r\n        for (uint256 j = 0; j < proofLength; j++) {\r\n            assembly {\r\n                el := mload(add(_proofs, _marker))\r\n            }\r\n            proof[j] = el;\r\n            _marker += 32;\r\n        }\r\n    }\r\n\r\n    function validate(\r\n        bytes32 root,\r\n        bytes32[] memory proof,\r\n        bytes32 hash\r\n    ) public pure returns (bool) {\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            if (hash < proof[i]) {\r\n                hash = keccak256(abi.encodePacked(hash, proof[i]));\r\n            } else {\r\n                hash = keccak256(abi.encodePacked(proof[i], hash));\r\n            }\r\n        }\r\n\r\n        return hash == root;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if recipient:`_recipient` awarded from airdrop:`_id`\r\n     * @param _id Airdrop id\r\n     * @param _recipient Recipient to check\r\n     */\r\n    function awarded(uint256 _id, address _recipient)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return airdrops[_id].awarded[_recipient];\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Award\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"PauseChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Start\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"airdrops\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"dataURI\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airdropsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"award\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_proofs\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"_proofLengths\",\"type\":\"uint256[]\"}],\"name\":\"awardFromMany\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"awarded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"core\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_proofs\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_marker\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proofLength\",\"type\":\"uint256\"}],\"name\":\"extractProof\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"_dataURI\",\"type\":\"string\"}],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"MerkleAirdrop","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"istanbul","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d87e1b75b40a3c7a80dad321259c0fad0b0661835ff1753ed2a29cb2f9d0a036"}]}