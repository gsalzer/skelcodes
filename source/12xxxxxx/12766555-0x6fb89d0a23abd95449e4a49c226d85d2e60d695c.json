{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/cover/Quotation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"../../abstract/MasterAware.sol\\\";\\nimport \\\"../../interfaces/IClaimsReward.sol\\\";\\nimport \\\"../../interfaces/IIncidents.sol\\\";\\nimport \\\"../../interfaces/IPool.sol\\\";\\nimport \\\"../../interfaces/IPooledStaking.sol\\\";\\nimport \\\"../../interfaces/IQuotation.sol\\\";\\nimport \\\"../../interfaces/IQuotationData.sol\\\";\\nimport \\\"../../interfaces/ITokenController.sol\\\";\\nimport \\\"../../interfaces/ITokenData.sol\\\";\\n\\ncontract Quotation is IQuotation, MasterAware, ReentrancyGuard {\\n  using SafeMath for uint;\\n\\n  IClaimsReward public cr;\\n  IPool public pool;\\n  IPooledStaking public pooledStaking;\\n  IQuotationData public qd;\\n  ITokenController public tc;\\n  ITokenData public td;\\n  IIncidents public incidents;\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public onlyInternal {\\n    cr = IClaimsReward(master.getLatestAddress(\\\"CR\\\"));\\n    pool = IPool(master.getLatestAddress(\\\"P1\\\"));\\n    pooledStaking = IPooledStaking(master.getLatestAddress(\\\"PS\\\"));\\n    qd = IQuotationData(master.getLatestAddress(\\\"QD\\\"));\\n    tc = ITokenController(master.getLatestAddress(\\\"TC\\\"));\\n    td = ITokenData(master.getLatestAddress(\\\"TD\\\"));\\n    incidents = IIncidents(master.getLatestAddress(\\\"IC\\\"));\\n  }\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  function sendEther() public payable {}\\n\\n  /**\\n   * @dev Expires a cover after a set period of time and changes the status of the cover\\n   * @dev Reduces the total and contract sum assured\\n   * @param coverId Cover Id.\\n   */\\n  function expireCover(uint coverId) external {\\n\\n    uint expirationDate = qd.getValidityOfCover(coverId);\\n    require(expirationDate < now, \\\"Quotation: cover is not due to expire\\\");\\n\\n    uint coverStatus = qd.getCoverStatusNo(coverId);\\n    require(coverStatus != uint(IQuotationData.CoverStatus.CoverExpired), \\\"Quotation: cover already expired\\\");\\n\\n    (/* claim count */, bool hasOpenClaim, /* accepted */) = tc.coverInfo(coverId);\\n    require(!hasOpenClaim, \\\"Quotation: cover has an open claim\\\");\\n\\n    if (coverStatus != uint(IQuotationData.CoverStatus.ClaimAccepted)) {\\n      (,, address contractAddress, bytes4 currency, uint amount,) = qd.getCoverDetailsByCoverID1(coverId);\\n      qd.subFromTotalSumAssured(currency, amount);\\n      qd.subFromTotalSumAssuredSC(contractAddress, currency, amount);\\n    }\\n\\n    qd.changeCoverStatusNo(coverId, uint8(IQuotationData.CoverStatus.CoverExpired));\\n  }\\n\\n  function withdrawCoverNote(address coverOwner, uint[] calldata coverIds, uint[] calldata reasonIndexes) external {\\n\\n    uint gracePeriod = tc.claimSubmissionGracePeriod();\\n\\n    for (uint i = 0; i < coverIds.length; i++) {\\n      uint expirationDate = qd.getValidityOfCover(coverIds[i]);\\n      require(expirationDate.add(gracePeriod) < now, \\\"Quotation: cannot withdraw before grace period expiration\\\");\\n    }\\n\\n    tc.withdrawCoverNote(coverOwner, coverIds, reasonIndexes);\\n  }\\n\\n  function getWithdrawableCoverNoteCoverIds(\\n    address coverOwner\\n  ) public view returns (\\n    uint[] memory expiredCoverIds,\\n    bytes32[] memory lockReasons\\n  ) {\\n\\n    uint[] memory coverIds = qd.getAllCoversOfUser(coverOwner);\\n    uint[] memory expiredIdsQueue = new uint[](coverIds.length);\\n    uint gracePeriod = tc.claimSubmissionGracePeriod();\\n    uint expiredQueueLength = 0;\\n\\n    for (uint i = 0; i < coverIds.length; i++) {\\n\\n      uint coverExpirationDate = qd.getValidityOfCover(coverIds[i]);\\n      uint gracePeriodExpirationDate = coverExpirationDate.add(gracePeriod);\\n      (/* claimCount */, bool hasOpenClaim, /* hasAcceptedClaim */) = tc.coverInfo(coverIds[i]);\\n\\n      if (!hasOpenClaim && gracePeriodExpirationDate < now) {\\n        expiredIdsQueue[expiredQueueLength] = coverIds[i];\\n        expiredQueueLength++;\\n      }\\n    }\\n\\n    expiredCoverIds = new uint[](expiredQueueLength);\\n    lockReasons = new bytes32[](expiredQueueLength);\\n\\n    for (uint i = 0; i < expiredQueueLength; i++) {\\n      expiredCoverIds[i] = expiredIdsQueue[i];\\n      lockReasons[i] = keccak256(abi.encodePacked(\\\"CN\\\", coverOwner, expiredIdsQueue[i]));\\n    }\\n  }\\n\\n  function getWithdrawableCoverNotesAmount(address coverOwner) external view returns (uint) {\\n\\n    uint withdrawableAmount;\\n    bytes32[] memory lockReasons;\\n    (/*expiredCoverIds*/, lockReasons) = getWithdrawableCoverNoteCoverIds(coverOwner);\\n\\n    for (uint i = 0; i < lockReasons.length; i++) {\\n      uint coverNoteAmount = tc.tokensLocked(coverOwner, lockReasons[i]);\\n      withdrawableAmount = withdrawableAmount.add(coverNoteAmount);\\n    }\\n\\n    return withdrawableAmount;\\n  }\\n\\n  /**\\n   * @dev Makes Cover funded via NXM tokens.\\n   * @param smartCAdd Smart Contract Address\\n   */\\n  function makeCoverUsingNXMTokens(\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod,\\n    bytes4 coverCurr,\\n    address smartCAdd,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) external onlyMember whenNotPaused {\\n    tc.burnFrom(msg.sender, coverDetails[2]); // needs allowance\\n    _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s, true);\\n  }\\n\\n  /**\\n   * @dev Verifies cover details signed off chain.\\n   * @param from address of funder.\\n   * @param scAddress Smart Contract Address\\n   */\\n  function verifyCoverDetails(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) public onlyInternal {\\n    _verifyCoverDetails(\\n      from,\\n      scAddress,\\n      coverCurr,\\n      coverDetails,\\n      coverPeriod,\\n      _v,\\n      _r,\\n      _s,\\n      false\\n    );\\n  }\\n\\n  /**\\n   * @dev Verifies signature.\\n   * @param coverDetails details related to cover.\\n   * @param coverPeriod validity of cover.\\n   * @param contractAddress smart contract address.\\n   * @param _v argument from vrs hash.\\n   * @param _r argument from vrs hash.\\n   * @param _s argument from vrs hash.\\n   */\\n  function verifySignature(\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    bytes4 currency,\\n    address contractAddress,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) public view returns (bool) {\\n    require(contractAddress != address(0));\\n    bytes32 hash = getOrderHash(coverDetails, coverPeriod, currency, contractAddress);\\n    return isValidSignature(hash, _v, _r, _s);\\n  }\\n\\n  /**\\n   * @dev Gets order hash for given cover details.\\n   * @param coverDetails details realted to cover.\\n   * @param coverPeriod validity of cover.\\n   * @param contractAddress smart contract address.\\n   */\\n  function getOrderHash(\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    bytes4 currency,\\n    address contractAddress\\n  ) public view returns (bytes32) {\\n    return keccak256(\\n      abi.encodePacked(\\n        coverDetails[0],\\n        currency,\\n        coverPeriod,\\n        contractAddress,\\n        coverDetails[1],\\n        coverDetails[2],\\n        coverDetails[3],\\n        coverDetails[4],\\n        address(this)\\n      )\\n    );\\n  }\\n\\n  /**\\n   * @dev Verifies signature.\\n   * @param hash order hash\\n   * @param v argument from vrs hash.\\n   * @param r argument from vrs hash.\\n   * @param s argument from vrs hash.\\n   */\\n  function isValidSignature(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public view returns (bool) {\\n    bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\n    bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\\n    address a = ecrecover(prefixedHash, v, r, s);\\n    return (a == qd.getAuthQuoteEngine());\\n  }\\n\\n  /**\\n   * @dev Creates cover of the quotation, changes the status of the quotation ,\\n   * updates the total sum assured and locks the tokens of the cover against a quote.\\n   * @param from Quote member Ethereum address.\\n   */\\n  function _makeCover(//solhint-disable-line\\n    address payable from,\\n    address contractAddress,\\n    bytes4 coverCurrency,\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod\\n  ) internal {\\n\\n    address underlyingToken = incidents.underlyingToken(contractAddress);\\n\\n    if (underlyingToken != address(0)) {\\n      address coverAsset = cr.getCurrencyAssetAddress(coverCurrency);\\n      require(coverAsset == underlyingToken, \\\"Quotation: Unsupported cover asset for this product\\\");\\n    }\\n\\n    uint cid = qd.getCoverLength();\\n\\n    qd.addCover(\\n      coverPeriod,\\n      coverDetails[0],\\n      from,\\n      coverCurrency,\\n      contractAddress,\\n      coverDetails[1],\\n      coverDetails[2]\\n    );\\n\\n    uint coverNoteAmount = coverDetails[2].mul(qd.tokensRetained()).div(100);\\n\\n    uint gracePeriod = tc.claimSubmissionGracePeriod();\\n    uint claimSubmissionPeriod = uint(coverPeriod).mul(1 days).add(gracePeriod);\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", from, cid));\\n\\n    // mint and lock cover note\\n    td.setDepositCNAmount(cid, coverNoteAmount);\\n    tc.mintCoverNote(from, reason, coverNoteAmount, claimSubmissionPeriod);\\n\\n    qd.addInTotalSumAssured(coverCurrency, coverDetails[0]);\\n    qd.addInTotalSumAssuredSC(contractAddress, coverCurrency, coverDetails[0]);\\n\\n    uint coverPremiumInNXM = coverDetails[2];\\n    uint stakersRewardPercentage = td.stakerCommissionPer();\\n    uint rewardValue = coverPremiumInNXM.mul(stakersRewardPercentage).div(100);\\n    pooledStaking.accumulateReward(contractAddress, rewardValue);\\n  }\\n\\n  /**\\n   * @dev Makes a cover.\\n   * @param from address of funder.\\n   * @param scAddress Smart Contract Address\\n   */\\n  function _verifyCoverDetails(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s,\\n    bool isNXM\\n  ) internal {\\n\\n    require(coverDetails[3] > now, \\\"Quotation: Quote has expired\\\");\\n    require(coverPeriod >= 30 && coverPeriod <= 365, \\\"Quotation: Cover period out of bounds\\\");\\n    require(!qd.timestampRepeated(coverDetails[4]), \\\"Quotation: Quote already used\\\");\\n    qd.setTimestampRepeated(coverDetails[4]);\\n\\n    address asset = cr.getCurrencyAssetAddress(coverCurr);\\n    if (coverCurr != \\\"ETH\\\" && !isNXM) {\\n      pool.transferAssetFrom(asset, from, coverDetails[1]);\\n    }\\n\\n    require(verifySignature(coverDetails, coverPeriod, coverCurr, scAddress, _v, _r, _s), \\\"Quotation: signature mismatch\\\");\\n    _makeCover(from, scAddress, coverCurr, coverDetails, coverPeriod);\\n  }\\n\\n  function createCover(\\n    address payable from,\\n    address scAddress,\\n    bytes4 currency,\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) external onlyInternal {\\n\\n    require(coverDetails[3] > now, \\\"Quotation: Quote has expired\\\");\\n    require(coverPeriod >= 30 && coverPeriod <= 365, \\\"Quotation: Cover period out of bounds\\\");\\n    require(!qd.timestampRepeated(coverDetails[4]), \\\"Quotation: Quote already used\\\");\\n    qd.setTimestampRepeated(coverDetails[4]);\\n\\n    require(verifySignature(coverDetails, coverPeriod, currency, scAddress, _v, _r, _s), \\\"Quotation: signature mismatch\\\");\\n    _makeCover(from, scAddress, currency, coverDetails, coverPeriod);\\n  }\\n\\n  // referenced in master, keeping for now\\n  // solhint-disable-next-line no-empty-blocks\\n  function transferAssetsToNewContract(address) external pure {}\\n\\n  function freeUpHeldCovers() external nonReentrant {\\n\\n    IERC20 dai = IERC20(cr.getCurrencyAssetAddress(\\\"DAI\\\"));\\n    uint membershipFee = td.joiningFee();\\n    uint lastCoverId = 106;\\n\\n    for (uint id = 1; id <= lastCoverId; id++) {\\n\\n      if (qd.holdedCoverIDStatus(id) != uint(IQuotationData.HCIDStatus.kycPending)) {\\n        continue;\\n      }\\n\\n      (/*id*/, /*sc*/, bytes4 currency, /*period*/) = qd.getHoldedCoverDetailsByID1(id);\\n      (/*id*/, address payable userAddress, uint[] memory coverDetails) = qd.getHoldedCoverDetailsByID2(id);\\n\\n      uint refundedETH = membershipFee;\\n      uint coverPremium = coverDetails[1];\\n\\n      if (qd.refundEligible(userAddress)) {\\n        qd.setRefundEligible(userAddress, false);\\n      }\\n\\n      qd.setHoldedCoverIDStatus(id, uint(IQuotationData.HCIDStatus.kycFailedOrRefunded));\\n\\n      if (currency == \\\"ETH\\\") {\\n        refundedETH = refundedETH.add(coverPremium);\\n      } else {\\n        require(dai.transfer(userAddress, coverPremium), \\\"Quotation: DAI refund transfer failed\\\");\\n      }\\n\\n      userAddress.transfer(refundedETH);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract ReentrancyGuard {\\n    bool private _notEntered;\\n\\n    constructor () internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction's gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/MasterAware.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"../interfaces/INXMMaster.sol\\\";\\n\\ncontract MasterAware {\\n\\n  INXMMaster public master;\\n\\n  modifier onlyMember {\\n    require(master.isMember(msg.sender), \\\"Caller is not a member\\\");\\n    _;\\n  }\\n\\n  modifier onlyInternal {\\n    require(master.isInternal(msg.sender), \\\"Caller is not an internal contract\\\");\\n    _;\\n  }\\n\\n  modifier onlyMaster {\\n    if (address(master) != address(0)) {\\n      require(address(master) == msg.sender, \\\"Not master\\\");\\n    }\\n    _;\\n  }\\n\\n  modifier onlyGovernance {\\n    require(\\n      master.checkIsAuthToGoverned(msg.sender),\\n      \\\"Caller is not authorized to govern\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier whenPaused {\\n    require(master.isPause(), \\\"System is not paused\\\");\\n    _;\\n  }\\n\\n  modifier whenNotPaused {\\n    require(!master.isPause(), \\\"System is paused\\\");\\n    _;\\n  }\\n\\n  function changeDependentContractAddress() external;\\n\\n  function changeMasterAddress(address masterAddress) public onlyMaster {\\n    master = INXMMaster(masterAddress);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IClaimsReward.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IClaimsReward {\\n\\n  /// @dev Decides the next course of action for a given claim.\\n  function changeClaimStatus(uint claimid) external;\\n\\n  function getCurrencyAssetAddress(bytes4 currency) external view returns (address);\\n\\n  function getRewardToBeGiven(\\n    uint check,\\n    uint voteid,\\n    uint flag\\n  )\\n  external\\n  view\\n  returns (\\n    uint tokenCalculated,\\n    bool lastClaimedCheck,\\n    uint tokens,\\n    uint perc\\n  );\\n\\n  function upgrade(address _newAdd) external;\\n\\n  function getRewardToBeDistributedByUser(address _add) external view returns (uint total);\\n\\n  function getRewardAndClaimedStatus(uint check, uint claimId) external view returns (uint reward, bool claimed);\\n\\n  function claimAllPendingReward(uint records) external;\\n\\n  function getAllPendingRewardOfUser(address _add) external view returns (uint);\\n\\n  function unlockCoverNote(uint coverId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IIncidents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IIncidents {\\n\\n  function underlyingToken(address) external view returns (address);\\n\\n  function coveredToken(address) external view returns (address);\\n\\n  function claimPayout(uint) external view returns (uint);\\n\\n  function incidentCount() external view returns (uint);\\n\\n  function addIncident(\\n    address productId,\\n    uint incidentDate,\\n    uint priceBefore\\n  ) external;\\n\\n  function redeemPayoutForMember(\\n    uint coverId,\\n    uint incidentId,\\n    uint coveredTokenAmount,\\n    address member\\n  ) external returns (uint claimId, uint payoutAmount, address payoutToken);\\n\\n  function redeemPayout(\\n    uint coverId,\\n    uint incidentId,\\n    uint coveredTokenAmount\\n  ) external returns (uint claimId, uint payoutAmount, address payoutToken);\\n\\n  function pushBurns(address productId, uint maxIterations) external;\\n\\n  function withdrawAsset(address asset, address destination, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./IPriceFeedOracle.sol\\\";\\n\\ninterface IPool {\\n  function sellNXM(uint tokenAmount, uint minEthOut) external;\\n\\n  function sellNXMTokens(uint tokenAmount) external returns (bool);\\n\\n  function minPoolEth() external returns (uint);\\n\\n  function transferAssetToSwapOperator(address asset, uint amount) external;\\n\\n  function setAssetDataLastSwapTime(address asset, uint32 lastSwapTime) external;\\n\\n  function getAssetDetails(address _asset) external view returns (\\n    uint112 min,\\n    uint112 max,\\n    uint32 lastAssetSwapTime,\\n    uint maxSlippageRatio\\n  );\\n\\n  function sendClaimPayout (\\n    address asset,\\n    address payable payoutAddress,\\n    uint amount\\n  ) external returns (bool success);\\n\\n  function transferAsset(\\n    address asset,\\n    address payable destination,\\n    uint amount\\n  ) external;\\n\\n  function upgradeCapitalPool(address payable newPoolAddress) external;\\n\\n  function priceFeedOracle() external view returns (IPriceFeedOracle);\\n\\n  function getPoolValueInEth() external view returns (uint);\\n\\n\\n  function transferAssetFrom(address asset, address from, uint amount) external;\\n\\n  function getEthForNXM(uint nxmAmount) external view returns (uint ethAmount);\\n\\n  function calculateEthForNXM(\\n    uint nxmAmount,\\n    uint currentTotalAssetValue,\\n    uint mcrEth\\n  ) external pure returns (uint);\\n\\n  function calculateMCRRatio(uint totalAssetValue, uint mcrEth) external pure returns (uint);\\n\\n  function calculateTokenSpotPrice(uint totalAssetValue, uint mcrEth) external pure returns (uint tokenPrice);\\n\\n  function getTokenPrice(address asset) external view returns (uint tokenPrice);\\n\\n  function getMCRRatio() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPooledStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IPooledStaking {\\n\\n  function accumulateReward(address contractAddress, uint amount) external;\\n\\n  function pushBurn(address contractAddress, uint amount) external;\\n\\n  function hasPendingActions() external view returns (bool);\\n\\n  function processPendingActions(uint maxIterations) external returns (bool finished);\\n\\n  function contractStake(address contractAddress) external view returns (uint);\\n\\n  function stakerReward(address staker) external view returns (uint);\\n\\n  function stakerDeposit(address staker) external view returns (uint);\\n\\n  function stakerContractStake(address staker, address contractAddress) external view returns (uint);\\n\\n  function withdraw(uint amount) external;\\n\\n  function stakerMaxWithdrawable(address stakerAddress) external view returns (uint);\\n\\n  function withdrawReward(address stakerAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQuotation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IQuotation {\\n  function verifyCoverDetails(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) external;\\n\\n  function createCover(\\n    address payable from,\\n    address scAddress,\\n    bytes4 currency,\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) external;\\n\\n  function transferAssetsToNewContract(address) external pure;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQuotationData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IQuotationData {\\n\\n  function authQuoteEngine() external view returns (address);\\n  function stlp() external view returns (uint);\\n  function stl() external view returns (uint);\\n  function pm() external view returns (uint);\\n  function minDays() external view returns (uint);\\n  function tokensRetained() external view returns (uint);\\n  function kycAuthAddress() external view returns (address);\\n\\n  function refundEligible(address) external view returns (bool);\\n  function holdedCoverIDStatus(uint) external view returns (uint);\\n  function timestampRepeated(uint) external view returns (bool);\\n\\n  enum HCIDStatus {NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover}\\n  enum CoverStatus {Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested}\\n\\n  function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external;\\n\\n  function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external;\\n\\n  function subFromTotalSumAssured(bytes4 _curr, uint _amount) external;\\n\\n  function addInTotalSumAssured(bytes4 _curr, uint _amount) external;\\n\\n  function setTimestampRepeated(uint _timestamp) external;\\n\\n  /// @dev Creates a blank new cover.\\n  function addCover(\\n    uint16 _coverPeriod,\\n    uint _sumAssured,\\n    address payable _userAddress,\\n    bytes4 _currencyCode,\\n    address _scAddress,\\n    uint premium,\\n    uint premiumNXM\\n  ) external;\\n\\n\\n  function addHoldCover(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod\\n  ) external;\\n\\n  function setRefundEligible(address _add, bool status) external;\\n\\n  function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external;\\n\\n  function setKycAuthAddress(address _add) external;\\n\\n  function changeAuthQuoteEngine(address _add) external;\\n\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val);\\n\\n  function getProductDetails()\\n  external\\n  view\\n  returns (\\n    uint _minDays,\\n    uint _pm,\\n    uint _stl,\\n    uint _stlp\\n  );\\n\\n  function getCoverLength() external view returns (uint len);\\n\\n  function getAuthQuoteEngine() external view returns (address _add);\\n\\n  function getTotalSumAssured(bytes4 _curr) external view returns (uint amount);\\n\\n  function getAllCoversOfUser(address _add) external view returns (uint[] memory allCover);\\n\\n  function getUserCoverLength(address _add) external view returns (uint len);\\n\\n  function getCoverStatusNo(uint _cid) external view returns (uint8);\\n\\n  function getCoverPeriod(uint _cid) external view returns (uint32 cp);\\n\\n  function getCoverSumAssured(uint _cid) external view returns (uint sa);\\n\\n  function getCurrencyOfCover(uint _cid) external view returns (bytes4 curr);\\n\\n  function getValidityOfCover(uint _cid) external view returns (uint date);\\n\\n  function getscAddressOfCover(uint _cid) external view returns (uint, address);\\n\\n  function getCoverMemberAddress(uint _cid) external view returns (address payable _add);\\n\\n  function getCoverPremiumNXM(uint _cid) external view returns (uint _premiumNXM);\\n\\n  function getCoverDetailsByCoverID1(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    address _memberAddress,\\n    address _scAddress,\\n    bytes4 _currencyCode,\\n    uint _sumAssured,\\n    uint premiumNXM\\n  );\\n\\n  function getCoverDetailsByCoverID2(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    uint8 status,\\n    uint sumAssured,\\n    uint16 coverPeriod,\\n    uint validUntil\\n  );\\n\\n  function getHoldedCoverDetailsByID1(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint16 coverPeriod\\n  );\\n\\n  function getUserHoldedCoverLength(address _add) external view returns (uint);\\n\\n  function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint);\\n\\n  function getHoldedCoverDetailsByID2(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address payable memberAddress,\\n    uint[] memory coverDetails\\n  );\\n\\n  function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns (uint amount);\\n\\n  function changeCoverStatusNo(uint _cid, uint8 _stat) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface ITokenController {\\n\\n  function coverInfo(uint id) external view returns (uint16 claimCount, bool hasOpenClaim, bool hasAcceptedClaim);\\n\\n  function claimSubmissionGracePeriod() external view returns (uint);\\n\\n  function withdrawCoverNote(\\n    address _of,\\n    uint[] calldata _coverIds,\\n    uint[] calldata _indexes\\n  ) external;\\n\\n  function markCoverClaimOpen(uint coverId) external;\\n\\n  function markCoverClaimClosed(uint coverId, bool isAccepted) external;\\n\\n  function changeOperator(address _newOperator) external;\\n\\n  function operatorTransfer(address _from, address _to, uint _value) external returns (bool);\\n\\n  function lockClaimAssessmentTokens(uint256 _amount, uint256 _time) external;\\n\\n  function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time) external returns (bool);\\n\\n  function mintCoverNote(\\n    address _of,\\n    bytes32 _reason,\\n    uint256 _amount,\\n    uint256 _time\\n  ) external;\\n\\n  function extendClaimAssessmentLock(uint256 _time) external;\\n\\n  function extendLockOf(address _of, bytes32 _reason, uint256 _time) external returns (bool);\\n\\n  function increaseClaimAssessmentLock(uint256 _amount) external;\\n\\n  function burnFrom(address _of, uint amount) external returns (bool);\\n\\n  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\\n\\n  function reduceLock(address _of, bytes32 _reason, uint256 _time) external;\\n\\n  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\\n\\n  function addToWhitelist(address _member) external;\\n\\n  function removeFromWhitelist(address _member) external;\\n\\n  function mint(address _member, uint _amount) external;\\n\\n  function lockForMemberVote(address _of, uint _days) external;\\n  function withdrawClaimAssessmentTokens(address _of) external;\\n\\n  function getLockReasons(address _of) external view returns (bytes32[] memory reasons);\\n\\n  function getLockedTokensValidity(address _of, bytes32 reason) external view returns (uint256 validity);\\n\\n  function getUnlockableTokens(address _of) external view returns (uint256 unlockableTokens);\\n\\n  function tokensLocked(address _of, bytes32 _reason) external view returns (uint256 amount);\\n\\n  function tokensLockedWithValidity(address _of, bytes32 _reason)\\n  external\\n  view\\n  returns (uint256 amount, uint256 validity);\\n\\n  function tokensUnlockable(address _of, bytes32 _reason) external view returns (uint256 amount);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time) external view returns (uint256 amount);\\n  function totalBalanceOf(address _of) external view returns (uint256 amount);\\n\\n  function totalLockedBalance(address _of) external view returns (uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface ITokenData {\\n\\n  function walletAddress() external view returns (address payable);\\n  function lockTokenTimeAfterCoverExp() external view returns (uint);\\n  function bookTime() external view returns (uint);\\n  function lockCADays() external view returns (uint);\\n  function lockMVDays() external view returns (uint);\\n  function scValidDays() external view returns (uint);\\n  function joiningFee() external view returns (uint);\\n  function stakerCommissionPer() external view returns (uint);\\n  function stakerMaxCommissionPer() external view returns (uint);\\n  function tokenExponent() external view returns (uint);\\n  function priceStep() external view returns (uint);\\n\\n  function depositedCN(uint) external view returns (uint amount, bool isDeposited);\\n\\n  function lastCompletedStakeCommission(address) external view returns (uint);\\n\\n  function changeWalletAddress(address payable _address) external;\\n\\n  function getStakerStakedContractByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (address stakedContractAddress);\\n\\n  function getStakerStakedBurnedByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint burnedAmount);\\n\\n  function getStakerStakedUnlockableBeforeLastBurnByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint unlockable);\\n\\n  function getStakerStakedContractIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint scIndex);\\n\\n  function getStakedContractStakerIndex(\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex\\n  )\\n  external\\n  view\\n  returns (uint sIndex);\\n\\n  function getStakerInitialStakedAmountOnContract(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint amount);\\n\\n  function getStakerStakedContractLength(\\n    address _stakerAddress\\n  )\\n  external\\n  view\\n  returns (uint length);\\n\\n  function getStakerUnlockedStakedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint amount);\\n\\n  function pushUnlockedStakedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n\\n  function pushBurnedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n  function pushUnlockableBeforeLastBurnTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n  function setUnlockableBeforeLastBurnTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n  function pushEarnedStakeCommissions(\\n    address _stakerAddress,\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex,\\n    uint _commissionAmount\\n  ) external;\\n\\n  function pushRedeemedStakeCommissions(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n  function getStakerEarnedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint);\\n\\n  function getStakerRedeemedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint);\\n\\n  function getStakerTotalEarnedStakeCommission(\\n    address _stakerAddress\\n  )\\n  external\\n  view\\n  returns (uint totalCommissionEarned);\\n\\n  function getStakerTotalReedmedStakeCommission(\\n    address _stakerAddress\\n  )\\n  external\\n  view\\n  returns (uint totalCommissionRedeemed);\\n\\n  function setDepositCN(uint coverId, bool flag) external;\\n\\n  function getStakedContractStakerByIndex(\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex\\n  )\\n  external\\n  view\\n  returns (address stakerAddress);\\n\\n  function getStakedContractStakersLength(\\n    address _stakedContractAddress\\n  ) external view returns (uint length);\\n\\n  function addStake(\\n    address _stakerAddress,\\n    address _stakedContractAddress,\\n    uint _amount\\n  ) external returns (uint scIndex);\\n\\n  function bookCATokens(address _of) external;\\n\\n  function isCATokensBooked(address _of) external view returns (bool res);\\n\\n  function setStakedContractCurrentCommissionIndex(\\n    address _stakedContractAddress,\\n    uint _index\\n  ) external;\\n\\n  function setLastCompletedStakeCommissionIndex(\\n    address _stakerAddress,\\n    uint _index\\n  ) external;\\n\\n\\n  function setStakedContractCurrentBurnIndex(\\n    address _stakedContractAddress,\\n    uint _index\\n  ) external;\\n\\n  function setDepositCNAmount(uint coverId, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INXMMaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface INXMMaster {\\n\\n  function tokenAddress() external view returns (address);\\n\\n  function owner() external view returns (address);\\n\\n  function pauseTime() external view returns (uint);\\n\\n  function masterInitialized() external view returns (bool);\\n\\n  function isInternal(address _add) external view returns (bool);\\n\\n  function isPause() external view returns (bool check);\\n\\n  function isOwner(address _add) external view returns (bool);\\n\\n  function isMember(address _add) external view returns (bool);\\n\\n  function checkIsAuthToGoverned(address _add) external view returns (bool);\\n\\n  function updatePauseTime(uint _time) external;\\n\\n  function dAppLocker() external view returns (address _add);\\n\\n  function dAppToken() external view returns (address _add);\\n\\n  function getLatestAddress(bytes2 _contractName) external view returns (address payable contractAddress);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceFeedOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IPriceFeedOracle {\\n\\n  function daiAddress() external view returns (address);\\n  function stETH() external view returns (address);\\n  function ETH() external view returns (address);\\n\\n  function getAssetToEthRate(address asset) external view returns (uint);\\n  function getAssetForEth(address asset, uint ethIn) external view returns (uint);\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"changeDependentContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"masterAddress\",\"type\":\"address\"}],\"name\":\"changeMasterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cr\",\"outputs\":[{\"internalType\":\"contract IClaimsReward\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"scAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"currency\",\"type\":\"bytes4\"},{\"internalType\":\"uint256[]\",\"name\":\"coverDetails\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16\",\"name\":\"coverPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"createCover\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"}],\"name\":\"expireCover\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freeUpHeldCovers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"coverDetails\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16\",\"name\":\"coverPeriod\",\"type\":\"uint16\"},{\"internalType\":\"bytes4\",\"name\":\"currency\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"getOrderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"coverOwner\",\"type\":\"address\"}],\"name\":\"getWithdrawableCoverNoteCoverIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"expiredCoverIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"lockReasons\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"coverOwner\",\"type\":\"address\"}],\"name\":\"getWithdrawableCoverNotesAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"incidents\",\"outputs\":[{\"internalType\":\"contract IIncidents\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"coverDetails\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16\",\"name\":\"coverPeriod\",\"type\":\"uint16\"},{\"internalType\":\"bytes4\",\"name\":\"coverCurr\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"smartCAdd\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"makeCoverUsingNXMTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"internalType\":\"contract INXMMaster\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract IPool\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pooledStaking\",\"outputs\":[{\"internalType\":\"contract IPooledStaking\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"qd\",\"outputs\":[{\"internalType\":\"contract IQuotationData\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tc\",\"outputs\":[{\"internalType\":\"contract ITokenController\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"td\",\"outputs\":[{\"internalType\":\"contract ITokenData\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferAssetsToNewContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"scAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"coverCurr\",\"type\":\"bytes4\"},{\"internalType\":\"uint256[]\",\"name\":\"coverDetails\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16\",\"name\":\"coverPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"verifyCoverDetails\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"coverDetails\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16\",\"name\":\"coverPeriod\",\"type\":\"uint16\"},{\"internalType\":\"bytes4\",\"name\":\"currency\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"verifySignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"coverOwner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"coverIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"reasonIndexes\",\"type\":\"uint256[]\"}],\"name\":\"withdrawCoverNote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Quotation","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}