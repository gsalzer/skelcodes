{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-04-09\r\n*/\r\n\r\npragma solidity 0.8.0;\r\n\r\n\r\n/*\r\n\r\nDigital Toast\r\n\r\nThere are only 21 for the bread burners.\r\n\r\nThis toast must be earned and not purchased!  Do not buy or sell toast.\r\n\r\n*/\r\n                                                                                 \r\n                                                                                \r\n/*        \r\n\r\n                                        ...                                     \r\n                                  ,##,........(#,                               \r\n                              *#/.................*#(.                          \r\n                          ,%(........./#(/(#(,.........(#*                      \r\n                      .##......../#,...........,((..........##.                 \r\n              |##((((*.. ... .*|...................,#...........*#/.            \r\n           ((...............#..|,,................,,#...............,(          \r\n          ((................,#,../*,,,.......,,,,**..,(..............#*         \r\n          #*#................#,......**,,,,,,*,..../*.............((,/*         \r\n          *(,,*%*..................((.......*%#(#%#,..........*#,,,,,#          \r\n           ((,,,,,,*#(................,/(/,...............*#*,,,,,,(/           \r\n             (#*,,,,,,,,*#/...........................*#*,,,,,,,(#              \r\n                 ,##*,,,,,,,,/#....................**,,,,,,,/#,                 \r\n                      *#(,,,,,,,,((................,#,,,/#*                     \r\n                          ,##*,,,,,,,((,.........((,%%*                         \r\n                              .##,,,,,,,,,,,,,,,,,,,#                           \r\n                                  ,#(,,,,,,,,,,,,,,#                            \r\n                                      .(##(//(#%(.                              \r\n*/\r\n\r\n\r\n \r\n interface ERC721\r\n{\r\n\r\n  /**\r\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\r\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\r\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\r\n   * transfer, the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n \r\n\r\n  \r\n \r\n\r\n   \r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @param _owner Address for whom to query the balance.\r\n   * @return Balance of _owner.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\r\n   * invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   * @return Address of _tokenId owner.\r\n   */\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  \r\n\r\n}\r\n\r\n\r\n interface BurnBook\r\n{\r\n    event tokensBurned(address from, address token, uint256 tokens);\r\n    \r\n    function getBurnedTokensAmount(address burner, address token) external view returns (uint);\r\n}\r\n\r\n/**\r\n * @dev ERC-721 interface for accepting safe transfers.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721TokenReceiver\r\n{\r\n\r\n  /**\r\n   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\r\n   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n   * of other than the magic value MUST result in the transaction being reverted.\r\n   * Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` unless throwing.\r\n   * @notice The contract address is always the message sender. A wallet/broker/auction application\r\n   * MUST implement the wallet interface if it will accept safe transfers.\r\n   * @param _operator The address which called `safeTransferFrom` function.\r\n   * @param _from The address which previously owned the token.\r\n   * @param _tokenId The NFT identifier which is being transferred.\r\n   * @param _data Additional data with no specified format.\r\n   * @return Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n   */\r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    returns(bytes4);\r\n\r\n}\r\n\r\n\r\n/**\r\n * @dev A standard for detecting smart contract interfaces. \r\n * See: https://eips.ethereum.org/EIPS/eip-165.\r\n */\r\ninterface ERC165\r\n{\r\n\r\n  /**\r\n   * @dev Checks if the smart contract includes a specific interface.\r\n   * This function uses less than 30,000 gas.\r\n   * @param _interfaceID The interface identifier, as specified in ERC-165.\r\n   * @return True if _interfaceID is supported, false otherwise.\r\n   */\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n    \r\n}\r\n\r\n\r\n/**\r\n * @dev Implementation of standard for detect smart contract interfaces.\r\n */\r\ncontract SupportsInterface is\r\n  ERC165\r\n{\r\n\r\n  /**\r\n   * @dev Mapping of supported intefraces. You must not set element 0xffffffff to true.\r\n   */\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n  {\r\n    supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check which interfaces are suported by this contract.\r\n   * @param _interfaceID Id of the interface.\r\n   * @return True if _interfaceID is supported, false otherwise.\r\n   */\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceID];\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @dev Utility library of inline functions on addresses.\r\n * @notice Based on:\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n * Requires EIP-1052.\r\n */\r\nlibrary AddressUtils\r\n{\r\n\r\n  /**\r\n   * @dev Returns whether the target address is a contract.\r\n   * @param _addr Address to check.\r\n   * @return addressCheck True if _addr is a contract, false if not.\r\n   */\r\n  function isContract(\r\n    address _addr\r\n  )\r\n    internal\r\n    view\r\n    returns (bool addressCheck)\r\n  {\r\n    // This method relies in extcodesize, which returns 0 for contracts in\r\n    // construction, since the code is only stored at the end of the\r\n    // constructor execution.\r\n\r\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n    // for accounts without code, i.e. `keccak256('')`\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    assembly { codehash := extcodehash(_addr) } // solhint-disable-line\r\n    addressCheck = (codehash != 0x0 && codehash != accountHash);\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of ERC-721 non-fungible token standard.\r\n */\r\ncontract NFToken is\r\n  ERC721,\r\n  SupportsInterface\r\n{\r\n  using AddressUtils for address;\r\n\r\n  /**\r\n   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\r\n   * Based on 0xcert framework error codes.\r\n   */\r\n  string constant ZERO_ADDRESS = \"003001\";\r\n  string constant NOT_VALID_NFT = \"003002\";\r\n  string constant NOT_OWNER_OR_OPERATOR = \"003003\";\r\n  string constant NOT_OWNER_APPROVED_OR_OPERATOR = \"003004\";\r\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\r\n  string constant NFT_ALREADY_EXISTS = \"003006\";\r\n  string constant NOT_OWNER = \"003007\";\r\n  string constant IS_OWNER = \"003008\";\r\n\r\n  /**\r\n   * @dev Magic value of a smart contract that can recieve NFT.\r\n   * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\r\n   */\r\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  /**\r\n   * @dev A mapping from NFT ID to the address that owns it.\r\n   */\r\n  mapping (uint256 => address) internal idToOwner;\r\n\r\n   \r\n   /**\r\n   * @dev Mapping from owner address to count of his tokens.\r\n   */\r\n  mapping (address => uint256) private ownerToNFTokenCount;\r\n\r\n  /**\r\n   * @dev Mapping from owner address to mapping of operator addresses.\r\n   */\r\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n\r\n  /**\r\n   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\r\n   * @param _tokenId ID of the NFT to validate.\r\n   */\r\n  modifier canOperate(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_OR_OPERATOR\r\n    );\r\n    _;\r\n  }\r\n\r\n \r\n\r\n  /**\r\n   * @dev Guarantees that _tokenId is a valid Token.\r\n   * @param _tokenId ID of the NFT to validate.\r\n   */\r\n  modifier validNFToken(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n  {\r\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n  }\r\n \r\n   \r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @param _owner Address for whom to query the balance.\r\n   * @return Balance of _owner.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_owner != address(0), ZERO_ADDRESS);\r\n    return _getOwnerNFTCount(_owner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\r\n   * invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   * @return _owner Address of _tokenId owner.\r\n   */\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (address _owner)\r\n  {\r\n    _owner = idToOwner[_tokenId];\r\n    require(_owner != address(0), NOT_VALID_NFT);\r\n  }\r\n\r\n   \r\n\r\n  /**\r\n   * @dev Actually preforms the transfer.\r\n   * @notice Does NO checks.\r\n   * @param _to Address of a new owner.\r\n   * @param _tokenId The NFT that is being transferred.\r\n   */\r\n  function _transfer(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    address from = idToOwner[_tokenId];\r\n    \r\n\r\n    _removeNFToken(from, _tokenId);\r\n    _addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Mints a new NFT.\r\n   * @notice This is an internal function which should be called from user-implemented external\r\n   * mint function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _to The address that will own the minted NFT.\r\n   * @param _tokenId of the NFT to be minted by the msg.sender.\r\n   */\r\n  function _mint(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n    _addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n \r\n\r\n  /**\r\n   * @dev Removes a NFT from owner.\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @param _from Address from wich we want to remove the NFT.\r\n   * @param _tokenId Which NFT we want to remove.\r\n   */\r\n  function _removeNFToken(\r\n    address _from,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\r\n    ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\r\n    delete idToOwner[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Assignes a new NFT to owner.\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @param _to Address to wich we want to add the NFT.\r\n   * @param _tokenId Which NFT we want to add.\r\n   */\r\n  function _addNFToken(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n    idToOwner[_tokenId] = _to;\r\n    ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to] + 1;\r\n  }\r\n\r\n  /**\r\n   *Â @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\r\n   * extension to remove double storage (gas optimization) of owner nft count.\r\n   * @param _owner Address for whom to query the count.\r\n   * @return Number of _owner NFTs.\r\n   */\r\n  function _getOwnerNFTCount(\r\n    address _owner\r\n  )\r\n    internal\r\n    virtual\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return ownerToNFTokenCount[_owner];\r\n  }\r\n\r\n   \r\n\r\n}\r\n\r\n\r\n/**\r\n * @dev Optional metadata extension for ERC-721 non-fungible token standard.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721Metadata\r\n{\r\n\r\n  /**\r\n   * @dev Returns a descriptive name for a collection of NFTs in this contract.\r\n   * @return _name Representing name.\r\n   */\r\n  function name()\r\n    external\r\n    view\r\n    returns (string memory _name);\r\n\r\n  /**\r\n   * @dev Returns a abbreviated name for a collection of NFTs in this contract.\r\n   * @return _symbol Representing symbol.\r\n   */\r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string memory _symbol);\r\n\r\n  /**\r\n   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\r\n   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\r\n   * that conforms to the \"ERC721 Metadata JSON Schema\".\r\n   * @return URI of _tokenId.\r\n   */\r\n  function tokenURI(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (string memory);\r\n\r\n}\r\n\r\n \r\n \r\n\r\n\r\n\r\n/**\r\n * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\r\n */\r\nabstract contract NFTokenMetadata is\r\n  NFToken,\r\n  ERC721Metadata\r\n{\r\n\r\n  /**\r\n   * @dev A descriptive name for a collection of NFTs.\r\n   */\r\n  string internal nftName;\r\n\r\n  /**\r\n   * @dev An abbreviated name for NFTokens.\r\n   */\r\n  string internal nftSymbol;\r\n \r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   * @notice When implementing this contract don't forget to set nftName and nftSymbol.\r\n   */\r\n  constructor()\r\n  {\r\n    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\r\n  }\r\n\r\n  /**\r\n   * @dev Returns a descriptive name for a collection of NFTokens.\r\n   * @return _name Representing name.\r\n   */\r\n  function name()\r\n    external\r\n    override\r\n    view\r\n    returns (string memory _name)\r\n  {\r\n    _name = nftName;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an abbreviated name for NFTokens.\r\n   * @return _symbol Representing symbol.\r\n   */\r\n  function symbol()\r\n    external\r\n    override\r\n    view\r\n    returns (string memory _symbol)\r\n  {\r\n    _symbol = nftSymbol;\r\n  }\r\n\r\n  \r\n  \r\n  \r\n\r\n}\r\n\r\n\r\n/**\r\n * What happens to bread when you burn it? \r\n * \r\n * No... I mean only burn it a tiny bit.\r\n * \r\n * Seriously... the nerve of you degens!! \r\n *\r\n */\r\ncontract DigitalToast is\r\n  NFTokenMetadata\r\n{\r\n    \r\n  uint256 public slicesToasted;\r\n  address public _burnbook;\r\n  address public _burnableToken;\r\n  \r\n  event toastTaken(uint indexed tokenId, address previousOwner, address newOwner,  string scribble);\r\n  \r\n  \r\n  constructor(address burnBook, address burnableToken)\r\n  {\r\n    nftName = \"Digital Toast\";\r\n    nftSymbol = \"TOAST\";\r\n    \r\n    _burnbook = burnBook;\r\n    _burnableToken = burnableToken;\r\n  }\r\n\r\n  /**\r\n   * @dev Mints a new NFT.\r\n   * @param _to The address that will own the minted NFT.\r\n   */\r\n  function mint( address _to, string memory scribble) external returns(bool) {  \r\n      \r\n    require( ERC721(this).balanceOf(_to) == 0 );\r\n     \r\n    super._mint(_to,slicesToasted);\r\n    \r\n    slicesToasted = slicesToasted + 1;\r\n    \r\n    require(slicesToasted <= 21);\r\n    \r\n    emit toastTaken(slicesToasted, address(this), _to, scribble);\r\n    \r\n    return true;\r\n  }\r\n  \r\n  function take(uint tokenId, string memory scribble) external returns(bool){\r\n    \r\n    address from = msg.sender; \r\n    \r\n    require(ERC721(this).balanceOf(from) == 0);\r\n  \r\n    address previousOwner = ERC721(this).ownerOf(tokenId);\r\n    \r\n    uint fromAmountBurned = BurnBook(_burnbook).getBurnedTokensAmount(from,_burnableToken);\r\n    uint previousOwnerAmountBurned = BurnBook(_burnbook).getBurnedTokensAmount(previousOwner,_burnableToken);\r\n    \r\n    require(fromAmountBurned >= (previousOwnerAmountBurned + 100000000));\r\n     \r\n    _transfer(from,tokenId);\r\n    \r\n    emit toastTaken(tokenId, previousOwner, from, scribble);\r\n    \r\n    return true;\r\n  }\r\n  \r\n  \r\n   /**\r\n   * @dev A distinct URI (RFC 3986) for a given NFT.\r\n   * @param _tokenId Id for which we want uri.\r\n   * @return URI of _tokenId.\r\n   */\r\n  function tokenURI(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    validNFToken(_tokenId)\r\n    returns (string memory)\r\n  {\r\n    return \"ipfs://QmR9RNGq2ydEB73arpaLZTbU616RF6sG6ikKM64yXVEK5H\";\r\n  }\r\n\r\n   \r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"burnBook\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"burnableToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"scribble\",\"type\":\"string\"}],\"name\":\"toastTaken\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_burnableToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_burnbook\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"scribble\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slicesToasted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"scribble\",\"type\":\"string\"}],\"name\":\"take\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DigitalToast","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000005a0361e743b1d172dc09456388aa3d4acd14adf3000000000000000000000000b6ed7644c69416d67b522e20bc294a9a9b405b31","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1d832f8bb23b744d7e56752ab5c8c898b7ceeaebda32084d2290fa25a19c2149"}]}