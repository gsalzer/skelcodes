{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/IAuthoriser.sol\": {\r\n      \"content\": \"// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\ninterface IAuthoriser {\\n    function isAuthorised(address _sender, address _spender, address _to, bytes calldata _data) external view returns (bool);\\n    function areAuthorised(\\n        address _spender,\\n        address[] calldata _spenders,\\n        address[] calldata _to,\\n        bytes[] calldata _data\\n    )\\n        external\\n        view\\n        returns (bool);\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/dapp/BaseFilter.sol\": {\r\n      \"content\": \"// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\nimport \\\"./IFilter.sol\\\";\\n\\nabstract contract BaseFilter is IFilter {\\n    function getMethod(bytes memory _data) internal pure returns (bytes4 method) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            method := mload(add(_data, 0x20))\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/dapp/IFilter.sol\": {\r\n      \"content\": \"// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\ninterface IFilter {\\n    function isValid(address _wallet, address _spender, address _to, bytes calldata _data) external view returns (bool valid);\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/dapp/ParaswapFilter.sol\": {\r\n      \"content\": \"// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\nimport \\\"./BaseFilter.sol\\\";\\nimport \\\"../IAuthoriser.sol\\\";\\nimport \\\"../../modules/common/Utils.sol\\\";\\n\\ninterface IUniswapV1Factory {\\n    function getExchange(address token) external view returns (address);\\n}\\n\\ninterface IParaswapUniswapProxy {\\n    function UNISWAP_FACTORY() external view returns (address);\\n    function UNISWAP_INIT_CODE() external view returns (bytes32);\\n    function WETH() external view returns (address);\\n}\\n\\ninterface IParaswap {\\n    struct Route {\\n        address payable exchange;\\n        address targetExchange;\\n        uint256 percent;\\n        bytes payload;\\n        uint256 networkFee;\\n    }\\n\\n    struct Path {\\n        address to;\\n        uint256 totalNetworkFee;\\n        Route[] routes;\\n    }\\n\\n    struct SellData {\\n        address fromToken;\\n        uint256 fromAmount;\\n        uint256 toAmount;\\n        uint256 expectedAmount;\\n        address payable beneficiary;\\n        string referrer;\\n        bool useReduxToken;\\n        Path[] path;\\n    }\\n\\n    struct MegaSwapPath {\\n        uint256 fromAmountPercent;\\n        Path[] path;\\n    }\\n\\n    struct MegaSwapSellData {\\n        address fromToken;\\n        uint256 fromAmount;\\n        uint256 toAmount;\\n        uint256 expectedAmount;\\n        address payable beneficiary;\\n        string referrer;\\n        bool useReduxToken;\\n        MegaSwapPath[] path;\\n    }\\n\\n    struct UniswapV2Data {\\n        address[] path;\\n    }\\n\\n    struct ZeroExV2Order {\\n        address makerAddress;\\n        address takerAddress;\\n        address feeRecipientAddress;\\n        address senderAddress;\\n        uint256 makerAssetAmount;\\n        uint256 takerAssetAmount;\\n        uint256 makerFee;\\n        uint256 takerFee;\\n        uint256 expirationTimeSeconds;\\n        uint256 salt;\\n        bytes makerAssetData;\\n        bytes takerAssetData;\\n    }\\n\\n    struct ZeroExV2Data {\\n        ZeroExV2Order[] orders;\\n        bytes[] signatures;\\n    }\\n\\n    struct ZeroExV4Order {\\n        address makerToken;\\n        address takerToken;\\n        uint128 makerAmount;\\n        uint128 takerAmount;\\n        address maker;\\n        address taker;\\n        address txOrigin;\\n        bytes32 pool;\\n        uint64 expiry;\\n        uint256 salt;\\n    }\\n\\n    enum ZeroExV4SignatureType {\\n        ILLEGAL,\\n        INVALID,\\n        EIP712,\\n        ETHSIGN\\n    }\\n\\n    struct ZeroExV4Signature {\\n        ZeroExV4SignatureType signatureType;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    struct ZeroExV4Data {\\n        ZeroExV4Order order;\\n        ZeroExV4Signature signature;\\n    }\\n\\n    function getUniswapProxy() external view returns (address);\\n}\\n\\ncontract ParaswapFilter is BaseFilter {\\n\\n    bytes4 constant internal MULTISWAP = bytes4(keccak256(\\n        \\\"multiSwap((address,uint256,uint256,uint256,address,string,bool,(address,uint256,(address,address,uint256,bytes,uint256)[])[]))\\\"\\n    ));\\n    bytes4 constant internal SIMPLESWAP = bytes4(keccak256(\\n        \\\"simpleSwap(address,address,uint256,uint256,uint256,address[],bytes,uint256[],uint256[],address,string,bool)\\\"\\n    ));\\n    bytes4 constant internal SWAP_ON_UNI = bytes4(keccak256(\\n        \\\"swapOnUniswap(uint256,uint256,address[],uint8)\\\"\\n    ));\\n    bytes4 constant internal SWAP_ON_UNI_FORK = bytes4(keccak256(\\n        \\\"swapOnUniswapFork(address,bytes32,uint256,uint256,address[],uint8)\\\"\\n    ));\\n    bytes4 constant internal MEGASWAP = bytes4(keccak256(\\n        \\\"megaSwap((address,uint256,uint256,uint256,address,string,bool,(uint256,(address,uint256,(address,address,uint256,bytes,uint256)[])[])[]))\\\"\\n    ));\\n\\n    address constant internal ETH_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    // The token price registry\\n    address public immutable tokenRegistry;\\n    // Paraswap entrypoint\\n    address public immutable augustus;\\n    // Supported Paraswap targetExchanges\\n    mapping(address => bool) public targetExchanges;\\n    // Supported ParaswapPool market makers\\n    mapping(address => bool) public marketMakers;\\n    // The supported adapters\\n    address public immutable uniV1Adapter;\\n    address public immutable uniV2Adapter;\\n    address public immutable sushiswapAdapter;\\n    address public immutable linkswapAdapter;\\n    address public immutable defiswapAdapter;\\n    address public immutable zeroExV2Adapter;\\n    address public immutable zeroExV4Adapter;\\n    // The Dapp registry (used to authorise simpleSwap())\\n    IAuthoriser public immutable authoriser;\\n    // Uniswap Proxy used by Paraswap's AugustusSwapper contract\\n    address public immutable uniswapProxy;\\n    // Whether the uniswap proxy has been changed -> needs manual update\\n    bool public isValidUniswapProxy = true;\\n    // WETH address\\n    address public immutable weth;\\n\\n    // Supported Uniswap Fork (factory, initcode) couples.\\n    // Note that a `mapping(address => bytes32) public supportedInitCodes;` would be cleaner\\n    // but would cost one storage read to authorise each uni fork swap.\\n    address public immutable uniFactory; // uniswap\\n    address public immutable uniForkFactory1; // sushiswap\\n    address public immutable uniForkFactory2; // linkswap\\n    address public immutable uniForkFactory3; // defiswap\\n    bytes32 public immutable uniInitCode; // uniswap\\n    bytes32 public immutable uniForkInitCode1; // sushiswap\\n    bytes32 public immutable uniForkInitCode2; // linkswap\\n    bytes32 public immutable uniForkInitCode3; // defiswap\\n\\n    constructor(\\n        address _tokenRegistry,\\n        IAuthoriser _authoriser,\\n        address _augustus,\\n        address _uniswapProxy,\\n        address[3] memory _uniFactories,\\n        bytes32[3] memory _uniInitCodes,\\n        address[7] memory _adapters,\\n        address[] memory _targetExchanges,\\n        address[] memory _marketMakers\\n    ) {\\n        tokenRegistry = _tokenRegistry;\\n        authoriser = _authoriser;\\n        augustus = _augustus;\\n        uniswapProxy = _uniswapProxy;\\n        weth = IParaswapUniswapProxy(_uniswapProxy).WETH();\\n        uniFactory = IParaswapUniswapProxy(_uniswapProxy).UNISWAP_FACTORY();\\n        uniInitCode = IParaswapUniswapProxy(_uniswapProxy).UNISWAP_INIT_CODE();\\n        uniForkFactory1 = _uniFactories[0];\\n        uniForkFactory2 = _uniFactories[1];\\n        uniForkFactory3 = _uniFactories[2];\\n        uniForkInitCode1 = _uniInitCodes[0];\\n        uniForkInitCode2 = _uniInitCodes[1];\\n        uniForkInitCode3 = _uniInitCodes[2];\\n        uniV1Adapter = _adapters[0];\\n        uniV2Adapter = _adapters[1];\\n        sushiswapAdapter = _adapters[2];\\n        linkswapAdapter = _adapters[3];\\n        defiswapAdapter = _adapters[4];\\n        zeroExV2Adapter = _adapters[5];\\n        zeroExV4Adapter = _adapters[6];\\n        for(uint i = 0; i < _targetExchanges.length; i++) {\\n            targetExchanges[_targetExchanges[i]] = true;\\n        }\\n        for(uint i = 0; i < _marketMakers.length; i++) {\\n            marketMakers[_marketMakers[i]] = true;\\n        }\\n    }\\n\\n    function updateIsValidUniswapProxy() external {\\n        isValidUniswapProxy = (uniswapProxy == IParaswap(augustus).getUniswapProxy());\\n    }\\n\\n    function isValid(address _wallet, address /*_spender*/, address _to, bytes calldata _data) external view override returns (bool valid) {\\n        // disable ETH transfer & unsupported Paraswap entrypoints\\n        if (_data.length < 4 || _to != augustus) {\\n            return false;\\n        }\\n        bytes4 methodId = getMethod(_data);\\n        if(methodId == MULTISWAP) {\\n            return isValidMultiSwap(_wallet, _data);\\n        } \\n        if(methodId == SIMPLESWAP) {\\n            return isValidSimpleSwap(_wallet, _to, _data);\\n        }\\n        if(methodId == SWAP_ON_UNI) {\\n            return isValidUniSwap(_data);\\n        }\\n        if(methodId == SWAP_ON_UNI_FORK) {\\n            return isValidUniForkSwap(_data);\\n        }\\n        if(methodId == MEGASWAP) {\\n            return isValidMegaSwap(_wallet, _data);\\n        }\\n        return false;\\n    }\\n\\n    function isValidMultiSwap(address _wallet, bytes calldata _data) internal view returns (bool) {\\n        (IParaswap.SellData memory sell) = abi.decode(_data[4:], (IParaswap.SellData));\\n        return hasValidBeneficiary(_wallet, sell.beneficiary) && hasValidPath(sell.fromToken, sell.path);\\n    }\\n\\n    function isValidSimpleSwap(address _wallet, address _augustus, bytes calldata _data) internal view returns (bool) {\\n        (,address toToken,, address[] memory callees,, uint256[] memory startIndexes,, address beneficiary) \\n            = abi.decode(_data[4:], (address, address, uint256[3],address[],bytes,uint256[],uint256[],address));\\n        return hasValidBeneficiary(_wallet, beneficiary) &&\\n            hasTradableToken(toToken) &&\\n            hasAuthorisedCallees(_augustus, callees, startIndexes, _data);\\n    }\\n\\n    function isValidUniSwap(bytes calldata _data) internal view returns (bool) {\\n        if(!isValidUniswapProxy) {\\n            return false;\\n        }\\n        (, address[] memory path) = abi.decode(_data[4:], (uint256[2], address[]));\\n        return hasValidUniV2Path(path, uniFactory, uniInitCode);\\n    }\\n\\n    function isValidUniForkSwap(bytes calldata _data) internal view returns (bool) {\\n        if(!isValidUniswapProxy) {\\n            return false;\\n        }\\n        (address factory, bytes32 initCode,, address[] memory path) = abi.decode(_data[4:], (address, bytes32, uint256[2], address[]));\\n        return factory != address(0) && initCode != bytes32(0) && (\\n            (factory == uniForkFactory1 && initCode == uniForkInitCode1 && hasValidUniV2Path(path, uniForkFactory1, uniForkInitCode1)) ||\\n            (factory == uniForkFactory2 && initCode == uniForkInitCode2 && hasValidUniV2Path(path, uniForkFactory2, uniForkInitCode2)) ||\\n            (factory == uniForkFactory3 && initCode == uniForkInitCode3 && hasValidUniV2Path(path, uniForkFactory3, uniForkInitCode3))\\n        );\\n    }\\n\\n    function isValidMegaSwap(address _wallet, bytes calldata _data) internal view returns (bool) {\\n        (IParaswap.MegaSwapSellData memory sell) = abi.decode(_data[4:], (IParaswap.MegaSwapSellData));\\n        return hasValidBeneficiary(_wallet, sell.beneficiary) && hasValidMegaPath(sell.fromToken, sell.path);\\n    }\\n\\n    function hasAuthorisedCallees(\\n        address _augustus,\\n        address[] memory _callees,\\n        uint256[] memory _startIndexes,\\n        bytes calldata _data\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        // _data = {sig:4}{six params:192}{exchangeDataOffset:32}{...}\\n        // we add 4+32=36 to the offset to skip the method sig and the size of the exchangeData array\\n        uint256 exchangeDataOffset = 36 + abi.decode(_data[196:228], (uint256)); \\n        address[] memory spenders = new address[](_callees.length);\\n        bytes[] memory allData = new bytes[](_callees.length);\\n        for(uint256 i = 0; i < _callees.length; i++) {\\n            bytes calldata slicedExchangeData = _data[exchangeDataOffset+_startIndexes[i] : exchangeDataOffset+_startIndexes[i+1]];\\n            allData[i] = slicedExchangeData;\\n            spenders[i] = Utils.recoverSpender(_callees[i], slicedExchangeData);\\n        }\\n        return authoriser.areAuthorised(_augustus, spenders, _callees, allData);\\n    }\\n\\n    function hasValidBeneficiary(address _wallet, address _beneficiary) internal pure returns (bool) {\\n        return (_beneficiary == address(0) || _beneficiary == _wallet);\\n    }\\n\\n    function hasValidUniV2Path(address[] memory _path, address _factory, bytes32 _initCode) internal view returns (bool) {\\n        address[] memory lpTokens = new address[](_path.length - 1);\\n        for(uint i = 0; i < lpTokens.length; i++) {\\n            lpTokens[i] = pairFor(_path[i], _path[i+1], _factory, _initCode);\\n        }\\n        return hasTradableTokens(lpTokens);\\n    }\\n\\n    function pairFor(address _tokenA, address _tokenB, address _factory, bytes32 _initCode) internal view returns (address) {\\n        (address tokenA, address tokenB) = (_tokenA == ETH_TOKEN ? weth : _tokenA, _tokenB == ETH_TOKEN ? weth : _tokenB);\\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        return(address(uint160(uint(keccak256(abi.encodePacked(\\n            hex\\\"ff\\\",\\n            _factory,\\n            keccak256(abi.encodePacked(token0, token1)),\\n            _initCode\\n        ))))));\\n    }\\n\\n    function hasTradableToken(address _destToken) internal view returns (bool) {\\n        if(_destToken == ETH_TOKEN) {\\n            return true;\\n        }\\n        (bool success, bytes memory res) = tokenRegistry.staticcall(abi.encodeWithSignature(\\\"isTokenTradable(address)\\\", _destToken));\\n        return success && abi.decode(res, (bool));\\n    }\\n\\n    function hasTradableTokens(address[] memory _tokens) internal view returns (bool) {\\n        (bool success, bytes memory res) = tokenRegistry.staticcall(abi.encodeWithSignature(\\\"areTokensTradable(address[])\\\", _tokens));\\n        return success && abi.decode(res, (bool));\\n    }\\n\\n    function hasValidPath(address _fromToken, IParaswap.Path[] memory _path) internal view returns (bool) {\\n        for (uint i = 0; i < _path.length; i++) {\\n            for (uint j = 0; j < _path[i].routes.length; j++) {\\n                if(!hasValidRoute(_path[i].routes[j], (i == 0) ? _fromToken : _path[i-1].to, _path[i].to)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function hasValidRoute(IParaswap.Route memory _route, address _fromToken, address _toToken) internal view returns (bool) {\\n        if(_route.targetExchange != address(0) && !targetExchanges[_route.targetExchange]) {\\n            return false;\\n        }\\n        if(_route.exchange == uniV2Adapter) { \\n            return hasValidUniV2Route(_route.payload, uniFactory, uniInitCode);\\n        } \\n        if(_route.exchange == sushiswapAdapter) { \\n            return hasValidUniV2Route(_route.payload, uniForkFactory1, uniForkInitCode1);\\n        }\\n        if(_route.exchange == zeroExV4Adapter) { \\n            return hasValidZeroExV4Route(_route.payload);\\n        }\\n        if(_route.exchange == zeroExV2Adapter) { \\n            return hasValidZeroExV2Route(_route.payload);\\n        }\\n        if(_route.exchange == linkswapAdapter) { \\n            return hasValidUniV2Route(_route.payload, uniForkFactory2, uniForkInitCode2);\\n        }\\n        if(_route.exchange == defiswapAdapter) { \\n            return hasValidUniV2Route(_route.payload, uniForkFactory3, uniForkInitCode3);\\n        }\\n        if(_route.exchange == uniV1Adapter) { \\n            return hasValidUniV1Route(_route.targetExchange, _fromToken, _toToken);\\n        }\\n        return false;  \\n    }\\n\\n    function hasValidUniV2Route(bytes memory _payload, address _factory, bytes32 _initCode) internal view returns (bool) {\\n        IParaswap.UniswapV2Data memory data = abi.decode(_payload, (IParaswap.UniswapV2Data));\\n        return hasValidUniV2Path(data.path, _factory, _initCode);\\n    }\\n\\n    function hasValidUniV1Route(address _uniV1Factory, address _fromToken, address _toToken) internal view returns (bool) {\\n        address pool = IUniswapV1Factory(_uniV1Factory).getExchange(_fromToken == ETH_TOKEN ? _toToken : _fromToken);\\n        return hasTradableToken(pool);\\n    }\\n\\n    function hasValidZeroExV4Route(bytes memory _payload) internal view returns (bool) {\\n        IParaswap.ZeroExV4Data memory data = abi.decode(_payload, (IParaswap.ZeroExV4Data));\\n        return marketMakers[data.order.maker];\\n    }\\n\\n    function hasValidZeroExV2Route(bytes memory _payload) internal view returns (bool) {\\n        IParaswap.ZeroExV2Data memory data = abi.decode(_payload, (IParaswap.ZeroExV2Data));\\n        for(uint i = 0; i < data.orders.length; i++) {\\n            if(!marketMakers[data.orders[i].makerAddress]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function hasValidMegaPath(address _fromToken, IParaswap.MegaSwapPath[] memory _megaPath) internal view returns (bool) {\\n        for(uint i = 0; i < _megaPath.length; i++) {\\n            if(!hasValidPath(_fromToken, _megaPath[i].path)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/modules/common/Utils.sol\": {\r\n      \"content\": \"// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\n/**\\n * @title Utils\\n * @notice Common utility methods used by modules.\\n */\\nlibrary Utils {\\n\\n    // ERC20, ERC721 & ERC1155 transfers & approvals\\n    bytes4 private constant ERC20_TRANSFER = bytes4(keccak256(\\\"transfer(address,uint256)\\\"));\\n    bytes4 private constant ERC20_APPROVE = bytes4(keccak256(\\\"approve(address,uint256)\\\"));\\n    bytes4 private constant ERC721_SET_APPROVAL_FOR_ALL = bytes4(keccak256(\\\"setApprovalForAll(address,bool)\\\"));\\n    bytes4 private constant ERC721_TRANSFER_FROM = bytes4(keccak256(\\\"transferFrom(address,address,uint256)\\\"));\\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM = bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256)\\\"));\\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM_BYTES = bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256,bytes)\\\"));\\n    bytes4 private constant ERC1155_SAFE_TRANSFER_FROM = bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256,uint256,bytes)\\\"));\\n\\n    bytes4 private constant OWNER_SIG = 0x8da5cb5b;\\n    /**\\n    * @notice Helper method to recover the signer at a given position from a list of concatenated signatures.\\n    * @param _signedHash The signed hash\\n    * @param _signatures The concatenated signatures.\\n    * @param _index The index of the signature to recover.\\n    */\\n    function recoverSigner(bytes32 _signedHash, bytes memory _signatures, uint _index) internal pure returns (address) {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        // we jump 32 (0x20) as the first slot of bytes contains the length\\n        // we jump 65 (0x41) per signature\\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\\n        }\\n        require(v == 27 || v == 28, \\\"Utils: bad v value in signature\\\");\\n\\n        address recoveredAddress = ecrecover(_signedHash, v, r, s);\\n        require(recoveredAddress != address(0), \\\"Utils: ecrecover returned 0\\\");\\n        return recoveredAddress;\\n    }\\n\\n    /**\\n    * @notice Helper method to recover the spender from a contract call. \\n    * The method returns the contract unless the call is to a standard method of a ERC20/ERC721/ERC1155 token\\n    * in which case the spender is recovered from the data.\\n    * @param _to The target contract.\\n    * @param _data The data payload.\\n    */\\n    function recoverSpender(address _to, bytes memory _data) internal pure returns (address spender) {\\n        if(_data.length >= 68) {\\n            bytes4 methodId;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                methodId := mload(add(_data, 0x20))\\n            }\\n            if(\\n                methodId == ERC20_TRANSFER ||\\n                methodId == ERC20_APPROVE ||\\n                methodId == ERC721_SET_APPROVAL_FOR_ALL) \\n            {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    spender := mload(add(_data, 0x24))\\n                }\\n                return spender;\\n            }\\n            if(\\n                methodId == ERC721_TRANSFER_FROM ||\\n                methodId == ERC721_SAFE_TRANSFER_FROM ||\\n                methodId == ERC721_SAFE_TRANSFER_FROM_BYTES ||\\n                methodId == ERC1155_SAFE_TRANSFER_FROM)\\n            {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    spender := mload(add(_data, 0x44))\\n                }\\n                return spender;\\n            }\\n        }\\n\\n        spender = _to;\\n    }\\n\\n    /**\\n    * @notice Helper method to parse data and extract the method signature.\\n    */\\n    function functionPrefix(bytes memory _data) internal pure returns (bytes4 prefix) {\\n        require(_data.length >= 4, \\\"Utils: Invalid functionPrefix\\\");\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            prefix := mload(add(_data, 0x20))\\n        }\\n    }\\n\\n    /**\\n    * @notice Checks if an address is a contract.\\n    * @param _addr The address.\\n    */\\n    function isContract(address _addr) internal view returns (bool) {\\n        uint32 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return (size > 0);\\n    }\\n\\n    /**\\n    * @notice Checks if an address is a guardian or an account authorised to sign on behalf of a smart-contract guardian\\n    * given a list of guardians.\\n    * @param _guardians the list of guardians\\n    * @param _guardian the address to test\\n    * @return true and the list of guardians minus the found guardian upon success, false and the original list of guardians if not found.\\n    */\\n    function isGuardianOrGuardianSigner(address[] memory _guardians, address _guardian) internal view returns (bool, address[] memory) {\\n        if (_guardians.length == 0 || _guardian == address(0)) {\\n            return (false, _guardians);\\n        }\\n        bool isFound = false;\\n        address[] memory updatedGuardians = new address[](_guardians.length - 1);\\n        uint256 index = 0;\\n        for (uint256 i = 0; i < _guardians.length; i++) {\\n            if (!isFound) {\\n                // check if _guardian is an account guardian\\n                if (_guardian == _guardians[i]) {\\n                    isFound = true;\\n                    continue;\\n                }\\n                // check if _guardian is the owner of a smart contract guardian\\n                if (isContract(_guardians[i]) && isGuardianOwner(_guardians[i], _guardian)) {\\n                    isFound = true;\\n                    continue;\\n                }\\n            }\\n            if (index < updatedGuardians.length) {\\n                updatedGuardians[index] = _guardians[i];\\n                index++;\\n            }\\n        }\\n        return isFound ? (true, updatedGuardians) : (false, _guardians);\\n    }\\n\\n    /**\\n    * @notice Checks if an address is the owner of a guardian contract.\\n    * The method does not revert if the call to the owner() method consumes more then 25000 gas.\\n    * @param _guardian The guardian contract\\n    * @param _owner The owner to verify.\\n    */\\n    function isGuardianOwner(address _guardian, address _owner) internal view returns (bool) {\\n        address owner = address(0);\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr,OWNER_SIG)\\n            let result := staticcall(25000, _guardian, ptr, 0x20, ptr, 0x20)\\n            if eq(result, 1) {\\n                owner := mload(ptr)\\n            }\\n        }\\n        return owner == _owner;\\n    }\\n\\n    /**\\n    * @notice Returns ceil(a / b).\\n    */\\n    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a / b;\\n        if (a % b == 0) {\\n            return c;\\n        } else {\\n            return c + 1;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenRegistry\",\"type\":\"address\"},{\"internalType\":\"contract IAuthoriser\",\"name\":\"_authoriser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_augustus\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapProxy\",\"type\":\"address\"},{\"internalType\":\"address[3]\",\"name\":\"_uniFactories\",\"type\":\"address[3]\"},{\"internalType\":\"bytes32[3]\",\"name\":\"_uniInitCodes\",\"type\":\"bytes32[3]\"},{\"internalType\":\"address[7]\",\"name\":\"_adapters\",\"type\":\"address[7]\"},{\"internalType\":\"address[]\",\"name\":\"_targetExchanges\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_marketMakers\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"augustus\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authoriser\",\"outputs\":[{\"internalType\":\"contract IAuthoriser\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defiswapAdapter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"isValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isValidUniswapProxy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"linkswapAdapter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"marketMakers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiswapAdapter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"targetExchanges\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniForkFactory1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniForkFactory2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniForkFactory3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniForkInitCode1\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniForkInitCode2\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniForkInitCode3\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniInitCode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniV1Adapter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniV2Adapter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateIsValidUniswapProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zeroExV2Adapter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zeroExV4Adapter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ParaswapFilter","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"000000000000000000000000b0ec6c52f76574da1f1b2a20eb97e1eca75fd117000000000000000000000000b5ecc8ab46e2e20573c2e57c865f7c97f58c27980000000000000000000000001bd435f3c054b6e901b7b108a0ab7617c808677b0000000000000000000000000fcbb36ed7908bd5952ca171584b74bbab283091000000000000000000000000c0aee478e3658e2610c5f7a4a2e1777ce9e4f2ac000000000000000000000000696708db871b77355d6c2be7290b27cf0bb9b24b0000000000000000000000009deb29c9a4c7a88a3c0257393b7f3335338d9a9de18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c630350955d9250740335afc702786778ebeae56a5225e4e18b7cb046e61437cde6b369d637e77615df9f235f642acebbdad8963ef35c5523142078c9b8f9d0ceba7e00000000000000000000000060b64533b9a1865d88758b05b6adfe60426311f2000000000000000000000000695725627e04898ef4a126ae71fc30aa935c5fb600000000000000000000000077bc1a1ba4e9a6df5bdb21f2bbc07b9854e8d1a800000000000000000000000028c4106aadd12a9bb5d795ae717d8aa0b5685277000000000000000000000000df68d5e9b413075ff9654fdabc7c6ca72f72cfa3000000000000000000000000ae0eea652303d174e267e4d51f656254d3039f7600000000000000000000000064c3fb89f934592a2d7a5d1aa87c504b4bffe428000000000000000000000000000000000000000000000000000000000000026000000000000000000000000000000000000000000000000000000000000003600000000000000000000000000000000000000000000000000000000000000007000000000000000000000000c0a47dfe034b400b47bdad5fecda2621de6c4d9500000000000000000000000086d3579b043585a97532514016dcf0c2d6c4b6a1000000000000000000000000bc1315cd2671bc498fdab42ae1214068003dc51e000000000000000000000000ec4c8110e5b5bf0ad8aa89e3371d9c3b8cdcd778000000000000000000000000f806f9972f9a34fc05394ca6cf2cc606297ca6d5000000000000000000000000080bf510fcbf18b91105470639e9561022937712000000000000000000000000def1c0ded9bec7f1a1670819833240f027b25eff000000000000000000000000000000000000000000000000000000000000001100000000000000000000000056178a0d5f301baf6cf3e1cd53d9863437345bf9000000000000000000000000912c43e04bc77d5d64e234d92821b6bb52666f2c0000000000000000000000007be351f273ef11892e4125045d363f56cb755966000000000000000000000000a5d07e978398eb1715056d3ca5cb31035c02fdad0000000000000000000000000000006daea1723962647b7e189d311d757fb7930000000000000000000000007b1886e49ab5433bb46f7258548092dc8cdca28b00000000000000000000000096aea3a04627f96a038b348b4d34ac24df08820a00000000000000000000000057845987c8c859d52931ee248d8d84ab105324070000000000000000000000006c2d992b7739dfb363a473cc4f28998b7f1f6de2000000000000000000000000dc6d991a6f18471418e28c9249d69f385333f4ac0000000000000000000000004a45afd5a9691407b2b8e6ed8052a511ee7f01e9000000000000000000000000fc2f592ed0e0447c6c0e75350940fc069c2ba1e6000000000000000000000000cf9ebecaa4b1581b5566baacfb6d9933f9849032000000000000000000000000638c1ef824acd48e63e6acc84948f8ead46f08de000000000000000000000000f19179ab6cde7e40cb4d5240f51adfb1744f3671000000000000000000000000579d0b20609414db74d81b293900470f6d6f035b0000000000000000000000005874f5f637157f713433d0897bae58f761f6b8bb","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}