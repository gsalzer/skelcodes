{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.2 \\u003c0.8.0;\\r\\n\\r\\nlibrary Address {\\r\\n   \\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n    \\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n \\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"CurveInterface.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\ninterface CurvePool {\\r\\n\\r\\n    function get_virtual_price() external view returns(uint256);\\r\\n\\r\\n    function calc_token_amount(\\r\\n        uint256[3] memory, \\r\\n        bool\\r\\n    )  external view returns(uint256);\\r\\n\\r\\n    function add_liquidity(\\r\\n        uint256[3] memory,\\r\\n        uint256\\r\\n    )  external;\\r\\n\\r\\n    function remove_liquidity(\\r\\n        uint256,\\r\\n        uint256[3] memory\\r\\n    )  external;\\r\\n\\r\\n    function remove_liquidity_imbalance(\\r\\n        uint256[3] memory,\\r\\n        uint256\\r\\n    )  external;\\r\\n\\r\\n\\r\\n    function remove_liquidity_one_coin(\\r\\n        uint256,\\r\\n        int128,\\r\\n        uint256\\r\\n    )  external;\\r\\n}\\r\\n\\r\\ninterface PoolGauge {\\r\\n    function deposit(uint256)  external;\\r\\n    function withdraw(uint256)  external;\\r\\n    function balanceOf(address)  external view returns (uint256);\\r\\n    function claimable_tokens(address) external view returns(uint256);\\r\\n    function totalSupply()  external view returns(uint256);\\r\\n}\\r\\n\\r\\ninterface Minter {\\r\\n    function mint(address)  external;\\r\\n}\\r\\n\\r\\n\\r\\ninterface DepositY{\\r\\n    function add_liquidity(\\r\\n        uint256[3] memory,\\r\\n        uint256\\r\\n    )  external;\\r\\n\\r\\n\\r\\n    function remove_liquidity(uint256,uint256[3] memory)  external ;\\r\\n\\r\\n      function remove_liquidity_imbalance(\\r\\n        uint256[3] memory,\\r\\n        uint256\\r\\n    )  external;\\r\\n\\r\\n    function calc_withdraw_one_coin(uint256, int128)  external returns(uint256);\\r\\n\\r\\n    function remove_liquidity_one_coin(uint256, int128,uint256,bool) external ;\\r\\n\\r\\n}\\r\\n\\r\\ninterface VoteEscrow{\\r\\n    function create_lock(uint256,uint256) external ;\\r\\n    function increase_amount(uint256)  external;\\r\\n    function increase_unlock_time(uint256)  external;\\r\\n    function withdraw()  external;\\r\\n    function totalSupply()  external view returns(uint256);\\r\\n}\\r\\n\\r\\n\\r\\ninterface FeeDistributor{\\r\\n    function claim()  external;\\r\\n}\"},\"IERC20Interface.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\ninterface IERC20{\\r\\n    function approve( address, uint256)  external returns(bool);\\r\\n\\r\\n     function allowance(address, address) external view returns (uint256);\\r\\n    function balanceOf(address)  external view returns(uint256);\\r\\n\\r\\n    function decimals()  external view returns(uint8);\\r\\n\\r\\n    function totalSupply() external  view returns(uint256);\\r\\n\\r\\n    function transferFrom(address,address,uint256) external  returns(bool);\\r\\n\\r\\n    function transfer(address,uint256) external  returns(bool);\\r\\n    function mint(address , uint256 ) external ;\\r\\n    function burn(address , uint256 ) external ;\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"rCurveStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\nimport \\u0027./SafeERC20.sol\\u0027;\\r\\nimport \\u0027./CurveInterface.sol\\u0027;\\r\\nimport \\u0027./UniswapInterface.sol\\u0027;\\r\\n\\r\\ncontract CurveStrategy {\\r\\n\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address public royaleAddress;\\r\\n    address public yieldDistributor;\\r\\n    IERC20 public poolToken;\\r\\n    IERC20[3] public tokens;  // DAI / USDC / USDT\\r\\n    CurvePool public pool;\\r\\n    PoolGauge public gauge;\\r\\n    Minter public minter;\\r\\n    VoteEscrow public voteEscrow;\\r\\n    FeeDistributor public feeDistributor;\\r\\n    UniswapI  public uniAddr;\\r\\n    IERC20 public crvAddr;\\r\\n    address public wethAddr;\\r\\n     \\r\\n    uint256 public constant DENOMINATOR = 10000;\\r\\n\\r\\n    uint256 public depositSlip = 100;\\r\\n\\r\\n    uint256 public withdrawSlip = 200;\\r\\n    \\r\\n    uint256 public uniswapSlippage=50;\\r\\n\\r\\n    address public wallet;\\r\\n    address public nominatedWallet;\\r\\n    \\r\\n   // uint256 public totalProfit;\\r\\n    \\r\\n    uint256 public crvBreak=10000;\\r\\n\\r\\n   // uint256 public virtualPrice;\\r\\n \\r\\n    bool public TEST = false; // For testing uniswap , should be removed on deployment to the mainnet\\r\\n\\r\\n    modifier onlyAuthorized(){\\r\\n      require(wallet == msg.sender|| msg.sender==royaleAddress, \\\"Not authorized\\\");\\r\\n      _;\\r\\n    }\\r\\n\\r\\n    modifier onlyWallet(){\\r\\n        require((wallet==msg.sender),\\\"Not Authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyRoyaleLP() {\\r\\n        require(msg.sender == royaleAddress, \\\"Not authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n         address _wallet,\\r\\n         IERC20[3] memory _tokens, \\r\\n         address _royaleaddress,\\r\\n         address _yieldDistributor,\\r\\n         address _crvpool,\\r\\n         address _poolToken,\\r\\n         address _gauge,\\r\\n         address _minter,\\r\\n         address _uniAddress,\\r\\n         address _crvAddress,\\r\\n         address _wethAddress,\\r\\n         address _voteEscrow,\\r\\n         address _feeDistributor\\r\\n         ) public {\\r\\n\\r\\n        wallet=_wallet;\\r\\n        tokens = _tokens;\\r\\n        royaleAddress =_royaleaddress;\\r\\n        yieldDistributor=_yieldDistributor;\\r\\n        pool = CurvePool(_crvpool);\\r\\n        poolToken = IERC20(_poolToken);\\r\\n        gauge = PoolGauge(_gauge);\\r\\n        minter=Minter(_minter);\\r\\n        uniAddr=UniswapI(_uniAddress);\\r\\n        crvAddr=IERC20(_crvAddress);\\r\\n        wethAddr=_wethAddress;  \\r\\n        feeDistributor = FeeDistributor(_feeDistributor);\\r\\n        voteEscrow = VoteEscrow(_voteEscrow);\\r\\n    }\\r\\n\\r\\n    function setCRVBreak(uint256 _percentage)external onlyWallet(){\\r\\n        crvBreak=_percentage;\\r\\n    }\\r\\n\\r\\n    function nominateNewOwner(address _wallet) external onlyWallet {\\r\\n        nominatedWallet = _wallet;\\r\\n        emit walletNominated(_wallet);\\r\\n    }\\r\\n\\r\\n    function acceptOwnership() external {\\r\\n        require(msg.sender == nominatedWallet, \\\"You must be nominated before you can accept ownership\\\");\\r\\n        emit walletChanged(wallet, nominatedWallet);\\r\\n        wallet = nominatedWallet;\\r\\n        nominatedWallet = address(0);\\r\\n    }\\r\\n\\r\\n    function changeRoyaleLP(address _address)external onlyWallet(){\\r\\n        royaleAddress=_address;\\r\\n    }\\r\\n\\r\\n    function changeYieldDistributor(address _address)external onlyWallet(){\\r\\n        yieldDistributor=_address;\\r\\n    }\\r\\n    \\r\\n    function changeDepositSlip(uint _value)external onlyWallet(){\\r\\n        depositSlip=_value;\\r\\n    }\\r\\n    \\r\\n    function changeWithdrawSlip(uint _value)external onlyWallet(){\\r\\n        withdrawSlip=_value;\\r\\n    }\\r\\n    \\r\\n    function changeUniswapSlippage(uint _value) external onlyWallet(){\\r\\n        uniswapSlippage=_value;\\r\\n    }\\r\\n\\r\\n// deposits stable tokens into the 3pool and stake recived LPtoken(3CRV) in the curve 3pool gauge\\r\\n    function deposit(uint[3] memory amounts) external onlyRoyaleLP(){\\r\\n        uint currentTotal;\\r\\n        for(uint8 i=0; i\\u003c3; i++) {\\r\\n            if(amounts[i] \\u003e 0) {\\r\\n               uint decimal;\\r\\n               decimal=tokens[i].decimals();\\r\\n               tokens[i].safeApprove(address(pool),0);\\r\\n               tokens[i].safeApprove(address(pool), amounts[i]); \\r\\n               currentTotal =currentTotal.add(amounts[i].mul(1e18).div(10**decimal));\\r\\n            }\\r\\n        }\\r\\n        uint256 mintAmount = currentTotal.mul(1e18).div(pool.get_virtual_price());\\r\\n        pool.add_liquidity(amounts,  mintAmount.mul(DENOMINATOR.sub(depositSlip)).div(DENOMINATOR));\\r\\n        stakeLP();   \\r\\n    }\\r\\n\\r\\n    //withdraws stable tokens from the 3pool.Unstake required LPtokens and stake LP tokens if not used.\\r\\n    function withdraw(uint[3] memory amounts,uint[3] memory max_burn) external onlyRoyaleLP() {\\r\\n        //uint256 max_burn = pool.calc_token_amount(amounts,false);\\r\\n        uint burnAmount;\\r\\n        for(uint i=0;i\\u003c3;i++){\\r\\n             burnAmount = burnAmount.add(max_burn[i]);\\r\\n        }\\r\\n        burnAmount=burnAmount.mul(DENOMINATOR.add(withdrawSlip)).div(DENOMINATOR);\\r\\n        unstakeLP(burnAmount);\\r\\n        pool.remove_liquidity_imbalance(amounts, burnAmount);\\r\\n        for(uint8 i=0;i\\u003c3;i++){\\r\\n            if(amounts[i]!=0){\\r\\n               tokens[i].safeTransfer(royaleAddress, tokens[i].balanceOf(address(this)));\\r\\n            }\\r\\n        }\\r\\n        if(poolToken.balanceOf(address(this))\\u003e0){\\r\\n            stakeLP();\\r\\n        } \\r\\n    }\\r\\n\\r\\n   //unstake all the LPtokens and withdraw all the Stable tokens from 3pool \\r\\n    function withdrawAll() external onlyRoyaleLP() returns(uint256[3] memory){\\r\\n        unstakeLP(gauge.balanceOf(address(this)));\\r\\n        uint256[3] memory withdrawAmt;\\r\\n        pool.remove_liquidity(poolToken.balanceOf(address(this)),withdrawAmt);\\r\\n        for(uint8 i=0;i\\u003c3;i++){\\r\\n            if(tokens[i].balanceOf(address(this))!=0){\\r\\n                withdrawAmt[i]=tokens[i].balanceOf(address(this));\\r\\n                tokens[i].safeTransfer(royaleAddress,withdrawAmt[i]); \\r\\n            }\\r\\n        }\\r\\n        return withdrawAmt; \\r\\n    } \\r\\n    \\r\\n    // Functions to stake and unstake LPTokens(Ycrv) and claim CRV\\r\\n\\r\\n\\r\\n    //Stakes LP token(3CRV) into the curve 3pool gauage\\r\\n    function stakeLP() public onlyAuthorized() {\\r\\n        uint depositAmt = poolToken.balanceOf(address(this)) ;\\r\\n        poolToken.safeApprove(address(gauge),0);\\r\\n        poolToken.safeApprove(address(gauge), depositAmt);\\r\\n        gauge.deposit(depositAmt);  \\r\\n        emit staked(depositAmt);\\r\\n    }\\r\\n\\r\\n    //For unstaking LP tokens(3CRV)\\r\\n    function unstakeLP(uint _amount) public  onlyAuthorized(){\\r\\n        require(gauge.balanceOf(address(this)) \\u003e= _amount,\\\"You have not staked that much amount\\\");\\r\\n        gauge.withdraw(_amount);\\r\\n        emit unstaked(_amount);\\r\\n    }\\r\\n    \\r\\n    //Checking claimable CRV tokens.\\r\\n    function checkClaimableToken()public view  returns(uint256){\\r\\n        return gauge.claimable_tokens(address(this));\\r\\n    }\\r\\n\\r\\n    //for claiming CRV tokens which accumalates on staking 3CRV.\\r\\n    function claimCRV() public onlyAuthorized(){\\r\\n        minter.mint(address(gauge));\\r\\n        emit crvClaimed();\\r\\n    }\\r\\n\\r\\n    // Functions to lock and unlock CRV and recieve VeCRV\\r\\n\\r\\n\\r\\n   //For locking CRV tokens in the curve lock\\r\\n    function createLock(uint256 _value,uint256 _unlockTime) external onlyWallet(){\\r\\n        crvAddr.safeApprove(address(voteEscrow), 0);\\r\\n        crvAddr.safeApprove(address(voteEscrow), _value);\\r\\n        voteEscrow.create_lock(_value, _unlockTime);\\r\\n        emit locked(_value);\\r\\n    }\\r\\n\\r\\n\\r\\n    //Increasing lock CRV amount\\r\\n    function increaseLockAmount(uint256 _value) external onlyWallet(){\\r\\n        crvAddr.safeApprove(address(voteEscrow), 0);\\r\\n        crvAddr.safeApprove(address(voteEscrow), _value);\\r\\n        voteEscrow.increase_amount(_value);\\r\\n        emit locked(_value);\\r\\n    }\\r\\n\\r\\n    //For unlocking CRV tokens\\r\\n    function releaseLock() external onlyWallet(){\\r\\n        voteEscrow.withdraw(); \\r\\n        emit unlocked();\\r\\n    }\\r\\n\\r\\n//For claiming recieved 3CRV tokens which are given for locking CRV and\\r\\n   // withdrawing stable tokens from curve 3pool using those 3CRV and sending those stable tokens to an address\\r\\n    function claim3CRV()public onlyWallet(){\\r\\n        uint prevCoin=poolToken.balanceOf(address(this));\\r\\n        feeDistributor.claim();\\r\\n        uint postCoin=poolToken.balanceOf(address(this));\\r\\n        uint[3] memory minimum;\\r\\n        pool.remove_liquidity(postCoin-prevCoin,minimum);\\r\\n        for(uint i=0;i\\u003c3;i++){\\r\\n            emit yieldTransfered(i,tokens[i].balanceOf(address(this)));\\r\\n            tokens[i].safeTransfer(yieldDistributor,tokens[i].balanceOf(address(this)));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    // Function to sell CRV using uniswap to any stable token and send that token to an address\\r\\n    function sellCRV(uint8 _index,uint _amount) public onlyWallet() returns(uint256) {  //here index=0 means convert crv into DAI , index=1 means crv into USDC , index=2 means crv into USDT\\r\\n        uint256 crvAmt = IERC20(crvAddr).balanceOf(address(this));\\r\\n        uint256 prevCoin = tokens[_index].balanceOf(address(this));\\r\\n        require(crvAmt \\u003e 0, \\\"insufficient CRV\\\");\\r\\n        crvAmt=crvAmt.mul(crvBreak).div(DENOMINATOR);\\r\\n        crvAddr.safeApprove(address(uniAddr), 0);\\r\\n        crvAddr.safeApprove(address(uniAddr), crvAmt);\\r\\n        address[] memory path; \\r\\n        if(TEST) {\\r\\n            path = new address[](2);\\r\\n            path[0] = address(crvAddr);\\r\\n            path[1] = address(tokens[_index]);\\r\\n\\r\\n        } else {    \\r\\n            path = new address[](3);\\r\\n            path[0] = address(crvAddr);\\r\\n            path[1] = wethAddr;\\r\\n            path[2] = address(tokens[_index]);\\r\\n        }\\r\\n        uint minimumAmount=_amount.sub(_amount.mul(uniswapSlippage).div(DENOMINATOR));\\r\\n        UniswapI(uniAddr).swapExactTokensForTokens(\\r\\n            crvAmt, \\r\\n            minimumAmount, \\r\\n            path, \\r\\n            address(this), \\r\\n            now + 1800\\r\\n        );\\r\\n        uint256 postCoin=tokens[_index].balanceOf(address(this));\\r\\n        tokens[_index].safeTransfer(yieldDistributor,postCoin.sub(prevCoin));\\r\\n        emit yieldTransfered(_index,postCoin.sub(prevCoin));\\r\\n    }\\r\\n\\r\\n    //calulates how much VeCRV is needed to get 2.5X boost.\\r\\n    function gaugeVeCRVCalculator() public view returns(uint256){\\r\\n          uint minimumVeCRV ;\\r\\n          minimumVeCRV =(gauge.balanceOf(address(this)).mul(100)).sub((gauge.balanceOf(address(this)).mul(40))).mul(voteEscrow.totalSupply()).div(gauge.totalSupply().mul(60));\\r\\n          return minimumVeCRV;\\r\\n    }\\r\\n    \\r\\n    event yieldTransfered(uint index,uint coin);\\r\\n    event staked(uint amount);\\r\\n    event unstaked(uint amount);\\r\\n    event crvClaimed();\\r\\n    event locked(uint amount);\\r\\n    event unlocked();\\r\\n    event walletNominated(address newOwner);\\r\\n    event walletChanged(address oldOwner, address newOwner);\\r\\n\\r\\n}\"},\"SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\nimport \\u0027./SafeMath.sol\\u0027;\\r\\nimport \\\"./IERC20Interface.sol\\\";\\r\\nimport \\u0027./Address.sol\\u0027;\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        uint256 c = a + b;\\r\\n        if (c \\u003c a) return (false, 0);\\r\\n        return (true, c);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b \\u003e a) return (false, 0);\\r\\n        return (true, a - b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) return (true, 0);\\r\\n        uint256 c = a * b;\\r\\n        if (c / a != b) return (false, 0);\\r\\n        return (true, c);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b == 0) return (false, 0);\\r\\n        return (true, a / b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b == 0) return (false, 0);\\r\\n        return (true, a % b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) return 0;\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, \\\"SafeMath: modulo by zero\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting with custom message when dividing by zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"UniswapInterface.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\ninterface UniswapI {\\r\\n    \\r\\n    function swapExactTokensForTokens(uint256,uint256,address[] calldata,address,uint256) external;\\r\\n\\r\\n    function getAmountsOut(uint amountIn, address[] memory path) external returns (uint[] memory amounts);\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[3]\",\"name\":\"_tokens\",\"type\":\"address[3]\"},{\"internalType\":\"address\",\"name\":\"_royaleaddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yieldDistributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_crvpool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_crvAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wethAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_voteEscrow\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeDistributor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"crvClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"unlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"walletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"walletNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coin\",\"type\":\"uint256\"}],\"name\":\"yieldTransfered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"changeDepositSlip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"changeRoyaleLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"changeUniswapSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"changeWithdrawSlip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"changeYieldDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkClaimableToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim3CRV\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimCRV\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unlockTime\",\"type\":\"uint256\"}],\"name\":\"createLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crvAddr\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crvBreak\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"amounts\",\"type\":\"uint256[3]\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositSlip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDistributor\",\"outputs\":[{\"internalType\":\"contract FeeDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gauge\",\"outputs\":[{\"internalType\":\"contract PoolGauge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugeVeCRVCalculator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"increaseLockAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"contract Minter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract CurvePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_index\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellCRV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"setCRVBreak\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniAddr\",\"outputs\":[{\"internalType\":\"contract UniswapI\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unstakeLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteEscrow\",\"outputs\":[{\"internalType\":\"contract VoteEscrow\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"amounts\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[3]\",\"name\":\"max_burn\",\"type\":\"uint256[3]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"\",\"type\":\"uint256[3]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawSlip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldDistributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CurveStrategy","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000ccbbf208cd893959f78f7e68e8896e11e9cd3beb0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000fdc4ca4f70c59d3cd306beb3ecd83b1d1c71172c000000000000000000000000ccbbf208cd893959f78f7e68e8896e11e9cd3beb000000000000000000000000bebc44782c7db0a1a60cb6fe97d0b483032ff1c70000000000000000000000006c3f90f043a72fa612cbac8115ee7e52bde6e490000000000000000000000000bfcf63294ad7105dea65aa58f8ae5be2d9d0952a000000000000000000000000d061d61a4d941c39e5453435b6345dc261c2fce00000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000d533a949740bb3306d119cc777fa900ba034cd52000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000005f3b5dfeb7b28cdbd7faba78963ee202a494e2a2000000000000000000000000a464e6dcda8ac41e03616f95f4bc98a13b8922dc","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8e36e6979a906a72c3fb67a905eb39deb24215664acb6c56c85860c4d5626eca"}]}