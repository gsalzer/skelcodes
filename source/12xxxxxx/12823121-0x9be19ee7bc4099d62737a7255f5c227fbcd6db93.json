{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.8.6;\r\n\r\ncontract AddressesProvider {\r\n    address public ownerAddress;    \r\n    mapping(uint256 => address) addressMap;\r\n    mapping(uint256 => string) addressIdMap;\r\n    uint256 addressesLength;\r\n\r\n    constructor() {\r\n        ownerAddress = msg.sender;\r\n    }\r\n    \r\n    struct AddressMetadata {\r\n        string addrId;\r\n        address addr;\r\n    }\r\n    \r\n    function setAddress(AddressMetadata memory addressMetadata) public {\r\n        require(msg.sender == ownerAddress, \"Caller is not owner\");\r\n        string memory addressId = addressMetadata.addrId;\r\n        address addr = addressMetadata.addr;\r\n        uint256 upsertPosition = addressesLength;\r\n        int256 addressPosition = addressPositionById(addressId);\r\n        if (addressPosition >= 0) {\r\n            upsertPosition = uint256(addressPosition);\r\n        } else {\r\n            addressIdMap[upsertPosition] = addressId;\r\n            addressesLength++;\r\n        }\r\n        addressMap[upsertPosition] = addr;\r\n    }\r\n    \r\n    function setAddresses(AddressMetadata[] memory _addressesMetadata) public {\r\n        require(msg.sender == ownerAddress, \"Caller is not owner\");\r\n        for (uint256 addressMetadataIdx; addressMetadataIdx < _addressesMetadata.length; addressMetadataIdx++) {\r\n            AddressMetadata memory addressMetadata = _addressesMetadata[addressMetadataIdx];\r\n            setAddress(addressMetadata);\r\n        }\r\n    }\r\n    \r\n    function addressPositionById(string memory addressId) public view returns (int) {\r\n        for (uint256 addressIdx; addressIdx < addressesLength; addressIdx++) {\r\n            string memory currentAddressId = addressIdMap[addressIdx];\r\n            if (stringsEqual(addressId, currentAddressId)) {\r\n                return int256(addressIdx);\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n        \r\n    function addressById(string memory addressId) external view returns (address) {\r\n        return addressMap[uint256(addressPositionById(addressId))];\r\n    }\r\n    \r\n    function addresses() external view returns (address[] memory) {\r\n        address[] memory _addresses = new address[](addressesLength);\r\n        for (uint256 addressIdx; addressIdx < addressesLength; addressIdx++) {\r\n            _addresses[addressIdx] = addressMap[addressIdx];\r\n        }\r\n        return _addresses;\r\n    }\r\n\r\n    function addressesIds() external view returns (string[] memory) {\r\n        string[] memory _addressesIds = new string[](addressesLength);\r\n        for (uint256 addressIdx; addressIdx < addressesLength; addressIdx++) {\r\n            _addressesIds[addressIdx] = addressIdMap[addressIdx];\r\n        }\r\n        return _addressesIds;\r\n    }\r\n\r\n    function addressesMetadata() external view returns (AddressMetadata[] memory) {\r\n        AddressMetadata[] memory _addressesMetadata = new AddressMetadata[](addressesLength);\r\n        for (uint256 addressIdx; addressIdx < addressesLength; addressIdx++) {\r\n            _addressesMetadata[addressIdx] = AddressMetadata({\r\n                addrId: addressIdMap[addressIdx],\r\n                addr: addressMap[addressIdx]\r\n            });\r\n        }\r\n        return _addressesMetadata;\r\n    }\r\n\r\n    function addressesMetadataByIdStartsWith(string memory addressIdSubstring) external view returns (AddressMetadata[] memory) {\r\n        AddressMetadata[] memory _addressesMetadata = new AddressMetadata[](addressesLength);\r\n        uint256 _addressesLength;\r\n        for (uint256 addressIdx; addressIdx < addressesLength; addressIdx++) {\r\n            string memory addressId = addressIdMap[addressIdx];\r\n            bool foundMatch = startsWith(addressId, addressIdSubstring);\r\n            if (foundMatch) {\r\n                _addressesMetadata[_addressesLength] = AddressMetadata({\r\n                    addrId: addressIdMap[addressIdx],\r\n                    addr: addressMap[addressIdx]\r\n                });\r\n                _addressesLength++;\r\n            }\r\n        }\r\n        bytes memory encodedAddresses = abi.encode(_addressesMetadata);\r\n        assembly {\r\n            mstore(add(encodedAddresses, 0x40), _addressesLength)\r\n        }\r\n        AddressMetadata[] memory filteredAddresses =\r\n            abi.decode(encodedAddresses, (AddressMetadata[]));\r\n        return filteredAddresses;\r\n    }\r\n    \r\n    /**\r\n     * Allow storage slots to be manually updated by owner\r\n     */\r\n    function updateSlot(bytes32 slot, bytes32 value) external {\r\n        require(msg.sender == ownerAddress, \"Caller is not owner\");\r\n        assembly {\r\n            sstore(slot, value)\r\n        }\r\n    }\r\n\r\n    /***********\r\n     * Utilities\r\n     ***********/\r\n    \r\n    /**\r\n     * Search for a needle in a haystack\r\n     */\r\n    function startsWith(string memory haystack, string memory needle) internal pure returns (bool) {\r\n        return indexOf(needle, haystack) == 0;\r\n    }\r\n\r\n    /**\r\n     * Case insensitive string search\r\n     *\r\n     * @param needle The string to search for\r\n     * @param haystack The string to search in\r\n     * @return Returns -1 if no match is found, otherwise returns the index of the match \r\n     */\r\n    function indexOf(string memory needle, string memory haystack) internal pure returns (int256) {\r\n        bytes memory _needle = bytes(needle);\r\n        bytes memory _haystack = bytes(haystack);\r\n        if (_haystack.length < _needle.length) {\r\n            return -1;\r\n        }\r\n        bool _match;\r\n        for (uint256 haystackIdx; haystackIdx < _haystack.length; haystackIdx++) {\r\n            for (uint256 needleIdx; needleIdx < _needle.length; needleIdx++) {\r\n                uint8 needleChar = uint8(_needle[needleIdx]);\r\n                if (haystackIdx + needleIdx >= _haystack.length) {\r\n                    return -1;\r\n                }\r\n                uint8 haystackChar = uint8(_haystack[haystackIdx + needleIdx]);\r\n                if (needleChar == haystackChar) {\r\n                    _match = true;\r\n                    if (needleIdx == _needle.length - 1) {\r\n                        return int(haystackIdx);\r\n                    }\r\n                } else {\r\n                    _match = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    /**\r\n     * Check to see if two strings are exactly equal\r\n     * @dev Only valid for strings up to 32 characters\r\n     */    \r\n    function stringsEqual(string memory input1, string memory input2) internal pure returns (bool) {\r\n        bytes32 input1Bytes32;\r\n        bytes32 input2Bytes32;\r\n        assembly {\r\n            input1Bytes32 := mload(add(input1, 32))\r\n            input2Bytes32 := mload(add(input2, 32))\r\n        }\r\n        return input1Bytes32 == input2Bytes32;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"addressId\",\"type\":\"string\"}],\"name\":\"addressById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"addressId\",\"type\":\"string\"}],\"name\":\"addressPositionById\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressesIds\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressesMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"addrId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"internalType\":\"struct AddressesProvider.AddressMetadata[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"addressIdSubstring\",\"type\":\"string\"}],\"name\":\"addressesMetadataByIdStartsWith\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"addrId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"internalType\":\"struct AddressesProvider.AddressMetadata[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"addrId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"internalType\":\"struct AddressesProvider.AddressMetadata\",\"name\":\"addressMetadata\",\"type\":\"tuple\"}],\"name\":\"setAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"addrId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"internalType\":\"struct AddressesProvider.AddressMetadata[]\",\"name\":\"_addressesMetadata\",\"type\":\"tuple[]\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"value\",\"type\":\"bytes32\"}],\"name\":\"updateSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AddressesProvider","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e30d853a5e941e7e8b94e2fd063153b0e3057dc03e5c5f4364bb04f29bc0acda"}]}