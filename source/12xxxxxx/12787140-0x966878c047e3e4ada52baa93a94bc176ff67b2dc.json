{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/core/OptionsPremiumPricer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.7.3;\\n\\nimport {IVolatilityOracle} from \\\"../interfaces/IVolatilityOracle.sol\\\";\\nimport {IPriceOracle} from \\\"../interfaces/IPriceOracle.sol\\\";\\nimport {DSMath} from \\\"../libraries/DSMath.sol\\\";\\nimport {IERC20Detailed} from \\\"../interfaces/IERC20Detailed.sol\\\";\\nimport {Math} from \\\"../libraries/Math.sol\\\";\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract OptionsPremiumPricer is DSMath {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * Immutables\\n     */\\n    address public immutable pool;\\n    IVolatilityOracle public immutable volatilityOracle;\\n    IPriceOracle public immutable priceOracle;\\n    IPriceOracle public immutable stablesOracle;\\n    uint256 private immutable priceOracleDecimals;\\n    uint256 private immutable stablesOracleDecimals;\\n\\n    // For reference - IKEEP3rVolatility: 0xCCdfCB72753CfD55C5afF5d98eA5f9C43be9659d\\n\\n    /**\\n     * @notice Constructor for pricer, deploy one for every pool\\n     * @param _pool is the Uniswap v3 pool\\n     * @param _volatilityOracle is the oracle for historical volatility\\n     * @param _priceOracle is the Chainlink price oracle for the underlying asset\\n     * @param _stablesOracle is the Chainlink price oracle for the strike asset (e.g. USDC)\\n     */\\n    constructor(\\n        address _pool,\\n        address _volatilityOracle,\\n        address _priceOracle,\\n        address _stablesOracle\\n    ) {\\n        require(_pool != address(0), \\\"!_pool\\\");\\n        require(_volatilityOracle != address(0), \\\"!_volatilityOracle\\\");\\n        require(_priceOracle != address(0), \\\"!_priceOracle\\\");\\n        require(_stablesOracle != address(0), \\\"!_stablesOracle\\\");\\n\\n        pool = _pool;\\n        volatilityOracle = IVolatilityOracle(_volatilityOracle);\\n        priceOracle = IPriceOracle(_priceOracle);\\n        stablesOracle = IPriceOracle(_stablesOracle);\\n        priceOracleDecimals = IPriceOracle(_priceOracle).decimals();\\n        stablesOracleDecimals = IPriceOracle(_stablesOracle).decimals();\\n    }\\n\\n    /**\\n     * @notice Calculates the premium of the provided option using Black-Scholes\\n     * References for Black-Scholes:\\n       https://www.macroption.com/black-scholes-formula/\\n       https://www.investopedia.com/terms/b/blackscholes.asp\\n       https://www.erieri.com/blackscholes\\n       https://goodcalculators.com/black-scholes-calculator/\\n       https://www.calkoo.com/en/black-scholes-option-pricing-model\\n     * @param st is the strike price of the option\\n     * @param expiryTimestamp is the unix timestamp of expiry\\n     * @param isPut is whether the option is a put option\\n     * @return premium for 100 contracts with 18 decimals i.e.\\n     * 500*10**18 = 500 USDC for 100 contracts for puts,\\n     * 5*10**18 = 5 of underlying asset (ETH, WBTC, etc.) for 100 contracts for calls,\\n     */\\n    function getPremium(\\n        uint256 st,\\n        uint256 expiryTimestamp,\\n        bool isPut\\n    ) external view returns (uint256 premium) {\\n        require(\\n            expiryTimestamp > block.timestamp,\\n            \\\"Expiry must be in the future!\\\"\\n        );\\n\\n        uint256 spotPrice = priceOracle.latestAnswer();\\n\\n        (uint256 sp, uint256 v, uint256 t) =\\n            blackScholesParams(spotPrice, expiryTimestamp);\\n\\n        (uint256 call, uint256 put) = quoteAll(t, v, sp, st);\\n\\n        // Multiplier to convert oracle latestAnswer to 18 decimals\\n        uint256 assetOracleMultiplier =\\n            10 **\\n                (\\n                    uint256(18).sub(\\n                        isPut ? stablesOracleDecimals : priceOracleDecimals\\n                    )\\n                );\\n        // Make option premium denominated in the underlying\\n        // asset for call vaults and USDC for put vaults\\n        premium = isPut\\n            ? wdiv(put, stablesOracle.latestAnswer().mul(assetOracleMultiplier))\\n            : wdiv(call, spotPrice.mul(assetOracleMultiplier));\\n\\n        // Convert to 18 decimals\\n        premium = premium.mul(assetOracleMultiplier);\\n    }\\n\\n    /**\\n     * @notice Calculates the option's delta\\n     * Formula reference: `d_1` in https://www.investopedia.com/terms/b/blackscholes.asp\\n     * http://www.optiontradingpedia.com/options_delta.htm\\n     * https://www.macroption.com/black-scholes-formula/\\n     * @param st is the strike price of the option\\n     * @param expiryTimestamp is the unix timestamp of expiry\\n     * @return delta for given option. 4 decimals (ex: 8100 = 0.81 delta) as this is what strike selection\\n     * module recognizes\\n     */\\n    function getOptionDelta(uint256 st, uint256 expiryTimestamp)\\n        external\\n        view\\n        returns (uint256 delta)\\n    {\\n        require(\\n            expiryTimestamp > block.timestamp,\\n            \\\"Expiry must be in the future!\\\"\\n        );\\n\\n        uint256 spotPrice = priceOracle.latestAnswer();\\n        (uint256 sp, uint256 v, uint256 t) =\\n            blackScholesParams(spotPrice, expiryTimestamp);\\n\\n        uint256 d1;\\n        uint256 d2;\\n\\n        // Divide delta by 10 ** 10 to bring it to 4 decimals for strike selection\\n        if (sp >= st) {\\n            (d1, d2) = derivatives(t, v, sp, st);\\n            delta = Math.ncdf((Math.FIXED_1 * d1) / 1e18).div(10**10);\\n        } else {\\n            // If underlying < strike price notice we switch st <-> sp passed into d\\n            (d1, d2) = derivatives(t, v, st, sp);\\n            delta = uint256(10)\\n                .mul(10**13)\\n                .sub(Math.ncdf((Math.FIXED_1 * d2) / 1e18))\\n                .div(10**10);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the option's delta\\n     * Formula reference: `d_1` in https://www.investopedia.com/terms/b/blackscholes.asp\\n     * http://www.optiontradingpedia.com/options_delta.htm\\n     * https://www.macroption.com/black-scholes-formula/\\n     * @param sp is the spot price of the option\\n     * @param st is the strike price of the option\\n     * @param v is the annualized volatility of the underlying asset\\n     * @param expiryTimestamp is the unix timestamp of expiry\\n     * @return delta for given option. 4 decimals (ex: 8100 = 0.81 delta) as this is what strike selection\\n     * module recognizes\\n     */\\n    function getOptionDelta(\\n        uint256 sp,\\n        uint256 st,\\n        uint256 v,\\n        uint256 expiryTimestamp\\n    ) external view returns (uint256 delta) {\\n        require(\\n            expiryTimestamp > block.timestamp,\\n            \\\"Expiry must be in the future!\\\"\\n        );\\n\\n        // days until expiry\\n        uint256 t = expiryTimestamp.sub(block.timestamp).div(1 days);\\n\\n        uint256 d1;\\n        uint256 d2;\\n\\n        // Divide delta by 10 ** 10 to bring it to 4 decimals for strike selection\\n        if (sp >= st) {\\n            (d1, d2) = derivatives(t, v, sp, st);\\n            delta = Math.ncdf((Math.FIXED_1 * d1) / 1e18).div(10**10);\\n        } else {\\n            // If underlying < strike price notice we switch st <-> sp passed into d\\n            (d1, d2) = derivatives(t, v, st, sp);\\n            delta = uint256(10)\\n                .mul(10**13)\\n                .sub(Math.ncdf((Math.FIXED_1 * d2) / 1e18))\\n                .div(10**10);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates black scholes for both put and call\\n     * @param t is the days until expiry\\n     * @param v is the annualized volatility\\n     * @param sp is the underlying price\\n     * @param st is the strike price\\n     * @return call is the premium of the call option given parameters\\n     * @return put is the premium of the put option given parameters\\n     */\\n    function quoteAll(\\n        uint256 t,\\n        uint256 v,\\n        uint256 sp,\\n        uint256 st\\n    ) private pure returns (uint256 call, uint256 put) {\\n        uint256 _c;\\n        uint256 _p;\\n\\n        if (sp > st) {\\n            _c = blackScholes(t, v, sp, st);\\n            _p = max(_c.add(st), sp) == sp ? 0 : _c.add(st).sub(sp);\\n        } else {\\n            _p = blackScholes(t, v, st, sp);\\n            _c = max(_p.add(sp), st) == st ? 0 : _p.add(sp).sub(st);\\n        }\\n\\n        return (_c, _p);\\n    }\\n\\n    /**\\n     * @notice Calculates black scholes for the ITM option at mint given strike\\n     * price and underlying given the parameters (if underling >= strike price this is\\n     * premium of call, and put otherwise)\\n     * @param t is the days until expiry\\n     * @param v is the annualized volatility\\n     * @param sp is the underlying price\\n     * @param st is the strike price\\n     * @return premium is the premium of option\\n     */\\n    function blackScholes(\\n        uint256 t,\\n        uint256 v,\\n        uint256 sp,\\n        uint256 st\\n    ) private pure returns (uint256 premium) {\\n        (uint256 d1, uint256 d2) = derivatives(t, v, sp, st);\\n\\n        uint256 cdfD1 = Math.ncdf((Math.FIXED_1 * d1) / 1e18);\\n        uint256 cdfD2 = Math.cdf((int256(Math.FIXED_1) * int256(d2)) / 1e18);\\n\\n        premium = (sp * cdfD1) / 1e14 - (st * cdfD2) / 1e14;\\n    }\\n\\n    /**\\n     * @notice Calculates d1 and d2 used in black scholes calculation\\n     * as parameters to black scholes calculations\\n     * @param t is the days until expiry\\n     * @param v is the annualized volatility\\n     * @param sp is the underlying price\\n     * @param st is the strike price\\n     * @return d1 and d2\\n     */\\n    function derivatives(\\n        uint256 t,\\n        uint256 v,\\n        uint256 sp,\\n        uint256 st\\n    ) internal pure returns (uint256 d1, uint256 d2) {\\n        require(sp > 0, \\\"!sp\\\");\\n        require(st > 0, \\\"!st\\\");\\n\\n        uint256 sigma = ((v**2) / 2);\\n        uint256 sigmaB = 1e36;\\n\\n        uint256 sig = (((1e18 * sigma) / sigmaB) * t) / 365;\\n\\n        uint256 sSQRT = (v * Math.sqrt2((1e18 * t) / 365)) / 1e9;\\n        require(sSQRT > 0, \\\"!sSQRT\\\");\\n\\n        d1 = (1e18 * Math.ln((Math.FIXED_1 * sp) / st)) / Math.FIXED_1;\\n        d1 = ((d1 + sig) * 1e18) / sSQRT;\\n        d2 = d1 - sSQRT;\\n    }\\n\\n    /**\\n     * @notice Calculates the current underlying price, annualized volatility, and days until expiry\\n     * as parameters to black scholes calculations\\n     * @param expiryTimestamp is the unix timestamp of expiry\\n     * @return sp is the underlying\\n     * @return v is the volatility\\n     * @return t is the days until expiry\\n     */\\n    function blackScholesParams(uint256 spotPrice, uint256 expiryTimestamp)\\n        private\\n        view\\n        returns (\\n            uint256 sp,\\n            uint256 v,\\n            uint256 t\\n        )\\n    {\\n        // chainlink oracle returns crypto / usd pairs with 8 decimals, like otoken strike price\\n        sp = spotPrice.mul(10**8).div(10**priceOracleDecimals);\\n        // annualized vol * 10 ** 8 because delta expects 18 decimals\\n        // and annualizedVol is 8 decimals\\n        v = volatilityOracle.annualizedVol(pool).mul(10**10);\\n        t = expiryTimestamp.sub(block.timestamp).div(1 days);\\n    }\\n\\n    /**\\n     * @notice Calculates the underlying assets price\\n     */\\n    function getUnderlyingPrice() external view returns (uint256 price) {\\n        price = priceOracle.latestAnswer();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVolatilityOracle.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.7.3;\\n\\ninterface IVolatilityOracle {\\n    function commit(address pool) external;\\n\\n    function twap(address pool) external returns (uint256 price);\\n\\n    function vol(address pool)\\n        external\\n        view\\n        returns (uint256 standardDeviation);\\n\\n    function annualizedVol(address pool)\\n        external\\n        view\\n        returns (uint256 annualStdev);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.7.3;\\n\\ninterface IPriceOracle {\\n    function decimals() external view returns (uint256 _decimals);\\n\\n    function latestAnswer() external view returns (uint256 price);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DSMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/// math.sol -- mixin for inline numerical wizardry\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >0.4.13;\\n\\ncontract DSMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    uint256 constant WAD = 10**18;\\n    uint256 constant RAY = 10**27;\\n\\n    //rounds to zero if x*WAD < y/2\\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    //rounds to zero if x*RAY < y/2\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n\\n    //rounds to zero if x*y < RAY / 2\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Detailed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.3;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IERC20Detailed is IERC20 {\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string calldata);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.7.3;\\n\\nlibrary Math {\\n    uint256 constant FIXED_1 = 0x080000000000000000000000000000000;\\n    uint256 constant FIXED_2 = 0x100000000000000000000000000000000;\\n    uint256 constant SQRT_1 = 13043817825332782212;\\n    uint256 constant LNX = 3988425491;\\n    uint256 constant LOG_10_2 = 3010299957;\\n    uint256 constant LOG_E_2 = 6931471806;\\n    uint256 constant BASE = 1e10;\\n\\n    // solhint-disable-next-line\\n    // Credit to Ryan Hendricks, https://github.com/RyanHendricks/Black-Scholes-Solidity/blob/master/contracts/BlackScholesEstimate.sol\\n    /**\\n     * @dev stddev calculates the standard deviation for an array of integers\\n     * @dev precision is the same as sqrt above meaning for higher precision\\n     * @dev the decimal place must be moved prior to passing the params\\n     * @param numbers uint[] array of numbers to be used in calculation\\n     */\\n    function stddev(uint256[] memory numbers)\\n        internal\\n        pure\\n        returns (uint256 sd)\\n    {\\n        uint256 sum = 0;\\n        for (uint256 i = 0; i < numbers.length; i++) {\\n            sum += numbers[i];\\n        }\\n        uint256 mean = sum / numbers.length; // Integral value; float not supported in Solidity\\n        sum = 0;\\n        uint256 i;\\n        for (i = 0; i < numbers.length; i++) {\\n            sum += (numbers[i] - mean)**2;\\n        }\\n        sd = sqrt(sum / (numbers.length - 1)); //Integral value; float not supported in Solidity\\n        return sd;\\n    }\\n\\n    function sqrt2(uint256 x) internal pure returns (uint256 y) {\\n        uint256 z = (x + 1) / 2;\\n        y = x;\\n        while (z < y) {\\n            y = z;\\n            z = (x / z + z) / 2;\\n        }\\n    }\\n\\n    // solhint-disable-next-line\\n    // Credit to Paul Razvan Berg https://github.com/hifi-finance/prb-math/blob/main/contracts/PRBMath.sol\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Set the initial guess to the closest power of two that is higher than x.\\n        uint256 xAux = uint256(x);\\n        result = 1;\\n        if (xAux >= 0x100000000000000000000000000000000) {\\n            xAux >>= 128;\\n            result <<= 64;\\n        }\\n        if (xAux >= 0x10000000000000000) {\\n            xAux >>= 64;\\n            result <<= 32;\\n        }\\n        if (xAux >= 0x100000000) {\\n            xAux >>= 32;\\n            result <<= 16;\\n        }\\n        if (xAux >= 0x10000) {\\n            xAux >>= 16;\\n            result <<= 8;\\n        }\\n        if (xAux >= 0x100) {\\n            xAux >>= 8;\\n            result <<= 4;\\n        }\\n        if (xAux >= 0x10) {\\n            xAux >>= 4;\\n            result <<= 2;\\n        }\\n        if (xAux >= 0x8) {\\n            result <<= 1;\\n        }\\n\\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1; // Seven iterations should be enough\\n        uint256 roundedDownResult = x / result;\\n        return result >= roundedDownResult ? roundedDownResult : result;\\n    }\\n\\n    /**\\n     * @dev computes e ^ (x / FIXED_1) * FIXED_1\\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\\n     * auto-generated via 'PrintFunctionOptimalExp.py'\\n     * Detailed description:\\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\\n     * - The exponentiation of each binary exponent is given (pre-calculated)\\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\\n     */\\n    function optimalExp(uint256 x) internal pure returns (uint256) {\\n        uint256 res = 0;\\n\\n        uint256 y;\\n        uint256 z;\\n\\n        z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\\n        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\\n\\n        if ((x & 0x010000000000000000000000000000000) != 0)\\n            res =\\n                (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) /\\n                0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\\n        if ((x & 0x020000000000000000000000000000000) != 0)\\n            res =\\n                (res * 0x18ebef9eac820ae8682b9793ac6d1e778) /\\n                0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\\n        if ((x & 0x040000000000000000000000000000000) != 0)\\n            res =\\n                (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) /\\n                0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\\n        if ((x & 0x080000000000000000000000000000000) != 0)\\n            res =\\n                (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) /\\n                0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\\n        if ((x & 0x100000000000000000000000000000000) != 0)\\n            res =\\n                (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) /\\n                0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\\n        if ((x & 0x200000000000000000000000000000000) != 0)\\n            res =\\n                (res * 0x00960aadc109e7a3bf4578099615711d7) /\\n                0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\\n        if ((x & 0x400000000000000000000000000000000) != 0)\\n            res =\\n                (res * 0x0002bf84208204f5977f9a8cf01fdc307) /\\n                0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\\n\\n        return res;\\n    }\\n\\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\\n        uint8 res = 0;\\n\\n        if (_n < 256) {\\n            // At most 8 iterations\\n            while (_n > 1) {\\n                _n >>= 1;\\n                res += 1;\\n            }\\n        } else {\\n            // Exactly 8 iterations\\n            for (uint8 s = 128; s > 0; s >>= 1) {\\n                if (_n >= (uint256(1) << s)) {\\n                    _n >>= s;\\n                    res |= s;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    function ln(uint256 x) internal pure returns (uint256) {\\n        uint256 res = 0;\\n\\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\\n        if (x >= FIXED_2) {\\n            uint8 count = floorLog2(x / FIXED_1);\\n            x >>= count; // now x < 2\\n            res = count * FIXED_1;\\n        }\\n\\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\\n        if (x > FIXED_1) {\\n            for (uint8 i = 127; i > 0; --i) {\\n                x = (x * x) / FIXED_1; // now 1 < x < 4\\n                if (x >= FIXED_2) {\\n                    x >>= 1; // now 1 < x < 2\\n                    res += uint256(1) << (i - 1);\\n                }\\n            }\\n        }\\n\\n        return (res * LOG_E_2) / BASE;\\n    }\\n\\n    /**\\n     * @notice Takes the absolute value of a given number\\n     * @dev Helper function\\n     * @param _number The specified number\\n     * @return The absolute value of the number\\n     */\\n    function abs(int256 _number) public pure returns (uint256) {\\n        return _number < 0 ? uint256(_number * (-1)) : uint256(_number);\\n    }\\n\\n    function ncdf(uint256 x) internal pure returns (uint256) {\\n        int256 t1 = int256(1e7 + ((2316419 * x) / FIXED_1));\\n        uint256 exp = ((x / 2) * x) / FIXED_1;\\n        int256 d = int256((3989423 * FIXED_1) / optimalExp(uint256(exp)));\\n        uint256 prob =\\n            uint256(\\n                (d *\\n                    (3193815 +\\n                        ((-3565638 +\\n                            ((17814780 +\\n                                ((-18212560 + (13302740 * 1e7) / t1) * 1e7) /\\n                                t1) * 1e7) /\\n                            t1) * 1e7) /\\n                        t1) *\\n                    1e7) / t1\\n            );\\n        if (x > 0) prob = 1e14 - prob;\\n        return prob;\\n    }\\n\\n    function cdf(int256 x) internal pure returns (uint256) {\\n        int256 t1 = int256(1e7 + int256((2316419 * abs(x)) / FIXED_1));\\n        uint256 exp = uint256((x / 2) * x) / FIXED_1;\\n        int256 d = int256((3989423 * FIXED_1) / optimalExp(uint256(exp)));\\n        uint256 prob =\\n            uint256(\\n                (d *\\n                    (3193815 +\\n                        ((-3565638 +\\n                            ((17814780 +\\n                                ((-18212560 + (13302740 * 1e7) / t1) * 1e7) /\\n                                t1) * 1e7) /\\n                            t1) * 1e7) /\\n                        t1) *\\n                    1e7) / t1\\n            );\\n        if (x > 0) prob = 1e14 - prob;\\n        return prob;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_volatilityOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stablesOracle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"st\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTimestamp\",\"type\":\"uint256\"}],\"name\":\"getOptionDelta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"delta\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"st\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTimestamp\",\"type\":\"uint256\"}],\"name\":\"getOptionDelta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"delta\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"st\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPut\",\"type\":\"bool\"}],\"name\":\"getPremium\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"contract IPriceOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stablesOracle\",\"outputs\":[{\"internalType\":\"contract IPriceOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"volatilityOracle\",\"outputs\":[{\"internalType\":\"contract IVolatilityOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"OptionsPremiumPricer","CompilerVersion":"v0.7.3+commit.9bfce1f6","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008ad599c3a0ff1de082011efddc58f1908eb6e6d80000000000000000000000008eb47e59e0c03a7d1bfeafee6b85910cefd0ee990000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b84190000000000000000000000008fffffd4afb6115b954bd326cbe7b4ba576818f6","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}