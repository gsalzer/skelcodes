{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.6;  \r\n\r\n\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256 supply);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    function decimals() external view returns (uint256 digits);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n} \r\n\r\n\r\n\r\n\r\n\r\nabstract contract IWETH {\r\n    function allowance(address, address) public virtual view returns (uint256);\r\n\r\n    function balanceOf(address) public virtual view returns (uint256);\r\n\r\n    function approve(address, uint256) public virtual;\r\n\r\n    function transfer(address, uint256) public virtual returns (bool);\r\n\r\n    function transferFrom(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) public virtual returns (bool);\r\n\r\n    function deposit() public payable virtual;\r\n\r\n    function withdraw(uint256) public virtual;\r\n}  \r\n\r\n\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}  \r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    /// @dev Edited so it always first approves 0 and then the value, because of non standard tokens\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\r\n            value,\r\n            \"SafeERC20: decreased allowance below zero\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\r\n        );\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(\r\n            data,\r\n            \"SafeERC20: low-level call failed\"\r\n        );\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}  \r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary TokenUtils {\r\n    using SafeERC20 for IERC20;\r\n\r\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    function approveToken(\r\n        address _tokenAddr,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal {\r\n        if (_tokenAddr == ETH_ADDR) return;\r\n\r\n        if (IERC20(_tokenAddr).allowance(address(this), _to) < _amount) {\r\n            IERC20(_tokenAddr).safeApprove(_to, _amount);\r\n        }\r\n    }\r\n\r\n    function pullTokensIfNeeded(\r\n        address _token,\r\n        address _from,\r\n        uint256 _amount\r\n    ) internal returns (uint256) {\r\n        // handle max uint amount\r\n        if (_amount == type(uint256).max) {\r\n            uint256 userAllowance = IERC20(_token).allowance(_from, address(this));\r\n            uint256 balance = getBalance(_token, _from);\r\n\r\n            // pull max allowance amount if balance is bigger than allowance\r\n            _amount = (balance > userAllowance) ? userAllowance : balance;\r\n        }\r\n\r\n        if (_from != address(0) && _from != address(this) && _token != ETH_ADDR && _amount != 0) {\r\n            IERC20(_token).safeTransferFrom(_from, address(this), _amount);\r\n        }\r\n\r\n        return _amount;\r\n    }\r\n\r\n    function withdrawTokens(\r\n        address _token,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal returns (uint256) {\r\n        if (_amount == type(uint256).max) {\r\n            _amount = getBalance(_token, address(this));\r\n        }\r\n\r\n        if (_to != address(0) && _to != address(this) && _amount != 0) {\r\n            if (_token != ETH_ADDR) {\r\n                IERC20(_token).safeTransfer(_to, _amount);\r\n            } else {\r\n                payable(_to).transfer(_amount);\r\n            }\r\n        }\r\n\r\n        return _amount;\r\n    }\r\n\r\n    function depositWeth(uint256 _amount) internal {\r\n        IWETH(WETH_ADDR).deposit{value: _amount}();\r\n    }\r\n\r\n    function withdrawWeth(uint256 _amount) internal {\r\n        IWETH(WETH_ADDR).withdraw(_amount);\r\n    }\r\n\r\n    function getBalance(address _tokenAddr, address _acc) internal view returns (uint256) {\r\n        if (_tokenAddr == ETH_ADDR) {\r\n            return _acc.balance;\r\n        } else {\r\n            return IERC20(_tokenAddr).balanceOf(_acc);\r\n        }\r\n    }\r\n\r\n    function getTokenDecimals(address _token) internal view returns (uint256) {\r\n        if (_token == ETH_ADDR) return 18;\r\n\r\n        return IERC20(_token).decimals();\r\n    }\r\n}  \r\n\r\n\r\n\r\n\r\n// Common interface for the Trove Manager.\r\ninterface ITroveManager {\r\n    \r\n    // --- Events ---\r\n\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\r\n    event ActivePoolAddressChanged(address _activePoolAddress);\r\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\r\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\r\n    event GasPoolAddressChanged(address _gasPoolAddress);\r\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\r\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\r\n    event LQTYTokenAddressChanged(address _lqtyTokenAddress);\r\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\r\n\r\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\r\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\r\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\r\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, uint8 operation);\r\n    event BaseRateUpdated(uint _baseRate);\r\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\r\n    event TotalStakesUpdated(uint _newTotalStakes);\r\n    event SystemSnapshotsUpdated(uint _totalStakesSnapshot, uint _totalCollateralSnapshot);\r\n    event LTermsUpdated(uint _L_ETH, uint _L_LUSDDebt);\r\n    event TroveSnapshotsUpdated(uint _L_ETH, uint _L_LUSDDebt);\r\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\r\n\r\n    function getTroveOwnersCount() external view returns (uint);\r\n\r\n    function getTroveFromTroveOwnersArray(uint _index) external view returns (address);\r\n\r\n    function getNominalICR(address _borrower) external view returns (uint);\r\n    function getCurrentICR(address _borrower, uint _price) external view returns (uint);\r\n\r\n    function liquidate(address _borrower) external;\r\n\r\n    function liquidateTroves(uint _n) external;\r\n\r\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\r\n\r\n    function redeemCollateral(\r\n        uint _LUSDAmount,\r\n        address _firstRedemptionHint,\r\n        address _upperPartialRedemptionHint,\r\n        address _lowerPartialRedemptionHint,\r\n        uint _partialRedemptionHintNICR,\r\n        uint _maxIterations,\r\n        uint _maxFee\r\n    ) external; \r\n\r\n    function updateStakeAndTotalStakes(address _borrower) external returns (uint);\r\n\r\n    function updateTroveRewardSnapshots(address _borrower) external;\r\n\r\n    function addTroveOwnerToArray(address _borrower) external returns (uint index);\r\n\r\n    function applyPendingRewards(address _borrower) external;\r\n\r\n    function getPendingETHReward(address _borrower) external view returns (uint);\r\n\r\n    function getPendingLUSDDebtReward(address _borrower) external view returns (uint);\r\n\r\n     function hasPendingRewards(address _borrower) external view returns (bool);\r\n\r\n    function getEntireDebtAndColl(address _borrower) external view returns (\r\n        uint debt, \r\n        uint coll, \r\n        uint pendingLUSDDebtReward, \r\n        uint pendingETHReward\r\n    );\r\n\r\n    function closeTrove(address _borrower) external;\r\n\r\n    function removeStake(address _borrower) external;\r\n\r\n    function getRedemptionRate() external view returns (uint);\r\n    function getRedemptionRateWithDecay() external view returns (uint);\r\n\r\n    function getRedemptionFeeWithDecay(uint _ETHDrawn) external view returns (uint);\r\n\r\n    function getBorrowingRate() external view returns (uint);\r\n    function getBorrowingRateWithDecay() external view returns (uint);\r\n\r\n    function getBorrowingFee(uint LUSDDebt) external view returns (uint);\r\n    function getBorrowingFeeWithDecay(uint _LUSDDebt) external view returns (uint);\r\n\r\n    function decayBaseRateFromBorrowing() external;\r\n\r\n    function getTroveStatus(address _borrower) external view returns (uint);\r\n    \r\n    function getTroveStake(address _borrower) external view returns (uint);\r\n\r\n    function getTroveDebt(address _borrower) external view returns (uint);\r\n\r\n    function getTroveColl(address _borrower) external view returns (uint);\r\n\r\n    function setTroveStatus(address _borrower, uint num) external;\r\n\r\n    function increaseTroveColl(address _borrower, uint _collIncrease) external returns (uint);\r\n\r\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external returns (uint); \r\n\r\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external returns (uint); \r\n\r\n    function decreaseTroveDebt(address _borrower, uint _collDecrease) external returns (uint); \r\n\r\n    function getTCR(uint _price) external view returns (uint);\r\n\r\n    function checkRecoveryMode(uint _price) external view returns (bool);\r\n}  \r\n\r\n\r\n\r\n// Common interface for the Trove Manager.\r\ninterface IBorrowerOperations {\r\n\r\n    // --- Events ---\r\n\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolAddressChanged(address _activePoolAddress);\r\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\r\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\r\n    event GasPoolAddressChanged(address _gasPoolAddress);\r\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\r\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\r\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\r\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\r\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\r\n\r\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\r\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\r\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\r\n\r\n    // --- Functions ---\r\n\r\n    function openTrove(uint _maxFee, uint _LUSDAmount, address _upperHint, address _lowerHint) external payable;\r\n\r\n    function addColl(address _upperHint, address _lowerHint) external payable;\r\n\r\n    function moveETHGainToTrove(address _user, address _upperHint, address _lowerHint) external payable;\r\n\r\n    function withdrawColl(uint _amount, address _upperHint, address _lowerHint) external;\r\n\r\n    function withdrawLUSD(uint _maxFee, uint _amount, address _upperHint, address _lowerHint) external;\r\n\r\n    function repayLUSD(uint _amount, address _upperHint, address _lowerHint) external;\r\n\r\n    function closeTrove() external;\r\n\r\n    function adjustTrove(uint _maxFee, uint _collWithdrawal, uint _debtChange, bool isDebtIncrease, address _upperHint, address _lowerHint) external payable;\r\n\r\n    function claimCollateral() external;\r\n\r\n    function getCompositeDebt(uint _debt) external pure returns (uint);\r\n}  \r\n\r\n\r\n\r\ninterface IPriceFeed {\r\n    function lastGoodPrice() external pure returns (uint256);\r\n}  \r\n\r\n\r\n\r\ninterface IHintHelpers {\r\n\r\n    function getRedemptionHints(\r\n        uint _LUSDamount, \r\n        uint _price,\r\n        uint _maxIterations\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            address firstRedemptionHint,\r\n            uint partialRedemptionHintNICR,\r\n            uint truncatedLUSDamount\r\n        );\r\n\r\n    function getApproxHint(uint _CR, uint _numTrials, uint _inputRandomSeed)\r\n        external\r\n        view\r\n        returns (address hintAddress, uint diff, uint latestRandomSeed);\r\n\r\n    function computeNominalCR(uint _coll, uint _debt) external pure returns (uint);\r\n\r\n    function computeCR(uint _coll, uint _debt, uint _price) external pure returns (uint);\r\n}  \r\n\r\n\r\n\r\n// Common interface for the SortedTroves Doubly Linked List.\r\ninterface ISortedTroves {\r\n\r\n    // --- Events ---\r\n    \r\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\r\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\r\n    event NodeAdded(address _id, uint _NICR);\r\n    event NodeRemoved(address _id);\r\n\r\n    // --- Functions ---\r\n    \r\n    function setParams(uint256 _size, address _TroveManagerAddress, address _borrowerOperationsAddress) external;\r\n\r\n    function insert(address _id, uint256 _ICR, address _prevId, address _nextId) external;\r\n\r\n    function remove(address _id) external;\r\n\r\n    function reInsert(address _id, uint256 _newICR, address _prevId, address _nextId) external;\r\n\r\n    function contains(address _id) external view returns (bool);\r\n\r\n    function isFull() external view returns (bool);\r\n\r\n    function isEmpty() external view returns (bool);\r\n\r\n    function getSize() external view returns (uint256);\r\n\r\n    function getMaxSize() external view returns (uint256);\r\n\r\n    function getFirst() external view returns (address);\r\n\r\n    function getLast() external view returns (address);\r\n\r\n    function getNext(address _id) external view returns (address);\r\n\r\n    function getPrev(address _id) external view returns (address);\r\n\r\n    function validInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (bool);\r\n\r\n    function findInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (address, address);\r\n}  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LiquityHelper {\r\n    address constant public LUSDTokenAddr = 0x5f98805A4E8be255a32880FDeC7F6728C6568bA0;\r\n    address constant public PriceFeedAddr = 0x4c517D4e2C851CA76d7eC94B805269Df0f2201De;\r\n    address constant public BorrowerOperationsAddr = 0x24179CD81c9e782A4096035f7eC97fB8B783e007;\r\n    address constant public TroveManagerAddr = 0xA39739EF8b0231DbFA0DcdA07d7e29faAbCf4bb2;\r\n    address constant public SortedTrovesAddr = 0x8FdD3fbFEb32b28fb73555518f8b361bCeA741A6;\r\n    address constant public HintHelpersAddr = 0xE84251b93D9524E0d2e621Ba7dc7cb3579F997C0;\r\n\r\n    IPriceFeed constant public PriceFeed = IPriceFeed(PriceFeedAddr);\r\n    IBorrowerOperations constant public BorrowerOperations = IBorrowerOperations(BorrowerOperationsAddr);\r\n    ITroveManager constant public TroveManager = ITroveManager(TroveManagerAddr);\r\n    ISortedTroves constant public SortedTroves = ISortedTroves(SortedTrovesAddr);\r\n    IHintHelpers constant public HintHelpers = IHintHelpers(HintHelpersAddr);\r\n}  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LiquityView is LiquityHelper {\r\n    using TokenUtils for address;\r\n    using SafeMath for uint256;\r\n\r\n    enum LiquityActionId {Open, Borrow, Payback, Supply, Withdraw}\r\n\r\n    function isRecoveryMode() public view returns (bool) {\r\n        uint256 price = PriceFeed.lastGoodPrice();\r\n        return TroveManager.checkRecoveryMode(price);\r\n    }\r\n\r\n    function computeNICR(uint256 _coll, uint256 _debt) public pure returns (uint256) {\r\n        if (_debt > 0) {\r\n            return _coll.mul(1e20).div(_debt);\r\n        }\r\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\r\n        else {\r\n            // if (_debt == 0)\r\n            return 2**256 - 1;\r\n        }\r\n    }\r\n\r\n    /// @notice Predict the resulting nominal collateral ratio after a trove modifying action\r\n    /// @param _troveOwner Address of the trove owner, if the action specified is LiquityOpen this argument is ignored\r\n    /// @param _action LiquityActionIds\r\n    function predictNICR(\r\n        address _troveOwner,\r\n        LiquityActionId _action,\r\n        address _from,\r\n        uint256 _collAmount,\r\n        uint256 _lusdAmount\r\n    ) external view returns (uint256 NICR) {\r\n        //  LiquityOpen\r\n        if (_action == LiquityActionId.Open) {\r\n            if (!isRecoveryMode())\r\n                _lusdAmount = _lusdAmount.add(TroveManager.getBorrowingFeeWithDecay(_lusdAmount));\r\n            _lusdAmount = BorrowerOperations.getCompositeDebt(_lusdAmount);\r\n\r\n            if (_collAmount == type(uint256).max)\r\n                _collAmount = TokenUtils.WETH_ADDR.getBalance(_from);\r\n\r\n            return computeNICR(_collAmount, _lusdAmount);\r\n        }\r\n\r\n        (uint256 debt, uint256 coll, , ) = TroveManager.getEntireDebtAndColl(_troveOwner);\r\n\r\n        //  LiquityBorrow\r\n        if (_action == LiquityActionId.Borrow) {\r\n            if (!isRecoveryMode())\r\n                _lusdAmount = _lusdAmount.add(TroveManager.getBorrowingFeeWithDecay(_lusdAmount));\r\n            return computeNICR(coll, debt.add(_lusdAmount));\r\n        }\r\n\r\n        //  LiquityPayback\r\n        if (_action == LiquityActionId.Payback) {\r\n            return computeNICR(coll, debt.sub(_lusdAmount));\r\n        }\r\n\r\n        //  LiquitySupply\r\n        if (_action == LiquityActionId.Supply) {\r\n            if (_collAmount == type(uint256).max)\r\n                _collAmount = TokenUtils.WETH_ADDR.getBalance(_from);\r\n\r\n            return computeNICR(coll.add(_collAmount), debt);\r\n        }\r\n\r\n        //  LiquityWithdraw\r\n        if (_action == LiquityActionId.Withdraw) {\r\n            return computeNICR(coll.sub(_collAmount), debt);\r\n        }\r\n    }\r\n\r\n    function getApproxHint(\r\n        uint256 _CR,\r\n        uint256 _numTrials,\r\n        uint256 _inputRandomSeed\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            address hintAddress,\r\n            uint256 diff,\r\n            uint256 latestRandomSeed\r\n        )\r\n    {\r\n        return HintHelpers.getApproxHint(_CR, _numTrials, _inputRandomSeed);\r\n    }\r\n\r\n    function findInsertPosition(\r\n        uint256 _ICR,\r\n        address _prevId,\r\n        address _nextId\r\n    ) external view returns (address upperHint, address lowerHint) {\r\n        return SortedTroves.findInsertPosition(_ICR, _prevId, _nextId);\r\n    }\r\n\r\n    function getTroveInfo(address _troveOwner)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 troveStatus,\r\n            uint256 collAmount,\r\n            uint256 debtAmount,\r\n            uint256 collPrice,\r\n            uint256 TCRatio,\r\n            bool recoveryMode\r\n        )\r\n    {\r\n        troveStatus = TroveManager.getTroveStatus(_troveOwner);\r\n        collAmount = TroveManager.getTroveColl(_troveOwner);\r\n        debtAmount = TroveManager.getTroveDebt(_troveOwner);\r\n        collPrice = PriceFeed.lastGoodPrice();\r\n        TCRatio = TroveManager.getTCR(collPrice);\r\n        recoveryMode = TroveManager.checkRecoveryMode(collPrice);\r\n    }\r\n\r\n    function getInsertPosition(\r\n        uint256 _collAmount,\r\n        uint256 _debtAmount,\r\n        uint256 _numTrials,\r\n        uint256 _inputRandomSeed\r\n    ) external view returns (address upperHint, address lowerHint) {\r\n        uint256 NICR = _collAmount.mul(1e20).div(_debtAmount);\r\n        (address hintAddress, , ) = HintHelpers.getApproxHint(NICR, _numTrials, _inputRandomSeed);\r\n        (upperHint, lowerHint) = SortedTroves.findInsertPosition(NICR, hintAddress, hintAddress);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"BorrowerOperations\",\"outputs\":[{\"internalType\":\"contract IBorrowerOperations\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BorrowerOperationsAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HintHelpers\",\"outputs\":[{\"internalType\":\"contract IHintHelpers\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HintHelpersAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LUSDTokenAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PriceFeed\",\"outputs\":[{\"internalType\":\"contract IPriceFeed\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PriceFeedAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SortedTroves\",\"outputs\":[{\"internalType\":\"contract ISortedTroves\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SortedTrovesAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TroveManager\",\"outputs\":[{\"internalType\":\"contract ITroveManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TroveManagerAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_coll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"}],\"name\":\"computeNICR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ICR\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_prevId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nextId\",\"type\":\"address\"}],\"name\":\"findInsertPosition\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upperHint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lowerHint\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_CR\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numTrials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_inputRandomSeed\",\"type\":\"uint256\"}],\"name\":\"getApproxHint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"hintAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"diff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestRandomSeed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numTrials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_inputRandomSeed\",\"type\":\"uint256\"}],\"name\":\"getInsertPosition\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upperHint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lowerHint\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_troveOwner\",\"type\":\"address\"}],\"name\":\"getTroveInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"troveStatus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TCRatio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"recoveryMode\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRecoveryMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_troveOwner\",\"type\":\"address\"},{\"internalType\":\"enum LiquityView.LiquityActionId\",\"name\":\"_action\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lusdAmount\",\"type\":\"uint256\"}],\"name\":\"predictNICR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"NICR\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LiquityView","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://af94e7f7e264a8c162b245e1f64b395d92bdf9500d3c480902039ae381731ba0"}]}