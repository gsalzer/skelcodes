{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\ncontract MarketRegistry is Ownable {\r\n    \r\n    enum MarketType {Buy, Sell, Both}\r\n    enum CurrencySupported {Eth, Erc20}\r\n    \r\n    struct BuyDetails {\r\n        uint256 marketId;\r\n        bytes buyData;\r\n    }\r\n\r\n    struct SellDetails {\r\n        uint256 marketId;\r\n        bytes sellData;\r\n    }\r\n\r\n    struct Market {\r\n        MarketType marketType;\r\n        CurrencySupported currencySupported;\r\n        address proxy;\r\n        bool isActive;\r\n    }\r\n\r\n    Market[] public markets;\r\n\r\n    constructor(\r\n        MarketType[] memory marketTypes,\r\n        CurrencySupported[] memory currenciesSupported, \r\n        address[] memory proxies\r\n    ) {\r\n        for (uint256 i = 0; i < marketTypes.length; i++) {\r\n            markets.push(Market(marketTypes[i], currenciesSupported[i], proxies[i], true));    \r\n        }\r\n    }\r\n\r\n    function addMarket(\r\n        MarketType marketType, \r\n        CurrencySupported currencySupported, \r\n        address proxy\r\n    ) external onlyOwner {\r\n        markets.push(Market(marketType, currencySupported, proxy, true));\r\n    }\r\n\r\n    function setMarketStatus(uint256 marketId, bool newStatus) external onlyOwner {\r\n        Market storage market = markets[marketId];\r\n        market.isActive = newStatus;\r\n    }\r\n\r\n    function setMarketProxy(uint256 marketId, address newProxy) external onlyOwner {\r\n        Market storage market = markets[marketId];\r\n        market.proxy = newProxy;\r\n    }\r\n}\r\n\r\ncontract ExchangeRegistry is Ownable {\r\n    \r\n    struct SwapDetails {\r\n        uint256 exchangeId;\r\n        bytes swapData; \r\n    }\r\n\r\n    struct Exchange {\r\n        address proxy;\r\n        bool isActive;\r\n    }\r\n\r\n    Exchange[] public exchanges;\r\n\r\n    constructor(address[] memory proxies) {\r\n        for (uint256 i = 0; i < proxies.length; i++) {\r\n            exchanges.push(Exchange(proxies[i], true));\r\n        }\r\n    }\r\n\r\n    function addExchange(\r\n        address proxy\r\n    ) external onlyOwner {\r\n        exchanges.push(Exchange(proxy, true));\r\n    }\r\n\r\n    function setExchangeStatus(uint256 exchangeId, bool newStatus) external onlyOwner {\r\n        Exchange storage exchange = exchanges[exchangeId];\r\n        exchange.isActive = newStatus;\r\n    }\r\n\r\n    function setExchangeProxy(uint256 exchangeId, address newProxy) external onlyOwner {\r\n        Exchange storage exchange = exchanges[exchangeId];\r\n        exchange.proxy = newProxy;\r\n    }\r\n\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n        * @dev Returns the amount of tokens owned by `account`.\r\n        */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n        * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n        *\r\n        * Returns a boolean value indicating whether the operation succeeded.\r\n        *\r\n        * Emits a {Transfer} event.\r\n        */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC721 {\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;\r\n    \r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n    \r\n    function isApprovedForAll(address owner, address operator) external returns (bool);\r\n}\r\n\r\ninterface IERC1155 {\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external;\r\n}\r\n\r\ninterface ISellMarket {\r\n    function sellERC721ForERC20Equivalent(\r\n        bytes memory data\r\n    ) external returns (address _erc20Address, uint256 _erc20Amount);\r\n\r\n    function sellERC1155ForERC20Equivalent(\r\n        bytes memory data\r\n    ) external returns (address erc20, uint256 amount);\r\n\r\n    function sellERC1155BatchForERC20Equivalent(\r\n        bytes memory data\r\n    ) external returns (address erc20, uint256 amount);\r\n}\r\n\r\ninterface IBuyMarket {\r\n    function buyAssetsForEth(bytes memory data, address recipient) external;\r\n    function buyAssetsForErc20(bytes memory data, address recipient) external;\r\n    function estimateBatchAssetPriceInEth(bytes memory data) external view returns(uint256 totalCost);\r\n    function estimateBatchAssetPriceInErc20(bytes memory data) external view returns(address[] memory erc20Addrs, uint256[] memory amounts);\r\n}\r\n\r\ninterface IExchange {\r\n    function swapExactERC20ForERC20(\r\n        address _from,\r\n        address _to,\r\n        address _recipient,\r\n        uint256 _amountIn\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapERC20ForExactERC20(\r\n        address _from,\r\n        address _to,\r\n        address _recipient,\r\n        uint256 _amountOut\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapERC20ForExactETH(\r\n        address _from,\r\n        address _recipient,\r\n        uint256 _amountOut\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactERC20ForETH(\r\n        address _from,\r\n        address _recipient,\r\n        uint256 _amountIn\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapETHForExactERC20(\r\n        address _to,\r\n        address _recipient,\r\n        uint256 _amountOut\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForERC20(\r\n        address _to,\r\n        address _recipient,\r\n        uint256 _amountOutMin\r\n    ) external returns (uint256[] memory amounts);\r\n}\r\n\r\ncontract CrossAssetSwap is Ownable {\r\n\r\n    struct ERC20Details {\r\n        address[] tokenAddrs;\r\n        uint256[] amounts;\r\n    }\r\n\r\n    struct ERC721Details {\r\n        address tokenAddr;\r\n        uint256[] ids;\r\n        MarketRegistry.SellDetails[] sellDetails;\r\n    }\r\n\r\n    struct ERC1155Details {\r\n        address tokenAddr;\r\n        uint256[] ids;\r\n        uint256[] amounts;\r\n        MarketRegistry.SellDetails[] sellDetails;\r\n    }\r\n\r\n    MarketRegistry public marketRegistry;\r\n    ExchangeRegistry public exchangeRegistry;\r\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address public constant MAINTAINER = 0x073Ab1C0CAd3677cDe9BDb0cDEEDC2085c029579;\r\n    uint256 public FEES = 300;\r\n\r\n    constructor(address _marketRegistry, address _exchangeRegistry) {\r\n        marketRegistry = MarketRegistry(_marketRegistry);\r\n        exchangeRegistry = ExchangeRegistry(_exchangeRegistry);\r\n    }\r\n\r\n    function updateFees(uint256 newFees) external {\r\n        require(msg.sender == MAINTAINER, \"updateFees: invalid caller.\");\r\n        FEES = newFees;\r\n    }\r\n\r\n    function _transferHelper(\r\n        ERC20Details memory _inputERC20s,\r\n        ERC721Details[] memory inputERC721s,\r\n        ERC1155Details[] memory inputERC1155s\r\n    ) internal returns (address[] memory _erc20AddrsIn, uint256[] memory _erc20AmountsIn) {\r\n        address[] memory _addrsIn1;\r\n        address[] memory _addrsIn2; \r\n        uint256[] memory _amountsIn1;\r\n        uint256[] memory _amountsIn2;\r\n\r\n        // transfer ERC20 tokens from the sender to this contract\r\n        for (uint256 i = 0; i < _inputERC20s.tokenAddrs.length; i++) {\r\n            require(\r\n                IERC20(_inputERC20s.tokenAddrs[i]).transferFrom(\r\n                    msg.sender,\r\n                    address(this),\r\n                    _inputERC20s.amounts[i]\r\n                ),\r\n                \"_transferHelper: transfer failed\"\r\n            );\r\n        }\r\n        // transfer ERC721 tokens from the sender to this contract\r\n        for (uint256 i = 0; i < inputERC721s.length; i++) {\r\n            for (uint256 j = 0; j < inputERC721s[i].ids.length; j++) {\r\n                IERC721(inputERC721s[i].tokenAddr).transferFrom(\r\n                    msg.sender,\r\n                    address(this),\r\n                    inputERC721s[i].ids[j]\r\n                );\r\n            }\r\n            (_addrsIn1, _amountsIn1) = _sellNFT(inputERC721s[i].sellDetails);\r\n        }\r\n        // transfer ERC1155 tokens from the sender to this contract\r\n        for (uint256 i = 0; i < inputERC1155s.length; i++) {\r\n            IERC1155(inputERC1155s[i].tokenAddr).safeBatchTransferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                inputERC1155s[i].ids,\r\n                inputERC1155s[i].amounts,\r\n                \"\"\r\n            );\r\n            (_addrsIn2, _amountsIn2) = _sellNFT(inputERC1155s[i].sellDetails);\r\n        }\r\n        // return _erc20AddrsIn, _erc20AmountsIn\r\n        {\r\n            uint256 totalLen = msg.value > 0 \r\n            ? _inputERC20s.tokenAddrs.length+_addrsIn1.length+_addrsIn2.length+1\r\n            : _inputERC20s.tokenAddrs.length+_addrsIn1.length+_addrsIn2.length;\r\n            _erc20AddrsIn = new address[](totalLen);\r\n            _erc20AmountsIn = new uint256[](totalLen);\r\n            if (msg.value > 0) {\r\n                _erc20AddrsIn[totalLen-1] = ETH; \r\n                _erc20AmountsIn[totalLen-1] = msg.value;\r\n            }\r\n            // populate the arrays\r\n            for (uint256 i = 0; i < _inputERC20s.tokenAddrs.length; i++) {\r\n                _erc20AddrsIn[i] = _inputERC20s.tokenAddrs[i];\r\n                _erc20AmountsIn[i] = _inputERC20s.amounts[i];\r\n            }\r\n\r\n            totalLen = _inputERC20s.tokenAddrs.length-1;\r\n            for (uint256 i = 0; i < _addrsIn1.length; i++) {\r\n                _erc20AddrsIn[_inputERC20s.tokenAddrs.length+i] = _addrsIn1[i];\r\n                _erc20AmountsIn[_inputERC20s.tokenAddrs.length+i] = _amountsIn1[i];\r\n            }\r\n\r\n            totalLen = _inputERC20s.tokenAddrs.length+_addrsIn1.length-1;\r\n            for (uint256 i = 0; i < _addrsIn2.length; i++) {\r\n                _erc20AddrsIn[totalLen+i] = _addrsIn2[i];\r\n                _erc20AmountsIn[totalLen+i] = _amountsIn2[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    // swaps any combination of ERC-20/721/1155\r\n    // User needs to approve assets before invoking swap\r\n    function multiAssetSwap(\r\n        ERC20Details memory inputERC20s,\r\n        ERC721Details[] memory inputERC721s,\r\n        ERC1155Details[] memory inputERC1155s,\r\n        MarketRegistry.BuyDetails[] memory buyDetails,\r\n        ExchangeRegistry.SwapDetails[] memory swapDetails,\r\n        address[] memory addrs // [changeIn, exchange, recipient]\r\n    ) payable external {\r\n        address[] memory _erc20AddrsIn;\r\n        uint256[] memory _erc20AmountsIn;\r\n        \r\n        // transfer all tokens\r\n        (_erc20AddrsIn, _erc20AmountsIn) = _transferHelper(\r\n            inputERC20s,\r\n            inputERC721s,\r\n            inputERC1155s\r\n        );\r\n\r\n        // execute all swaps\r\n        _swap(\r\n            swapDetails,\r\n            buyDetails,\r\n            _erc20AmountsIn,\r\n            _erc20AddrsIn,\r\n            addrs[0],\r\n            addrs[1],\r\n            addrs[2]\r\n        );\r\n    }\r\n    event Data(ERC721Details[]);\r\n    function buyNftForERC20(\r\n        MarketRegistry.BuyDetails[] memory buyDetails,\r\n        ExchangeRegistry.SwapDetails[] memory swapDetails,\r\n        ERC20Details memory inputErc20Details,\r\n        address[] memory addrs // [changeIn, exchange, recipient]\r\n    ) external {\r\n        // transfer the fees\r\n        require(\r\n            IERC20(inputErc20Details.tokenAddrs[0]).transferFrom(msg.sender, MAINTAINER, FEES*inputErc20Details.amounts[0]/10000),\r\n            \"buyNftForERC20: fees transfer failed\"\r\n        );\r\n        // transfer the inputErc20 to the contract\r\n        require(\r\n            IERC20(inputErc20Details.tokenAddrs[0]).transferFrom(msg.sender, address(this), (10000-FEES)*inputErc20Details.amounts[0]/10000),\r\n            \"buyNftForERC20: transfer failed\"\r\n        );\r\n        // swap to desired assets if needed\r\n        for (uint256 i=0; i < swapDetails.length; i++) {\r\n            (address proxy, ) = exchangeRegistry.exchanges(swapDetails[i].exchangeId);\r\n            (bool success, ) = proxy.delegatecall(swapDetails[i].swapData);\r\n            require(success, \"buyNftForERC20: swap failed.\");\r\n        }\r\n\r\n        // buy NFTs\r\n        _buyNFT(buyDetails);\r\n\r\n        // Note: We know it as a fact that only input ERC20 can be the dust asset\r\n        // return remaining input ERC20\r\n        if(addrs[0] == inputErc20Details.tokenAddrs[0]) {\r\n            IERC20(inputErc20Details.tokenAddrs[0]).transfer(msg.sender, IERC20(inputErc20Details.tokenAddrs[0]).balanceOf(address(this)));\r\n        }\r\n        // return remaining ETH\r\n        else if(addrs[0] == ETH) {\r\n            (bool success, ) = addrs[1].delegatecall(abi.encodeWithSignature(\"swapExactERC20ForETH(address,address,uint256)\", inputErc20Details.tokenAddrs[0], addrs[2], IERC20(inputErc20Details.tokenAddrs[0]).balanceOf(address(this))));\r\n            require(success, \"buyNftForERC20: return failed.\");\r\n        }\r\n        // return remaining ERC20\r\n        else {\r\n            (bool success, ) = addrs[1].delegatecall(abi.encodeWithSignature(\"swapExactERC20ForERC20(address,address,address,uint256)\", inputErc20Details.tokenAddrs[0], addrs[0], addrs[2], IERC20(inputErc20Details.tokenAddrs[0]).balanceOf(address(this))));\r\n            require(success, \"buyNftForERC20: return failed.\");\r\n        }\r\n    }\r\n\r\n    function buyNftForEth(\r\n        MarketRegistry.BuyDetails[] memory buyDetails,\r\n        ExchangeRegistry.SwapDetails[] memory swapDetails,\r\n        address[] memory addrs // [changeIn, exchange, recipient]\r\n    ) external payable {\r\n        bool success;\r\n        (success, ) = MAINTAINER.call{value:FEES*address(this).balance/10000}('');\r\n        require(success, \"buyNftForEth: fees failed.\");\r\n\r\n        // swap to desired assets if needed\r\n        for (uint256 i=0; i < swapDetails.length; i++) {\r\n            (address proxy, ) = exchangeRegistry.exchanges(swapDetails[i].exchangeId);\r\n            (success, ) = proxy.delegatecall(swapDetails[i].swapData);\r\n            require(success, \"buyNftForEth: swap failed.\");\r\n        }\r\n\r\n        // buy NFT\r\n        _buyNFT(buyDetails);\r\n\r\n        // Note: We know it as a fact that only Eth can be the dust asset\r\n        // return remaining ETH\r\n        if(addrs[0] == ETH) {\r\n            (success, ) = msg.sender.call{value:address(this).balance}('');\r\n            require(success, \"buyNftForEth: return failed.\");\r\n        }\r\n        // return remaining ERC20\r\n        else {\r\n            (success, ) = addrs[1].delegatecall(abi.encodeWithSignature(\"swapExactETHForERC20(address,address,uint256)\", addrs[0], addrs[2], 0));\r\n            require(success, \"buyNftForEth: return failed.\");\r\n        }\r\n    }\r\n\r\n    function _sellNFT(\r\n        MarketRegistry.SellDetails[] memory _sellDetails\r\n    ) internal returns(address[] memory erc20Addrs, uint256[] memory erc20Amounts) {\r\n        erc20Addrs = new address[](_sellDetails.length);\r\n        erc20Amounts = new uint256[](_sellDetails.length);\r\n\r\n        // sell ERC1155 assets to respective markets\r\n        for (uint256 i = 0; i < _sellDetails.length; i++) {\r\n            // fetch the market details\r\n            (, , address _proxy, bool _isActive) = marketRegistry.markets(_sellDetails[i].marketId);\r\n            // the market should be active \r\n            require(_isActive, \"_sellNFT: InActive Market\");\r\n            // sell the specified asset\r\n            (bool success, bytes memory data) = _proxy.delegatecall(_sellDetails[i].sellData);\r\n            // check if the delegatecall passed successfully\r\n            require(success, \"_sellNFT: sell failed.\");\r\n            // populate return values            \r\n            (erc20Addrs[i], erc20Amounts[i]) = abi.decode(\r\n                data,\r\n                (address, uint256)\r\n            );\r\n        }\r\n    }\r\n\r\n    function _buyNFT(\r\n        MarketRegistry.BuyDetails[] memory _buyDetails\r\n    ) internal {\r\n        for (uint256 i = 0; i < _buyDetails.length; i++) {\r\n            // get market details\r\n            (, , address _proxy, bool _isActive) = marketRegistry.markets(_buyDetails[i].marketId);\r\n            // market should be active\r\n            require(_isActive, \"function: InActive Market\");\r\n            // buy NFT with ETH or ERC20\r\n            (bool success, ) = _proxy.delegatecall(_buyDetails[i].buyData);\r\n            // check if the delegatecall passed successfully\r\n            require(success, \"_buyNFT: buy failed.\");\r\n        }\r\n    }\r\n\r\n    function _returnChange(\r\n        address _changeIn,\r\n        address _erc20AddrIn,\r\n        address _recipient,\r\n        address _proxy,\r\n        uint256 _erc20AmountIn\r\n    ) internal {\r\n        bool success;\r\n        // in case desired changeIn is NOT the equivalent ERC20\r\n        if (_changeIn != _erc20AddrIn) {\r\n            // get market address\r\n            // (address proxy, ) = exchangeRegistry.exchanges(_exchangeId);\r\n            // in case input asset is ETH\r\n            if(_erc20AddrIn == ETH) {\r\n                (success, ) = _proxy.delegatecall(abi.encodeWithSignature(\"swapExactETHForERC20(address,address,uint256)\", _changeIn, _recipient, 0));\r\n                require(success, \"_returnChange: return failed.\");\r\n            }\r\n            // in case changeIn is ETH\r\n            else if(_changeIn == ETH) {\r\n                // Convert all the _erc20Amount to _changeIn ERC20\r\n                (success, ) = _proxy.delegatecall(abi.encodeWithSignature(\"swapExactERC20ForETH(address,address,uint256)\", _erc20AddrIn, _recipient, _erc20AmountIn));\r\n                require(success, \"_returnChange: return failed.\");\r\n            }\r\n            // in case changeIn is some other ERC20\r\n            else {\r\n                // execute exchange\r\n                (success, ) = _proxy.delegatecall(abi.encodeWithSignature(\"swapExactERC20ForERC20(address,address,address,uint256)\", _erc20AddrIn, _changeIn, _recipient, _erc20AmountIn));\r\n                require(success, \"_returnChange: return failed.\");\r\n            }\r\n        }\r\n        // in case desired changeIn is the equivalent ERC20\r\n        else {\r\n            IERC20(_changeIn).transfer(_recipient, _erc20AmountIn);\r\n        }\r\n    }\r\n\r\n    function _swap(\r\n        ExchangeRegistry.SwapDetails[] memory _swapDetails,\r\n        MarketRegistry.BuyDetails[] memory _buyDetails,\r\n        uint256[] memory _erc20AmountsIn,\r\n        address[] memory _erc20AddrsIn,\r\n        address _changeIn,\r\n        address _exchange,\r\n        address _recipient\r\n    ) internal {\r\n        bool success;\r\n        // in case user does NOT want to buy any NFTs \r\n        if(_buyDetails.length == 0) {\r\n            for(uint256 i = 0; i < _erc20AddrsIn.length; i++) {\r\n                _returnChange(\r\n                    _changeIn,\r\n                    _erc20AddrsIn[i],\r\n                    _recipient,\r\n                    _exchange,\r\n                    _erc20AmountsIn[i]\r\n                );\r\n            }\r\n        }\r\n        // in case user wants to buy NFTs\r\n        else {\r\n            for (uint256 i = 0; i < _swapDetails.length; i++) {\r\n                // get market address\r\n                (address proxy, ) = exchangeRegistry.exchanges(_swapDetails[i].exchangeId);\r\n                // execute swap \r\n                (success, ) = proxy.delegatecall(_swapDetails[i].swapData);\r\n                require(success, \"_swap: swap failed.\");\r\n            }\r\n\r\n            // buy the NFTs\r\n            _buyNFT(_buyDetails);\r\n\r\n            // return remaining amount to the user\r\n            for (uint256 i = 0; i < _erc20AddrsIn.length; i++) {\r\n                _returnChange(\r\n                    _changeIn,\r\n                    _erc20AddrsIn[i],\r\n                    _recipient,\r\n                    _exchange,\r\n                    _erc20AddrsIn[i] == ETH \r\n                        ? address(this).balance\r\n                        : IERC20(_erc20AddrsIn[i]).balanceOf(address(this))\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function _executeSingleTrxSwap(\r\n        bytes memory _data,\r\n        address _from\r\n    ) internal {\r\n        // decode the trade details\r\n        MarketRegistry.SellDetails[] memory _sellDetails;\r\n        ExchangeRegistry.SwapDetails[] memory _swapDetails;\r\n        MarketRegistry.BuyDetails[] memory _buyDetails;\r\n        address[] memory addrs; // [changeIn, exchange, recipient]\r\n\r\n        (_sellDetails, _swapDetails, _buyDetails, addrs) = abi.decode(\r\n            _data,\r\n            (MarketRegistry.SellDetails[], ExchangeRegistry.SwapDetails[], MarketRegistry.BuyDetails[], address[])\r\n        );\r\n\r\n        // _sellDetails should not be empty\r\n        require(_sellDetails.length > 0, \"_executeSingleTrxSwap: no sell details\");\r\n\r\n        // if recipient is zero address, then set _from as recipient\r\n        if(addrs[2] == address(0)) {\r\n            addrs[2] = _from;\r\n        }\r\n\r\n        // sell input assets\r\n        (address[] memory _erc20AddrsIn, uint256[] memory _erc20AmountsIn) = _sellNFT(_sellDetails);\r\n        \r\n        // swap ERC20 equivalents to desired intermediate assets\r\n        _swap(_swapDetails, _buyDetails, _erc20AmountsIn, _erc20AddrsIn, addrs[0], addrs[1], addrs[2]);\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes calldata\r\n    ) public virtual returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address _from,\r\n        uint256[] calldata,\r\n        uint256[] calldata,\r\n        bytes calldata _data\r\n    ) public virtual returns (bytes4) {\r\n        // return with function selector if data is empty\r\n        if(keccak256(abi.encodePacked((_data))) == keccak256(abi.encodePacked((\"\")))) {\r\n            return this.onERC1155BatchReceived.selector;\r\n        }\r\n        \r\n        // execute single transaction swap\r\n        _executeSingleTrxSwap(_data, _from);\r\n\r\n        // return the function selector\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n\r\n    function onERC721Received(\r\n        address,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) external virtual returns (bytes4) {\r\n        // return with function selector if data is empty        \r\n        if(keccak256(abi.encodePacked((_data))) == keccak256(abi.encodePacked((\"\")))) {\r\n            return this.onERC721Received.selector;\r\n        }\r\n\r\n        // execute single transaction swap\r\n        _executeSingleTrxSwap(_data, _from);\r\n\r\n        return this.onERC721Received.selector;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        external\r\n        virtual\r\n        view\r\n        returns (bool)\r\n    {\r\n        return interfaceId == this.supportsInterface.selector;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    // Emergency function: In case any ERC20 tokens get stuck in the contract unintentionally\r\n    // Only owner can retrieve the asset balance to a recipient address\r\n    function rescueERC20(address asset, address recipient) onlyOwner external returns(uint256 amountRescued) {\r\n        amountRescued = IERC20(asset).balanceOf(address(this)); \r\n        IERC20(asset).transfer(recipient, amountRescued);\r\n    }\r\n\r\n    // Emergency function: In case any ERC721 tokens get stuck in the contract unintentionally\r\n    // Only owner can retrieve the asset balance to a recipient address\r\n    function rescueERC721(address asset, uint256[] calldata ids, address recipient) onlyOwner external {\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            IERC721(asset).transferFrom(address(this), recipient, ids[i]);\r\n        }\r\n    }\r\n\r\n    // Emergency function: In case any ERC1155 tokens get stuck in the contract unintentionally\r\n    // Only owner can retrieve the asset balance to a recipient address\r\n    function rescueERC1155(address asset, uint256[] calldata ids, uint256[] calldata amounts, address recipient) onlyOwner external {\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            IERC1155(asset).safeTransferFrom(address(this), recipient, ids[i], amounts[i], \"\");\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exchangeRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sellData\",\"type\":\"bytes\"}],\"internalType\":\"struct MarketRegistry.SellDetails[]\",\"name\":\"sellDetails\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct CrossAssetSwap.ERC721Details[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"name\":\"Data\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAINTAINER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"buyData\",\"type\":\"bytes\"}],\"internalType\":\"struct MarketRegistry.BuyDetails[]\",\"name\":\"buyDetails\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"exchangeId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeRegistry.SwapDetails[]\",\"name\":\"swapDetails\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct CrossAssetSwap.ERC20Details\",\"name\":\"inputErc20Details\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"buyNftForERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"buyData\",\"type\":\"bytes\"}],\"internalType\":\"struct MarketRegistry.BuyDetails[]\",\"name\":\"buyDetails\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"exchangeId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeRegistry.SwapDetails[]\",\"name\":\"swapDetails\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"buyNftForEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRegistry\",\"outputs\":[{\"internalType\":\"contract ExchangeRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketRegistry\",\"outputs\":[{\"internalType\":\"contract MarketRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct CrossAssetSwap.ERC20Details\",\"name\":\"inputERC20s\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sellData\",\"type\":\"bytes\"}],\"internalType\":\"struct MarketRegistry.SellDetails[]\",\"name\":\"sellDetails\",\"type\":\"tuple[]\"}],\"internalType\":\"struct CrossAssetSwap.ERC721Details[]\",\"name\":\"inputERC721s\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sellData\",\"type\":\"bytes\"}],\"internalType\":\"struct MarketRegistry.SellDetails[]\",\"name\":\"sellDetails\",\"type\":\"tuple[]\"}],\"internalType\":\"struct CrossAssetSwap.ERC1155Details[]\",\"name\":\"inputERC1155s\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"buyData\",\"type\":\"bytes\"}],\"internalType\":\"struct MarketRegistry.BuyDetails[]\",\"name\":\"buyDetails\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"exchangeId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeRegistry.SwapDetails[]\",\"name\":\"swapDetails\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"multiAssetSwap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"rescueERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"rescueERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountRescued\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"rescueERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFees\",\"type\":\"uint256\"}],\"name\":\"updateFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"CrossAssetSwap","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006f33234a79a8a7917766a58166361f92dd5b80e900000000000000000000000052b2e2c4c6cf654f7097d6ceb10142b4c057df80","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://58155467ed651020d1f8c07012ccbc9978eba79dd5a5f5d2da3f60329adb57fa"}]}