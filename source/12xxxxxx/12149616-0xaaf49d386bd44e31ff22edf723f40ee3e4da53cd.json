{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n ___ _ _    _    _ _      \r\n| _ (_) |__| |__(_) |_ ___\r\n|   / | '_ \\ '_ \\ |  _(_-<\r\n|_|_\\_|_.__/_.__/_|\\__/__/\r\nA unique set of 1,000 collectable and tradable frog themed NFTs.\r\n\r\nWebsite: https://ribbits.xyz/\r\nCreated by sol_dev\r\n\r\n*/\r\npragma solidity ^0.5.17;\r\n\r\ninterface Receiver {\r\n\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\r\n}\r\n\r\ninterface Callable {\r\n\tfunction tokenCallback(address _from, uint256 _tokens, bytes calldata _data) external returns (bool);\r\n}\r\n\r\ninterface Router {\r\n\tfunction WETH() external pure returns (address);\r\n\tfunction factory() external pure returns (address);\r\n}\r\n\r\ninterface Factory {\r\n\tfunction createPair(address, address) external returns (address);\r\n}\r\n\r\ninterface Pair {\r\n\tfunction token0() external view returns (address);\r\n\tfunction totalSupply() external view returns (uint256);\r\n\tfunction balanceOf(address) external view returns (uint256);\r\n\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\ncontract Metadata {\r\n\tstring public name = \"Ribbits\";\r\n\tstring public symbol = \"RBT\";\r\n\tfunction contractURI() external pure returns (string memory) {\r\n\t\treturn \"https://api.ribbits.xyz/metadata\";\r\n\t}\r\n\tfunction baseTokenURI() public pure returns (string memory) {\r\n\t\treturn \"https://api.ribbits.xyz/ribbit/metadata/\";\r\n\t}\r\n\tfunction tokenURI(uint256 _tokenId) external pure returns (string memory) {\r\n\t\tbytes memory _base = bytes(baseTokenURI());\r\n\t\tuint256 _digits = 1;\r\n\t\tuint256 _n = _tokenId;\r\n\t\twhile (_n > 9) {\r\n\t\t\t_n /= 10;\r\n\t\t\t_digits++;\r\n\t\t}\r\n\t\tbytes memory _uri = new bytes(_base.length + _digits);\r\n\t\tfor (uint256 i = 0; i < _uri.length; i++) {\r\n\t\t\tif (i < _base.length) {\r\n\t\t\t\t_uri[i] = _base[i];\r\n\t\t\t} else {\r\n\t\t\t\tuint256 _dec = (_tokenId / (10**(_uri.length - i - 1))) % 10;\r\n\t\t\t\t_uri[i] = byte(uint8(_dec) + 48);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn string(_uri);\r\n\t}\r\n}\r\n\r\ncontract WrappedRibbits {\r\n\r\n\tuint256 constant private UINT_MAX = uint256(-1);\r\n\r\n\tstring constant public name = \"Wrapped Ribbits\";\r\n\tstring constant public symbol = \"wRBT\";\r\n\tuint8 constant public decimals = 18;\r\n\r\n\tstruct User {\r\n\t\tuint256 balance;\r\n\t\tmapping(address => uint256) allowance;\r\n\t}\r\n\r\n\tstruct Info {\r\n\t\tuint256 totalSupply;\r\n\t\tmapping(address => User) users;\r\n\t\tRouter router;\r\n\t\tPair pair;\r\n\t\tRibbits ribbits;\r\n\t\tbool weth0;\r\n\t}\r\n\tInfo private info;\r\n\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 tokens);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 tokens);\r\n\r\n\r\n\tconstructor(Ribbits _ribbits) public {\r\n\t\tinfo.router = Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n\t\tinfo.pair = Pair(Factory(info.router.factory()).createPair(info.router.WETH(), address(this)));\r\n\t\tinfo.weth0 = info.pair.token0() == info.router.WETH();\r\n\t\tinfo.ribbits = _ribbits;\r\n\t}\r\n\r\n\tfunction wrap(uint256[] calldata _tokenIds) external {\r\n\t\tuint256 _count = _tokenIds.length;\r\n\t\trequire(_count > 0);\r\n\t\tfor (uint256 i = 0; i < _count; i++) {\r\n\t\t\tinfo.ribbits.transferFrom(msg.sender, address(this), _tokenIds[i]);\r\n\t\t}\r\n\t\tuint256 _amount = _count * 1e18;\r\n\t\tinfo.totalSupply += _amount;\r\n\t\tinfo.users[msg.sender].balance += _amount;\r\n\t\temit Transfer(address(0x0), msg.sender, _amount);\r\n\t}\r\n\r\n\tfunction unwrap(uint256[] calldata _tokenIds) external returns (uint256 totalUnwrapped) {\r\n\t\tuint256 _count = _tokenIds.length;\r\n\t\trequire(balanceOf(msg.sender) >= _count * 1e18);\r\n\t\ttotalUnwrapped = 0;\r\n\t\tfor (uint256 i = 0; i < _count; i++) {\r\n\t\t\tif (info.ribbits.ownerOf(_tokenIds[i]) == address(this)) {\r\n\t\t\t\tinfo.ribbits.transferFrom(address(this), msg.sender, _tokenIds[i]);\r\n\t\t\t\ttotalUnwrapped++;\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(totalUnwrapped > 0);\r\n\t\tuint256 _cost = totalUnwrapped * 1e18;\r\n\t\tinfo.totalSupply -= _cost;\r\n\t\tinfo.users[msg.sender].balance -= _cost;\r\n\t\temit Transfer(msg.sender, address(0x0), _cost);\r\n\t}\r\n\r\n\tfunction transfer(address _to, uint256 _tokens) external returns (bool) {\r\n\t\treturn _transfer(msg.sender, _to, _tokens);\r\n\t}\r\n\r\n\tfunction approve(address _spender, uint256 _tokens) external returns (bool) {\r\n\t\tinfo.users[msg.sender].allowance[_spender] = _tokens;\r\n\t\temit Approval(msg.sender, _spender, _tokens);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _tokens) external returns (bool) {\r\n\t\tuint256 _allowance = allowance(_from, msg.sender);\r\n\t\trequire(_allowance >= _tokens);\r\n\t\tif (_allowance != UINT_MAX) {\r\n\t\t\tinfo.users[_from].allowance[msg.sender] -= _tokens;\r\n\t\t}\r\n\t\treturn _transfer(_from, _to, _tokens);\r\n\t}\r\n\r\n\tfunction transferAndCall(address _to, uint256 _tokens, bytes calldata _data) external returns (bool) {\r\n\t\t_transfer(msg.sender, _to, _tokens);\r\n\t\tuint32 _size;\r\n\t\tassembly {\r\n\t\t\t_size := extcodesize(_to)\r\n\t\t}\r\n\t\tif (_size > 0) {\r\n\t\t\trequire(Callable(_to).tokenCallback(msg.sender, _tokens, _data));\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\r\n\tfunction totalSupply() public view returns (uint256) {\r\n\t\treturn info.totalSupply;\r\n\t}\r\n\r\n\tfunction balanceOf(address _user) public view returns (uint256) {\r\n\t\treturn info.users[_user].balance;\r\n\t}\r\n\r\n\tfunction allowance(address _user, address _spender) public view returns (uint256) {\r\n\t\treturn info.users[_user].allowance[_spender];\r\n\t}\r\n\r\n\tfunction allInfoFor(address _user) external view returns (uint256 totalTokens, uint256 totalLPTokens, uint256 wethReserve, uint256 wrbtReserve, uint256 userRibbits, bool userApproved, uint256 userBalance, uint256 userLPBalance) {\r\n\t\ttotalTokens = totalSupply();\r\n\t\ttotalLPTokens = info.pair.totalSupply();\r\n\t\t(uint256 _res0, uint256 _res1, ) = info.pair.getReserves();\r\n\t\twethReserve = info.weth0 ? _res0 : _res1;\r\n\t\twrbtReserve = info.weth0 ? _res1 : _res0;\r\n\t\tuserRibbits = info.ribbits.balanceOf(_user);\r\n\t\tuserApproved = info.ribbits.isApprovedForAll(_user, address(this));\r\n\t\tuserBalance = balanceOf(_user);\r\n\t\tuserLPBalance = info.pair.balanceOf(_user);\r\n\t}\r\n\r\n\r\n\tfunction _transfer(address _from, address _to, uint256 _tokens) internal returns (bool) {\r\n\t\trequire(balanceOf(_from) >= _tokens);\r\n\t\tinfo.users[_from].balance -= _tokens;\r\n\t\tinfo.users[_to].balance += _tokens;\r\n\t\temit Transfer(_from, _to, _tokens);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\ncontract Ribbits {\r\n\r\n\tuint256 constant private MAX_NAME_LENGTH = 32;\r\n\tuint256 constant private TOTAL_RIBBITS = 1000;\r\n\tuint256 constant private CLAIM_COST = 0.1 ether;\r\n\r\n\tstruct User {\r\n\t\tuint256[] list;\r\n\t\tmapping(address => bool) approved;\r\n\t\tmapping(uint256 => uint256) indexOf;\r\n\t}\r\n\r\n\tstruct Ribbit {\r\n\t\tbool claimed;\r\n\t\taddress owner;\r\n\t\taddress approved;\r\n\t\tstring name;\r\n\t}\r\n\r\n\tstruct Info {\r\n\t\tmapping(uint256 => Ribbit) list;\r\n\t\tmapping(address => User) users;\r\n\t\tMetadata metadata;\r\n\t\taddress owner;\r\n\t}\r\n\tInfo private info;\r\n\r\n\tmapping(bytes4 => bool) public supportsInterface;\r\n\r\n\tstring constant public compositeHash = \"11df1dfb29760fdf721b68137825ebbf350a69f92ac50a922088f0240e62e0d3\";\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n\tevent Rename(address indexed owner, uint256 indexed tokenId, string name);\r\n\r\n\r\n\tconstructor() public {\r\n\t\tinfo.metadata = new Metadata();\r\n\t\tinfo.owner = msg.sender;\r\n\t\tsupportsInterface[0x01ffc9a7] = true; // ERC-165\r\n\t\tsupportsInterface[0x80ac58cd] = true; // ERC-721\r\n\t\tsupportsInterface[0x5b5e139f] = true; // Metadata\r\n\t\tsupportsInterface[0x780e9d63] = true; // Enumerable\r\n\r\n\t\t// Initial Claims\r\n\t\taddress _receiver = msg.sender;\r\n\t\t_claim(77,  _receiver);\r\n\t\t_claim(114, _receiver);\r\n\t\t_claim(168, _receiver);\r\n\t\t_claim(172, _receiver);\r\n\t\t_claim(173, _receiver);\r\n\t\t_claim(210, _receiver);\r\n\t\t_claim(275, _receiver);\r\n\t\t_claim(285, _receiver);\r\n\t\t_claim(595, _receiver);\r\n\t\t_claim(726, _receiver);\r\n\r\n\t\t_receiver = 0xcb4BfcF57aee5e8ad825Cde1012fEe1cC62d8e4c;\r\n\t\t_claim(368, _receiver);\r\n\t\t_claim(737, _receiver);\r\n\t\t_claim(751, _receiver);\r\n\t\t_claim(895, _receiver);\r\n\t\t_claim(49,  _receiver);\r\n\t\t_claim(242, _receiver);\r\n\t\t_claim(391, _receiver);\r\n\r\n\t\t_receiver = 0x8F83Eb7ABb2bCf57347298d9BF09A2d284190643;\r\n\t\t_claim(534, _receiver);\r\n\t\t_claim(729, _receiver);\r\n\t\t_claim(35,  _receiver);\r\n\t\t_claim(55,  _receiver);\r\n\t\t_claim(68,  _receiver);\r\n\t\t_claim(621, _receiver);\r\n\t\t_claim(796, _receiver);\r\n\t\t_claim(971, _receiver);\r\n\t\t_claim(167, _receiver);\r\n\t\t_claim(152, _receiver);\r\n\t\t_claim(202, _receiver);\r\n\t\t_claim(205, _receiver);\r\n\t\t_claim(221, _receiver);\r\n\t\t_claim(283, _receiver);\r\n\t\t_claim(299, _receiver);\r\n\t\t_claim(309, _receiver);\r\n\t\t_claim(325, _receiver);\r\n\t\t_claim(341, _receiver);\r\n\t\t_claim(367, _receiver);\r\n\t\t_claim(393, _receiver);\r\n\t\t_claim(405, _receiver);\r\n\t\t_claim(452, _receiver);\r\n\t\t_claim(485, _receiver);\r\n\t\t_claim(507, _receiver);\r\n\t\t_claim(526, _receiver);\r\n\t\t_claim(542, _receiver);\r\n\t\t_claim(609, _receiver);\r\n\t\t_claim(723, _receiver);\r\n\t\t_claim(500, _receiver);\r\n\t\t_claim(16,  _receiver);\r\n\t\t_claim(46,  _receiver);\r\n\t\t_claim(79,  _receiver);\r\n\r\n\t\t_claim(822, 0xACE5BeedDDc24dec659eeEcb21A3C21F5576e3C9);\r\n\t\t_claim(934, 0xface14522b18BE412e9DB0E1570Be94Cb9af0A88);\r\n\t\t_claim(894, 0xFADE7bB65A1e06D11B3F099b225ddC7C8Ae65967);\r\n\t\t_claim(946, 0xC0015CfE8C0e00423E2D84853E5A9052EdcdF8b2);\r\n\t\t_claim(957, 0xce1179C2e69edBaCaB52485a75C0Ae4a979b0919);\r\n\t\t_claim(712, 0xea5e37c75383331a1de5b7f7f1a93Ef080b319Be);\r\n\t\t_claim(539, 0xD1CEbD1Ad772c8A6dD05eCdFA0ae776a9266032c);\r\n\t\t_claim(549, 0xFEED4873Ab0D642dD4b694EdA6FF90cD732fE4C9);\r\n\t\t_claim(364, 0xCafe59428b2946FBc128fd6C36cb1Ec1443AeD6C);\r\n\t\t_claim(166, 0xb01d89cb608b46a9EB697ee11e2df6313BCbEb20);\r\n\t\t_claim(547, 0x1eadc5E9A94e61BFe4819274aBBEE1e23805bA38);\r\n\t\t_claim(515, 0xF01D2ba4F31161Bb89e7Ab3cf443AaA38426dC65);\r\n\t\t_claim(612, 0xF00Da17Fd777Bf2ae536816C016fF1593F9CDDC3);\r\n\t}\r\n\r\n\tfunction setOwner(address _owner) external {\r\n\t\trequire(msg.sender == info.owner);\r\n\t\tinfo.owner = _owner;\r\n\t}\r\n\r\n\tfunction setMetadata(Metadata _metadata) external {\r\n\t\trequire(msg.sender == info.owner);\r\n\t\tinfo.metadata = _metadata;\r\n\t}\r\n\r\n\tfunction ownerWithdraw() external {\r\n\t\trequire(msg.sender == info.owner);\r\n\t\tuint256 _balance = address(this).balance;\r\n\t\trequire(_balance > 0);\r\n\t\tmsg.sender.transfer(_balance);\r\n\t}\r\n\r\n\r\n\tfunction claim(uint256 _tokenId) external payable {\r\n\t\tclaimFor(_tokenId, msg.sender);\r\n\t}\r\n\r\n\tfunction claimFor(uint256 _tokenId, address _receiver) public payable {\r\n\t\tuint256[] memory _tokenIds = new uint256[](1);\r\n\t\taddress[] memory _receivers = new address[](1);\r\n\t\t_tokenIds[0] = _tokenId;\r\n\t\t_receivers[0] = _receiver;\r\n\t\tclaimManyFor(_tokenIds, _receivers);\r\n\t}\r\n\r\n\tfunction claimMany(uint256[] calldata _tokenIds) external payable returns (uint256) {\r\n\t\tuint256 _count = _tokenIds.length;\r\n\t\taddress[] memory _receivers = new address[](_count);\r\n\t\tfor (uint256 i = 0; i < _count; i++) {\r\n\t\t\t_receivers[i] = msg.sender;\r\n\t\t}\r\n\t\treturn claimManyFor(_tokenIds, _receivers);\r\n\t}\r\n\r\n\tfunction claimManyFor(uint256[] memory _tokenIds, address[] memory _receivers) public payable returns (uint256 totalClaimed) {\r\n\t\tuint256 _count = _tokenIds.length;\r\n\t\trequire(_count > 0 && _count == _receivers.length);\r\n\t\trequire(msg.value >= CLAIM_COST * _count);\r\n\t\ttotalClaimed = 0;\r\n\t\tfor (uint256 i = 0; i < _count; i++) {\r\n\t\t\tif (!getClaimed(_tokenIds[i])) {\r\n\t\t\t\t_claim(_tokenIds[i], _receivers[i]);\r\n\t\t\t\ttotalClaimed++;\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(totalClaimed > 0);\r\n\t\tuint256 _cost = CLAIM_COST * totalClaimed;\r\n\t\tif (msg.value > _cost) {\r\n\t\t\tmsg.sender.transfer(msg.value - _cost);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction rename(uint256 _tokenId, string calldata _newName) external {\r\n\t\trequire(bytes(_newName).length <= MAX_NAME_LENGTH);\r\n\t\trequire(msg.sender == ownerOf(_tokenId));\r\n\t\tinfo.list[_tokenId].name = _newName;\r\n\t\temit Rename(msg.sender, _tokenId, _newName);\r\n\t}\r\n\r\n\tfunction approve(address _approved, uint256 _tokenId) external {\r\n\t\trequire(msg.sender == ownerOf(_tokenId));\r\n\t\tinfo.list[_tokenId].approved = _approved;\r\n\t\temit Approval(msg.sender, _approved, _tokenId);\r\n\t}\r\n\r\n\tfunction setApprovalForAll(address _operator, bool _approved) external {\r\n\t\tinfo.users[msg.sender].approved[_operator] = _approved;\r\n\t\temit ApprovalForAll(msg.sender, _operator, _approved);\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external {\r\n\t\t_transfer(_from, _to, _tokenId);\r\n\t}\r\n\r\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n\t\tsafeTransferFrom(_from, _to, _tokenId, \"\");\r\n\t}\r\n\r\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public {\r\n\t\t_transfer(_from, _to, _tokenId);\r\n\t\tuint32 _size;\r\n\t\tassembly {\r\n\t\t\t_size := extcodesize(_to)\r\n\t\t}\r\n\t\tif (_size > 0) {\r\n\t\t\trequire(Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) == 0x150b7a02);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction name() external view returns (string memory) {\r\n\t\treturn info.metadata.name();\r\n\t}\r\n\r\n\tfunction symbol() external view returns (string memory) {\r\n\t\treturn info.metadata.symbol();\r\n\t}\r\n\r\n\tfunction contractURI() external view returns (string memory) {\r\n\t\treturn info.metadata.contractURI();\r\n\t}\r\n\r\n\tfunction baseTokenURI() external view returns (string memory) {\r\n\t\treturn info.metadata.baseTokenURI();\r\n\t}\r\n\r\n\tfunction tokenURI(uint256 _tokenId) external view returns (string memory) {\r\n\t\treturn info.metadata.tokenURI(_tokenId);\r\n\t}\r\n\r\n\tfunction owner() public view returns (address) {\r\n\t\treturn info.owner;\r\n\t}\r\n\r\n\tfunction totalSupply() public pure returns (uint256) {\r\n\t\treturn TOTAL_RIBBITS;\r\n\t}\r\n\r\n\tfunction balanceOf(address _owner) public view returns (uint256) {\r\n\t\treturn info.users[_owner].list.length;\r\n\t}\r\n\r\n\tfunction ownerOf(uint256 _tokenId) public view returns (address) {\r\n\t\trequire(_tokenId < totalSupply());\r\n\t\treturn info.list[_tokenId].owner;\r\n\t}\r\n\r\n\tfunction getApproved(uint256 _tokenId) public view returns (address) {\r\n\t\trequire(_tokenId < totalSupply());\r\n\t\treturn info.list[_tokenId].approved;\r\n\t}\r\n\r\n\tfunction isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n\t\treturn info.users[_owner].approved[_operator];\r\n\t}\r\n\r\n\tfunction getName(uint256 _tokenId) public view returns (string memory) {\r\n\t\trequire(_tokenId < totalSupply());\r\n\t\treturn info.list[_tokenId].name;\r\n\t}\r\n\r\n\tfunction getClaimed(uint256 _tokenId) public view returns (bool) {\r\n\t\trequire(_tokenId < totalSupply());\r\n\t\treturn info.list[_tokenId].claimed;\r\n\t}\r\n\r\n\tfunction tokenByIndex(uint256 _index) external pure returns (uint256) {\r\n\t\trequire(_index < totalSupply());\r\n\t\treturn _index;\r\n\t}\r\n\r\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\r\n\t\trequire(_index < balanceOf(_owner));\r\n\t\treturn info.users[_owner].list[_index];\r\n\t}\r\n\r\n\tfunction getRibbit(uint256 _tokenId) public view returns (address tokenOwner, address approved, string memory tokenName, bool claimed) {\r\n\t\treturn (ownerOf(_tokenId), getApproved(_tokenId), getName(_tokenId), getClaimed(_tokenId));\r\n\t}\r\n\r\n\tfunction getRibbits(uint256[] memory _tokenIds) public view returns (address[] memory owners, address[] memory approveds, bool[] memory claimeds) {\r\n\t\tuint256 _length = _tokenIds.length;\r\n\t\towners = new address[](_length);\r\n\t\tapproveds = new address[](_length);\r\n\t\tclaimeds = new bool[](_length);\r\n\t\tfor (uint256 i = 0; i < _length; i++) {\r\n\t\t\t(owners[i], approveds[i], , claimeds[i]) = getRibbit(_tokenIds[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getRibbitsTable(uint256 _limit, uint256 _page, bool _isAsc) public view returns (uint256[] memory tokenIds, address[] memory owners, address[] memory approveds, bool[] memory claimeds, uint256 totalRibbits, uint256 totalPages) {\r\n\t\trequire(_limit > 0);\r\n\t\ttotalRibbits = totalSupply();\r\n\r\n\t\tif (totalRibbits > 0) {\r\n\t\t\ttotalPages = (totalRibbits / _limit) + (totalRibbits % _limit == 0 ? 0 : 1);\r\n\t\t\trequire(_page < totalPages);\r\n\r\n\t\t\tuint256 _offset = _limit * _page;\r\n\t\t\tif (_page == totalPages - 1 && totalRibbits % _limit != 0) {\r\n\t\t\t\t_limit = totalRibbits % _limit;\r\n\t\t\t}\r\n\r\n\t\t\ttokenIds = new uint256[](_limit);\r\n\t\t\tfor (uint256 i = 0; i < _limit; i++) {\r\n\t\t\t\ttokenIds[i] = (_isAsc ? _offset + i : totalRibbits - _offset - i - 1);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttotalPages = 0;\r\n\t\t\ttokenIds = new uint256[](0);\r\n\t\t}\r\n\t\t(owners, approveds, claimeds) = getRibbits(tokenIds);\r\n\t}\r\n\r\n\tfunction getOwnerRibbitsTable(address _owner, uint256 _limit, uint256 _page, bool _isAsc) public view returns (uint256[] memory tokenIds, address[] memory approveds, uint256 totalRibbits, uint256 totalPages) {\r\n\t\trequire(_limit > 0);\r\n\t\ttotalRibbits = balanceOf(_owner);\r\n\r\n\t\tif (totalRibbits > 0) {\r\n\t\t\ttotalPages = (totalRibbits / _limit) + (totalRibbits % _limit == 0 ? 0 : 1);\r\n\t\t\trequire(_page < totalPages);\r\n\r\n\t\t\tuint256 _offset = _limit * _page;\r\n\t\t\tif (_page == totalPages - 1 && totalRibbits % _limit != 0) {\r\n\t\t\t\t_limit = totalRibbits % _limit;\r\n\t\t\t}\r\n\r\n\t\t\ttokenIds = new uint256[](_limit);\r\n\t\t\tfor (uint256 i = 0; i < _limit; i++) {\r\n\t\t\t\ttokenIds[i] = tokenOfOwnerByIndex(_owner, _isAsc ? _offset + i : totalRibbits - _offset - i - 1);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttotalPages = 0;\r\n\t\t\ttokenIds = new uint256[](0);\r\n\t\t}\r\n\t\t( , approveds, ) = getRibbits(tokenIds);\r\n\t}\r\n\r\n\tfunction allClaimeds() external view returns (bool[] memory claimeds) {\r\n\t\tuint256 _length = totalSupply();\r\n\t\tclaimeds = new bool[](_length);\r\n\t\tfor (uint256 i = 0; i < _length; i++) {\r\n\t\t\tclaimeds[i] = getClaimed(i);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction allInfoFor(address _owner) external view returns (uint256 supply, uint256 ownerBalance) {\r\n\t\treturn (totalSupply(), balanceOf(_owner));\r\n\t}\r\n\r\n\r\n\tfunction _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n\t\t(address _owner, address _approved, , ) = getRibbit(_tokenId);\r\n\t\trequire(_from == _owner);\r\n\t\trequire(msg.sender == _owner || msg.sender == _approved || isApprovedForAll(_owner, msg.sender));\r\n\r\n\t\tinfo.list[_tokenId].owner = _to;\r\n\t\tif (_approved != address(0x0)) {\r\n\t\t\tinfo.list[_tokenId].approved = address(0x0);\r\n\t\t\temit Approval(address(0x0), address(0x0), _tokenId);\r\n\t\t}\r\n\r\n\t\tuint256 _index = info.users[_from].indexOf[_tokenId] - 1;\r\n\t\tuint256 _movedRibbit = info.users[_from].list[info.users[_from].list.length - 1];\r\n\t\tinfo.users[_from].list[_index] = _movedRibbit;\r\n\t\tinfo.users[_from].indexOf[_movedRibbit] = _index + 1;\r\n\t\tinfo.users[_from].list.length--;\r\n\t\tdelete info.users[_from].indexOf[_tokenId];\r\n\t\tinfo.users[_to].indexOf[_tokenId] = info.users[_to].list.push(_tokenId);\r\n\t\temit Transfer(_from, _to, _tokenId);\r\n\t}\r\n\r\n\tfunction _claim(uint256 _tokenId, address _receiver) internal {\r\n\t\trequire(!getClaimed(_tokenId));\r\n\t\tinfo.list[_tokenId].claimed = true;\r\n\t\tinfo.list[_tokenId].owner = _receiver;\r\n\t\tinfo.users[_receiver].indexOf[_tokenId] = info.users[_receiver].list.push(_tokenId);\r\n\t\temit Transfer(address(0x0), _receiver, _tokenId);\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Ribbits\",\"name\":\"_ribbits\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"allInfoFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLPTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wrbtReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userRibbits\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"userApproved\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"userBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userLPBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unwrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalUnwrapped\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"wrap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"WrappedRibbits","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a8e7366031d493a0df88a583196d092f80152029","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://018b454828847ea364c5929214e10daf49ea332c548f9b07074c88e869f068ea"}]}