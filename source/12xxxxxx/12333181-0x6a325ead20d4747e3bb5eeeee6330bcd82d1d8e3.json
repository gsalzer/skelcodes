{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/misc/KyberInternalGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\n\\n\\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport {PermissionAdmin} from '@kyber.network/utils-sc/contracts/PermissionAdmin.sol';\\nimport {PermissionOperators} from '@kyber.network/utils-sc/contracts/PermissionOperators.sol';\\nimport {IERC20Ext} from '@kyber.network/utils-sc/contracts/IERC20Ext.sol';\\nimport {IKyberGovernance} from '../interfaces/governance/IKyberGovernance.sol';\\nimport {IRewardsDistributor} from '../interfaces/rewardDistribution/IRewardsDistributor.sol';\\n\\n\\n/**\\n    Internal contracts to participate in KyberDAO and claim rewards for Kyber\\n    Only accept external delegation, all reward will be transferred\\n*/\\ncontract KyberInternalGovernance is PermissionOperators {\\n    using SafeERC20 for IERC20Ext;\\n\\n    IERC20Ext public constant ETH_TOKEN_ADDRESS = IERC20Ext(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n\\n    address payable public rewardRecipient;\\n    IKyberGovernance public governance;\\n    IRewardsDistributor public rewardDistributor;\\n\\n    constructor(\\n        address _admin,\\n        address payable _rewardRecipient,\\n        IKyberGovernance _governance,\\n        IRewardsDistributor _rewardDistributor,\\n        address _operator\\n    ) PermissionAdmin(_admin) {\\n        require(_rewardRecipient != address(0), \\\"invalid reward recipient\\\");\\n        require(_governance != IKyberGovernance(0), \\\"invalid kyber governance\\\");\\n        require(_rewardDistributor != IRewardsDistributor(0), \\\"invalid reward distributor\\\");\\n\\n        rewardRecipient = _rewardRecipient;\\n        governance = _governance;\\n        rewardDistributor = _rewardDistributor;\\n\\n        if (_operator != address(0)) {\\n            // consistent with current design\\n            operators[_operator] = true;\\n            operatorsGroup.push(_operator);\\n            emit OperatorAdded(_operator, true);\\n        }\\n    }\\n\\n    receive() external payable {}\\n\\n    /**\\n    * @dev only operator can vote, given list of proposal ids\\n    *   and an option for each proposal\\n    */\\n    function vote(\\n        uint256[] calldata proposalIds,\\n        uint256[] calldata optionBitMasks\\n    )\\n        external onlyOperator\\n    {\\n        require(proposalIds.length == optionBitMasks.length, \\\"invalid length\\\");\\n        for(uint256 i = 0; i < proposalIds.length; i++) {\\n            governance.submitVote(proposalIds[i], optionBitMasks[i]);\\n        }\\n    }\\n\\n    /**\\n    * @dev anyone can call to claim rewards for multiple epochs\\n    * @dev all eth will be sent back to rewardRecipient\\n    */\\n    function claimRewards(\\n        uint256 cycle,\\n        uint256 index,\\n        IERC20Ext[] calldata tokens,\\n        uint256[] calldata cumulativeAmounts,\\n        bytes32[] calldata merkleProof\\n    )\\n        external\\n        returns (uint256[] memory claimAmounts)\\n    {\\n        claimAmounts = rewardDistributor.claim(\\n            cycle, index, address(this), tokens, cumulativeAmounts, merkleProof\\n        );\\n\\n        for(uint256 i = 0; i < tokens.length; i++) {\\n            uint256 bal = tokens[i] == ETH_TOKEN_ADDRESS ?\\n                address(this).balance : tokens[i].balanceOf(address(this));\\n            if (bal > 0) _transferToken(tokens[i], bal);\\n        }\\n    }\\n\\n    function updateRewardRecipient(address payable _newRecipient)\\n        external onlyAdmin\\n    {\\n        require(_newRecipient != address(0), \\\"invalid address\\\");\\n        rewardRecipient = _newRecipient;\\n    }\\n\\n    /**\\n    * @dev most likely unused, but put here for flexibility or in case a mistake in deployment \\n    */\\n    function updateKyberContracts(\\n        IKyberGovernance _governance,\\n        IRewardsDistributor _rewardDistributor\\n    )\\n        external onlyAdmin\\n    {\\n        require(_governance != IKyberGovernance(0), \\\"invalid kyber dao\\\");\\n        require(_rewardDistributor != IRewardsDistributor(0), \\\"invalid reward distributor\\\");\\n        governance = _governance;\\n        rewardDistributor = _rewardDistributor;\\n    }\\n\\n    /**\\n    * @dev allow withdraw funds of any tokens to rewardRecipient address\\n    */\\n    function withdrawFund(\\n        IERC20Ext[] calldata tokens,\\n        uint256[] calldata amounts\\n    ) external {\\n        require(tokens.length == amounts.length, \\\"invalid length\\\");\\n        for(uint256 i = 0; i < tokens.length; i++) {\\n            _transferToken(tokens[i], amounts[i]);\\n        }\\n    }\\n\\n    function _transferToken(IERC20Ext token, uint256 amount) internal {\\n        if (token == ETH_TOKEN_ADDRESS) {\\n            (bool success, ) = rewardRecipient.call { value: amount }(\\\"\\\");\\n            require(success, \\\"transfer eth failed\\\");\\n        } else {\\n            token.safeTransfer(rewardRecipient, amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@kyber.network/utils-sc/contracts/PermissionAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\n\\nabstract contract PermissionAdmin {\\n    address public admin;\\n    address public pendingAdmin;\\n\\n    event AdminClaimed(address newAdmin, address previousAdmin);\\n\\n    event TransferAdminPending(address pendingAdmin);\\n\\n    constructor(address _admin) {\\n        require(_admin != address(0), \\\"admin 0\\\");\\n        admin = _admin;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"only admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current admin to set the pendingAdmin address.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdmin(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0), \\\"new admin 0\\\");\\n        emit TransferAdminPending(newAdmin);\\n        pendingAdmin = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0), \\\"admin 0\\\");\\n        emit TransferAdminPending(newAdmin);\\n        emit AdminClaimed(newAdmin, admin);\\n        admin = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\\n     */\\n    function claimAdmin() public {\\n        require(pendingAdmin == msg.sender, \\\"not pending\\\");\\n        emit AdminClaimed(pendingAdmin, admin);\\n        admin = pendingAdmin;\\n        pendingAdmin = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"@kyber.network/utils-sc/contracts/PermissionOperators.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nimport \\\"./PermissionAdmin.sol\\\";\\n\\n\\nabstract contract PermissionOperators is PermissionAdmin {\\n    uint256 private constant MAX_GROUP_SIZE = 50;\\n\\n    mapping(address => bool) internal operators;\\n    address[] internal operatorsGroup;\\n\\n    event OperatorAdded(address newOperator, bool isAdd);\\n\\n    modifier onlyOperator() {\\n        require(operators[msg.sender], \\\"only operator\\\");\\n        _;\\n    }\\n\\n    function getOperators() external view returns (address[] memory) {\\n        return operatorsGroup;\\n    }\\n\\n    function addOperator(address newOperator) public onlyAdmin {\\n        require(!operators[newOperator], \\\"operator exists\\\"); // prevent duplicates.\\n        require(operatorsGroup.length < MAX_GROUP_SIZE, \\\"max operators\\\");\\n\\n        emit OperatorAdded(newOperator, true);\\n        operators[newOperator] = true;\\n        operatorsGroup.push(newOperator);\\n    }\\n\\n    function removeOperator(address operator) public onlyAdmin {\\n        require(operators[operator], \\\"not operator\\\");\\n        operators[operator] = false;\\n\\n        for (uint256 i = 0; i < operatorsGroup.length; ++i) {\\n            if (operatorsGroup[i] == operator) {\\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\\n                operatorsGroup.pop();\\n                emit OperatorAdded(operator, false);\\n                break;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@kyber.network/utils-sc/contracts/IERC20Ext.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n\\n/**\\n * @dev Interface extending ERC20 standard to include decimals() as\\n *      it is optional in the OpenZeppelin IERC20 interface.\\n */\\ninterface IERC20Ext is IERC20 {\\n    /**\\n     * @dev This function is required as Kyber requires to interact\\n     *      with token.decimals() with many of its operations.\\n     */\\n    function decimals() external view returns (uint8 digits);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/governance/IKyberGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IExecutorWithTimelock} from './IExecutorWithTimelock.sol';\\nimport {IVotingPowerStrategy} from './IVotingPowerStrategy.sol';\\n\\ninterface IKyberGovernance {\\n  enum ProposalState {\\n    Pending,\\n    Canceled,\\n    Active,\\n    Failed,\\n    Succeeded,\\n    Queued,\\n    Expired,\\n    Executed,\\n    Finalized\\n  }\\n  enum ProposalType {Generic, Binary}\\n\\n  /// For Binary proposal, optionBitMask is 0/1/2\\n  /// For Generic proposal, optionBitMask is bitmask of voted options\\n  struct Vote {\\n    uint32 optionBitMask;\\n    uint224 votingPower;\\n  }\\n\\n  struct ProposalWithoutVote {\\n    uint256 id;\\n    ProposalType proposalType;\\n    address creator;\\n    IExecutorWithTimelock executor;\\n    IVotingPowerStrategy strategy;\\n    address[] targets;\\n    uint256[] weiValues;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n    string[] options;\\n    uint256[] voteCounts;\\n    uint256 totalVotes;\\n    uint256 maxVotingPower;\\n    uint256 startTime;\\n    uint256 endTime;\\n    uint256 executionTime;\\n    string link;\\n    bool executed;\\n    bool canceled;\\n  }\\n\\n  struct Proposal {\\n    ProposalWithoutVote proposalData;\\n    mapping(address => Vote) votes;\\n  }\\n\\n  struct BinaryProposalParams {\\n    address[] targets;\\n    uint256[] weiValues;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n  }\\n\\n  /**\\n   * @dev emitted when a new binary proposal is created\\n   * @param proposalId id of the binary proposal\\n   * @param creator address of the creator\\n   * @param executor ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param targets list of contracts called by proposal's associated transactions\\n   * @param weiValues list of value in wei for each propoposal's associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used\\n   *     when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty,\\n   *     calldata ready, else calldata is arguments\\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget,\\n   *    else calls the target\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param link URL link of the proposal\\n   * @param maxVotingPower max voting power for this proposal\\n   **/\\n  event BinaryProposalCreated(\\n    uint256 proposalId,\\n    address indexed creator,\\n    IExecutorWithTimelock indexed executor,\\n    IVotingPowerStrategy indexed strategy,\\n    address[] targets,\\n    uint256[] weiValues,\\n    string[] signatures,\\n    bytes[] calldatas,\\n    bool[] withDelegatecalls,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string link,\\n    uint256 maxVotingPower\\n  );\\n\\n  /**\\n   * @dev emitted when a new generic proposal is created\\n   * @param proposalId id of the generic proposal\\n   * @param creator address of the creator\\n   * @param executor ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param options list of proposal vote options\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param link URL link of the proposal\\n   * @param maxVotingPower max voting power for this proposal\\n   **/\\n  event GenericProposalCreated(\\n    uint256 proposalId,\\n    address indexed creator,\\n    IExecutorWithTimelock indexed executor,\\n    IVotingPowerStrategy indexed strategy,\\n    string[] options,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string link,\\n    uint256 maxVotingPower\\n  );\\n\\n  /**\\n   * @dev emitted when a proposal is canceled\\n   * @param proposalId id of the proposal\\n   **/\\n  event ProposalCanceled(uint256 proposalId);\\n\\n  /**\\n   * @dev emitted when a proposal is queued\\n   * @param proposalId id of the proposal\\n   * @param executionTime time when proposal underlying transactions can be executed\\n   * @param initiatorQueueing address of the initiator of the queuing transaction\\n   **/\\n  event ProposalQueued(\\n    uint256 indexed proposalId,\\n    uint256 executionTime,\\n    address indexed initiatorQueueing\\n  );\\n  /**\\n   * @dev emitted when a proposal is executed\\n   * @param proposalId id of the proposal\\n   * @param initiatorExecution address of the initiator of the execution transaction\\n   **/\\n  event ProposalExecuted(uint256 proposalId, address indexed initiatorExecution);\\n  /**\\n   * @dev emitted when a vote is registered\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @param voteOptions vote options selected by voter\\n   * @param votingPower Power of the voter/vote\\n   **/\\n  event VoteEmitted(\\n    uint256 indexed proposalId,\\n    address indexed voter,\\n    uint32 indexed voteOptions,\\n    uint224 votingPower\\n  );\\n\\n  /**\\n   * @dev emitted when a vote is registered\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @param voteOptions vote options selected by voter\\n   * @param oldVotingPower Old power of the voter/vote\\n   * @param newVotingPower New power of the voter/vote\\n   **/\\n  event VotingPowerChanged(\\n    uint256 indexed proposalId,\\n    address indexed voter,\\n    uint32 indexed voteOptions,\\n    uint224 oldVotingPower,\\n    uint224 newVotingPower\\n  );\\n\\n  event DaoOperatorTransferred(address indexed newDaoOperator);\\n\\n  event ExecutorAuthorized(address indexed executor);\\n\\n  event ExecutorUnauthorized(address indexed executor);\\n\\n  event VotingPowerStrategyAuthorized(address indexed strategy);\\n\\n  event VotingPowerStrategyUnauthorized(address indexed strategy);\\n\\n  /**\\n   * @dev Function is triggered when users withdraw from staking and change voting power\\n   */\\n  function handleVotingPowerChanged(\\n    address staker,\\n    uint256 newVotingPower,\\n    uint256[] calldata proposalIds\\n  ) external;\\n\\n  /**\\n   * @dev Creates a Binary Proposal (needs to be validated by the Proposal Validator)\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy voting power strategy of the proposal\\n   * @param executionParams data for execution, includes\\n   *   targets list of contracts called by proposal's associated transactions\\n   *   weiValues list of value in wei for each proposal's associated transaction\\n   *   signatures list of function signatures (can be empty)\\n   *        to be used when created the callData\\n   *   calldatas list of calldatas: if associated signature empty,\\n   *        calldata ready, else calldata is arguments\\n   *   withDelegatecalls boolean, true = transaction delegatecalls the taget,\\n   *        else calls the target\\n   * @param startTime start timestamp to allow vote\\n   * @param endTime end timestamp of the proposal\\n   * @param link link to the proposal description\\n   **/\\n  function createBinaryProposal(\\n    IExecutorWithTimelock executor,\\n    IVotingPowerStrategy strategy,\\n    BinaryProposalParams memory executionParams,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string memory link\\n  ) external returns (uint256 proposalId);\\n\\n  /**\\n   * @dev Creates a Generic Proposal\\n   * @param executor ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param options list of proposal vote options\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param link URL link of the proposal\\n   **/\\n  function createGenericProposal(\\n    IExecutorWithTimelock executor,\\n    IVotingPowerStrategy strategy,\\n    string[] memory options,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string memory link\\n  ) external returns (uint256 proposalId);\\n\\n  /**\\n   * @dev Cancels a Proposal,\\n   * either at anytime by guardian\\n   * or when proposal is Pending/Active and threshold no longer reached\\n   * @param proposalId id of the proposal\\n   **/\\n  function cancel(uint256 proposalId) external;\\n\\n  /**\\n   * @dev Queue the proposal (If Proposal Succeeded)\\n   * @param proposalId id of the proposal to queue\\n   **/\\n  function queue(uint256 proposalId) external;\\n\\n  /**\\n   * @dev Execute the proposal (If Proposal Queued)\\n   * @param proposalId id of the proposal to execute\\n   **/\\n  function execute(uint256 proposalId) external payable;\\n\\n  /**\\n   * @dev Function allowing msg.sender to vote for/against a proposal\\n   * @param proposalId id of the proposal\\n   * @param optionBitMask vote option(s) selected\\n   **/\\n  function submitVote(uint256 proposalId, uint256 optionBitMask) external;\\n\\n  /**\\n   * @dev Function to register the vote of user that has voted offchain via signature\\n   * @param proposalId id of the proposal\\n   * @param choice the bit mask of voted options\\n   * @param v v part of the voter signature\\n   * @param r r part of the voter signature\\n   * @param s s part of the voter signature\\n   **/\\n  function submitVoteBySignature(\\n    uint256 proposalId,\\n    uint256 choice,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized executors\\n   * @param executors list of new addresses to be authorized executors\\n   **/\\n  function authorizeExecutors(address[] calldata executors) external;\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized executors\\n   * @param executors list of addresses to be removed as authorized executors\\n   **/\\n  function unauthorizeExecutors(address[] calldata executors) external;\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized strategies\\n   * @param strategies list of new addresses to be authorized strategies\\n   **/\\n  function authorizeVotingPowerStrategies(address[] calldata strategies) external;\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized strategies\\n   * @param strategies list of addresses to be removed as authorized strategies\\n   **/\\n  function unauthorizeVotingPowerStrategies(address[] calldata strategies) external;\\n\\n  /**\\n   * @dev Returns whether an address is an authorized executor\\n   * @param executor address to evaluate as authorized executor\\n   * @return true if authorized\\n   **/\\n  function isExecutorAuthorized(address executor) external view returns (bool);\\n\\n  /**\\n   * @dev Returns whether an address is an authorized strategy\\n   * @param strategy address to evaluate as authorized strategy\\n   * @return true if authorized\\n   **/\\n  function isVotingPowerStrategyAuthorized(address strategy) external view returns (bool);\\n\\n  /**\\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\\n   * @return The address of the guardian\\n   **/\\n  function getDaoOperator() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the proposal count (the current number of proposals ever created)\\n   * @return the proposal count\\n   **/\\n  function getProposalsCount() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of a proposal by id\\n   * @param proposalId id of the proposal to get\\n   * @return the proposal as ProposalWithoutVote memory object\\n   **/\\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVote memory);\\n\\n  /**\\n   * @dev Getter of the vote data of a proposal by id\\n   * including totalVotes, voteCounts and options\\n   * @param proposalId id of the proposal\\n   * @return (totalVotes, voteCounts, options)\\n   **/\\n  function getProposalVoteDataById(uint256 proposalId)\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256[] memory,\\n      string[] memory\\n    );\\n\\n  /**\\n   * @dev Getter of the Vote of a voter about a proposal\\n   * Note: Vote is a struct: ({uint32 bitOptionMask, uint224 votingPower})\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @return The associated Vote memory object\\n   **/\\n  function getVoteOnProposal(uint256 proposalId, address voter)\\n    external\\n    view\\n    returns (Vote memory);\\n\\n  /**\\n   * @dev Get the current state of a proposal\\n   * @param proposalId id of the proposal\\n   * @return The current state if the proposal\\n   **/\\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/rewardDistribution/IRewardsDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nimport {IERC20Ext} from '@kyber.network/utils-sc/contracts/IERC20Ext.sol';\\n\\n\\ninterface IRewardsDistributor {\\n  event Claimed(\\n    uint256 indexed cycle,\\n    address indexed user,\\n    IERC20Ext[] tokens,\\n    uint256[] claimAmounts\\n  );\\n\\n  /**\\n   * @dev Claim accumulated rewards for a set of tokens at a given cycle number\\n   * @param cycle cycle number\\n   * @param index user reward info index in the array of reward info\\n   * during merkle tree generation\\n   * @param user wallet address of reward beneficiary\\n   * @param tokens array of tokens claimable by reward beneficiary\\n   * @param cumulativeAmounts cumulative token amounts claimable by reward beneficiary\\n   * @param merkleProof merkle proof of claim\\n   * @return claimAmounts actual claimed token amounts sent to the reward beneficiary\\n   **/\\n  function claim(\\n    uint256 cycle,\\n    uint256 index,\\n    address user,\\n    IERC20Ext[] calldata tokens,\\n    uint256[] calldata cumulativeAmounts,\\n    bytes32[] calldata merkleProof\\n  ) external returns (uint256[] memory claimAmounts);\\n\\n  /**\\n   * @dev Checks whether a claim is valid or not\\n   * @param cycle cycle number\\n   * @param index user reward info index in the array of reward info\\n   * during merkle tree generation\\n   * @param user wallet address of reward beneficiary\\n   * @param tokens array of tokens claimable by reward beneficiary\\n   * @param cumulativeAmounts cumulative token amounts claimable by reward beneficiary\\n   * @param merkleProof merkle proof of claim\\n   * @return true if valid claim, false otherwise\\n   **/\\n  function isValidClaim(\\n    uint256 cycle,\\n    uint256 index,\\n    address user,\\n    IERC20Ext[] calldata tokens,\\n    uint256[] calldata cumulativeAmounts,\\n    bytes32[] calldata merkleProof\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Fetch accumulated claimed rewards for a set of tokens since the first cycle\\n   * @param user wallet address of reward beneficiary\\n   * @param tokens array of tokens claimed by reward beneficiary\\n   * @return userClaimedAmounts claimed token amounts by reward beneficiary since the first cycle\\n   **/\\n  function getClaimedAmounts(address user, IERC20Ext[] calldata tokens)\\n    external\\n    view\\n    returns (uint256[] memory userClaimedAmounts);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/governance/IExecutorWithTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IKyberGovernance} from './IKyberGovernance.sol';\\n\\ninterface IExecutorWithTimelock {\\n  /**\\n   * @dev emitted when a new pending admin is set\\n   * @param newPendingAdmin address of the new pending admin\\n   **/\\n  event NewPendingAdmin(address newPendingAdmin);\\n\\n  /**\\n   * @dev emitted when a new admin is set\\n   * @param newAdmin address of the new admin\\n   **/\\n  event NewAdmin(address newAdmin);\\n\\n  /**\\n   * @dev emitted when a new delay (between queueing and execution) is set\\n   * @param delay new delay\\n   **/\\n  event NewDelay(uint256 delay);\\n\\n  /**\\n   * @dev emitted when a new (trans)action is Queued.\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  event QueuedAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  );\\n\\n  /**\\n   * @dev emitted when an action is Cancelled\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  event CancelledAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  );\\n\\n  /**\\n   * @dev emitted when an action is Cancelled\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @param resultData the actual callData used on the target\\n   **/\\n  event ExecutedAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall,\\n    bytes resultData\\n  );\\n\\n  /**\\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external returns (bytes32);\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external payable returns (bytes memory);\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external returns (bytes32);\\n\\n  /**\\n   * @dev Getter of the current admin address (should be governance)\\n   * @return The address of the current admin\\n   **/\\n  function getAdmin() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the current pending admin address\\n   * @return The address of the pending admin\\n   **/\\n  function getPendingAdmin() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the delay between queuing and execution\\n   * @return The delay in seconds\\n   **/\\n  function getDelay() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns whether an action (via actionHash) is queued\\n   * @param actionHash hash of the action to be checked\\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\\n   * @return true if underlying action of actionHash is queued\\n   **/\\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\\n\\n  /**\\n   * @dev Checks whether a proposal is over its grace period\\n   * @param governance Governance contract\\n   * @param proposalId Id of the proposal against which to test\\n   * @return true of proposal is over grace period\\n   **/\\n  function isProposalOverGracePeriod(IKyberGovernance governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Getter of grace period constant\\n   * @return grace period in seconds\\n   **/\\n  function GRACE_PERIOD() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of minimum delay constant\\n   * @return minimum delay in seconds\\n   **/\\n  function MINIMUM_DELAY() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of maximum delay constant\\n   * @return maximum delay in seconds\\n   **/\\n  function MAXIMUM_DELAY() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/governance/IVotingPowerStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IWithdrawHandler} from '../staking/IWithdrawHandler.sol';\\n\\ninterface IVotingPowerStrategy is IWithdrawHandler {\\n  /**\\n   * @dev call by governance when create a proposal\\n   */\\n  function handleProposalCreation(\\n    uint256 proposalId,\\n    uint256 startTime,\\n    uint256 endTime\\n  ) external;\\n\\n  /**\\n   * @dev call by governance when cancel a proposal\\n   */\\n  function handleProposalCancellation(uint256 proposalId) external;\\n\\n  /**\\n   * @dev call by governance when submitting a vote\\n   * @param choice: unused param for future usage\\n   * @return votingPower of voter\\n   */\\n  function handleVote(\\n    address voter,\\n    uint256 proposalId,\\n    uint256 choice\\n  ) external returns (uint256 votingPower);\\n\\n  /**\\n   * @dev get voter's voting power given timestamp\\n   * @dev for reading purposes and validating voting power for creating/canceling proposal in the furture\\n   * @dev when submitVote, should call 'handleVote' instead\\n   */\\n  function getVotingPower(address voter, uint256 timestamp)\\n    external\\n    view\\n    returns (uint256 votingPower);\\n\\n  /**\\n   * @dev validate that startTime and endTime are suitable for calculating voting power\\n   * @dev with current version, startTime and endTime must be in the sameEpcoh\\n   */\\n  function validateProposalCreation(uint256 startTime, uint256 endTime)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev getMaxVotingPower at current time\\n   * @dev call by governance when creating a proposal\\n   */\\n  function getMaxVotingPower() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/staking/IWithdrawHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n/**\\n * @title Interface for callbacks hooks when user withdraws from staking contract\\n */\\ninterface IWithdrawHandler {\\n  function handleWithdrawal(address staker, uint256 reduceAmount) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_rewardRecipient\",\"type\":\"address\"},{\"internalType\":\"contract IKyberGovernance\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"contract IRewardsDistributor\",\"name\":\"_rewardDistributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETH_TOKEN_ADDRESS\",\"outputs\":[{\"internalType\":\"contract IERC20Ext\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20Ext[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"cumulativeAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"claimAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"contract IKyberGovernance\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardDistributor\",\"outputs\":[{\"internalType\":\"contract IRewardsDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRecipient\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKyberGovernance\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"contract IRewardsDistributor\",\"name\":\"_rewardDistributor\",\"type\":\"address\"}],\"name\":\"updateKyberContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newRecipient\",\"type\":\"address\"}],\"name\":\"updateRewardRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"proposalIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"optionBitMasks\",\"type\":\"uint256[]\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Ext[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"withdrawFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"KyberInternalGovernance","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"0000000000000000000000003eb01b3391ea15ce752d01cf3d3f09dec596f65000000000000000000000000043ec6ecffc1e9faab5627341c2186b08d4acdfc20000000000000000000000007ec8fcc26be7e9e85b57e73083e5fe0550d8a7fe0000000000000000000000005ec0dcf4f6f55f28550c70b854082993fdc0d3b2000000000000000000000000be2f0354d970265bfc36d383af77f72736b81b54","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}