{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/FraudProof.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\npragma experimental ABIEncoderV2;\\n\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport { IERC20 } from \\\"./interfaces/IERC20.sol\\\";\\nimport { ITokenRegistry } from \\\"./interfaces/ITokenRegistry.sol\\\";\\n\\nimport { Types } from \\\"./libs/Types.sol\\\";\\nimport { RollupUtils } from \\\"./libs/RollupUtils.sol\\\";\\nimport { ParamManager } from \\\"./libs/ParamManager.sol\\\";\\nimport { ECVerify } from \\\"./libs/ECVerify.sol\\\";\\n\\nimport { MerkleTreeUtils as MTUtils } from \\\"./MerkleTreeUtils.sol\\\";\\nimport { Governance } from \\\"./Governance.sol\\\";\\nimport { NameRegistry as Registry } from \\\"./NameRegistry.sol\\\";\\n\\ncontract FraudProofSetup {\\n    using SafeMath for uint256;\\n    using ECVerify for bytes32;\\n\\n    MTUtils public merkleUtils;\\n    ITokenRegistry public tokenRegistry;\\n    Registry public nameRegistry;\\n\\n    bytes32\\n        public constant ZERO_BYTES32 = 0x0000000000000000000000000000000000000000000000000000000000000000;\\n\\n    Governance public governance;\\n}\\n\\ncontract FraudProofHelpers is FraudProofSetup {\\n    function ValidatePubkeyAvailability(\\n        bytes32 _accountsRoot,\\n        Types.PDAMerkleProof memory _from_pda_proof,\\n        uint256 from_index\\n    ) public view {\\n        // verify from account pubkey exists in PDA tree\\n        // NOTE: We dont need to prove that to address has the pubkey available\\n        Types.PDALeaf memory fromPDA = Types.PDALeaf({\\n            pubkey: _from_pda_proof._pda.pubkey_leaf.pubkey\\n        });\\n\\n        require(\\n            merkleUtils.verifyLeaf(\\n                _accountsRoot,\\n                RollupUtils.PDALeafToHash(fromPDA),\\n                _from_pda_proof._pda.pathToPubkey,\\n                _from_pda_proof.siblings\\n            ),\\n            \\\"From PDA proof is incorrect\\\"\\n        );\\n\\n        // convert pubkey path to ID\\n        uint256 computedID = merkleUtils.pathToIndex(\\n            _from_pda_proof._pda.pathToPubkey,\\n            governance.MAX_DEPTH()\\n        );\\n\\n        // make sure the ID in transaction is the same account for which account proof was provided\\n        require(\\n            computedID == from_index,\\n            \\\"Pubkey not related to the from account in the transaction\\\"\\n        );\\n    }\\n\\n    function ValidateAccountMP(\\n        bytes32 root,\\n        Types.AccountMerkleProof memory merkle_proof\\n    ) public view {\\n        bytes32 accountLeaf = RollupUtils.getAccountHash(\\n            merkle_proof.accountIP.account.ID,\\n            merkle_proof.accountIP.account.balance,\\n            merkle_proof.accountIP.account.nonce,\\n            merkle_proof.accountIP.account.tokenType\\n        );\\n\\n        // verify from leaf exists in the balance tree\\n        require(\\n            merkleUtils.verifyLeaf(\\n                root,\\n                accountLeaf,\\n                merkle_proof.accountIP.pathToAccount,\\n                merkle_proof.siblings\\n            ),\\n            \\\"Merkle Proof is incorrect\\\"\\n        );\\n    }\\n\\n    function validateTxBasic(\\n        Types.Transaction memory _tx,\\n        Types.UserAccount memory _from_account\\n    ) public view returns (Types.ErrorCode) {\\n        // verify that tokens are registered\\n        if (tokenRegistry.registeredTokens(_tx.tokenType) == address(0)) {\\n            // invalid state transition\\n            // to be slashed because the submitted transaction\\n            // had invalid token type\\n            return Types.ErrorCode.InvalidTokenAddress;\\n        }\\n\\n        if (_tx.amount == 0) {\\n            // invalid state transition\\n            // needs to be slashed because the submitted transaction\\n            // had 0 amount.\\n            return Types.ErrorCode.InvalidTokenAmount;\\n        }\\n\\n        // check from leaf has enough balance\\n        if (_from_account.balance < _tx.amount) {\\n            // invalid state transition\\n            // needs to be slashed because the account doesnt have enough balance\\n            // for the transfer\\n            return Types.ErrorCode.NotEnoughTokenBalance;\\n        }\\n\\n        return Types.ErrorCode.NoError;\\n    }\\n\\n    function RemoveTokensFromAccount(\\n        Types.UserAccount memory account,\\n        uint256 numOfTokens\\n    ) public pure returns (Types.UserAccount memory updatedAccount) {\\n        return (\\n            RollupUtils.UpdateBalanceInAccount(\\n                account,\\n                RollupUtils.BalanceFromAccount(account).sub(numOfTokens)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice ApplyTx applies the transaction on the account. This is where\\n     * people need to define the logic for the application\\n     * @param _merkle_proof contains the siblings and path to the account\\n     * @param transaction is the transaction that needs to be applied\\n     * @return returns updated account and updated state root\\n     * */\\n    function ApplyTx(\\n        Types.AccountMerkleProof memory _merkle_proof,\\n        Types.Transaction memory transaction\\n    ) public view returns (bytes memory updatedAccount, bytes32 newRoot) {\\n        Types.UserAccount memory account = _merkle_proof.accountIP.account;\\n        if (transaction.fromIndex == account.ID) {\\n            account = RemoveTokensFromAccount(account, transaction.amount);\\n            account.nonce++;\\n        }\\n\\n        if (transaction.toIndex == account.ID) {\\n            account = AddTokensToAccount(account, transaction.amount);\\n        }\\n\\n        newRoot = UpdateAccountWithSiblings(account, _merkle_proof);\\n\\n        return (RollupUtils.BytesFromAccount(account), newRoot);\\n    }\\n\\n    function AddTokensToAccount(\\n        Types.UserAccount memory account,\\n        uint256 numOfTokens\\n    ) public pure returns (Types.UserAccount memory updatedAccount) {\\n        return (\\n            RollupUtils.UpdateBalanceInAccount(\\n                account,\\n                RollupUtils.BalanceFromAccount(account).add(numOfTokens)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Returns the updated root and balance\\n     */\\n    function UpdateAccountWithSiblings(\\n        Types.UserAccount memory new_account,\\n        Types.AccountMerkleProof memory _merkle_proof\\n    ) public view returns (bytes32) {\\n        bytes32 newRoot = merkleUtils.updateLeafWithSiblings(\\n            keccak256(RollupUtils.BytesFromAccount(new_account)),\\n            _merkle_proof.accountIP.pathToAccount,\\n            _merkle_proof.siblings\\n        );\\n        return (newRoot);\\n    }\\n\\n    function ValidateSignature(\\n        Types.Transaction memory _tx,\\n        Types.PDAMerkleProof memory _from_pda_proof\\n    ) public pure returns (bool) {\\n        require(\\n            RollupUtils.calculateAddress(\\n                _from_pda_proof._pda.pubkey_leaf.pubkey\\n            ) ==\\n                RollupUtils\\n                    .getTxSignBytes(\\n                    _tx\\n                        .fromIndex,\\n                    _tx\\n                        .toIndex,\\n                    _tx\\n                        .tokenType,\\n                    _tx\\n                        .txType,\\n                    _tx\\n                        .nonce,\\n                    _tx\\n                        .amount\\n                )\\n                    .ecrecovery(_tx.signature),\\n            \\\"Signature is incorrect\\\"\\n        );\\n    }\\n}\\n\\ncontract FraudProof is FraudProofHelpers {\\n    /*********************\\n     * Constructor *\\n     ********************/\\n    constructor(address _registryAddr) public {\\n        nameRegistry = Registry(_registryAddr);\\n\\n        governance = Governance(\\n            nameRegistry.getContractDetails(ParamManager.Governance())\\n        );\\n\\n        merkleUtils = MTUtils(\\n            nameRegistry.getContractDetails(ParamManager.MERKLE_UTILS())\\n        );\\n\\n        tokenRegistry = ITokenRegistry(\\n            nameRegistry.getContractDetails(ParamManager.TOKEN_REGISTRY())\\n        );\\n    }\\n\\n    function generateTxRoot(Types.Transaction[] memory _txs)\\n        public\\n        view\\n        returns (bytes32 txRoot)\\n    {\\n        // generate merkle tree from the txs provided by user\\n        bytes[] memory txs = new bytes[](_txs.length);\\n        for (uint256 i = 0; i < _txs.length; i++) {\\n            txs[i] = RollupUtils.CompressTx(_txs[i]);\\n        }\\n        txRoot = merkleUtils.getMerkleRoot(txs);\\n        return txRoot;\\n    }\\n\\n    /**\\n     * @notice processBatch processes a whole batch\\n     * @return returns updatedRoot, txRoot and if the batch is valid or not\\n     * */\\n    function processBatch(\\n        bytes32 stateRoot,\\n        bytes32 accountsRoot,\\n        Types.Transaction[] memory _txs,\\n        Types.BatchValidationProofs memory batchProofs,\\n        bytes32 expectedTxRoot\\n    )\\n        public\\n        view\\n        returns (\\n            bytes32,\\n            bytes32,\\n            bool\\n        )\\n    {\\n        bytes32 actualTxRoot = generateTxRoot(_txs);\\n        // if there is an expectation set, revert if it's not met\\n        if (expectedTxRoot == ZERO_BYTES32) {\\n            // if tx root while submission doesnt match tx root of given txs\\n            // dispute is unsuccessful\\n            require(\\n                actualTxRoot == expectedTxRoot,\\n                \\\"Invalid dispute, tx root doesn't match\\\"\\n            );\\n        }\\n\\n        bool isTxValid;\\n        {\\n            for (uint256 i = 0; i < _txs.length; i++) {\\n                // call process tx update for every transaction to check if any\\n                // tx evaluates correctly\\n                (stateRoot, , , , isTxValid) = processTx(\\n                    stateRoot,\\n                    accountsRoot,\\n                    _txs[i],\\n                    batchProofs.pdaProof[i],\\n                    batchProofs.accountProofs[i]\\n                );\\n\\n                if (!isTxValid) {\\n                    break;\\n                }\\n            }\\n        }\\n        return (stateRoot, actualTxRoot, !isTxValid);\\n    }\\n\\n    /**\\n     * @notice processTx processes a transactions and returns the updated balance tree\\n     *  and the updated leaves\\n     * conditions in require mean that the dispute be declared invalid\\n     * if conditons evaluate if the coordinator was at fault\\n     * @return Total number of batches submitted onchain\\n     */\\n    function processTx(\\n        bytes32 _balanceRoot,\\n        bytes32 _accountsRoot,\\n        Types.Transaction memory _tx,\\n        Types.PDAMerkleProof memory _from_pda_proof,\\n        Types.AccountProofs memory accountProofs\\n    )\\n        public\\n        view\\n        returns (\\n            bytes32,\\n            bytes memory,\\n            bytes memory,\\n            Types.ErrorCode,\\n            bool\\n        )\\n    {\\n        // Step-1 Prove that from address's public keys are available\\n        ValidatePubkeyAvailability(\\n            _accountsRoot,\\n            _from_pda_proof,\\n            _tx.fromIndex\\n        );\\n\\n        // STEP:2 Ensure the transaction has been signed using the from public key\\n        // ValidateSignature(_tx, _from_pda_proof);\\n\\n        // Validate the from account merkle proof\\n        ValidateAccountMP(_balanceRoot, accountProofs.from);\\n\\n        Types.ErrorCode err_code = validateTxBasic(\\n            _tx,\\n            accountProofs.from.accountIP.account\\n        );\\n        if (err_code != Types.ErrorCode.NoError)\\n            return (ZERO_BYTES32, \\\"\\\", \\\"\\\", err_code, false);\\n\\n        // account holds the token type in the tx\\n        if (accountProofs.from.accountIP.account.tokenType != _tx.tokenType)\\n            // invalid state transition\\n            // needs to be slashed because the submitted transaction\\n            // had invalid token type\\n            return (\\n                ZERO_BYTES32,\\n                \\\"\\\",\\n                \\\"\\\",\\n                Types.ErrorCode.BadFromTokenType,\\n                false\\n            );\\n\\n        bytes32 newRoot;\\n        bytes memory new_from_account;\\n        bytes memory new_to_account;\\n\\n        (new_from_account, newRoot) = ApplyTx(accountProofs.from, _tx);\\n\\n        // validate if leaf exists in the updated balance tree\\n        ValidateAccountMP(newRoot, accountProofs.to);\\n\\n        // account holds the token type in the tx\\n        if (accountProofs.to.accountIP.account.tokenType != _tx.tokenType)\\n            // invalid state transition\\n            // needs to be slashed because the submitted transaction\\n            // had invalid token type\\n            return (\\n                ZERO_BYTES32,\\n                \\\"\\\",\\n                \\\"\\\",\\n                Types.ErrorCode.BadToTokenType,\\n                false\\n            );\\n\\n        (new_to_account, newRoot) = ApplyTx(accountProofs.to, _tx);\\n\\n        return (\\n            newRoot,\\n            new_from_account,\\n            new_to_account,\\n            Types.ErrorCode.NoError,\\n            true\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/Governance.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\n\\n/*\\nGovernance contract handles all the proof of burn related functionality\\n*/\\ncontract Governance {\\n    constructor(uint256 maxDepth, uint256 maxDepositSubTree) public {\\n        _MAX_DEPTH = maxDepth;\\n        _MAX_DEPOSIT_SUBTREE = maxDepositSubTree;\\n    }\\n\\n    uint256 public _MAX_DEPTH = 4;\\n\\n    function MAX_DEPTH() public view returns (uint256) {\\n        return _MAX_DEPTH;\\n    }\\n\\n    uint256 public _MAX_DEPOSIT_SUBTREE = 2;\\n\\n    function MAX_DEPOSIT_SUBTREE() public view returns (uint256) {\\n        return _MAX_DEPOSIT_SUBTREE;\\n    }\\n\\n    // finalisation time is the number of blocks required by a batch to finalise\\n    // Delay period = 7 days. Block time = 15 seconds\\n    uint256 public _TIME_TO_FINALISE = 7 days;\\n\\n    function TIME_TO_FINALISE() public view returns (uint256) {\\n        return _TIME_TO_FINALISE;\\n    }\\n\\n    // min gas required before rollback pauses\\n    uint256 public _MIN_GAS_LIMIT_LEFT = 100000;\\n\\n    function MIN_GAS_LIMIT_LEFT() public view returns (uint256) {\\n        return _MIN_GAS_LIMIT_LEFT;\\n    }\\n\\n    uint256 public _MAX_TXS_PER_BATCH = 10;\\n\\n    function MAX_TXS_PER_BATCH() public view returns (uint256) {\\n        return _MAX_TXS_PER_BATCH;\\n    }\\n\\n    uint256 public _STAKE_AMOUNT = 32 ether;\\n\\n    function STAKE_AMOUNT() public view returns (uint256) {\\n        return _STAKE_AMOUNT;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/MerkleTreeUtils.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\npragma experimental ABIEncoderV2;\\nimport { ParamManager } from \\\"./libs/ParamManager.sol\\\";\\nimport { Governance } from \\\"./Governance.sol\\\";\\nimport { NameRegistry as Registry } from \\\"./NameRegistry.sol\\\";\\n\\ncontract MerkleTreeUtils {\\n    // The default hashes\\n    bytes32[] public defaultHashes;\\n    uint256 public MAX_DEPTH;\\n    Governance public governance;\\n\\n    /**\\n     * @notice Initialize a new MerkleTree contract, computing the default hashes for the merkle tree (MT)\\n     */\\n    constructor(address _registryAddr) public {\\n        Registry nameRegistry = Registry(_registryAddr);\\n        governance = Governance(\\n            nameRegistry.getContractDetails(ParamManager.Governance())\\n        );\\n        MAX_DEPTH = governance.MAX_DEPTH();\\n        defaultHashes = new bytes32[](MAX_DEPTH);\\n        // Calculate & set the default hashes\\n        setDefaultHashes(MAX_DEPTH);\\n    }\\n\\n    /* Methods */\\n\\n    /**\\n     * @notice Set default hashes\\n     */\\n    function setDefaultHashes(uint256 depth) internal {\\n        // Set the initial default hash.\\n        defaultHashes[0] = keccak256(abi.encode(0));\\n        for (uint256 i = 1; i < depth; i++) {\\n            defaultHashes[i] = keccak256(\\n                abi.encode(defaultHashes[i - 1], defaultHashes[i - 1])\\n            );\\n        }\\n    }\\n\\n    function getZeroRoot() public view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    defaultHashes[MAX_DEPTH - 1],\\n                    defaultHashes[MAX_DEPTH - 1]\\n                )\\n            );\\n    }\\n\\n    function getMaxTreeDepth() public view returns (uint256) {\\n        return MAX_DEPTH;\\n    }\\n\\n    function getRoot(uint256 index) public view returns (bytes32) {\\n        return defaultHashes[index];\\n    }\\n\\n    function getDefaultHashAtLevel(uint256 index)\\n        public\\n        view\\n        returns (bytes32)\\n    {\\n        return defaultHashes[index];\\n    }\\n\\n    function keecakHash(bytes memory data) public pure returns (bytes32) {\\n        return keccak256(data);\\n    }\\n\\n    /**\\n     * @notice Get the merkle root computed from some set of data blocks.\\n     * @param _dataBlocks The data being used to generate the tree.\\n     * @return the merkle tree root\\n     * NOTE: This is a stateless operation\\n     */\\n    function getMerkleRoot(bytes[] calldata _dataBlocks)\\n        external\\n        view\\n        returns (bytes32)\\n    {\\n        uint256 nextLevelLength = _dataBlocks.length;\\n        uint256 currentLevel = 0;\\n        bytes32[] memory nodes = new bytes32[](nextLevelLength + 1); // Add one in case we have an odd number of leaves\\n        // Generate the leaves\\n        for (uint256 i = 0; i < _dataBlocks.length; i++) {\\n            nodes[i] = keccak256(_dataBlocks[i]);\\n        }\\n        if (_dataBlocks.length == 1) {\\n            return nodes[0];\\n        }\\n        // Add a defaultNode if we've got an odd number of leaves\\n        if (nextLevelLength % 2 == 1) {\\n            nodes[nextLevelLength] = defaultHashes[currentLevel];\\n            nextLevelLength += 1;\\n        }\\n\\n        // Now generate each level\\n        while (nextLevelLength > 1) {\\n            currentLevel += 1;\\n            // Calculate the nodes for the currentLevel\\n            for (uint256 i = 0; i < nextLevelLength / 2; i++) {\\n                nodes[i] = getParent(nodes[i * 2], nodes[i * 2 + 1]);\\n            }\\n            nextLevelLength = nextLevelLength / 2;\\n            // Check if we will need to add an extra node\\n            if (nextLevelLength % 2 == 1 && nextLevelLength != 1) {\\n                nodes[nextLevelLength] = defaultHashes[currentLevel];\\n                nextLevelLength += 1;\\n            }\\n        }\\n        // Alright! We should be left with a single node! Return it...\\n        return nodes[0];\\n    }\\n\\n    /**\\n     * @notice Get the merkle root computed from some set of data blocks.\\n     * @param nodes The data being used to generate the tree.\\n     * @return the merkle tree root\\n     * NOTE: This is a stateless operation\\n     */\\n    function getMerkleRootFromLeaves(bytes32[] memory nodes)\\n        public\\n        view\\n        returns (bytes32)\\n    {\\n        uint256 nextLevelLength = nodes.length;\\n        uint256 currentLevel = 0;\\n        if (nodes.length == 1) {\\n            return nodes[0];\\n        }\\n\\n        // Add a defaultNode if we've got an odd number of leaves\\n        if (nextLevelLength % 2 == 1) {\\n            nodes[nextLevelLength] = defaultHashes[currentLevel];\\n            nextLevelLength += 1;\\n        }\\n\\n        // Now generate each level\\n        while (nextLevelLength > 1) {\\n            currentLevel += 1;\\n\\n            // Calculate the nodes for the currentLevel\\n            for (uint256 i = 0; i < nextLevelLength / 2; i++) {\\n                nodes[i] = getParent(nodes[i * 2], nodes[i * 2 + 1]);\\n            }\\n\\n            nextLevelLength = nextLevelLength / 2;\\n            // Check if we will need to add an extra node\\n            if (nextLevelLength % 2 == 1 && nextLevelLength != 1) {\\n                nodes[nextLevelLength] = defaultHashes[currentLevel];\\n                nextLevelLength += 1;\\n            }\\n        }\\n\\n        // Alright! We should be left with a single node! Return it...\\n        return nodes[0];\\n    }\\n\\n    /**\\n     * @notice Calculate root from an inclusion proof.\\n     * @param _dataBlock The data block we're calculating root for.\\n     * @param _path The path from the leaf to the root.\\n     * @param _siblings The sibling nodes along the way.\\n     * @return The next level of the tree\\n     * NOTE: This is a stateless operation\\n     */\\n    function computeInclusionProofRoot(\\n        bytes memory _dataBlock,\\n        uint256 _path,\\n        bytes32[] memory _siblings\\n    ) public pure returns (bytes32) {\\n        // First compute the leaf node\\n        bytes32 computedNode = keccak256(_dataBlock);\\n\\n        for (uint256 i = 0; i < _siblings.length; i++) {\\n            bytes32 sibling = _siblings[i];\\n            uint8 isComputedRightSibling = getNthBitFromRight(_path, i);\\n            if (isComputedRightSibling == 0) {\\n                computedNode = getParent(computedNode, sibling);\\n            } else {\\n                computedNode = getParent(sibling, computedNode);\\n            }\\n        }\\n        // Check if the computed node (_root) is equal to the provided root\\n        return computedNode;\\n    }\\n\\n    /**\\n     * @notice Calculate root from an inclusion proof.\\n     * @param _leaf The data block we're calculating root for.\\n     * @param _path The path from the leaf to the root.\\n     * @param _siblings The sibling nodes along the way.\\n     * @return The next level of the tree\\n     * NOTE: This is a stateless operation\\n     */\\n    function computeInclusionProofRootWithLeaf(\\n        bytes32 _leaf,\\n        uint256 _path,\\n        bytes32[] memory _siblings\\n    ) public pure returns (bytes32) {\\n        // First compute the leaf node\\n        bytes32 computedNode = _leaf;\\n        for (uint256 i = 0; i < _siblings.length; i++) {\\n            bytes32 sibling = _siblings[i];\\n            uint8 isComputedRightSibling = getNthBitFromRight(_path, i);\\n            if (isComputedRightSibling == 0) {\\n                computedNode = getParent(computedNode, sibling);\\n            } else {\\n                computedNode = getParent(sibling, computedNode);\\n            }\\n        }\\n        // Check if the computed node (_root) is equal to the provided root\\n        return computedNode;\\n    }\\n\\n    /**\\n     * @notice Verify an inclusion proof.\\n     * @param _root The root of the tree we are verifying inclusion for.\\n     * @param _dataBlock The data block we're verifying inclusion for.\\n     * @param _path The path from the leaf to the root.\\n     * @param _siblings The sibling nodes along the way.\\n     * @return The next level of the tree\\n     * NOTE: This is a stateless operation\\n     */\\n    function verify(\\n        bytes32 _root,\\n        bytes memory _dataBlock,\\n        uint256 _path,\\n        bytes32[] memory _siblings\\n    ) public pure returns (bool) {\\n        // First compute the leaf node\\n        bytes32 calculatedRoot = computeInclusionProofRoot(\\n            _dataBlock,\\n            _path,\\n            _siblings\\n        );\\n        return calculatedRoot == _root;\\n    }\\n\\n    /**\\n     * @notice Verify an inclusion proof.\\n     * @param _root The root of the tree we are verifying inclusion for.\\n     * @param _leaf The data block we're verifying inclusion for.\\n     * @param _path The path from the leaf to the root.\\n     * @param _siblings The sibling nodes along the way.\\n     * @return The next level of the tree\\n     * NOTE: This is a stateless operation\\n     */\\n    function verifyLeaf(\\n        bytes32 _root,\\n        bytes32 _leaf,\\n        uint256 _path,\\n        bytes32[] memory _siblings\\n    ) public pure returns (bool) {\\n        bytes32 calculatedRoot = computeInclusionProofRootWithLeaf(\\n            _leaf,\\n            _path,\\n            _siblings\\n        );\\n        return calculatedRoot == _root;\\n    }\\n\\n    /**\\n     * @notice Update a leaf using siblings and root\\n     *         This is a stateless operation\\n     * @param _leaf The leaf we're updating.\\n     * @param _path The path from the leaf to the root / the index of the leaf.\\n     * @param _siblings The sibling nodes along the way.\\n     * @return Updated root\\n     */\\n    function updateLeafWithSiblings(\\n        bytes32 _leaf,\\n        uint256 _path,\\n        bytes32[] memory _siblings\\n    ) public pure returns (bytes32) {\\n        bytes32 computedNode = _leaf;\\n        for (uint256 i = 0; i < _siblings.length; i++) {\\n            bytes32 parent;\\n            bytes32 sibling = _siblings[i];\\n            uint8 isComputedRightSibling = getNthBitFromRight(_path, i);\\n            if (isComputedRightSibling == 0) {\\n                parent = getParent(computedNode, sibling);\\n            } else {\\n                parent = getParent(sibling, computedNode);\\n            }\\n            computedNode = parent;\\n        }\\n        return computedNode;\\n    }\\n\\n    /**\\n     * @notice Get the parent of two children nodes in the tree\\n     * @param _left The left child\\n     * @param _right The right child\\n     * @return The parent node\\n     */\\n    function getParent(bytes32 _left, bytes32 _right)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(_left, _right));\\n    }\\n\\n    /**\\n     * @notice get the n'th bit in a uint.\\n     *         For instance, if exampleUint=binary(11), getNth(exampleUint, 0) == 1, getNth(2, 1) == 1\\n     * @param _intVal The uint we are extracting a bit out of\\n     * @param _index The index of the bit we want to extract\\n     * @return The bit (1 or 0) in a uint8\\n     */\\n    function getNthBitFromRight(uint256 _intVal, uint256 _index)\\n        public\\n        pure\\n        returns (uint8)\\n    {\\n        return uint8((_intVal >> _index) & 1);\\n    }\\n\\n    /**\\n     * @notice Get the right sibling key. Note that these keys overwrite the first bit of the hash\\n               to signify if it is on the right side of the parent or on the left\\n     * @param _parent The parent node\\n     * @return the key for the left sibling (0 as the first bit)\\n     */\\n    function getLeftSiblingKey(bytes32 _parent) public pure returns (bytes32) {\\n        return\\n            _parent &\\n            0x0111111111111111111111111111111111111111111111111111111111111111;\\n    }\\n\\n    /**\\n     * @notice Get the right sibling key. Note that these keys overwrite the first bit of the hash\\n               to signify if it is on the right side of the parent or on the left\\n     * @param _parent The parent node\\n     * @return the key for the right sibling (1 as the first bit)\\n     */\\n    function getRightSiblingKey(bytes32 _parent) public pure returns (bytes32) {\\n        return\\n            _parent |\\n            0x1000000000000000000000000000000000000000000000000000000000000000;\\n    }\\n\\n    function pathToIndex(uint256 path, uint256 height)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 result = 0;\\n        for (uint256 i = 0; i < height; i++) {\\n            uint8 temp = getNthBitFromRight(path, i);\\n            // UNSAFE FIX THIS\\n            result = result + (temp * (2**i));\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/NameRegistry.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\n\\ncontract NameRegistry {\\n    struct ContractDetails {\\n        // registered contract address\\n        address contractAddress;\\n    }\\n    event RegisteredNewContract(bytes32 name, address contractAddr);\\n    mapping(bytes32 => ContractDetails) registry;\\n\\n    function registerName(bytes32 name, address addr) external returns (bool) {\\n        ContractDetails memory info = registry[name];\\n        // create info if it doesn't exist in the registry\\n        if (info.contractAddress == address(0)) {\\n            info.contractAddress = addr;\\n            registry[name] = info;\\n            // added to registry\\n            return true;\\n        } else {\\n            // already was registered\\n            return false;\\n        }\\n    }\\n\\n    function getContractDetails(bytes32 name) external view returns (address) {\\n        return (registry[name].contractAddress);\\n    }\\n\\n    function updateContractDetails(bytes32 name, address addr) external {\\n        // TODO not sure if we should do this\\n        // If we do we need a plan on how to remove this\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\n\\n// ERC20 token interface\\ncontract IERC20 {\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) public returns (bool) {}\\n\\n    function transfer(address recipient, uint256 value) public returns (bool) {}\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/ITokenRegistry.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\n\\n// token registry contract interface\\ncontract ITokenRegistry {\\n    uint256 public numTokens;\\n    mapping(address => bool) public pendingRegistrations;\\n    mapping(uint256 => address) public registeredTokens;\\n\\n    function requestTokenRegistration(address tokenContract) public {}\\n\\n    function finaliseTokenRegistration(address tokenContract) public {}\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/ECVerify.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\n\\nlibrary ECVerify {\\n    function ecrecovery(bytes32 hash, bytes memory sig)\\n        public\\n        pure\\n        returns (address)\\n    {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        if (sig.length != 65) {\\n            return address(0x0);\\n        }\\n\\n        assembly {\\n            r := mload(add(sig, 32))\\n            s := mload(add(sig, 64))\\n            v := and(mload(add(sig, 65)), 255)\\n        }\\n\\n        // https://github.com/ethereum/go-ethereum/issues/2053\\n        if (v < 27) {\\n            v += 27;\\n        }\\n\\n        if (v != 27 && v != 28) {\\n            return address(0x0);\\n        }\\n\\n        // get address out of hash and signature\\n        address result = ecrecover(hash, v, r, s);\\n\\n        // ecrecover returns zero on error\\n        require(result != address(0x0));\\n\\n        return result;\\n    }\\n\\n    function ecrecovery(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public pure returns (address) {\\n        // get address out of hash and signature\\n        address result = ecrecover(hash, v, r, s);\\n\\n        // ecrecover returns zero on error\\n        require(result != address(0x0));\\n\\n        return result;\\n    }\\n\\n    function ecverify(\\n        bytes32 hash,\\n        bytes memory sig,\\n        address signer\\n    ) public pure returns (bool) {\\n        return signer == ecrecovery(hash, sig);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/ParamManager.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\n\\nlibrary ParamManager {\\n    function DEPOSIT_MANAGER() public pure returns (bytes32) {\\n        return keccak256(\\\"deposit_manager\\\");\\n    }\\n\\n    function WITHDRAW_MANAGER() public pure returns (bytes32) {\\n        return keccak256(\\\"withdraw_manager\\\");\\n    }\\n\\n    function TOKEN() public pure returns (bytes32) {\\n        return keccak256(\\\"token\\\");\\n    }\\n\\n    function POB() public pure returns (bytes32) {\\n        return keccak256(\\\"pob\\\");\\n    }\\n\\n    function Governance() public pure returns (bytes32) {\\n        return keccak256(\\\"governance\\\");\\n    }\\n\\n    function ROLLUP_CORE() public pure returns (bytes32) {\\n        return keccak256(\\\"rollup_core\\\");\\n    }\\n\\n    function ACCOUNTS_TREE() public pure returns (bytes32) {\\n        return keccak256(\\\"accounts_tree\\\");\\n    }\\n\\n    function LOGGER() public pure returns (bytes32) {\\n        return keccak256(\\\"logger\\\");\\n    }\\n\\n    function MERKLE_UTILS() public pure returns (bytes32) {\\n        return keccak256(\\\"merkle_lib\\\");\\n    }\\n\\n    function PARAM_MANAGER() public pure returns (bytes32) {\\n        return keccak256(\\\"param_manager\\\");\\n    }\\n\\n    function TOKEN_REGISTRY() public pure returns (bytes32) {\\n        return keccak256(\\\"token_registry\\\");\\n    }\\n\\n    function FRAUD_PROOF() public pure returns (bytes32) {\\n        return keccak256(\\\"fraud_proof\\\");\\n    }\\n\\n    bytes32 public constant _CHAIN_ID = keccak256(\\\"opru-123\\\");\\n\\n    function CHAIN_ID() public pure returns (bytes32) {\\n        return _CHAIN_ID;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/RollupUtils.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\npragma experimental ABIEncoderV2;\\n\\nimport { Types } from \\\"./Types.sol\\\";\\n\\nlibrary RollupUtils {\\n    // ---------- Account Related Utils -------------------\\n    function PDALeafToHash(Types.PDALeaf memory _PDA_Leaf)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(_PDA_Leaf.pubkey));\\n    }\\n\\n    // returns a new User Account with updated balance\\n    function UpdateBalanceInAccount(\\n        Types.UserAccount memory original_account,\\n        uint256 new_balance\\n    ) public pure returns (Types.UserAccount memory updated_account) {\\n        original_account.balance = new_balance;\\n        return original_account;\\n    }\\n\\n    function BalanceFromAccount(Types.UserAccount memory account)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return account.balance;\\n    }\\n\\n    // AccountFromBytes decodes the bytes to account\\n    function AccountFromBytes(bytes memory accountBytes)\\n        public\\n        pure\\n        returns (\\n            uint256 ID,\\n            uint256 balance,\\n            uint256 nonce,\\n            uint256 tokenType\\n        )\\n    {\\n        return abi.decode(accountBytes, (uint256, uint256, uint256, uint256));\\n    }\\n\\n    //\\n    // BytesFromAccount and BytesFromAccountDeconstructed do the same thing i.e encode account to bytes\\n    //\\n    function BytesFromAccount(Types.UserAccount memory account)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory data = abi.encodePacked(\\n            account.ID,\\n            account.balance,\\n            account.nonce,\\n            account.tokenType\\n        );\\n\\n        return data;\\n    }\\n\\n    function BytesFromAccountDeconstructed(\\n        uint256 ID,\\n        uint256 balance,\\n        uint256 nonce,\\n        uint256 tokenType\\n    ) public pure returns (bytes memory) {\\n        return abi.encodePacked(ID, balance, nonce, tokenType);\\n    }\\n\\n    //\\n    // HashFromAccount and getAccountHash do the same thing i.e hash account\\n    //\\n    function getAccountHash(\\n        uint256 id,\\n        uint256 balance,\\n        uint256 nonce,\\n        uint256 tokenType\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                BytesFromAccountDeconstructed(id, balance, nonce, tokenType)\\n            );\\n    }\\n\\n    function HashFromAccount(Types.UserAccount memory account)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                BytesFromAccountDeconstructed(\\n                    account.ID,\\n                    account.balance,\\n                    account.nonce,\\n                    account.tokenType\\n                )\\n            );\\n    }\\n\\n    // ---------- Tx Related Utils -------------------\\n    function CompressTx(Types.Transaction memory _tx)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        return\\n            abi.encode(_tx.fromIndex, _tx.toIndex, _tx.amount, _tx.signature);\\n    }\\n\\n    function DecompressTx(bytes memory txBytes)\\n        public\\n        pure\\n        returns (\\n            uint256 from,\\n            uint256 to,\\n            uint256 nonce,\\n            bytes memory sig\\n        )\\n    {\\n        return abi.decode(txBytes, (uint256, uint256, uint256, bytes));\\n    }\\n\\n    function CompressTxWithMessage(bytes memory message, bytes memory sig)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        Types.Transaction memory _tx = TxFromBytes(message);\\n        return abi.encode(_tx.fromIndex, _tx.toIndex, _tx.amount, sig);\\n    }\\n\\n    // Decoding transaction from bytes\\n    function TxFromBytesDeconstructed(bytes memory txBytes)\\n        public\\n        pure\\n        returns (\\n            uint256 from,\\n            uint256 to,\\n            uint256 tokenType,\\n            uint256 nonce,\\n            uint256 txType,\\n            uint256 amount\\n        )\\n    {\\n        return\\n            abi.decode(\\n                txBytes,\\n                (uint256, uint256, uint256, uint256, uint256, uint256)\\n            );\\n    }\\n\\n    function TxFromBytes(bytes memory txBytes)\\n        public\\n        pure\\n        returns (Types.Transaction memory)\\n    {\\n        Types.Transaction memory transaction;\\n        (\\n            transaction.fromIndex,\\n            transaction.toIndex,\\n            transaction.tokenType,\\n            transaction.nonce,\\n            transaction.txType,\\n            transaction.amount\\n        ) = abi.decode(\\n            txBytes,\\n            (uint256, uint256, uint256, uint256, uint256, uint256)\\n        );\\n        return transaction;\\n    }\\n\\n    //\\n    // BytesFromTx and BytesFromTxDeconstructed do the same thing i.e encode transaction to bytes\\n    //\\n    function BytesFromTx(Types.Transaction memory _tx)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        return\\n            abi.encodePacked(\\n                _tx.fromIndex,\\n                _tx.toIndex,\\n                _tx.tokenType,\\n                _tx.nonce,\\n                _tx.txType,\\n                _tx.amount\\n            );\\n    }\\n\\n    function BytesFromTxDeconstructed(\\n        uint256 from,\\n        uint256 to,\\n        uint256 tokenType,\\n        uint256 nonce,\\n        uint256 txType,\\n        uint256 amount\\n    ) public pure returns (bytes memory) {\\n        return abi.encodePacked(from, to, tokenType, nonce, txType, amount);\\n    }\\n\\n    //\\n    // HashFromTx and getTxSignBytes do the same thing i.e get the tx data to be signed\\n    //\\n    function HashFromTx(Types.Transaction memory _tx)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                BytesFromTxDeconstructed(\\n                    _tx.fromIndex,\\n                    _tx.toIndex,\\n                    _tx.tokenType,\\n                    _tx.nonce,\\n                    _tx.txType,\\n                    _tx.amount\\n                )\\n            );\\n    }\\n\\n    function getTxSignBytes(\\n        uint256 fromIndex,\\n        uint256 toIndex,\\n        uint256 tokenType,\\n        uint256 txType,\\n        uint256 nonce,\\n        uint256 amount\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                BytesFromTxDeconstructed(\\n                    fromIndex,\\n                    toIndex,\\n                    tokenType,\\n                    nonce,\\n                    txType,\\n                    amount\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the address from the pubkey\\n     * @param pub is the pubkey\\n     * @return Returns the address that has been calculated from the pubkey\\n     */\\n    function calculateAddress(bytes memory pub)\\n        public\\n        pure\\n        returns (address addr)\\n    {\\n        bytes32 hash = keccak256(pub);\\n        assembly {\\n            mstore(0, hash)\\n            addr := mload(0)\\n        }\\n    }\\n\\n    function GetGenesisLeaves() public view returns (bytes32[2] memory leaves) {\\n        Types.UserAccount memory account1 = Types.UserAccount({\\n            ID: 0,\\n            tokenType: 0,\\n            balance: 0,\\n            nonce: 0\\n        });\\n        Types.UserAccount memory account2 = Types.UserAccount({\\n            ID: 1,\\n            tokenType: 0,\\n            balance: 0,\\n            nonce: 0\\n        });\\n        leaves[0] = HashFromAccount(account1);\\n        leaves[1] = HashFromAccount(account2);\\n    }\\n\\n    function GetGenesisDataBlocks()\\n        public\\n        view\\n        returns (bytes[2] memory dataBlocks)\\n    {\\n        Types.UserAccount memory account1 = Types.UserAccount({\\n            ID: 0,\\n            tokenType: 0,\\n            balance: 0,\\n            nonce: 0\\n        });\\n        Types.UserAccount memory account2 = Types.UserAccount({\\n            ID: 1,\\n            tokenType: 0,\\n            balance: 0,\\n            nonce: 0\\n        });\\n        dataBlocks[0] = BytesFromAccount(account1);\\n        dataBlocks[1] = BytesFromAccount(account2);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/Types.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\n\\n/**\\n * @title DataTypes\\n */\\nlibrary Types {\\n    // We define Usage for a batch or for a tx\\n    // to check if the usage of a batch and all txs in it are the same\\n    enum Usage {\\n        Genesis, // The Genesis type is only applicable to batch but not tx\\n        Transfer,\\n        Deposit\\n    }\\n    // PDALeaf represents the leaf in\\n    // Pubkey DataAvailability Tree\\n    struct PDALeaf {\\n        bytes pubkey;\\n    }\\n\\n    // Batch represents the batch submitted periodically to the ethereum chain\\n    struct Batch {\\n        bytes32 stateRoot;\\n        bytes32 accountRoot;\\n        bytes32 depositTree;\\n        address committer;\\n        bytes32 txRoot;\\n        uint256 stakeCommitted;\\n        uint256 finalisesOn;\\n        uint256 timestamp;\\n        Usage batchType;\\n    }\\n\\n    // Transaction represents how each transaction looks like for\\n    // this rollup chain\\n    struct Transaction {\\n        uint256 fromIndex;\\n        uint256 toIndex;\\n        uint256 tokenType;\\n        uint256 nonce;\\n        uint256 txType;\\n        uint256 amount;\\n        bytes signature;\\n    }\\n\\n    // AccountInclusionProof consists of the following fields\\n    // 1. Path to the account leaf from root in the balances tree\\n    // 2. Actual data stored in the leaf\\n    struct AccountInclusionProof {\\n        uint256 pathToAccount;\\n        UserAccount account;\\n    }\\n\\n    struct TranasctionInclusionProof {\\n        uint256 pathToTx;\\n        Transaction data;\\n    }\\n\\n    struct PDAInclusionProof {\\n        uint256 pathToPubkey;\\n        PDALeaf pubkey_leaf;\\n    }\\n\\n    // UserAccount contains the actual data stored in the leaf of balance tree\\n    struct UserAccount {\\n        // ID is the path to the pubkey in the PDA tree\\n        uint256 ID;\\n        uint256 tokenType;\\n        uint256 balance;\\n        uint256 nonce;\\n    }\\n\\n    struct AccountMerkleProof {\\n        AccountInclusionProof accountIP;\\n        bytes32[] siblings;\\n    }\\n\\n    struct AccountProofs {\\n        AccountMerkleProof from;\\n        AccountMerkleProof to;\\n    }\\n\\n    struct BatchValidationProofs {\\n        AccountProofs[] accountProofs;\\n        PDAMerkleProof[] pdaProof;\\n    }\\n\\n    struct TransactionMerkleProof {\\n        TranasctionInclusionProof _tx;\\n        bytes32[] siblings;\\n    }\\n\\n    struct PDAMerkleProof {\\n        PDAInclusionProof _pda;\\n        bytes32[] siblings;\\n    }\\n\\n    enum ErrorCode {\\n        NoError,\\n        InvalidTokenAddress,\\n        InvalidTokenAmount,\\n        NotEnoughTokenBalance,\\n        BadFromTokenType,\\n        BadToTokenType\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"/contracts/libs/ECVerify.sol\": {\r\n        \"ECVerify\": \"0x3529Fd3c2EDD0D6147f1dAecC91e16E7A0600826\"\r\n      },\r\n      \"/contracts/libs/ParamManager.sol\": {\r\n        \"ParamManager\": \"0x874dF019F8Ac3c7a2575c0F513e300915e4A8Dc1\"\r\n      },\r\n      \"/contracts/libs/RollupUtils.sol\": {\r\n        \"RollupUtils\": \"0x9E649D34aC3097E3B68c37FCb94D76588cA9DE54\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registryAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"account\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"numOfTokens\",\"type\":\"uint256\"}],\"name\":\"AddTokensToAccount\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"updatedAccount\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pathToAccount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"account\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.AccountInclusionProof\",\"name\":\"accountIP\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Types.AccountMerkleProof\",\"name\":\"_merkle_proof\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.Transaction\",\"name\":\"transaction\",\"type\":\"tuple\"}],\"name\":\"ApplyTx\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"updatedAccount\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"account\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"numOfTokens\",\"type\":\"uint256\"}],\"name\":\"RemoveTokensFromAccount\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"updatedAccount\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"new_account\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pathToAccount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"account\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.AccountInclusionProof\",\"name\":\"accountIP\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Types.AccountMerkleProof\",\"name\":\"_merkle_proof\",\"type\":\"tuple\"}],\"name\":\"UpdateAccountWithSiblings\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pathToAccount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"account\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.AccountInclusionProof\",\"name\":\"accountIP\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Types.AccountMerkleProof\",\"name\":\"merkle_proof\",\"type\":\"tuple\"}],\"name\":\"ValidateAccountMP\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_accountsRoot\",\"type\":\"bytes32\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pathToPubkey\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.PDALeaf\",\"name\":\"pubkey_leaf\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.PDAInclusionProof\",\"name\":\"_pda\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Types.PDAMerkleProof\",\"name\":\"_from_pda_proof\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"from_index\",\"type\":\"uint256\"}],\"name\":\"ValidatePubkeyAvailability\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.Transaction\",\"name\":\"_tx\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pathToPubkey\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.PDALeaf\",\"name\":\"pubkey_leaf\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.PDAInclusionProof\",\"name\":\"_pda\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Types.PDAMerkleProof\",\"name\":\"_from_pda_proof\",\"type\":\"tuple\"}],\"name\":\"ValidateSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZERO_BYTES32\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.Transaction[]\",\"name\":\"_txs\",\"type\":\"tuple[]\"}],\"name\":\"generateTxRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"txRoot\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"contract Governance\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"merkleUtils\",\"outputs\":[{\"internalType\":\"contract MerkleTreeUtils\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nameRegistry\",\"outputs\":[{\"internalType\":\"contract NameRegistry\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"accountsRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.Transaction[]\",\"name\":\"_txs\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pathToAccount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"account\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.AccountInclusionProof\",\"name\":\"accountIP\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Types.AccountMerkleProof\",\"name\":\"from\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pathToAccount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"account\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.AccountInclusionProof\",\"name\":\"accountIP\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Types.AccountMerkleProof\",\"name\":\"to\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.AccountProofs[]\",\"name\":\"accountProofs\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pathToPubkey\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.PDALeaf\",\"name\":\"pubkey_leaf\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.PDAInclusionProof\",\"name\":\"_pda\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Types.PDAMerkleProof[]\",\"name\":\"pdaProof\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Types.BatchValidationProofs\",\"name\":\"batchProofs\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"expectedTxRoot\",\"type\":\"bytes32\"}],\"name\":\"processBatch\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_balanceRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_accountsRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.Transaction\",\"name\":\"_tx\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pathToPubkey\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.PDALeaf\",\"name\":\"pubkey_leaf\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.PDAInclusionProof\",\"name\":\"_pda\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Types.PDAMerkleProof\",\"name\":\"_from_pda_proof\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pathToAccount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"account\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.AccountInclusionProof\",\"name\":\"accountIP\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Types.AccountMerkleProof\",\"name\":\"from\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pathToAccount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"account\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.AccountInclusionProof\",\"name\":\"accountIP\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Types.AccountMerkleProof\",\"name\":\"to\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.AccountProofs\",\"name\":\"accountProofs\",\"type\":\"tuple\"}],\"name\":\"processTx\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"enum Types.ErrorCode\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenRegistry\",\"outputs\":[{\"internalType\":\"contract ITokenRegistry\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.Transaction\",\"name\":\"_tx\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"_from_account\",\"type\":\"tuple\"}],\"name\":\"validateTxBasic\",\"outputs\":[{\"internalType\":\"enum Types.ErrorCode\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"FraudProof","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000deb8e93884732a191052af12fb20c42b0e701c16","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}