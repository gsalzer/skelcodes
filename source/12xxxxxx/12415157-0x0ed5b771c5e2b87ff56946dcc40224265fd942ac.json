{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IUniswapV2Router {\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n}\r\n\r\ncontract AuthorisedTokenSwap {\r\n    mapping(bytes32 => uint) approvals;\r\n    \r\n    event Approval(address indexed owner, address indexed trader, address indexed router, address[] path, uint amount);\r\n    event Swap(address indexed owner, address indexed trader, address indexed router, address[] path, uint[] amounts);\r\n    \r\n    function approval(address owner, address trader, address router, address[] calldata path) public view returns(uint) {\r\n        return approvals[getApprovalHash(owner, trader, router, path)];\r\n    }\r\n    \r\n    function setApproval(address trader, address router, address[] calldata path, uint amount) public {\r\n        approvals[getApprovalHash(msg.sender, trader, router, path)] = amount;\r\n        emit Approval(msg.sender, trader, router, path, amount);\r\n    }\r\n    \r\n    function swapExactTokensForTokens(address owner, IUniswapV2Router router, uint amountIn, uint amountOutMin, address[] calldata path, uint deadline)\r\n        external returns (uint[] memory swapAmounts) \r\n    {\r\n        require(path.length >= 2);\r\n        approvals[getApprovalHash(owner, msg.sender, address(router), path)] -= amountIn; // 0.8.x uses safemath by default\r\n        \r\n        IERC20 sourceToken = IERC20(path[0]);\r\n        uint balanceBefore = sourceToken.balanceOf(address(this));\r\n\r\n        require(sourceToken.transferFrom(owner, address(this), amountIn), \"Transfer in failed\");\r\n        require(sourceToken.approve(address(router), amountIn), \"Approve failed\");\r\n        swapAmounts = router.swapExactTokensForTokens(amountIn, amountOutMin, path, owner, deadline);\r\n        emit Swap(owner, msg.sender, address(router), path, swapAmounts);\r\n        \r\n        // Check the swap was successful\r\n        require(swapAmounts[0] == amountIn, \"Wrong number of source tokens deducted\");\r\n        require(swapAmounts[swapAmounts.length - 1] >= amountOutMin, \"Insufficient destination tokens received\");\r\n        require(sourceToken.balanceOf(address(this)) == balanceBefore, \"Tokens left in contract\");\r\n    }\r\n    \r\n    function getApprovalHash(address owner, address trader, address router, address[] calldata path) internal pure returns(bytes32) {\r\n        return keccak256(abi.encodePacked(owner, trader, router, path));\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"approval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Router\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"swapAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AuthorisedTokenSwap","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f0c187071849cbca58ac7108068f9c0447b8f6a9d1d7c05659704b97aa753a0f"}]}