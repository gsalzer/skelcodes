{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BoringCryptoDashboardV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function owner() external view returns (address);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IShibaSwapPoolNames {\\n    function logos(uint256) external view returns(string memory);\\n    function names(uint256) external view returns(string memory);\\n    function setPoolInfo(uint256 pid, string memory logo, string memory name) external;\\n}\\n\\ninterface IBoneToken is IERC20{\\n    function delegates(address who) external view returns(address);\\n    function getCurrentVotes(address who) external view returns(uint256);\\n    function nonces(address who) external view returns(uint256);\\n}\\n\\ninterface ITopDog {\\n    function BONUS_MULTIPLIER() external view returns (uint256);\\n    function bonusEndBlock() external view returns (uint256);\\n    function devaddr() external view returns (address);\\n    function migrator() external view returns (address);\\n    function owner() external view returns (address);\\n    function startBlock() external view returns (uint256);\\n    function bone() external view returns (address);\\n    function bonePerBlock() external view returns (uint256);\\n    function totalAllocPoint() external view returns (uint256);\\n\\n    function poolLength() external view returns (uint256);\\n    function poolInfo(uint256 nr) external view returns (address, uint256, uint256, uint256);\\n    function userInfo(uint256 nr, address who) external view returns (uint256, uint256);\\n    function pendingBone(uint256 nr, address who) external view returns (uint256);\\n}\\n\\ninterface IFactory {\\n    function allPairsLength() external view returns (uint256);\\n    function allPairs(uint256 i) external view returns (address);\\n    function getPair(address token0, address token1) external view returns (address);\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n}\\n\\ninterface IPair is IERC20 {\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112, uint112, uint32);\\n}\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a); return c; }\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a); uint256 c = a - b; return c; }\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; }\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b > 0); uint256 c = a / b; return c; }\\n}\\n\\ncontract Ownable {\\n    address public owner;\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () internal {\\n        address msgSender = msg.sender;\\n        owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n}\\n\\ncontract BoringCryptoTokenScanner\\n{\\n    using SafeMath for uint256;\\n\\n    struct Balance {\\n        address token;\\n        uint256 balance;\\n    }\\n\\n    struct BalanceFull {\\n        address token;\\n        uint256 balance;\\n        uint256 rate;\\n    }\\n\\n    struct TokenInfo {\\n        address token;\\n        uint256 decimals;\\n        string name;\\n        string symbol;\\n    }\\n\\n    function getTokenInfo(address[] calldata addresses) public view returns(TokenInfo[] memory) {\\n        TokenInfo[] memory infos = new TokenInfo[](addresses.length);\\n\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            IERC20 token = IERC20(addresses[i]);\\n            infos[i].token = address(token);\\n\\n            infos[i].name = token.name();\\n            infos[i].symbol = token.symbol();\\n            infos[i].decimals = token.decimals();\\n        }\\n\\n        return infos;\\n    }\\n\\n    function findBalances(address who, address[] calldata addresses) public view returns(Balance[] memory) {\\n        uint256 balanceCount;\\n\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            if (IERC20(addresses[i]).balanceOf(who) > 0) {\\n                balanceCount++;\\n            }\\n        }\\n\\n        Balance[] memory balances = new Balance[](balanceCount);\\n\\n        balanceCount = 0;\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            IERC20 token = IERC20(addresses[i]);\\n            uint256 balance = token.balanceOf(who);\\n            if (balance > 0) {\\n                balances[balanceCount].token = address(token);\\n                balances[balanceCount].balance = token.balanceOf(who);\\n                balanceCount++;\\n            }\\n        }\\n\\n        return balances;\\n    }\\n\\n    function getBalances(address who, address[] calldata addresses, IFactory factory, address currency) public view returns(BalanceFull[] memory) {\\n        BalanceFull[] memory balances = new BalanceFull[](addresses.length);\\n\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            IERC20 token = IERC20(addresses[i]);\\n            balances[i].token = address(token);\\n            balances[i].balance = token.balanceOf(who);\\n\\n            IPair pair = IPair(factory.getPair(addresses[i], currency));\\n            if(address(pair) != address(0))\\n            {\\n                uint256 reserveCurrency;\\n                uint256 reserveToken;\\n                if (pair.token0() == currency) {\\n                    (reserveCurrency, reserveToken,) = pair.getReserves();\\n                }\\n                else\\n                {\\n                    (reserveToken, reserveCurrency,) = pair.getReserves();\\n                }\\n                balances[i].rate = reserveToken * 1e18 / reserveCurrency;\\n            }\\n        }\\n\\n        return balances;\\n    }\\n\\n    struct Factory {\\n        IFactory factory;\\n        uint256 allPairsLength;\\n        address feeTo;\\n        address feeToSetter;\\n    }\\n\\n    function getFactoryInfo(IFactory[] calldata addresses) public view returns(Factory[] memory) {\\n        Factory[] memory factories = new Factory[](addresses.length);\\n\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            IFactory factory = addresses[i];\\n            factories[i].factory = factory;\\n\\n            factories[i].allPairsLength = factory.allPairsLength();\\n            factories[i].feeTo = factory.feeTo();\\n            factories[i].feeToSetter = factory.feeToSetter();\\n        }\\n\\n        return factories;\\n    }\\n\\n    struct Pair {\\n        address token;\\n        address token0;\\n        address token1;\\n    }\\n\\n    function getPairs(IFactory factory, uint256 fromID, uint256 toID) public view returns(Pair[] memory) {\\n        if (toID == 0){\\n            toID = factory.allPairsLength();\\n        }\\n\\n        Pair[] memory pairs = new Pair[](toID - fromID);\\n\\n        for(uint256 id = fromID; id < toID; id++) {\\n            address token = factory.allPairs(id);\\n            uint256 i = id - fromID;\\n            pairs[i].token = token;\\n            pairs[i].token0 = IPair(token).token0();\\n            pairs[i].token1 = IPair(token).token1();\\n        }\\n        return pairs;\\n    }\\n\\n    function findPairs(address who, IFactory factory, uint256 fromID, uint256 toID) public view returns(Pair[] memory) {\\n        if (toID == 0){\\n            toID = factory.allPairsLength();\\n        }\\n\\n        uint256 pairCount;\\n\\n        for(uint256 id = fromID; id < toID; id++) {\\n            address token = factory.allPairs(id);\\n            if (IERC20(token).balanceOf(who) > 0) {\\n                pairCount++;\\n            }\\n        }\\n\\n        Pair[] memory pairs = new Pair[](pairCount);\\n\\n        pairCount = 0;\\n        for(uint256 id = fromID; id < toID; id++) {\\n            address token = factory.allPairs(id);\\n            uint256 balance = IERC20(token).balanceOf(who);\\n            if (balance > 0) {\\n                pairs[pairCount].token = token;\\n                pairs[pairCount].token0 = IPair(token).token0();\\n                pairs[pairCount].token1 = IPair(token).token1();\\n                pairCount++;\\n            }\\n        }\\n\\n        return pairs;\\n    }\\n\\n    struct PairFull {\\n        address token;\\n        address token0;\\n        address token1;\\n        uint256 reserve0;\\n        uint256 reserve1;\\n        uint256 totalSupply;\\n        uint256 balance;\\n    }\\n\\n    function getPairsFull(address who, address[] calldata addresses) public view returns(PairFull[] memory) {\\n        PairFull[] memory pairs = new PairFull[](addresses.length);\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            address token = addresses[i];\\n            pairs[i].token = token;\\n            pairs[i].token0 = IPair(token).token0();\\n            pairs[i].token1 = IPair(token).token1();\\n            (uint256 reserve0, uint256 reserve1,) = IPair(token).getReserves();\\n            pairs[i].reserve0 = reserve0;\\n            pairs[i].reserve1 = reserve1;\\n            pairs[i].balance = IERC20(token).balanceOf(who);\\n            pairs[i].totalSupply = IERC20(token).totalSupply();\\n        }\\n        return pairs;\\n    }\\n}\\n\\ncontract BoringCryptoDashboardV2\\n{\\n    using SafeMath for uint256;\\n\\n    ITopDog topdog;\\n\\n    address uniFactory;\\n    address sushiFactory;\\n    address shibaFactory;\\n    address weth;\\n\\n    constructor(\\n        address _topdog,\\n        address _uniFactory,\\n        address _sushiFactory,\\n        address _shibaFactory,\\n        address _weth\\n    ) public {\\n        topdog = ITopDog(_topdog);\\n        uniFactory = _uniFactory;\\n        sushiFactory = _sushiFactory;\\n        shibaFactory = _shibaFactory;\\n        weth = _weth;\\n    }\\n\\n    struct PairFull {\\n        address token;\\n        address token0;\\n        address token1;\\n        uint256 reserve0;\\n        uint256 reserve1;\\n        uint256 totalSupply;\\n        uint256 balance;\\n    }\\n\\n    function getPairsFull(address who, address[] calldata addresses) public view returns(PairFull[] memory) {\\n        PairFull[] memory pairs = new PairFull[](addresses.length);\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            address token = addresses[i];\\n            pairs[i].token = token;\\n            pairs[i].token0 = IPair(token).token0();\\n            pairs[i].token1 = IPair(token).token1();\\n            (uint256 reserve0, uint256 reserve1,) = IPair(token).getReserves();\\n            pairs[i].reserve0 = reserve0;\\n            pairs[i].reserve1 = reserve1;\\n            pairs[i].balance = IERC20(token).balanceOf(who);\\n            pairs[i].totalSupply = IERC20(token).totalSupply();\\n        }\\n        return pairs;\\n    }\\n\\n    struct PoolsInfo {\\n        uint256 totalAllocPoint;\\n        uint256 poolLength;\\n    }\\n\\n    struct PoolInfo {\\n        uint256 pid;\\n        IPair lpToken;           // Address of LP token contract.\\n        uint256 allocPoint;       // How many allocation points assigned to this pool. SUSHIs to distribute per block.\\n        address token0;\\n        address token1;\\n    }\\n\\n    function getPools(uint256[] calldata pids) public view returns(PoolsInfo memory, PoolInfo[] memory) {\\n        PoolsInfo memory info;\\n        info.totalAllocPoint = topdog.totalAllocPoint();\\n        uint256 poolLength = topdog.poolLength();\\n        info.poolLength = poolLength;\\n\\n        PoolInfo[] memory pools = new PoolInfo[](pids.length);\\n\\n        for (uint256 i = 0; i < pids.length; i++) {\\n            pools[i].pid = pids[i];\\n            (address lpToken, uint256 allocPoint,,) = topdog.poolInfo(pids[i]);\\n            IPair uniV2 = IPair(lpToken);\\n            pools[i].lpToken = uniV2;\\n            pools[i].allocPoint = allocPoint;\\n\\n            pools[i].token0 = uniV2.token0();\\n            pools[i].token1 = uniV2.token1();\\n        }\\n        return (info, pools);\\n    }\\n\\n    function findPools(address who, uint256[] calldata pids) public view returns(PoolInfo[] memory) {\\n        uint256 count;\\n\\n        for (uint256 i = 0; i < pids.length; i++) {\\n            (uint256 balance,) = topdog.userInfo(pids[i], who);\\n            if (balance > 0) {\\n                count++;\\n            }\\n        }\\n\\n        PoolInfo[] memory pools = new PoolInfo[](count);\\n\\n        count = 0;\\n        for (uint256 i = 0; i < pids.length; i++) {\\n            (uint256 balance,) = topdog.userInfo(pids[i], who);\\n            if (balance > 0) {\\n                pools[count].pid = pids[i];\\n                (address lpToken, uint256 allocPoint,,) = topdog.poolInfo(pids[i]);\\n                IPair uniV2 = IPair(lpToken);\\n                pools[count].lpToken = uniV2;\\n                pools[count].allocPoint = allocPoint;\\n\\n                pools[count].token0 = uniV2.token0();\\n                pools[count].token1 = uniV2.token1();\\n                count++;\\n            }\\n        }\\n\\n        return pools;\\n    }\\n\\n    function getETHRate(address token) public view returns(uint256) {\\n        uint256 eth_rate = 1e18;\\n        if (token != weth)\\n        {\\n            IPair pairUniV2;\\n            IPair pairSushi;\\n            IPair pairShiba;\\n\\n            pairUniV2 = IPair(IFactory(uniFactory).getPair(token, weth));\\n            pairSushi = IPair(IFactory(sushiFactory).getPair(token, weth));\\n            pairShiba = IPair(IFactory(shibaFactory).getPair(token, weth));\\n\\n            if (address(pairUniV2) == address(0)\\n            && address(pairSushi) == address(0)\\n                && address(pairShiba) == address(0)) {\\n                return 0;\\n            }\\n\\n            uint112 reserve0UniV2; uint112 reserve1UniV2;\\n            uint112 reserve0Sushi; uint112 reserve1Sushi;\\n            uint112 reserve0Shiba; uint112 reserve1Shiba;\\n\\n            if (address(pairUniV2) != address(0)) {\\n                (reserve0UniV2, reserve1UniV2,) = pairUniV2.getReserves();\\n            }\\n            if (address(pairSushi) != address(0)) {\\n                (reserve0Sushi, reserve1Sushi,) = pairSushi.getReserves();\\n            }\\n            if (address(pairShiba) != address(0)) {\\n                (reserve0Shiba, reserve1Shiba,) = pairShiba.getReserves();\\n            }\\n\\n            if (address(pairShiba) == address(0) || reserve0UniV2 > reserve0Shiba || reserve1UniV2 > reserve1Shiba) {\\n                // return uni rate\\n                if (pairUniV2.token0() == weth) {\\n                    eth_rate = uint256(reserve1UniV2).mul(1e18).div(reserve0UniV2);\\n                } else {\\n                    eth_rate = uint256(reserve0UniV2).mul(1e18).div(reserve1UniV2);\\n                }\\n            } else if (reserve0Sushi > reserve0Shiba || reserve1Sushi > reserve1Shiba) {\\n                if (pairSushi.token0() == weth) {\\n                    eth_rate = uint256(reserve1Sushi).mul(1e18).div(reserve0Sushi);\\n                } else {\\n                    eth_rate = uint256(reserve0Sushi).mul(1e18).div(reserve1Sushi);\\n                }\\n            } else {\\n                if (pairShiba.token0() == weth) {\\n                    eth_rate = uint256(reserve1Shiba).mul(1e18).div(reserve0Shiba);\\n                } else {\\n                    eth_rate = uint256(reserve0Shiba).mul(1e18).div(reserve1Shiba);\\n                }\\n            }\\n        }\\n        return eth_rate;\\n    }\\n\\n    struct UserPoolInfo {\\n        uint256 pid;\\n        uint256 balance; // Balance of pool tokens\\n        uint256 totalSupply; // Token staked lp tokens\\n        uint256 lpBalance; // Balance of lp tokens not staked\\n        uint256 lpTotalSupply; // TotalSupply of lp tokens\\n        uint256 lpAllowance; // LP tokens approved for TopDog\\n        uint256 reserve0;\\n        uint256 reserve1;\\n        uint256 token0rate;\\n        uint256 token1rate;\\n        uint256 rewardDebt;\\n        uint256 pending; // Pending BONE\\n    }\\n\\n    function pollPools(address who, uint256[] calldata pids) public view returns(UserPoolInfo[] memory) {\\n        UserPoolInfo[] memory pools = new UserPoolInfo[](pids.length);\\n\\n        for (uint256 i = 0; i < pids.length; i++) {\\n            (uint256 amount,) = topdog.userInfo(pids[i], who);\\n            pools[i].balance = amount;\\n            pools[i].pending = topdog.pendingBone(pids[i], who);\\n\\n            (address lpToken,,,) = topdog.poolInfo(pids[i]);\\n            pools[i].pid = pids[i];\\n            IPair uniV2 = IPair(lpToken);\\n            pools[i].totalSupply = uniV2.balanceOf(address(topdog));\\n            pools[i].lpAllowance = uniV2.allowance(who, address(topdog));\\n            pools[i].lpBalance = uniV2.balanceOf(who);\\n            pools[i].lpTotalSupply = uniV2.totalSupply();\\n            pools[i].token0rate = getETHRate(uniV2.token0());\\n            pools[i].token1rate = getETHRate(uniV2.token1());\\n\\n            (uint112 reserve0, uint112 reserve1,) = uniV2.getReserves();\\n            pools[i].reserve0 = reserve0;\\n            pools[i].reserve1 = reserve1;\\n        }\\n        return pools;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 5000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_topdog\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sushiFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_shibaFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"pids\",\"type\":\"uint256[]\"}],\"name\":\"findPools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"contract IPair\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"internalType\":\"struct BoringCryptoDashboardV2.PoolInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getETHRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"getPairsFull\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringCryptoDashboardV2.PairFull[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pids\",\"type\":\"uint256[]\"}],\"name\":\"getPools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalAllocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolLength\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringCryptoDashboardV2.PoolsInfo\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"contract IPair\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"internalType\":\"struct BoringCryptoDashboardV2.PoolInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"pids\",\"type\":\"uint256[]\"}],\"name\":\"pollPools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringCryptoDashboardV2.UserPoolInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BoringCryptoDashboardV2","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"5000","ConstructorArguments":"00000000000000000000000094235659cf8b805b2c658f9ea2d6d6ddbb17c8d70000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f000000000000000000000000c0aee478e3658e2610c5f7a4a2e1777ce9e4f2ac000000000000000000000000115934131916c8b277dd010ee02de363c09d037c000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}