{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/auction/AuctionHouse.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"./Staged.sol\\\";\\nimport \\\"./AuctionHouseMath.sol\\\";\\n\\nimport \\\"./interfaces/IAuctionHouse.sol\\\";\\n\\nimport \\\"../funds/interfaces/basket/IBasketReader.sol\\\";\\nimport \\\"../oracle/interfaces/ITwap.sol\\\";\\nimport \\\"../policy/interfaces/IMonetaryPolicy.sol\\\";\\nimport \\\"../tokens/interfaces/ISupplyControlledERC20.sol\\\";\\n\\nimport \\\"../lib/BasisMath.sol\\\";\\nimport \\\"../lib/BlockNumber.sol\\\";\\nimport \\\"../lib/Recoverable.sol\\\";\\nimport \\\"../external-lib/SafeDecimalMath.sol\\\";\\nimport \\\"../tokens/SafeSupplyControlledERC20.sol\\\";\\n\\n/**\\n * @title Float Protocol Auction House\\n * @notice The contract used to sell or buy FLOAT\\n * @dev This contract does not store any assets, except for protocol fees, hence\\n * it implements an asset recovery functionality (Recoverable).\\n */\\ncontract AuctionHouse is\\n  IAuctionHouse,\\n  BlockNumber,\\n  AuctionHouseMath,\\n  AccessControl,\\n  Staged,\\n  Recoverable\\n{\\n  using SafeMath for uint256;\\n  using SafeDecimalMath for uint256;\\n  using SafeERC20 for IERC20;\\n  using SafeERC20 for ISupplyControlledERC20;\\n  using SafeSupplyControlledERC20 for ISupplyControlledERC20;\\n  using BasisMath for uint256;\\n\\n  /* ========== CONSTANTS ========== */\\n  bytes32 public constant GOVERNANCE_ROLE = keccak256(\\\"GOVERNANCE_ROLE\\\");\\n\\n  IERC20 internal immutable weth;\\n  ISupplyControlledERC20 internal immutable bank;\\n  ISupplyControlledERC20 internal immutable float;\\n  IBasketReader internal immutable basket;\\n\\n  /* ========== STATE VARIABLES ========== */\\n  // Monetary Policy Contract that decides the target price\\n  IMonetaryPolicy internal monetaryPolicy;\\n  // Provides the BANK-ETH Time Weighted Average Price (TWAP) [e27]\\n  ITwap internal bankEthOracle;\\n  // Provides the FLOAT-ETH Time Weighted Average Price (TWAP) [e27]\\n  ITwap internal floatEthOracle;\\n\\n  /// @inheritdoc IAuctionHouseState\\n  uint16 public override buffer = 10_00; // 10% default\\n\\n  /// @inheritdoc IAuctionHouseState\\n  uint16 public override protocolFee = 5_00; // 5% / 500 bps\\n\\n  /// @inheritdoc IAuctionHouseState\\n  uint32 public override allowanceCap = 10_00; // 10% / 1000 bps\\n\\n  /// @inheritdoc IAuctionHouseVariables\\n  uint64 public override round;\\n\\n  /**\\n   * @notice Allows for monetary policy updates to be enabled and disabled.\\n   */\\n  bool public shouldUpdatePolicy = true;\\n\\n  /**\\n   * Note that we choose to freeze all price values at the start of an auction.\\n   * These values are stale _by design_. The burden of price checking\\n   * is moved to the arbitrager, already vital for them to make a profit.\\n   * We don't mind these values being out of date, as we start the auctions from a position generously in favour of the protocol (assuming our target price is correct). If these market values are stale, then profit opportunity will start earlier / later, and hence close out a mispriced auction early.\\n   * We also start the auctions at `buffer`% of the price.\\n   */\\n\\n  /// @inheritdoc IAuctionHouseVariables\\n  mapping(uint64 => Auction) public override auctions;\\n\\n  /* ========== CONSTRUCTOR ========== */\\n\\n  constructor(\\n    // Dependencies\\n    address _weth,\\n    address _bank,\\n    address _float,\\n    address _basket,\\n    address _monetaryPolicy,\\n    address _gov,\\n    address _bankEthOracle,\\n    address _floatEthOracle,\\n    // Parameters\\n    uint16 _auctionDuration,\\n    uint32 _auctionCooldown,\\n    uint256 _firstAuctionBlock\\n  ) Staged(_auctionDuration, _auctionCooldown, _firstAuctionBlock) {\\n    // Tokens\\n    weth = IERC20(_weth);\\n    bank = ISupplyControlledERC20(_bank);\\n    float = ISupplyControlledERC20(_float);\\n\\n    // Basket\\n    basket = IBasketReader(_basket);\\n\\n    // Monetary Policy\\n    monetaryPolicy = IMonetaryPolicy(_monetaryPolicy);\\n    floatEthOracle = ITwap(_floatEthOracle);\\n    bankEthOracle = ITwap(_bankEthOracle);\\n\\n    emit ModifyParameters(\\\"monetaryPolicy\\\", _monetaryPolicy);\\n    emit ModifyParameters(\\\"floatEthOracle\\\", _floatEthOracle);\\n    emit ModifyParameters(\\\"bankEthOracle\\\", _bankEthOracle);\\n\\n    emit ModifyParameters(\\\"auctionDuration\\\", _auctionDuration);\\n    emit ModifyParameters(\\\"auctionCooldown\\\", _auctionCooldown);\\n    emit ModifyParameters(\\\"lastAuctionBlock\\\", lastAuctionBlock);\\n    emit ModifyParameters(\\\"buffer\\\", buffer);\\n    emit ModifyParameters(\\\"protocolFee\\\", protocolFee);\\n    emit ModifyParameters(\\\"allowanceCap\\\", allowanceCap);\\n\\n    // Roles\\n    _setupRole(DEFAULT_ADMIN_ROLE, _gov);\\n    _setupRole(GOVERNANCE_ROLE, _gov);\\n    _setupRole(RECOVER_ROLE, _gov);\\n  }\\n\\n  /* ========== MODIFIERS ========== */\\n\\n  modifier onlyGovernance {\\n    require(\\n      hasRole(GOVERNANCE_ROLE, _msgSender()),\\n      \\\"AuctionHouse/GovernanceRole\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier inExpansion {\\n    require(\\n      latestAuction().stabilisationCase == Cases.Up ||\\n        latestAuction().stabilisationCase == Cases.Restock,\\n      \\\"AuctionHouse/NotInExpansion\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier inContraction {\\n    require(\\n      latestAuction().stabilisationCase == Cases.Confidence ||\\n        latestAuction().stabilisationCase == Cases.Down,\\n      \\\"AuctionHouse/NotInContraction\\\"\\n    );\\n    _;\\n  }\\n\\n  /* ========== VIEWS ========== */\\n\\n  /// @inheritdoc IAuctionHouseDerivedState\\n  function price()\\n    public\\n    view\\n    override(IAuctionHouseDerivedState)\\n    returns (uint256 wethPrice, uint256 bankPrice)\\n  {\\n    Auction memory _latestAuction = latestAuction();\\n    uint256 _step = step();\\n\\n    wethPrice = lerp(\\n      _latestAuction.startWethPrice,\\n      _latestAuction.endWethPrice,\\n      _step,\\n      auctionDuration\\n    );\\n    bankPrice = lerp(\\n      _latestAuction.startBankPrice,\\n      _latestAuction.endBankPrice,\\n      _step,\\n      auctionDuration\\n    );\\n    return (wethPrice, bankPrice);\\n  }\\n\\n  /// @inheritdoc IAuctionHouseDerivedState\\n  function step()\\n    public\\n    view\\n    override(IAuctionHouseDerivedState)\\n    atStage(Stages.AuctionActive)\\n    returns (uint256)\\n  {\\n    // .sub is unnecessary here - block number >= lastAuctionBlock.\\n    return _blockNumber() - lastAuctionBlock;\\n  }\\n\\n  function _startPrice(\\n    bool expansion,\\n    Cases stabilisationCase,\\n    uint256 targetFloatInEth,\\n    uint256 marketFloatInEth,\\n    uint256 bankInEth,\\n    uint256 basketFactor\\n  ) internal view returns (uint256 wethStart, uint256 bankStart) {\\n    uint256 bufferedMarketPrice =\\n      _bufferedMarketPrice(expansion, marketFloatInEth);\\n\\n    if (stabilisationCase == Cases.Up) {\\n      uint256 bankProportion =\\n        bufferedMarketPrice.sub(targetFloatInEth).divideDecimalRoundPrecise(\\n          bankInEth\\n        );\\n\\n      return (targetFloatInEth, bankProportion);\\n    }\\n\\n    if (\\n      stabilisationCase == Cases.Restock ||\\n      stabilisationCase == Cases.Confidence\\n    ) {\\n      return (bufferedMarketPrice, 0);\\n    }\\n\\n    assert(stabilisationCase == Cases.Down);\\n    assert(basketFactor < SafeDecimalMath.PRECISE_UNIT);\\n    uint256 invertedBasketFactor =\\n      SafeDecimalMath.PRECISE_UNIT.sub(basketFactor);\\n\\n    uint256 basketFactorAdjustedEth =\\n      bufferedMarketPrice.multiplyDecimalRoundPrecise(basketFactor);\\n\\n    // Note that the PRECISE_UNIT factors itself out\\n    uint256 basketFactorAdjustedBank =\\n      bufferedMarketPrice.mul(invertedBasketFactor).div(bankInEth);\\n    return (basketFactorAdjustedEth, basketFactorAdjustedBank);\\n  }\\n\\n  function _endPrice(\\n    Cases stabilisationCase,\\n    uint256 targetFloatInEth,\\n    uint256 bankInEth,\\n    uint256 basketFactor\\n  ) internal pure returns (uint256 wethEnd, uint256 bankEnd) {\\n    if (stabilisationCase == Cases.Down) {\\n      assert(basketFactor < SafeDecimalMath.PRECISE_UNIT);\\n      uint256 invertedBasketFactor =\\n        SafeDecimalMath.PRECISE_UNIT.sub(basketFactor);\\n\\n      uint256 basketFactorAdjustedEth =\\n        targetFloatInEth.multiplyDecimalRoundPrecise(basketFactor);\\n\\n      // Note that the PRECISE_UNIT factors itself out.\\n      uint256 basketFactorAdjustedBank =\\n        targetFloatInEth.mul(invertedBasketFactor).div(bankInEth);\\n      return (basketFactorAdjustedEth, basketFactorAdjustedBank);\\n    }\\n\\n    return (targetFloatInEth, 0);\\n  }\\n\\n  /// @inheritdoc IAuctionHouseDerivedState\\n  function latestAuction()\\n    public\\n    view\\n    override(IAuctionHouseDerivedState)\\n    returns (Auction memory)\\n  {\\n    return auctions[round];\\n  }\\n\\n  /// @dev Returns a buffered [e27] market price, note that buffer is still [e18], so can use divideDecimal.\\n  function _bufferedMarketPrice(bool expansion, uint256 marketPrice)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    uint256 factor =\\n      expansion\\n        ? BasisMath.FULL_PERCENT.add(buffer)\\n        : BasisMath.FULL_PERCENT.sub(buffer);\\n    return marketPrice.percentageOf(factor);\\n  }\\n\\n  /// @dev Calculates the current case based on if we're expanding and basket factor.\\n  function _currentCase(bool expansion, uint256 basketFactor)\\n    internal\\n    pure\\n    returns (Cases)\\n  {\\n    bool underlyingDemand = basketFactor >= SafeDecimalMath.PRECISE_UNIT;\\n\\n    if (expansion) {\\n      return underlyingDemand ? Cases.Up : Cases.Restock;\\n    }\\n\\n    return underlyingDemand ? Cases.Confidence : Cases.Down;\\n  }\\n\\n  /* |||||||||| AuctionPending |||||||||| */\\n\\n  // solhint-disable function-max-lines\\n  /// @inheritdoc IAuctionHouseActions\\n  function start()\\n    external\\n    override(IAuctionHouseActions)\\n    timedTransition\\n    atStage(Stages.AuctionPending)\\n    returns (uint64 newRound)\\n  {\\n    // Check we have up to date oracles, this also ensures we don't have\\n    // auctions too close together (reverts based upon timeElapsed < periodSize).\\n    bankEthOracle.update(address(bank), address(weth));\\n    floatEthOracle.update(address(float), address(weth));\\n\\n    // [e27]\\n    uint256 frozenBankInEth =\\n      bankEthOracle.consult(\\n        address(bank),\\n        SafeDecimalMath.PRECISE_UNIT,\\n        address(weth)\\n      );\\n    // [e27]\\n    uint256 frozenFloatInEth =\\n      floatEthOracle.consult(\\n        address(float),\\n        SafeDecimalMath.PRECISE_UNIT,\\n        address(weth)\\n      );\\n\\n    // Update Monetary Policy with previous auction results\\n    if (round != 0 && shouldUpdatePolicy) {\\n      uint256 oldTargetPriceInEth = monetaryPolicy.consult();\\n      uint256 oldBasketFactor = basket.getBasketFactor(oldTargetPriceInEth);\\n\\n      monetaryPolicy.updateGivenAuctionResults(\\n        round,\\n        lastAuctionBlock,\\n        frozenFloatInEth,\\n        oldBasketFactor\\n      );\\n    }\\n\\n    // Round only increments by one on start, given auction period of restriction of 150 blocks\\n    // this means we'd need 2**64 / 150 blocks or ~3.7 lifetimes of the universe to overflow.\\n    // Likely, we'd have upgraded the contract by this point.\\n    round++;\\n\\n    // Calculate target price [e27]\\n    uint256 frozenTargetPriceInEth = monetaryPolicy.consult();\\n\\n    // STC: Pull out to ValidateOracles\\n    require(frozenTargetPriceInEth != 0, \\\"AuctionHouse/TargetSenseCheck\\\");\\n    require(frozenBankInEth != 0, \\\"AuctionHouse/BankSenseCheck\\\");\\n    require(frozenFloatInEth != 0, \\\"AuctionHouse/FloatSenseCheck\\\");\\n    uint256 basketFactor = basket.getBasketFactor(frozenTargetPriceInEth);\\n\\n    bool expansion = frozenFloatInEth >= frozenTargetPriceInEth;\\n    Cases stabilisationCase = _currentCase(expansion, basketFactor);\\n\\n    // Calculate Auction Price points\\n    (uint256 wethStart, uint256 bankStart) =\\n      _startPrice(\\n        expansion,\\n        stabilisationCase,\\n        frozenTargetPriceInEth,\\n        frozenFloatInEth,\\n        frozenBankInEth,\\n        basketFactor\\n      );\\n\\n    (uint256 wethEnd, uint256 bankEnd) =\\n      _endPrice(\\n        stabilisationCase,\\n        frozenTargetPriceInEth,\\n        frozenBankInEth,\\n        basketFactor\\n      );\\n\\n    // Calculate Allowance\\n    uint256 allowance =\\n      AuctionHouseMath.allowance(\\n        expansion,\\n        allowanceCap,\\n        float.totalSupply(),\\n        frozenFloatInEth,\\n        frozenTargetPriceInEth\\n      );\\n\\n    require(allowance != 0, \\\"AuctionHouse/NoAllowance\\\");\\n\\n    auctions[round].stabilisationCase = stabilisationCase;\\n    auctions[round].targetFloatInEth = frozenTargetPriceInEth;\\n    auctions[round].marketFloatInEth = frozenFloatInEth;\\n    auctions[round].bankInEth = frozenBankInEth;\\n\\n    auctions[round].basketFactor = basketFactor;\\n    auctions[round].allowance = allowance;\\n\\n    auctions[round].startWethPrice = wethStart;\\n    auctions[round].startBankPrice = bankStart;\\n    auctions[round].endWethPrice = wethEnd;\\n    auctions[round].endBankPrice = bankEnd;\\n\\n    lastAuctionBlock = _blockNumber();\\n    _setStage(Stages.AuctionActive);\\n\\n    emit NewAuction(round, allowance, frozenTargetPriceInEth, lastAuctionBlock);\\n\\n    return round;\\n  }\\n\\n  // solhint-enable function-max-lines\\n\\n  /* |||||||||| AuctionActive |||||||||| */\\n\\n  function _updateDelta(uint256 floatDelta) internal {\\n    Auction memory _currentAuction = latestAuction();\\n\\n    require(\\n      floatDelta <= _currentAuction.allowance.sub(_currentAuction.delta),\\n      \\\"AuctionHouse/WithinAllowedDelta\\\"\\n    );\\n\\n    auctions[round].delta = _currentAuction.delta.add(floatDelta);\\n  }\\n\\n  /* |||||||||| AuctionActive:inExpansion |||||||||| */\\n\\n  /// @inheritdoc IAuctionHouseActions\\n  function buy(\\n    uint256 wethInMax,\\n    uint256 bankInMax,\\n    uint256 floatOutMin,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    override(IAuctionHouseActions)\\n    timedTransition\\n    atStage(Stages.AuctionActive)\\n    inExpansion\\n    returns (\\n      uint256 usedWethIn,\\n      uint256 usedBankIn,\\n      uint256 usedFloatOut\\n    )\\n  {\\n    // solhint-disable-next-line not-rely-on-time\\n    require(block.timestamp <= deadline, \\\"AuctionHouse/TransactionTooOld\\\");\\n\\n    (uint256 wethPrice, uint256 bankPrice) = price();\\n\\n    usedFloatOut = Math.min(\\n      wethInMax.divideDecimalRoundPrecise(wethPrice),\\n      bankPrice == 0\\n        ? type(uint256).max\\n        : bankInMax.divideDecimalRoundPrecise(bankPrice)\\n    );\\n\\n    require(usedFloatOut != 0, \\\"AuctionHouse/ZeroFloatBought\\\");\\n    require(usedFloatOut >= floatOutMin, \\\"AuctionHouse/RequestedTooMuch\\\");\\n\\n    usedWethIn = wethPrice.multiplyDecimalRoundPrecise(usedFloatOut);\\n    usedBankIn = bankPrice.multiplyDecimalRoundPrecise(usedFloatOut);\\n\\n    require(wethInMax >= usedWethIn, \\\"AuctionHouse/MinimumWeth\\\");\\n    require(bankInMax >= usedBankIn, \\\"AuctionHouse/MinimumBank\\\");\\n\\n    _updateDelta(usedFloatOut);\\n\\n    emit Buy(round, _msgSender(), usedWethIn, usedBankIn, usedFloatOut);\\n\\n    _interactBuy(usedWethIn, usedBankIn, usedFloatOut, to);\\n\\n    return (usedWethIn, usedBankIn, usedFloatOut);\\n  }\\n\\n  function _interactBuy(\\n    uint256 usedWethIn,\\n    uint256 usedBankIn,\\n    uint256 usedFloatOut,\\n    address to\\n  ) internal {\\n    weth.safeTransferFrom(_msgSender(), address(basket), usedWethIn);\\n\\n    if (usedBankIn != 0) {\\n      (uint256 bankToSave, uint256 bankToBurn) =\\n        usedBankIn.splitBy(protocolFee);\\n\\n      bank.safeTransferFrom(_msgSender(), address(this), bankToSave);\\n      bank.safeBurnFrom(_msgSender(), bankToBurn);\\n    }\\n\\n    float.safeMint(to, usedFloatOut);\\n  }\\n\\n  /* |||||||||| AuctionActive:inContraction |||||||||| */\\n\\n  /// @inheritdoc IAuctionHouseActions\\n  function sell(\\n    uint256 floatIn,\\n    uint256 wethOutMin,\\n    uint256 bankOutMin,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    override(IAuctionHouseActions)\\n    timedTransition\\n    atStage(Stages.AuctionActive)\\n    inContraction\\n    returns (\\n      uint256 usedfloatIn,\\n      uint256 usedWethOut,\\n      uint256 usedBankOut\\n    )\\n  {\\n    // solhint-disable-next-line not-rely-on-time\\n    require(block.timestamp <= deadline, \\\"AuctionHouse/TransactionTooOld\\\");\\n    require(floatIn != 0, \\\"AuctionHouse/ZeroFloatSold\\\");\\n\\n    (uint256 wethPrice, uint256 bankPrice) = price();\\n\\n    usedWethOut = wethPrice.multiplyDecimalRoundPrecise(floatIn);\\n    usedBankOut = bankPrice.multiplyDecimalRoundPrecise(floatIn);\\n\\n    require(wethOutMin <= usedWethOut, \\\"AuctionHouse/ExpectedTooMuchWeth\\\");\\n    require(bankOutMin <= usedBankOut, \\\"AuctionHouse/ExpectedTooMuchBank\\\");\\n\\n    _updateDelta(floatIn);\\n\\n    emit Sell(round, _msgSender(), floatIn, usedWethOut, usedBankOut);\\n\\n    _interactSell(floatIn, usedWethOut, usedBankOut, to);\\n\\n    return (floatIn, usedWethOut, usedBankOut);\\n  }\\n\\n  function _interactSell(\\n    uint256 floatIn,\\n    uint256 usedWethOut,\\n    uint256 usedBankOut,\\n    address to\\n  ) internal {\\n    float.safeBurnFrom(_msgSender(), floatIn);\\n\\n    if (usedWethOut != 0) {\\n      weth.safeTransferFrom(address(basket), to, usedWethOut);\\n    }\\n\\n    if (usedBankOut != 0) {\\n      // STC: Maximum mint checks relative to allowance\\n      bank.safeMint(to, usedBankOut);\\n    }\\n  }\\n\\n  /* |||||||||| AuctionCooldown, AuctionPending, AuctionActive |||||||||| */\\n\\n  /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n  /* ----- onlyGovernance ----- */\\n\\n  /// @inheritdoc IAuctionHouseGovernedActions\\n  function modifyParameters(bytes32 parameter, uint256 data)\\n    external\\n    override(IAuctionHouseGovernedActions)\\n    onlyGovernance\\n  {\\n    if (parameter == \\\"auctionDuration\\\") {\\n      require(data <= type(uint16).max, \\\"AuctionHouse/ModADMax\\\");\\n      require(data != 0, \\\"AuctionHouse/ModADZero\\\");\\n      auctionDuration = uint16(data);\\n    } else if (parameter == \\\"auctionCooldown\\\") {\\n      require(data <= type(uint32).max, \\\"AuctionHouse/ModCMax\\\");\\n      auctionCooldown = uint32(data);\\n    } else if (parameter == \\\"buffer\\\") {\\n      // 0% <= buffer <= 1000%\\n      require(data <= 10 * BasisMath.FULL_PERCENT, \\\"AuctionHouse/ModBMax\\\");\\n      buffer = uint16(data);\\n    } else if (parameter == \\\"protocolFee\\\") {\\n      // 0% <= protocolFee <= 100%\\n      require(data <= BasisMath.FULL_PERCENT, \\\"AuctionHouse/ModPFMax\\\");\\n      protocolFee = uint16(data);\\n    } else if (parameter == \\\"allowanceCap\\\") {\\n      // 0% < allowanceCap <= N ~ 1_000%\\n      require(data <= type(uint32).max, \\\"AuctionHouse/ModACMax\\\");\\n      require(data != 0, \\\"AuctionHouse/ModACMin\\\");\\n      allowanceCap = uint32(data);\\n    } else if (parameter == \\\"shouldUpdatePolicy\\\") {\\n      require(data == 1 || data == 0, \\\"AuctionHouse/ModUP\\\");\\n      shouldUpdatePolicy = data == 1;\\n    } else if (parameter == \\\"lastAuctionBlock\\\") {\\n      // We wouldn't want to disable auctions for more than ~4.3 weeks\\n      // A longer period should result in a \\\"burnt\\\" auction house and redeploy.\\n      require(data <= block.number + 2e5, \\\"AuctionHouse/ModLABMax\\\");\\n      require(data != 0, \\\"AuctionHouse/ModLABMin\\\");\\n      // Can be used to pause auctions if set in the future.\\n      lastAuctionBlock = data;\\n    } else revert(\\\"AuctionHouse/InvalidParameter\\\");\\n\\n    emit ModifyParameters(parameter, data);\\n  }\\n\\n  /// @inheritdoc IAuctionHouseGovernedActions\\n  function modifyParameters(bytes32 parameter, address data)\\n    external\\n    override(IAuctionHouseGovernedActions)\\n    onlyGovernance\\n  {\\n    if (parameter == \\\"monetaryPolicy\\\") {\\n      // STC: Sense check\\n      monetaryPolicy = IMonetaryPolicy(data);\\n    } else if (parameter == \\\"bankEthOracle\\\") {\\n      // STC: Sense check\\n      bankEthOracle = ITwap(data);\\n    } else if (parameter == \\\"floatEthOracle\\\") {\\n      // STC: Sense check\\n      floatEthOracle = ITwap(data);\\n    } else revert(\\\"AuctionHouse/InvalidParameter\\\");\\n\\n    emit ModifyParameters(parameter, data);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/EnumerableSet.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/auction/Staged.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"../lib/BlockNumber.sol\\\";\\n\\ncontract Staged is BlockNumber {\\n  /**\\n   * @dev The current auction stage.\\n   * - AuctionCooling - We cannot start an auction due to Cooling Period.\\n   * - AuctionPending - We can start an auction at any time.\\n   * - AuctionActive - Auction is ongoing.\\n   */\\n  enum Stages {AuctionCooling, AuctionPending, AuctionActive}\\n\\n  /* ========== STATE VARIABLES ========== */\\n\\n  /**\\n   * @dev The cooling period between each auction in blocks.\\n   */\\n  uint32 internal auctionCooldown;\\n\\n  /**\\n   * @dev The length of the auction in blocks.\\n   */\\n  uint16 internal auctionDuration;\\n\\n  /**\\n   * @notice The current stage\\n   */\\n  Stages public stage;\\n\\n  /**\\n   * @notice Block number when the last auction started.\\n   */\\n  uint256 public lastAuctionBlock;\\n\\n  /* ========== CONSTRUCTOR ========== */\\n\\n  constructor(\\n    uint16 _auctionDuration,\\n    uint32 _auctionCooldown,\\n    uint256 _firstAuctionBlock\\n  ) {\\n    require(\\n      _firstAuctionBlock >= _auctionDuration + _auctionCooldown,\\n      \\\"Staged/InvalidAuctionStart\\\"\\n    );\\n\\n    auctionDuration = _auctionDuration;\\n    auctionCooldown = _auctionCooldown;\\n    lastAuctionBlock = _firstAuctionBlock - _auctionDuration - _auctionCooldown;\\n    stage = Stages.AuctionCooling;\\n  }\\n\\n  /* ============ Events ============ */\\n\\n  event StageChanged(uint8 _prevStage, uint8 _newStage);\\n\\n  /* ========== MODIFIERS ========== */\\n\\n  modifier atStage(Stages _stage) {\\n    require(stage == _stage, \\\"Staged/InvalidStage\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modify the stages as necessary on call.\\n   */\\n  modifier timedTransition() {\\n    uint256 _blockNumber = _blockNumber();\\n\\n    if (\\n      stage == Stages.AuctionActive &&\\n      _blockNumber > lastAuctionBlock + auctionDuration\\n    ) {\\n      stage = Stages.AuctionCooling;\\n      emit StageChanged(uint8(Stages.AuctionActive), uint8(stage));\\n    }\\n    // Note that this can cascade so AuctionActive -> AuctionPending in one update, when auctionCooldown = 0.\\n    if (\\n      stage == Stages.AuctionCooling &&\\n      _blockNumber > lastAuctionBlock + auctionDuration + auctionCooldown\\n    ) {\\n      stage = Stages.AuctionPending;\\n      emit StageChanged(uint8(Stages.AuctionCooling), uint8(stage));\\n    }\\n\\n    _;\\n  }\\n\\n  /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n  /**\\n   * @notice Updates the stage, even if a function with timedTransition modifier has not yet been called\\n   * @return Returns current auction stage\\n   */\\n  function updateStage() external timedTransition returns (Stages) {\\n    return stage;\\n  }\\n\\n  /**\\n   * @dev Set the stage manually.\\n   */\\n  function _setStage(Stages _stage) internal {\\n    Stages priorStage = stage;\\n    stage = _stage;\\n    emit StageChanged(uint8(priorStage), uint8(_stage));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/auction/AuctionHouseMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\n\\nimport \\\"../lib/BasisMath.sol\\\";\\nimport \\\"../external-lib/SafeDecimalMath.sol\\\";\\n\\ncontract AuctionHouseMath {\\n  using SafeMath for uint256;\\n  using SafeDecimalMath for uint256;\\n  using BasisMath for uint256;\\n\\n  /**\\n   * @notice Calculate the maximum allowance for this action to do a price correction\\n   * This is normally an over-estimate as it assumes all Float is circulating\\n   * and the market cap is constant through supply changes.\\n   */\\n  function allowance(\\n    bool expansion,\\n    uint256 capBasisPoint,\\n    uint256 floatSupply,\\n    uint256 marketFloatPrice,\\n    uint256 targetFloatPrice\\n  ) internal pure returns (uint256) {\\n    uint256 targetSupply =\\n      marketFloatPrice.mul(floatSupply).div(targetFloatPrice);\\n    uint256 allowanceForAdjustment =\\n      expansion ? targetSupply.sub(floatSupply) : floatSupply.sub(targetSupply);\\n\\n    // Cap Allowance per auction; e.g. with 10% of total supply => ~20% price move.\\n    uint256 allowanceByCap = floatSupply.percentageOf(capBasisPoint);\\n\\n    return Math.min(allowanceForAdjustment, allowanceByCap);\\n  }\\n\\n  /**\\n   * @notice Linear interpolation: start + (end - start) * (step/duration)\\n   * @dev For 150 steps, duration = 149, start / end can be in any format\\n   * as long as <= 10 ** 49.\\n   * @param start The starting value\\n   * @param end The ending value\\n   * @param step Number of blocks into interpolation\\n   * @param duration Total range\\n   */\\n  function lerp(\\n    uint256 start,\\n    uint256 end,\\n    uint256 step,\\n    uint256 duration\\n  ) internal pure returns (uint256 result) {\\n    require(duration != 0, \\\"AuctionHouseMath/ZeroDuration\\\");\\n    require(step <= duration, \\\"AuctionHouseMath/InvalidStep\\\");\\n\\n    // Max value <= 2^256 / 10^27 of which 10^49 is.\\n    require(start <= 10**49, \\\"AuctionHouseMath/StartTooLarge\\\");\\n    require(end <= 10**49, \\\"AuctionHouseMath/EndTooLarge\\\");\\n\\n    // 0 <= t <= PRECISE_UNIT\\n    uint256 t = step.divideDecimalRoundPrecise(duration);\\n\\n    // result = start + (end - start) * t\\n    //        = end * t + start - start * t\\n    return\\n      result = end.multiplyDecimalRoundPrecise(t).add(start).sub(\\n        start.multiplyDecimalRoundPrecise(t)\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/IAuctionHouse.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./ah/IAuctionHouseState.sol\\\";\\nimport \\\"./ah/IAuctionHouseVariables.sol\\\";\\nimport \\\"./ah/IAuctionHouseDerivedState.sol\\\";\\nimport \\\"./ah/IAuctionHouseActions.sol\\\";\\nimport \\\"./ah/IAuctionHouseGovernedActions.sol\\\";\\nimport \\\"./ah/IAuctionHouseEvents.sol\\\";\\n\\n/**\\n * @title The interface for a Float Protocol Auction House\\n * @notice The Auction House enables the sale and buy of FLOAT tokens from the\\n * market in order to stabilise price.\\n * @dev The Auction House interface is broken up into many smaller pieces\\n */\\ninterface IAuctionHouse is\\n  IAuctionHouseState,\\n  IAuctionHouseVariables,\\n  IAuctionHouseDerivedState,\\n  IAuctionHouseActions,\\n  IAuctionHouseGovernedActions,\\n  IAuctionHouseEvents\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/funds/interfaces/basket/IBasketReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\ninterface IBasketReader {\\n  /**\\n   * @notice Underlying token that is kept in this Basket\\n   */\\n  function underlying() external view returns (address);\\n\\n  /**\\n   * @notice Given a target price, what is the basket factor\\n   * @param targetPriceInUnderlying the current target price to calculate the\\n   * basket factor for in the units of the underlying token.\\n   */\\n  function getBasketFactor(uint256 targetPriceInUnderlying)\\n    external\\n    view\\n    returns (uint256 basketFactor);\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/interfaces/ITwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\ninterface ITwap {\\n  /**\\n   * @notice Returns the amount out corresponding to the amount in for a given token using the moving average over time range [`block.timestamp` - [`windowSize`, `windowSize - periodSize * 2`], `block.timestamp`].\\n   * E.g. with a windowSize = 24hrs, periodSize = 6hrs.\\n   * [24hrs ago to 12hrs ago, now]\\n   * @dev Update must have been called for the bucket corresponding to the timestamp `now - windowSize`\\n   * @param tokenIn the address of the token we are offering\\n   * @param amountIn the quantity of tokens we are pricing\\n   * @param tokenOut the address of the token we want\\n   * @return amountOut the `tokenOut` amount corresponding to the `amountIn` for `tokenIn` over the time range\\n   */\\n  function consult(\\n    address tokenIn,\\n    uint256 amountIn,\\n    address tokenOut\\n  ) external view returns (uint256 amountOut);\\n\\n  /**\\n   * @notice Checks if a particular pair can be updated\\n   * @param tokenA Token A of pair (any order)\\n   * @param tokenB Token B of pair (any order)\\n   * @return If an update call will succeed\\n   */\\n  function updateable(address tokenA, address tokenB)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @notice Update the cumulative price for the observation at the current timestamp. Each observation is updated at most once per epoch period.\\n   * @param tokenA the first token to create pair from\\n   * @param tokenB the second token to create pair from\\n   * @return if the observation was updated or not.\\n   */\\n  function update(address tokenA, address tokenB) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/policy/interfaces/IMonetaryPolicy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\ninterface IMonetaryPolicy {\\n  /**\\n   * @notice Consult the monetary policy for the target price in eth\\n   */\\n  function consult() external view returns (uint256 targetPriceInEth);\\n\\n  /**\\n   * @notice Update the Target price given the auction results.\\n   * @dev 0 values are used to indicate missing data.\\n   */\\n  function updateGivenAuctionResults(\\n    uint256 round,\\n    uint256 lastAuctionBlock,\\n    uint256 floatMarketPrice,\\n    uint256 basketFactor\\n  ) external returns (uint256 targetPriceInEth);\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/interfaces/ISupplyControlledERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface ISupplyControlledERC20 is IERC20 {\\n  /**\\n   * @dev Creates `amount` new tokens for `to`.\\n   *\\n   * See {ERC20-_mint}.\\n   *\\n   * Requirements:\\n   * - the caller must have the `MINTER_ROLE`.\\n   */\\n  function mint(address to, uint256 amount) external;\\n\\n  /**\\n   * @dev Destroys `amount` tokens from the caller.\\n   *\\n   * See {ERC20-_burn}.\\n   */\\n  function burn(uint256 amount) external;\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the\\n   * total supply.\\n   *\\n   * See {ERC20-_burn}.\\n   */\\n  function burnFrom(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/BasisMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\n/**\\n * @title Basis Mathematics\\n * @notice Provides helpers to perform percentage calculations\\n * @dev Percentages are [e2] i.e. with 2 decimals precision / basis point.\\n */\\nlibrary BasisMath {\\n  uint256 internal constant FULL_PERCENT = 1e4; // 100.00% / 1000 bp\\n  uint256 internal constant HALF_ONCE_SCALED = FULL_PERCENT / 2;\\n\\n  /**\\n   * @dev Percentage pct, round 0.5+ up.\\n   * @param self The value to take a percentage pct\\n   * @param percentage The percentage to be calculated [e2]\\n   * @return pct self * percentage\\n   */\\n  function percentageOf(uint256 self, uint256 percentage)\\n    internal\\n    pure\\n    returns (uint256 pct)\\n  {\\n    if (self == 0 || percentage == 0) {\\n      pct = 0;\\n    } else {\\n      require(\\n        self <= (type(uint256).max - HALF_ONCE_SCALED) / percentage,\\n        \\\"BasisMath/Overflow\\\"\\n      );\\n\\n      pct = (self * percentage + HALF_ONCE_SCALED) / FULL_PERCENT;\\n    }\\n  }\\n\\n  /**\\n   * @dev Split value into percentage, round 0.5+ up.\\n   * @param self The value to split\\n   * @param percentage The percentage to be calculated [e2]\\n   * @return pct The percentage of the value\\n   * @return rem Anything leftover from the value\\n   */\\n  function splitBy(uint256 self, uint256 percentage)\\n    internal\\n    pure\\n    returns (uint256 pct, uint256 rem)\\n  {\\n    require(percentage <= FULL_PERCENT, \\\"BasisMath/ExcessPercentage\\\");\\n    pct = percentageOf(self, percentage);\\n    rem = self - pct;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/BlockNumber.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\n/// @title Function for getting block number\\n/// @dev Base contract that is overridden for tests\\nabstract contract BlockNumber {\\n  /// @dev Method that exists purely to be overridden for tests\\n  /// @return The current block number\\n  function _blockNumber() internal view virtual returns (uint256) {\\n    return block.number;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Recoverable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title Recoverable feature\\n * @dev should _only_ be used with contracts that should not store assets,\\n * but instead interacted with value so there is potential to lose assets.\\n */\\nabstract contract Recoverable is AccessControl {\\n  using SafeERC20 for IERC20;\\n  using Address for address payable;\\n\\n  /* ========== CONSTANTS ========== */\\n  bytes32 public constant RECOVER_ROLE = keccak256(\\\"RECOVER_ROLE\\\");\\n\\n  /* ============ Events ============ */\\n\\n  event Recovered(address onBehalfOf, address tokenAddress, uint256 amount);\\n\\n  /* ========== MODIFIERS ========== */\\n\\n  modifier isRecoverer {\\n    require(hasRole(RECOVER_ROLE, _msgSender()), \\\"Recoverable/RecoverRole\\\");\\n    _;\\n  }\\n\\n  /* ========== RESTRICTED FUNCTIONS ========== */\\n  /* ----- RECOVER_ROLE ----- */\\n\\n  /**\\n   * @notice Provide accidental token retrieval.\\n   * @dev Sourced from synthetix/contracts/StakingRewards.sol\\n   */\\n  function recoverERC20(\\n    address to,\\n    address tokenAddress,\\n    uint256 tokenAmount\\n  ) external isRecoverer {\\n    emit Recovered(to, tokenAddress, tokenAmount);\\n\\n    IERC20(tokenAddress).safeTransfer(to, tokenAmount);\\n  }\\n\\n  /**\\n   * @notice Provide accidental ETH retrieval.\\n   */\\n  function recoverETH(address to) external isRecoverer {\\n    uint256 contractBalance = address(this).balance;\\n\\n    emit Recovered(to, address(0), contractBalance);\\n\\n    payable(to).sendValue(contractBalance);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/external-lib/SafeDecimalMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\\nlibrary SafeDecimalMath {\\n  using SafeMath for uint256;\\n\\n  /* Number of decimal places in the representations. */\\n  uint8 public constant decimals = 18;\\n  uint8 public constant highPrecisionDecimals = 27;\\n\\n  /* The number representing 1.0. */\\n  uint256 public constant UNIT = 10**uint256(decimals);\\n\\n  /* The number representing 1.0 for higher fidelity numbers. */\\n  uint256 public constant PRECISE_UNIT = 10**uint256(highPrecisionDecimals);\\n  uint256 private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR =\\n    10**uint256(highPrecisionDecimals - decimals);\\n\\n  /**\\n   * @return Provides an interface to UNIT.\\n   */\\n  function unit() external pure returns (uint256) {\\n    return UNIT;\\n  }\\n\\n  /**\\n   * @return Provides an interface to PRECISE_UNIT.\\n   */\\n  function preciseUnit() external pure returns (uint256) {\\n    return PRECISE_UNIT;\\n  }\\n\\n  /**\\n   * @return The result of multiplying x and y, interpreting the operands as fixed-point\\n   * decimals.\\n   *\\n   * @dev A unit factor is divided out after the product of x and y is evaluated,\\n   * so that product must be less than 2**256. As this is an integer division,\\n   * the internal division always rounds down. This helps save on gas. Rounding\\n   * is more expensive on gas.\\n   */\\n  function multiplyDecimal(uint256 x, uint256 y)\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\\n    return x.mul(y) / UNIT;\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of the specified precision unit.\\n   *\\n   * @dev The operands should be in the form of a the specified unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function _multiplyDecimalRound(\\n    uint256 x,\\n    uint256 y,\\n    uint256 precisionUnit\\n  ) private pure returns (uint256) {\\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\\n    uint256 quotientTimesTen = x.mul(y) / (precisionUnit / 10);\\n\\n    if (quotientTimesTen % 10 >= 5) {\\n      quotientTimesTen += 10;\\n    }\\n\\n    return quotientTimesTen / 10;\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of a precise unit.\\n   *\\n   * @dev The operands should be in the precise unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function multiplyDecimalRoundPrecise(uint256 x, uint256 y)\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return _multiplyDecimalRound(x, y, PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of a standard unit.\\n   *\\n   * @dev The operands should be in the standard unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function multiplyDecimalRound(uint256 x, uint256 y)\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return _multiplyDecimalRound(x, y, UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is a high\\n   * precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the standard precision unit\\n   * is evaluated, so the product of x and UNIT must be less than 2**256. As\\n   * this is an integer division, the result is always rounded down.\\n   * This helps save on gas. Rounding is more expensive on gas.\\n   */\\n  function divideDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\\n    /* Reintroduce the UNIT factor that will be divided out by y. */\\n    return x.mul(UNIT).div(y);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * decimal in the precision unit specified in the parameter.\\n   *\\n   * @dev y is divided after the product of x and the specified precision unit\\n   * is evaluated, so the product of x and the specified precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function _divideDecimalRound(\\n    uint256 x,\\n    uint256 y,\\n    uint256 precisionUnit\\n  ) private pure returns (uint256) {\\n    uint256 resultTimesTen = x.mul(precisionUnit * 10).div(y);\\n\\n    if (resultTimesTen % 10 >= 5) {\\n      resultTimesTen += 10;\\n    }\\n\\n    return resultTimesTen / 10;\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * standard precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the standard precision unit\\n   * is evaluated, so the product of x and the standard precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function divideDecimalRound(uint256 x, uint256 y)\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return _divideDecimalRound(x, y, UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * high precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the high precision unit\\n   * is evaluated, so the product of x and the high precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function divideDecimalRoundPrecise(uint256 x, uint256 y)\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return _divideDecimalRound(x, y, PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @dev Convert a standard decimal representation to a high precision one.\\n   */\\n  function decimalToPreciseDecimal(uint256 i) internal pure returns (uint256) {\\n    return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\\n  }\\n\\n  /**\\n   * @dev Convert a high precision decimal to a standard decimal representation.\\n   */\\n  function preciseDecimalToDecimal(uint256 i) internal pure returns (uint256) {\\n    uint256 quotientTimesTen =\\n      i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\\n\\n    if (quotientTimesTen % 10 >= 5) {\\n      quotientTimesTen += 10;\\n    }\\n\\n    return quotientTimesTen / 10;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/SafeSupplyControlledERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\n\\nimport \\\"../tokens/interfaces/ISupplyControlledERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\n/**\\n * @title SafeSupplyControlledERC20\\n * @dev Wrappers around Supply Controlled ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n */\\nlibrary SafeSupplyControlledERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeBurnFrom(\\n    ISupplyControlledERC20 token,\\n    address from,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.burnFrom.selector, from, value)\\n    );\\n  }\\n\\n  function safeMint(\\n    ISupplyControlledERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.mint.selector, to, value)\\n    );\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\n   * @param token The token targeted by the call.\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\n   */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata =\\n      address(token).functionCall(\\n        data,\\n        \\\"SafeSupplyControlled/LowlevelCallFailed\\\"\\n      );\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      // solhint-disable-next-line max-line-length\\n      require(\\n        abi.decode(returndata, (bool)),\\n        \\\"SafeSupplyControlled/ERC20Failed\\\"\\n      );\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/ah/IAuctionHouseState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\n/// @title Auction House state that can change by governance.\\n/// @notice These methods provide vision on specific state that could be used in wrapper contracts.\\ninterface IAuctionHouseState {\\n  /**\\n   * @notice The buffer around the starting price to handle mispriced / stale oracles.\\n   * @dev Basis point\\n   * Starts at 10% / 1e3 so market price is buffered by 110% or 90%\\n   */\\n  function buffer() external view returns (uint16);\\n\\n  /**\\n   * @notice The fee taken by the protocol.\\n   * @dev Basis point\\n   */\\n  function protocolFee() external view returns (uint16);\\n\\n  /**\\n   * @notice The cap based on total FLOAT supply to change in a single auction. E.g. 10% cap => absolute max of 10% of total supply can be minted / burned\\n   * @dev Basis point\\n   */\\n  function allowanceCap() external view returns (uint32);\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/ah/IAuctionHouseVariables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./ICases.sol\\\";\\n\\n/// @title Auction House state that can change\\n/// @notice These methods compose the auctions state, and will change per action.\\ninterface IAuctionHouseVariables is ICases {\\n  /**\\n   * @notice The number of auctions since inception.\\n   */\\n  function round() external view returns (uint64);\\n\\n  /**\\n   * @notice Returns data about a specific auction.\\n   * @param roundNumber The round number for the auction array to fetch\\n   * @return stabilisationCase The Auction struct including case\\n   */\\n  function auctions(uint64 roundNumber)\\n    external\\n    view\\n    returns (\\n      Cases stabilisationCase,\\n      uint256 targetFloatInEth,\\n      uint256 marketFloatInEth,\\n      uint256 bankInEth,\\n      uint256 startWethPrice,\\n      uint256 startBankPrice,\\n      uint256 endWethPrice,\\n      uint256 endBankPrice,\\n      uint256 basketFactor,\\n      uint256 delta,\\n      uint256 allowance\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/ah/IAuctionHouseDerivedState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./IAuction.sol\\\";\\n\\n/// @title Auction House state that can change\\n/// @notice These methods are derived from the IAuctionHouseState.\\ninterface IAuctionHouseDerivedState is IAuction {\\n  /**\\n   * @notice The price (that the Protocol with expect on expansion, and give on Contraction) for 1 FLOAT\\n   * @dev Under cases, this value is used differently:\\n   * - Contraction, Protocol buys FLOAT for pair.\\n   * - Expansion, Protocol sells FLOAT for pair.\\n   * @return wethPrice [e27] Expected price in wETH.\\n   * @return bankPrice [e27] Expected price in BANK.\\n   */\\n  function price() external view returns (uint256 wethPrice, uint256 bankPrice);\\n\\n  /**\\n   * @notice The current step through the auction.\\n   * @dev block numbers since auction start (0 indexed)\\n   */\\n  function step() external view returns (uint256);\\n\\n  /**\\n   * @notice Latest Auction alias\\n   */\\n  function latestAuction() external view returns (Auction memory);\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/ah/IAuctionHouseActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\n/// @title Open Auction House actions\\n/// @notice Contains all actions that can be called by anyone\\ninterface IAuctionHouseActions {\\n  /**\\n   * @notice Starts an auction\\n   * @dev This will:\\n   * - update the oracles\\n   * - calculate the target price\\n   * - check stabilisation case\\n   * - create allowance.\\n   * - Set start / end prices of the auction\\n   */\\n  function start() external returns (uint64 newRound);\\n\\n  /**\\n   * @notice Buy for an amount of <WETH, BANK> for as much FLOAT tokens as possible.\\n   * @dev Expansion, Protocol sells FLOAT for pair.\\n    As the price descends there should be no opportunity for slippage causing failure\\n    `msg.sender` should already have given the auction allowance for at least `wethIn` and `bankIn`.\\n   * `wethInMax` / `bankInMax` < 2**256 / 10**18, assumption is that totalSupply\\n   * doesn't exceed type(uint128).max\\n   * @param wethInMax The max amount of WETH to send (takes maximum from given ratio).\\n   * @param bankInMax The max amount of BANK to send (takes maximum from given ratio).\\n   * @param floatOutMin The minimum amount of FLOAT that must be received for this transaction not to revert.\\n   * @param to Recipient of the FLOAT.\\n   * @param deadline Unix timestamp after which the transaction will revert.\\n   */\\n  function buy(\\n    uint256 wethInMax,\\n    uint256 bankInMax,\\n    uint256 floatOutMin,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    returns (\\n      uint256 usedWethIn,\\n      uint256 usedBankIn,\\n      uint256 usedFloatOut\\n    );\\n\\n  /**\\n   * @notice Sell an amount of FLOAT for the given reward tokens.\\n   * @dev Contraction, Protocol buys FLOAT for pair. `msg.sender` should already have given the auction allowance for at least `floatIn`.\\n   * @param floatIn The amount of FLOAT to sell.\\n   * @param wethOutMin The minimum amount of WETH that can be received before the transaction reverts.\\n   * @param bankOutMin The minimum amount of BANK that can be received before the tranasction reverts.\\n   * @param to Recipient of <WETH, BANK>.\\n   * @param deadline Unix timestamp after which the transaction will revert.\\n   */\\n  function sell(\\n    uint256 floatIn,\\n    uint256 wethOutMin,\\n    uint256 bankOutMin,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    returns (\\n      uint256 usedfloatIn,\\n      uint256 usedWethOut,\\n      uint256 usedBankOut\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/ah/IAuctionHouseGovernedActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\n/// @title Auction House actions that require certain level of privilege\\n/// @notice Contains Auction House methods that may only be called by controller\\ninterface IAuctionHouseGovernedActions {\\n  /**\\n   * @notice Modify a uint256 parameter\\n   * @param parameter The parameter name to modify\\n   * @param data New value for the parameter\\n   */\\n  function modifyParameters(bytes32 parameter, uint256 data) external;\\n\\n  /**\\n   * @notice Modify an address parameter\\n   * @param parameter The parameter name to modify\\n   * @param data New address for the parameter\\n   */\\n  function modifyParameters(bytes32 parameter, address data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/ah/IAuctionHouseEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\n/// @title Events emitted by the auction house\\n/// @notice Contains all events emitted by the auction house\\ninterface IAuctionHouseEvents {\\n  event NewAuction(\\n    uint256 indexed round,\\n    uint256 allowance,\\n    uint256 targetFloatInEth,\\n    uint256 startBlock\\n  );\\n  event Buy(\\n    uint256 indexed round,\\n    address indexed buyer,\\n    uint256 wethIn,\\n    uint256 bankIn,\\n    uint256 floatOut\\n  );\\n  event Sell(\\n    uint256 indexed round,\\n    address indexed seller,\\n    uint256 floatIn,\\n    uint256 wethOut,\\n    uint256 bankOut\\n  );\\n  event ModifyParameters(bytes32 parameter, uint256 data);\\n  event ModifyParameters(bytes32 parameter, address data);\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/ah/ICases.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\ninterface ICases {\\n  /**\\n   * @dev The Stabilisation Cases\\n   * Up (Expansion) - Estimated market price >= target price & Basket Factor >= 1.\\n   * Restock (Expansion) - Estimated market price >= target price & Basket Factor < 1.\\n   * Confidence (Contraction) - Estimated market price < target price & Basket Factor >= 1.\\n   * Down (Contraction) - Estimated market price < target price & Basket Factor < 1.\\n   */\\n  enum Cases {Up, Restock, Confidence, Down}\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/ah/IAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./ICases.sol\\\";\\n\\ninterface IAuction is ICases {\\n  /**\\n   * The current Stabilisation Case\\n   * Auction's target price.\\n   * Auction's floatInEth price.\\n   * Auction's bankInEth price.\\n   * Auction's basket factor.\\n   * Auction's used float delta.\\n   * Auction's allowed float delta (how much FLOAT can be created or burned).\\n   */\\n  struct Auction {\\n    Cases stabilisationCase;\\n    uint256 targetFloatInEth;\\n    uint256 marketFloatInEth;\\n    uint256 bankInEth;\\n    uint256 startWethPrice;\\n    uint256 startBankPrice;\\n    uint256 endWethPrice;\\n    uint256 endBankPrice;\\n    uint256 basketFactor;\\n    uint256 delta;\\n    uint256 allowance;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bank\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_float\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_basket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_monetaryPolicy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gov\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bankEthOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_floatEthOracle\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_auctionDuration\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"_auctionCooldown\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_firstAuctionBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bankIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"floatOut\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetFloatInEth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"}],\"name\":\"NewAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"floatIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bankOut\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_prevStage\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_newStage\",\"type\":\"uint8\"}],\"name\":\"StageChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOVERNANCE_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RECOVER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowanceCap\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"auctions\",\"outputs\":[{\"internalType\":\"enum ICases.Cases\",\"name\":\"stabilisationCase\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"targetFloatInEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketFloatInEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bankInEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startWethPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBankPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endWethPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBankPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basketFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buffer\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wethInMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bankInMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"floatOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usedWethIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usedBankIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usedFloatOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastAuctionBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAuction\",\"outputs\":[{\"components\":[{\"internalType\":\"enum ICases.Cases\",\"name\":\"stabilisationCase\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"targetFloatInEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketFloatInEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bankInEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startWethPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBankPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endWethPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBankPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basketFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"}],\"internalType\":\"struct IAuction.Auction\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wethPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bankPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFee\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"recoverETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"floatIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bankOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usedfloatIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usedWethOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usedBankOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shouldUpdatePolicy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"internalType\":\"enum Staged.Stages\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"newRound\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateStage\",\"outputs\":[{\"internalType\":\"enum Staged.Stages\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AuctionHouse","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000024a6a37576377f63f194caa5f518a60f45b42921000000000000000000000000b05097849bca421a3f51b249ba6cca4af4b97cb9000000000000000000000000f3b29cead29cbeb35cf9371504da2ff4770c59ec0000000000000000000000006b995aa6e188289d1b67c511dedf4f1291ab4fc0000000000000000000000000383df49ad1f0219759a46399fe33cb7a63cd051c0000000000000000000000007cb48e0826433b2d7a2a7f0e69a716d5ca0452290000000000000000000000007cb48e0826433b2d7a2a7f0e69a716d5ca045229000000000000000000000000000000000000000000000000000000000000009500000000000000000000000000000000000000000000000000000000000019fa0000000000000000000000000000000000000000000000000000000000bdf2a0","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}