{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Multiplies two unsigned integers, reverts on overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath mul error\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, \"SafeMath div error\");\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath sub error\");\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two unsigned integers, reverts on overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath add error\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n   * reverts when dividing by zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"SafeMath mod error\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ncontract IERC20 {\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n    function balanceOf(address who) public view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ILPToken is IERC20 {\r\n  function getReserves() public returns (uint112, uint112, uint32);\r\n}\r\n\r\ncontract ELDFarm {\r\n  using SafeMath for uint;\r\n\r\n  IERC20 constant eldToken = IERC20(0xf0C6521b1F8ad9C33a99Aaf056F6C6247A3862BA);\r\n  ILPToken constant lpToken = ILPToken(0x54d5230d16033eb03ffbaB29FCc09Ac54Df6F812);\r\n\r\n  uint constant blockPerDay = 5760;\r\n\r\n  address admin;\r\n  uint eldPrice = 9230; // decimal 6\r\n\r\n  struct UserInfo {\r\n    uint usdtAmount;\r\n    uint lpTokenAmount;\r\n    uint lastRewardBlock;\r\n  }\r\n\r\n  mapping(address => UserInfo) public userInfo;\r\n  event Deposit(address indexed user, uint lpTokenAmount, uint usdtAmount);\r\n  event Withdraw(address indexed user, uint lpTokenAmount);\r\n  event Reward(address indexed user, uint eldAmount);\r\n  event EmergencyWithdraw(address indexed user, uint lpTokenAmount);\r\n\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == admin, 'onlyAdmin');\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    admin = msg.sender;\r\n  }\r\n\r\n  function setELDPrice(uint _price) external onlyAdmin {\r\n    eldPrice = _price;\r\n  }\r\n\r\n  function deposit(uint _lpTokenAmount) external {\r\n    require(_lpTokenAmount > 0, 'Invalid amount');\r\n    require(lpToken.transferFrom(msg.sender, address(this), _lpTokenAmount), 'You are not approve lpToken to this contract');\r\n    UserInfo storage user = userInfo[msg.sender];\r\n    if (user.usdtAmount > 0 && block.number > user.lastRewardBlock) {\r\n      uint rewardedBlock = block.number - user.lastRewardBlock;\r\n      user.lastRewardBlock = block.number;\r\n      uint pendingRewardBalance = getPendingReward(rewardedBlock, user.usdtAmount);\r\n      safeELDTransfer(msg.sender, pendingRewardBalance);\r\n      emit Reward(msg.sender, pendingRewardBalance);\r\n    } else {\r\n      user.lastRewardBlock = block.number;\r\n    }\r\n    user.lpTokenAmount = user.lpTokenAmount.add(_lpTokenAmount);\r\n    uint usdtAmount = getUSDTFromLPToken(_lpTokenAmount);\r\n    user.usdtAmount = user.usdtAmount.add(usdtAmount);\r\n    emit Deposit(msg.sender, _lpTokenAmount, usdtAmount);\r\n  }\r\n\r\n  function withdraw() external {\r\n    UserInfo storage user = userInfo[msg.sender];\r\n    require (user.lpTokenAmount > 0, 'You have no farming');\r\n    if (user.usdtAmount > 0 && block.number > user.lastRewardBlock) {\r\n      uint rewardedBlock = block.number - user.lastRewardBlock;\r\n      user.lastRewardBlock = block.number;\r\n      uint userUsdtAmount = user.usdtAmount;\r\n      user.usdtAmount = 0;\r\n      uint userLPTokenAmount = user.lpTokenAmount;\r\n      user.lpTokenAmount = 0;\r\n      uint pendingRewardBalance = getPendingReward(rewardedBlock, userUsdtAmount);\r\n      safeELDTransfer(msg.sender, pendingRewardBalance);\r\n      safeLPTokenTransfer(msg.sender, userLPTokenAmount);\r\n      emit Reward(msg.sender, pendingRewardBalance);\r\n      emit Withdraw(msg.sender, userLPTokenAmount);\r\n    }\r\n  }\r\n\r\n  function reward() public {\r\n    UserInfo storage user = userInfo[msg.sender];\r\n    require (user.lpTokenAmount > 0, 'You have no farming');\r\n    if (user.usdtAmount > 0 && block.number > user.lastRewardBlock) {\r\n      uint rewardedBlock = block.number - user.lastRewardBlock;\r\n      user.lastRewardBlock = block.number;\r\n      uint pendingRewardBalance = getPendingReward(rewardedBlock, user.usdtAmount);\r\n      safeELDTransfer(msg.sender, pendingRewardBalance);\r\n      emit Reward(msg.sender, pendingRewardBalance);\r\n    }\r\n  }\r\n\r\n  function safeELDTransfer(address _to, uint256 _amount) internal {\r\n    uint256 eldBalance = eldToken.balanceOf(address(this));\r\n    require(eldBalance > 0, 'Contract is insufficient balance');\r\n    if (_amount > eldBalance) {\r\n      eldToken.transfer(_to, eldBalance);\r\n    } else {\r\n      eldToken.transfer(_to, _amount);\r\n    }\r\n  }\r\n\r\n  function safeLPTokenTransfer(address _to, uint256 _amount) internal {\r\n    uint256 lpBalance = lpToken.balanceOf(address(this));\r\n    require(lpBalance > 0, 'Contract is insufficient balance');\r\n    if (_amount > lpBalance) {\r\n      lpToken.transfer(_to, lpBalance);\r\n    } else {\r\n      lpToken.transfer(_to, _amount);\r\n    }\r\n  }\r\n\r\n  function getUSDTFromLPToken(uint _lpTokenAmount) public returns (uint) {\r\n    uint totalSupply = lpToken.totalSupply();\r\n    uint112 reserveUSDT;\r\n    uint112 _reserveELD;\r\n    uint32 _no;\r\n    (reserveUSDT, _reserveELD, _no) = lpToken.getReserves();\r\n    return _lpTokenAmount * uint(reserveUSDT) / totalSupply;\r\n  }\r\n\r\n  function getPendingReward(uint _rewardedBlock, uint _usdtAmount) public view returns (uint) {\r\n    return _rewardedBlock * _usdtAmount * 1e12 / eldPrice * 1e6 * 5 / 1e3 / blockPerDay;\r\n  }\r\n\r\n  function emergencyWithdraw() public {\r\n    UserInfo storage user = userInfo[msg.sender];\r\n    require (user.lpTokenAmount > 0, 'You have no farming');\r\n    user.lastRewardBlock = block.number;\r\n    user.usdtAmount = 0;\r\n    uint userLPTokenAmount = user.lpTokenAmount;\r\n    user.lpTokenAmount = 0;\r\n    safeLPTokenTransfer(msg.sender, userLPTokenAmount);\r\n    emit EmergencyWithdraw(msg.sender, user.lpTokenAmount);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"name\":\"usdtAmount\",\"type\":\"uint256\"},{\"name\":\"lpTokenAmount\",\"type\":\"uint256\"},{\"name\":\"lastRewardBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rewardedBlock\",\"type\":\"uint256\"},{\"name\":\"_usdtAmount\",\"type\":\"uint256\"}],\"name\":\"getPendingReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lpTokenAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setELDPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lpTokenAmount\",\"type\":\"uint256\"}],\"name\":\"getUSDTFromLPToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"lpTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"usdtAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"lpTokenAmount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eldAmount\",\"type\":\"uint256\"}],\"name\":\"Reward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"lpTokenAmount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"}]","ContractName":"ELDFarm","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6ab5d2d5d33b41b03fd516e04ebbba858a5b63f1d962982e61c6a913cbffef66"}]}