{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.7;\r\n\r\ncontract GebMath {\r\n    uint256 public constant RAY = 10 ** 27;\r\n    uint256 public constant WAD = 10 ** 18;\r\n\r\n    function ray(uint x) public pure returns (uint z) {\r\n        z = multiply(x, 10 ** 9);\r\n    }\r\n    function rad(uint x) public pure returns (uint z) {\r\n        z = multiply(x, 10 ** 27);\r\n    }\r\n    function minimum(uint x, uint y) public pure returns (uint z) {\r\n        z = (x <= y) ? x : y;\r\n    }\r\n    function addition(uint x, uint y) public pure returns (uint z) {\r\n        z = x + y;\r\n        require(z >= x, \"uint-uint-add-overflow\");\r\n    }\r\n    function subtract(uint x, uint y) public pure returns (uint z) {\r\n        z = x - y;\r\n        require(z <= x, \"uint-uint-sub-underflow\");\r\n    }\r\n    function multiply(uint x, uint y) public pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"uint-uint-mul-overflow\");\r\n    }\r\n    function rmultiply(uint x, uint y) public pure returns (uint z) {\r\n        z = multiply(x, y) / RAY;\r\n    }\r\n    function rdivide(uint x, uint y) public pure returns (uint z) {\r\n        z = multiply(x, RAY) / y;\r\n    }\r\n    function wdivide(uint x, uint y) public pure returns (uint z) {\r\n        z = multiply(x, WAD) / y;\r\n    }\r\n    function wmultiply(uint x, uint y) public pure returns (uint z) {\r\n        z = multiply(x, y) / WAD;\r\n    }\r\n    function rpower(uint x, uint n, uint base) public pure returns (uint z) {\r\n        assembly {\r\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\r\n            default {\r\n                switch mod(n, 2) case 0 { z := base } default { z := x }\r\n                let half := div(base, 2)  // for rounding.\r\n                for { n := div(n, 2) } n { n := div(n,2) } {\r\n                    let xx := mul(x, x)\r\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\r\n                    let xxRound := add(xx, half)\r\n                    if lt(xxRound, xx) { revert(0,0) }\r\n                    x := div(xxRound, base)\r\n                    if mod(n,2) {\r\n                        let zx := mul(z, x)\r\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\r\n                        let zxRound := add(zx, half)\r\n                        if lt(zxRound, zx) { revert(0,0) }\r\n                        z := div(zxRound, base)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract StabilityFeeTreasuryLike {\r\n    function getAllowance(address) virtual external view returns (uint, uint);\r\n    function systemCoin() virtual external view returns (address);\r\n    function pullFunds(address, address, uint) virtual external;\r\n    function setTotalAllowance(address, uint256) external virtual;\r\n    function setPerBlockAllowance(address, uint256) external virtual;    \r\n}\r\n\r\ncontract MandatoryFixedTreasuryReimbursement is GebMath {\r\n    // --- Auth ---\r\n    mapping (address => uint) public authorizedAccounts;\r\n    /**\r\n     * @notice Add auth to an account\r\n     * @param account Account to add auth to\r\n     */\r\n    function addAuthorization(address account) virtual external isAuthorized {\r\n        authorizedAccounts[account] = 1;\r\n        emit AddAuthorization(account);\r\n    }\r\n    /**\r\n     * @notice Remove auth from an account\r\n     * @param account Account to remove auth from\r\n     */\r\n    function removeAuthorization(address account) virtual external isAuthorized {\r\n        authorizedAccounts[account] = 0;\r\n        emit RemoveAuthorization(account);\r\n    }\r\n    /**\r\n    * @notice Checks whether msg.sender can call an authed function\r\n    **/\r\n    modifier isAuthorized {\r\n        require(authorizedAccounts[msg.sender] == 1, \"MandatoryFixedTreasuryReimbursement/account-not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Variables ---\r\n    // The fixed reward sent by the treasury to a fee receiver\r\n    uint256 public fixedReward;               // [wad]\r\n    // SF treasury\r\n    StabilityFeeTreasuryLike public treasury;\r\n\r\n    // --- Events ---\r\n    event AddAuthorization(address account);\r\n    event RemoveAuthorization(address account);\r\n    event ModifyParameters(\r\n      bytes32 parameter,\r\n      address addr\r\n    );\r\n    event ModifyParameters(\r\n      bytes32 parameter,\r\n      uint256 val\r\n    );\r\n    event RewardCaller(address indexed finalFeeReceiver, uint256 fixedReward);\r\n\r\n    constructor(address treasury_, uint256 fixedReward_) public {\r\n        require(fixedReward_ > 0, \"MandatoryFixedTreasuryReimbursement/null-reward\");\r\n        require(treasury_ != address(0), \"MandatoryFixedTreasuryReimbursement/null-treasury\");\r\n\r\n        authorizedAccounts[msg.sender] = 1;\r\n\r\n        treasury    = StabilityFeeTreasuryLike(treasury_);\r\n        fixedReward = fixedReward_;\r\n\r\n        emit AddAuthorization(msg.sender);\r\n        emit ModifyParameters(\"treasury\", treasury_);\r\n        emit ModifyParameters(\"fixedReward\", fixedReward);\r\n    }\r\n\r\n    // --- Boolean Logic ---\r\n    function both(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := and(x, y)}\r\n    }\r\n\r\n    // --- Treasury Utils ---\r\n    /*\r\n    * @notify Return the amount of SF that the treasury can transfer in one transaction when called by this contract\r\n    */\r\n    function treasuryAllowance() public view returns (uint256) {\r\n        (uint total, uint perBlock) = treasury.getAllowance(address(this));\r\n        return minimum(total, perBlock);\r\n    }\r\n    /*\r\n    * @notify Get the actual reward to be sent by taking the minimum between the fixed reward and the amount that can be sent by the treasury\r\n    */\r\n    function getCallerReward() public view returns (uint256 reward) {\r\n        reward = minimum(fixedReward, treasuryAllowance() / RAY);\r\n    }\r\n    /*\r\n    * @notice Send a SF reward to a fee receiver by calling the treasury\r\n    * @param proposedFeeReceiver The address that will receive the reward (unless null in which case msg.sender will receive it)\r\n    */\r\n    function rewardCaller(address proposedFeeReceiver) internal {\r\n        // If the receiver is the treasury itself or if the treasury is null or if the reward is zero, revert\r\n        require(address(treasury) != proposedFeeReceiver, \"MandatoryFixedTreasuryReimbursement/reward-receiver-cannot-be-treasury\");\r\n        require(both(address(treasury) != address(0), fixedReward > 0), \"MandatoryFixedTreasuryReimbursement/invalid-treasury-or-reward\");\r\n\r\n        // Determine the actual fee receiver and reward them\r\n        address finalFeeReceiver = (proposedFeeReceiver == address(0)) ? msg.sender : proposedFeeReceiver;\r\n        uint256 finalReward      = getCallerReward();\r\n        treasury.pullFunds(finalFeeReceiver, treasury.systemCoin(), finalReward);\r\n\r\n        emit RewardCaller(finalFeeReceiver, finalReward);\r\n    }\r\n}\r\n\r\nabstract contract AccountingEngineLike {\r\n    function debtPoppers(uint256) virtual public view returns (address);\r\n}\r\n\r\ncontract DebtPopperRewards is MandatoryFixedTreasuryReimbursement {\r\n    // --- Variables ---\r\n    // When the next reward period starts\r\n    uint256 public rewardPeriodStart;                    // [unix timestamp]\r\n    // Delay between two consecutive reward periods\r\n    uint256 public interPeriodDelay;                     // [seconds]\r\n    // Time (after a block of debt is popped) after which no reward can be given anymore\r\n    uint256 public rewardTimeline;                       // [seconds]\r\n    // Amount of pops that can be rewarded per period\r\n    uint256 public maxPerPeriodPops;\r\n    // Timestamp from which the contract accepts requests for rewarding debt poppers\r\n    uint256 public rewardStartTime;\r\n\r\n    // Whether a debt block has been popped\r\n    mapping(uint256 => bool)    public rewardedPop;      // [unix timestamp => bool]\r\n    // Amount of pops that were rewarded in each period\r\n    mapping(uint256 => uint256) public rewardsPerPeriod; // [unix timestamp => wad]\r\n\r\n    // Accounting engine contract\r\n    AccountingEngineLike        public accountingEngine;\r\n\r\n    // --- Events ---\r\n    event SetRewardPeriodStart(uint256 rewardPeriodStart);\r\n    event RewardForPop(uint256 slotTimestamp, uint256 reward);\r\n\r\n    constructor(\r\n        address accountingEngine_,\r\n        address treasury_,\r\n        uint256 rewardPeriodStart_,\r\n        uint256 interPeriodDelay_,\r\n        uint256 rewardTimeline_,\r\n        uint256 fixedReward_,\r\n        uint256 maxPerPeriodPops_,\r\n        uint256 rewardStartTime_\r\n    ) public MandatoryFixedTreasuryReimbursement(treasury_, fixedReward_) {\r\n        require(rewardPeriodStart_ >= now, \"DebtPopperRewards/invalid-reward-period-start\");\r\n        require(interPeriodDelay_ > 0, \"DebtPopperRewards/invalid-inter-period-delay\");\r\n        require(rewardTimeline_ > 0, \"DebtPopperRewards/invalid-harvest-timeline\");\r\n        require(maxPerPeriodPops_ > 0, \"DebtPopperRewards/invalid-max-per-period-pops\");\r\n        require(accountingEngine_ != address(0), \"DebtPopperRewards/null-accounting-engine\");\r\n\r\n        accountingEngine   = AccountingEngineLike(accountingEngine_);\r\n\r\n        rewardPeriodStart  = rewardPeriodStart_;\r\n        interPeriodDelay   = interPeriodDelay_;\r\n        rewardTimeline     = rewardTimeline_;\r\n        fixedReward        = fixedReward_;\r\n        maxPerPeriodPops   = maxPerPeriodPops_;\r\n        rewardStartTime    = rewardStartTime_;\r\n\r\n        emit ModifyParameters(\"accountingEngine\", accountingEngine_);\r\n        emit ModifyParameters(\"interPeriodDelay\", interPeriodDelay);\r\n        emit ModifyParameters(\"rewardTimeline\", rewardTimeline);\r\n        emit ModifyParameters(\"rewardStartTime\", rewardStartTime);\r\n        emit ModifyParameters(\"maxPerPeriodPops\", maxPerPeriodPops);\r\n\r\n        emit SetRewardPeriodStart(rewardPeriodStart);\r\n    }\r\n\r\n    // --- Administration ---\r\n    /*\r\n    * @notify Modify a uint256 parameter\r\n    * @param parameter The parameter name\r\n    * @param val The new value for the parameter\r\n    */\r\n    function modifyParameters(bytes32 parameter, uint256 val) external isAuthorized {\r\n        require(val > 0, \"DebtPopperRewards/invalid-value\");\r\n        if (parameter == \"interPeriodDelay\") {\r\n          interPeriodDelay = val;\r\n        }\r\n        else if (parameter == \"rewardTimeline\") {\r\n          rewardTimeline = val;\r\n        }\r\n        else if (parameter == \"fixedReward\") {\r\n          require(val > 0, \"DebtPopperRewards/null-reward\");\r\n          fixedReward = val;\r\n        }\r\n        else if (parameter == \"maxPerPeriodPops\") {\r\n          maxPerPeriodPops = val;\r\n        }\r\n        else if (parameter == \"rewardPeriodStart\") {\r\n          require(val > now, \"DebtPopperRewards/invalid-reward-period-start\");\r\n          rewardPeriodStart = val;\r\n        }\r\n        else revert(\"DebtPopperRewards/modify-unrecognized-param\");\r\n        emit ModifyParameters(parameter, val);\r\n    }\r\n    /*\r\n    * @notify Set a new treasury address\r\n    * @param parameter The parameter name\r\n    * @param addr The new address for the parameter\r\n    */\r\n    function modifyParameters(bytes32 parameter, address addr) external isAuthorized {\r\n        require(addr != address(0), \"DebtPopperRewards/null-address\");\r\n        if (parameter == \"treasury\") treasury = StabilityFeeTreasuryLike(addr);\r\n        else revert(\"DebtPopperRewards/modify-unrecognized-param\");\r\n        emit ModifyParameters(parameter, addr);\r\n    }\r\n\r\n    /*\r\n    * @notify Get rewarded for popping a debt slot from the AccountingEngine debt queue\r\n    * @oaran slotTimestamp The time of the popped slot\r\n    * @param feeReceiver The address that will receive the reward for popping\r\n    */\r\n    function getRewardForPop(uint256 slotTimestamp, address feeReceiver) external {\r\n        // Perform checks\r\n        require(slotTimestamp >= rewardStartTime, \"DebtPopperRewards/slot-time-before-reward-start\");\r\n        require(slotTimestamp < now, \"DebtPopperRewards/slot-cannot-be-in-the-future\");\r\n        require(now >= rewardPeriodStart, \"DebtPopperRewards/wait-more\");\r\n        require(addition(slotTimestamp, rewardTimeline) >= now, \"DebtPopperRewards/missed-reward-window\");\r\n        require(accountingEngine.debtPoppers(slotTimestamp) == msg.sender, \"DebtPopperRewards/not-debt-popper\");\r\n        require(!rewardedPop[slotTimestamp], \"DebtPopperRewards/pop-already-rewarded\");\r\n        require(getCallerReward() >= fixedReward, \"DebtPopperRewards/invalid-available-reward\");\r\n\r\n        // Update state\r\n        rewardedPop[slotTimestamp]          = true;\r\n        rewardsPerPeriod[rewardPeriodStart] = addition(rewardsPerPeriod[rewardPeriodStart], 1);\r\n\r\n        // If we offered rewards for too many pops, enforce a delay since rewards are available again\r\n        if (rewardsPerPeriod[rewardPeriodStart] >= maxPerPeriodPops) {\r\n          rewardPeriodStart = addition(now, interPeriodDelay);\r\n          emit SetRewardPeriodStart(rewardPeriodStart);\r\n        }\r\n\r\n        emit RewardForPop(slotTimestamp, fixedReward);\r\n\r\n        // Give the reward\r\n        rewardCaller(feeReceiver);\r\n    }\r\n}\r\n\r\ncontract DeployDebtPopperRewards {\r\n    // --- Variables ---\r\n    uint256 public constant WAD = 10**18;\r\n    uint256 public constant RAY = 10**27;\r\n    uint256 public constant RAD = 10**45;\r\n\r\n    function execute(\r\n        address _accountingEngine,\r\n        address _treasury\r\n    ) public returns (address) {\r\n        // Define params\r\n        uint256 rewardPeriodStart = now;\r\n        uint256 interPeriodDelay = 1209600;\r\n        uint256 rewardTimeline = 4838400;\r\n        uint256 fixedReward = 5 * WAD;\r\n        uint256 maxPerPeriodPops = 10;\r\n        uint256 rewardStartTime = now;\r\n\r\n        // deploy the throttler\r\n        DebtPopperRewards popperRewards = new DebtPopperRewards(\r\n            _accountingEngine,\r\n            _treasury,\r\n            rewardPeriodStart,\r\n            interPeriodDelay,\r\n            rewardTimeline,\r\n            fixedReward,\r\n            maxPerPeriodPops,\r\n            rewardStartTime\r\n\r\n        );\r\n\r\n        // setting allowances in the SF treasury\r\n        StabilityFeeTreasuryLike(_treasury).setPerBlockAllowance(address(popperRewards), 1 * RAD);\r\n        StabilityFeeTreasuryLike(_treasury).setTotalAllowance(address(popperRewards), uint(-1));\r\n\r\n        return address(popperRewards);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"RAD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_accountingEngine\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DeployDebtPopperRewards","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4aadf67c176f5da7d1fe16585dfa4e7d922004ef27f74ce6e27530793a8f11b3"}]}