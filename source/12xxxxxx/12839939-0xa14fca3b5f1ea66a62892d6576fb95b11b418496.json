{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\nimport \\\"./ERC20Basic.sol\\\";\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20  {\\n     /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    \\n    event Deposit(address indexed from, uint256 value);\\n    \\n    event Withdraw(address indexed to, uint256 value);\\n    \\n}\\n\"},\"ERC20Basic.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/179\\n */\\ncontract ERC20Basic {\\n  /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    \\n    event Deposit(address indexed from, uint256 value);\\n    \\n    event Withdraw(address indexed to, uint256 value);\\n    \\n}\\n\"},\"FavorCoinCrowdsale.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\n\\n/**\\n * @title FavorCoinCrowdsale\\n * @dev Crowdsale is a base contract for managing a token crowdsale,\\n * allowing investors to purchase tokens with ether. This contract implements\\n * such functionality in its most fundamental form and can be extended to provide additional\\n * functionality and/or custom behavior.\\n * The external interface represents the basic interface for purchasing tokens, and conform\\n * the base architecture for crowdsales. They are *not* intended to be modified / overriden.\\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\\n * the methods to add functionality. Consider using \\u0027super\\u0027 where appropiate to concatenate\\n * behavior.\\n */\\ncontract FavorCoinCrowdsale is Ownable {\\n  using SafeMath for uint256;\\n\\n  // The token being sold\\n  ERC20 public token;\\n\\n  // Address where funds are collected\\n  address payable public wallet;\\n\\n  // How many token units a buyer gets per wei\\n  uint256 public rate;\\n\\n  // Amount of wei raised\\n  uint256 public weiRaised;\\n  \\n  uint256 public FEE = 1;\\n  \\n  uint256 public tokensSold;\\n\\n  /**\\n   * Event for token purchase logging\\n   * @param purchaser who paid for the tokens\\n   * @param beneficiary who got the tokens\\n   * @param value weis paid for purchase\\n   * @param amount amount of tokens purchased\\n   */\\n  event TokenPurchase(\\n    address indexed purchaser,\\n    address indexed beneficiary,\\n    uint256 value,\\n    uint256 amount\\n  );\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    \\n    event FeeUpdated(uint256 newFee);\\n    \\n    event Deposit(address indexed from, uint256 value);\\n  /**\\n   * @param _rate Number of token units a buyer gets per wei\\n   * @param _wallet Address where collected funds will be forwarded to\\n   * @param _token Address of the token being sold\\n   */\\n  constructor(uint256 _rate, address payable  _wallet, address _token) public {\\n    require(_rate \\u003e 0);\\n    require(_wallet != address(0));\\n    require(_token != address(0));\\n\\n    rate = _rate;\\n    wallet = _wallet;\\n    token = ERC20(_token);\\n  }\\n\\n  // -----------------------------------------\\n  // Crowdsale external interface\\n  // -----------------------------------------\\n\\n  /**\\n   * @dev fallback function ***DO NOT OVERRIDE***\\n   */\\n  function () external payable {\\n    \\n    buyTokens(msg.sender);\\n  }\\n\\n  /**\\n   * @dev low level token purchase ***DO NOT OVERRIDE***\\n   * @param _beneficiary Address performing the token purchase\\n   */\\n  function buyTokens(address payable  _beneficiary) public payable {\\n    require(msg.value != 0);\\n    uint256 amountTobuy = msg.value;\\n    uint256 dexBalance = token.balanceOf(address(this));\\n    require(amountTobuy \\u003e 0, \\\"You need to send some ether\\\");\\n    \\n     _preValidatePurchase(_beneficiary, amountTobuy);\\n    uint256 _fee = SafeMath.wdiv((SafeMath.wmul(amountTobuy,FEE)),1000);\\n    uint256 _amountTobuy = SafeMath.sub(amountTobuy,_fee);\\n     \\n    // calculate token amount to be created\\n    uint256 tokens = _getTokenAmount(_amountTobuy);\\n    require(tokens \\u003c= dexBalance, \\\"Not enough tokens in the reserve\\\");\\n \\n    tokensSold = tokensSold.add(tokens);\\n    // update state\\n    weiRaised = weiRaised.add(amountTobuy);\\n    emit Deposit(_beneficiary,tokens);\\n    ERC20(token).transfer(address(_beneficiary), tokens);\\n    emit Transfer(address(0),_beneficiary,tokens);\\n    \\n    emit TokenPurchase(\\n      msg.sender,\\n      _beneficiary,\\n      amountTobuy,\\n      tokens\\n    );\\n    \\n\\n    _updatePurchasingState(_beneficiary, amountTobuy);\\n    \\n     (bool success, bytes memory mem) = address(wallet).call.value(msg.value).gas(21000)(\\u0027\\u0027);\\n        require(success);\\n        \\n  \\n    _postValidatePurchase(_beneficiary, amountTobuy);\\n  }\\n  \\n  function sendEther(address payable receiverAddr, uint256 _amount)  external onlyOwner {\\n      if (!address(receiverAddr).send(_amount)) {\\n          revert();\\n      }\\n  }\\n\\n  function sendETHMasterWallet(uint256 _amount) external onlyOwner {\\n      (bool success, bytes memory mem) = address(wallet).call.value(_amount).gas(21000)(\\u0027\\u0027);\\n        require(success);\\n  }\\n\\n function setFee(uint _fee) external onlyOwner{\\n        FEE = _fee;\\n        emit FeeUpdated(FEE);\\n    }\\nfunction setWallet(address payable _wallet) external onlyOwner{\\n    wallet = _wallet;\\n    emit FeeUpdated(FEE);\\n}\\n  function tokensRemaining() public view returns (uint256){\\n      return token.balanceOf(address(this));\\n  }\\n  \\n\\n  // -----------------------------------------\\n  // Internal interface (extensible)\\n  // -----------------------------------------\\n\\n  /**\\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\\n   * @param _beneficiary Address performing the token purchase\\n   * @param _weiAmount Value in wei involved in the purchase\\n   */\\n  function _preValidatePurchase(\\n    address _beneficiary,\\n    uint256 _weiAmount\\n  )\\n    internal\\n  {\\n    require(_beneficiary != address(0));\\n    require(_weiAmount != 0);\\n  }\\n\\n  /**\\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\\n   * @param _beneficiary Address performing the token purchase\\n   * @param _weiAmount Value in wei involved in the purchase\\n   */\\n  function _postValidatePurchase(\\n    address _beneficiary,\\n    uint256 _weiAmount\\n  )\\n    internal\\n  {\\n    // optional override\\n  }\\n\\n  /**\\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\\n   * @param _beneficiary Address performing the token purchase\\n   * @param _tokenAmount Number of tokens to be emitted\\n   */\\n  function _deliverTokens(\\n    address _beneficiary,\\n    uint256 _tokenAmount\\n  )\\n    internal\\n  {\\n    token.transfer(_beneficiary, _tokenAmount);\\n  }\\n\\n  /**\\n   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\\n   * @param _beneficiary Address receiving the tokens\\n   * @param _tokenAmount Number of tokens to be purchased\\n   */\\n  function _processPurchase(\\n    address _beneficiary,\\n    uint256 _tokenAmount\\n  )\\n    internal\\n  {\\n    _deliverTokens(_beneficiary, _tokenAmount);\\n  }\\n\\n  /**\\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\\n   * @param _beneficiary Address receiving the tokens\\n   * @param _weiAmount Value in wei involved in the purchase\\n   */\\n  function _updatePurchasingState(\\n    address _beneficiary,\\n    uint256 _weiAmount\\n  )\\n    internal\\n  {\\n    // optional override\\n  }\\n\\n  /**\\n   * @dev Override to extend the way in which ether is converted to tokens.\\n   * @param _weiAmount Value in wei to be converted into tokens\\n   * @return Number of tokens that can be purchased with the specified _weiAmount\\n   */\\n  function _getTokenAmount(uint256 _weiAmount)\\n    internal view returns (uint256)\\n  {\\n    return _weiAmount.div(rate);\\n  }\\n\\n  \\n}\\n\"},\"FavorCoinSale.sol\":{\"content\":\"/**\\n * \\n * \\n /$$$$$$$$ /$$$$$$  /$$    /$$  /$$$$$$  /$$$$$$$         /$$$$$$   /$$$$$$  /$$$$$$ /$$   /$$        /$$$$$$   /$$$$$$  /$$       /$$$$$$$$\\n| $$_____//$$__  $$| $$   | $$ /$$__  $$| $$__  $$       /$$__  $$ /$$__  $$|_  $$_/| $$$ | $$       /$$__  $$ /$$__  $$| $$      | $$_____/\\n| $$     | $$  \\\\ $$| $$   | $$| $$  \\\\ $$| $$  \\\\ $$      | $$  \\\\__/| $$  \\\\ $$  | $$  | $$$$| $$      | $$  \\\\__/| $$  \\\\ $$| $$      | $$      \\n| $$$$$  | $$$$$$$$|  $$ / $$/| $$  | $$| $$$$$$$/      | $$      | $$  | $$  | $$  | $$ $$ $$      |  $$$$$$ | $$$$$$$$| $$      | $$$$$   \\n| $$__/  | $$__  $$ \\\\  $$ $$/ | $$  | $$| $$__  $$      | $$      | $$  | $$  | $$  | $$  $$$$       \\\\____  $$| $$__  $$| $$      | $$__/   \\n| $$     | $$  | $$  \\\\  $$$/  | $$  | $$| $$  \\\\ $$      | $$    $$| $$  | $$  | $$  | $$\\\\  $$$       /$$  \\\\ $$| $$  | $$| $$      | $$      \\n| $$     | $$  | $$   \\\\  $/   |  $$$$$$/| $$  | $$      |  $$$$$$/|  $$$$$$/ /$$$$$$| $$ \\\\  $$      |  $$$$$$/| $$  | $$| $$$$$$$$| $$$$$$$$\\n|__/     |__/  |__/    \\\\_/     \\\\______/ |__/  |__/       \\\\______/  \\\\______/ |______/|__/  \\\\__/       \\\\______/ |__/  |__/|________/|________/\\n                                                                                                                                            \\n                                                                  εɖɖίε રεĢĢίε ĵΘε\\n * \\n * \\n\\n *\\n *\\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\\n */\\n\\n\\npragma solidity ^0.5.17;\\n\\nimport \\\"./IncreasingPriceCrowdsale.sol\\\";\\nimport \\\"./FavorCoinCrowdsale.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\ncontract FavorCoinSale is IncreasingPriceCrowdsale {\\n  uint256 public defaultCap;\\n  mapping(address =\\u003e uint256) public contributions;\\n  mapping(address =\\u003e uint256) public caps;\\n\\n  address  private ownerwallet;\\n  constructor (\\n    uint256 _openingTime,\\n    uint256 _closingTime,\\n    address payable _wallet,\\n    address _token,\\n    uint256 _initialRate,\\n    uint256 _finalRate,\\n    uint256 _walletCap\\n  )\\n    public\\n    FavorCoinCrowdsale(_initialRate, _wallet, _token)\\n    TimedCrowdsale(_openingTime, _closingTime)\\n    IncreasingPriceCrowdsale(_initialRate, _finalRate)\\n  {\\n      ownerwallet=_wallet;\\n      defaultCap = _walletCap;\\n  }\\n  \\n  function closeSale() onlyOwner payable public{\\n      uint256 contractTokenBalance = tokensRemaining();\\n     \\n      if(contractTokenBalance\\u003e0){\\n        ERC20(token).transfer(ownerwallet,contractTokenBalance);  \\n        emit Transfer(address(0),address(ownerwallet),contractTokenBalance);\\n      }\\n      (bool success, bytes memory mem) = address(wallet).call.value(address(this).balance).gas(21000)(\\u0027\\u0027);\\n        require(success);\\n     \\n  }\\n\\n/**\\n   * @dev Sets default user\\u0027s maximum contribution.\\n   * @param _cap Wei limit for individual contribution\\n   */\\n  function setDefaultCap( uint256 _cap) external onlyOwner {\\n      defaultCap = _cap;\\n  }\\n/**\\n   * @dev Sets a specific user\\u0027s maximum contribution.\\n   * @param _beneficiary Address to be capped\\n   * @param _cap Wei limit for individual contribution\\n   */\\n  function setUserCap(address _beneficiary, uint256 _cap) external onlyOwner {\\n    caps[_beneficiary] = _cap;\\n  }\\n/**\\n   * Called from invest() to confirm if the curret investment does not break our cap rule.\\n   */\\n  function isBreakingCap(uint tokenAmount) public view  returns (bool limitBroken) {\\n    if(tokenAmount \\u003e getTokensLeft()) {\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * We are sold out when our approve pool becomes empty.\\n   */\\n  function isCrowdsaleFull() public view returns (bool) {\\n    return getTokensLeft() == 0;\\n  }\\n\\n  /**\\n   * Get the amount of unsold tokens allocated to this contract;\\n   */\\n  function getTokensLeft() public view returns (uint) {\\n    return token.allowance(owner, address(this));\\n  }\\n\\n  /**\\n   * Transfer tokens from approve() pool to the buyer.\\n   *\\n   * Use approve() given to this crowdsale to distribute the tokens.\\n   */\\n  function assignTokens(address receiver, uint tokenAmount) public onlyOwner {\\n    if(!token.transferFrom(address(0), receiver, tokenAmount)) revert();\\n  }\\n  /**\\n   * @dev Sets a group of users\\u0027 maximum contribution.\\n   * @param _beneficiaries List of addresses to be capped\\n   * @param _cap Wei limit for individual contribution\\n   */\\n  function setGroupCap(\\n    address[] calldata  _beneficiaries,\\n    uint256 _cap\\n  )\\n    external\\n    onlyOwner\\n  {\\n    for (uint256 i = 0; i \\u003c _beneficiaries.length; i++) {\\n      caps[_beneficiaries[i]] = _cap;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the cap of a specific user.\\n   * @param _beneficiary Address whose cap is to be checked\\n   * @return Current cap for individual user\\n   */\\n  function getUserCap(address _beneficiary) public view returns (uint256) {\\n    return caps[_beneficiary];\\n  }\\n\\n  /**\\n   * @dev Returns the amount contributed so far by a sepecific user.\\n   * @param _beneficiary Address of contributor\\n   * @return User contribution so far\\n   */\\n  function getUserContribution(address _beneficiary)\\n    public view returns (uint256)\\n  {\\n    return contributions[_beneficiary];\\n  }\\n\\n  /**\\n   * @dev Extend parent behavior requiring purchase to respect the user\\u0027s funding cap.\\n   * @param _beneficiary Token purchaser\\n   * @param _weiAmount Amount of wei contributed\\n   */\\n  function _preValidatePurchase(\\n    address _beneficiary,\\n    uint256 _weiAmount\\n  )\\n    internal\\n  {\\n    super._preValidatePurchase(_beneficiary, _weiAmount);\\n    if(caps[_beneficiary]==0){\\n      caps[_beneficiary] = defaultCap;\\n    }\\n    require(contributions[_beneficiary].add(_weiAmount) \\u003c= caps[_beneficiary]);\\n  }\\n\\n  /**\\n   * @dev Extend parent behavior to update user contributions\\n   * @param _beneficiary Token purchaser\\n   * @param _weiAmount Amount of wei contributed\\n   */\\n  function _updatePurchasingState(\\n    address _beneficiary,\\n    uint256 _weiAmount\\n  )\\n    internal\\n  {\\n    super._updatePurchasingState(_beneficiary, _weiAmount);\\n    contributions[_beneficiary] = contributions[_beneficiary].add(_weiAmount);\\n  }\\n\\n}\"},\"IncreasingPriceCrowdsale.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\nimport \\\"./TimedCrowdsale.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\n/**\\n * @title IncreasingPriceCrowdsale\\n * @dev Extension of Crowdsale contract that increases the price of tokens linearly in time.\\n * Note that what should be provided to the constructor is the initial and final _rates_, that is,\\n * the amount of tokens per wei contributed. Thus, the initial rate must be greater than the final rate.\\n */\\ncontract IncreasingPriceCrowdsale is TimedCrowdsale {\\n  using SafeMath for uint256;\\n\\n  uint256 public initialRate;\\n  uint256 public finalRate;\\n\\n  /**\\n   * @dev Constructor, takes intial and final rates of tokens received per wei contributed.\\n   * @param _initialRate Number of tokens a buyer gets per wei at the start of the crowdsale\\n   * @param _finalRate Number of tokens a buyer gets per wei at the end of the crowdsale\\n   */\\n  constructor(uint256 _initialRate, uint256 _finalRate) public {\\n    require(_initialRate \\u003e= _finalRate);\\n    require(_finalRate \\u003e 0);\\n    initialRate = _initialRate;\\n    finalRate = _finalRate;\\n  }\\n\\n  /**\\n   * @dev Returns the rate of tokens per wei at the present time.\\n   * Note that, as price _increases_ with time, the rate _decreases_.\\n   * @return The number of tokens a buyer gets per wei at a given time\\n   */\\n  function getCurrentRate() public view returns (uint256) {\\n    // solium-disable-next-line security/no-block-members\\n    uint256 elapsedTime = block.timestamp.sub(openingTime);\\n    uint256 timeRange = closingTime.sub(openingTime);\\n    uint256 rateRange = initialRate.sub(finalRate);\\n    return initialRate.sub(elapsedTime.mul(rateRange).div(timeRange));\\n  }\\n\\n  /**\\n   * @dev Overrides parent method taking into account variable rate.\\n   * @param _weiAmount The value in wei to be converted into tokens\\n   * @return The number of tokens _weiAmount wei will buy at present time\\n   */\\n  function _getTokenAmount(uint256 _weiAmount)\\n    internal view returns (uint256)\\n  {\\n    uint256 currentRate = getCurrentRate();\\n    return (_weiAmount.div(currentRate)).mul(1 ether);\\n  }\\n\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n  address public owner;\\n\\n\\n  event OwnershipRenounced(address indexed previousOwner);\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  /**\\n   * @dev revert()s if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address newOwner) public onlyOwner {\\n    require(newOwner != address(0));\\n    emit OwnershipTransferred(owner, newOwner);\\n    owner = newOwner;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to relinquish control of the contract.\\n   */\\n  function renounceOwnership() public onlyOwner {\\n    emit OwnershipRenounced(owner);\\n    owner = address(0);\\n  }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return a / b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n  uint constant WAD = 10 ** 18;\\n    uint constant RAY = 10 ** 27;\\n\\n    function rmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n\\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    function wmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n    \\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\\n        uint256 c = add(a,m);\\n        uint256 d = sub(c,1);\\n        return mul(div(d,m),m);\\n    }\\n}\\n\"},\"TimedCrowdsale.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./FavorCoinCrowdsale.sol\\\";\\n\\n\\n/**\\n * @title TimedCrowdsale\\n * @dev Crowdsale accepting contributions only within a time frame.\\n */\\ncontract TimedCrowdsale is FavorCoinCrowdsale {\\n  using SafeMath for uint256;\\n\\n  uint256 public openingTime;\\n  uint256 public closingTime;\\n\\n  /**\\n   * @dev Reverts if not in crowdsale time range.\\n   */\\n  modifier onlyWhileOpen {\\n    // solium-disable-next-line security/no-block-members\\n    require(block.timestamp \\u003e= openingTime \\u0026\\u0026 block.timestamp \\u003c= closingTime);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Constructor, takes crowdsale opening and closing times.\\n   * @param _openingTime Crowdsale opening time\\n   * @param _closingTime Crowdsale closing time\\n   */\\n  constructor(uint256 _openingTime, uint256 _closingTime) public {\\n    // solium-disable-next-line security/no-block-members\\n    require(_openingTime \\u003e= block.timestamp);\\n    require(_closingTime \\u003e= _openingTime);\\n\\n    openingTime = _openingTime;\\n    closingTime = _closingTime;\\n  }\\n\\n  /**\\n   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\\n   * @return Whether crowdsale period has elapsed\\n   */\\n  function hasClosed() public view returns (bool) {\\n    // solium-disable-next-line security/no-block-members\\n    return block.timestamp \\u003e closingTime;\\n  }\\n\\n  /**\\n   * @dev Extend parent behavior requiring to be within contributing period\\n   * @param _beneficiary Token purchaser\\n   * @param _weiAmount Amount of wei contributed\\n   */\\n  function _preValidatePurchase(\\n    address _beneficiary,\\n    uint256 _weiAmount\\n  )\\n    internal\\n    onlyWhileOpen\\n  {\\n    super._preValidatePurchase(_beneficiary, _weiAmount);\\n  }\\n\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_openingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initialRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_finalRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_walletCap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"FeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"assignTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"caps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeSale\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokensLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getUserCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getUserContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"isBreakingCap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"limitBroken\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCrowdsaleFull\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendETHMasterWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiverAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setDefaultCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_beneficiaries\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setGroupCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setUserCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"FavorCoinSale","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000060f1e79900000000000000000000000000000000000000000000000000000000618d328f0000000000000000000000004b591c34d907020ebe37543aed1906d17f08b0e90000000000000000000000002e875a18060a00c4c3470b824e6cd22dfdf6ff010000000000000000000000000000000000000000000000000000bdf9085996640000000000000000000000000000000000000000000000000000001851073679000000000000000000000000000000000000000000000018650127cc3dc80000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://47bcc9fd10f696bb993ef5726d0024adb67a012a9d6e49ba6db1e805ecd8e7c5"}]}