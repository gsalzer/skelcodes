{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/staking/KyberStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nimport {Math} from '@openzeppelin/contracts/math/Math.sol';\\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\\nimport {SafeCast} from '@openzeppelin/contracts/utils/SafeCast.sol';\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\\nimport {PermissionAdmin} from '@kyber.network/utils-sc/contracts/PermissionAdmin.sol';\\n\\nimport {IKyberStaking} from '../interfaces/staking/IKyberStaking.sol';\\nimport {IWithdrawHandler} from '../interfaces/staking/IWithdrawHandler.sol';\\nimport {EpochUtils} from '../misc/EpochUtils.sol';\\n\\n/**\\n * @notice   This contract is using SafeMath for uint, which is inherited from EpochUtils\\n *           Some events are moved to interface, easier for public uses\\n */\\ncontract KyberStaking is IKyberStaking, EpochUtils, ReentrancyGuard, PermissionAdmin {\\n  using Math for uint256;\\n  using SafeMath for uint256;\\n  struct StakerData {\\n    uint128 stake;\\n    uint128 delegatedStake;\\n    address representative;\\n    // true/false: if data has been initialized at an epoch for a staker\\n    bool hasInited;\\n  }\\n\\n  IERC20 public immutable override kncToken;\\n\\n  IWithdrawHandler public withdrawHandler;\\n  // staker data per epoch, including stake, delegated stake and representative\\n  mapping(uint256 => mapping(address => StakerData)) internal stakerPerEpochData;\\n  // latest data of a staker, including stake, delegated stake, representative\\n  mapping(address => StakerData) internal stakerLatestData;\\n\\n  // event is fired if something is wrong with withdrawal\\n  // even though the withdrawal is still successful\\n  event WithdrawDataUpdateFailed(uint256 curEpoch, address staker, uint256 amount);\\n\\n  event UpdateWithdrawHandler(IWithdrawHandler withdrawHandler);\\n\\n  constructor(\\n    address _admin,\\n    IERC20 _kncToken,\\n    uint256 _epochPeriod,\\n    uint256 _startTime\\n  ) PermissionAdmin(_admin) EpochUtils(_epochPeriod, _startTime) {\\n    require(_startTime >= block.timestamp, 'ctor: start in the past');\\n\\n    require(_kncToken != IERC20(0), 'ctor: kncToken 0');\\n    kncToken = _kncToken;\\n  }\\n\\n  function updateWithdrawHandler(IWithdrawHandler _withdrawHandler) external onlyAdmin {\\n    withdrawHandler = _withdrawHandler;\\n\\n    emit UpdateWithdrawHandler(_withdrawHandler);\\n  }\\n\\n  /**\\n   * @dev calls to set delegation for msg.sender, will take effect from the next epoch\\n   * @param newRepresentative address to delegate to\\n   */\\n  function delegate(address newRepresentative) external override {\\n    require(newRepresentative != address(0), 'delegate: representative 0');\\n    address staker = msg.sender;\\n    uint256 curEpoch = getCurrentEpochNumber();\\n\\n    initDataIfNeeded(staker, curEpoch);\\n\\n    address curRepresentative = stakerPerEpochData[curEpoch + 1][staker].representative;\\n    // nothing changes here\\n    if (newRepresentative == curRepresentative) {\\n      return;\\n    }\\n\\n    uint256 updatedStake = stakerPerEpochData[curEpoch + 1][staker].stake;\\n\\n    // reduce delegatedStake for curRepresentative if needed\\n    if (curRepresentative != staker) {\\n      initDataIfNeeded(curRepresentative, curEpoch);\\n      decreaseDelegatedStake(stakerPerEpochData[curEpoch + 1][curRepresentative], updatedStake);\\n      decreaseDelegatedStake(stakerLatestData[curRepresentative], updatedStake);\\n\\n      emit Delegated(staker, curRepresentative, curEpoch, false);\\n    }\\n\\n    stakerLatestData[staker].representative = newRepresentative;\\n    stakerPerEpochData[curEpoch + 1][staker].representative = newRepresentative;\\n\\n    // ignore if staker is delegating back to himself\\n    if (newRepresentative != staker) {\\n      initDataIfNeeded(newRepresentative, curEpoch);\\n      increaseDelegatedStake(stakerPerEpochData[curEpoch + 1][newRepresentative], updatedStake);\\n      increaseDelegatedStake(stakerLatestData[newRepresentative], updatedStake);\\n\\n      emit Delegated(staker, newRepresentative, curEpoch, true);\\n    }\\n  }\\n\\n  /**\\n   * @dev call to stake more KNC for msg.sender\\n   * @param amount amount of KNC to stake\\n   */\\n  function deposit(uint256 amount) external override {\\n    require(amount > 0, 'deposit: amount is 0');\\n\\n    uint256 curEpoch = getCurrentEpochNumber();\\n    address staker = msg.sender;\\n\\n    // collect KNC token from staker\\n    require(kncToken.transferFrom(staker, address(this), amount), 'deposit: can not get token');\\n\\n    initDataIfNeeded(staker, curEpoch);\\n    increaseStake(stakerPerEpochData[curEpoch + 1][staker], amount);\\n    increaseStake(stakerLatestData[staker], amount);\\n\\n    // increase delegated stake for address that staker has delegated to (if it is not staker)\\n    address representative = stakerPerEpochData[curEpoch + 1][staker].representative;\\n    if (representative != staker) {\\n      initDataIfNeeded(representative, curEpoch);\\n      increaseDelegatedStake(stakerPerEpochData[curEpoch + 1][representative], amount);\\n      increaseDelegatedStake(stakerLatestData[representative], amount);\\n    }\\n\\n    emit Deposited(curEpoch, staker, amount);\\n  }\\n\\n  /**\\n   * @dev call to withdraw KNC from staking\\n   * @dev it could affect voting point when calling withdrawHandlers handleWithdrawal\\n   * @param amount amount of KNC to withdraw\\n   */\\n  function withdraw(uint256 amount) external override nonReentrant {\\n    require(amount > 0, 'withdraw: amount is 0');\\n\\n    uint256 curEpoch = getCurrentEpochNumber();\\n    address staker = msg.sender;\\n\\n    require(\\n      stakerLatestData[staker].stake >= amount,\\n      'withdraw: latest amount staked < withdrawal amount'\\n    );\\n\\n    initDataIfNeeded(staker, curEpoch);\\n    decreaseStake(stakerLatestData[staker], amount);\\n\\n    (bool success, ) = address(this).call(\\n      abi.encodeWithSelector(KyberStaking.handleWithdrawal.selector, staker, amount, curEpoch)\\n    );\\n    if (!success) {\\n      // Note: should catch this event to check if something went wrong\\n      emit WithdrawDataUpdateFailed(curEpoch, staker, amount);\\n    }\\n\\n    // transfer KNC back to staker\\n    require(kncToken.transfer(staker, amount), 'withdraw: can not transfer knc');\\n    emit Withdraw(curEpoch, staker, amount);\\n  }\\n\\n  /**\\n   * @dev initialize data if needed, then return staker's data for current epoch\\n   * @param staker - staker's address to initialize and get data for\\n   */\\n  function initAndReturnStakerDataForCurrentEpoch(address staker)\\n    external\\n    override\\n    nonReentrant\\n    returns (\\n      uint256 stake,\\n      uint256 delegatedStake,\\n      address representative\\n    )\\n  {\\n    uint256 curEpoch = getCurrentEpochNumber();\\n    initDataIfNeeded(staker, curEpoch);\\n\\n    StakerData memory stakerData = stakerPerEpochData[curEpoch][staker];\\n    stake = stakerData.stake;\\n    delegatedStake = stakerData.delegatedStake;\\n    representative = stakerData.representative;\\n  }\\n\\n  /**\\n   * @notice return raw data of a staker for an epoch\\n   *         WARN: should be used only for initialized data\\n   *          if data has not been initialized, it will return all 0\\n   *          pool master shouldn't use this function to compute/distribute rewards of pool members\\n   */\\n  function getStakerRawData(address staker, uint256 epoch)\\n    external\\n    override\\n    view\\n    returns (\\n      uint256 stake,\\n      uint256 delegatedStake,\\n      address representative\\n    )\\n  {\\n    StakerData memory stakerData = stakerPerEpochData[epoch][staker];\\n    stake = stakerData.stake;\\n    delegatedStake = stakerData.delegatedStake;\\n    representative = stakerData.representative;\\n  }\\n\\n  /**\\n   * @dev allow to get data up to current epoch + 1\\n   */\\n  function getStake(address staker, uint256 epoch) external view returns (uint256) {\\n    uint256 curEpoch = getCurrentEpochNumber();\\n    if (epoch > curEpoch + 1) {\\n      return 0;\\n    }\\n    uint256 i = epoch;\\n    while (true) {\\n      if (stakerPerEpochData[i][staker].hasInited) {\\n        return stakerPerEpochData[i][staker].stake;\\n      }\\n      if (i == 0) {\\n        break;\\n      }\\n      i--;\\n    }\\n    return 0;\\n  }\\n\\n  /**\\n   * @dev allow to get data up to current epoch + 1\\n   */\\n  function getDelegatedStake(address staker, uint256 epoch) external view returns (uint256) {\\n    uint256 curEpoch = getCurrentEpochNumber();\\n    if (epoch > curEpoch + 1) {\\n      return 0;\\n    }\\n    uint256 i = epoch;\\n    while (true) {\\n      if (stakerPerEpochData[i][staker].hasInited) {\\n        return stakerPerEpochData[i][staker].delegatedStake;\\n      }\\n      if (i == 0) {\\n        break;\\n      }\\n      i--;\\n    }\\n    return 0;\\n  }\\n\\n  /**\\n   * @dev allow to get data up to current epoch + 1\\n   */\\n  function getRepresentative(address staker, uint256 epoch) external view returns (address) {\\n    uint256 curEpoch = getCurrentEpochNumber();\\n    if (epoch > curEpoch + 1) {\\n      return address(0);\\n    }\\n    uint256 i = epoch;\\n    while (true) {\\n      if (stakerPerEpochData[i][staker].hasInited) {\\n        return stakerPerEpochData[i][staker].representative;\\n      }\\n      if (i == 0) {\\n        break;\\n      }\\n      i--;\\n    }\\n    // not delegated to anyone, default to yourself\\n    return staker;\\n  }\\n\\n  /**\\n   * @notice return combine data (stake, delegatedStake, representative) of a staker\\n   * @dev allow to get staker data up to current epoch + 1\\n   */\\n  function getStakerData(address staker, uint256 epoch)\\n    external\\n    override\\n    view\\n    returns (\\n      uint256 stake,\\n      uint256 delegatedStake,\\n      address representative\\n    )\\n  {\\n    stake = 0;\\n    delegatedStake = 0;\\n    representative = address(0);\\n\\n    uint256 curEpoch = getCurrentEpochNumber();\\n    if (epoch > curEpoch + 1) {\\n      return (stake, delegatedStake, representative);\\n    }\\n    uint256 i = epoch;\\n    while (true) {\\n      if (stakerPerEpochData[i][staker].hasInited) {\\n        stake = stakerPerEpochData[i][staker].stake;\\n        delegatedStake = stakerPerEpochData[i][staker].delegatedStake;\\n        representative = stakerPerEpochData[i][staker].representative;\\n        return (stake, delegatedStake, representative);\\n      }\\n      if (i == 0) {\\n        break;\\n      }\\n      i--;\\n    }\\n    // not delegated to anyone, default to yourself\\n    representative = staker;\\n  }\\n\\n  function getLatestRepresentative(address staker) external view returns (address) {\\n    return\\n      stakerLatestData[staker].representative == address(0)\\n        ? staker\\n        : stakerLatestData[staker].representative;\\n  }\\n\\n  function getLatestDelegatedStake(address staker) external view returns (uint256) {\\n    return stakerLatestData[staker].delegatedStake;\\n  }\\n\\n  function getLatestStakeBalance(address staker) external view returns (uint256) {\\n    return stakerLatestData[staker].stake;\\n  }\\n\\n  function getLatestStakerData(address staker)\\n    external\\n    override\\n    view\\n    returns (\\n      uint256 stake,\\n      uint256 delegatedStake,\\n      address representative\\n    )\\n  {\\n    stake = stakerLatestData[staker].stake;\\n    delegatedStake = stakerLatestData[staker].delegatedStake;\\n    representative = stakerLatestData[staker].representative == address(0)\\n      ? staker\\n      : stakerLatestData[staker].representative;\\n  }\\n\\n  /**\\n    * @dev  separate logics from withdraw, so staker can withdraw as long as amount <= staker's deposit amount\\n            calling this function from withdraw function, ignore reverting\\n    * @param staker staker that is withdrawing\\n    * @param amount amount to withdraw\\n    * @param curEpoch current epoch\\n    */\\n  function handleWithdrawal(\\n    address staker,\\n    uint256 amount,\\n    uint256 curEpoch\\n  ) external {\\n    require(msg.sender == address(this), 'only staking contract');\\n    // update staker's data for next epoch\\n    decreaseStake(stakerPerEpochData[curEpoch + 1][staker], amount);\\n    address representative = stakerPerEpochData[curEpoch + 1][staker].representative;\\n    if (representative != staker) {\\n      initDataIfNeeded(representative, curEpoch);\\n      decreaseDelegatedStake(stakerPerEpochData[curEpoch + 1][representative], amount);\\n      decreaseDelegatedStake(stakerLatestData[representative], amount);\\n    }\\n\\n    representative = stakerPerEpochData[curEpoch][staker].representative;\\n    uint256 curStake = stakerPerEpochData[curEpoch][staker].stake;\\n    uint256 lStakeBal = stakerLatestData[staker].stake;\\n    uint256 newStake = curStake.min(lStakeBal);\\n    uint256 reduceAmount = curStake.sub(newStake); // newStake is always <= curStake\\n\\n    if (reduceAmount > 0) {\\n      if (representative != staker) {\\n        initDataIfNeeded(representative, curEpoch);\\n        // staker has delegated to representative, withdraw will affect representative's delegated stakes\\n        decreaseDelegatedStake(stakerPerEpochData[curEpoch][representative], reduceAmount);\\n      }\\n      stakerPerEpochData[curEpoch][staker].stake = SafeCast.toUint128(newStake);\\n      // call withdrawHandlers to reduce reward, if staker has delegated, then pass his representative\\n      if (withdrawHandler != IWithdrawHandler(0)) {\\n        (bool success, ) = address(withdrawHandler).call(\\n          abi.encodeWithSelector(\\n            IWithdrawHandler.handleWithdrawal.selector,\\n            representative,\\n            reduceAmount\\n          )\\n        );\\n        if (!success) {\\n          emit WithdrawDataUpdateFailed(curEpoch, staker, amount);\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev initialize data if it has not been initialized yet\\n   * @param staker staker's address to initialize\\n   * @param epoch should be current epoch\\n   */\\n  function initDataIfNeeded(address staker, uint256 epoch) internal {\\n    address representative = stakerLatestData[staker].representative;\\n    if (representative == address(0)) {\\n      // not delegate to anyone, consider as delegate to yourself\\n      stakerLatestData[staker].representative = staker;\\n      representative = staker;\\n    }\\n\\n    uint128 lStakeBal = stakerLatestData[staker].stake;\\n    uint128 ldStake = stakerLatestData[staker].delegatedStake;\\n\\n    if (!stakerPerEpochData[epoch][staker].hasInited) {\\n      stakerPerEpochData[epoch][staker] = StakerData({\\n        stake: lStakeBal,\\n        delegatedStake: ldStake,\\n        representative: representative,\\n        hasInited: true\\n      });\\n    }\\n\\n    // whenever stakers deposit/withdraw/delegate, the current and next epoch data need to be updated\\n    // as the result, we will also initialize data for staker at the next epoch\\n    if (!stakerPerEpochData[epoch + 1][staker].hasInited) {\\n      stakerPerEpochData[epoch + 1][staker] = StakerData({\\n        stake: lStakeBal,\\n        delegatedStake: ldStake,\\n        representative: representative,\\n        hasInited: true\\n      });\\n    }\\n  }\\n\\n  function decreaseDelegatedStake(StakerData storage stakeData, uint256 amount) internal {\\n    stakeData.delegatedStake = SafeCast.toUint128(uint256(stakeData.delegatedStake).sub(amount));\\n  }\\n\\n  function increaseDelegatedStake(StakerData storage stakeData, uint256 amount) internal {\\n    stakeData.delegatedStake = SafeCast.toUint128(uint256(stakeData.delegatedStake).add(amount));\\n  }\\n\\n  function increaseStake(StakerData storage stakeData, uint256 amount) internal {\\n    stakeData.stake = SafeCast.toUint128(uint256(stakeData.stake).add(amount));\\n  }\\n\\n  function decreaseStake(StakerData storage stakeData, uint256 amount) internal {\\n    stakeData.stake = SafeCast.toUint128(uint256(stakeData.stake).sub(amount));\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@kyber.network/utils-sc/contracts/PermissionAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\n\\nabstract contract PermissionAdmin {\\n    address public admin;\\n    address public pendingAdmin;\\n\\n    event AdminClaimed(address newAdmin, address previousAdmin);\\n\\n    event TransferAdminPending(address pendingAdmin);\\n\\n    constructor(address _admin) {\\n        require(_admin != address(0), \\\"admin 0\\\");\\n        admin = _admin;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"only admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current admin to set the pendingAdmin address.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdmin(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0), \\\"new admin 0\\\");\\n        emit TransferAdminPending(newAdmin);\\n        pendingAdmin = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0), \\\"admin 0\\\");\\n        emit TransferAdminPending(newAdmin);\\n        emit AdminClaimed(newAdmin, admin);\\n        admin = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\\n     */\\n    function claimAdmin() public {\\n        require(pendingAdmin == msg.sender, \\\"not pending\\\");\\n        emit AdminClaimed(pendingAdmin, admin);\\n        admin = pendingAdmin;\\n        pendingAdmin = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/staking/IKyberStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport {IEpochUtils} from './IEpochUtils.sol';\\n\\ninterface IKyberStaking is IEpochUtils {\\n  event Delegated(\\n    address indexed staker,\\n    address indexed representative,\\n    uint256 indexed epoch,\\n    bool isDelegated\\n  );\\n  event Deposited(uint256 curEpoch, address indexed staker, uint256 amount);\\n  event Withdraw(uint256 indexed curEpoch, address indexed staker, uint256 amount);\\n\\n  function initAndReturnStakerDataForCurrentEpoch(address staker)\\n    external\\n    returns (\\n      uint256 stake,\\n      uint256 delegatedStake,\\n      address representative\\n    );\\n\\n  function deposit(uint256 amount) external;\\n\\n  function delegate(address dAddr) external;\\n\\n  function withdraw(uint256 amount) external;\\n\\n  /**\\n   * @notice return combine data (stake, delegatedStake, representative) of a staker\\n   * @dev allow to get staker data up to current epoch + 1\\n   */\\n  function getStakerData(address staker, uint256 epoch)\\n    external\\n    view\\n    returns (\\n      uint256 stake,\\n      uint256 delegatedStake,\\n      address representative\\n    );\\n\\n  function getLatestStakerData(address staker)\\n    external\\n    view\\n    returns (\\n      uint256 stake,\\n      uint256 delegatedStake,\\n      address representative\\n    );\\n\\n  /**\\n   * @notice return raw data of a staker for an epoch\\n   *         WARN: should be used only for initialized data\\n   *          if data has not been initialized, it will return all 0\\n   *          pool master shouldn't use this function to compute/distribute rewards of pool members\\n   */\\n  function getStakerRawData(address staker, uint256 epoch)\\n    external\\n    view\\n    returns (\\n      uint256 stake,\\n      uint256 delegatedStake,\\n      address representative\\n    );\\n\\n  function kncToken() external view returns (IERC20);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/staking/IWithdrawHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n/**\\n * @title Interface for callbacks hooks when user withdraws from staking contract\\n */\\ninterface IWithdrawHandler {\\n  function handleWithdrawal(address staker, uint256 reduceAmount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/misc/EpochUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\n\\nimport '../interfaces/staking/IEpochUtils.sol';\\n\\ncontract EpochUtils is IEpochUtils {\\n  using SafeMath for uint256;\\n\\n  uint256 public immutable override epochPeriodInSeconds;\\n  uint256 public immutable override firstEpochStartTime;\\n\\n  constructor(uint256 _epochPeriod, uint256 _startTime) {\\n    require(_epochPeriod > 0, 'ctor: epoch period is 0');\\n\\n    epochPeriodInSeconds = _epochPeriod;\\n    firstEpochStartTime = _startTime;\\n  }\\n\\n  function getCurrentEpochNumber() public override view returns (uint256) {\\n    return getEpochNumber(block.timestamp);\\n  }\\n\\n  function getEpochNumber(uint256 currentTime) public override view returns (uint256) {\\n    if (currentTime < firstEpochStartTime || epochPeriodInSeconds == 0) {\\n      return 0;\\n    }\\n    // ((currentTime - firstEpochStartTime) / epochPeriodInSeconds) + 1;\\n    return ((currentTime.sub(firstEpochStartTime)).div(epochPeriodInSeconds)).add(1);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/staking/IEpochUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\ninterface IEpochUtils {\\n  function epochPeriodInSeconds() external view returns (uint256);\\n\\n  function firstEpochStartTime() external view returns (uint256);\\n\\n  function getCurrentEpochNumber() external view returns (uint256);\\n\\n  function getEpochNumber(uint256 timestamp) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_kncToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_epochPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"representative\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isDelegated\",\"type\":\"bool\"}],\"name\":\"Delegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"curEpoch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IWithdrawHandler\",\"name\":\"withdrawHandler\",\"type\":\"address\"}],\"name\":\"UpdateWithdrawHandler\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"curEpoch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"curEpoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawDataUpdateFailed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRepresentative\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochPeriodInSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstEpochStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpochNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getDelegatedStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"}],\"name\":\"getEpochNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getLatestDelegatedStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getLatestRepresentative\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getLatestStakeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getLatestStakerData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delegatedStake\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"representative\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getRepresentative\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getStakerData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delegatedStake\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"representative\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getStakerRawData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delegatedStake\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"representative\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curEpoch\",\"type\":\"uint256\"}],\"name\":\"handleWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"initAndReturnStakerDataForCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delegatedStake\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"representative\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kncToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IWithdrawHandler\",\"name\":\"_withdrawHandler\",\"type\":\"address\"}],\"name\":\"updateWithdrawHandler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawHandler\",\"outputs\":[{\"internalType\":\"contract IWithdrawHandler\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"KyberStaking","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"000000000000000000000000560fb65513a3e9f22df97501393360bf0db448ad000000000000000000000000defa4e8a7bcba345f687a2f1456f5edd9ce972020000000000000000000000000000000000000000000000000000000000127500000000000000000000000000000000000000000000000000000000006087b81b","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}