{"status":"1","message":"OK","result":[{"SourceCode":"{\"CoinvestingDeFiERC20.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\nimport \\\"./ICoinvestingDeFiERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract CoinvestingDeFiERC20 is ICoinvestingDeFiERC20 {\\n    using SafeMath for uint;\\n    // Public variables\\n    uint8 public constant override decimals = 18;    \\n    string public constant override name = \\\"Coinvesting DeFi V2\\\";\\n    string public constant override symbol = \\\"COINVEX-V2\\\";    \\n    uint public override totalSupply;\\n\\n    bytes32 public override DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    \\n    mapping(address =\\u003e mapping(address =\\u003e uint)) public override allowance;\\n    mapping(address =\\u003e uint) public override balanceOf;\\n    mapping(address =\\u003e uint) public override nonces;\\n\\n    constructor() {\\n        uint chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\u0027EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\u0027),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\u00271\\u0027)),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    // External functions\\n    function approve(\\n        address spender,\\n        uint value\\n    )\\n    external\\n    virtual \\n    override\\n    returns (bool)\\n    {\\n        _approve(\\n            payable(msg.sender), \\n            spender, \\n            value\\n        );\\n        return true;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint value,\\n        uint deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    )\\n    external \\n    override\\n    {\\n        require(deadline \\u003e= block.timestamp, \\\"ERC20: EXPD\\\");\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\u0027\\\\x19\\\\x01\\u0027,\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        owner,\\n                        spender,\\n                        value,\\n                        nonces[owner]++,\\n                        deadline\\n                    )\\n                )\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress != address(0) \\u0026\\u0026 recoveredAddress == owner,\\n            \\\"ERC20: INV_SIG\\\");\\n        _approve(owner, spender, value);\\n    }\\n\\n    function transfer(\\n        address to,\\n        uint value\\n    )\\n    external\\n    virtual \\n    override\\n    returns (bool)\\n    {\\n        _transfer(\\n            payable(msg.sender),\\n            to,\\n            value\\n        );\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from, \\n        address to, \\n        uint value\\n    ) \\n    external \\n    virtual \\n    override \\n    returns (bool) \\n    {\\n        if (allowance[from][msg.sender] != type(uint).max) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(\\n            from, \\n            to, \\n            value\\n        );\\n        return true;\\n    }\\n\\n    // Internal functions\\n    function _burn(\\n        address from,\\n        uint value\\n    )\\n    internal\\n    virtual\\n    {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _mint(\\n        address to, \\n        uint value\\n    )\\n    internal \\n    virtual \\n    {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    // Private functions\\n    function _approve(\\n        address owner, \\n        address spender, \\n        uint value\\n    ) \\n    private  \\n    {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n    \\n    function _transfer(\\n        address from, \\n        address to, \\n        uint value\\n    ) \\n    private \\n    {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n}\\n\"},\"CoinvestingDeFiFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\nimport \\\"./ICoinvestingDeFiFactory.sol\\\";\\nimport \\\"./CoinvestingDeFiPair.sol\\\";\\n\\ncontract CoinvestingDeFiFactory is ICoinvestingDeFiFactory {\\n    // Public variables\\n    address[] public override allPairs;\\n    address public override feeTo;\\n    address public override feeToSetter;\\n    \\n    mapping(address =\\u003e mapping(address =\\u003e address)) public override getPair;\\n\\n    constructor(address _feeToSetter) {\\n        feeToSetter = _feeToSetter;\\n    }\\n\\n    //External functions\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    )\\n    external\\n    override\\n    returns (address pair)\\n    {\\n        require(tokenA != tokenB, \\\"FAC: IDT_ADDR\\\");\\n        (address token0, address token1) = tokenA \\u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), \\\"FAC: ZERO_ADDR\\\");\\n        require(getPair[token0][token1] == address(0), \\\"FAC: PAIR_EXISTS\\\");\\n        bytes memory bytecode = type(CoinvestingDeFiPair).creationCode;\\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\\n        assembly {\\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n        ICoinvestingDeFiPair(pair).initialize(token0, token1);\\n        getPair[token0][token1] = pair;\\n        getPair[token1][token0] = pair;\\n        allPairs.push(pair);\\n        emit PairCreated(token0, token1, pair, allPairs.length);\\n    }\\n\\n    function setFeeTo(address _feeTo) external override {\\n        require(msg.sender == feeToSetter,\\n            \\\"FAC: CALLER_AINT_SETTER\\\");\\n        feeTo = _feeTo;\\n    }\\n\\n    function setFeeToSetter(address _feeToSetter) external override {\\n        require(msg.sender == feeToSetter,\\n            \\\"FAC: CALLER_AINT_SETTER\\\");\\n        feeToSetter = _feeToSetter;\\n    }\\n\\n    //External functions that are view\\n    function allPairsLength() external view override returns (uint) {\\n        return allPairs.length;\\n    }\\n}\\n\"},\"CoinvestingDeFiPair.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\nimport \\\"./ICoinvestingDeFiCallee.sol\\\";\\nimport \\\"./ICoinvestingDeFiFactory.sol\\\";\\nimport \\\"./ICoinvestingDeFiPair.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Math.sol\\\";\\nimport \\\"./UQ112x112.sol\\\";\\nimport \\\"./CoinvestingDeFiERC20.sol\\\";\\n\\ncontract CoinvestingDeFiPair is ICoinvestingDeFiPair, CoinvestingDeFiERC20 {\\n    using SafeMath  for uint;\\n    using UQ112x112 for uint224;\\n\\n    // Public variables\\n    address public override factory;\\n    uint public override kLast;\\n    uint public override price0CumulativeLast;\\n    uint public override price1CumulativeLast;\\n    address public override token0;\\n    address public override token1;\\n\\n    uint public constant override MINIMUM_LIQUIDITY = 10**3;\\n        \\n    // Private variables\\n    uint32  private blockTimestampLast;\\n    uint112 private reserve0;\\n    uint112 private reserve1;    \\n    uint private unlocked = 1;\\n\\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\n\\n    // Modifiers\\n    modifier lock() {\\n        require(unlocked == 1, \\\"PAIR: LOCKED\\\");\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    constructor() {\\n        factory = payable(msg.sender);\\n    }\\n\\n    // External functions\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function burn(address to) external override lock returns (\\n        uint amount0,\\n        uint amount1\\n    ) \\n    {\\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves();\\n        address _token0 = token0;\\n        address _token1 = token1;\\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\\n        uint liquidity = balanceOf[address(this)];\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint _totalSupply = totalSupply;\\n        amount0 = liquidity.mul(balance0) / _totalSupply;\\n        amount1 = liquidity.mul(balance1) / _totalSupply;\\n        require(\\n            amount0 \\u003e 0 \\u0026\\u0026 amount1 \\u003e 0, \\n            \\\"PAIR: INSUF_LIQ_BURN\\\"\\n        );\\n\\n        _burn(address(this), liquidity);\\n        _safeTransfer(_token0, to, amount0);\\n        _safeTransfer(_token1, to, amount1);\\n        balance0 = IERC20(_token0).balanceOf(address(this));\\n        balance1 = IERC20(_token1).balanceOf(address(this));\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); \\n        emit Burn(msg.sender, amount0, amount1, to);\\n    }\\n    \\n    // called once by the factory at time of deployment\\n    function initialize(\\n        address _token0,\\n        address _token1\\n    )\\n    external\\n    override\\n    {\\n        require(msg.sender == factory, \\\"PAIR: CALLER_MUST_BE_FAC\\\");\\n        token0 = _token0;\\n        token1 = _token1;\\n    }\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function mint(address to) external override lock returns (uint liquidity) {\\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves();\\n        uint balance0 = IERC20(token0).balanceOf(address(this));\\n        uint balance1 = IERC20(token1).balanceOf(address(this));\\n        uint amount0 = balance0.sub(_reserve0);\\n        uint amount1 = balance1.sub(_reserve1);\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint _totalSupply = totalSupply; \\n        if (_totalSupply == 0) {\\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\\n           _mint(address(0), MINIMUM_LIQUIDITY);\\n        } else\\n            liquidity = Math.min(\\n                amount0.mul(_totalSupply) / _reserve0,\\n                amount1.mul(_totalSupply) / _reserve1\\n            );\\n        require(liquidity \\u003e 0, \\\"PAIR: INSUF_LIQ_MINT\\\");\\n        _mint(to, liquidity);\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        if (feeOn) kLast = uint(reserve0).mul(reserve1);\\n        emit Mint(msg.sender, amount0, amount1);\\n    }\\n\\n    // force balances to match reserves\\n    function skim(address to) external override lock {\\n        address _token0 = token0; \\n        address _token1 = token1; \\n        _safeTransfer(\\n            _token0,\\n            to,\\n            IERC20(_token0).balanceOf(address(this)).sub(reserve0)\\n        );\\n        _safeTransfer(\\n            _token1,\\n            to,\\n            IERC20(_token1).balanceOf(address(this)).sub(reserve1)\\n        );\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function swap(\\n        uint amount0Out,\\n        uint amount1Out,\\n        address to,\\n        bytes calldata data\\n    )\\n    external\\n    override\\n    lock\\n    {\\n        require(\\n            amount0Out \\u003e 0 || amount1Out \\u003e 0, \\n            \\\"PAIR: INSUF_OUT_AMT\\\"\\n        );\\n\\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves();\\n        require(\\n            amount0Out \\u003c _reserve0 \\u0026\\u0026 amount1Out \\u003c _reserve1, \\n            \\\"PAIR: INSUF_LIQ\\\"\\n        );\\n        \\n        uint balance0;\\n        uint balance1;\\n        {\\n            address _token0 = token0;\\n            address _token1 = token1;\\n            require(\\n                to != _token0 \\u0026\\u0026 to != _token1, \\n                \\\"PAIR: INV_TO\\\"\\n            );\\n\\n            if (amount0Out \\u003e 0) _safeTransfer(_token0, to, amount0Out);\\n            if (amount1Out \\u003e 0) _safeTransfer(_token1, to, amount1Out);\\n            if (data.length \\u003e 0) \\n                ICoinvestingDeFiCallee(to).coinvestingDeFiCall(\\n                    payable(msg.sender),\\n                    amount0Out,\\n                    amount1Out,\\n                    data\\n                );\\n            balance0 = IERC20(_token0).balanceOf(address(this));\\n            balance1 = IERC20(_token1).balanceOf(address(this));\\n        } \\n\\n        uint amount0In = balance0 \\u003e _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\\n        uint amount1In = balance1 \\u003e _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\\n        require(amount0In \\u003e 0 || amount1In \\u003e 0, \\\"PAIR: INSUF_IN_AMT\\\");\\n        {\\n            uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\\n            uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\\n            require(\\n                balance0Adjusted.mul(balance1Adjusted) \\u003e= uint(_reserve0).mul(_reserve1).mul(1000**2),\\n                \\\"Pair: K\\\"\\n            );\\n        }\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    // force reserves to match balances\\n    function sync() external override lock {\\n        _update(\\n            IERC20(token0).balanceOf(address(this)), \\n            IERC20(token1).balanceOf(address(this)), \\n            reserve0, \\n            reserve1\\n        );\\n    }\\n\\n    // External functions that are view\\n    function getReserves() \\n        public\\n        override \\n        view \\n        returns (\\n            uint112 _reserve0, \\n            uint112 _reserve1, \\n            uint32 _blockTimestampLast\\n        ) \\n    {\\n        _reserve0 = reserve0;\\n        _reserve1 = reserve1;\\n        _blockTimestampLast = blockTimestampLast;\\n    }\\n\\n    // Private functions\\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\\n    function _mintFee(\\n        uint112 _reserve0,\\n        uint112 _reserve1\\n    )\\n    private\\n    returns (bool feeOn)\\n    {\\n        address feeTo = ICoinvestingDeFiFactory(factory).feeTo();\\n        feeOn = feeTo != address(0);\\n        uint _kLast = kLast; // gas savings\\n        if (feeOn) {\\n            if (_kLast != 0) {\\n                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\\n                uint rootKLast = Math.sqrt(_kLast);\\n                if (rootK \\u003e rootKLast) {\\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\\n                    uint denominator = rootK.mul(5).add(rootKLast);\\n                    uint liquidity = numerator / denominator;\\n                    if (liquidity \\u003e 0) _mint(feeTo, liquidity);\\n                }\\n            }\\n        } else if (_kLast != 0) {\\n           kLast = 0; \\n        } \\n    }\\n\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint value\\n    ) \\n    private \\n    {\\n        (bool success, bytes memory data) = \\n            token.call(abi.encodeWithSelector(SELECTOR, to, value));\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"PAIR: TXFR_FL\\\"\\n        );\\n    }\\n\\n    // update reserves and, on the first call per block, price accumulators\\n    function _update(\\n        uint balance0,\\n        uint balance1,\\n        uint112 _reserve0,\\n        uint112 _reserve1\\n    ) \\n    private\\n    {\\n        require(balance0 \\u003c= type(uint112).max \\u0026\\u0026 balance1 \\u003c= type(uint).max, \\\"PAIR: OVF\\\");\\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n        if (timeElapsed \\u003e 0 \\u0026\\u0026 _reserve0 != 0 \\u0026\\u0026 _reserve1 != 0) {\\n            // * never overflows, and + overflow is desired\\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\\n        }\\n        reserve0 = uint112(balance0);\\n        reserve1 = uint112(balance1);\\n        blockTimestampLast = blockTimestamp;\\n        emit Sync(reserve0, reserve1);\\n    }\\n}\\n\"},\"ICoinvestingDeFiCallee.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\ninterface ICoinvestingDeFiCallee {\\n    // External functions\\n    function coinvestingDeFiCall(\\n        address sender, \\n        uint amount0,\\n        uint amount1,\\n        bytes calldata data\\n    )\\n    external;\\n}\\n\"},\"ICoinvestingDeFiERC20.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\ninterface ICoinvestingDeFiERC20 {\\n    // Events\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint value\\n    );\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint value\\n    );\\n\\n    // External functions\\n    function approve(\\n        address spender,\\n        uint value\\n    )\\n        external \\n        returns (bool);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint value,\\n        uint deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    )\\n        external;\\n    \\n    function transfer(\\n        address to,\\n        uint value\\n    )\\n        external\\n        returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint value\\n    )\\n        external\\n        returns (bool);\\n    \\n    // External functions that are view        \\n    function allowance(\\n        address owner,\\n        address spender\\n    )\\n        external \\n        view \\n        returns (uint);\\n\\n    function balanceOf(address owner) external view returns (uint);\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n    function totalSupply() external view returns (uint);\\n\\n    // External functions that are pure\\n    function decimals() external pure returns (uint8);\\n    function name() external pure returns (string memory);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function symbol() external pure returns (string memory);\\n}\\n\"},\"ICoinvestingDeFiFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\ninterface ICoinvestingDeFiFactory {\\n    //Events\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint\\n    );\\n\\n    //External functions\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    )\\n    external\\n    returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n\\n    // External functions that are view\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function getPair(\\n        address tokenA,\\n        address tokenB\\n    )\\n    external\\n    view\\n    returns (address pair);\\n}\\n\"},\"ICoinvestingDeFiPair.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\nimport \\\"./ICoinvestingDeFiERC20.sol\\\";\\n\\ninterface ICoinvestingDeFiPair is ICoinvestingDeFiERC20 {\\n    // Events\\n    event Burn(\\n        address indexed sender,\\n        uint amount0,\\n        uint amount1,\\n        address indexed to\\n    );\\n\\n    event Mint(\\n        address indexed sender,\\n        uint amount0,\\n        uint amount1\\n    );\\n\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n\\n    event Sync(\\n        uint112 reserve0, \\n        uint112 reserve1\\n    );\\n\\n    // External functions\\n    function burn(address to) external returns (\\n        uint amount0,\\n        uint amount1\\n    );\\n\\n    function initialize(\\n        address,\\n        address\\n    ) external;\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function skim(address to) external;\\n    function swap(\\n        uint amount0Out,\\n        uint amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function sync() external;\\n\\n    // External functions that are view\\n    function factory() external view returns (address);\\n    function getReserves() external view returns (\\n        uint112 reserve0,\\n        uint112 reserve1,\\n        uint32 blockTimestampLast\\n    );\\n\\n    function kLast() external view returns (uint);    \\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    \\n\\n    // External functions that are pure\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\ninterface IERC20 {\\n    //Events\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint value\\n    );\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint value\\n    );\\n\\n    //External functions\\n    function approve(\\n        address spender,\\n        uint value\\n    )\\n        external \\n        returns (bool);\\n    \\n    function transfer(\\n        address to,\\n        uint value\\n    )\\n        external\\n        returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint value\\n    )\\n        external\\n        returns (bool);\\n    \\n    // External functions that are view        \\n    function allowance(\\n        address owner,\\n        address spender\\n    )\\n        external \\n        view \\n        returns (uint);\\n\\n    function balanceOf(address owner) external view returns (uint);\\n    function decimals() external view returns (uint8);\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function totalSupply() external view returns (uint);\\n}\\n\"},\"Math.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\nlibrary Math {\\n    \\n    /// @dev Returns the smallest of two numbers.\\n    function min(\\n        uint x, \\n        uint y\\n    ) \\n    internal \\n    pure \\n    returns (uint z) \\n    {\\n        z = x \\u003c y ? x : y;\\n    }\\n\\n    /// @dev babylonian method \\n    ///(https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y \\u003e 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x \\u003c z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler\\u0027s built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c \\u003c a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b \\u003e a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n            // benefit is lost if \\u0027b\\u0027 is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003c= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"},\"UQ112x112.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\n/// @dev Library for handling binary fixed point numbers\\n/// (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    /// @dev encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112;\\n    }\\n\\n    /// @dev // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(\\n        uint224 x,\\n        uint112 y\\n    )\\n    internal\\n    pure\\n    returns (uint224 z) \\n    {\\n        z = x / uint224(y);\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allPairsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeToSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeTo\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"name\":\"setFeeToSetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CoinvestingDeFiFactory","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000eb62dc3dd35e6ae07db9f741ebefb12c7d94e71e","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://36fdfd02941ca9960fda0f47fa189ef7514cc6f1128fb017d2505bdddb90cc38"}]}