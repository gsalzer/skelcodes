{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/StealthKeyFIFSRegistrar.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.6;\\n\\nimport \\\"@ensdomains/ens/contracts/ENS.sol\\\";\\nimport \\\"./profiles/StealthKeyResolver.sol\\\";\\nimport \\\"./profiles/AddrResolver.sol\\\";\\n\\n/**\\n * A registrar that allocates StealthKey ready subdomains to the first person to claim them.\\n * Based on the FIFSRegistrar contract here:\\n * https://github.com/ensdomains/ens/blob/master/contracts/FIFSRegistrar.sol\\n */\\ncontract StealthKeyFIFSRegistrar {\\n    ENS public ens;\\n    bytes32 public rootNode;\\n\\n    /**\\n     * Constructor.\\n     * @param _ens The address of the ENS registry.\\n     * @param _rootNode The node that this registrar administers.\\n     */\\n    constructor(ENS _ens, bytes32 _rootNode) {\\n        ens = _ens;\\n        rootNode = _rootNode;\\n    }\\n\\n    /**\\n     * Register a name, or change the owner of an existing registration.\\n     * @param _label The hash of the label to register.\\n     * @param _owner The address of the new owner.\\n     * @param _resolver The Stealth Key compatible resolver that will be used for this subdomain\\n     * @param _spendingPubKeyPrefix Prefix of the spending public key (2 or 3)\\n     * @param _spendingPubKey The public key for generating a stealth address\\n     * @param _viewingPubKeyPrefix Prefix of the viewing public key (2 or 3)\\n     * @param _viewingPubKey The public key to use for encryption\\n     */\\n    function register(\\n        bytes32 _label,\\n        address _owner,\\n        address _resolver,\\n        uint256 _spendingPubKeyPrefix,\\n        uint256 _spendingPubKey,\\n        uint256 _viewingPubKeyPrefix,\\n        uint256 _viewingPubKey\\n    ) public {\\n        // calculate the node for this subdomain\\n        bytes32 _node = keccak256(abi.encodePacked(rootNode, _label));\\n\\n        // ensure the subdomain has not yet been claimed\\n        address _currentOwner = ens.owner(_node);\\n        require(_currentOwner == address(0x0), 'StealthKeyFIFSRegistrar: Already claimed');\\n\\n        // temporarily make this contract the subnode owner to allow it to update the stealth keys & address\\n        ens.setSubnodeOwner(rootNode, _label, address(this));\\n        StealthKeyResolver(_resolver).setStealthKeys(_node, _spendingPubKeyPrefix, _spendingPubKey, _viewingPubKeyPrefix, _viewingPubKey);\\n        AddrResolver(_resolver).setAddr(_node, _owner);\\n\\n        // transfer ownership to the registrant and set stealth key resolver\\n        ens.setSubnodeRecord(rootNode, _label, _owner, address(_resolver), 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens/contracts/ENS.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\ninterface ENS {\\n\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual;\\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual;\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external virtual returns(bytes32);\\n    function setResolver(bytes32 node, address resolver) external virtual;\\n    function setOwner(bytes32 node, address owner) external virtual;\\n    function setTTL(bytes32 node, uint64 ttl) external virtual;\\n    function setApprovalForAll(address operator, bool approved) external virtual;\\n    function owner(bytes32 node) external virtual view returns (address);\\n    function resolver(bytes32 node) external virtual view returns (address);\\n    function ttl(bytes32 node) external virtual view returns (uint64);\\n    function recordExists(bytes32 node) external virtual view returns (bool);\\n    function isApprovedForAll(address owner, address operator) external virtual view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/profiles/StealthKeyResolver.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\nimport \\\"../ResolverBase.sol\\\";\\n\\nabstract contract StealthKeyResolver is ResolverBase {\\n    bytes4 constant private STEALTH_KEY_INTERFACE_ID = 0x69a76591;\\n\\n    /// @dev Event emitted when a user updates their resolver stealth keys\\n    event StealthKeyChanged(bytes32 indexed node, uint256 spendingPubKeyPrefix, uint256 spendingPubKey, uint256 viewingPubKeyPrefix, uint256 viewingPubKey);\\n\\n    /**\\n     * @dev Mapping used to store two secp256k1 curve public keys useful for\\n     * receiving stealth payments. The mapping records two keys: a viewing\\n     * key and a spending key, which can be set and read via the `setsStealthKeys`\\n     * and `stealthKey` methods respectively.\\n     *\\n     * The mapping associates the node to another mapping, which itself maps\\n     * the public key prefix to the actual key . This scheme is used to avoid using an\\n     * extra storage slot for the public key prefix. For a given node, the mapping\\n     * may contain a spending key at position 0 or 1, and a viewing key at position\\n     * 2 or 3. See the setter/getter methods for details of how these map to prefixes.\\n     *\\n     * For more on secp256k1 public keys and prefixes generally, see:\\n     * https://github.com/ethereumbook/ethereumbook/blob/develop/04keys-addresses.asciidoc#generating-a-public-key\\n     *\\n     */\\n    mapping(bytes32 => mapping(uint256 => uint256)) _stealthKeys;\\n\\n    /**\\n     * Sets the stealth keys associated with an ENS name, for anonymous sends.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param spendingPubKeyPrefix Prefix of the spending public key (2 or 3)\\n     * @param spendingPubKey The public key for generating a stealth address\\n     * @param viewingPubKeyPrefix Prefix of the viewing public key (2 or 3)\\n     * @param viewingPubKey The public key to use for encryption\\n     */\\n    function setStealthKeys(bytes32 node, uint256 spendingPubKeyPrefix, uint256 spendingPubKey, uint256 viewingPubKeyPrefix, uint256 viewingPubKey) external authorised(node) {\\n        require(\\n            (spendingPubKeyPrefix == 2 || spendingPubKeyPrefix == 3) &&\\n            (viewingPubKeyPrefix == 2 || viewingPubKeyPrefix == 3),\\n            \\\"StealthKeyResolver: Invalid Prefix\\\"\\n        );\\n\\n        emit StealthKeyChanged(node, spendingPubKeyPrefix, spendingPubKey, viewingPubKeyPrefix, viewingPubKey);\\n\\n        // Shift the spending key prefix down by 2, making it the appropriate index of 0 or 1\\n        spendingPubKeyPrefix -= 2;\\n\\n        // Ensure the opposite prefix indices are empty\\n        delete _stealthKeys[node][1 - spendingPubKeyPrefix];\\n        delete _stealthKeys[node][5 - viewingPubKeyPrefix];\\n\\n        // Set the appropriate indices to the new key values\\n        _stealthKeys[node][spendingPubKeyPrefix] = spendingPubKey;\\n        _stealthKeys[node][viewingPubKeyPrefix] = viewingPubKey;\\n    }\\n\\n    /**\\n     * Returns the stealth key associated with a name.\\n     * @param node The ENS node to query.\\n     * @return spendingPubKeyPrefix Prefix of the spending public key (2 or 3)\\n     * @return spendingPubKey The public key for generating a stealth address\\n     * @return viewingPubKeyPrefix Prefix of the viewing public key (2 or 3)\\n     * @return viewingPubKey The public key to use for encryption\\n     */\\n    function stealthKeys(bytes32 node) external view returns (uint256 spendingPubKeyPrefix, uint256 spendingPubKey, uint256 viewingPubKeyPrefix, uint256 viewingPubKey) {\\n        if (_stealthKeys[node][0] != 0) {\\n            spendingPubKeyPrefix = 2;\\n            spendingPubKey = _stealthKeys[node][0];\\n        } else {\\n            spendingPubKeyPrefix = 3;\\n            spendingPubKey = _stealthKeys[node][1];\\n        }\\n\\n        if (_stealthKeys[node][2] != 0) {\\n            viewingPubKeyPrefix = 2;\\n            viewingPubKey = _stealthKeys[node][2];\\n        } else {\\n            viewingPubKeyPrefix = 3;\\n            viewingPubKey = _stealthKeys[node][3];\\n        }\\n\\n        return (spendingPubKeyPrefix, spendingPubKey, viewingPubKeyPrefix, viewingPubKey);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public virtual override pure returns(bool) {\\n        return interfaceID == STEALTH_KEY_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/profiles/AddrResolver.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\nimport \\\"../ResolverBase.sol\\\";\\n\\nabstract contract AddrResolver is ResolverBase {\\n    bytes4 constant private ADDR_INTERFACE_ID = 0x3b3b57de;\\n    bytes4 constant private ADDRESS_INTERFACE_ID = 0xf1cb7e06;\\n    uint constant private COIN_TYPE_ETH = 60;\\n\\n    event AddrChanged(bytes32 indexed node, address a);\\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\\n\\n    mapping(bytes32=>mapping(uint=>bytes)) _addresses;\\n\\n    /**\\n     * Sets the address associated with an ENS node.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param a The address to set.\\n     */\\n    function setAddr(bytes32 node, address a) virtual external authorised(node) {\\n        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));\\n    }\\n\\n    /**\\n     * Returns the address associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated address.\\n     */\\n    function addr(bytes32 node) virtual public view returns (address payable) {\\n        bytes memory a = addr(node, COIN_TYPE_ETH);\\n        if(a.length == 0) {\\n            return address(0);\\n        }\\n        return bytesToAddress(a);\\n    }\\n\\n    function setAddr(bytes32 node, uint coinType, bytes memory a) virtual public authorised(node) {\\n        emit AddressChanged(node, coinType, a);\\n        if(coinType == COIN_TYPE_ETH) {\\n            emit AddrChanged(node, bytesToAddress(a));\\n        }\\n        _addresses[node][coinType] = a;\\n    }\\n\\n    function addr(bytes32 node, uint coinType) virtual public view returns(bytes memory) {\\n        return _addresses[node][coinType];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == ADDR_INTERFACE_ID || interfaceID == ADDRESS_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ResolverBase.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\nabstract contract ResolverBase {\\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\\n\\n    function supportsInterface(bytes4 interfaceID) virtual public pure returns(bool) {\\n        return interfaceID == INTERFACE_META_ID;\\n    }\\n\\n    function isAuthorised(bytes32 node) internal virtual view returns(bool);\\n\\n    modifier authorised(bytes32 node) {\\n        require(isAuthorised(node));\\n        _;\\n    }\\n\\n    function bytesToAddress(bytes memory b) internal pure returns(address payable a) {\\n        require(b.length == 20);\\n        assembly {\\n            a := div(mload(add(b, 32)), exp(256, 12))\\n        }\\n    }\\n\\n    function addressToBytes(address a) internal pure returns(bytes memory b) {\\n        b = new bytes(20);\\n        assembly {\\n            mstore(add(b, 32), mul(a, exp(256, 12)))\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"_ens\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_rootNode\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"internalType\":\"contract ENS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_label\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_spendingPubKeyPrefix\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_spendingPubKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_viewingPubKeyPrefix\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_viewingPubKey\",\"type\":\"uint256\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootNode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"StealthKeyFIFSRegistrar","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000c2e074ec69a0dfb2997ba6c7d2e1e2bd24f861db34646ddb2ad289c900afad96daff108b9d677e25b13f0158426eb","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}