{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\nlibrary SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return _sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function _sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return _div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function _div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return _mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function _mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n interface IERC20 {\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external  view returns (uint256);\r\n    function transfer(address to, uint256 value) external  returns (bool ok);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool ok);\r\n    function approve(address spender, uint256 value)external returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n}\r\n\r\ncontract BitmindCrowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    struct Participant {\r\n        uint256 amount;   // How many tokens the user has provided.\r\n    }\r\n    struct CrowdsaleHistory {\r\n        uint256 id;\r\n        uint256 start_time;\r\n        uint256 end_time;\r\n        uint256 initial_price;\r\n        uint256 final_price;\r\n        uint256 final_cap;\r\n        uint256 total_received;\r\n        uint256 token_available;\r\n        uint256 token_sold;\r\n    }\r\n      \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, 'BitmindMsg: Only Owner'); \r\n        _;\r\n    }\r\n    modifier onlyWhileOpen{\r\n        //Validation Crowdsale\r\n        require(start_time > 0 && end_time > 0 , 'BitmindMsg: Crowdsale is not started yet');\r\n        require(block.timestamp > start_time && block.timestamp < end_time, 'BitmindMsg: Crowdsale is not started yet');\r\n        _;\r\n    }\r\n     \r\n    modifier onlyFreezer{\r\n        require(msg.sender == freezerAddress, 'BitmindMsg: Only Freezer Address');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Configurator Crowdsale Contract\r\n     */\r\n    address payable private owner;\r\n    address private freezerAddress;\r\n\r\n    /**\r\n     * Token Address for Crowdsale Contract\r\n     */\r\n    IERC20 private tokenAddress;\r\n    IERC20 private pairAddress;\r\n    \r\n    /**\r\n     * Time Configuration\r\n     */\r\n    uint256 private start_time;\r\n    uint256 private end_time;\r\n    bool private pause;\r\n    \r\n    /** \r\n     * Crowdsale Information\r\n     */\r\n    uint256 private min_contribution;\r\n    uint256 private max_contribution;\r\n    uint256 public cap;\r\n    uint256 private rate;\r\n    uint256 private price;\r\n    uint256 public token_available;\r\n    uint256 public total_received;\r\n    uint256 public token_sold;\r\n    \r\n    /**\r\n     * Participant Information\r\n     */\r\n    mapping (address => Participant) public userInfo;\r\n    address[] private addressList;\r\n    \r\n    mapping (uint256 => CrowdsaleHistory) public crowdsaleInfo;\r\n    uint256[] private crowdsaleid;\r\n\r\n    /**\r\n     * Event for token purchase logging\r\n     * @param purchaser : who paid for the tokens and get the tokens\r\n     * @param amount : total amount of tokens purchased\r\n     */\r\n    event TokensPurchased(address indexed purchaser, uint256 amount);\r\n    \r\n    /**\r\n     * Event shown after change Opening Time \r\n     * @param owner : who owner this contract\r\n     * @param openingtime : time when the Crowdsale started\r\n     */\r\n    event setOpeningtime(address indexed owner, uint256 openingtime);\r\n    \r\n    /**\r\n     * Event shown after change Closing Time\r\n     * @param owner : who owner this contract\r\n     * @param closingtime : time when the Crowdsale Ended\r\n     */\r\n    event setClosingtime(address indexed owner, uint256 closingtime);\r\n    \r\n     /**\r\n     * Event for withdraw usdt token from contract to owner\r\n     * @param owner : who owner this contract\r\n     * @param amount : time when the Crowdsale Ended\r\n     */\r\n    event WithdrawUSDT(address indexed owner, uint256 amount);\r\n    \r\n    /**\r\n     * Event for withdraw bmd token from contract to owner\r\n     * @param owner : who owner this contract\r\n     * @param amount : time when the Crowdsale Ended\r\n     */\r\n    event WithdrawBMD(address indexed owner, uint256 amount);\r\n  \r\n  /**\r\n     * Event for Transfer Ownership\r\n     * @param previousOwner : owner Crowdsale contract\r\n     * @param newOwner : New Owner of Crowdsale contract\r\n     * @param time : time when changeOwner function executed\r\n     */\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner, uint256 time);\r\n    \r\n    /**\r\n     * Event for Transfer Freezer Admin\r\n     * @param previousFreezer : Freezer of Crowdsale contract\r\n     * @param newFreezer : new Freezer of Crowdsale contract\r\n     * @param time : time when transferFreezer function executed\r\n     */\r\n    event FreezerTransferred(address indexed previousFreezer, address indexed newFreezer, uint256 time);\r\n    \r\n     /**\r\n     * Event for Freeze the Crowdsale\r\n     * @param FreezerAddress : Address who can freeze Crowdsale contract\r\n     * @param time : time when changeOwner function executed\r\n     */\r\n    event FreezeCrowdsale(address indexed FreezerAddress, uint256 time);\r\n    \r\n    /**\r\n     * Event for Unfreeze the Crowdsale\r\n     * @param FreezerAddress : Address who can freeze Crowdsale contract\r\n     * @param time : time when changeOwner function executed\r\n     */\r\n    event UnfreezeCrowdsale(address indexed FreezerAddress, uint256 time);\r\n    \r\n    /**\r\n     * Event for Initializing Crowdsale Contract\r\n     * @param Token : Main Token which will be distributed in Crowdsale\r\n     * @param Pair : Pair Token which will be used for transaction in Crowdsale\r\n     * @param owner : Address who can initialize Crowdsale contract\r\n     * @param min_contribution : min contribution for transaction in Crowdsale\r\n     * @param max_contribution : max contribution for transaction in Crowdsale\r\n     * @param start_time : time when the Crowdsale starts\r\n     * @param end_time : time when the Crowdsale ends\r\n     * @param rate : increasing price every period\r\n     * @param initial_price : initial price of Crowdsale\r\n     */\r\n    event Initializing(\r\n        address indexed Token,\r\n        address indexed Pair,\r\n        address indexed owner, \r\n        uint256 min_contribution, \r\n        uint256 max_contribution,\r\n        uint256 start_time,\r\n        uint256 end_time,\r\n        uint256 rate,\r\n        uint256 initial_price\r\n    );\r\n\r\n    /**\r\n     * Constructor of Bitmind Crowdsale Contract\r\n     */\r\n     \r\n    constructor() public {\r\n        owner = msg.sender;\r\n        freezerAddress = msg.sender;\r\n        pause = false;\r\n    }\r\n    \r\n    /**\r\n     * Function for Initialize default configuration of Crowdsale\r\n     */\r\n    function initialize(\r\n        address Token,\r\n        address Pair,\r\n        uint256 MinContribution,\r\n        uint256 MaxContribution,\r\n        uint256 initial_cap,\r\n        uint256 StartTime,\r\n        uint256 EndTime,\r\n        uint256 initial_price,\r\n        uint256 initial_rate\r\n    ) public onlyOwner returns(bool){\r\n        tokenAddress = IERC20(Token);\r\n        pairAddress = IERC20(Pair);\r\n        \r\n        require(initial_price > 0 , \"BitmindMsg: initial price must higher than 0\");\r\n        price = initial_price;\r\n        \r\n        require(StartTime > 0, \"BitmindMsg: start_time must higher than 0\");\r\n        start_time = StartTime;\r\n        \r\n        require(EndTime > 0, \"BitmindMsg: end_time must higher than 0\");\r\n        end_time = EndTime;\r\n        \r\n        require(MinContribution > 0, \"BitmindMsg: min_contribution must higher than 0\");\r\n        min_contribution = MinContribution;\r\n        \r\n        require(MaxContribution > 0, \"BitmindMsg: max_contribution must higher than 0\");\r\n        max_contribution = MaxContribution;\r\n        \r\n        require(initial_rate > 0, \"BitmindMsg: initial_rate must higher than 0\");\r\n        rate = initial_rate;\r\n        \r\n        \r\n        cap = initial_cap;\r\n        token_available = initial_cap;\r\n        token_sold = 0;\r\n        total_received = 0;\r\n        \r\n        uint256 id = crowdsaleid.length.add(1);\r\n        crowdsaleid.push(id);\r\n        crowdsaleInfo[id].id = id;\r\n        crowdsaleInfo[id].start_time = StartTime;\r\n        crowdsaleInfo[id].end_time = EndTime;\r\n        crowdsaleInfo[id].initial_price = initial_price;\r\n        crowdsaleInfo[id].final_price = initial_price;\r\n        crowdsaleInfo[id].final_cap = initial_cap;\r\n        crowdsaleInfo[id].token_available = token_available;\r\n        \r\n        emit Initializing(Token, Pair, msg.sender, MinContribution, MaxContribution, StartTime, EndTime, initial_rate, initial_price);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Function for Purchase Token on Crowdsale\r\n     * @param amount : amount which user purchase\r\n     * \r\n     * return deliveryTokens\r\n     */\r\n    \r\n    function Purchase(uint256 amount) external onlyWhileOpen returns(bool){\r\n        \r\n        require(pause == false, 'BitmindMsg: Crowdsale is freezing');\r\n        \r\n        require(price > 0, 'BitmindMsg: Initial Prize is not set yet');\r\n        \r\n        if (min_contribution > 0 && max_contribution > 0 ){\r\n            require(amount >= min_contribution && amount <= max_contribution, \"BitmindMsg: Amount invalid\");\r\n        }\r\n        \r\n        uint256 tokenReached = getEstimateToken(amount);\r\n        require(tokenReached > 0, \"BitmindMsg: Calculating Error!\");\r\n        require(token_available > 0 && token_available >= tokenReached, \"BitmindMsg: INSUFFICIENT BMD\");\r\n        \r\n        pairAddress.transferFrom(msg.sender, address(this), amount.div(1e12));\r\n        total_received = total_received.add(amount);\r\n        \r\n        crowdsaleInfo[crowdsaleid.length].total_received = total_received;\r\n        crowdsaleInfo[crowdsaleid.length].final_price = getPrice();\r\n        \r\n        if (userInfo[msg.sender].amount == 0) {\r\n          addressList.push(address(msg.sender));\r\n        }\r\n        userInfo[msg.sender].amount = userInfo[msg.sender].amount.add(amount);\r\n        \r\n        token_available = token_available.sub(tokenReached);\r\n        token_sold = token_sold.add(tokenReached);\r\n        \r\n        crowdsaleInfo[crowdsaleid.length].token_available = token_available;\r\n        crowdsaleInfo[crowdsaleid.length].token_sold = token_sold;\r\n    \r\n        tokenAddress.transfer(msg.sender, tokenReached);\r\n        \r\n        emit TokensPurchased(msg.sender, tokenReached);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Function for Estimate token which user get on Crowdsale\r\n     * @param _amount : amount which user purchase\r\n     * \r\n     * return token_amount type uint256\r\n     */\r\n    function getEstimateToken(uint256 _amount) private view returns(uint256) {\r\n        \r\n        uint256 token_amount;\r\n        uint256 a;\r\n        uint256 b;\r\n        uint256 phase_1 = cap.mul(50).div(100);\r\n        uint256 phase_2 = cap.mul(80).div(100);\r\n        uint256 phase_3 = cap.mul(100).div(100);\r\n        \r\n        uint256 get = _amount.div(getPrice().div(1e18));\r\n        if(token_available > cap.sub(phase_1)){\r\n            if(token_available.sub(get) < cap.sub(phase_1)){\r\n                a = token_available.sub(cap.sub(phase_1));\r\n                b = _amount.sub(a.mul(getPrice().div(1e18))).div(price.add(rate.mul(1)).div(1e18));\r\n                token_amount = a.add(b);\r\n            }else{\r\n                token_amount = get;\r\n            }\r\n        }else if(token_available > cap.sub(phase_2)){\r\n            if(token_available.sub(get) < cap.sub(phase_2)){\r\n                a = token_available.sub(cap.sub(phase_2));\r\n                b = _amount.sub(a.mul(getPrice().div(1e18))).div(price.add(rate.mul(2)).div(1e18));\r\n                token_amount = a.add(b);\r\n            }else{\r\n                token_amount = get;\r\n            }\r\n        }else if(token_available > cap.sub(phase_3)){\r\n            if(token_available.sub(get) < cap.sub(phase_3)){\r\n                token_amount = token_available.sub(phase_3);\r\n            }else{\r\n                token_amount = get;\r\n            }\r\n        }\r\n        return token_amount;\r\n    }\r\n    \r\n    /**\r\n     * Function for getting current price\r\n     * \r\n     * return price (uint256)\r\n     */\r\n    \r\n    function getPrice() public view returns(uint256){\r\n        require(price > 0 && token_available > 0 && cap > 0, \"BitmindMsg: Initializing contract first\");\r\n        \r\n        if(token_available > cap.sub(cap.mul(50).div(100))){\r\n            return price;\r\n        }else if(token_available > cap.sub(cap.mul(80).div(100))){\r\n            return price.add(rate.mul(1));\r\n        }else if(token_available > cap.sub(cap.mul(100).div(100))){\r\n            return price.add(rate.mul(2));\r\n        }else{\r\n            return price.add(rate.mul(2));\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Function for withdraw usdt token on Crowdsale\r\n     * \r\n     * return event WithdrawUSDT\r\n     */\r\n     \r\n    function withdrawUSDT() public onlyOwner returns(bool){\r\n         require(total_received>0, 'BitmindMsg: Pair Token INSUFFICIENT');\r\n         \r\n         uint256 balance = pairAddress.balanceOf(address(this));\r\n         pairAddress.transfer(msg.sender, balance);\r\n         emit WithdrawUSDT(msg.sender,balance);\r\n         return true;\r\n    }\r\n    \r\n     /**\r\n     * Function for withdraw bmd token on Crowdsale\r\n     * \r\n     * return event WithdrawUSDT\r\n     */\r\n     \r\n    function withdrawBMD() public onlyOwner returns(bool){\r\n         require(token_available > 0, 'BitmindMsg: Distributed Token INSUFFICIENT');\r\n         \r\n         uint256 balance = tokenAddress.balanceOf(address(this));\r\n         tokenAddress.transfer(owner, balance);\r\n         emit WithdrawBMD(msg.sender, balance);\r\n         return true;\r\n    }\r\n    \r\n    /**\r\n     * Function to get opening time of Crowdsale\r\n     */\r\n    \r\n    function openingTime() public view returns(uint256){\r\n        return start_time;\r\n    }\r\n    \r\n    /**\r\n     * Function to get closing time of Crowdsale\r\n     */\r\n    \r\n    function closingTime() public view returns(uint256){\r\n        return end_time;\r\n    }\r\n    \r\n    /**\r\n     * Function to get minimum contribution of Crowdsale\r\n     */\r\n    function MIN_CONTRIBUTION() public view returns(uint256){\r\n         return min_contribution;\r\n    }\r\n    /**\r\n     * Function to get maximum contribution of Crowdsale\r\n     */\r\n    function MAX_CONTRIBUTION() public view returns(uint256){\r\n        return max_contribution;\r\n    }\r\n      \r\n    /**\r\n     * Function to get rate which user get during transaction per 1 pair on Crowdsale \r\n     */\r\n    function Rate() public view returns(uint256){\r\n        return rate;\r\n    }\r\n    /**\r\n     * Function to get status of Crowdsale which user get during transaction per 1 pair on Crowdsale \r\n     */\r\n    function Pause() public view returns(bool){\r\n        return pause;\r\n    }\r\n    \r\n    /**\r\n     * Function to get total participant of Crowdsale\r\n     * \r\n     * return total participant\r\n     */\r\n    \r\n    function totalParticipant() public view returns(uint){\r\n        return addressList.length;\r\n    }\r\n    \r\n    /**\r\n     * Function to set opening time of Crowdsale\r\n     * @param _time : time for opening time\r\n     * \r\n     * return event OpeningTime\r\n     */\r\n     \r\n    function changeOpeningTime(uint256 _time) public onlyOwner returns(bool) {\r\n        require(_time >= block.timestamp, \"BitmindMsg: Opening Time must before current time\");\r\n        \r\n        start_time = _time;\r\n        emit setOpeningtime(owner, _time);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Function to set closing time of Crowdsale\r\n     * @param _time : time for opening time\r\n     * \r\n     * return event ClosingTime\r\n     */\r\n    function changeClosingTime(uint256 _time) public onlyOwner returns(bool) {\r\n        require(_time >= start_time, \"BitmindMsg: Closing Time already set\");\r\n        \r\n        end_time = _time;\r\n        emit setClosingtime(owner, _time);\r\n        return true;\r\n    }\r\n    \r\n     /**\r\n     * Function to change Crowdsale contract Owner\r\n     * Only Owner who could access this function\r\n     * \r\n     * return event OwnershipTransferred\r\n     */\r\n    \r\n    function transferOwnership(address payable _owner) onlyOwner public returns(bool) {\r\n        owner = _owner;\r\n        \r\n        emit OwnershipTransferred(msg.sender, _owner, block.timestamp);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Function to change Freezer Address\r\n     * Only Freezer who could access this function\r\n     * \r\n     * return event FreezerTransferred\r\n     */\r\n    \r\n    function transferFreezer(address freezer) onlyFreezer public returns(bool){\r\n        freezerAddress = freezer;\r\n        \r\n        emit FreezerTransferred(msg.sender, freezer, block.timestamp);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Function to freeze or pause crowdsale\r\n     * Only Freezer who could access this function\r\n     * \r\n     * return true\r\n     */\r\n    \r\n    function freeze() public onlyFreezer returns(bool) {\r\n        pause = true;\r\n        \r\n        emit FreezeCrowdsale(freezerAddress, block.timestamp);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Function to unfreeze or pause crowdsale\r\n     * Only Freezer who could access this function\r\n     * \r\n     * return true\r\n     */\r\n    \r\n    function unfreeze() public onlyFreezer returns(bool) {\r\n        pause = false;\r\n        \r\n        emit UnfreezeCrowdsale(freezerAddress, block.timestamp);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"FreezerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"FreezeCrowdsale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousFreezer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFreezer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"FreezerTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"min_contribution\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"max_contribution\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initial_price\",\"type\":\"uint256\"}],\"name\":\"Initializing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"FreezerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"UnfreezeCrowdsale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawBMD\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawUSDT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"closingtime\",\"type\":\"uint256\"}],\"name\":\"setClosingtime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"openingtime\",\"type\":\"uint256\"}],\"name\":\"setOpeningtime\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_CONTRIBUTION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_CONTRIBUTION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Pause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Purchase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"changeClosingTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"changeOpeningTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"crowdsaleInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initial_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"final_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"final_cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_received\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token_available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token_sold\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freeze\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"Pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"MinContribution\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MaxContribution\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initial_cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"StartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initial_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initial_rate\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token_available\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token_sold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalParticipant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_received\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"freezer\",\"type\":\"address\"}],\"name\":\"transferFreezer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBMD\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawUSDT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BitmindCrowdsale","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://9e18917e52ef01010d67616923bf2d5d64f1aefeb0f614bc0cf368e9d4e9bb05"}]}