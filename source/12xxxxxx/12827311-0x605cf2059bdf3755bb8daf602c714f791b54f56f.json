{"status":"1","message":"OK","result":[{"SourceCode":"pragma experimental ABIEncoderV2;\r\npragma solidity 0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n      *\r\n      * Requirements:\r\n      *\r\n      * - `from` cannot be the zero address.\r\n      * - `to` cannot be the zero address.\r\n      * - `tokenId` token must exist and be owned by `from`.\r\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n      *\r\n      * Emits a {Transfer} event.\r\n      */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155  {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\r\n}\r\n\r\n\r\ncontract SwapContract {\r\n\r\n  struct Swap {\r\n      \r\n       string swapID; \r\n       address payable openTrader;\r\n       address payable closeTrader;\r\n       uint[] swapChoice;    // 0: ether, 1: erc20, 2:erc721, 3: erc1155\r\n       address[] contractAddress;\r\n       uint256[] swapValue;\r\n       uint[] trader;  // 1: openTrader, 2: closeTrader\r\n       uint256 States;  // 1: open, 2: closed, 3: expired\r\n       uint256 swapDate;\r\n       mapping (address => uint256) ERC1155Value;  \r\n     \r\n  }\r\n\r\n  mapping (string => Swap) private swaps;\r\n  string[] private swapList;\r\n\r\n\r\n   constructor()  {\r\n       \r\n   }\r\n   \r\n  \r\n  function openERC20(string memory _swapID, uint256 _openValueERC20, address _openContractAddress, address payable _closeTrader) public {\r\n       \r\n             IERC20 openERC20Contract = IERC20(_openContractAddress);\r\n           //  uint256 val = _openValueERC20*1000000000000000000;\r\n             openERC20Contract.transferFrom(msg.sender, address(this), _openValueERC20);\r\n             bytes memory identifiant = bytes(swaps[_swapID].swapID);\r\n\r\n        if(identifiant.length == 0) {\r\n             swaps[_swapID].swapID = _swapID;\r\n      \r\n      swaps[_swapID].openTrader = payable(msg.sender);\r\n      \r\n      swaps[_swapID].closeTrader = _closeTrader;\r\n      swaps[_swapID].States = 1;\r\n       swapList.push(_swapID);\r\n        }\r\n      swaps[_swapID].swapChoice.push(1);\r\n      \r\n      swaps[_swapID].contractAddress.push(_openContractAddress);\r\n      \r\n      swaps[_swapID].swapValue.push(_openValueERC20);\r\n      \r\n      swaps[_swapID].trader.push(1);\r\n      \r\n  }\r\n  \r\n   function openERC721(string memory _swapID, uint256 _openIdERC721, address _openContractAddress, address payable _closeTrader) public {\r\n       \r\n             IERC721 openERC721Contract = IERC721(_openContractAddress);\r\n             openERC721Contract.transferFrom(msg.sender, address(this), _openIdERC721);\r\n             bytes memory identifiant = bytes(swaps[_swapID].swapID);\r\n\r\n        if(identifiant.length == 0) {\r\n                  swaps[_swapID].swapID = _swapID;\r\n      \r\n      swaps[_swapID].openTrader = payable(msg.sender);\r\n      \r\n      swaps[_swapID].closeTrader = _closeTrader;\r\n      swaps[_swapID].States = 1;\r\n       swapList.push(_swapID);\r\n        }\r\n\r\n      \r\n      swaps[_swapID].swapChoice.push(2);\r\n      \r\n      swaps[_swapID].contractAddress.push(_openContractAddress);\r\n      \r\n      swaps[_swapID].swapValue.push(_openIdERC721);\r\n      \r\n      swaps[_swapID].trader.push(1);\r\n      \r\n      \r\n  }\r\n   \r\n   \r\n   function openERC1155(string memory _swapID, uint256 _openValueERC1155, uint256 _openIdERC1155, address _openContractAddress, address payable  _closeTrader, bytes calldata _data) public {\r\n       \r\n              IERC1155  openERC1155Contract = IERC1155(_openContractAddress);\r\n             openERC1155Contract.safeTransferFrom(msg.sender, address(this),_openIdERC1155, _openValueERC1155, _data);\r\n            bytes memory identifiant = bytes(swaps[_swapID].swapID);\r\n\r\n        if(identifiant.length == 0) {\r\n             swaps[_swapID].swapID = _swapID;\r\n      \r\n      swaps[_swapID].openTrader = payable(msg.sender);\r\n      \r\n      swaps[_swapID].closeTrader = _closeTrader;\r\n       swaps[_swapID].States = 1;\r\n        swapList.push(_swapID);\r\n        }\r\n     \r\n      \r\n      swaps[_swapID].swapChoice.push(3);\r\n      \r\n      swaps[_swapID].contractAddress.push(_openContractAddress);\r\n      \r\n      swaps[_swapID].swapValue.push(_openIdERC1155);\r\n      \r\n      swaps[_swapID].ERC1155Value[_openContractAddress] = _openValueERC1155;\r\n      \r\n      swaps[_swapID].trader.push(1);\r\n      \r\n     \r\n   \r\n    \r\n      \r\n  }\r\n   \r\n  \r\n   function closeERC20(string memory _swapID, uint256 _closeValueERC20, address _closeContractAddress) public  {\r\n       \r\n       \r\n        IERC20 closeERC20Contract = IERC20(_closeContractAddress);\r\n        \r\n        closeERC20Contract.transferFrom(msg.sender, address(this), _closeValueERC20);\r\n        \r\n        swaps[_swapID].swapChoice.push(1);\r\n      \r\n        swaps[_swapID].contractAddress.push(_closeContractAddress);\r\n      \r\n        swaps[_swapID].swapValue.push(_closeValueERC20);\r\n        \r\n        swaps[_swapID].trader.push(2);\r\n        swaps[_swapID].States = 2;\r\n        \r\n\r\n  }\r\n  \r\n   function closeER721(string memory _swapID, uint256 _closeIdERC721, address _closeContractAddress) public  {\r\n       \r\n           IERC721 closeERC721Contract = IERC721(_closeContractAddress);\r\n           \r\n           closeERC721Contract.transferFrom(swaps[_swapID].closeTrader, address(this), _closeIdERC721);\r\n           \r\n           swaps[_swapID].swapChoice.push(2);\r\n      \r\n           swaps[_swapID].contractAddress.push(_closeContractAddress);\r\n      \r\n           swaps[_swapID].swapValue.push(_closeIdERC721);\r\n           \r\n           swaps[_swapID].trader.push(2);\r\n           swaps[_swapID].States = 2;\r\n        \r\n  }\r\n   \r\n    function closeERC1155(string memory _swapID, uint256 _closeIdERC1155, uint256 _closeValueERC1155, address _closeContractAddress, bytes calldata _data) public  {\r\n       \r\n           IERC1155 closeERC1155Contract = IERC1155(_closeContractAddress);\r\n           \r\n           closeERC1155Contract.safeTransferFrom(swaps[_swapID].closeTrader,address(this), _closeIdERC1155, _closeValueERC1155, _data);\r\n           \r\n           swaps[_swapID].swapChoice.push(3);\r\n      \r\n           swaps[_swapID].contractAddress.push(_closeContractAddress);\r\n      \r\n           swaps[_swapID].swapValue.push(_closeIdERC1155);\r\n      \r\n           swaps[_swapID].ERC1155Value[_closeContractAddress] = _closeValueERC1155;\r\n           \r\n           swaps[_swapID].trader.push(2);\r\n           swaps[_swapID].States = 2;\r\n      \r\n  }\r\n  \r\n  function finalClose(string memory _swapID, bytes calldata _data) public  {\r\n     \r\n      \r\n        for(uint256 i=0; i<swaps[_swapID].swapChoice.length; i++) {\r\n                 if(swaps[_swapID].swapChoice[i] == 1) {\r\n                       IERC20 closeERC20Contract = IERC20(swaps[_swapID].contractAddress[i]);\r\n                   if(swaps[_swapID].trader[i] == 1) {\r\n                       \r\n                        closeERC20Contract.transfer(swaps[_swapID].closeTrader, swaps[_swapID].swapValue[i]);\r\n                        \r\n                   } else if(swaps[_swapID].trader[i] == 2) {\r\n                       \r\n                        closeERC20Contract.transfer(swaps[_swapID].openTrader, swaps[_swapID].swapValue[i]);\r\n                        \r\n                   }\r\n            \r\n           \r\n                 } else if(swaps[_swapID].swapChoice[i] == 2) {\r\n                         IERC721 closeERC721Contract = IERC721(swaps[_swapID].contractAddress[i]);\r\n                            if(swaps[_swapID].trader[i] == 1) {\r\n                                \r\n                              closeERC721Contract.transferFrom(address(this), swaps[_swapID].closeTrader, swaps[_swapID].swapValue[i]);\r\n              \r\n                          } else if(swaps[_swapID].trader[i] == 2) {\r\n                              closeERC721Contract.transferFrom(address(this), swaps[_swapID].openTrader, swaps[_swapID].swapValue[i]);\r\n                             }\r\n                 } else if(swaps[_swapID].swapChoice[i] == 3) {\r\n                     \r\n          uint256 value = swaps[_swapID].ERC1155Value[swaps[_swapID].contractAddress[i]];\r\n          IERC1155 closeERC1155Contract = IERC1155(swaps[_swapID].contractAddress[i]);\r\n           if(swaps[_swapID].trader[i] == 1) {\r\n               \r\n                         closeERC1155Contract.safeTransferFrom(address(this), swaps[_swapID].closeTrader, swaps[_swapID].swapValue[i], value, _data);\r\n\r\n           } else if(swaps[_swapID].trader[i] == 2) {\r\n               \r\n                         closeERC1155Contract.safeTransferFrom(address(this), swaps[_swapID].openTrader, swaps[_swapID].swapValue[i], value, _data);\r\n           }\r\n          \r\n      }\r\n        }\r\n          swaps[_swapID].swapDate = block.timestamp;\r\n          swaps[_swapID].States = 3;\r\n  \r\n  }\r\n\r\n\r\nfunction expire(string memory _swapID, bytes calldata _data) public payable {\r\n     \r\n      \r\n        for(uint256 i=0; i<swaps[_swapID].swapChoice.length; i++) {\r\n            \r\n                  if(swaps[_swapID].swapChoice[i] == 0) {\r\n                       if(swaps[_swapID].trader[i] == 1) {\r\n                           \r\n                           address payable openTraderr = swaps[_swapID].openTrader;\r\n       \r\n                           openTraderr.transfer(msg.value);\r\n                           \r\n                       } else if(swaps[_swapID].trader[i] == 2) { \r\n                           \r\n                           address payable closeTraderr = swaps[_swapID].closeTrader;\r\n       \r\n                           closeTraderr.transfer(msg.value);\r\n                           \r\n                       }\r\n                     \r\n                      \r\n                  } else if(swaps[_swapID].swapChoice[i] == 1) {\r\n                       IERC20 closeERC20Contract = IERC20(swaps[_swapID].contractAddress[i]);\r\n                   if(swaps[_swapID].trader[i] == 1) {\r\n                       \r\n                        closeERC20Contract.transfer(swaps[_swapID].openTrader, swaps[_swapID].swapValue[i]);\r\n                        \r\n                   } else if(swaps[_swapID].trader[i] == 2) {\r\n                       \r\n                        closeERC20Contract.transfer(swaps[_swapID].closeTrader, swaps[_swapID].swapValue[i]);\r\n                        \r\n                   }\r\n            \r\n           \r\n                 } else if(swaps[_swapID].swapChoice[i] == 2) {\r\n                         IERC721 closeERC721Contract = IERC721(swaps[_swapID].contractAddress[i]);\r\n                            if(swaps[_swapID].trader[i] == 1) {\r\n                                \r\n                              closeERC721Contract.transferFrom(address(this), swaps[_swapID].openTrader, swaps[_swapID].swapValue[i]);\r\n              \r\n                          } else if(swaps[_swapID].trader[i] == 2) {\r\n                  \r\n                              closeERC721Contract.transferFrom(address(this), swaps[_swapID].closeTrader, swaps[_swapID].swapValue[i]);\r\n                  \r\n                             }\r\n   \r\n\r\n\r\n                 } else if(swaps[_swapID].swapChoice[i] == 3) {\r\n                     \r\n          uint256 value = swaps[_swapID].ERC1155Value[swaps[_swapID].contractAddress[i]];\r\n          IERC1155 closeERC1155Contract = IERC1155(swaps[_swapID].contractAddress[i]);\r\n           if(swaps[_swapID].trader[i] == 1) {\r\n               \r\n                         closeERC1155Contract.safeTransferFrom(address(this), swaps[_swapID].openTrader, swaps[_swapID].swapValue[i], value, _data);\r\n\r\n           } else if(swaps[_swapID].trader[i] == 2) {\r\n               \r\n                         closeERC1155Contract.safeTransferFrom(address(this), swaps[_swapID].closeTrader, swaps[_swapID].swapValue[i], value, _data);\r\n\r\n           }\r\n          \r\n          \r\n          \r\n      }\r\n        }\r\n\r\n          swaps[_swapID].States = 4;\r\n  \r\n  }\r\n\r\n\r\n   function getSwapList() public view returns (uint256) {\r\n       return swapList.length;\r\n       \r\n   }\r\n   function getSwapsId() public view returns (string [] memory ) {\r\n     return swapList;\r\n   }\r\n \r\n   function checkSwap(string memory _swapID) public view returns (string memory swapId, address closeTrader, address openTrader, uint256 States, uint256 date) {\r\n   return (swaps[_swapID].swapID, swaps[_swapID].closeTrader, swaps[_swapID].openTrader, swaps[_swapID].States, swaps[_swapID].swapDate);\r\n    //Swap memory swap = swaps[_swapID];\r\n   // return (swap.swapID, swap.closeTrader, swap.openTrader, swap.States, swap.swapDate);\r\n  }\r\n  \r\n   function gettrCaSvSc(string memory _swapID)public view returns( uint  [] memory, address  [] memory, uint256  [] memory, uint  [] memory){\r\n    return (swaps[_swapID].trader, swaps[_swapID].contractAddress, swaps[_swapID].swapValue, swaps[_swapID].swapChoice);\r\n}\r\nfunction getValERC11(string memory _swapID, address contractAddress) public view returns(uint256) {\r\n    \r\n    return(swaps[_swapID].ERC1155Value[contractAddress]);\r\n}\r\n\r\n\r\n   \r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_swapID\",\"type\":\"string\"}],\"name\":\"checkSwap\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"swapId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"closeTrader\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"openTrader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"States\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_swapID\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_closeIdERC721\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_closeContractAddress\",\"type\":\"address\"}],\"name\":\"closeER721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_swapID\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_closeIdERC1155\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_closeValueERC1155\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_closeContractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"closeERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_swapID\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_closeValueERC20\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_closeContractAddress\",\"type\":\"address\"}],\"name\":\"closeERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_swapID\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"expire\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_swapID\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"finalClose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapsId\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_swapID\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"getValERC11\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_swapID\",\"type\":\"string\"}],\"name\":\"gettrCaSvSc\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_swapID\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_openValueERC1155\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_openIdERC1155\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_openContractAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_closeTrader\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"openERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_swapID\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_openValueERC20\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_openContractAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_closeTrader\",\"type\":\"address\"}],\"name\":\"openERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_swapID\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_openIdERC721\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_openContractAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_closeTrader\",\"type\":\"address\"}],\"name\":\"openERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SwapContract","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://44757bd8c77789de344cd6eb8b54c90108b43f824fabe36db832dc7d73b70de5"}]}