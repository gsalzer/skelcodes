{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.15\r\n\"\"\"\r\n@title Yearn Vault Swapper\r\n@license GNU AGPLv3\r\n@author yearn.finance\r\n@notice\r\n  Yearn vault swapper should be used to swap from one crv vault to an other.\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\nN_ALL_COINS: constant(int128) = 2\r\n\r\n\r\ninterface Vault:\r\n    def token() -> address: view\r\n    def apiVersion() -> String[28]: view\r\n    def governance() -> address: view\r\n    def withdraw(\r\n    maxShares: uint256,\r\n    recipient: address\r\n    ) -> uint256: nonpayable\r\n    def deposit(amount: uint256, recipient: address) -> uint256: nonpayable\r\n    def pricePerShare() -> uint256: view\r\n    def transferFrom(f: address, to: address, amount: uint256) -> uint256: nonpayable\r\n    def decimals() -> uint256: view\r\n\r\ninterface StableSwap:\r\n    def remove_liquidity_one_coin(amount: uint256, i: int128, min_amount: uint256): nonpayable\r\n    def coins(i: uint256) -> address: view\r\n    def add_liquidity(amounts: uint256[N_ALL_COINS], min_mint_amount: uint256): nonpayable\r\n    def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256: view\r\n    def calc_token_amount(amounts: uint256[N_ALL_COINS], is_deposit: bool) -> uint256: view\r\n\r\ninterface Token:\r\n    def minter() -> address: view\r\n\r\ninterface Registry:\r\n    def get_pool_from_lp_token(lp: address) -> address: view\r\n\r\nregistry: public(Registry)\r\n\r\n@external\r\ndef __init__():\r\n    self.registry = Registry(0x90E00ACe148ca3b23Ac1bC8C240C2a7Dd9c2d7f5)\r\n\r\n@external\r\ndef swap(from_vault: address, to_vault: address, amount: uint256, min_amount_out: uint256):\r\n    \"\"\"\r\n    @notice swap tokens from one vault to an other\r\n    @dev Remove funds from a vault, move one side of \r\n    the asset from one curve pool to an other and \r\n    deposit into the new vault.\r\n    @param from_vault The vault tokens should be taken from\r\n    @param to_vault The vault tokens should be deposited to\r\n    @param amount The amount of tokens you whish to use from the from_vault\r\n    @param min_amount_out The minimal amount of tokens you would expect from the to_vault\r\n    \"\"\"\r\n    underlying: address = Vault(from_vault).token()\r\n    target: address = Vault(to_vault).token()\r\n\r\n    underlying_pool:address = self.registry.get_pool_from_lp_token(underlying)\r\n\r\n    target_pool: address = self.registry.get_pool_from_lp_token(target)\r\n\r\n    Vault(from_vault).transferFrom(msg.sender, self, amount)\r\n\r\n    underlying_amount: uint256 = Vault(from_vault).withdraw(amount, self)\r\n    \r\n    StableSwap(underlying_pool).remove_liquidity_one_coin(underlying_amount, 1, 1)\r\n    \r\n    liquidity_amount: uint256 = ERC20(StableSwap(underlying_pool).coins(1)).balanceOf(self)\r\n    ERC20(StableSwap(underlying_pool).coins(1)).approve(target_pool, liquidity_amount)\r\n\r\n    StableSwap(target_pool).add_liquidity([0, liquidity_amount], 1)\r\n\r\n    target_amount: uint256 = ERC20(target).balanceOf(self)\r\n    if ERC20(target).allowance(self, to_vault) < target_amount:\r\n        ERC20(target).approve(to_vault, 0)\r\n        ERC20(target).approve(to_vault, MAX_UINT256) \r\n\r\n    out:uint256 = Vault(to_vault).deposit(target_amount, msg.sender)\r\n    assert(out >= min_amount_out)\r\n\r\n@view\r\n@external\r\ndef estimate_out(from_vault: address, to_vault: address, amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice estimate the amount of tokens out\r\n    @param from_vault The vault tokens should be taken from\r\n    @param to_vault The vault tokens should be deposited to\r\n    @param amount The amount of tokens you whish to use from the from_vault\r\n    @return the amount of token shared expected in the to_vault\r\n    \"\"\"\r\n    underlying: address = Vault(from_vault).token()\r\n    target: address = Vault(to_vault).token()\r\n\r\n    underlying_pool:address = self.registry.get_pool_from_lp_token(underlying)\r\n\r\n    target_pool: address = self.registry.get_pool_from_lp_token(target)\r\n\r\n    pricePerShareFrom: uint256 = Vault(from_vault).pricePerShare()\r\n    pricePerShareTo: uint256 = Vault(to_vault).pricePerShare()\r\n\r\n    amount_out: uint256 = pricePerShareFrom * amount / (10 ** Vault(from_vault).decimals())\r\n    amount_out = StableSwap(underlying_pool).calc_withdraw_one_coin(amount_out, 1)\r\n    amount_out = StableSwap(target_pool).calc_token_amount([0, amount_out], True)\r\n    \r\n    return amount_out * (10 ** Vault(to_vault).decimals()) / pricePerShareTo","ABI":"[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"swap\",\"inputs\":[{\"name\":\"from_vault\",\"type\":\"address\"},{\"name\":\"to_vault\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"min_amount_out\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":50608},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"estimate_out\",\"inputs\":[{\"name\":\"from_vault\",\"type\":\"address\"},{\"name\":\"to_vault\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":34319},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"registry\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2448}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.15","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":""}]}