{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\npragma solidity 0.8.0;\r\n\r\n\r\ninterface MassetStructs {\r\n    struct BassetPersonal {\r\n        // Address of the bAsset\r\n        address addr;\r\n        // Address of the bAsset\r\n        address integrator;\r\n        // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\r\n        bool hasTxFee; // takes a byte in storage\r\n        // Status of the bAsset\r\n        BassetStatus status;\r\n    }\r\n\r\n    struct BassetData {\r\n        // 1 Basset * ratio / ratioScale == x Masset (relative value)\r\n        // If ratio == 10e8 then 1 bAsset = 10 mAssets\r\n        // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\r\n        uint128 ratio;\r\n        // Amount of the Basset that is held in Collateral\r\n        uint128 vaultBalance;\r\n    }\r\n\r\n    // Status of the Basset - has it broken its peg?\r\n    enum BassetStatus {\r\n        Default,\r\n        Normal,\r\n        BrokenBelowPeg,\r\n        BrokenAbovePeg,\r\n        Blacklisted,\r\n        Liquidating,\r\n        Liquidated,\r\n        Failed\r\n    }\r\n\r\n    struct BasketState {\r\n        bool undergoingRecol;\r\n        bool failed;\r\n    }\r\n\r\n    struct InvariantConfig {\r\n        uint256 a;\r\n        WeightLimits limits;\r\n    }\r\n\r\n    struct WeightLimits {\r\n        uint128 min;\r\n        uint128 max;\r\n    }\r\n\r\n    struct AmpData {\r\n        uint64 initialA;\r\n        uint64 targetA;\r\n        uint64 rampStartTime;\r\n        uint64 rampEndTime;\r\n    }\r\n}\r\n\r\nabstract contract IInvariantValidator is MassetStructs {\r\n    // Mint\r\n    function computeMint(\r\n        BassetData[] calldata _bAssets,\r\n        uint8 _i,\r\n        uint256 _rawInput,\r\n        InvariantConfig memory _config\r\n    ) external view virtual returns (uint256);\r\n\r\n    function computeMintMulti(\r\n        BassetData[] calldata _bAssets,\r\n        uint8[] calldata _indices,\r\n        uint256[] calldata _rawInputs,\r\n        InvariantConfig memory _config\r\n    ) external view virtual returns (uint256);\r\n\r\n    // Swap\r\n    function computeSwap(\r\n        BassetData[] calldata _bAssets,\r\n        uint8 _i,\r\n        uint8 _o,\r\n        uint256 _rawInput,\r\n        uint256 _feeRate,\r\n        InvariantConfig memory _config\r\n    ) external view virtual returns (uint256, uint256);\r\n\r\n    // Redeem\r\n    function computeRedeem(\r\n        BassetData[] calldata _bAssets,\r\n        uint8 _i,\r\n        uint256 _mAssetQuantity,\r\n        InvariantConfig memory _config\r\n    ) external view virtual returns (uint256);\r\n\r\n    function computeRedeemExact(\r\n        BassetData[] calldata _bAssets,\r\n        uint8[] calldata _indices,\r\n        uint256[] calldata _rawOutputs,\r\n        InvariantConfig memory _config\r\n    ) external view virtual returns (uint256);\r\n}\r\n\r\nlibrary Root {\r\n    /**\r\n     * @dev Returns the square root of a given number\r\n     * @param x Input\r\n     * @return y Square root of Input\r\n     */\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        if (x == 0) return 0;\r\n        else {\r\n            uint256 xx = x;\r\n            uint256 r = 1;\r\n            if (xx >= 0x100000000000000000000000000000000) {\r\n                xx >>= 128;\r\n                r <<= 64;\r\n            }\r\n            if (xx >= 0x10000000000000000) {\r\n                xx >>= 64;\r\n                r <<= 32;\r\n            }\r\n            if (xx >= 0x100000000) {\r\n                xx >>= 32;\r\n                r <<= 16;\r\n            }\r\n            if (xx >= 0x10000) {\r\n                xx >>= 16;\r\n                r <<= 8;\r\n            }\r\n            if (xx >= 0x100) {\r\n                xx >>= 8;\r\n                r <<= 4;\r\n            }\r\n            if (xx >= 0x10) {\r\n                xx >>= 4;\r\n                r <<= 2;\r\n            }\r\n            if (xx >= 0x8) {\r\n                r <<= 1;\r\n            }\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1; // Seven iterations should be enough\r\n            uint256 r1 = x / r;\r\n            return uint256(r < r1 ? r : r1);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title   InvariantValidator\r\n * @author  mStable\r\n * @notice  Builds on and enforces the StableSwap invariant conceived by Michael Egorov. (https://www.curve.fi/stableswap-paper.pdf)\r\n *          Derived by mStable and adapted for the needs of an mAsset, as described in MIP-7 (http://mips.mstable.org/MIPS/mip-7)\r\n *          Calculates and validates the result of Masset operations with respect to the invariant.\r\n *          This supports low slippage swaps and applies penalties towards min and max regions.\r\n * @dev     VERSION: 1.0\r\n *          DATE:    2021-02-04\r\n */\r\ncontract InvariantValidator is IInvariantValidator {\r\n    uint256 internal constant A_PRECISION = 100;\r\n\r\n    /***************************************\r\n                    EXTERNAL\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Compute the amount of mAsset received for minting\r\n     * with `quantity` amount of bAsset index `i`.\r\n     * @param _bAssets      Array of all bAsset Data\r\n     * @param _i            Index of bAsset with which to mint\r\n     * @param _rawInput     Raw amount of bAsset to use in mint\r\n     * @param _config       Generalised invariantConfig stored externally\r\n     * @return mintAmount   Quantity of mAssets minted\r\n     */\r\n    function computeMint(\r\n        BassetData[] calldata _bAssets,\r\n        uint8 _i,\r\n        uint256 _rawInput,\r\n        InvariantConfig memory _config\r\n    ) external view override returns (uint256 mintAmount) {\r\n        // 1. Get raw reserves\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        // 2. Get value of reserves according to invariant\r\n        uint256 k0 = _invariant(x, sum, _config.a);\r\n        uint256 scaledInput = (_rawInput * _bAssets[_i].ratio) / 1e8;\r\n\r\n        // 3. Add deposit to x and sum\r\n        x[_i] += scaledInput;\r\n        sum += scaledInput;\r\n        // 4. Finalise mint\r\n        require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\r\n        mintAmount = _computeMintOutput(x, sum, k0, _config.a);\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the amount of mAsset received for minting\r\n     * with the given array of inputs.\r\n     * @param _bAssets      Array of all bAsset Data\r\n     * @param _indices      Indexes of bAssets with which to mint\r\n     * @param _rawInputs    Raw amounts of bAssets to use in mint\r\n     * @param _config       Generalised invariantConfig stored externally\r\n     * @return mintAmount   Quantity of mAssets minted\r\n     */\r\n    function computeMintMulti(\r\n        BassetData[] calldata _bAssets,\r\n        uint8[] calldata _indices,\r\n        uint256[] calldata _rawInputs,\r\n        InvariantConfig memory _config\r\n    ) external view override returns (uint256 mintAmount) {\r\n        // 1. Get raw reserves\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        // 2. Get value of reserves according to invariant\r\n        uint256 k0 = _invariant(x, sum, _config.a);\r\n\r\n        // 3. Add deposits to x and sum\r\n        uint256 len = _indices.length;\r\n        uint8 idx;\r\n        uint256 scaledInput;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            idx = _indices[i];\r\n            scaledInput = (_rawInputs[i] * _bAssets[idx].ratio) / 1e8;\r\n            x[idx] += scaledInput;\r\n            sum += scaledInput;\r\n        }\r\n        // 4. Finalise mint\r\n        require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\r\n        mintAmount = _computeMintOutput(x, sum, k0, _config.a);\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the amount of bAsset received for swapping\r\n     * `quantity` amount of index `input_idx` to index `output_idx`.\r\n     * @param _bAssets      Array of all bAsset Data\r\n     * @param _i            Index of bAsset to swap IN\r\n     * @param _o            Index of bAsset to swap OUT\r\n     * @param _rawInput     Raw amounts of input bAsset to input\r\n     * @param _feeRate      Swap fee rate to apply to output\r\n     * @param _config       Generalised invariantConfig stored externally\r\n     * @return bAssetOutputQuantity   Raw bAsset output quantity\r\n     * @return scaledSwapFee          Swap fee collected, in mAsset terms\r\n     */\r\n    function computeSwap(\r\n        BassetData[] calldata _bAssets,\r\n        uint8 _i,\r\n        uint8 _o,\r\n        uint256 _rawInput,\r\n        uint256 _feeRate,\r\n        InvariantConfig memory _config\r\n    ) external view override returns (uint256 bAssetOutputQuantity, uint256 scaledSwapFee) {\r\n        // 1. Get raw reserves\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        // 2. Get value of reserves according to invariant\r\n        uint256 k0 = _invariant(x, sum, _config.a);\r\n        // 3. Add deposits to x and sum\r\n        uint256 scaledInput = (_rawInput * _bAssets[_i].ratio) / 1e8;\r\n        x[_i] += scaledInput;\r\n        sum += scaledInput;\r\n        // 4. Calc total mAsset q\r\n        uint256 k1 = _invariant(x, sum, _config.a);\r\n        scaledSwapFee = ((k1 - k0) * _feeRate) / 1e18;\r\n        // 5. Calc output bAsset\r\n        uint256 newOutputReserve = _solveInvariant(x, _config.a, _o, k0 + scaledSwapFee);\r\n        uint256 output = x[_o] - newOutputReserve - 1;\r\n        bAssetOutputQuantity = (output * 1e8) / _bAssets[_o].ratio;\r\n        // 6. Check for bounds\r\n        x[_o] -= output;\r\n        sum -= output;\r\n        require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the amount of bAsset index `i` received for\r\n     * redeeming `quantity` amount of mAsset.\r\n     * @param _bAssets              Array of all bAsset Data\r\n     * @param _o                    Index of output bAsset\r\n     * @param _netMassetQuantity    Net amount of mAsset to redeem\r\n     * @param _config               Generalised invariantConfig stored externally\r\n     * @return rawOutputUnits       Raw bAsset output returned\r\n     */\r\n    function computeRedeem(\r\n        BassetData[] calldata _bAssets,\r\n        uint8 _o,\r\n        uint256 _netMassetQuantity,\r\n        InvariantConfig memory _config\r\n    ) external view override returns (uint256 rawOutputUnits) {\r\n        // 1. Get raw reserves\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        // 2. Get value of reserves according to invariant\r\n        uint256 k0 = _invariant(x, sum, _config.a);\r\n        // 3. Compute bAsset output\r\n        uint256 newOutputReserve = _solveInvariant(x, _config.a, _o, k0 - _netMassetQuantity);\r\n        uint256 output = x[_o] - newOutputReserve - 1;\r\n        rawOutputUnits = (output * 1e8) / _bAssets[_o].ratio;\r\n        // 4. Check for max weight\r\n        x[_o] -= output;\r\n        sum -= output;\r\n        require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the amount of mAsset required to redeem\r\n     * a given selection of bAssets.\r\n     * @param _bAssets          Array of all bAsset Data\r\n     * @param _indices          Indexes of output bAssets\r\n     * @param _rawOutputs       Desired raw bAsset outputs\r\n     * @param _config           Generalised invariantConfig stored externally\r\n     * @return totalmAssets     Amount of mAsset required to redeem bAssets\r\n     */\r\n    function computeRedeemExact(\r\n        BassetData[] calldata _bAssets,\r\n        uint8[] calldata _indices,\r\n        uint256[] calldata _rawOutputs,\r\n        InvariantConfig memory _config\r\n    ) external view override returns (uint256 totalmAssets) {\r\n        // 1. Get raw reserves\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        // 2. Get value of reserves according to invariant\r\n        uint256 k0 = _invariant(x, sum, _config.a);\r\n        // 3. Sub deposits from x and sum\r\n        uint256 len = _indices.length;\r\n        uint256 ratioed;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            ratioed = (_rawOutputs[i] * _bAssets[_indices[i]].ratio) / 1e8;\r\n            x[_indices[i]] -= ratioed;\r\n            sum -= ratioed;\r\n        }\r\n        require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\r\n        // 4. Get new value of reserves according to invariant\r\n        uint256 k1 = _invariant(x, sum, _config.a);\r\n        // 5. Total mAsset is the difference between values\r\n        totalmAssets = k0 - k1;\r\n    }\r\n\r\n    /***************************************\r\n                    INTERNAL\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Computes the actual mint output after adding mint inputs\r\n     * to the vault balances.\r\n     * @param _x            Scaled vaultBalances\r\n     * @param _sum          Sum of vaultBalances, to avoid another loop\r\n     * @param _k            Previous value of invariant, k, before addition\r\n     * @param _a                Precise amplification coefficient\r\n     * @return mintAmount   Amount of value added to invariant, in mAsset terms\r\n     */\r\n    function _computeMintOutput(\r\n        uint256[] memory _x,\r\n        uint256 _sum,\r\n        uint256 _k,\r\n        uint256 _a\r\n    ) internal view returns (uint256 mintAmount) {\r\n        // 1. Get value of reserves according to invariant\r\n        uint256 kFinal = _invariant(_x, _sum, _a);\r\n        // 2. Total minted is the difference between values\r\n        mintAmount = kFinal - _k;\r\n    }\r\n\r\n    /**\r\n     * @dev Simply scaled raw reserve values and returns the sum\r\n     * @param _bAssets  All bAssets\r\n     * @return x        Scaled vault balances\r\n     * @return sum      Sum of scaled vault balances\r\n     */\r\n    function _getReserves(BassetData[] memory _bAssets)\r\n        internal\r\n        pure\r\n        returns (uint256[] memory x, uint256 sum)\r\n    {\r\n        uint256 len = _bAssets.length;\r\n        x = new uint256[](len);\r\n        uint256 r;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            BassetData memory bAsset = _bAssets[i];\r\n            r = (bAsset.vaultBalance * bAsset.ratio) / 1e8;\r\n            x[i] = r;\r\n            sum += r;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks that no bAsset reserves exceed max weight\r\n     * @param _x            Scaled bAsset reserves\r\n     * @param _sum          Sum of x, precomputed\r\n     * @param _limits       Config object containing max and min weights\r\n     * @return inBounds     Bool, true if all assets are within bounds\r\n     */\r\n    function _inBounds(\r\n        uint256[] memory _x,\r\n        uint256 _sum,\r\n        WeightLimits memory _limits\r\n    ) internal pure returns (bool inBounds) {\r\n        uint256 len = _x.length;\r\n        inBounds = true;\r\n        uint256 w;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            w = (_x[i] * 1e18) / _sum;\r\n            if (w > _limits.max || w < _limits.min) return false;\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                    INVARIANT\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Compute the invariant f(x) for a given array of supplies `x`.\r\n     * @param _x        Scaled vault balances\r\n     * @param _sum      Sum of scaled vault balances\r\n     * @param _a        Precise amplification coefficient\r\n     * @return k        Cumulative value of all assets according to the invariant\r\n     */\r\n    function _invariant(\r\n        uint256[] memory _x,\r\n        uint256 _sum,\r\n        uint256 _a\r\n    ) internal pure returns (uint256 k) {\r\n        uint256 len = _x.length;\r\n\r\n        if (_sum == 0) return 0;\r\n\r\n        uint256 nA = _a * len;\r\n        uint256 kPrev;\r\n        k = _sum;\r\n\r\n        for (uint256 i = 0; i < 256; i++) {\r\n            uint256 kP = k;\r\n            for (uint256 j = 0; j < len; j++) {\r\n                kP = (kP * k) / (_x[j] * len);\r\n            }\r\n            kPrev = k;\r\n            k =\r\n                (((nA * _sum) / A_PRECISION + (kP * len)) * k) /\r\n                (((nA - A_PRECISION) * k) / A_PRECISION + ((len + 1) * kP));\r\n            if (_hasConverged(k, kPrev)) {\r\n                return k;\r\n            }\r\n        }\r\n\r\n        revert(\"Invariant did not converge\");\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a given solution has converged within a factor of 1\r\n     * @param _k              Current solution k\r\n     * @param _kPrev          Previous iteration solution\r\n     * @return hasConverged   Bool, true if diff abs(k, kPrev) <= 1\r\n     */\r\n    function _hasConverged(uint256 _k, uint256 _kPrev) internal pure returns (bool) {\r\n        if (_kPrev > _k) {\r\n            return (_kPrev - _k) <= 1;\r\n        } else {\r\n            return (_k - _kPrev) <= 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Solves the invariant for _i with respect to target K, given an array of reserves.\r\n     * @param _x        Scaled reserve balances\r\n     * @param _a        Precise amplification coefficient\r\n     * @param _idx      Index of asset for which to solve\r\n     * @param _targetK  Target invariant value K\r\n     * @return y        New reserve of _i\r\n     */\r\n    function _solveInvariant(\r\n        uint256[] memory _x,\r\n        uint256 _a,\r\n        uint8 _idx,\r\n        uint256 _targetK\r\n    ) internal pure returns (uint256 y) {\r\n        uint256 len = _x.length;\r\n        require(_idx >= 0 && _idx < len, \"Invalid index\");\r\n\r\n        (uint256 sum_, uint256 nA, uint256 kP) = (0, _a * len, _targetK);\r\n\r\n        for (uint256 i = 0; i < len; i++) {\r\n            if (i != _idx) {\r\n                sum_ += _x[i];\r\n                kP = (kP * _targetK) / (_x[i] * len);\r\n            }\r\n        }\r\n\r\n        uint256 c = (((kP * _targetK) * A_PRECISION) / nA) / len;\r\n        uint256 g = (_targetK * (nA - A_PRECISION)) / nA;\r\n        uint256 b = 0;\r\n\r\n        if (g > sum_) {\r\n            b = g - sum_;\r\n            y = (Root.sqrt((b**2) + (4 * c)) + b) / 2 + 1;\r\n        } else {\r\n            b = sum_ - g;\r\n            y = (Root.sqrt((b**2) + (4 * c)) - b) / 2 + 1;\r\n        }\r\n\r\n        if (y < 1e8) revert(\"Invalid solution\");\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct MassetStructs.BassetData[]\",\"name\":\"_bAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8\",\"name\":\"_i\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_rawInput\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct MassetStructs.WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct MassetStructs.InvariantConfig\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"computeMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct MassetStructs.BassetData[]\",\"name\":\"_bAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_indices\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_rawInputs\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct MassetStructs.WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct MassetStructs.InvariantConfig\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"computeMintMulti\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct MassetStructs.BassetData[]\",\"name\":\"_bAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8\",\"name\":\"_o\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_netMassetQuantity\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct MassetStructs.WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct MassetStructs.InvariantConfig\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"computeRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rawOutputUnits\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct MassetStructs.BassetData[]\",\"name\":\"_bAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_indices\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_rawOutputs\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct MassetStructs.WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct MassetStructs.InvariantConfig\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"computeRedeemExact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalmAssets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct MassetStructs.BassetData[]\",\"name\":\"_bAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8\",\"name\":\"_i\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_o\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_rawInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeRate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct MassetStructs.WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct MassetStructs.InvariantConfig\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"computeSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bAssetOutputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scaledSwapFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"InvariantValidator","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5c3973dae807eec13292413c3d44fc0b8818dc15938b44d2926ca8c62336a48e"}]}